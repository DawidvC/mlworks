head	1.20;
access;
symbols
	MLW_daveb_inline_1_4_99:1.20.1
	MLWorks_21c0_1999_03_25:1.20
	MLWorks_20c1_1998_08_20:1.19
	MLWorks_20c0_1998_08_04:1.19
	MLWorks_20b2c2_1998_06_19:1.19
	MLWorks_20b2_Windows_1998_06_12:1.19
	MLWorks_20b1c1_1998_05_07:1.19
	MLWorks_20b0_1998_04_07:1.18
	MLWorks_20b0_1998_03_20:1.18
	MLWorks_20m2_1998_02_16:1.16
	MLWorks_MM_adapt:1.16.3
	MLWorks_20m1_1997_10_23:1.16
	MLWorks_11r1:1.14.5.1.1.1.1
	MLWorks_workspace_97:1.16.2
	MLWorks_dt_wizard:1.16.1
	MLWorks_11c0_1997_09_09:1.14.5.1.1.1
	MLWorks_10r3:1.14.5.1.3
	MLWorks_10r2_551:1.14.5.1.2
	MLWorks_11:1.14.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.14.5.1
	MLWorks_20m0_1997_06_20:1.16
	MLWorks_1_0_r2c2_1997_06_14:1.14.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.14.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.14.5
	MLWorks_BugFix_1997_04_24:1.14
	MLWorks_1_0_r2_Win32_1997_04_11:1.14
	MLWorks_1_0_r2_Unix_1997_04_04:1.14
	MM_ML_release_korma_1997_04_01:1.14
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.14.3.1.1
	MLWorks_gui_1996_12_18:1.14.4
	MLWorks_1_0_Win32_1996_12_17:1.14.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.13.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.13.1.2
	JFHrts:1.14.2
	MLWorks_1_0_Irix_1996_11_28:1.13.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.14.1
	MLWorks_1_0_Unix_1996_11_14:1.13.1
	MLWorks_Open_Beta2_1996_10_11:1.11.3
	MLWorks_License_dev:1.11.2
	MLWorks_1_open_beta_1996_09_13:1.11.1
	MLWorks_Open_Beta_1996_08_22:1.11
	MLWorks_Beta_1996_07_02:1.11
	MLWorks_Beta_1996_06_07:1.11
	MLWorks_Beta_1996_06_06:1.11
	MLWorks_Beta_1996_06_05:1.11
	MLWorks_Beta_1996_06_03:1.11
	MLWorks_Beta_1996_05_31:1.11
	MLWorks_Beta_1996_05_30:1.11
	hope_poo:1.3.1
	ML_beta_release_12/08/94:1.3.1.1
	ML_beta_release_03/08/94:1.3;
locks; strict;
comment	@ * @;


1.20
date	98.09.17.15.22.04;	author jont;	state Exp;
branches
	1.20.1.1;
next	1.19;

1.19
date	98.04.24.10.32.05;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	98.03.18.11.16.50;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	98.03.03.14.22.52;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	97.06.03.16.27.04;	author jont;	state Exp;
branches
	1.16.1.1
	1.16.2.1
	1.16.3.1;
next	1.15;

1.15
date	97.05.30.10.43.52;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	96.11.15.15.17.42;	author jont;	state Exp;
branches
	1.14.1.1
	1.14.2.1
	1.14.3.1
	1.14.4.1
	1.14.5.1;
next	1.13;

1.13
date	96.11.07.17.23.35;	author stephenb;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	96.11.05.12.25.22;	author stephenb;	state Exp;
branches;
next	1.11;

1.11
date	96.02.14.17.28.21;	author jont;	state Exp;
branches
	1.11.1.1
	1.11.2.1
	1.11.3.1;
next	1.10;

1.10
date	96.02.12.15.59.13;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	96.01.11.17.24.46;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.11.21.14.44.42;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	95.05.30.10.16.57;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.03.29.14.30.28;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	95.03.07.17.28.17;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.03.01.10.37.14;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	94.06.21.15.58.40;	author nickh;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	94.06.09.14.30.53;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.10.55.28;	author nickh;	state Exp;
branches;
next	;

1.3.1.1
date	95.07.05.10.30.27;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	96.09.13.11.23.28;	author hope;	state Exp;
branches;
next	;

1.11.2.1
date	96.10.07.16.13.39;	author hope;	state Exp;
branches;
next	;

1.11.3.1
date	96.10.17.11.33.05;	author hope;	state Exp;
branches;
next	;

1.13.1.1
date	96.11.14.12.58.51;	author hope;	state Exp;
branches
	1.13.1.1.1.1;
next	1.13.1.2;

1.13.1.2
date	96.12.05.17.42.45;	author jont;	state Exp;
branches;
next	;

1.13.1.1.1.1
date	96.11.28.15.08.49;	author hope;	state Exp;
branches;
next	;

1.14.1.1
date	96.11.22.18.16.32;	author hope;	state Exp;
branches;
next	;

1.14.2.1
date	96.12.17.10.03.17;	author hope;	state Exp;
branches;
next	;

1.14.3.1
date	96.12.17.17.54.55;	author hope;	state Exp;
branches
	1.14.3.1.1.1;
next	;

1.14.3.1.1.1
date	97.02.24.11.46.02;	author hope;	state Exp;
branches;
next	;

1.14.4.1
date	96.12.18.09.49.30;	author hope;	state Exp;
branches;
next	;

1.14.5.1
date	97.05.12.10.41.54;	author hope;	state Exp;
branches
	1.14.5.1.1.1
	1.14.5.1.2.1
	1.14.5.1.3.1;
next	;

1.14.5.1.1.1
date	97.07.28.18.25.20;	author daveb;	state Exp;
branches
	1.14.5.1.1.1.1.1;
next	;

1.14.5.1.1.1.1.1
date	97.10.07.11.51.13;	author jkbrook;	state Exp;
branches;
next	;

1.14.5.1.2.1
date	97.09.08.17.18.34;	author daveb;	state Exp;
branches;
next	;

1.14.5.1.3.1
date	97.09.09.14.14.44;	author daveb;	state Exp;
branches;
next	;

1.16.1.1
date	97.09.10.19.31.25;	author brucem;	state Exp;
branches;
next	;

1.16.2.1
date	97.09.11.21.00.53;	author daveb;	state Exp;
branches;
next	;

1.16.3.1
date	97.10.31.13.43.55;	author nickb;	state Exp;
branches;
next	;

1.20.1.1
date	99.04.01.18.00.49;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.20
log
@[Bug #20124]
Use validate_address in is_ml_heap/is_ml_stack
@
text
@/*  === SPARC STACK ROUTINES ===
 *
 *  Copyright (C) 1994 Harlequin Ltd
 *
 *  Description
 *  -----------
 * All architecture-dependent routines that deal with the stack.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:arch:SPARC:stacks.c,v $
 * Revision 1.19  1998/04/24  10:32:05  jont
 * [Bug #70034]
 * TYPE_STACK has become TYPE_ML_STACK
 *
 * Revision 1.18  1998/03/18  11:16:50  jont
 * [Bug #70026]
 * Allow profiling of stub_c functions, recording the time according
 * to the name of the runtime system functions
 *
 * Revision 1.17  1998/03/03  14:22:52  jont
 * [Bug #70018]
 * Allow explorer to search stack for heap values
 *
 * Revision 1.16  1997/06/03  16:27:04  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
 * Revision 1.15  1997/05/30  10:43:52  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
 * Revision 1.14  1996/11/15  15:17:42  jont
 * [Bug #1781]
 * Remove the assertion until we know what it should be doing.
 *
 * Revision 1.13  1996/11/07  17:23:35  stephenb
 * [Bug #1461]
 * Must not construct fake frames for non-leaf functions, as
 * they do not contain values which the GC and the debugger expect
 * them to. This can lead to fatal failure of either the GC or
 * the debugger (e.g. indexing down from an fp which does not
 * point to the top of a genuine stack frame).
 *
 * Revision 1.12  1996/11/05  12:25:22  stephenb
 * [Bug #1441]
 * frame_next: change the offset to be a byte rather than word
 * offset since instructions are not word aligned on an I386 and
 * so the debugger has been changed to expect byte offsets.
 *
 * Revision 1.11  1996/02/14  17:28:21  jont
 * ISPTR becomes MLVALISPTR
 *
 * Revision 1.10  1996/02/12  15:59:13  nickb
 * Add heap-exploration hooks.
 *
 * Revision 1.9  1996/01/11  17:24:46  nickb
 * Runtime error message buffer problem.
 *
 * Revision 1.8  1995/11/21  14:44:42  jont
 * Add debugger call to get pointer into frame for accessing reals
 *
 * Revision 1.7  1995/05/30  10:16:57  nickb
 * Add frame_argument function.
 *
 * Revision 1.6  1995/03/29  14:30:28  nickb
 * Threads system.
 *
 * Revision 1.5  1995/03/07  17:28:17  matthew
 * Adding is_top_frame ML function
 *
 * Revision 1.4  1995/03/01  10:37:14  matthew
 * Adding flush_windows to current
 *
 * Revision 1.3  1994/06/21  15:58:40  nickh
 * New ancillary structure.
 *
 * Revision 1.2  1994/06/09  14:30:53  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:55:28  nickh
 * new file
 *
 *
 */

#include <assert.h>		/* assert */
#include "mltypes.h"
#include "diagnostic.h"
#include "values.h"
#include "stacks.h"
#include "arena.h"
#include "mem.h"
#include "fixup.h"
#include "environment.h"
#include "state.h"
#include "interface.h"
#include "utils.h"
#include "allocator.h"
#include "ansi.h"
#include "tags.h"
#include "explore.h"
#include "ml_utilities.h"

/* First the GC stack-crawling code.
 *
 *  NOTE: 1. This code is highly SPARC-specific
 *        2. Register windows need to have been flushed before entry
 *
 *  This function fixes the stack contents between GC_SP and the
 *  first frame pointer since entry to ML.  fix() is called on any
 *  GC values, and link registers (return addresses) are shifted to
 *  correspond with any movement of code.
 *
 *  On entry GC_SP should point the last save area that needs to be fixed.
 *  This area contains the link register which points into the innermost
 *  executing ML function, i.e., the last link that needs fixing.
 *
 *  The obvious one-pass version of this will not work because a
 *  closure may be referred to by more than one frame.  If the closure
 *  is fixed the first time it is seen then information is lost and
 *  later link registers will not be fixed.
 *
 *  The number of non-GC spills in each frame is fetched from the
 *  first word of the code vector.
 */

extern void stack_crawl_phase_one(void)
{
  struct thread_state *thread;
  struct stack_frame *sp;

  flush_windows();
  DIAGNOSTIC(4, "stack_crawl first pass", 0, 0);

  for (thread= TOP_THREAD.next; thread != &TOP_THREAD; thread = thread->next) {
    DIAGNOSTIC(4,"  thread %d",thread->number, 0);
    /* turn each ML link slot into an offset from the closure code address */
    for(sp = GC_SP(thread); sp != NULL; sp = sp->fp) {
      if(TYPE(sp->fp) == TYPE_ML_STACK) { /* it's a GCable frame */
	if (SPACE_TYPE(sp->lr) == TYPE_FROM) { /* make the link relative */
	  struct stack_frame *fp = sp->fp;
	  mlval codeptr = FIELD(fp->closure, 0);
	  DIAGNOSTIC(5, "  frame 0x%X  next 0x%X", sp, fp);
	  DIAGNOSTIC(5, "    lr 0x%X from `%s'", sp->lr,
		     CSTRING(CCODENAME(codeptr)));
	  if (sp->lr && pc_in_closure(sp->lr, fp->closure)) {
	    sp->lr -= codeptr;			 /* NB: no longer aligned */
	  }
	  DIAGNOSTIC(5, "    lr is 0x%X+0x%X", codeptr, sp->lr);
	} 
      }
    }
  }
}

extern mlval *stack_crawl_phase_two(mlval *to)
{
  struct thread_state *thread;
  struct stack_frame *sp;
    
  DIAGNOSTIC(4, "stack_crawl(to = 0x%X):", to, 0);
  DIAGNOSTIC(4, " second pass", 0, 0);

  /* Now fix everything on the stacks, restoring the link slots as we go */

  for (thread= TOP_THREAD.next; thread != &TOP_THREAD; thread = thread->next) {
    DIAGNOSTIC(4,"  thread %d",thread->number, 0);
    for(sp = GC_SP(thread); sp != NULL; sp = sp->fp) {
      struct stack_frame *fp = sp->fp;
      if (TYPE(sp->fp) == TYPE_ML_STACK) {
	DIAGNOSTIC(5, "  frame 0x%X (to = 0x%X)", sp, to);
	
	if(MLVALISPTR(fp->closure)) {
	  mlval *top, closure, code;
	  fix(to, &fp->closure);		/* fix the caller's closure */
	  closure = fp->closure;
	  fix(to, &FIELD(closure, 0));	/* fix the caller's code vector */
	  code = FIELD(closure, 0);
	  
	  /* if the link address is unaligned, it must be restored: */
	  if(word_align(sp->lr) != sp->lr) {
	    DIAGNOSTIC(5, "    lr is 0x%X+0x%X", code, sp->lr);
	    sp->lr += code;    
	    DIAGNOSTIC(5, "    fixed to 0x%X", sp->lr, 0);
	  }
	  
	  top = (mlval *)fp->fp - CCODENONGC(code);
	  scan((mlval *)(sp->fp+1), top, to); /* fix stack allocated area */
		  /* (sp->fp+1 is the top of the struct stack_frame) */
	}
	/* Now fix the register slots */
	fix_reg(to, &sp->l0); fix_reg(to, &sp->l1); fix_reg(to, &sp->l2);
	fix_reg(to, &sp->l3); fix_reg(to, &sp->l4); fix_reg(to, &sp->l5);
	fix_reg(to, &sp->l6); fix_reg(to, &sp->l7);
	
	fix_reg(to, &sp->i0); fix_reg(to, &sp->closure); fix_reg(to, &sp->i2);
	fix_reg(to, &sp->i3); fix_reg(to, &sp->i4); fix_reg(to, &sp->i5);
      }
    }
  }
  return(to);
}

#ifdef EXPLORER

/* The explorer needs to find any potential roots on the stacks. */

extern void explore_stacks(void)
{
  struct thread_state *thread;
  struct stack_frame *sp;

  flush_windows();
  for (thread= TOP_THREAD.next; thread != &TOP_THREAD; thread = thread->next) {
    for(sp = GC_SP(thread); sp != NULL; sp = sp->fp) {
      struct stack_frame *fp = sp->fp;
      if (TYPE(sp->fp) == TYPE_ML_STACK) {
	if(MLVALISPTR(fp->closure)) {	/* there may be stack allocation */
	  mlval *top, code;
	  code = FIELD(fp->closure, 0);
	  top = (mlval *)fp->fp - CCODENONGC(code);
	  explore_stack_allocated(thread, fp, (mlval *)(fp+1), top); 
		  /* fp+1 is the top of the struct stack_frame */
	}
	explore_stack_registers(thread, sp, &sp->l0, &sp->i5);
      }
    }
  }
}

#endif

/* Stack backtrace */

static const char *code_vector_name(word closure)
{
  if (validate_ml_address(&(FIELD(closure, 0)))) {
    word code = FIELD(closure, 0);
    if (validate_ml_address((void *)code) && validate_ml_address((void *)(OBJECT(code)))) {
      if (validate_ml_address(&(CCODEANCILLARY(code))) &&
	  validate_ml_address(&(CCODEANCRECORD(code, NAMES))) &&
	  validate_ml_address(&(CCODEANCVALUE(code, NAMES))) &&
	  validate_ml_address(CSTRING(CCODENAME(code)))) {
	return CSTRING(CCODENAME(code));
      } else {	
	return "invalid code ancillary";
      }
    } else {
      return "invalid code pointer";
    }
  } else {
    return "invalid closure";
  }
}

int max_backtrace_depth = 50;

void backtrace(struct stack_frame *sp, struct thread_state *thread,
	       int depth_max)
{
  message_content("Stack backtrace\n");
  if (sp == NULL)
    message_content("  No stack!\n");
  else if ((word)sp == thread->ml_state.stack_top)
    message_content("  %p empty stack.\n",sp);
  if (validate_address(&sp->closure)) {
    if (!is_ml_stack(sp)) {
      message_content("  %p closure 0x%08X\n", sp, sp->closure);
      if (validate_address(&sp->fp)) sp = sp->fp;
    }
  } else {
    message_content("  %p cannot read closure address %p\n", sp, &sp->closure);
    if (validate_address(&sp->fp)) sp = sp->fp;
  }
  while(depth_max-- && sp) {
    if(is_ml_stack(sp)) {
      if (validate_address(&sp->closure)) {
	const char *name =
	  MLVALISPTR(sp->closure) ? code_vector_name(sp->closure) :
	  sp->closure == STACK_START ? "stack start" :
	  sp->closure == STACK_DISTURB_EVENT ? "disturb event" :
	  sp->closure == STACK_EXTENSION ? "stack extension" :
	  sp->closure == STACK_RAISE ? "raise" :
	  sp->closure == STACK_EVENT ? "asynchronous event handler" :
	  sp->closure == STACK_C_RAISE ? "raise from C" :
	  sp->closure == STACK_C_CALL ? "call to C" :
	  sp->closure == STACK_INTERCEPT ? "intercept" :
	  sp->closure == STACK_SPACE_PROFILE ? "space profile" : "special";
	message_content("  %p closure 0x%08X: ", sp, sp->closure);
	message_string(name);
	message_string("\n");
      } else {
	message_content("  %p cannot read closure address %p\n",
			sp, &sp->closure);
	break;
      }
    }
    if (validate_address(&sp->fp)) {
      sp = sp->fp;
    } else {
      break;
    }
  }
  if (sp == NULL || (word)sp == thread->ml_state.stack_top)
    message_content("--- base of stack --- \n");
  else if (depth_max > 0 && !validate_address(&sp->fp)) {
    /* Not at top of stack, but address invalid */
    message_content("  %p cannot read frame address %p\n", sp, &sp->fp);
  }
}

/* A SPARC stack frame contains ML values iff its frame pointer points
 * into an ML stack area. */

mlval is_ml_frame(struct stack_frame *sp)
{
  mlval closure = sp->closure;

  if(ISORDPTR(closure) && validate_ml_address((void *)closure)) {
    mlval secondary = SECONDARY(GETHEADER(closure));
    if(secondary == RECORD || secondary == 0) {
      mlval code = FIELD(closure, 0);
      if(validate_ml_address((void *)code) && PRIMARY(code) == POINTER &&
	 SECONDARY(GETHEADER(code)) == BACKPTR)
	return(code);
    }
  }
  return(MLUNIT);
}

/* Pervasive stack functions */

/* These first few are not SPARC-specific, assuming we have an fp, the
 * stack is full descending, &c */

static mlval ml_is_ml_frame (mlval frame)
{
  if (is_ml_frame ((struct stack_frame *)frame) == MLUNIT)
    return MLFALSE;
  else
    return MLTRUE;
}

static mlval ml_is_top_frame (mlval frame)
{
  struct stack_frame *sp = (struct stack_frame *)frame;
  if (sp->fp == NULL)
    return MLTRUE;
  else
    return MLFALSE;
}

static mlval flush(mlval arg)
{
  flush_windows();		/* I assume this is a nop on non-SPARCs */
  return(MLUNIT);
}

/* This returns the frame of the ML function calling it */

static mlval current(mlval arg)
{
  flush_windows();
  return((mlval)(GC_SP(CURRENT_THREAD)->fp));
}

static mlval sub(mlval arg)
{
  struct stack_frame *sp = (struct stack_frame *)FIELD(arg, 0);
  int index = CINT(FIELD(arg, 1));

  flush_windows();
  return(((mlval *)sp)[index]);
}

static mlval update(mlval arg)
{
  ((mlval *)FIELD(arg, 0))[CINT(FIELD(arg, 1))] = FIELD(arg, 2);
  return(MLUNIT);
}

static mlval frame_call(mlval argument)
{
  flush_windows();

  return(callml((mlval)GC_SP(CURRENT_THREAD), argument));
}

static mlval frame_offset(mlval argument)
{
  struct stack_frame *sp = (struct stack_frame *)FIELD(argument, 0);
  int index = CINT(FIELD(argument, 1));
  return(*((mlval *)(((int)(sp->fp))+index)));
}

static mlval frame_double(mlval argument)
{
  struct stack_frame *sp = (struct stack_frame *)FIELD(argument, 0);
  int index = CINT(FIELD(argument, 1)); /* This is a pointer to an unboxed double */
  mlval real = allocate_real();
  char *ptr = (char *)(((int)(sp->fp))+index);
  memcpy (((char *)real)+(8-POINTER), ptr, 8); /* Copy into double from stack */
  return (real);
}

/* Now these are SPARC-specific */

static mlval frame_next(mlval arg)
{
  mlval result;
  struct stack_frame *sp = (struct stack_frame *)arg;

  flush_windows();

  result = allocate_record(3);

  while(sp->fp != NULL)
  {
    mlval code= is_ml_frame(sp->fp);
    if(code != MLUNIT) {
      word code_start_addr= (word)CCODESTART(code);
      word call_addr= sp->lr;
      word call_offset= call_addr - code_start_addr;
/* Temporarily removed until we know what it should do with STACK_RAISE frames
      assert(code_start_addr < call_addr);
*/
      FIELD(result, 0) = MLTRUE;
      FIELD(result, 1) = (mlval)sp->fp;
      FIELD(result, 2) = MLINT(call_offset);
      return(result);
    } else {
      FIELD(result,0) = MLTRUE;
      FIELD(result, 1) = (mlval)sp->fp;
      FIELD(result,2) = MLINT(0);
      return(result);
    }

    sp = sp->fp;
  }

  /* No frames on the stack! */

  FIELD(result, 0) = MLFALSE;
  FIELD(result, 1) = MLUNIT;
  FIELD(result, 2) = MLINT(0);

  return(result);
}

static mlval frame_argument(mlval frame)
{
  struct stack_frame *sp = (struct stack_frame *) frame;
  return (sp->i0);
}

static mlval frame_allocations(mlval frame)
{
  struct stack_frame *sp = (struct stack_frame *)frame;

  if (((int)sp) < 0)
    return(MLFALSE);
    
  switch(((int)(sp->fp))-((int)(sp))-64)
    {
      case 0 : 
	{
	  return(MLFALSE);
	}
      default :
	{
	  return(MLTRUE);
	}
    }
}

void stacks_init()
{
  env_function("stack flush", flush);
  env_function("stack frame sub", sub);
  env_function("stack frame update", update);
  env_function("stack frame current", current);
  env_function("stack is ml frame", ml_is_ml_frame);
  env_function("stack is top frame", ml_is_top_frame);
  env_function("debugger frame call", frame_call);
  env_function("debugger frame next", frame_next);
  env_function("debugger frame sub", sub);
  env_function("debugger frame offset", frame_offset);
  env_function("debugger frame double", frame_double);
  env_function("debugger frame argument", frame_argument);
  env_function("debugger frame allocations", frame_allocations);
}
@


1.20.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 * Revision 1.20  1998/09/17  15:22:04  jont
 * [Bug #20124]
 * Use validate_address in is_ml_heap/is_ml_stack
 *
@


1.19
log
@[Bug #70034]
TYPE_STACK has become TYPE_ML_STACK
@
text
@d12 4
d236 21
d267 36
a302 19
  message_content("  %p closure 0x%08X\n", sp, sp->closure);

  while(depth_max-- && sp->fp) {
    struct stack_frame *fp = sp->fp;
    if(is_ml_stack(fp)) {
      const char *name =
	MLVALISPTR(fp->closure) ? CSTRING(CCODENAME(FIELD(fp->closure, 0))) :
	  fp->closure == STACK_START ? "stack start" :
	  fp->closure == STACK_DISTURB_EVENT ? "disturb event" :
	  fp->closure == STACK_EXTENSION ? "stack extension" :
	  fp->closure == STACK_RAISE ? "raise" :
	  fp->closure == STACK_EVENT ? "asynchronous event handler" :
	  fp->closure == STACK_C_RAISE ? "raise from C" :
	  fp->closure == STACK_C_CALL ? "call to C" :
	  fp->closure == STACK_INTERCEPT ? "intercept" :
	  fp->closure == STACK_SPACE_PROFILE ? "space profile" : "special";
      message_content("  %p closure 0x%08X: ", fp, fp->closure);
      message_string(name);
      message_string("\n");
d304 6
a309 2

    sp = sp->fp;
d320 1
a320 2
  if(is_ml_stack(sp->fp) && ISORDPTR(closure))
  {
d322 5
a326 14

    if(secondary == RECORD || secondary == 0)
    {
      mlval *object = OBJECT(closure);

      if(is_ml_heap(object) || is_ml_stack(object))
      {
	mlval code = FIELD(closure, 0);

	if((is_ml_heap(OBJECT(code)) || code == stub_c) && PRIMARY(code) == POINTER &&
	   (SECONDARY(GETHEADER(code)) == CODE ||
	    SECONDARY(GETHEADER(code)) == BACKPTR))
	  return(code);
      }
a328 1

@


1.18
log
@[Bug #70026]
Allow profiling of stub_c functions, recording the time according
to the name of the runtime system functions
@
text
@d12 5
d136 1
a136 1
      if(TYPE(sp->fp) == TYPE_STACK) { /* it's a GCable frame */
d167 1
a167 1
      if (TYPE(sp->fp) == TYPE_STACK) {
d214 1
a214 1
      if (TYPE(sp->fp) == TYPE_STACK) {
@


1.17
log
@[Bug #70018]
Allow explorer to search stack for heap values
@
text
@d12 4
d281 1
a281 1
	if(is_ml_heap(OBJECT(code)) && PRIMARY(code) == POINTER &&
@


1.16
log
@[Bug #30076]
Modify to make NONGC spills be counted in words
@
text
@d12 4
d90 1
d115 1
a115 1
extern mlval *stack_crawl(mlval *to)
a119 1
  DIAGNOSTIC(4, "stack_crawl(to = 0x%X):", to, 0);
d121 1
a121 1
  DIAGNOSTIC(4, " first pass", 0, 0);
d134 3
a136 1
	  sp->lr -= codeptr;			 /* NB: no longer aligned */
d142 6
d149 1
@


1.16.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a11 4
 * Revision 1.16  1997/06/03  16:27:04  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
@


1.16.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 4
 * Revision 1.16  1997/06/03  16:27:04  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
@


1.16.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 4
 * Revision 1.16  1997/06/03  16:27:04  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
@


1.15
log
@[Bug #30076]
Modifications to allow stack based parameter passing on the I386
@
text
@d12 4
d162 1
a162 1
	  top = (mlval *)fp->fp - (CCODENONGC(code)/sizeof(mlval));
d196 1
a196 1
	  top = (mlval *)fp->fp - (CCODENONGC(code)/sizeof(mlval));
@


1.14
log
@[Bug #1781]
Remove the assertion until we know what it should be doing.
@
text
@d12 4
d158 1
a158 1
	  top = (mlval *)fp->fp - (CCODESPILLS(code)/sizeof(mlval));
d192 1
a192 1
	  top = (mlval *)fp->fp - (CCODESPILLS(code)/sizeof(mlval));
@


1.14.5.1
log
@branched from 1.14
@
text
@a11 4
 * Revision 1.14  1996/11/15  15:17:42  jont
 * [Bug #1781]
 * Remove the assertion until we know what it should be doing.
 *
@


1.14.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 * Revision 1.14.5.1  1997/05/12  10:41:54  hope
 * branched from 1.14
 *
@


1.14.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 * Revision 1.14.5.1  1997/05/12  10:41:54  hope
 * branched from 1.14
 *
@


1.14.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 * Revision 1.14.5.1  1997/05/12  10:41:54  hope
 * branched from 1.14
 *
@


1.14.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 3
 * Revision 1.14.5.1.1.1  1997/07/28  18:25:20  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.14.4.1
log
@branched from 1.14
@
text
@a11 4
 * Revision 1.14  1996/11/15  15:17:42  jont
 * [Bug #1781]
 * Remove the assertion until we know what it should be doing.
 *
@


1.14.3.1
log
@branched from 1.14
@
text
@a11 4
 * Revision 1.14  1996/11/15  15:17:42  jont
 * [Bug #1781]
 * Remove the assertion until we know what it should be doing.
 *
@


1.14.3.1.1.1
log
@branched from 1.14.3.1
@
text
@a11 3
 * Revision 1.14.3.1  1996/12/17  17:54:55  hope
 * branched from 1.14
 *
@


1.14.2.1
log
@branched from 1.14
@
text
@a11 4
 * Revision 1.14  1996/11/15  15:17:42  jont
 * [Bug #1781]
 * Remove the assertion until we know what it should be doing.
 *
@


1.14.1.1
log
@branched from 1.14
@
text
@a11 4
 * Revision 1.14  1996/11/15  15:17:42  jont
 * [Bug #1781]
 * Remove the assertion until we know what it should be doing.
 *
@


1.13
log
@[Bug #1461]
Must not construct fake frames for non-leaf functions, as
they do not contain values which the GC and the debugger expect
them to. This can lead to fatal failure of either the GC or
the debugger (e.g. indexing down from an fp which does not
point to the top of a genuine stack frame).
@
text
@d12 8
d360 1
d362 1
@


1.13.1.1
log
@branched from 1.13
@
text
@a11 8
 * Revision 1.13  1996/11/07  17:23:35  stephenb
 * [Bug #1461]
 * Must not construct fake frames for non-leaf functions, as
 * they do not contain values which the GC and the debugger expect
 * them to. This can lead to fatal failure of either the GC or
 * the debugger (e.g. indexing down from an fp which does not
 * point to the top of a genuine stack frame).
 *
@


1.13.1.2
log
@Merge in changes from version 1.14
@
text
@a11 3
 * Revision 1.13.1.1  1996/11/14  12:58:51  hope
 * branched from 1.13
 *
a359 1
/* Temporarily removed until we know what it should do with STACK_RAISE frames
a360 1
*/
@


1.13.1.1.1.1
log
@branched from 1.13.1.1
@
text
@a11 3
 * Revision 1.13.1.1  1996/11/14  12:58:51  hope
 * branched from 1.13
 *
@


1.12
log
@[Bug #1441]
frame_next: change the offset to be a byte rather than word
offset since instructions are not word aligned on an I386 and
so the debugger has been changed to expect byte offsets.
@
text
@d12 6
d106 11
a116 9
    for(sp = GC_SP(thread); sp != NULL; sp = sp->fp)
      if(TYPE(sp->fp) == TYPE_STACK && SPACE_TYPE(sp->lr) == TYPE_FROM) {
	struct stack_frame *fp = sp->fp;
	mlval codeptr = FIELD(fp->closure, 0);
	DIAGNOSTIC(5, "  frame 0x%X  next 0x%X", sp, fp);
	DIAGNOSTIC(5, "    lr 0x%X from `%s'", sp->lr,
		   CSTRING(CCODENAME(codeptr)));
	sp->lr -= codeptr;			 /* NB: no longer aligned */
	DIAGNOSTIC(5, "    lr is 0x%X+0x%X", FIELD(fp->closure, 0), sp->lr);
d118 1
d211 9
a219 11
	fp->closure == STACK_EXTENSION ? "stack extension" :
	fp->closure == STACK_LEAF_RAISE ? "leaf raise" :
	fp->closure == STACK_RAISE ? "raise" :
	fp->closure == STACK_RESUME ? "resume" :
	fp->closure == STACK_PROFILE ? "profiler" :
	fp->closure == STACK_EVENT ? "asynchronous event handler" :
	fp->closure == STACK_C_RAISE ? "raise from C" : 
	fp->closure == STACK_C_CALL ? "call to C" :
	fp->closure == STACK_START ? "ML stack start" :
        fp->closure == STACK_INTERCEPT ? "intercept" : "special";

@


1.11
log
@ISPTR becomes MLVALISPTR
@
text
@d12 3
d48 1
d340 1
a340 3
    mlval code;

    code = is_ml_frame(sp->fp);
d342 4
d348 1
a348 2
      FIELD(result, 2) = MLINT((word *)sp->lr - CCODESTART(code));

a353 1
	
@


1.11.3.1
log
@branched from 1.11
@
text
@a11 3
 * Revision 1.11  1996/02/14  17:28:21  jont
 * ISPTR becomes MLVALISPTR
 *
@


1.11.2.1
log
@branched from 1.11
@
text
@a11 3
 * Revision 1.11  1996/02/14  17:28:21  jont
 * ISPTR becomes MLVALISPTR
 *
@


1.11.1.1
log
@branched from 1.11
@
text
@a11 3
 * Revision 1.11  1996/02/14  17:28:21  jont
 * ISPTR becomes MLVALISPTR
 *
@


1.10
log
@Add heap-exploration hooks.
@
text
@d12 3
d119 1
a119 1
	if(ISPTR(fp->closure)) {
d164 1
a164 1
	if(ISPTR(fp->closure)) {	/* there may be stack allocation */
d197 1
a197 1
	ISPTR(fp->closure) ? CSTRING(CCODENAME(FIELD(fp->closure, 0))) :
@


1.9
log
@Runtime error message buffer problem.
@
text
@d12 3
d56 1
d146 29
@


1.8
log
@Add debugger call to get pointer into frame for accessing reals
@
text
@d12 3
d173 3
a175 1
      message_content("  %p closure 0x%08X: %s\n", fp, fp->closure, name);
@


1.7
log
@Add frame_argument function.
@
text
@d12 3
d49 1
d272 10
d362 1
@


1.6
log
@Threads system.
@
text
@d12 3
d310 6
d348 1
@


1.5
log
@Adding is_top_frame ML function
@
text
@d12 3
d69 2
a70 1
  struct stack_frame *sp = GC_SP;
d76 15
a90 14
  /* turn each ML link slot into an offset from the closure code address */
  for(sp = GC_SP; sp != NULL; sp = sp->fp)
    if(TYPE(sp->fp) == TYPE_STACK && SPACE_TYPE(sp->lr) == TYPE_FROM) {
      struct stack_frame *fp = sp->fp;

      DIAGNOSTIC(5, "  frame 0x%X  next 0x%X", sp, fp);
      DIAGNOSTIC(5, "    lr 0x%X from `%s'", sp->lr,
		 CSTRING(CCODENAME(FIELD(fp->closure, 0))));
      
      sp->lr -= FIELD(fp->closure, 0); /* NB: no longer aligned */

      DIAGNOSTIC(5, "    lr is 0x%X+0x%X", FIELD(fp->closure, 0), sp->lr);
    }

d93 1
a93 1
  /* Now fix everything on the stack, restoring the link slots as we go */
d95 24
a118 18
  for(sp = GC_SP; sp != NULL; sp = sp->fp)
  {
    struct stack_frame *fp = sp->fp;
    if (TYPE(sp->fp) == TYPE_STACK) {
      DIAGNOSTIC(5, "  frame 0x%X (to = 0x%X)", sp, to);

      if(ISPTR(fp->closure)) {
	mlval *top, closure, code;
	fix(to, &fp->closure);		/* fix the caller's closure */
	closure = fp->closure;
	fix(to, &FIELD(closure, 0));	/* fix the caller's code vector */
	code = FIELD(closure, 0);

	/* if the link address is unaligned, it must be restored: */
	if(word_align(sp->lr) != sp->lr) {
	  DIAGNOSTIC(5, "    lr is 0x%X+0x%X", code, sp->lr);
	  sp->lr += code;    
	  DIAGNOSTIC(5, "    fixed to 0x%X", sp->lr, 0);
d120 7
a126 4

	top = (mlval *)fp->fp - (CCODESPILLS(code)/sizeof(mlval));
	scan((mlval *)(sp->fp+1), top, to); /* fix the stack allocated area */
			/* sp->fp+1 is the top of the struct stack_frame */
a127 7
      /* Now fix the register slots */
      fix_reg(to, &sp->l0); fix_reg(to, &sp->l1); fix_reg(to, &sp->l2);
      fix_reg(to, &sp->l3); fix_reg(to, &sp->l4); fix_reg(to, &sp->l5);
      fix_reg(to, &sp->l6); fix_reg(to, &sp->l7);

      fix_reg(to, &sp->i0); fix_reg(to, &sp->closure); fix_reg(to, &sp->i2);
      fix_reg(to, &sp->i3); fix_reg(to, &sp->i4); fix_reg(to, &sp->i5);
d135 1
a135 1
int max_backtrace_depth = 500;
d137 2
a138 1
void backtrace(FILE *stream, struct stack_frame *sp, int depth_max)
d140 6
a145 2
  fprintf(stream, "Stack backtrace\n");
  fprintf(stream, "  %p closure 0x%08X\n", sp, sp->closure);
d147 1
a147 2
  while(depth_max-- && sp->fp)
  {
d149 1
a149 3

    if(is_ml_stack(fp))
    {
d163 1
a163 1
      fprintf(stream, "  %p closure 0x%08X: %s\n", fp, fp->closure, name);
d190 2
a191 1
	   (SECONDARY(GETHEADER(code)) == CODE || SECONDARY(GETHEADER(code)) == BACKPTR))
d200 5
d207 4
a210 1
  return (is_ml_frame ((struct stack_frame *)frame) == MLUNIT ? MLFALSE : MLTRUE);
d216 2
a217 3
  
  if (sp->fp == 0)
    return (MLTRUE);
d219 1
a219 1
    return (MLFALSE);
a221 5
/* Pervasive stack functions */

/* These first few are not SPARC-specific, assuming we have an fp, the
 * stack is full descending, &c */

d228 2
a229 2
/* This returns the frame of the function calling the relevant pervasive function */
/* (I think) */
d233 1
a233 1
  return((mlval)ml_state.sp->fp);
d238 3
d242 1
a242 7

  {
    struct stack_frame *sp = (struct stack_frame *)FIELD(arg, 0);
    int index = CINT(FIELD(arg, 1));

    return(((mlval *)sp)[index]);
  }
d254 2
a255 1
  return(callml((mlval)ml_state.sp, argument));
@


1.4
log
@Adding flush_windows to current
@
text
@d12 3
d195 9
d324 1
@


1.3
log
@New ancillary structure.
@
text
@d12 3
d125 1
a125 1
int max_backtrace_depth = 25;
d187 6
d204 2
d208 1
d214 5
a218 2
  struct stack_frame *sp = (struct stack_frame *)FIELD(arg, 0);
  int index = CINT(FIELD(arg, 1));
d220 2
a221 1
  return(((mlval *)sp)[index]);
a232 1

d311 1
@


1.3.1.1
log
@branched from 1.3
@
text
@a11 3
 * Revision 1.3  1994/06/21  15:58:40  nickh
 * New ancillary structure.
 *
@


1.2
log
@new file
@
text
@d12 3
d104 1
a104 1
	top = (mlval *)fp->fp - CINT(CCODESPILLS(code))/sizeof(mlval);
@


1.1
log
@new file
@
text
@d11 4
a14 1
 *  $Log:$
@
