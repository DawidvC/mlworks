head	1.28;
access;
symbols
	MLW_daveb_inline_1_4_99:1.28.1
	MLWorks_21c0_1999_03_25:1.28
	MLWorks_20c1_1998_08_20:1.27
	MLWorks_20c0_1998_08_04:1.27
	MLWorks_20b2c2_1998_06_19:1.27
	MLWorks_20b2_Windows_1998_06_12:1.27
	MLWorks_20b1c1_1998_05_07:1.26
	MLWorks_20b0_1998_04_07:1.26
	MLWorks_20b0_1998_03_20:1.26
	MLWorks_20m2_1998_02_16:1.26
	MLWorks_MM_adapt:1.26.3
	MLWorks_20m1_1997_10_23:1.26
	MLWorks_11r1:1.25.1.1.1.1.1
	MLWorks_workspace_97:1.26.2
	MLWorks_dt_wizard:1.26.1
	MLWorks_11c0_1997_09_09:1.25.1.1.1.1
	MLWorks_10r3:1.25.1.1.3
	MLWorks_10r2_551:1.25.1.1.2
	MLWorks_11:1.25.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.25.1.1
	MLWorks_20m0_1997_06_20:1.25
	MLWorks_1_0_r2c2_1997_06_14:1.25.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.25.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.25.1
	MLWorks_BugFix_1997_04_24:1.25
	MLWorks_1_0_r2_Win32_1997_04_11:1.25
	MLWorks_1_0_r2_Unix_1997_04_04:1.25
	MM_ML_release_korma_1997_04_01:1.25
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.24.4.1.1
	MLWorks_gui_1996_12_18:1.24.5
	MLWorks_1_0_Win32_1996_12_17:1.24.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.24.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.24.1.1
	JFHrts:1.24.3
	MLWorks_1_0_Irix_1996_11_28:1.24.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.24.2
	MLWorks_1_0_Unix_1996_11_14:1.24.1
	MLWorks_Open_Beta2_1996_10_11:1.21.3
	MLWorks_License_dev:1.21.2
	MLWorks_1_open_beta_1996_09_13:1.21.1
	MLWorks_Open_Beta_1996_08_22:1.21
	MLWorks_Beta_1996_07_02:1.21
	MLWorks_Beta_1996_06_07:1.21
	MLWorks_Beta_1996_06_06:1.21
	MLWorks_Beta_1996_06_05:1.21
	MLWorks_Beta_1996_06_03:1.21
	MLWorks_Beta_1996_05_31:1.21
	MLWorks_Beta_1996_05_30:1.21
	hope_poo:1.7.1
	ML_beta_release_12/08/94:1.7.1.1
	ML_beta_release_03/08/94:1.7;
locks; strict;
comment	@ * @;


1.28
date	98.10.30.17.18.15;	author jont;	state Exp;
branches
	1.28.1.1;
next	1.27;

1.27
date	98.05.20.14.01.25;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	97.07.15.15.36.52;	author daveb;	state Exp;
branches
	1.26.1.1
	1.26.2.1
	1.26.3.1;
next	1.25;

1.25
date	97.02.06.11.41.51;	author nickb;	state Exp;
branches
	1.25.1.1;
next	1.24;

1.24
date	96.11.07.17.51.52;	author stephenb;	state Exp;
branches
	1.24.1.1
	1.24.2.1
	1.24.3.1
	1.24.4.1
	1.24.5.1;
next	1.23;

1.23
date	96.11.01.12.04.12;	author nickb;	state Exp;
branches;
next	1.22;

1.22
date	96.10.31.17.20.47;	author nickb;	state Exp;
branches;
next	1.21;

1.21
date	95.11.13.12.31.59;	author nickb;	state Exp;
branches
	1.21.1.1
	1.21.2.1
	1.21.3.1;
next	1.20;

1.20
date	95.09.06.15.34.22;	author nickb;	state Exp;
branches;
next	1.19;

1.19
date	95.07.26.08.28.30;	author nickb;	state Exp;
branches;
next	1.18;

1.18
date	95.07.25.11.27.41;	author nickb;	state Exp;
branches;
next	1.17;

1.17
date	95.07.05.14.45.01;	author nickb;	state Exp;
branches;
next	1.16;

1.16
date	95.06.14.14.29.03;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	95.06.02.10.42.25;	author nickb;	state Exp;
branches;
next	1.14;

1.14
date	95.03.28.15.13.05;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	95.02.23.15.01.15;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	94.10.27.23.05.49;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	94.10.19.11.59.41;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	94.09.15.11.53.40;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	94.09.05.12.20.36;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	94.08.25.09.41.16;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	94.07.22.16.21.24;	author nickh;	state Exp;
branches
	1.7.1.1;
next	1.6;

1.6
date	94.07.06.13.31.35;	author nickh;	state Exp;
branches;
next	1.5;

1.5
date	94.07.01.10.39.59;	author nickh;	state Exp;
branches;
next	1.4;

1.4
date	94.06.21.15.58.21;	author nickh;	state Exp;
branches;
next	1.3;

1.3
date	94.06.15.16.16.56;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.30.02;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.10.54.32;	author nickh;	state Exp;
branches;
next	;

1.7.1.1
date	95.07.05.10.29.28;	author hope;	state Exp;
branches;
next	;

1.21.1.1
date	96.09.13.11.24.44;	author hope;	state Exp;
branches;
next	;

1.21.2.1
date	96.10.07.16.15.04;	author hope;	state Exp;
branches;
next	;

1.21.3.1
date	96.10.17.11.34.30;	author hope;	state Exp;
branches;
next	;

1.24.1.1
date	96.11.14.13.00.09;	author hope;	state Exp;
branches
	1.24.1.1.1.1;
next	;

1.24.1.1.1.1
date	96.11.28.15.10.12;	author hope;	state Exp;
branches;
next	;

1.24.2.1
date	96.11.22.18.17.58;	author hope;	state Exp;
branches;
next	;

1.24.3.1
date	96.12.17.10.04.40;	author hope;	state Exp;
branches;
next	;

1.24.4.1
date	96.12.17.17.56.17;	author hope;	state Exp;
branches
	1.24.4.1.1.1;
next	;

1.24.4.1.1.1
date	97.02.24.11.47.52;	author hope;	state Exp;
branches;
next	1.24.4.1.1.2;

1.24.4.1.1.2
date	97.02.24.14.23.37;	author jont;	state Exp;
branches;
next	;

1.24.5.1
date	96.12.18.09.50.56;	author hope;	state Exp;
branches;
next	;

1.25.1.1
date	97.05.12.10.44.35;	author hope;	state Exp;
branches
	1.25.1.1.1.1
	1.25.1.1.2.1
	1.25.1.1.3.1;
next	;

1.25.1.1.1.1
date	97.07.28.18.27.31;	author daveb;	state Exp;
branches
	1.25.1.1.1.1.1.1;
next	;

1.25.1.1.1.1.1.1
date	97.10.07.11.53.32;	author jkbrook;	state Exp;
branches;
next	;

1.25.1.1.2.1
date	97.09.08.17.20.36;	author daveb;	state Exp;
branches;
next	;

1.25.1.1.3.1
date	97.09.09.14.16.43;	author daveb;	state Exp;
branches;
next	;

1.26.1.1
date	97.09.10.19.34.49;	author brucem;	state Exp;
branches;
next	;

1.26.2.1
date	97.09.11.21.03.41;	author daveb;	state Exp;
branches;
next	;

1.26.3.1
date	97.10.31.13.46.36;	author nickb;	state Exp;
branches;
next	;

1.28.1.1
date	99.04.01.18.02.42;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.28
log
@[Bug #70226]
Remove raise_count and stack_extension_count (gone to mlw_start.c)
@
text
@/*
 * ==== ML TO C INTERFACING CODE ====
 *		SPARC
 *
 * Copyright (C) 1991 Harlequin Ltd
 *
 * Description
 * -----------
 * This code does the job of managing the calls between ML and C.  The ML
 * and C states are stored in C structures declared in `state.c'.
 *
 * Notes
 * -----
 * This code uses some predefined macros as parameters.  These are
 * defined (or not) in the Makefile.  They are as follows:
 *
 *   COLLECT_STATS: If defined the routines will update various
 *                  counters defined in callc_codes.c when called.
 *
 * This file must be run through both CPP and the m4 macro processor to
 * produce an assembler file. 
 *
 * Revision Log
 * ------------
 * $Log: src:arch:SPARC:interface.S,v $
 * Revision 1.27  1998/05/20  14:01:25  jont
 * [Bug #70035]
 * Add stub_code_start and stub_code_end variables
 * for use in address validation
 *
 * Revision 1.26  1997/07/15  15:36:52  daveb
 * [Bug #30200]
 * Set in_ML in c_raise.
 *
 * Revision 1.25  1997/02/06  11:41:51  nickb
 * The ST_CLEAN_WINDOWS trap semantics are subtly different on UltraSPARCs. The
 * effect is that the registers which are current at the time of the trap may
 * reappear in a later register window. So whenever we invoke it, we have to
 * ensure that the current registers (ins, locals, and outs) are GC-safe.
 *
 * Revision 1.24  1996/11/07  17:51:52  stephenb
 * [Bug #1461]
 * Must not construct fake frames for non-leaf functions, as
 * they do not contain values which the GC and the debugger expect
 * them to. This can lead to fatal failure of either the GC or
 * the debugger (e.g. indexing down from an fp which does not
 * point to the top of a genuine stack frame).
 *
 * Revision 1.23  1996/11/01  12:04:12  nickb
 * When restoring the stack limit after return from a stack
 * extension, we should OR in the interrupt slot. By mistake,
 * we are ORing in the stack limit slot, which will have no
 * effect. This relatively harmless bug discovered when looking
 * for a much more serious one.
 *
 * Revision 1.21  1995/11/13  12:31:59  nickb
 * Move CURRENT_THREAD manipulation out of asm into portable C.
 *
 * Revision 1.20  1995/09/06  15:34:22  nickb
 * Change to c_sp protocol.
 *
 * Revision 1.19  1995/07/26  08:28:30  nickb
 * Bug in leaf handler raise.
 *
 * Revision 1.18  1995/07/25  11:27:41  nickb
 * Reuse stack frame on leaf handler raise.
 *
 * Revision 1.17  1995/07/05  14:45:01  nickb
 * Add space profiling code.
 *
 * Revision 1.16  1995/06/14  14:29:03  jont
 * Move to new method of preserving current handler frame when applying handler
 *
 * Revision 1.15  1995/06/02  10:42:25  nickb
 * Replace set_stack_underflow with more general code.
 *
 * Revision 1.14  1995/03/28  15:13:05  nickb
 * Add threads system.
 *
 * Revision 1.13  1995/02/23  15:01:15  matthew
 * Clear lr for intercept frame
 *
 * Revision 1.12  1994/10/27  23:05:49  jont
 * Change offsets in handler records to be ml integers
 *
 * Revision 1.11  1994/10/19  11:59:41  jont
 * Fix handler unwinding
 *
 * Revision 1.10  1994/09/15  11:53:40  jont
 * Reduce handler frame size to four words
 * by leaving out fp
 *
 * Revision 1.9  1994/09/05  12:20:36  nickb
 * Preserve o7 (link register) over non-leaf GC entry.
 *
 * Revision 1.8  1994/08/25  09:41:16  matthew
 * Change stack extension entry to free up O registers.
 *
 * Revision 1.7  1994/07/22  16:21:24  nickh
 * Add routines to get us into GC from a trap handler and back again.
 * (see gc_trap_entry, gc_trap_entry_leaf, &c).
 *
 * Revision 1.6  1994/07/06  13:31:35  nickh
 * Asm and C name prefixes differ according to OS.
 *
 * Revision 1.5  1994/07/01  10:39:59  nickh
 * Add debugger trap.
 *
 * Revision 1.4  1994/06/21  15:58:21  nickh
 * New ancillary layout.
 *
 * Revision 1.3  1994/06/15  16:16:56  jont
 * Put non ML return values in o7 when marking STACK_EVENT frames
 *
 * Revision 1.2  1994/06/09  14:30:02  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:54:32  nickh
 * new file
 *
 * Revision 1.79  1994/03/15  12:54:48  nickh
 * Fix intercept comments.
 *
 * Revision 1.78  1994/03/10  14:23:20  jont
 * Changes to handler records following LEO opcode
 *
 * Revision 1.77  1993/11/17  17:05:41  jont
 * Added the missing fields for stubs and rearranged the others into the right order
 *
 * Revision 1.76  1993/11/17  16:20:07  jont
 * Changed the header words on the strings 'stub to C' and 'stub to assembler'
 * so the value printer can understand them.
 *
 * Revision 1.75  1993/11/05  14:56:16  jont
 * Added check_event entries for leaf and non-leaf.
 *
 * Revision 1.74  1993/10/12  10:29:21  matthew
 * Fixed problem in extend_stack where g6 was getting set regardless of whether a signal had
 * been handled.
 *
 * Revision 1.73  1993/08/24  15:51:57  richard
 * Missing +8 offset on return from ml_intercept_leaf.
 *
 * Revision 1.72  1993/08/17  12:11:13  jont
 * Modified _c_raise to discard the c stack before raising its exception
 *
 * Revision 1.71  1993/06/22  11:15:56  richard
 * Marked intercept frames with STACK_INTERCEPT.  See tags.h.
 *
 * Revision 1.70  1993/06/01  14:59:00  richard
 * The interception code had some strange ideas about stack frames
 * which were confusing the garbage collector.  This goes back to the
 * time when interception was always done by overwriting the three nops
 * at the start of the code vector.
 *
 * Revision 1.69  1993/05/05  14:44:16  jont
 * Modified stack unwind code to use fp instead of sp to fix problems
 * with multiple handlers at the same stack level
 *
 * Revision 1.68  1993/04/30  15:47:08  jont
 * Changed to distinguish the real base of the stack from the stack limit pointer
 *
 * Revision 1.67  1993/04/30  12:37:57  jont
 * Made stub_asm a tail
 * Redid ml_raise to stack away current handler at top of stack rather
 * than using an unchecked save. Made ml_raise_leaf do a stack overflow
 * check before opening the stack to save current handler
 *
 * Revision 1.66  1993/04/22  16:44:18  jont
 * Added leaf raise code
 *
 * Revision 1.65  1993/04/20  13:54:25  richard
 * Ripped out old tracing mechanism and installed a new one.
 *
 * Revision 1.64  1993/04/16  14:49:15  jont
 * ml_raise no longers restores the handler chain, this is now done by the ml code
 *
 * Revision 1.63  1993/03/18  10:30:15  jont
 * Fixed some minor problems with the names of the stubs
 *
 * Revision 1.62  1993/02/26  17:52:55  jont
 * Now initialises all unused registers before calling ml.
 * This may have been a source of bad values
 *
 * Revision 1.61  1993/02/10  17:48:48  jont
 * Changes for code vector reform.
 *
 * Revision 1.60  1992/12/08  11:23:21  clive
 * Changed the type of nop used for tracing to store it being moved
 * by the scheduler
 *
 * Revision 1.59  1992/11/11  16:45:48  clive
 * Added some function needed for tracing
 *
 * Revision 1.58  1992/11/05  17:58:40  richard
 * Removed debugger related stuff and replaced it with a more general
 * event handling mechanism.
 *
 * Revision 1.57  1992/09/15  11:24:49  clive
 * Added a save of floating point registers to leaf_gc
 *
 * Revision 1.56  1992/09/09  15:16:20  clive
 * The assembler stub needed to be double-word aligned
 *
 * Revision 1.55  1992/09/02  12:13:59  clive
 * A bug in the disturbance code in the region of ext0 fixed
 *
 * Revision 1.54  1992/08/18  09:01:27  clive
 * Single-stepping wasn't working around calls to C
 *
 * Revision 1.53  1992/08/11  15:37:20  clive
 * Fixed the single-step code
 *
 * Revision 1.52  1992/08/10  13:06:43  richard
 * Added floating point reservation around calls to C and the garbage collector.
 *
 * Revision 1.51  1992/08/07  13:52:48  clive
 * Changed the functionality of some of the debugger functions - added support
 * for tracing
 *
 * Revision 1.50  1992/08/03  08:25:04  richard
 * The C and assembler calling stubs are now single static code vectors.
 * Fixed unwind_stack() for resumable exceptions.
 * Added ml_trap.
 *
 * Revision 1.49  1992/07/30  17:16:45  clive
 * Some changes to the single step hook, which now passes the 'current' function
 * to the hook
 *
 * Revision 1.48  1992/07/30  17:08:37  richard
 * Took the call counting out of the stubs until I can fix it.
 *
 * Revision 1.47  1992/07/29  14:10:59  clive
 * Changes to single-step and calling of debugger now we can callml from C - so
 * errors ironed out
 *
 * Revision 1.46  1992/07/27  14:04:05  richard
 * Implemented callasm stub and c_raise.
 *
 * Revision 1.45  1992/07/22  13:39:05  clive
 * Took out ml_profile
 *
 * Revision 1.44  1992/07/21  15:31:46  richard
 * Removed redundent `flush' instructions, and implemented a
 * _flush_windows routine which can be called from C instead.
 * Moved the unwind stack macro to macros.m4s.  Altered the
 * C calling stub slightly.
 *
 * Revision 1.43  1992/07/16  16:22:29  richard
 * Implemented re-entrant ML using stack bases.
 *
 * Revision 1.42  1992/07/16  15:53:44  clive
 * Did some work on single-stepping, and corrected some bugs in
 * the interrupt handling code
 *
 * Revision 1.41  1992/07/16  10:34:20  richard
 * Added a new way of calling C, although it isn't used yet.
 *
 * Revision 1.40  1992/07/14  15:27:06  richard
 * Removed obsolete memory profiling code and profiler entry point.
 * Changed calls to GC to include the closure of the caller.
 *
 * Revision 1.39  1992/07/09  14:39:53  clive
 * Removed call debugger - now written in ML plus C
 *
 * Revision 1.38  1992/07/08  15:09:55  clive
 * Added code for manually calling the debugger
 *
 * Revision 1.37  1992/07/03  14:40:10  richard
 * Generalised the idea of a `disturbance' and changed the way that
 * interrupts are generated and handled.
 *
 * Revision 1.36  1992/06/25  14:12:05  richard
 * Added a missing stack frame in the stack extension code.
 *
 * Revision 1.35  1992/06/23  12:59:02  richard
 * Altered stack extension return code to pop out of the stack
 * block it deallocates in case it gets unmapped.
 *
 * Revision 1.34  1992/06/22  14:55:36  clive
 * More work on the debugger
 *
 * Revision 1.33  1992/06/18  11:47:51  richard
 * Changed the way that stack extension frames are marked.  Also merged
 * in some of Clive's top level handler code.
 *
 * Revision 1.32  1992/06/17  14:37:46  richard
 * Added _ml_gc_leaf entry point.
 *
 * Revision 1.31  1992/06/11  11:08:14  clive
 * First attempt at converting a user ^C into an ML interrupt Interrupt
 * Also, entry from toplevel into the ML debugger hook function
 * Code need neatening ...
 *
 * Revision 1.30  1992/05/22  11:01:15  clive
 * ml_raise was winding back too many frames at a stack extension -
 * it wound back two before testing for the required frame
 *
 * Revision 1.29  1992/05/21  16:01:51  richard
 * Changed statistics collection to use the scratch register
 * to avoid confusion.
 *
 * Revision 1.28  1992/05/15  10:29:32  clive
 * Memory profiling result in bytes - to get tagging automatically
 *
 * Revision 1.27  1992/05/14  11:37:57  clive
 * Added memory profiling
 *
 * Revision 1.26  1992/04/15  10:25:47  richard
 * Converted to use the m4 macro processor and renamed to interface.m4s.
 * Added Clive's profiler stub.
 * Moved polymorphic equality code to a separate file.
 *
 * Revision 1.26  1992/04/14  16:06:13  richard
 * Converted to use m4 macro processor and renamed to interface.m4s.
 * Added Clive's code for profiling.
 *
 * Revision 1.24  1992/04/03  10:41:14  richard
 * Moved macros to a shared file.
 *
 * Revision 1.22  1992/03/26  15:21:42  richard
 * Added new statistics gathering code.  Removed definition of STATS.
 * COLLECT_STATS and TRAP_FLUSH are now defined by the Makefile so that
 * the behaviour can easily be reconfigured.
 *
 * Revision 1.21  1992/03/25  13:28:34  richard
 * Wrote an assembler version of polymorphic equality that intercepts
 * calls to the C version.  Very fast.
 *
 * Revision 1.20  1992/03/24  15:34:06  richard
 * Rewrote virtually everything again.  There are now far fewer save and
 * restore instructions and the `ml_external' routine looks up the
 * pervasive C function directly.
 *
 * Revision 1.19	 1992/03/18  12:23:58  clive
 * Added a flush windows in ML_TO_C2T in case a garbage collection occurs
 * whilst we are inside the C (in which case we expect the registers on the
 * stack )
 *
 * Revision 1.18	 1992/02/24  10:17:21  clive
 * ML_TO_C2 and like functions were causing one extra C-stack to be allocated
 * per ML call to C - changed them to use SAVE_C_STATE_WITHOUT_SP which saves
 * the C state but doesn't save away a new sp - this was the easiest fix to the
 * problem... C cannot now be used as a coroutine as the stack is reset to where
 * it started out
 *
 * Revision 1.17	 1992/01/20  16:48:42  richard
 * Revised some of the raise code.
 * Added a macro to call C with a window flush trap in the right place
 * for the garbage collector.
 *
 * Revision 1.16	 1992/01/15  18:18:45  richard
 * Further development of _ml_raise.
 *
 * Revision 1.15	 1992/01/14  16:26:35  richard
 * Added new exception raising code, plus other minor changes.
 *
 * Revision 1.14	 1992/01/13  11:03:44  richard
 * Used macros for C calling to simplify code for several procedures, and
 * to allow correct calls (in terms of stack frames) to the garbage collector.
 * Added ml_extend.
 *
 * Revision 1.13	 1992/01/08  14:18:17  richard
 * Rewrote almost everything to remove some redundant saves and restores.
 * Introduces the C preprocessor to allow macros.
 *
*/

#include "tags.h"
#include "offsets.h"
#include "macros.h"

/* === CALL ML FROM C ===
 *
 * callml is a C-like function which allows C to invoke an ML function in
 * the manner of a coroutine.
 *
 * The C global registers are stored in the structure c_state, and the
 * ML global state is loaded.  A new ML stack frame is allocated below
 * the base pointer of the current ML stack area (pointed to by %g6).
 * The ML function is then called.  On return the stack area base
 * pointer is restored to its value on entry, the ML state is stored
 * and the C state loaded, then control returns to C.
 *
 *
 * Parameters:
 *   %o0	 Argument for the ML function -- no multiple arg calls here.
 *   %o1	 Closure of the function to call
 *   %o7	 Link register for return to C
 * Returns:
 *   %o0	 Result of the ML function
 */

	.global C_NAME(callml)

C_NAME(callml):
	sethi	%hi(C_NAME(global_state)), %o2
	or	%o2, %lo(C_NAME(global_state)), %o2
	st	%o2, [%o2 + GLOBAL_in_ML] 	! now in ML
	ld	[%o2 + GLOBAL_current_thread], %g5 ! current thread in g5
	load_ML_state_with(%g5, %o4)
	ld	[%g5+THREAD_c_sp], %o3	! record old c_state.sp in this frame
	ld	[%g5+THREAD_ml_gc_sp], %o4 ! saved ml_state.gc_sp
	ld	[%g5+THREAD_ml_sp], %o5 ! current base of the ML stack area
	st	%sp, [%g5 + THREAD_c_sp]	! Remember C sp for calls to C
	save	%o5, -0x40, %sp		! Make first ML stack frame
	clean_current_registers
	clean_windows

	/* Ultra: l0-l7 and o2-o5 are zero, i0=arg, i1=clos, i2=global,
           i3=c_sp, i4=gc_sp, i5=ml_sp, and we're about to set o0 and o1: */

	mov	%i0, %o0
	mov	%i1, %o1		! Propagate closure and arguments
	ld	[%o1-1], %g4
	jmpl	%g4+CODE_OFFSET, %o7	! Call ML
	mov	STACK_START, %i1	! (marking start of ML stack)

/* On return from ML, i2 points to global state, i3 is the c_sp, i4 is
 * the previous ml_state.sp, i5 is the previous ml_state.base */

	mov	%o0, %i0		! Propagate result
	restore				! Get back to C stack
	store_ML_state_with(%g5)
	st	%o3, [%g5+THREAD_c_sp]  ! restore c_state.sp
	st	%o4, [%g5+THREAD_ml_gc_sp]	! restore ml_state.gc_sp
	st	%o5, [%g5+THREAD_ml_sp]! restore ml_state.sp
	st	%g0, [%o2+GLOBAL_in_ML]	! Not in ML
	retl				! Return to C
	nop

/*
 * === STUBS FROM ML ===
 *
 * These are static ML code vectors which call the routine pointed to
 * by their first closure element.  The C calling stub swaps into the C
 * state before calling the function, whereas the assembler version
 * does not.
 */

	.global	C_NAME(stub_c)
	.global	C_NAME(stub_asm)
	.global	C_NAME(stubs_code_start)
	.global	C_NAME(stubs_data_start)
	.global	C_NAME(stubs_data_end)

C_NAME(stub_c):			.word internal_stub_c+POINTER
C_NAME(stub_asm):		.word internal_stub_asm+POINTER
C_NAME(stubs_code_start):	.word stubancill
C_NAME(stubs_data_start):	.word 0
C_NAME(stubs_data_end):		.word 0

/* We have to build fake ancillary information */

	.align 	8
stubancill:				! this is a pair
	.word	stubnames + PAIRPTR
	.word	stubprofiles + PAIRPTR

	.align 8
stubnames:				! this is a pair
	.word	sc_name + POINTER
	.word	sa_name + POINTER

	.align 8
stubprofiles:				! this is a pair
	.word 0
	.word 0

	.align 	8
sc_name:
	.word	((sc_name_end - sc_name - 4) << 6) | STRING
	.asciz	'stub to C'
sc_name_end:

	.align 	8
sa_name:
	.word	((sa_name_end - sa_name - 4) << 6) | STRING
	.asciz	'stub to assembler'
sa_name_end:

	.align	8
stub_code_vector:
	.word	(((stub_code_end-stub_code_vector)-4)<<6) | CODE
	.word	stubancill + PAIRPTR

	.align 8
internal_stub_c:

	.word	(internal_stub_c - stub_code_vector) << 6 | BACKPTR
	.word	STUB_ANCILL_0		! ancillary word
	store_ML_state_with(%g5)
	ld	[%g5+THREAD_c_sp], %o5	! address of last C stack frame
	st	%sp, [%g5+THREAD_ml_sp] ! Save base of ML stack area
	save	%o5, -0x78, %sp		! Switch to C stack
	st	%sp, [%g5+THREAD_ml_gc_sp]	! Save last ML frame for GC
	ld	[%g5+THREAD_global],%i2 ! global state in i2
	std	%f0, [%sp+0x58]		! Preserve non-corrupted floats
	std	%f2, [%sp+0x60]
	std	%f6, [%sp+0x70]
	ld	[%i1+3], %o1		! address of C function to call
	mov	%i0, %o0		! propogate the argument
	jmpl	%o1, %o7		! Call the C function
	st	%g0, [%i2+GLOBAL_in_ML]	! not in ML

	st	%i2, [%i2+GLOBAL_in_ML]	! back in ML
	ld	[%i2+GLOBAL_current_thread],%g5	! current thread in g5
	mov	%o0, %i0		! Propagate the result
	ldd	[%sp+0x70], %f6
	ldd	[%sp+0x60], %f2
	ldd	[%sp+0x58], %f0
	restore				! Back to ML stack
	load_ML_state_with(%g5, %o4)

	clean_windows			! Clean dirty C windows
	ultra_clean(%o4)

	/* Ultra: we have just restored to an ML frame, so ins and
           locals are GC-safe. o0=result, o1=closure, o2=global, o5=c_sp.
           o3 is unmodified since we were in ML, so it's also GC-safe. */

	retl
	nop

	.align	8
internal_stub_asm:
	.word	(internal_stub_asm - stub_code_vector) << 6 | BACKPTR
	.word	STUB_ANCILL_1		! ancilary word
	ld	[%o1+3], %g4		! address of subroutine
	jmp	%g4			! Tail to subroutine
	nop

stub_code_end:
	.align 4
	.global	C_NAME(stubs_code_end)

C_NAME(stubs_code_end):	.word stub_code_end

/* === LOOK UP A VALUE IN THE RUNTIME ENVIRONMENT ===
 *
 * Calls directly through to env_lookup() from environment.h.
 */

	.global C_NAME(ml_lookup_pervasive)

C_NAME(ml_lookup_pervasive):
	save	%sp, -0x40, %sp
	mov	STACK_C_CALL, %i1
	mov	STACK_C_CALL, %o1
	mov	%g0, %o7		! fix return address for the GC
	mov	%i0, %o0
	ML_to_C(perv_lookup)
	mov	%o0, %i0
	ret
	restore


/*
 * These used to be called from ML when a GC was required. Now we
 * cause a trap instead, so these routines call a non-returning error
 * routine which prints the name of the calling closure instead.
 *
 * See also gc_trap_entry and gc_trap_entry_leaf, also in this file.
*/

	.global C_NAME(ml_gc)
C_NAME(ml_gc):
	call	C_NAME(ml_gc_die)
	mov	%i1, %o0

	.global C_NAME(ml_gc_leaf)
C_NAME(ml_gc_leaf):
	call	C_NAME(ml_gc_leaf_die)
	mov	%o1, %o0

/* === FLUSH REGISTER WINDOWS ===
 *
 * This routine simply invokes the window flushing trap.  It is here so
 * that C can do it neatly.
 */

	.global C_NAME(flush_windows)

C_NAME(flush_windows):
	retl
	ta ST_FLUSH_WINDOWS


/* === GET CALLER'S STACK FRAME ===
 *
 * This routine returns %fp to the caller. This is used, for instance,
 * in the signal handler, which needs to update %g6 (which is not
 * saved or restored in the sigcontext, but in the frame of the
 * _sigtramp function, which calls the handler). */

	.global C_NAME(get_callers_frame)

C_NAME(get_callers_frame):
	retl
     	mov	%fp, %o0

/*
 * === STACK OVERFLOW / ASYNCHRONOUS EVENT ===
 *
 * This code is called by ML when %sp-STACK_BUFFER < %g6 (unsigned).
 * This condition is checked by ML on function entry to ensure that
 * there is enough room for a frame, and is used by the asynchronous
 * event handler to trip up ML at a `safe' moment.
 *
 * The comments here use function names as if e called f called g, 
 * and g is the disturbed function.
 *
 * g jumps here with the following parameters:
 *
 *  %o1  closure of g
 *  %o0, %o2-%o5 arguments to g
 *  %o7  link to f
 *  %g7  minimum stack requirement of g
 *       (not including safety zone of 2kb)
 *  %g4  link to continue g
 *  %g6  current stack area or -1 for asynchronous event
 */
	.global C_NAME(ml_disturbance)

C_NAME(ml_disturbance):
	save	%sp, -0x40, %sp		/* make STACK_DISTURB_EVENT frame */
	mov	%i1, %l1		/* g's closure */
	mov	STACK_DISTURB_EVENT, %i1
	mov	%g0, %o7
	ld	[%l1-PAIRPTR],%l0
	add	%l0, CODE_OFFSET, %l0	/* code address of g */
	sub	%g4, %l0, %l0		/* offset to continue g [GC-safe] */
	ld	[%g5+IMPLICIT_stack_limit], %g4	/* true stack limit */
	sub	%sp, %g7, %o0		/* trial sp value */
	cmp	%o0, %g4		/* really extend stack? */
	bgeu	check_for_events
#ifdef COLLECT_STATS
	sethi	%hi(C_NAME(stack_extension_count)), %o0
	ld	[%o0 + %lo(C_NAME(stack_extension_count))], %o1
	add	%o1, 1, %o1
	st	%o1, [%o0 + %lo(C_NAME(stack_extension_count))]
#endif COLLECT_STATS
	sub	%g4, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
	add	%g7, STACK_BUFFER+DEFAULT_STACK_SIZE, %o1
	ML_to_C (make_ml_stack)

/* now we have to move onto the new stack block. This means resetting
 * the stack limit, unwinding the DISTURB_EVENT frame and building a
 * STACK_EXTENSION frame on the new stack block */

	ld	[%o0+4], %g7		/* top of new stack block */
	add	%o0, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
	st	%o0, [%g5+IMPLICIT_stack_limit]	/* new stack limit */
	mov	%o0, %g6
	mov	%l1, %i1		/* g's closure */
	restore	%l0, 0, %g4		/* offset to continue g */
	save	%g7, -0x40, %sp		/* first frame on new block */
	mov	%i1, %l1		/* g's closure */
	mov	%g4, %l0		/* offset to continue g */
	mov	%g0, %o7
	mov	STACK_EXTENSION, %i1

check_for_events:
	ld	[%g5+IMPLICIT_interrupt], %g4	/* has there been an event? */
	or	%g4, %g6, %g4
	cmp	%g4, %g0
	bgt	call_disturbed_fn		/* if so, ... */
	nop
	ld	[%g5+IMPLICIT_stack_limit],%g6	/* ... call ev_poll */
	st	%g0, [%g5+IMPLICIT_interrupt]
	ML_to_C (ev_poll)

call_disturbed_fn:
	mov	%l1, %o1		/* g's closure */
	mov	%i0, %o0		/* g's arguments */
	mov	%i2, %o2
	mov	%i3, %o3
	mov	%i4, %o4
	ld	[%o1-PAIRPTR], %l1
	add	%l1, CODE_OFFSET, %l1	/* g's code address [GC-safe] */
	add	%l0, %l1, %l0		/* g's continuation address */
	jmpl	%l0+8, %o7		/* continue g */
	mov	%i5, %o5		/* g's last argument */

return_from_disturbed_fn:
	cmp	%i1, STACK_EXTENSION	/* did we extend the stack? */
	bne	return_to_caller	/* if so, we have to undo it */	
	mov	%o0, %i0		/* result of g */
	restore
	save	%sp, -0x40, %sp
	ld	[%g5+IMPLICIT_stack_limit], %o0
	sub	%o0, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
	ML_to_C (unmake_ml_stack)
	add	%o0, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
	st	%o0, [%g5+IMPLICIT_stack_limit]
	mov	%o0, %g6
	ld	[%g5+IMPLICIT_interrupt], %o0
	or	%g6, %o0, %g6
return_to_caller:
	jmpl	%i7+8, %g0
	restore

/*
 * === CHECK FOR AN ML EVENT ===
 *
 * We arrive here when g6 has been detected to be -1
 *
 * All registers potentially significant
 * %o7 return address
 * %i1 function closure
 */
	.global	C_NAME(ml_event_check)
C_NAME(ml_event_check):
	save	%sp, -0x40, %sp		! Create extra frame
	ld	[%g5+IMPLICIT_stack_limit], %g6	! Restore the real stack in %g6
	st	%g0, [%g5+IMPLICIT_interrupt]	! Clear interrupt slot
	mov	STACK_EVENT, %i1
	mov	STACK_EVENT, %o1
	mov	0, %o7			! Clear link register for the GC
	ML_to_C(ev_poll)
	restore
	jmp	%o7+8			! Do the rest of the disturbed function
	nop
/*
 * %o1 function closure
 * %o7 function return address
 * %g4 return address from here
 */
	.globl	C_NAME(ml_event_check_leaf)
C_NAME(ml_event_check_leaf):
	save	%sp, -0x40, %sp		! Create a frame, so %i1 = closure
	mov	%g4, %o7		! Save return address

/* Poll code */

	save	%sp, -0x40, %sp		! Create extra frame
	ld	[%g5+IMPLICIT_stack_limit], %g6 ! Restore the real stack in %g6
	st	%g0, [%g5+IMPLICIT_interrupt]	! Clear interrupt slot
	mov	STACK_EVENT, %i1
	mov	STACK_EVENT, %o1
	mov	0, %o7			! Clear link register for the GC
	ML_to_C(ev_poll)
	restore
	jmp	%o7+8			! Do the rest of the disturbed function
	restore
	
/* === RAISE AN EXCEPTION FROM C === */
/* This is an entry point to ml_raise which may be called from C. */

	.global C_NAME(c_raise)

C_NAME(c_raise):

/*
 * We wind back the c stack explicitly to the previous ml_state.sp:
 */
	sethi	%hi(C_NAME(global_state)), %o4
	or	%o4, %lo(C_NAME(global_state)), %o4
	ld	[%o4 + GLOBAL_current_thread], %g5
	load_ML_state_with(%g5, %o4)
	ld	[%g5+THREAD_ml_gc_sp], %g4	! saved ml_state.gc_sp
	mov	%o0, %i0		! Propagate exception argument
c_raise10:
	restore				! Pop a frame
	cmp	%sp, %g4
	bne	c_raise10		! Loop until back to ml stack
	mov	%o0, %i0		! Propagate exception argument
	restore				! One more for luck (one beyond ml_state.sp)
	clean_windows

/* Ultra: we've just restored into an ML frame, so everything is GC-safe */

	mov	STACK_C_RAISE, %o1	! Mark this frame

	save	%sp, -0x40, %sp		! Make first ML stack frame below the base
	mov	%i0, %o0		! Propagate exception
        ld      [%g5+THREAD_global],%o2 ! global state in o2
        st      %o2, [%o2+GLOBAL_in_ML] ! back in ML
	! \/\/ fall through \/\/

/* 
 * === RAISE AN EXCEPTION ===
 *
 * When an exception is raised the first exception handler function on
 * the handler chain is called to deal with it.	If the handler
 * function returns then the exception was handled.  In the context of
 * the function in which the handler was created (the `creator') must
 * be restored and that function continued.  Restore instructions are
 * executed repeatedly until the current stack pointer matches the
 * pointer that was stored in the handler record.
 *
 * There are some subtleties.  The stack may be disjoint, so, after
 * crawling our way back up it the C function unwind_stack is called
 * to deallocate an extensions that are no longer required.
 *
 * Handler record format:
 *   -1	Previous handler
 *    3	Frame pointer of creator
 *    7	Handler function closure
 *   11	Offset within creator of continuation code
 *
 * Parameters:
 *   %o0	 The exception packet to raise
 *   %g3	 Exception handler record
 *
 * Warning. This code assumes that all procedures containing handler
 * continuations are non-leaf. This is currently true because setting
 * up a handler calls adr, which forces non-leaf because it corrupts o7.
 * However, should we produce a leaf adr by preserving o7 in g4, then
 * all hell will break loose.
 *
 */
	.global C_NAME(ml_raise)
	.global C_NAME(ml_raise_leaf)

C_NAME(ml_raise_leaf):
	cmp	%i1, STACK_RAISE
	beq,a	raise_skip
	mov	%o0, %i0
	
C_NAME(ml_raise):
	mov	STACK_RAISE, %o1	/* This frame's closure	*/
	save	%sp, -0x40, %sp		/* New frame */

raise_skip:
#ifdef COLLECT_STATS
	sethi	%hi(C_NAME(raise_count)), %o5
	or	%o5, %lo(C_NAME(raise_count)), %o5
	ld	[%o5], %g4		/* Increment raise count */
	add	%g4, 1, %g4		/* Using o5 is harmless */
	st	%g4, [%o5]
#endif
	mov	%g3, %l0		/* Remember current %g3 */
	ld	[%g3+7], %o1		/* Get handler closure */
	mov	%i0, %o0		/* Propagate exception packet */
	ld	[%o1-1], %g4
	jmpl	%g4+CODE_OFFSET, %o7	! The call to the handler ...
	ld	[%g3-1], %g3		! ... with previous handler restored
	mov	%l0, %g3		/* Reinstate handler */
	mov	%o0, %i0		/* Propagate exception result */
	restore				/* Throw away dummy frame */
	ld	[%g3+3], %g4		/* Load sp of creator function */
	unwind_stack(raise)		! Wind back to it, propagating result
unwound:
	ld	[%g3+11], %g4		! Fetch the continuation offset.
	srl	%g4, 2, %g4		! Convert to untagged int
	ld	[%i1-1], %o1		! Get address of creator function
	add	%g4, %o1, %g4		! Tagged address of continuation
	jmp	%g4+CODE_OFFSET
	nop

/* === CAUSE A FATAL ERROR ===
 *
 * Expects an error format string to follow the call instruction and
 * delay slot.
 */

error:	add	%o7, 8, %o0
	ML_to_C(error)
	ta	ST_BREAKPOINT


/*
 * === CODE VECTOR REPLACEMENT AND INTERCEPTION ===
 *
 *
 * When compiled for debugging, code vectors contain a sequence of
 * three nop operations which can be replaced with code to intercept or
 * replace the flow of control.  This is used to implement tracing,
 * profiling, etc.
 *
 *  ml_intercept (ml_intercept_leaf) is jumped to by the instructions
 * inserted into a code vector when it is to be intercepted (see
 * `intercept_on' below).  It calls the C function `intercept', passing
 * its parameter and closure (see intercept.c).  When `intercept'
 * returns, the intercepted function is continued.
 * 
 * The above comments hold (mutatis mutandis) for 'replace'; in that
 * case the intercepted function is abandoned.
 *
 * These four routines all live on the implicit vector.
 *
 *  Parameters:
 *    %o0	parameter } of intercepted function
 *    %o1	closure   }
 *
 * Return address is in %o7, or %g4 for leaf versions.
 *
 */
	.global	C_NAME(ml_replace)
	.global	C_NAME(ml_replace_leaf)
	.global C_NAME(ml_intercept)
	.global C_NAME(ml_intercept_leaf)

C_NAME(ml_replace):
	mov	%sp, %o0		! Pass frame to replace()
	mov	STACK_INTERCEPT, %o1	! for backtrace
	ML_to_C(replace)
	ret
	restore				! Pop callers frame

C_NAME(ml_replace_leaf):
	save	%sp, -0x40, %sp		! Dummy frame for function
	mov	%sp, %o0		! Pass frame to replace()
	mov	STACK_INTERCEPT, %o1	! for backtrace
	ML_to_C(replace)
	ret				! Return to function caller
	restore				! Throw away dummy frame

C_NAME(ml_intercept):
	save	%sp, -0x40, %sp		! Local frame
	mov	STACK_INTERCEPT, %i1	! Mark it
	mov	STACK_INTERCEPT, %o1	! for backtrace
	mov	%g0, %o7		! Clear link register for the GC
	mov	%fp, %o0		! Pass frame to intercept()
	ML_to_C(intercept)
	ret				! Return to intercepted code
	restore

C_NAME(ml_intercept_leaf):
	save	%sp, -0x40, %sp		! Dummy frame for function
	mov	%g4, %o7		! Pretend it called here
	save	%sp, -0x40, %sp		! Local frame
	mov	STACK_INTERCEPT, %i1	! Mark it
	mov	STACK_INTERCEPT, %o1	! for backtrace
	mov	%g0, %o7		! Clear link register for the GC
	mov	%fp, %o0		! Pass frame to intercept()
	ML_to_C(intercept)
	restore
	jmpl	%o7+8, %g0		! Back to caller...
	restore				! ...removing its frame

/* == Replacement code ==
 *
 * These are sections of code which are inserted at the start of a code
 * vector and altered to implement interception.  They are
 * INTERCEPT_LENGTH words long (from tags.h); three in the SPARC case.
 * 
 * There are four interception code segments; for intercepting and
 * replacing, for leaf and non-leaf functions. They call the relevant
 * bit of code above (ml_intercept_on calls ml_intercept, for
 * instance). ml_nop is the sequence of three special nops which are
 * replaced by the intercepts; they are here so we can undo
 * interception.
 */

	.global C_NAME(ml_replace_on)
	.global	C_NAME(ml_replace_on_leaf)
	.global C_NAME(ml_intercept_on)
	.global C_NAME(ml_intercept_on_leaf)
	.global C_NAME(ml_nop)

C_NAME(ml_replace_on):
	ld	[%g5+IMPLICIT_replace], %g4
	jmpl	%g4, %o7
	nop

C_NAME(ml_replace_on_leaf):
	ld	[%g5+IMPLICIT_replace_leaf], %g4
	jmpl	%g4, %g4
	nop

C_NAME(ml_intercept_on):
	ld	[%g5+IMPLICIT_intercept], %g4
	jmpl	%g4, %o7
	nop

C_NAME(ml_intercept_on_leaf):
	ld	[%g5+IMPLICIT_intercept_leaf], %g4
	jmpl	%g4, %g4
	nop

C_NAME(ml_nop):
	sethi	0, %g0		! These nops are used in mach_cg so that
	sethi	0, %g0		! the scheduler does not move them.
	sethi	0, %g0

/* This generates a debugger trap. */

	.global C_NAME(generate_debugger_trap)

C_NAME(generate_debugger_trap):
	ta	ST_BREAKPOINT
	nop

/* == GARBAGE COLLECTION ENTRY POINTS ==

 * When a garbage collection is required, we cause a trap. See
 * signals.c for the trap handler, which sets up some state on the C
 * side before 'returning' to either gc_trap_entry or
 * gc_trap_entry_leaf:

	gc_trap_return_address now contains the address to which we
		should return after the GC.

	gc_trap_ret_code points to code which tags the destination
		register and returns (see gc_trap_ret_template, below).

	gc_trap_bytes contains the number of bytes requested, or -1 if
		the number is in register g4.

 * The allocation attempt has not yet modified any registers.

 * We have to fake an entry to the portable function gc(), the
 * arguments being the number of bytes requested and the closure of
 * the calling function. On entry to gc(), ml_state.heap_start should
 * point to the current allocation point plus the number of requested
 * bytes.
 *
 * We have to be careful about the closure values in any frames which
 * we push, so as not to confuse the profiler.
 */

	.global C_NAME(gc_trap_entry)

C_NAME(gc_trap_entry):

	mov	%i1, %g1			/* save closure */
	save	%sp, -64, %sp			/* make ML stack frame */

/* get return address into i7 so the stack frame looks normal */

	mov	%i7, %l0			/* Preserve link reg in l0 */
	sethi	%hi(C_NAME(gc_trap_return_address)), %o0
	or	%o0, %lo(C_NAME(gc_trap_return_address)), %o0
	ld	[%o0],%i7

/* get number of bytes requested */

	sethi	%hi(C_NAME(gc_trap_bytes)), %o0
	or	%o0, %lo(C_NAME(gc_trap_bytes)), %o0
	ld	[%o0], %o0			/* get 'bytes requested' */
	addcc	%o0, 1, %g0			/* is it -1? */
	beq,a	got_bytes
	mov	%g4, %o0			/* if so, use %g4 instead */
got_bytes:
	add	%g2, %o0, %g2			/* add to GC_HEAP_START */

/* clean up closures so the profiler doesn't get confused */

	mov	%i1, %l1			/* preserve closure in l1 */
	mov	%g0, %i1			/* then clear it */
	mov	%g0, %o1			/* clear this one too */

	mov	%g1, %o2			/* closure for arg to gc() */
	store_ML_state_with(%g5)		/* save ML state */
	st	%sp, [%g5+THREAD_ml_gc_sp]	/* Save last ML frame for GC */
	st	%sp, [%g5+THREAD_ml_sp]		/* Save base of ML stack */
	ld	[%g5+THREAD_c_sp], %o4
	ld	[%g5+THREAD_global], %o5
	save	%o4, -216, %sp			/* Switch to C stack */
	store_fps(%sp+88)			/* save FP registers */
	mov	%i0, %o0			/* arg 0 is number of bytes */
	mov	%i2, %o1			/* arg 1 is closure */
	call	C_NAME(gc)			/* call GC ... */
	st	%g0, [%i5+GLOBAL_in_ML]		/* not in ML */

/* On exit from gc(), ml_state.heap_start and ml_state.heap_limit have
 * been updated to reflect the new creation space, and ml_state.global
 * contains the address at which bytes have been allocated. */

/* We now have a tricky sequence, split between here and
 * gc_trap_ret_template (below) (which has been copied to the data
 * segment and which is pointed to by gc_trap_ret_code) . We need to
 * enter that code with one restore still to do and with g1 and g4 set
 * in particular ways:
*/

	st	%i5, [%i5+GLOBAL_in_ML]		/* back in ML */
	ld	[%i5+GLOBAL_current_thread], %g5 /* get current thread */
	load_fps(%sp+88)
	load_ML_state_with(%g5, %o4)
	restore
	clean_windows

/* Ultra: We've just restored into the frame which we created when
 * entering gc_trap_entry. ins are the outs from ML, l2-l7 and o3 are
 * still fresh, l0=old i7, l1=old i1, o0=object size, i1=o1=0, o2=closure,
 * o4=c_sp, o5=global */

	sethi	%hi(C_NAME(gc_trap_ret_code)), %g1
	or	%g1, %lo(C_NAME(gc_trap_ret_code)), %g1
	ld	[%g1], %g1			/* code address in g1 */
	mov	%i7, %g4			/* return address in g4 */
	mov	%l1, %i1			/* restore i1 */
	jmpl	%g1, %g0
	mov	%l0, %i7			/* restore link register */

/* -------- end of gc_trap_entry ----------- */

/* Code to return to ML after a GC. Note that this code is copied into
  the data segment and the instruction at gc_trap_ret_template_overwrite
  is overwritten with a result-tagging instruction, which tags
  g1. This code is called from gc_trap_entry, above.

  We enter this code with these restored g registers

	%g7 = the restored g7 value 
	%g6 = the stack limit
	%g5 = the thread state
	%g3 = the current handler
	%g2 = the GC base

  and these which still need to be restored:

	%g4 = the return address,
	%g1 = this code

  We need to get the GC return value from the thread state into g1, do
  a restore, do the tagging operation, load g1 from the thread state,
  recompute the alloc test from the alloc limit, and return to
  g4. This sequence is carefully chosen to make sure we get back to ML
  with all the registers correctly set (except g4).

  The computation of g1 is (0x7ffffffc - (limit - alloc)), 
  */

	.global C_NAME(gc_trap_ret_template)
	.global C_NAME(gc_trap_ret_template_end)
	.global C_NAME(gc_trap_ret_template_overwrite)

C_NAME(gc_trap_ret_template):
	ld	[%g5+THREAD_ml_global], %g1	/* get GC return value */
	restore
C_NAME(gc_trap_ret_template_overwrite):
	nop				/* this instr will be overwritten */
	sethi	%hi(0x7ffffffc), %g1
	or	%g1, %lo(0x7ffffffc), %g1
	ld	[%g5+IMPLICIT_gc_limit],%g2
	sub	%g1, %g2, %g1			/* g1 = 0x7ffffffc - limit */
	ld	[%g5+IMPLICIT_gc_base],%g2	/* g2 = alloc, which we keep */
	jmpl	%g4+8, %g0
	add	%g1, %g2, %g1			/* g1 += alloc */
C_NAME(gc_trap_ret_template_end):
	nop

/* gc_trap_entry_leaf is almost identical to gc_trap_entry
  (above). This is entered on return from the trap handler after an
  allocation trap in a leaf function. */

	.global C_NAME(gc_trap_entry_leaf)

C_NAME(gc_trap_entry_leaf):

	save	%sp, -64, %sp			/* make ML stack frame */
	mov	%i1, %o2			/* save closure for gc arg */
	mov	%g0, %o1			/* clear clos for profiler */

/* get return address into o7 so the stack frame looks normal */

	sethi	%hi(C_NAME(gc_trap_return_address)), %o0
	or	%o0, %lo(C_NAME(gc_trap_return_address)), %o0
	ld	[%o0],%o7

/* get number of bytes requested */

	sethi	%hi(C_NAME(gc_trap_bytes)), %o0
	or	%o0, %lo(C_NAME(gc_trap_bytes)), %o0
	ld	[%o0], %o0			/* get 'bytes requested' */
	addcc	%o0, 1, %g0			/* is it -1? */
	beq,a	leaf_got_bytes
	mov	%g4, %o0			/* if so, use %g4 instead */
leaf_got_bytes:
	add	%g2, %o0, %g2			/* add to GC_HEAP_START */

	store_ML_state_with(%g5)		/* save ML state */
	st	%sp, [%g5+THREAD_ml_sp]		/* Save base of ML stack */
	ld	[%g5+THREAD_global], %o5	/* o5 = global_state */
	ld	[%g5+THREAD_c_sp], %o4
	save	%o4, -216, %sp			/* Switch to C stack */
	st	%sp, [%g5+THREAD_ml_gc_sp]	/* Save last ML frame for GC */
	store_fps(%sp+88)			/* save FP registers */
	mov	%i0, %o0			/* arg 0 is number of bytes */
	mov	%i2, %o1			/* arg 1 is closure */
	call	C_NAME(gc)			/* call GC */
	st	%g0, [%i5+GLOBAL_in_ML]		/* not in ML */

	st	%i5, [%i5+GLOBAL_in_ML]		/* back in ML */
	ld	[%i5+GLOBAL_current_thread],%g5
	load_fps(%sp+88)
	load_ML_state_with(%g5, %o4)
	restore
	clean_windows

/* Ultra: ins are the outs from ML, locals and o3 are fresh,
 * o0=request size, o1=0, o2=closure, o4=c_sp, o5=global. */

	sethi	%hi(C_NAME(gc_trap_ret_leaf_code)), %g1
	or	%g1, %lo(C_NAME(gc_trap_ret_leaf_code)), %g1
	ld	[%g1], %g1			/* code address in g1 */
	jmpl	%g1, %g0
	mov	%o7, %g4			/* return address in g4 */

/* Code to return to an ML leaf procedure after GC. As for
  gc_trap_ret_template (above). Actually these two routines are
  identical now; they are distinct in case we want to change one of
  them later. */

	.global C_NAME(gc_trap_ret_leaf_template)
	.global C_NAME(gc_trap_ret_leaf_template_end)
	.global C_NAME(gc_trap_ret_leaf_template_overwrite)

C_NAME(gc_trap_ret_leaf_template):
	ld	[%g5+THREAD_ml_global], %g1	/* get GC return value */
	restore
C_NAME(gc_trap_ret_leaf_template_overwrite):
	nop				/* this instr will be overwritten */
	sethi	%hi(0x7ffffffc), %g1
	or	%g1, %lo(0x7ffffffc), %g1
	ld	[%g5+IMPLICIT_gc_limit],%g2
	sub	%g1, %g2, %g1			/* g1 = 0x7ffffffc - limit */
	ld	[%g5+IMPLICIT_gc_base],%g2	/* g2 = alloc, which we keep */
	jmpl	%g4+8, %g0
	add	%g1, %g2, %g1			/* g1 += alloc */
C_NAME(gc_trap_ret_leaf_template_end):
	nop

/* Space profiling. When space profiling is turned on, each
3-instruction allocation sequence of interest is replaced with one of
the following sequences:

1. non-leaf, small static size

	jmpl	%g5+IMPLICIT_profile_alloc, %g5
	li	%g4, <size>
	add	%g4, <tag>, <result>

2. non-leaf, large or dynamic size (in g4)

	jmpl	%g5+IMPLICIT_profile_alloc, %g5
	nop
	add	%g4, <tag>, <result>

3. leaf, small static size

	jmpl	%g5+IMPLICIT_profile_alloc_leaf, %g5
	li	%g4, <size>
	or	%g4, <tag>, <result>

4. leaf, large or dynamic size (in g4)

	jmpl	%g5+IMPLICIT_profile_alloc_leaf, %g5
	nop
	or	%g4, <tag>, <result>

On the implicit vector (i.e. every thread state) we place a pair of
three-instruction stubs: */

	.global	C_NAME(implicit_profile_alloc_code)
	.global	C_NAME(implicit_profile_alloc_code_end)

C_NAME(implicit_profile_alloc_code):
	sethi	%hi(C_NAME(ml_profile_alloc)), %g1
	jmpl	%g1+%lo(C_NAME(ml_profile_alloc)),%g0
	nop
	sethi	%hi(C_NAME(ml_profile_alloc_leaf)), %g1
	jmpl	%g1+%lo(C_NAME(ml_profile_alloc_leaf)),%g0
	nop
C_NAME(implicit_profile_alloc_code_end):
	nop

/*
This gets us to these two routines with the following 'arguments':

	g5 is the continuation address
	g4 is the amount to allocate
	g1 is garbage

and the following required 'result':

	g4 is the allocated object

We have to be careful about what we put in the closure (i1) and link
(i7) registers in any frame, because when a GC occurs the link slots
on the stack are fixed up according to the code address in the
caller's closure (found in the caller's frame). So our link back to
the allocating function should go in the link slot of the first frame
which we allocate (so that the fix happens correctly), and our own
link slots should not look like link slots (i.e. should not be
pointers into fromspace). Our own closure slots should not look like
closures (i.e. should be special values) */

	.global C_NAME(ml_profile_alloc)

C_NAME(ml_profile_alloc):

/* Enter and set up the frame as if it were a regular ML frame */

	mov	%i1, %g1		/* save allocator's closure ...  */
	save	%sp, -64, %sp
	mov	%g1, %o0		/* ... in o0 */
	mov	%i1, %l1		/* save allocator's o1 in l1 */
	mov	%i7, %l2		/* save allocator's o7 in l2 */

	mov	STACK_SPACE_PROFILE, %i1 /* set closure to special value */
	mov	%g5, %i7		/* set return address in case we GC */

/* Restore g1 and g5 from the thread state */

	sethi	%hi(C_NAME(global_state)), %o2
	or	%o2, %lo(C_NAME(global_state)), %o2
	ld	[%o2 + GLOBAL_current_thread], %g5	/* restore g5 */
	ld	[%g5 + IMPLICIT_gc_limit], %o3
	sethi	%hi(0x7ffffffc), %o4
	or	%o4, %lo(0x7ffffffc), %o4
	sub	%o4, %o3, %o4
	add	%o4, %g2, %g1		/* g1 = 0x7ffffffc-(limit-g2) */

/* do the allocation (non-leaf) */

	taddcctv %g1, %g4, %g1		/* allocation sequence */
	add	%g2, 0, %o3		/* result in o3 (untagged) */
	add	%g2, %g4, %g2
	mov	%o3, %g4		/* result in g4 */

/* write the heap profile info */

	ld	[%g5 + THREAD_ml_profile], %o4	/* load heap profile pointer */
	st	%o0, [%o4]		/* first word is the closure */
	st	%g4, [%o4+4]		/* second word is the alloc ptr */
	add	%o4, 8, %o4		/* inc heap profile pointer */
	st	%o4, [%g5 + THREAD_ml_profile]		/* write it back */

/* restore the allocator's stack frame and return */
	mov	%l1, %i1
	jmpl	%i7+8, %g0		/* return */
	restore	%l2, 0, %o7		/* restore allocator's o1 */


	.global C_NAME(ml_profile_alloc_leaf)

C_NAME(ml_profile_alloc_leaf):

/* Enter and set up the frame */

	save	%sp, -64, %sp
	mov	STACK_SPACE_PROFILE, %o1 /* set closure to a special value */
	mov	%g5, %o7		/* set return address in case we GC */

/* restore g5 and g1 */

	sethi	%hi(C_NAME(global_state)), %o2
	or	%o2, %lo(C_NAME(global_state)), %o2
	ld	[%o2 + GLOBAL_current_thread], %g5	/* restore g5 */
	ld	[%g5 + IMPLICIT_gc_limit], %o3
	sethi	%hi(0x7ffffffc), %o4
	or	%o4, %lo(0x7ffffffc), %o4
	sub	%o4, %o3, %o4
	add	%o4, %g2, %g1		/* g1 = 0x7ffffffc-(limit-g2) */

/* allocate */

	taddcctv %g1, %g4, %g1		/* allocation sequence */
	or	%g2, 0, %o3		/* result in o3 (untagged) */
	add	%g2, %g4, %g2
	mov	%o3, %g4		/* and then in g4 */

/* write the heap profile info */

	ld	[%g5 + THREAD_ml_profile], %o4	/* load heap profile pointer */
	st	%i1, [%o4]		/* first word is the closure */
	st	%g4, [%o4+4]		/* second word is the alloc ptr */
	add	%o4, 8, %o4		/* inc heap profile pointer */
	st	%o4, [%g5 + THREAD_ml_profile]		/* write it back */

/* restore the stack frame and return */

	jmpl	%o7+8, %g0		/* return */
	restore

	.global C_NAME(switch_to_thread)

C_NAME(switch_to_thread):
	save	%sp, -64, %sp

	add	%i7, 8, %i7			/* compute the pc = lr+8 */
	st	%i6, [%i0+THREAD_c_tsp]		/* save the old thread's sp */
	st	%i7, [%i0+THREAD_c_pc]		/* save the old thread's pc */

/* we cause a trap, flushing windows, so that future restores will be
 * from the new thread's stack. */

	ta	ST_FLUSH_WINDOWS
	ld	[%i1+THREAD_c_pc], %i7		/* new 'return address' */
	ld	[%i1+THREAD_c_tsp], %i6		/* new fp */
	jmpl	%i7, %g0
	restore

#ifdef COLLECT_STATS
	.global C_NAME(raise_count)
	.global C_NAME(stack_extension_count)
#endif
@


1.28.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a25 4
 * Revision 1.28  1998/10/30  17:18:15  jont
 * [Bug #70226]
 * Remove raise_count and stack_extension_count (gone to mlw_start.c)
 *
@


1.27
log
@[Bug #70035]
Add stub_code_start and stub_code_end variables
for use in address validation
@
text
@d26 5
a1391 6
	.data
	.align 2
C_NAME(raise_count):
	.word 0
C_NAME(stack_extension_count):
	.word 0
@


1.26
log
@[Bug #30200]
Set in_ML in c_raise.
@
text
@d26 4
d438 9
a446 3

C_NAME(stub_c):		.word internal_stub_c+POINTER
C_NAME(stub_asm):	.word internal_stub_asm+POINTER
d530 3
@


1.26.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a25 4
 * Revision 1.26  1997/07/15  15:36:52  daveb
 * [Bug #30200]
 * Set in_ML in c_raise.
 *
@


1.26.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a25 4
 * Revision 1.26  1997/07/15  15:36:52  daveb
 * [Bug #30200]
 * Set in_ML in c_raise.
 *
@


1.26.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a25 4
 * Revision 1.26  1997/07/15  15:36:52  daveb
 * [Bug #30200]
 * Set in_ML in c_raise.
 *
@


1.25
log
@The ST_CLEAN_WINDOWS trap semantics are subtly different on UltraSPARCs. The
effect is that the registers which are current at the time of the trap may
reappear in a later register window. So whenever we invoke it, we have to
ensure that the current registers (ins, locals, and outs) are GC-safe.
@
text
@d26 6
d759 2
@


1.25.1.1
log
@branched from 1.25
@
text
@a25 6
 * Revision 1.25  1997/02/06  11:41:51  nickb
 * The ST_CLEAN_WINDOWS trap semantics are subtly different on UltraSPARCs. The
 * effect is that the registers which are current at the time of the trap may
 * reappear in a later register window. So whenever we invoke it, we have to
 * ensure that the current registers (ins, locals, and outs) are GC-safe.
 *
@


1.25.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a25 3
 * Revision 1.25.1.1  1997/05/12  10:44:35  hope
 * branched from 1.25
 *
@


1.25.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a25 3
 * Revision 1.25.1.1  1997/05/12  10:44:35  hope
 * branched from 1.25
 *
@


1.25.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a25 3
 * Revision 1.25.1.1  1997/05/12  10:44:35  hope
 * branched from 1.25
 *
@


1.25.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a25 3
 * Revision 1.25.1.1.1.1  1997/07/28  18:27:31  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.24
log
@[Bug #1461]
Must not construct fake frames for non-leaf functions, as
they do not contain values which the GC and the debugger expect
them to. This can lead to fatal failure of either the GC or
the debugger (e.g. indexing down from an fp which does not
point to the top of a genuine stack frame).
@
text
@d26 8
a357 6
/* we can't get this macro from an include file because under SunOS
 * it's in /usr/include/machine/trap.h and under Solaris it's in
 * /usr/include/sys/trap.h */

#define ST_FLUSH_WINDOWS 3

d395 3
d404 2
a405 2
/* i2 points to global state, i3 is the c_sp, i4 is the previous
 * ml_state.sp, i5 is the previous ml_state.base */
d468 1
d493 8
d502 1
a502 1
	clean_windows			! Clean dirty C windows
d562 1
a562 1
	ta 3
d746 5
a751 1
	mov	STACK_C_RAISE, %i1	! Mark this frame
d834 1
a834 1
	ta	1
d957 1
a957 1
	ta	1
d1048 6
d1106 1
a1107 2
	jmpl	%g4+8, %g0
	clean_windows
a1118 1

d1157 5
a1161 1
	
d1187 1
a1188 2
	jmpl	%g4+8, %g0
	clean_windows
@


1.24.5.1
log
@branched from 1.24
@
text
@a25 8
 * Revision 1.24  1996/11/07  17:51:52  stephenb
 * [Bug #1461]
 * Must not construct fake frames for non-leaf functions, as
 * they do not contain values which the GC and the debugger expect
 * them to. This can lead to fatal failure of either the GC or
 * the debugger (e.g. indexing down from an fp which does not
 * point to the top of a genuine stack frame).
 *
@


1.24.4.1
log
@branched from 1.24
@
text
@a25 8
 * Revision 1.24  1996/11/07  17:51:52  stephenb
 * [Bug #1461]
 * Must not construct fake frames for non-leaf functions, as
 * they do not contain values which the GC and the debugger expect
 * them to. This can lead to fatal failure of either the GC or
 * the debugger (e.g. indexing down from an fp which does not
 * point to the top of a genuine stack frame).
 *
@


1.24.4.1.1.1
log
@branched from 1.24.4.1
@
text
@a25 3
 * Revision 1.24.4.1  1996/12/17  17:56:17  hope
 * branched from 1.24
 *
@


1.24.4.1.1.2
log
@[Bug #0]
Make ULTRA SPARC capable version
@
text
@a25 10
 * Revision 1.25  1997/02/06  11:41:51  nickb
 * The ST_CLEAN_WINDOWS trap semantics are subtly different on UltraSPARCs. The
 * effect is that the registers which are current at the time of the trap may
 * reappear in a later register window. So whenever we invoke it, we have to
 * ensure that the current registers (ins, locals, and outs) are GC-safe.
 *
 * Revision 1.24.4.1.1.1  1997/02/24  11:47:52  hope
 * branched from 1.24.4.1
 *
 * Revision 1.24.4.1  1996/12/17  17:56:17  hope
d361 6
a403 3
	/* Ultra: l0-l7 and o2-o5 are zero, i0=arg, i1=clos, i2=global,
           i3=c_sp, i4=gc_sp, i5=ml_sp, and we're about to set o0 and o1: */

d410 2
a411 2
/* On return from ML, i2 points to global state, i3 is the c_sp, i4 is
 * the previous ml_state.sp, i5 is the previous ml_state.base */
a473 1

d498 1
a498 1

a499 8
	ultra_clean(%o4)

	/* Ultra: we have just restored to an ML frame, so ins and
           locals are GC-safe. o0=result, o1=closure, o2=global, o5=c_sp.
           o3 is unmodified since we were in ML, so it's also GC-safe. */

	retl
	nop
d559 1
a559 1
	ta ST_FLUSH_WINDOWS
a742 5

/* Ultra: we've just restored into an ML frame, so everything is GC-safe */

	mov	STACK_C_RAISE, %o1	! Mark this frame

d744 1
d827 1
a827 1
	ta	ST_BREAKPOINT
d950 1
a950 1
	ta	ST_BREAKPOINT
a1040 6
	clean_windows

/* Ultra: We've just restored into the frame which we created when
 * entering gc_trap_entry. ins are the outs from ML, l2-l7 and o3 are
 * still fresh, l0=old i7, l1=old i1, o0=object size, i1=o1=0, o2=closure,
 * o4=c_sp, o5=global */
d1093 1
d1095 1
a1095 1
	add	%g1, %g2, %g1			/* g1 += alloc */
d1107 1
d1146 1
a1146 5
	clean_windows

/* Ultra: ins are the outs from ML, locals and o3 are fresh,
 * o0=request size, o1=0, o2=closure, o4=c_sp, o5=global. */

d1172 1
d1174 1
a1174 1
	add	%g1, %g2, %g1			/* g1 += alloc */
@


1.24.3.1
log
@branched from 1.24
@
text
@a25 8
 * Revision 1.24  1996/11/07  17:51:52  stephenb
 * [Bug #1461]
 * Must not construct fake frames for non-leaf functions, as
 * they do not contain values which the GC and the debugger expect
 * them to. This can lead to fatal failure of either the GC or
 * the debugger (e.g. indexing down from an fp which does not
 * point to the top of a genuine stack frame).
 *
@


1.24.2.1
log
@branched from 1.24
@
text
@a25 8
 * Revision 1.24  1996/11/07  17:51:52  stephenb
 * [Bug #1461]
 * Must not construct fake frames for non-leaf functions, as
 * they do not contain values which the GC and the debugger expect
 * them to. This can lead to fatal failure of either the GC or
 * the debugger (e.g. indexing down from an fp which does not
 * point to the top of a genuine stack frame).
 *
@


1.24.1.1
log
@branched from 1.24
@
text
@a25 8
 * Revision 1.24  1996/11/07  17:51:52  stephenb
 * [Bug #1461]
 * Must not construct fake frames for non-leaf functions, as
 * they do not contain values which the GC and the debugger expect
 * them to. This can lead to fatal failure of either the GC or
 * the debugger (e.g. indexing down from an fp which does not
 * point to the top of a genuine stack frame).
 *
@


1.24.1.1.1.1
log
@branched from 1.24.1.1
@
text
@a25 3
 * Revision 1.24.1.1  1996/11/14  13:00:09  hope
 * branched from 1.24
 *
@


1.23
log
@When restoring the stack limit after return from a stack
extension, we should OR in the interrupt slot. By mistake,
we are ORing in the stack limit slot, which will have no
effect. This relatively harmless bug discovered when looking
for a much more serious one.
@
text
@d26 7
d570 6
a575 2
 * event handler to trip up ML at a `safe' moment.  The function
 * jumps here with the following parameters:
d577 4
a580 4
 *  %o0  function argument
 *  %o1  function closure
 *  %o2 - %o5 rest of arguments
 *  %g7  minimum stack requirement of function
d582 1
a582 2
 *  %g4  link to continue function
 *  %o7  link to functions caller
d588 10
a597 5
	save	%sp, -0x40, %sp
	mov	%g4, %o7
	ld	[%g5+IMPLICIT_stack_limit], %g4
	sub	%sp, %g7, %o0
	cmp	%o0, %g4
a598 1
	mov	STACK_EVENT, %o1
d608 6
a613 1
	ld	[%o0+4], %g7
d615 1
a615 1
	st	%o0, [%g5+IMPLICIT_stack_limit]
d617 7
a623 4
	restore	%o7, 0, %g4
	save	%g7, -0x40, %sp
	mov	%g4, %o7
	mov	STACK_EXTENSION, %o1
d626 1
a626 1
	ld	[%g5+IMPLICIT_interrupt], %g4
d629 1
a629 1
	bgt	call_disturbed_fn
d631 1
a631 4
	save	%sp, -0x40, %sp
	mov	0, %o7
	mov	STACK_EVENT, %o1
	ld	[%g5+IMPLICIT_stack_limit],%g6
a633 1
	restore
d636 2
a637 3
	mov	%o1, %g4
	mov	%i0, %o0
	mov	%i1, %o1
d641 5
a645 3
	mov	%i5, %o5
	jmpl	%o7+8, %o7
	mov	%g4, %i1
d648 3
a650 3
	cmp	%i1, STACK_EXTENSION
	bne	return_to_caller
	mov	%o0, %i0
@


1.22
log
@Exchange ml_state.base and ml_state.sp, to be consistent with other platforms.
@
text
@d640 1
a640 1
	ld	[%g5+IMPLICIT_stack_limit], %o0
@


1.21
log
@Move CURRENT_THREAD manipulation out of asm into portable C.
@
text
@d26 3
d358 1
a358 1
 * pointer is restored to its calue on entry, the ML state is stored
d379 2
a380 2
	ld	[%g5+THREAD_ml_sp], %o4 ! saved ml_state.sp
	ld	[%g5+THREAD_ml_base], %o5 ! current base of the ML stack area
d382 1
a382 1
	save	%o5, -0x40, %sp		! Make first ML stack frame below it
d399 2
a400 2
	st	%o4, [%g5+THREAD_ml_sp]	! restore ml_state.sp
	st	%o5, [%g5+THREAD_ml_base]! restore base of the ML stack area
d460 1
a460 1
	st	%sp, [%g5+THREAD_ml_base] ! Save base of ML stack area
d462 1
a462 1
	st	%sp, [%g5+THREAD_ml_sp]	! Save last ML frame for GC
d704 1
a704 1
	ld	[%g5+THREAD_ml_sp], %g4	! saved ml_state.sp
d984 2
a985 2
	st	%sp, [%g5+THREAD_ml_sp]		/* Save last ML frame for GC */
	st	%sp, [%g5+THREAD_ml_base]	/* Save base of ML stack */
d1100 1
a1100 1
	st	%sp, [%g5+THREAD_ml_base]	/* Save base of ML stack */
d1104 1
a1104 1
	st	%sp, [%g5+THREAD_ml_sp]		/* Save last ML frame for GC */
@


1.21.3.1
log
@branched from 1.21
@
text
@a25 3
 * Revision 1.21  1995/11/13  12:31:59  nickb
 * Move CURRENT_THREAD manipulation out of asm into portable C.
 *
@


1.21.2.1
log
@branched from 1.21
@
text
@a25 3
 * Revision 1.21  1995/11/13  12:31:59  nickb
 * Move CURRENT_THREAD manipulation out of asm into portable C.
 *
@


1.21.1.1
log
@branched from 1.21
@
text
@a25 3
 * Revision 1.21  1995/11/13  12:31:59  nickb
 * Move CURRENT_THREAD manipulation out of asm into portable C.
 *
@


1.20
log
@Change to c_sp protocol.
@
text
@d26 3
a1302 12
/* switch the 'current thread' */

	sethi	%hi(C_NAME(global_state)), %i1
	or	%i1, %lo(C_NAME(global_state)), %i1
	ld 	[%i1+GLOBAL_current_thread], %i2 /* change current thread */
	st	%i0, [%i1+GLOBAL_current_thread]

/* if the interrupt slot is set in the old thread, set it in the new
 * thread too. This computation interleaved with stuff to save the old
 * thread's sp and pc */

	ld	[%i2+IMPLICIT_interrupt], %i3
d1304 2
a1305 6
	st	%i6, [%i2+THREAD_c_tsp]		/* save the old thread's sp */
	cmp	%g0, %i3
	beq	switch_skip
	st	%i7, [%i2+THREAD_c_pc]		/* save the old thread's pc */
	st	%i3, [%i0+IMPLICIT_interrupt]
switch_skip:
d1311 2
a1312 4
	ld	[%i0+THREAD_c_pc], %i7		/* new 'return address' */
	ld	[%i0+THREAD_c_tsp], %i6		/* new fp */

	mov	%i2, %i0			/* return last thread */
@


1.19
log
@Bug in leaf handler raise.
@
text
@d26 3
a336 2
#define NEW_HANDLERS 1

d372 1
a374 1
	ld	[%g5+THREAD_c_sp], %o3	! record old c_state.sp in this frame
d392 1
d451 1
a451 2
	.word	0x7f00			! Code element 0
					! (no spills,leaf,intercept)
a467 1
	st	%i5, [%g5+THREAD_c_sp]	!	resave C sp and
d480 1
a480 2
	.word	0x7f01			! Code element 1
					! (no spills, leaf, intercept)
a705 1
	st	%o5, [%g5+THREAD_c_sp]	! restore c_sp from this stack frame
d1313 1
a1313 1
	st	%i6, [%i2+THREAD_c_sp]		/* save the old thread's sp */
d1325 1
a1325 1
	ld	[%i0+THREAD_c_sp], %i6		/* new fp */
@


1.18
log
@Reuse stack frame on leaf handler raise.
@
text
@d26 3
d751 2
a752 2
	beq	raise_skip
	nop
@


1.17
log
@Add space profiling code.
@
text
@d26 3
a725 6
 * If the handler record is zero then the next handler is the top-level
 * handler, and the C function handle() is called.  This returns iff a
 * debugger is installed, and passes some information about where to
 * find it.  In this case, the debugger is called, and that in turn
 * returns instructions for what to do next.
 *
d729 2
a730 3
 *    7	Stack pointer of creator
 *   11	Handler function closure
 *   15	Offset within creator of continuation code
a733 1
 *   %o7  Return address for resumption (not used at present, and not true for leaf)
a735 1
 *
d746 5
d752 4
d757 5
a761 5
	sethi	%hi(C_NAME(raise_count)), %o1
	or	%o1, %lo(C_NAME(raise_count)), %o1
	ld	[%o1], %g4
	add	%g4, 1, %g4
	st	%g4, [%o1]
a762 6
#if NEW_HANDLERS
/*
 * Build a new small frame
 */
	mov	STACK_RAISE, %o1	/* This frame's closure	*/
	save	%sp, -0x40, %sp		/* New frame */
a765 15
#else
	ld	[%g3+7], %o1		! Get handler closure
	mov	%sp, %g4		! Remember current sp
	sub	%sp, 8, %sp		! Extend current stack slightly
	mov	%g3, %o2		! Get base of handlers
ml_raise10:
	ld	[%o2+3], %o3		! Get handlers sp
	cmp	%o3, %g4		! Is it the sp we are changing
	bne,a	ml_raise20
	std	%g2, [%sp+64]		! Save current handler pointer
	st	%sp, [%o2+3]		! Update sp in handler frame
	ba	ml_raise10		! Loop
	ld	[%o2-1], %o2		! With previous handler
ml_raise20:
#endif
d767 2
a768 3
	jmpl	%g4+CODE_OFFSET, %o7	! The call to the handler
	ld	[%g3-1], %g3		! Call the handler with previous handler restored
#if NEW_HANDLERS
d773 1
a773 16
#else
	ld	[%sp+68], %g3		! Reinstate the handler
	mov	%sp, %g4		! Remember current sp
	add	%sp, 8, %sp		! Return stack to its previous size
	mov	%g3, %o2		! Get base of handlers
ml_raise30:
	ld	[%o2+3], %o3		! Get handler sp
	cmp	%o3, %g4		! Is it the sp we are changing
	bne,a	ml_raise40
	ld	[%g3+3], %g4		! Load sp of creator function
	st	%sp, [%o2+3]		! Update sp in handler frame
	ba	ml_raise30		! Loop
	ld	[%o2-1], %o2		! With previous handler
ml_raise40:
#endif
	unwind_stack(raise)		! Wind back to that frame, propagating result
d775 1
a775 1
	ld	[%g3+11], %g4		! Fetch the offset of the continuation...
d777 1
a777 1
	ld	[%i1-1], %o1		! Get the address of the creator function
a780 22

C_NAME(ml_raise_leaf):
#ifdef COLLECT_STATS
	sethi	%hi(C_NAME(raise_count)), %o1
	or	%o1, %lo(C_NAME(raise_count)), %o1
	ld	[%o1], %g4
	add	%g4, 1, %g4
	st	%g4, [%o1]
#endif

/* New code for stack extending when needed for leaf raise */

	sub	%sp, STACK_BUFFER+0x40, %g4	! Extension needed test
	cmp	%g4, %g6		! The test
	bcc	C_NAME(ml_raise)	! Branch if ok
	ld	[%g5+IMPLICIT_extend], %g4
	jmpl	%g4, %g4		! Extend stack
	mov	STACK_BUFFER+0x40, %g7	! Required size
	save	%sp, -0x40, %sp		! New frame on new stack
	mov	%i0, %o0		! Argument to raise
	ba	C_NAME(ml_raise)	! And as before (note handler continuation
	mov	STACK_RAISE, %i1	! will unwind the stack extension)
@


1.16
log
@Move to new method of preserving current handler frame when applying handler
@
text
@d26 3
d995 4
a998 1
*/
a1023 1
	mov	%g1, %o1			/* get closure back */
d1025 7
d1040 1
a1040 1
	mov	%i1, %o1			/* arg 1 is closure */
d1065 1
d1126 1
d1128 2
a1129 1
	mov	%i1, %o1			/* save closure */
a1146 1
	add	%g1, %o0, %g1			/* add to GC_HEAP_LIMIT */
a1149 1

d1156 1
a1156 1
	mov	%i1, %o1			/* arg 1 is closure */
d1197 152
@


1.15
log
@Replace set_stack_underflow with more general code.
@
text
@d26 47
a72 44
# Revision 1.14  1995/03/28  15:13:05  nickb
# Add threads system.
#
# Revision 1.13  1995/02/23  15:01:15  matthew
# Clear lr for intercept frame
#
# Revision 1.12  1994/10/27  23:05:49  jont
# Change offsets in handler records to be ml integers
#
# Revision 1.11  1994/10/19  11:59:41  jont
# Fix handler unwinding
#
# Revision 1.10  1994/09/15  11:53:40  jont
# Reduce handler frame size to four words
# by leaving out fp
#
# Revision 1.9  1994/09/05  12:20:36  nickb
# Preserve o7 (link register) over non-leaf GC entry.
#
# Revision 1.8  1994/08/25  09:41:16  matthew
# Change stack extension entry to free up O registers.
#
# Revision 1.7  1994/07/22  16:21:24  nickh
# Add routines to get us into GC from a trap handler and back again.
# (see gc_trap_entry, gc_trap_entry_leaf, &c).
#
# Revision 1.6  1994/07/06  13:31:35  nickh
# Asm and C name prefixes differ according to OS.
#
# Revision 1.5  1994/07/01  10:39:59  nickh
# Add debugger trap.
#
# Revision 1.4  1994/06/21  15:58:21  nickh
# New ancillary layout.
#
# Revision 1.3  1994/06/15  16:16:56  jont
# Put non ML return values in o7 when marking STACK_EVENT frames
#
# Revision 1.2  1994/06/09  14:30:02  nickh
# new file
#
# Revision 1.1  1994/06/09  10:54:32  nickh
# new file
#
d325 2
d757 10
d780 1
d784 6
d803 1
@


1.14
log
@Add threads system.
@
text
@d26 3
d525 1
a525 1
/* === CAUSE A CALL TO EVENT POLL ===
d527 4
a530 6
 * This routine is called from the asynchronous event handler in order
 * to cause ML to call the event poll routine at the next opportunity.
 * It does this by modifying the value of %g6 (the stack limit
 * register) to -1.  IT ONLY WORKS IF CALLED DIRECTLY FROM A SIGNAL
 * HANDLER.  Ack gag barf.
 */
d532 1
a532 1
	.global C_NAME(set_stack_underflow)
d534 1
a534 2
C_NAME(set_stack_underflow):
	xnor	%g0, %g0, %o0
d536 1
a536 2
	st	%o0, [%fp+0xf8]		! Blech!  Blat %g6 with -1.

@


1.13
log
@Clear lr for intercept frame
@
text
@d26 3
d319 6
d349 9
a357 5
	store_C_globals(c_state, %o2)
	st	%sp, [%o2 + 28]		! Remember C stack ptr for calls to C
	load_ML_state(ml_state, %o3, %o4)
	ld	[%o3 + 28], %o4		! saved ml_state.sp
	ld	[%o3 + 32], %o5		! the current base of the ML stack area
d361 1
a361 4
/*
	Assume that we are calling a closure so there is only
	one argument to propagate.
*/
d367 4
d373 4
a376 4
	store_ML_state(ml_state, %o2)
	st	%o4, [%o2 + 28]		! restore ml_state.sp
	st	%o5, [%o2 + 32]		! restore base of the ML stack area
	load_C_globals(c_state, %o3)
d434 6
a439 6
	store_ML_state(ml_state, %o2)
	st	%sp, [%o2+32]		! Save base of ML stack area (see callml)
	load_C_globals(c_state, %o3)
	ld	[%o3+28], %o4		! address of last C stack frame
	save	%o4, -0x78, %sp		! Switch to C stack
	st	%sp, [%i2+28]		! Save last ML frame for GC
d444 1
d446 5
a450 1
	mov	%i0, %o0		! (propagating the argument)
d456 1
a456 2
	store_C_globals(c_state, %o3)
	load_ML_state(ml_state, %o2, %o4)
d482 2
d525 1
a525 1
 * to cause ML to call the event poll routine at the next opportinuty.
d552 1
a552 2
 *       (not including safety zone of 2kb or the normal register save area)
 *       (these are added in here)
d561 6
a566 16
	mov	%g4, %o7		! So gc can fix return link
	addcc	%g6, 1, %g0		! Is %g6 -1? (events pending)
	beq,a	event_poll
	nop
	! \/\/ fall through \/\/

/* == Extend ML stack ==
 *
 * If a function is disturbed by lack of stack this code allocates a
 * new stack area by calling make_stack() in the storage manager and
 * linking to the new stack using a special stack frame.  It then calls
 * the remainder of the disturbed function, deallocating the stack on
 * its return.
 */

extend_stack:
d569 5
a573 5
	or	%o0, %lo(C_NAME(stack_extension_count)), %o0
	ld	[%o0], %g4
	add	%g4, 1, %g4
	st	%g4, [%o0]
#endif
d575 2
a576 7
				! Minimum stack requirement is second arg
	sub	%g6, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
				! Current stack area is first arg
	ML_to_C(make_stack)		! Allocate a new stack area
	sethi	%hi(C_NAME(ml_state)), %o2
	or	%o2, %lo(C_NAME(ml_state)), %o2
	ld	[%o0+0x4], %g4		! Get top of new stack
d578 24
a601 7
	st	%o0, [%o2+16]		! Install the new stack in ml_state
	addcc	%g6, 1, %g0		! Was there an event while in C?
	bne,a	ext0
	mov	%o0, %g6		! Install the new stack in %g6
ext0:	restore	
	save	%g4, -0x40, %sp		! Link to new stack
	mov	%i0, %o0		! Propagate arguments
d607 2
a608 3
	jmpl	%o7+8, %o7		! Call rest of disturbed function
	mov	STACK_EXTENSION, %i1	! (Mark the extra frame)
	! \/\/ fall through \/\/
d610 4
a613 11
extend_return:
	mov	%o0, %i0		! Propagate result to caller
	restore				! Restore back to the old stack, since it is about to disappear
	save	%sp, -0x40, %sp		! Make a frame on the old stack
	addcc	%g6, 1, %g0		! Is an event flagged?
	beq,a	ext1
	sethi	%hi(C_NAME(ml_state)), %o2
	sub	%g6, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
	ML_to_C(unmake_stack)		! Deallocate the stack
	add	%o0, STACK_BUFFER+DEFAULT_STACK_SIZE, %g6
	ret
d615 4
a618 3
ext1:	or	%o2, %lo(C_NAME(ml_state)), %o2
	ld	[%o2+16], %o0		! (Fetch real stack from _ml_state.)
	ML_to_C(unmake_stack)		! Deallocate the stack
d620 6
a625 26
	st	%o0, [%o2+16]		! Update _ml_state with older stack
	ret
	restore				! Return to functions caller

/* == Poll asynchronous events ==
 *
 * If a function has been disturbed by having %g6 = -1 then poll the
 * event handler.
 */

event_poll:
	sethi	%hi(C_NAME(ml_state)), %o0
	or	%o0, %lo(C_NAME(ml_state)), %o0
	ld	[%o0+16], %g6		! Restore the real stack in %g6
	st	%g0, [%g5+IMPLICIT_interrupt] ! Clear the interrupt flag
	sub	%sp, %g7, %g4		! Does the stack really need extending?
	cmp	%g4, %g6
	bgeu	int1
	sethi	%hi(C_NAME(ml_disturbance)), %o4
	or	%o4, %lo(C_NAME(ml_disturbance)), %o4
	jmpl	%o4, %o4		! Really extend the stack
	nop
int1:	save	%sp, -0x40, %sp		! NB %i7 contains disturbed function continuation
	mov	STACK_EVENT, %i1
	mov	0, %o7			! Ensure o7 not mistaken for a return to ML
	ML_to_C(ev_poll)
a626 2
	jmp	%o7+8			! Do the rest of the disturbed function
	restore
d640 2
a641 3
	sethi	%hi(C_NAME(ml_state)), %o0
	or	%o0, %lo(C_NAME(ml_state)), %o0
	ld	[%o0+16], %g6		! Restore the real stack in %g6
d643 2
a644 1
	mov	0, %o7			! Ensure o7 not mistaken for a return to ML
d656 1
a656 1
	save	%sp, -0x40, %sp		! Create a frame, so %i1 = function closure
d662 2
a663 3
	sethi	%hi(C_NAME(ml_state)), %o0
	or	%o0, %lo(C_NAME(ml_state)), %o0
	ld	[%o0+16], %g6		! Restore the real stack in %g6
d665 2
d680 1
a680 10
 * This used to store the globals in c_state using %o2:
 *	st	%sp, [%o2 + 28]		! Remember C stack ptr for calls to C
 * But that extends the unix stack in an unlimited fashion,
 * and is unnecessary.
 *
 * Now we must wind back the c stack explicitly to avoid the ml stack
 * threading back through a bit of C stack we have thrown away and
 * then reused.
 *
 * Rewind to previous ml_state.sp
d682 5
a686 3

	load_ML_state(ml_state, %o3, %o4)
	ld	[%o3 + 28], %g4		! save ml_state.sp
d694 1
d782 1
a782 1
	unwind_stack(%sp, raise)	! Wind back to that frame, propagating result
d858 1
d866 1
a870 4
/* If these functions are going to be called at positions other than
immediately after function entry, then we will need to save all the
caller saves */ 

d874 2
a875 2
	mov 	%g0, %o7
	mov 	%g0, %o1		! blat closure register
d886 2
a887 2
	mov 	%g0, %o7
	mov 	%g0, %o1		! blat closure register
d998 5
a1002 6
	store_ML_state(ml_state,%o2)		/* save ML state */
	st	%sp, [%o2 + 28]			/* Save last ML frame for GC */
	st	%sp, [%o2 + 32]			/* Save base of ML stack */

	load_C_globals(c_state,%o3)		/* load C state */
	ld	[%o3 + 28], %o4
d1005 2
a1006 1
	mov	%i0, %o0			/* number of bytes */
d1008 1
a1008 1
	mov	%i1, %o1			/* with closure */
d1015 4
a1018 2
 * gc_trap_ret_template (below). WE need to enter that code with one
 * restore still to do and with g1, g2, and g4 set in particular ways:
d1021 2
d1024 1
a1024 3
	store_C_globals(c_state, %o2)
	load_ML_state(ml_state, %o3, %o4)
	mov	%o3, %g2			/* address of ml_state in g2 */
a1025 3
	
/* The template for the return code has been copied to
 * *gc_trap_ret_code */
d1038 4
a1041 2
  is overwritten with a result-tagging instruction. This code is
  called from gc_trap_entry, above.
d1043 8
a1050 1
  We enter this code with
a1051 1
	%g2 = ml_state
d1054 7
a1060 4
  We need to get the GC return value from the ml_state into g1, do a
  restore, do the tagging operation, load g1 and g2 from the ml_state,
  and return to g4. This sequence is carefully chosen to make sure we
  get back to ML with all the registers correctly set (except g4).
d1062 1
d1068 1
a1068 1
	ld	[%g2+8], %g1
d1071 7
a1077 3
	nop			/* this instr to be overwritten */
	ld	[%g2+24],%g1
	ld	[%g2],%g2	
d1112 2
a1113 2
	store_ML_state(ml_state,%o2)		/* save ML state */
	st	%sp, [%o2 + 32]			/* Save base of ML stack */
d1115 2
a1116 2
	load_C_globals(c_state,%o3)		/* load C state */
	ld	[%o3 + 28], %o4
d1118 1
a1118 1
	st	%sp, [%i2 + 28]			/* Save last ML frame for GC */
d1120 7
a1126 3
	mov	%i0, %o0			/* number of bytes */
	call	C_NAME(gc)			/* call GC ... */
	mov	%i1, %o1			/* with closure */
d1128 1
a1128 3
	store_C_globals(c_state, %o2)
	load_ML_state(ml_state, %o3, %o4)
	mov	%o3, %g2			/* address of ml_state in g2 */
d1147 1
a1147 1
	ld	[%g2+8], %g1
d1150 7
a1156 3
	nop			/* this instr to be overwritten */
	ld	[%g2+24],%g1
	ld	[%g2],%g2	
d1162 47
@


1.12
log
@Change offsets in handler records to be ml integers
@
text
@d26 3
d882 4
d889 2
d901 2
@


1.11
log
@Fix handler unwinding
@
text
@d26 3
a791 8
#if 0
	cmp	%g4, %sp		! See if there already
	bcs	do_unwind		! Branch if we must unwind
	cmp	%g4, %fp		! See if sp < g4 < fp
	bcs	unwound			! Branch if in correct frame
	nop
#endif
do_unwind:
d795 2
a796 1
	ld	[%i1-1], %o1		! ...and the address of the creator function
@


1.10
log
@Reduce handler frame size to four words
by leaving out fp
@
text
@d26 4
d761 1
a761 1
	ld	[%o1-1], %g4
d763 5
d769 5
d777 1
d779 5
d785 5
d795 1
@


1.9
log
@Preserve o7 (link register) over non-leaf GC entry.
@
text
@d26 3
d756 1
a756 1
	ld	[%g3+11], %o1		! Get handler closure
d764 10
a773 3
	ld	[%g3+3], %g4		! Load fp of creator function
	unwind_stack(%fp, raise)	! Wind back to that frame, propagating result
	ld	[%g3+15], %g4		! Fetch the offset of the continuation...
@


1.8
log
@Change stack extension entry to free up O registers.
@
text
@d26 3
d953 1
d1003 1
d1005 1
a1005 1
	mov	%i7, %g4			/* return address in g4 */
@


1.7
log
@Add routines to get us into GC from a trap handler and back again.
(see gc_trap_entry, gc_trap_entry_leaf, &c).
@
text
@d26 4
d314 1
a314 1
 *   %o0	 Argument for the ML function
d332 4
d514 2
a515 1
 *  %o3  minimum stack requirement of function
d518 1
a518 1
 *  %o4  link to continue function
d526 1
a526 1
	mov	%i4, %o7		! So gc can fix return link
d549 1
a549 1
	add	%i3, STACK_BUFFER+DEFAULT_STACK_SIZE, %o1
d554 2
a555 2
	sethi	%hi(C_NAME(ml_state)), %i2
	or	%i2, %lo(C_NAME(ml_state)), %i2
d558 1
a558 1
	st	%o0, [%i2+16]		! Install the new stack in ml_state
d564 7
a570 3
	mov	%i1, %o1		! Propagate arguments
	mov	%i0, %o0
	jmpl	%i4+8, %o7		! Call rest of disturbed function
d580 1
a580 1
	sethi	%hi(C_NAME(ml_state)), %i2
d586 2
a587 2
ext1:	or	%i2, %lo(C_NAME(ml_state)), %i2
	ld	[%i2+16], %o0		! (Fetch real stack from _ml_state.)
d590 1
a590 1
	st	%o0, [%i2+16]		! Update _ml_state with older stack
d605 1
a605 1
	sub	%sp, %i3, %g4		! Does the stack really need extending?
d611 1
a611 1
	mov	%i3, %o3
d781 2
a782 2
	jmpl	%g4, %o4		! Extend stack
	mov	STACK_BUFFER+0x40, %o3	! Required size
@


1.7.1.1
log
@branched from 1.7
@
text
@a25 4
 * Revision 1.7  1994/07/22  16:21:24  nickh
 * Add routines to get us into GC from a trap handler and back again.
 * (see gc_trap_entry, gc_trap_entry_leaf, &c).
 *
@


1.6
log
@Asm and C name prefixes differ according to OS.
@
text
@d26 3
d448 3
a450 11
 * === GARBAGE COLLECTOR ENTRY POINT ===
 *
 * Non-leaf case:
 *  Parameters:
 *    %g4  Number of bytes required
 *    %g1  Top of live data + %g4
 *  Returns:
 *    %g4  Address of allocated space
 *    %g1  New top of live data + %g4
 *    %g2  New heap limit
 *    Other registers preserved.
d452 1
a452 11
 * Leaf case:
 *  Parameters:
 *    %g4  Number of bytes required
 *    %g1  Top of live data + %g4
 *    %g2  Link register back to ML code
 *  Returns:
 *    As non-leaf case.
 *
 * The address of this code is stored in the implcit vector (see
 * `implicit.h').  It is called when the heap start exceeds the heap
 * limit (i.e. when additional space needs to be found).
a455 1

d457 2
a458 21
	mov	%i1, %g2		! Copy callers closure for later
	save	%sp, -64, %sp		/* Make extra stack frame for */
					/* caller's 'out' registers */
	mov	%g4, %o0
	store_ML_state(ml_state, %o2)
	st	%sp, [%o2 + 28]		! Save last ML frame for GC
	st	%sp, [%o2 + 32]		! Save base of ML stack (see callml)
	load_C_globals(c_state, %o3)
	ld	[%o3 + 28], %o4
	save	%o4, -216, %sp		! Switch to C stack
	store_fps(%sp+88)
	mov	%i0, %o0
	call	C_NAME(gc)		! Call garabage collector
	ld	[%i2 + 0], %o1		! (with size and callers closure)
	load_fps(%sp+88)
	store_C_globals(c_state, %o2)
	load_ML_state(ml_state, %o3, %o4)
	restore				! Switch back to ML stack
	restore 			! Pop back caller's `o' registers
	retl				! Return to ML
	clean_windows			! Clean C values from windows
a460 1

d462 2
a463 22
	save	%sp, -64, %sp		! Make frame for caller registers
	mov	%g4, %o0
	mov	%i1, %o1		! Propagate closure for gc
	mov	%g2, %o7		! Store leaf case link register
	store_ML_state(ml_state, %o2)
	st	%sp, [%o2 + 32]		! Save base of ML stack (see callml)
	load_C_globals(c_state, %o3)
	ld	[%o3 + 28], %o4
	save	%o4, -216, %sp		! Switch to C stack
	st	%sp, [%i2 + 28]		! Save last ML frame for GC
	store_fps(%sp+88)
	mov	%i0, %o0
	call	C_NAME(gc)		! Call garabage collector
	mov	%i1, %o1		! (with size and closure)
	load_fps(%sp+88)
	store_C_globals(c_state, %o2)
	load_ML_state(ml_state, %o3, %o4)
	restore				! Switch back to ML stack
	clean_windows
	jmpl	%o7+8, %g0		! Return to ML
	restore				! Pop back caller's `o' registers

a464 1

d902 193
@


1.5
log
@Add debugger trap.
@
text
@d26 3
d298 1
a298 1
 * The C global registers are stored in the structure _c_state, and the
d314 1
a314 1
	.global _callml
d316 2
a317 2
_callml:
	store_C_globals(_c_state, %o2)
d319 1
a319 1
	load_ML_state(_ml_state, %o3, %o4)
d332 1
a332 1
	store_ML_state(_ml_state, %o2)
d335 1
a335 1
	load_C_globals(_c_state, %o3)
d348 2
a349 2
	.global	_stub_c
	.global	_stub_asm
d351 2
a352 2
_stub_c:	.word stub_c+POINTER
_stub_asm:	.word stub_asm+POINTER
d389 2
a390 1
stub_c:	.word	(stub_c - stub_code_vector) << 6 | BACKPTR
d393 1
a393 1
	store_ML_state(_ml_state, %o2)
d395 1
a395 1
	load_C_globals(_c_state, %o3)
d410 2
a411 2
	store_C_globals(_c_state, %o3)
	load_ML_state(_ml_state, %o2, %o4)
d416 2
a417 2
stub_asm:
	.word	(stub_asm - stub_code_vector) << 6 | BACKPTR
d432 1
a432 1
	.global _ml_lookup_pervasive
d434 1
a434 1
_ml_lookup_pervasive:
d438 1
a438 1
	ML_to_C(_perv_lookup)
d470 1
a470 1
	.global _ml_gc
d472 1
a472 1
_ml_gc:
d477 1
a477 1
	store_ML_state(_ml_state, %o2)
d480 1
a480 1
	load_C_globals(_c_state, %o3)
d485 1
a485 1
	call	_gc			! Call garabage collector
d488 2
a489 2
	store_C_globals(_c_state, %o2)
	load_ML_state(_ml_state, %o3, %o4)
d495 1
a495 1
	.global _ml_gc_leaf
d497 1
a497 1
_ml_gc_leaf:
d502 1
a502 1
	store_ML_state(_ml_state, %o2)
d504 1
a504 1
	load_C_globals(_c_state, %o3)
d510 1
a510 1
	call	_gc			! Call garabage collector
d513 2
a514 2
	store_C_globals(_c_state, %o2)
	load_ML_state(_ml_state, %o3, %o4)
d528 1
a528 1
	.global _flush_windows
d530 1
a530 1
_flush_windows:
d544 1
a544 1
	.global _set_stack_underflow
d546 1
a546 1
_set_stack_underflow:
d570 1
a570 1
	.global _ml_disturbance
d572 1
a572 1
_ml_disturbance:
d591 2
a592 2
	sethi	%hi(_stack_extension_count), %o0
	or	%o0, %lo(_stack_extension_count), %o0
d601 3
a603 3
	ML_to_C(_make_stack)		! Allocate a new stack area
	sethi	%hi(_ml_state), %i2
	or	%i2, %lo(_ml_state), %i2
d606 1
a606 1
	st	%o0, [%i2+16]		! Install the new stack in _ml_state
d624 1
a624 1
	sethi	%hi(_ml_state), %i2
d626 1
a626 1
	ML_to_C(_unmake_stack)		! Deallocate the stack
d630 1
a630 1
ext1:	or	%i2, %lo(_ml_state), %i2
d632 1
a632 1
	ML_to_C(_unmake_stack)		! Deallocate the stack
d645 2
a646 2
	sethi	%hi(_ml_state), %o0
	or	%o0, %lo(_ml_state), %o0
d652 2
a653 2
	sethi	%hi(_ml_disturbance), %o4
	or	%o4, %lo(_ml_disturbance), %o4
d659 1
a659 1
	ML_to_C(_ev_poll)
d673 2
a674 2
	.globl	_ml_event_check
_ml_event_check:
d676 2
a677 2
	sethi	%hi(_ml_state), %o0
	or	%o0, %lo(_ml_state), %o0
d681 1
a681 1
	ML_to_C(_ev_poll)
d690 2
a691 2
	.globl	_ml_event_check_leaf
_ml_event_check_leaf:
d698 2
a699 2
	sethi	%hi(_ml_state), %o0
	or	%o0, %lo(_ml_state), %o0
d702 1
a702 1
	ML_to_C(_ev_poll)
d708 1
a708 1
/* This is an entry point to _ml_raise which may be called from C. */
d710 1
a710 1
	.global _c_raise
d712 1
a712 1
_c_raise:
d715 1
a715 1
 * This used to store the globals in _c_state using %o2:
d727 1
a727 1
	load_ML_state(_ml_state, %o3, %o4)
d730 1
a730 1
_c_raise10:
d733 1
a733 1
	bne	_c_raise10		! Loop until back to ml stack
d754 1
a754 1
 * crawling our way back up it the C function _unwind_stack is called
d783 2
a784 2
	.global _ml_raise
	.global _ml_raise_leaf
d786 1
a786 1
_ml_raise:
d788 2
a789 2
	sethi	%hi(_raise_count), %o1
	or	%o1, %lo(_raise_count), %o1
d810 1
a810 1
_ml_raise_leaf:
d812 2
a813 2
	sethi	%hi(_raise_count), %o1
	or	%o1, %lo(_raise_count), %o1
d823 1
a823 1
	bcc	_ml_raise		! Branch if ok
d829 1
a829 1
	ba	_ml_raise		! And as before (note handler continuation
a831 10
toplevel_handler:
	ML_to_C(_handler)
	ta	1			! Should never return

continue_from_interrupt:
	mov	%o0, %g4		! The resume frame from the exn packet
	unwind_stack(%sp, top)		! Wind back to that frame
	retl
	nop

d839 1
a839 1
	ML_to_C(_error)
a842 9
/* === DEBUGGING TRAP === */

	.global	_ml_trap

_ml_trap:
	ta 1
	retl
	nop

d852 1
a852 1
 *  _ml_intercept (_ml_intercept_leaf) is jumped to by the instructions
d870 4
a873 4
	.global	_ml_replace
	.global	_ml_replace_leaf
	.global _ml_intercept
	.global _ml_intercept_leaf
d875 1
a875 1
_ml_replace:
d877 1
a877 1
	ML_to_C(_replace)
d881 1
a881 1
_ml_replace_leaf:
d884 1
a884 1
	ML_to_C(_replace)
d888 1
a888 1
_ml_intercept:
d892 1
a892 1
	ML_to_C(_intercept)
d896 1
a896 1
_ml_intercept_leaf:
d902 1
a902 1
	ML_to_C(_intercept)
d915 2
a916 2
 * bit of code above (_ml_intercept_on calls _ml_intercept, for
 * instance). _ml_nop is the sequence of three special nops which are
d921 5
a925 5
	.global	_ml_replace_on
	.global	_ml_replace_on_leaf
	.global _ml_intercept_on
	.global _ml_intercept_on_leaf
	.global _ml_nop
d927 1
a927 1
_ml_replace_on:
d932 1
a932 1
_ml_replace_on_leaf:
d937 1
a937 1
_ml_intercept_on:
d942 1
a942 1
_ml_intercept_on_leaf:
d947 1
a947 1
_ml_nop:
d954 1
a954 1
	.global _generate_debugger_trap
d956 1
a956 1
_generate_debugger_trap:
@


1.4
log
@New ancillary layout.
@
text
@d26 3
d966 8
@


1.3
log
@Put non ML return values in o7 when marking STACK_EVENT frames
@
text
@d26 3
d348 1
a348 1
/* First we put in some fake arrays etc */
d351 14
a364 10
cancill:	.word	((cancill_end-cancill-4)<< 6) | ARRAY
	.word	0
	.word	4
	.word	ccvspills + REFPTR
	.word	ccvnames + REFPTR
	.word	ccvleaf + REFPTR
	.word	ccvprofile + REFPTR
	.word	ccvintercepts + REFPTR
	.word	ccvinterfns + REFPTR
cancill_end:
d366 5
a370 5
ccvspills:	.word	((cspills_end-ccvspills-4) << 6) | ARRAY
	.word	0
	.word	4
	.word	0
cspills_end:
d372 5
a376 23
ccvnames:	.word	((cnames_end-ccvnames-4) << 6) | ARRAY
	.word	0
	.word	4
	.word	sc_name + POINTER
cnames_end:
	.align	8
ccvleaf:	.word	((cleaf_end-ccvleaf-4) << 6) | ARRAY
	.word	0
	.word	4
	.word	0
cleaf_end:
	.align	8
ccvintercepts:	.word	((cintercepts_end-ccvintercepts-4) << 6) | ARRAY
	.word	0
	.word	4
	.word	-4
cintercepts_end:
	.align	8
ccvinterfns:	.word	((cinterfns_end-ccvinterfns-4) << 6) | ARRAY
	.word	0
	.word	4
	.word	0
cinterfns_end:
d378 8
a385 10
ccvprofile:	.word	((cprofile_end-ccvprofile -4) << 6) | ARRAY
	.word	0
	.word	4
	.word	0
cprofile_end:
	.align 	8
	.word	((sc_end-stub_c+4)<<6) | CODE
	.word	cancill + REFPTR
stub_c:	.word	0x222			! Back pointer
	.word	0			! Code element 0
a406 1
sc_end:	.align	8
a407 33
sc_name:
	.word	((sc_name_end - sc_name - 4) << 6) | STRING
	.asciz	'stub to C'
sc_name_end:
	.align 	8
aancill:	.word	((aancill_end-aancill-4)<< 6) | ARRAY
	.word	0
	.word	4
	.word	acvspills + REFPTR
	.word	acvnames + REFPTR
	.word	acvleaf + REFPTR
	.word	acvprofile + REFPTR
	.word	acvintercepts + REFPTR
	.word	acvinterfns + REFPTR
aancill_end:
	.align 	8
acvspills:	.word	((aspills_end-acvspills-4) << 6) | ARRAY
	.word	0
	.word	4
	.word	0
aspills_end:
	.align 	8
acvnames:	.word	((anames_end-acvnames-4) << 6) | ARRAY
	.word	0
	.word	4
	.word	sa_name + POINTER
anames_end:
	.align	8
acvleaf:	.word	((aleaf_end-acvleaf-4) << 6) | ARRAY
	.word	0
	.word	4
	.word	0
aleaf_end:
a408 20
acvintercepts:	.word	((aintercepts_end-acvintercepts-4) << 6) | ARRAY
	.word	0
	.word	4
	.word	-4
aintercepts_end:
	.align	8
acvinterfns:	.word	((ainterfns_end-acvinterfns-4) << 6) | ARRAY
	.word	0
	.word	4
	.word	0
ainterfns_end:
	.align	8
acvprofile:	.word	((aprofile_end-acvprofile -4) << 6) | ARRAY
	.word	0
	.word	4
	.word	0
aprofile_end:
	.align 	8
	.word	((sa_end-stub_asm+4)<<6) | CODE
	.word	aancill + REFPTR
d410 3
a412 2
	.word	0x222			! Back pointer
	.word	0			! Code element zero
d417 2
a418 8
sa_end:	.align	8

sa_name:
	.word	((sa_name_end - sa_name - 4) << 6) | STRING
	.asciz	'stub to assembler'
sa_name_end:
	.align	4

@


1.2
log
@new file
@
text
@d26 3
d723 1
d745 1
@


1.1
log
@new file
@
text
@d25 4
a28 1
 * $Log: interface.m4s,v $
@
