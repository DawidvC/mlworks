head	1.11;
access;
symbols
	MLW_daveb_inline_1_4_99:1.11.1
	MLWorks_21c0_1999_03_25:1.11
	MLWorks_20c1_1998_08_20:1.11
	MLWorks_20c0_1998_08_04:1.11
	MLWorks_20b2c2_1998_06_19:1.11
	MLWorks_20b2_Windows_1998_06_12:1.11
	MLWorks_20b1c1_1998_05_07:1.11
	MLWorks_20b0_1998_04_07:1.11
	MLWorks_20b0_1998_03_20:1.10
	MLWorks_20m2_1998_02_16:1.9
	MLWorks_MM_adapt:1.9.3
	MLWorks_20m1_1997_10_23:1.9
	MLWorks_11r1:1.8.9.1.1.1.1
	MLWorks_workspace_97:1.9.2
	MLWorks_dt_wizard:1.9.1
	MLWorks_11c0_1997_09_09:1.8.9.1.1.1
	MLWorks_10r3:1.8.9.1.3
	MLWorks_10r2_551:1.8.9.1.2
	MLWorks_11:1.8.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.8.9.1
	MLWorks_20m0_1997_06_20:1.9
	MLWorks_1_0_r2c2_1997_06_14:1.8.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.8.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.8.9
	MLWorks_BugFix_1997_04_24:1.8
	MLWorks_1_0_r2_Win32_1997_04_11:1.8
	MLWorks_1_0_r2_Unix_1997_04_04:1.8
	MM_ML_release_korma_1997_04_01:1.8
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.7.1.1
	MLWorks_gui_1996_12_18:1.8.8
	MLWorks_1_0_Win32_1996_12_17:1.8.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.8.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.8.4.1
	JFHrts:1.8.6
	MLWorks_1_0_Irix_1996_11_28:1.8.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.8.5
	MLWorks_1_0_Unix_1996_11_14:1.8.4
	MLWorks_Open_Beta2_1996_10_11:1.8.3
	MLWorks_License_dev:1.8.2
	MLWorks_1_open_beta_1996_09_13:1.8.1
	MLWorks_Open_Beta_1996_08_22:1.8
	MLWorks_Beta_1996_07_02:1.8
	MLWorks_Beta_1996_06_07:1.8
	MLWorks_Beta_1996_06_06:1.8
	MLWorks_Beta_1996_06_05:1.8
	MLWorks_Beta_1996_06_03:1.8
	MLWorks_Beta_1996_05_31:1.8
	MLWorks_Beta_1996_05_30:1.8
	hope_poo:1.3.1
	ML_beta_release_12/08/94:1.3.1.1
	ML_beta_release_03/08/94:1.3;
locks; strict;
comment	@ * @;


1.11
date	98.03.26.14.50.51;	author jont;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	98.02.23.18.32.45;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	97.05.09.13.39.17;	author jont;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1;
next	1.8;

1.8
date	96.02.16.14.45.22;	author nickb;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1
	1.8.5.1
	1.8.6.1
	1.8.7.1
	1.8.8.1
	1.8.9.1;
next	1.7;

1.7
date	96.02.13.17.36.41;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	96.01.11.17.28.32;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	95.10.31.11.46.16;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	95.01.13.14.58.53;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.06.29.16.14.43;	author nickh;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	94.06.09.14.52.52;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.11.28.21;	author nickh;	state Exp;
branches;
next	;

1.3.1.1
date	95.07.05.10.28.21;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	96.09.13.11.22.13;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.10.07.16.12.18;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.10.17.11.31.15;	author hope;	state Exp;
branches;
next	;

1.8.4.1
date	96.11.14.12.57.12;	author hope;	state Exp;
branches
	1.8.4.1.1.1;
next	;

1.8.4.1.1.1
date	96.11.28.15.07.24;	author hope;	state Exp;
branches;
next	;

1.8.5.1
date	96.11.22.18.15.04;	author hope;	state Exp;
branches;
next	;

1.8.6.1
date	96.12.17.10.01.51;	author hope;	state Exp;
branches;
next	;

1.8.7.1
date	96.12.17.17.53.35;	author hope;	state Exp;
branches
	1.8.7.1.1.1;
next	;

1.8.7.1.1.1
date	97.02.24.11.44.35;	author hope;	state Exp;
branches;
next	;

1.8.8.1
date	96.12.18.09.48.09;	author hope;	state Exp;
branches;
next	;

1.8.9.1
date	97.05.12.10.40.33;	author hope;	state Exp;
branches
	1.8.9.1.1.1
	1.8.9.1.2.1
	1.8.9.1.3.1;
next	;

1.8.9.1.1.1
date	97.07.28.18.25.12;	author daveb;	state Exp;
branches
	1.8.9.1.1.1.1.1;
next	;

1.8.9.1.1.1.1.1
date	97.10.07.11.51.06;	author jkbrook;	state Exp;
branches;
next	;

1.8.9.1.2.1
date	97.09.08.17.18.26;	author daveb;	state Exp;
branches;
next	;

1.8.9.1.3.1
date	97.09.09.14.14.37;	author daveb;	state Exp;
branches;
next	;

1.9.1.1
date	97.09.10.19.31.06;	author brucem;	state Exp;
branches;
next	;

1.9.2.1
date	97.09.11.21.00.43;	author daveb;	state Exp;
branches;
next	;

1.9.3.1
date	97.10.31.13.43.45;	author nickb;	state Exp;
branches;
next	;

1.11.1.1
date	99.04.01.18.00.46;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.11
log
@[Bug #30090]
Remove MLWorks.IO based stuff
@
text
@/*  ==== PERVASIVE STREAMS ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Implementation
 *  --------------
 *  The ML stream type is a pair record containing a FILE * and the `name'
 *  of the stream (usually the filename it was opened with).  A stream is
 *  marked as closed by setting the FILE * to NULL.
 *
 *  The std_in, std_out, and std_err streams visible from ML are global
 *  roots which are fixed up to point at the C stdin, stdout, and stderr
 *  streams, and so persist across images.  All other streams are kept on a
 *  weak list and splatted with NULL when an image is reloaded.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:streams.c,v $
 * Revision 1.10  1998/02/23  18:32:45  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.9  1997/05/09  13:39:17  jont
 * [Bug #30091]
 * Remove MLWorks.Internal.FileIO and related stuff
 *
 * Revision 1.8  1996/02/16  14:45:22  nickb
 * Change to declare_global().
 *
 * Revision 1.7  1996/02/13  17:36:41  jont
 * Add some type casts to allow compilation without warnings under VC++
 *
 * Revision 1.6  1996/01/11  17:28:32  nickb
 * Runtime error message buffer problem.
 *
 * Revision 1.5  1995/10/31  11:46:16  jont
 * Ensure write errors during flush and close are detected
 *
 * Revision 1.4  1995/01/13  14:58:53  jont
 * Change file opening to be binary mode
 *
 * Revision 1.3  1994/06/29  16:14:43  nickh
 * Add message stream functions.
 *
 * Revision 1.2  1994/06/09  14:52:52  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:28:21  nickh
 * new file
 *
 *  Revision 1.10  1994/01/28  17:39:42  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.9  1993/11/18  10:55:54  nickh
 *  Add "stream closed" function to test closed-ness of a stream.
 *
 *  Revision 1.8  1993/11/16  17:38:42  nickh
 *  Added root declaration and retraction in open_in().
 *
 *  Revision 1.7  1993/10/12  16:14:15  matthew
 *  Merging bug fixes
 *
 *  Revision 1.6.1.2  1993/10/11  14:34:08  matthew
 *  Added call to fsync before closing a file
 *  Workaround for problem on Solbournes
 *
 *  Revision 1.6.1.1  1993/04/23  10:41:00  jont
 *  Fork for bug fixing
 *
 *  Revision 1.6  1993/04/23  10:41:00  jont
 *  Added a stream output byte function
 *
 *  Revision 1.5  1993/04/20  12:48:37  richard
 *  Replaced safe_exn_raise_format() with exn_raise_strings().
 *  Added several missing CSTRING() macros.
 *
 *  Revision 1.4  1993/03/31  17:04:53  jont
 *  Fixed output of filenames to be longer and to indicate when they are truncated
 *
 *  Revision 1.3  1993/02/01  16:13:16  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.2  1992/12/24  12:47:59  clive
 *  Changed to error messages to avoid overflowing the buffer in exn_raise_format
 *
 *  Revision 1.1  1992/10/26  16:43:06  richard
 *  Initial revision
 *
 */

#include <stdio.h>
#include <string.h>

#include "streams.h"
#include "allocator.h"
#include "exceptions.h"
#include "utils.h"
#include "environment.h"

static mlval message_output(mlval arg)
{
  if (messager_function)
    messager_function(CSTRING(arg));
  else
    fputs(CSTRING(arg),stderr);
  return MLUNIT;
}

static mlval message_flush(mlval unit)
{
  if (messager_function) {
    if (message_flusher)
      message_flusher();
  } else if(fflush(stderr) == EOF)
    exn_raise_syserr(ml_string("Cannot flush message stream : error on stderr"), 0);
  return MLUNIT;
}

/*  === INITIALISE ===  */

void streams_init()
{
  env_function("stream message output",message_output);
  env_function("stream message flush",message_flush);
}
@


1.11.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a18 4
 * Revision 1.11  1998/03/26  14:50:51  jont
 * [Bug #30090]
 * Remove MLWorks.IO based stuff
 *
@


1.10
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d19 5
a93 1
#include <memory.h>
a94 2
#include "ansi.h"
#include "syscalls.h"
a95 2
#include "mltypes.h"
#include "values.h"
a96 1
#include "pervasives.h"
a98 1
#include "gc.h"
a99 272
#include "global.h"
#include "os.h"

/*  == Local roots ==  */

static mlval foo, bar;


/*  == Standard streams ==  */

static mlval std_in, std_out, std_err;


/*  == Other streams ==
 *
 *  Opened streams are added to a weak list of streams so that they can be
 *  located and closed when an image is loaded.
 */

static mlval streams;


/*  == Fix standard streams ==
 *
 *  The standard streams can be fixed up across image saves and loads.
 */

static void fix_std_streams(const char *name, mlval *root, mlval value)
{
  if(root == &std_in)
    FIELD(value, 0) = (mlval)stdin;
  else if(root == &std_out)
    FIELD(value, 0) = (mlval)stdout;
  else if(root == &std_err)
    FIELD(value, 0) = (mlval)stderr;
  else
    error("fix_std_streams was called on a unknown root 0x%X", root);

  *root = value;
}


/*  == Fix other streams ==
 *
 *  Fix other streams by closing them.
 */

static mlval fix_close(unsigned int index, mlval stream)
{
  if(FIELD(stream, 0) != (mlval)NULL)
  {
    message_start();
    message_string("Warning: Stream opened to file `");
    message_string(CSTRING(FIELD(stream, 1)));
    message_string("' is now closed.");
    message_end();
    FIELD(stream, 0) = (mlval)NULL;
  }

  return(stream);
}

static void fix_streams(const char *name, mlval *root, mlval value)
{
  weak_apply(value, fix_close);
  *root = value;
}


/*  === OPEN INPUT STREAM ===
 *
 *  MLWorks.IO.open_in
 */

static mlval open_in(mlval argument)
{
  FILE *f = fopen(CSTRING(argument), "rb");
  mlval stream;

  if(f == NULL)
    exn_raise_strings(perv_exn_ref_io, "Cannot open ", CSTRING(argument), NULL);

  foo = argument;
  stream = allocate_record(2);
  FIELD(stream, 0) = (mlval)f;
  FIELD(stream, 1) = foo;
  declare_root(&stream, 0);
  streams = weak_add(streams, stream);
  retract_root(&stream);
  foo = MLUNIT;

  return(stream);
}

static mlval ml_close(mlval argument)
{
  FILE *f = (FILE *)FIELD(argument, 0);

  if(f == NULL)
    exn_raise_strings(perv_exn_ref_io,
		     "Cannot close ", CSTRING(FIELD(argument, 1)), ": already closed", NULL);

  if (fflush(f) != 0)
    exn_raise_strings(perv_exn_ref_io,
		     "Cannot close ", CSTRING(FIELD(argument, 1)), ": fflush failed", NULL);
  os_filesync(f);
  if (fclose(f) != 0)
    exn_raise_strings(perv_exn_ref_io,
		     "Cannot close ", CSTRING(FIELD(argument, 1)), ": fclose failed", NULL);
  FIELD(argument, 0) = (mlval)NULL;

  return(MLUNIT);
}

static mlval open_out(mlval argument)
{
  FILE *f = fopen(CSTRING(argument), "wb");
  mlval stream;

  if(f == NULL)
    exn_raise_strings(perv_exn_ref_io, "Cannot open ", CSTRING(argument), NULL);

  foo = argument;
  stream = allocate_record(2);
  FIELD(stream, 0) = (mlval)f;
  FIELD(stream, 1) = foo;
  foo = MLUNIT;

  return(stream);
}

static mlval clear_eof(mlval argument)
{
  mlval stream = argument;
  FILE *f = (FILE *)FIELD(stream, 0);

  if(f == NULL)
    exn_raise_strings(perv_exn_ref_io,
		     "Cannot clear eof on ", CSTRING(FIELD(argument, 1)), ": closed", NULL);

  clearerr(f);
  return MLUNIT;
}

static mlval input_string(mlval argument)
{
  mlval stream = FIELD(argument, 0);
  FILE *f = (FILE *)FIELD(stream, 0);
  int amount = CINT(FIELD(argument, 1));
  int length;
  mlval string;

  if(f == NULL)
    exn_raise_strings(perv_exn_ref_io,
		      "Cannot input from ", CSTRING(FIELD(stream, 1)), ": closed", NULL);

  if(amount < 0)
    exn_raise_strings(perv_exn_ref_io,
		      "Cannot input from ", CSTRING(FIELD(stream, 1)),
		      ": negative argument", NULL);

  foo = stream;
  bar = allocate_string((unsigned int)(amount+1));
  length = fread(CSTRING(bar), sizeof(char), (unsigned int) amount, f);

  if(length == amount)
  {
    string = bar;
    CSTRING(string)[amount] = '\0';
    foo = bar = MLUNIT;
    return(string);
  }

  if(ferror(f))
  {
    char *name = CSTRING(FIELD(foo, 1));

    foo = bar = MLUNIT;
    exn_raise_strings(perv_exn_ref_io,
		      "Cannot input from ", name, ": error on stream", NULL);
  }

  string = allocate_string((size_t) (length+1));
  memcpy(CSTRING(string), CSTRING(bar), (size_t) length);
  CSTRING(string)[length] = '\0';
  foo = bar = MLUNIT;
  return(string);
}

static mlval output_string(mlval argument)
{
  mlval stream = FIELD(argument, 0);
  FILE *f = (FILE *)FIELD(stream, 0);
  size_t length = CSTRINGLENGTH(FIELD(argument, 1));

  if(f == NULL)
    exn_raise_strings(perv_exn_ref_io,
		      "Cannot write to ", CSTRING(FIELD(FIELD(argument, 0), 1)),
		      ": closed", NULL);

  if(fwrite(CSTRING(FIELD(argument, 1)), sizeof(char), length, f) != length)
    exn_raise_strings(perv_exn_ref_io,
		      "Cannot write to ", CSTRING(FIELD(FIELD(argument, 0), 1)),
		      ": error on stream", NULL);

  return(MLUNIT);
}

static mlval output_byte(mlval argument)
{
  mlval stream = FIELD(argument, 0);
  FILE *f = (FILE *)FIELD(stream, 0);
  char i = (FIELD(argument, 1)) >> 2;

  if(fwrite(&i, sizeof(byte), 1, f) != 1)
    exn_raise_strings(perv_exn_ref_io,
		      "Cannot write to ", CSTRING(FIELD(stream, 1)),
		      ": error on stream", NULL);
  return(MLUNIT);
}

static mlval flush_out(mlval argument)
{
  FILE *f = (FILE *)FIELD(argument, 0);

  if(f == NULL)
    exn_raise_strings(perv_exn_ref_io,
		      "Cannot flush to ", CSTRING(FIELD(argument, 1)), ": closed", NULL);

  if(fflush(f) == EOF)
    exn_raise_strings(perv_exn_ref_io,
		      "Cannot flush to ", CSTRING(FIELD(argument, 1)),
		      ": error on stream", NULL);

  return(MLUNIT);
}

static mlval lookahead(mlval argument)
{
  FILE *f = (FILE *)FIELD(argument, 0);
  int c;
  mlval string;

  if(f == NULL)
    return(ml_string(""));	/* The Definition is crap in this respect */

  c = getc(f);

  if(c == EOF)
    return(ml_string(""));

  if(ungetc(c, f) == EOF)
    exn_raise_strings(perv_exn_ref_io,
		      "Cannot lookahead on ", CSTRING(FIELD(argument, 1)),
		      ": Unable to unget a character", NULL);

  string = allocate_string(2);
  CSTRING(string)[0] = c;
  CSTRING(string)[1] = '\0';

  return(string);
}

static mlval closed(mlval argument)
{
  FILE *f = (FILE *)FIELD(argument, 0);
  
  if (f == NULL)
    return MLTRUE;
  else
    return MLFALSE;
}
d116 1
a116 2
    exn_raise_string(perv_exn_ref_io,
		     "Cannot flush message stream : error on stderr");
a123 45
  foo = bar = MLUNIT;
  declare_root(&foo, 0);
  declare_root(&bar, 0);

  foo = ml_string("standard input");
  std_in = allocate_record(2);
  FIELD(std_in, 0) = (mlval)stdin;
  FIELD(std_in, 1) = foo;
  declare_global("pervasive stream std_in", &std_in, 
		 GLOBAL_DEFAULT, NULL, fix_std_streams, NULL);
  env_value("stream std_in", std_in);

  foo = ml_string("standard output");
  std_out = allocate_record(2);
  FIELD(std_out, 0) = (mlval)stdout;
  FIELD(std_out, 1) = foo;
  declare_global("pervasive stream std_out", &std_out,
		 GLOBAL_DEFAULT, NULL, fix_std_streams, NULL);
  env_value("stream std_out", std_out);

  foo = ml_string("standard error");
  std_err = allocate_record(2);
  FIELD(std_err, 0) = (mlval)stderr;
  FIELD(std_err, 1) = foo;
  declare_global("pervasive stream std_err", &std_err,
		 GLOBAL_DEFAULT, NULL, fix_std_streams, NULL);
  env_value("stream std_err", std_err);

  foo = MLUNIT;

  streams = weak_new(16);
  declare_global("pervasive streams", &streams,
		 GLOBAL_DEFAULT, NULL, fix_streams, NULL);

  env_function("stream open in", open_in);
  env_function("stream close in", ml_close);
  env_function("stream open out", open_out);
  env_function("stream close out", ml_close);
  env_function("stream clear eof", clear_eof);
  env_function("stream input string", input_string);
  env_function("stream output string", output_string);
  env_function("stream output byte", output_byte);
  env_function("stream flush out", flush_out);
  env_function("stream lookahead", lookahead);
  env_function("stream closed", closed);
@


1.9
log
@[Bug #30091]
Remove MLWorks.Internal.FileIO and related stuff
@
text
@d19 4
d188 1
a188 1
  declare_root(&stream);
d400 2
a401 2
  declare_root(&foo);
  declare_root(&bar);
@


1.9.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a18 4
 * Revision 1.9  1997/05/09  13:39:17  jont
 * [Bug #30091]
 * Remove MLWorks.Internal.FileIO and related stuff
 *
@


1.9.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a18 4
 * Revision 1.9  1997/05/09  13:39:17  jont
 * [Bug #30091]
 * Remove MLWorks.Internal.FileIO and related stuff
 *
@


1.9.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a18 4
 * Revision 1.9  1997/05/09  13:39:17  jont
 * [Bug #30091]
 * Remove MLWorks.Internal.FileIO and related stuff
 *
@


1.8
log
@Change to declare_global().
@
text
@d19 3
a228 51
static mlval open_update(mlval argument)
{
  FILE *f = fopen(CSTRING(argument), "wb+");
  mlval stream;

  if(f == NULL)
    exn_raise_strings(perv_exn_ref_io, "Cannot open ", CSTRING(argument), NULL);

  foo = argument;
  stream = allocate_record(2);
  FIELD(stream, 0) = (mlval)f;
  FIELD(stream, 1) = foo;
  streams = weak_add(streams, stream);
  foo = MLUNIT;

  return(stream);
}

static mlval seek_out(mlval argument)
{
  mlval stream = FIELD(argument, 0);
  FILE *f = (FILE *)FIELD(stream, 0);
  long offset = CINT(FIELD(argument, 1));
  int ptrname = CINT(FIELD(argument, 2));
  int result;

  switch(ptrname)
  {
    case 0:
    result = fseek(f, offset, SEEK_SET);
    break;

    case 1:
    result = fseek(f, offset, SEEK_CUR);
    break;

    case 2:
    result = fseek(f, offset, SEEK_END);
    break;

    default:
    error("stream seek out called with illegal pointer name %d", ptrname);
  }

  if(result)
    exn_raise_strings(perv_exn_ref_io,
		     "Failed to seek on ", CSTRING(FIELD(FIELD(argument, 0), 1)), NULL);

  return(MLUNIT);
}

a318 26
static mlval output_bytearray(mlval argument)
{
  mlval stream = FIELD(argument, 0);
  FILE *f = (FILE *)FIELD(stream, 0);
  int size = LENGTH(FIELD(argument, 1));
  int offset = CINT(FIELD(argument, 2));
  int length = CINT(FIELD(argument, 3));

  if(offset < 0 || offset + length > size)
    exn_raise_strings(perv_exn_ref_io,
		      "Cannot write to ", CSTRING(FIELD(stream, 1)),
		      ": parameters outside bytearray", NULL);

  if(f == NULL)
    exn_raise_strings(perv_exn_ref_io,
		      "Cannot write to ", CSTRING(FIELD(stream, 1)), ": closed", NULL);

  if(fwrite(CBYTEARRAY(FIELD(argument, 1))+offset, sizeof(byte),
	    (unsigned int) length, f) != (unsigned)length)
    exn_raise_strings(perv_exn_ref_io,
		      "Cannot write to ", CSTRING(FIELD(stream, 1)),
		      ": error on stream", NULL);

  return(MLUNIT);
}

a432 2
  env_function("stream open update", open_update);
  env_function("stream seek out", seek_out);
a436 1
  env_function("stream output bytearray", output_bytearray);
@


1.8.9.1
log
@branched from 1.8
@
text
@a18 3
 * Revision 1.8  1996/02/16  14:45:22  nickb
 * Change to declare_global().
 *
@


1.8.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a18 3
 * Revision 1.8.9.1  1997/05/12  10:40:33  hope
 * branched from 1.8
 *
@


1.8.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a18 3
 * Revision 1.8.9.1  1997/05/12  10:40:33  hope
 * branched from 1.8
 *
@


1.8.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a18 3
 * Revision 1.8.9.1  1997/05/12  10:40:33  hope
 * branched from 1.8
 *
@


1.8.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a18 3
 * Revision 1.8.9.1.1.1  1997/07/28  18:25:12  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.8.8.1
log
@branched from 1.8
@
text
@a18 3
 * Revision 1.8  1996/02/16  14:45:22  nickb
 * Change to declare_global().
 *
@


1.8.7.1
log
@branched from 1.8
@
text
@a18 3
 * Revision 1.8  1996/02/16  14:45:22  nickb
 * Change to declare_global().
 *
@


1.8.7.1.1.1
log
@branched from 1.8.7.1
@
text
@a18 3
 * Revision 1.8.7.1  1996/12/17  17:53:35  hope
 * branched from 1.8
 *
@


1.8.6.1
log
@branched from 1.8
@
text
@a18 3
 * Revision 1.8  1996/02/16  14:45:22  nickb
 * Change to declare_global().
 *
@


1.8.5.1
log
@branched from 1.8
@
text
@a18 3
 * Revision 1.8  1996/02/16  14:45:22  nickb
 * Change to declare_global().
 *
@


1.8.4.1
log
@branched from 1.8
@
text
@a18 3
 * Revision 1.8  1996/02/16  14:45:22  nickb
 * Change to declare_global().
 *
@


1.8.4.1.1.1
log
@branched from 1.8.4.1
@
text
@a18 3
 * Revision 1.8.4.1  1996/11/14  12:57:12  hope
 * branched from 1.8
 *
@


1.8.3.1
log
@branched from 1.8
@
text
@a18 3
 * Revision 1.8  1996/02/16  14:45:22  nickb
 * Change to declare_global().
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a18 3
 * Revision 1.8  1996/02/16  14:45:22  nickb
 * Change to declare_global().
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a18 3
 * Revision 1.8  1996/02/16  14:45:22  nickb
 * Change to declare_global().
 *
@


1.7
log
@Add some type casts to allow compilation without warnings under VC++
@
text
@d19 3
d122 1
a122 1
static void fix_std_streams(mlval *root, mlval value)
d157 1
a157 1
static void fix_streams(mlval *root, mlval value)
d477 2
a478 1
  declare_global("pervasive stream std_in", &std_in, fix_std_streams);
d485 2
a486 1
  declare_global("pervasive stream std_out", &std_out, fix_std_streams);
d493 2
a494 1
  declare_global("pervasive stream std_err", &std_err, fix_std_streams);
d500 2
a501 1
  declare_global("pervasive streams", &streams, fix_streams);
@


1.6
log
@Runtime error message buffer problem.
@
text
@d19 3
d382 1
a382 1
	    (unsigned int) length, f) != length)
@


1.5
log
@Ensure write errors during flush and close are detected
@
text
@d19 3
d140 5
a144 1
    message("Warning: Stream opened to file `%s' is now closed.", CSTRING(FIELD(stream, 1)));
@


1.4
log
@Change file opening to be binary mode
@
text
@d19 3
d184 3
a186 1
  (void)fflush(f);
d188 3
a190 1
  (void)fclose(f);
@


1.3
log
@Add message stream functions.
@
text
@d19 3
d155 1
a155 1
  FILE *f = fopen(CSTRING(argument), "r");
d191 1
a191 1
  FILE *f = fopen(CSTRING(argument), "w");
d208 1
a208 1
  FILE *f = fopen(CSTRING(argument), "w+");
@


1.3.1.1
log
@branched from 1.3
@
text
@a18 3
 * Revision 1.3  1994/06/29  16:14:43  nickh
 * Add message stream functions.
 *
@


1.2
log
@new file
@
text
@d19 3
d422 20
d490 2
@


1.1
log
@new file
@
text
@d18 4
a21 1
 *  $Log: streams.c,v $
@
