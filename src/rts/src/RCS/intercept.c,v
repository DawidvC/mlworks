head	1.9;
access;
symbols
	MLW_daveb_inline_1_4_99:1.9.13
	MLWorks_21c0_1999_03_25:1.9
	MLWorks_20c1_1998_08_20:1.9
	MLWorks_20c0_1998_08_04:1.9
	MLWorks_20b2c2_1998_06_19:1.9
	MLWorks_20b2_Windows_1998_06_12:1.9
	MLWorks_20b1c1_1998_05_07:1.9
	MLWorks_20b0_1998_04_07:1.9
	MLWorks_20b0_1998_03_20:1.9
	MLWorks_20m2_1998_02_16:1.9
	MLWorks_MM_adapt:1.9.12
	MLWorks_20m1_1997_10_23:1.9
	MLWorks_11r1:1.9.9.1.1.1.1
	MLWorks_workspace_97:1.9.11
	MLWorks_dt_wizard:1.9.10
	MLWorks_11c0_1997_09_09:1.9.9.1.1.1
	MLWorks_10r3:1.9.9.1.3
	MLWorks_10r2_551:1.9.9.1.2
	MLWorks_11:1.9.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.9.9.1
	MLWorks_20m0_1997_06_20:1.9
	MLWorks_1_0_r2c2_1997_06_14:1.9.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.9.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.9.9
	MLWorks_BugFix_1997_04_24:1.9
	MLWorks_1_0_r2_Win32_1997_04_11:1.9
	MLWorks_1_0_r2_Unix_1997_04_04:1.9
	MM_ML_release_korma_1997_04_01:1.9
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.9.7.1.1
	MLWorks_gui_1996_12_18:1.9.8
	MLWorks_1_0_Win32_1996_12_17:1.9.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.9.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.9.4.1
	JFHrts:1.9.6
	MLWorks_1_0_Irix_1996_11_28:1.9.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.9.5
	MLWorks_1_0_Unix_1996_11_14:1.9.4
	MLWorks_Open_Beta2_1996_10_11:1.9.3
	MLWorks_License_dev:1.9.2
	MLWorks_1_open_beta_1996_09_13:1.9.1
	MLWorks_Open_Beta_1996_08_22:1.9
	MLWorks_Beta_1996_07_02:1.9
	MLWorks_Beta_1996_06_07:1.9
	MLWorks_Beta_1996_06_06:1.9
	MLWorks_Beta_1996_06_05:1.9
	MLWorks_Beta_1996_06_03:1.9
	MLWorks_Beta_1996_05_31:1.9
	MLWorks_Beta_1996_05_30:1.9
	hope_poo:1.4.1
	ML_beta_release_12/08/94:1.4.1.1
	ML_beta_release_03/08/94:1.4;
locks; strict;
comment	@ * @;


1.9
date	96.01.08.15.56.35;	author stephenb;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1
	1.9.4.1
	1.9.5.1
	1.9.6.1
	1.9.7.1
	1.9.8.1
	1.9.9.1
	1.9.10.1
	1.9.11.1
	1.9.12.1
	1.9.13.1;
next	1.8;

1.8
date	95.09.01.14.33.04;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.08.31.13.06.43;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	94.11.15.15.38.27;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	94.10.19.14.29.43;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	94.07.13.16.34.26;	author jont;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	94.06.21.15.59.15;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.39.33;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.11.06.59;	author nickh;	state Exp;
branches;
next	;

1.4.1.1
date	95.07.05.10.31.58;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	96.09.13.11.24.00;	author hope;	state Exp;
branches;
next	;

1.9.2.1
date	96.10.07.16.14.18;	author hope;	state Exp;
branches;
next	;

1.9.3.1
date	96.10.17.11.33.44;	author hope;	state Exp;
branches;
next	;

1.9.4.1
date	96.11.14.12.59.24;	author hope;	state Exp;
branches
	1.9.4.1.1.1;
next	;

1.9.4.1.1.1
date	96.11.28.15.09.24;	author hope;	state Exp;
branches;
next	;

1.9.5.1
date	96.11.22.18.17.07;	author hope;	state Exp;
branches;
next	;

1.9.6.1
date	96.12.17.10.03.52;	author hope;	state Exp;
branches;
next	;

1.9.7.1
date	96.12.17.17.55.28;	author hope;	state Exp;
branches
	1.9.7.1.1.1;
next	;

1.9.7.1.1.1
date	97.02.24.11.46.46;	author hope;	state Exp;
branches;
next	;

1.9.8.1
date	96.12.18.09.50.04;	author hope;	state Exp;
branches;
next	;

1.9.9.1
date	97.05.12.10.43.45;	author hope;	state Exp;
branches
	1.9.9.1.1.1
	1.9.9.1.2.1
	1.9.9.1.3.1;
next	;

1.9.9.1.1.1
date	97.07.28.18.25.53;	author daveb;	state Exp;
branches
	1.9.9.1.1.1.1.1;
next	;

1.9.9.1.1.1.1.1
date	97.10.07.11.51.39;	author jkbrook;	state Exp;
branches;
next	;

1.9.9.1.2.1
date	97.09.08.17.19.08;	author daveb;	state Exp;
branches;
next	;

1.9.9.1.3.1
date	97.09.09.14.15.16;	author daveb;	state Exp;
branches;
next	;

1.9.10.1
date	97.09.10.19.32.12;	author brucem;	state Exp;
branches;
next	;

1.9.11.1
date	97.09.11.21.01.32;	author daveb;	state Exp;
branches;
next	;

1.9.12.1
date	97.10.31.13.44.29;	author nickb;	state Exp;
branches;
next	;

1.9.13.1
date	99.04.01.18.01.13;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.9
log
@Remove reference to %i0, fixing bug 744.
@
text
@/*  ==== CODE VECTOR INTERCEPTION ====
 *
 *  Copyright (C) 1993 Harlequin Ltd
 *
 *  Implementation
 *  --------------
 *  This is rather SPARC specific and will need to be moved later.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:intercept.c,v $
 * Revision 1.8  1995/09/01  14:33:04  nickb
 * Add CCODE_UNIT_SIZE
 *
 * Revision 1.7  1995/08/31  13:06:43  nickb
 * Change INTERCEPT_LENGTH to allow platform-specific values.
 *
 * Revision 1.6  1994/11/15  15:38:27  nickb
 * Add cache flushing.
 *
 * Revision 1.5  1994/10/19  14:29:43  nickb
 * Use the invalid value from the code_status enum.
 *
 * Revision 1.4  1994/07/13  16:34:26  jont
 * Remove references to i0 for the moment
 *
 * Revision 1.3  1994/06/21  15:59:15  nickh
 * New ancillary structure.
 *
 * Revision 1.2  1994/06/09  14:39:33  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:06:59  nickh
 * new file
 *
 *  Revision 1.4  1993/06/02  13:04:42  richard
 *  Added missing parameters to memcmp() calls.
 *
 *  Revision 1.3  1993/05/18  14:11:32  richard
 *  Added call counting for the profiler.
 *
 *  Revision 1.2  1993/04/26  14:51:09  richard
 *  Increased diagnostic levels.
 *
 *  Revision 1.1  1993/04/15  14:22:46  richard
 *  Initial revision
 *
 */

#include "values.h"
#include "intercept.h"
#include "interface.h"
#include "tags.h"
#include "diagnostic.h"
#include "extensions.h"
#include "profiler.h"
#include "utils.h"
#include "cache.h"

#include <errno.h>
#include <memory.h>

static int blat(mlval code, byte *new)
{
  byte *start;
  int offset;

  DIAGNOSTIC(4, "blat(code = 0x%X, new = 0x%X)", code, new);

  /* Check that the parameter is actually a code object */

  if(PRIMARY(code) != POINTER || SECONDARY(GETHEADER(code)) != BACKPTR)
  {
    DIAGNOSTIC(4, "  not code!", 0, 0);
    errno = EINTERCEPTCODE;
    return(-1);
  }

  /* Check that it can be intercepted */

  offset = CCODEINTERCEPT(code);
  DIAGNOSTIC(4, "  offset = %d", offset, 0);

  if(offset == CCODE_NO_INTERCEPT)
  {
    errno = EINTERCEPTFORM;
    return(-1);
  }

  /* Copy the intercepting instructions into the slot */

  start = (byte*)CCODESTART(code) + offset * CCODE_UNIT_SIZE;
  memcpy(start, new, INTERCEPT_LENGTH);
  cache_flush((void*)start,INTERCEPT_LENGTH);

  return(0);
}

int code_intercept(mlval code)
{
  DIAGNOSTIC(4, "code_intercept(0x%X)  name `%s'", code, CSTRING(CCODENAME(code)));

  return(blat(code,
	      CCODELEAF(code) ? ml_intercept_on_leaf : ml_intercept_on));
}

int code_replace(mlval code)
{
  DIAGNOSTIC(4, "code_replace(0x%X)  name `%s'", code, CSTRING(CCODENAME(code)));

  return(blat(code,
	      CCODELEAF(code) ? ml_replace_on_leaf : ml_replace_on));
}

int code_nop(mlval code)
{
  DIAGNOSTIC(4, "code_nop(0x%X)  name `%s'", code, CSTRING(CCODENAME(code)));

  /* If call-count profiling is operating on this code then change to */
  /* interception rather than nothing. */

  if((unsigned int *)CCODEPROFILE(code) != NULL)
    return(blat(code,
		CCODELEAF(code) ? ml_intercept_on_leaf : ml_intercept_on));
  else
    return(blat(code, ml_nop));
}

enum code_status code_status(mlval code)
{
  byte *start;
  int offset;

  if(PRIMARY(code) != POINTER || SECONDARY(GETHEADER(code)) != BACKPTR)
  {
    errno = EINTERCEPTCODE;
    return CS_INVALID;
  }

  offset = CCODEINTERCEPT(code);

  if(offset == CCODE_NO_INTERCEPT)
  {
    errno = EINTERCEPTFORM;
    return CS_INVALID;
  }

  start = (byte *)CCODESTART(code) + offset * CCODE_UNIT_SIZE;

  if(!memcmp(start, ml_nop, INTERCEPT_LENGTH))
    return(CS_NOP);
  else if(!memcmp(start, ml_intercept_on, INTERCEPT_LENGTH) ||
	  !memcmp(start, ml_intercept_on_leaf, INTERCEPT_LENGTH))
    return(CS_INTERCEPT);
  else if(!memcmp(start, ml_replace_on, INTERCEPT_LENGTH) ||
	  !memcmp(start, ml_replace_on_leaf, INTERCEPT_LENGTH))
    return(CS_REPLACE);

  error("code_status: code 0x%X has unrecognisable instructions in its intercept slot");
}

static inline void count_call(mlval code)
{
  unsigned int *count = (unsigned int *)CCODEPROFILE(code);
  if(count != NULL && !profile_suspended)
    ++*count;
}

void intercept(struct stack_frame *frame)
{
  mlval code, f;

  flush_windows();
  code = FIELD(frame->closure, 0);
  f = CCODEINTERFN(code);

  DIAGNOSTIC(2, "intercept(frame = 0x%X)", frame, 0);
  DIAGNOSTIC(2, "  function `%s'  intercept function `%s'",
	        CSTRING(CCODENAME(code)), CSTRING(CCODENAME(FIELD(f, 0))));
  DIAGNOSTIC(2, "  closure = 0x%X", frame->closure, 0);

  count_call(code);

  if(f != MLUNIT)
    callml((mlval)frame, f);
}

void replace(struct stack_frame *frame)
{
  mlval code, f;

  flush_windows();
  code = FIELD(frame->closure, 0);
  f = CCODEINTERFN(code);

  DIAGNOSTIC(2, "replace(frame = 0x%X)", frame, 0);
  DIAGNOSTIC(2, "  function `%s'  replace function `%s'",
	        CSTRING(CCODENAME(code)), CSTRING(CCODENAME(FIELD(f, 0))));
  DIAGNOSTIC(2, "  closure = 0x%X", frame->closure, 0);

  count_call(code);

  if(f != MLUNIT)
    callml((mlval)frame, f);
}

@


1.9.13.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.9.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.9.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.9.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.9.9.1
log
@branched from 1.9
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.9.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 * Revision 1.9.9.1  1997/05/12  10:43:45  hope
 * branched from 1.9
 *
@


1.9.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 * Revision 1.9.9.1  1997/05/12  10:43:45  hope
 * branched from 1.9
 *
@


1.9.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 * Revision 1.9.9.1  1997/05/12  10:43:45  hope
 * branched from 1.9
 *
@


1.9.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 3
 * Revision 1.9.9.1.1.1  1997/07/28  18:25:53  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.9.8.1
log
@branched from 1.9
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.9.7.1
log
@branched from 1.9
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.9.7.1.1.1
log
@branched from 1.9.7.1
@
text
@a11 3
 * Revision 1.9.7.1  1996/12/17  17:55:28  hope
 * branched from 1.9
 *
@


1.9.6.1
log
@branched from 1.9
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.9.5.1
log
@branched from 1.9
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.9.4.1
log
@branched from 1.9
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.9.4.1.1.1
log
@branched from 1.9.4.1
@
text
@a11 3
 * Revision 1.9.4.1  1996/11/14  12:59:24  hope
 * branched from 1.9
 *
@


1.9.3.1
log
@branched from 1.9
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.9.2.1
log
@branched from 1.9
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.9.1.1
log
@branched from 1.9
@
text
@a11 3
 * Revision 1.9  1996/01/08  15:56:35  stephenb
 * Remove reference to %i0, fixing bug 744.
 *
@


1.8
log
@Add CCODE_UNIT_SIZE
@
text
@d12 3
a179 3
/*
  DIAGNOSTIC(2, "  closure = 0x%X  arg = 0x%X", frame->closure, frame->i0);
*/
a198 3
/*
  DIAGNOSTIC(2, "  closure = 0x%X  arg = 0x%X", frame->closure, frame->i0);
*/
@


1.7
log
@Change INTERCEPT_LENGTH to allow platform-specific values.
@
text
@d12 3
d62 1
a62 1
  word *start;
d89 1
a89 1
  start = CCODESTART(code) + offset;
d128 1
a128 1
  word *start;
d145 1
a145 1
  start = CCODESTART(code) + offset;
d149 2
a150 2
  else if(!memcmp(start, ml_intercept, INTERCEPT_LENGTH) ||
	  !memcmp(start, ml_intercept_leaf, INTERCEPT_LENGTH))
d152 2
a153 2
  else if(!memcmp(start, ml_replace, INTERCEPT_LENGTH) ||
	  !memcmp(start, ml_replace_leaf, INTERCEPT_LENGTH))
@


1.6
log
@Add cache flushing.
@
text
@d12 3
d57 1
a57 3
#define INTERCEPT_BYTES	(sizeof(word)*INTERCEPT_LENGTH)

static int blat(mlval code, word *new)
d87 2
a88 2
  memcpy(start, new, INTERCEPT_BYTES);
  cache_flush((void*)start,INTERCEPT_BYTES);
d144 1
a144 1
  if(!memcmp(start, ml_nop, INTERCEPT_BYTES))
d146 2
a147 2
  else if(!memcmp(start, ml_intercept, INTERCEPT_BYTES) ||
	  !memcmp(start, ml_intercept_leaf, INTERCEPT_BYTES))
d149 2
a150 2
  else if(!memcmp(start, ml_replace, INTERCEPT_BYTES) ||
	  !memcmp(start, ml_replace_leaf, INTERCEPT_BYTES))
@


1.5
log
@Use the invalid value from the code_status enum.
@
text
@d12 3
d49 1
d87 1
@


1.4
log
@Remove references to i0 for the moment
@
text
@d12 3
d125 1
a125 1
    return(-1);
d133 1
a133 1
    return(-1);
@


1.4.1.1
log
@branched from 1.4
@
text
@a11 3
 * Revision 1.4  1994/07/13  16:34:26  jont
 * Remove references to i0 for the moment
 *
@


1.3
log
@New ancillary structure.
@
text
@d12 3
d165 1
d167 2
d187 1
d189 2
@


1.2
log
@new file
@
text
@d12 3
d64 1
a64 1
  offset = CINT(CCODEANCSUB(code, INTERCEPTS));
d67 1
a67 1
  if(offset == -1)
d86 1
a86 2
	      CCODEANCSUB(code, LEAFS) == MLTRUE ?
	        ml_intercept_on_leaf : ml_intercept_on));
d94 1
a94 2
	      CCODEANCSUB(code, LEAFS) == MLTRUE ?
	        ml_replace_on_leaf : ml_replace_on));
d104 1
a104 1
  if((unsigned int *)CCODEANCSUB(code, PROFILES) != NULL)
d106 1
a106 2
		CCODEANCSUB(code, LEAFS) == MLTRUE ?
	          ml_intercept_on_leaf : ml_intercept_on));
d122 1
a122 1
  offset = CINT(CCODEANCSUB(code, INTERCEPTS));
d124 1
a124 1
  if(offset == -1)
d146 1
a146 1
  unsigned int *count = (unsigned int *)CCODEANCSUB(code, PROFILES);
d157 1
a157 1
  f = CCODEANCSUB(code, INTERFNS);
d176 1
a176 1
  f = CCODEANCSUB(code, INTERFNS);
d188 1
@


1.1
log
@new file
@
text
@d11 4
a14 1
 *  $Log: intercept.c,v $
@
