head	1.5;
access;
symbols
	MLW_daveb_inline_1_4_99:1.5.1
	MLWorks_21c0_1999_03_25:1.5
	MLWorks_20c1_1998_08_20:1.4
	MLWorks_20c0_1998_08_04:1.4
	MLWorks_20b2c2_1998_06_19:1.4
	MLWorks_20b2_Windows_1998_06_12:1.4
	MLWorks_20b1c1_1998_05_07:1.4
	MLWorks_20b0_1998_04_07:1.3
	MLWorks_20b0_1998_03_20:1.3
	MLWorks_20m2_1998_02_16:1.3
	MLWorks_MM_adapt:1.3.12
	MLWorks_20m1_1997_10_23:1.3
	MLWorks_11r1:1.3.9.1.1.1.1
	MLWorks_workspace_97:1.3.11
	MLWorks_dt_wizard:1.3.10
	MLWorks_11c0_1997_09_09:1.3.9.1.1.1
	MLWorks_10r3:1.3.9.1.3
	MLWorks_10r2_551:1.3.9.1.2
	MLWorks_11:1.3.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.9.1
	MLWorks_20m0_1997_06_20:1.3
	MLWorks_1_0_r2c2_1997_06_14:1.3.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.3.9
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3
	MM_ML_release_korma_1997_04_01:1.3
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.3.7.1.1
	MLWorks_gui_1996_12_18:1.3.8
	MLWorks_1_0_Win32_1996_12_17:1.3.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.3.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.3.4.1
	JFHrts:1.3.6
	MLWorks_1_0_Irix_1996_11_28:1.3.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.3.5
	MLWorks_1_0_Unix_1996_11_14:1.3.4
	MLWorks_Open_Beta2_1996_10_11:1.3.3
	MLWorks_License_dev:1.3.2
	MLWorks_1_open_beta_1996_09_13:1.3.1
	MLWorks_Open_Beta_1996_08_22:1.3
	MLWorks_Beta_1996_07_02:1.3
	MLWorks_Beta_1996_06_07:1.3
	MLWorks_Beta_1996_06_06:1.3
	MLWorks_Beta_1996_06_05:1.3
	MLWorks_Beta_1996_06_03:1.3
	MLWorks_Beta_1996_05_31:1.3
	MLWorks_Beta_1996_05_30:1.3
	hope_poo:1.2.1
	ML_beta_release_12/08/94:1.2.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.5
date	98.07.29.12.54.57;	author jont;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	98.04.23.13.43.57;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	95.07.17.08.58.34;	author nickb;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1
	1.3.4.1
	1.3.5.1
	1.3.6.1
	1.3.7.1
	1.3.8.1
	1.3.9.1
	1.3.10.1
	1.3.11.1
	1.3.12.1;
next	1.2;

1.2
date	94.06.09.14.46.07;	author nickh;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	94.06.09.11.16.07;	author nickh;	state Exp;
branches;
next	;

1.2.1.1
date	95.07.05.10.29.32;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	96.09.13.11.22.43;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.10.07.16.12.49;	author hope;	state Exp;
branches;
next	;

1.3.3.1
date	96.10.17.11.31.59;	author hope;	state Exp;
branches;
next	;

1.3.4.1
date	96.11.14.12.58.00;	author hope;	state Exp;
branches
	1.3.4.1.1.1;
next	;

1.3.4.1.1.1
date	96.11.28.15.07.59;	author hope;	state Exp;
branches;
next	;

1.3.5.1
date	96.11.22.18.15.39;	author hope;	state Exp;
branches;
next	;

1.3.6.1
date	96.12.17.10.02.22;	author hope;	state Exp;
branches;
next	;

1.3.7.1
date	96.12.17.17.54.07;	author hope;	state Exp;
branches
	1.3.7.1.1.1;
next	;

1.3.7.1.1.1
date	97.02.24.11.45.10;	author hope;	state Exp;
branches;
next	;

1.3.8.1
date	96.12.18.09.48.42;	author hope;	state Exp;
branches;
next	;

1.3.9.1
date	97.05.12.10.41.06;	author hope;	state Exp;
branches
	1.3.9.1.1.1
	1.3.9.1.2.1
	1.3.9.1.3.1;
next	;

1.3.9.1.1.1
date	97.07.28.18.27.53;	author daveb;	state Exp;
branches
	1.3.9.1.1.1.1.1;
next	;

1.3.9.1.1.1.1.1
date	97.10.07.11.53.49;	author jkbrook;	state Exp;
branches;
next	;

1.3.9.1.2.1
date	97.09.08.17.20.55;	author daveb;	state Exp;
branches;
next	;

1.3.9.1.3.1
date	97.09.09.14.17.00;	author daveb;	state Exp;
branches;
next	;

1.3.10.1
date	97.09.10.19.35.25;	author brucem;	state Exp;
branches;
next	;

1.3.11.1
date	97.09.11.21.04.03;	author daveb;	state Exp;
branches;
next	;

1.3.12.1
date	97.10.31.13.47.05;	author nickb;	state Exp;
branches;
next	;

1.5.1.1
date	99.04.01.18.03.00;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.5
log
@[Bug #20133]
Make space_profile_active visible to external code (interface.S)
@
text
@/*  ==== PROFILER ====
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:profiler.h,v $
 * Revision 1.4  1998/04/23  13:43:57  jont
 * [Bug #70034]
 * Rationalising names in mem.h
 *
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
 * Revision 1.2  1994/06/09  14:46:07  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:16:07  nickh
 * new file
 *
 *  Revision 4.1  1994/03/29  15:57:03  johnk
 *  Bumped a revision.
 *
 *  Revision 3.4  1994/03/29  15:56:12  johnk
 *  Manually Bumped.
 *
 *  Revision 3.3  1994/03/23  12:44:07  nickh
 *  New profiler, with a slightly different interface.
 *
 *  Revision 3.2  1993/05/13  10:47:55  richard
 *  Added suspend and resume.
 *
 *  Revision 3.1  1993/04/06  15:28:01  richard
 *  Another complete rewrite based on Nosa's multi-level profiler.
 *
 *  Revision 2.5  1993/02/04  23:21:16  nosa
 *  Implemented a multi-level profiler
 *
 *  Revision 2.4  1992/12/18  15:20:56  clive
 *  Made the profiler take the generalised streams
 *
 *  Revision 2.3  1992/08/07  08:40:40  richard
 *  Profile_new() is no longer needed due to changes in the loader.
 *
 *  Revision 2.2  1992/07/29  14:23:00  richard
 *  Added better error return.
 *
 *  Revision 2.1  1992/07/14  15:56:06  richard
 *  Complete reimplementation without placing assumptions on the
 *  storage manager.  The profiler may now be `wrapped around'
 *  a computation in order to profile it, and sends it output to
 *  a specified stream.
 *
 *  Revision 1.4  1992/06/30  09:44:02  richard
 *  Tidying, and moved in_ML here since it isn't (going to be) used
 *  from the storage manager.
 *
 *  Revision 1.3  1992/06/11  17:07:21  clive
 *  Fixes to the profiler
 *  
 *  Revision 1.2  1992/05/08  17:09:03  clive
 *  Added some code for memory profiling and corrected some bugs
 *  
 *  Revision 1.1  1992/04/14  16:14:32  clive
 *  Initial revision
 */

#ifndef profiler_h
#define profiler_h

#include <stdio.h>
#include <stddef.h>

#include "options.h"
#include "values.h"
#include "stacks.h"

/*  === INIIALISE THE PROFILER ===
 *
 *  Performs internal initialisation.
 */

extern void profile_init(void);

/*  === PROFILING MANNER === */

#define PROFILE_CALLS		1
#define PROFILE_TIME		2
#define PROFILE_SPACE		4
#define PROFILE_SPACE_COPIES	8

#define PROFILE_DEPTH_SHIFT	16
#define PROFILE_DEPTH_MAX	15
#define PROFILE_DEPTH_MASK	(PROFILE_DEPTH_MAX << PROFILE_DEPTH_SHIFT)

#define PROFILE_BREAKDOWN_FIELDS 8
#define PROFILE_BREAKDOWN_SHIFT 8
#define PROFILE_BREAKDOWN_MASK  (((1<<PROFILE_BREAKDOWN_FIELDS) -1)	\
				 << PROFILE_BREAKDOWN_SHIFT)

#define PROFILE_SPACE_BREAKDOWN	PROFILE_BREAKDOWN_MASK

#define PROFILE_ALL	(PROFILE_CALLS + PROFILE_TIME + PROFILE_SPACE)

/*  === PROFILING OPTIONS ===
 *
 *  interval
 *    The interval, in virtual milliseconds, between scans of the stack.
 *    If zero, no scans will occur.
 *  manner
 *    A function which returns the manner in which a code item is
 *    to be profiled.
 *  stream
 *    The stream to which the profiler results are to be printed. If
 *    this is NULL, the profiler was called from ML and the profiler
 *    result should be constructed as an ML value and returned from
 *    profile_end.
 */

struct profile_options
{
  unsigned int interval;
  int (*manner)(mlval code);
  FILE *stream;
};

extern int profile_select_all_manner;
extern int profile_select_all(mlval code);

/* profile_on is non-zero when profiling and zero otherwise */

extern int profile_on;
extern int space_profile_active;

/*  profile_begin() and profile_end() are used to `bracket' a section of
 *  code to be profiled.
 */

extern int profile_begin(struct profile_options *options);
extern int profile_end(mlval *result);

enum /* errno */
{
  EPROFILENEST = 1,			/* profiler cannot nest */
  EPROFILEDEPTH				/* stack profiling too deep */
};

/* time_profile_scan is called by the signal-handling code (in
 * signals.[ch]), each time the profiler alarm goes off. */

extern void time_profile_scan(struct stack_frame *sp);

/* pre_gc_space_profile and post_gc_space_profile are called either
   side of a collection from 'from' to 'to'. 'number' is the true
   generation number of the 'from' generation.  */

extern void pre_gc_space_profile(struct ml_heap *from,
				 struct ml_heap *to,
				 int number);
extern void post_gc_space_profile(struct ml_heap *from,
				  struct ml_heap *to,
				  int number);

/*  === PROFILE SUSPENDING ===
 *
 *  Between a profile_begin() and a profile_end() it may be desirable to
 *  suspend profiling temporarily, for example, to enter a debugger.
 *  profile_suspend() and profile_resume() do the obvious thing, and return
 *  zero on success.  They nest, and return -1 and set errno to EPROFILENEST
 *  if wrongly nested or used outside profiling.
 *
 *  The integer profile_suspended is non-zero if profiling is suspended.  It
 * is not meaningful outside profiling.  */

extern int profile_suspended;
extern int profile_suspend(void);
extern int profile_resume(void);

#endif
@


1.5.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 4
 * Revision 1.5  1998/07/29  12:54:57  jont
 * [Bug #20133]
 * Make space_profile_active visible to external code (interface.S)
 *
@


1.4
log
@[Bug #70034]
Rationalising names in mem.h
@
text
@d8 4
d133 1
@


1.3
log
@Move to new profiler framework, with results into ML.
@
text
@d8 3
d152 2
a153 2
extern void pre_gc_space_profile(struct gen *from,
				 struct gen *to,
d155 2
a156 2
extern void post_gc_space_profile(struct gen *from,
				  struct gen *to,
@


1.3.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a7 3
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
@


1.3.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 3
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
@


1.3.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 3
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
@


1.3.9.1
log
@branched from 1.3
@
text
@a7 3
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
@


1.3.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.3.9.1  1997/05/12  10:41:06  hope
 * branched from 1.3
 *
@


1.3.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.3.9.1  1997/05/12  10:41:06  hope
 * branched from 1.3
 *
@


1.3.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.3.9.1  1997/05/12  10:41:06  hope
 * branched from 1.3
 *
@


1.3.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.3.9.1.1.1  1997/07/28  18:27:53  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.3.8.1
log
@branched from 1.3
@
text
@a7 3
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
@


1.3.7.1
log
@branched from 1.3
@
text
@a7 3
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
@


1.3.7.1.1.1
log
@branched from 1.3.7.1
@
text
@a7 3
 * Revision 1.3.7.1  1996/12/17  17:54:07  hope
 * branched from 1.3
 *
@


1.3.6.1
log
@branched from 1.3
@
text
@a7 3
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
@


1.3.5.1
log
@branched from 1.3
@
text
@a7 3
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
@


1.3.4.1
log
@branched from 1.3
@
text
@a7 3
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
@


1.3.4.1.1.1
log
@branched from 1.3.4.1
@
text
@a7 3
 * Revision 1.3.4.1  1996/11/14  12:58:00  hope
 * branched from 1.3
 *
@


1.3.3.1
log
@branched from 1.3
@
text
@a7 3
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
@


1.3.2.1
log
@branched from 1.3
@
text
@a7 3
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a7 3
 * Revision 1.3  1995/07/17  08:58:34  nickb
 * Move to new profiler framework, with results into ML.
 *
@


1.2
log
@new file
@
text
@d8 3
d78 10
d89 9
d103 8
a110 10
 *  depth
 *    The depth of caller-callee relations to which information is
 *    collated.  (1 gives profiles about individual code vectors.)
 *  select
 *    A function which yields non-zero if a code is to be profiled.  This
 *    may be called asynchronously and therefore cannot be in ML.
 *  print
 *    A function (in C or ML) which is applied to the strings which
 *    form the output of the profiler.  It must not raise an
 *    exception.
d116 2
a117 8
  unsigned int depth;
  int (*select)(mlval code);
  enum {PROFILE_OPT_C, PROFILE_OPT_ML} printer_type;
  union
  {
    mlval ml;
    void (*c)(const char *string);
  } print;
d120 1
a121 1
extern void profile_print_stdout(const char *string);
d127 2
a128 9
/*  === PROFILE A CODE SECTION ===
 *
 *  profile_begin() and profile_end() are used to `bracket' a section of
 *  code to be profiled.   The results of profiling are passed to a print
 *  function as strings.
 *
 *  The options structure must not be modified until profile_end() returns.
 *
 *  Both functions return zero on success or -1 on error and set errno.
d131 2
a132 1
#define PROFILE_DEPTH_MAX	256
d136 2
a137 2
  EPROFILEDEPTH = 1,		/* cannot profile that deep */
  EPROFILENEST			/* profiler cannot nest */
d140 2
a141 2
extern int profile_begin(struct profile_options *options);
extern int profile_end(void);
d143 1
a143 2
/* profile_scan is called by the signal-handling code (in
 * signals.[ch]), each time the profiler alarm goes off. */
d145 10
a154 1
extern void profile_scan(struct stack_frame *sp);
d165 1
a165 2
 *  is not meaningful outside profiling.
 */
a169 1

@


1.2.1.1
log
@branched from 1.2
@
text
@a7 3
 * Revision 1.2  1994/06/09  14:46:07  nickh
 * new file
 *
@


1.1
log
@new file
@
text
@d7 4
a10 1
 *  $Log: profiler.h,v $
@
