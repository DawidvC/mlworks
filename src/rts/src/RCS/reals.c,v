head	1.29;
access;
symbols
	MLW_daveb_inline_1_4_99:1.29.1
	MLWorks_21c0_1999_03_25:1.29
	MLWorks_20c1_1998_08_20:1.28
	MLWorks_20c0_1998_08_04:1.28
	MLWorks_20b2c2_1998_06_19:1.28
	MLWorks_20b2_Windows_1998_06_12:1.28
	MLWorks_20b1c1_1998_05_07:1.28
	MLWorks_20b0_1998_04_07:1.26
	MLWorks_20b0_1998_03_20:1.26
	MLWorks_20m2_1998_02_16:1.25
	MLWorks_MM_adapt:1.23.1
	MLWorks_20m1_1997_10_23:1.23
	MLWorks_11r1:1.21.1.1.1.1.1
	MLWorks_workspace_97:1.21.3
	MLWorks_dt_wizard:1.21.2
	MLWorks_11c0_1997_09_09:1.21.1.1.1.1
	MLWorks_10r3:1.21.1.1.3
	MLWorks_10r2_551:1.21.1.1.2
	MLWorks_11:1.21.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.21.1.1
	MLWorks_20m0_1997_06_20:1.21
	MLWorks_1_0_r2c2_1997_06_14:1.21.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.21.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.21.1
	MLWorks_BugFix_1997_04_24:1.21
	MLWorks_1_0_r2_Win32_1997_04_11:1.21
	MLWorks_1_0_r2_Unix_1997_04_04:1.21
	MM_ML_release_korma_1997_04_01:1.21
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.18.4.1.1
	MLWorks_gui_1996_12_18:1.18.5
	MLWorks_1_0_Win32_1996_12_17:1.18.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.18.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.18.1.1
	JFHrts:1.18.3
	MLWorks_1_0_Irix_1996_11_28:1.18.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.18.2
	MLWorks_1_0_Unix_1996_11_14:1.18.1
	MLWorks_Open_Beta2_1996_10_11:1.17.3
	MLWorks_License_dev:1.17.2
	MLWorks_1_open_beta_1996_09_13:1.17.1
	MLWorks_Open_Beta_1996_08_22:1.17
	MLWorks_Beta_1996_07_02:1.13
	MLWorks_Beta_1996_06_07:1.13
	MLWorks_Beta_1996_06_06:1.13
	MLWorks_Beta_1996_06_05:1.13
	MLWorks_Beta_1996_06_03:1.13
	MLWorks_Beta_1996_05_31:1.13
	MLWorks_Beta_1996_05_30:1.13
	hope_poo:1.4.1
	ML_beta_release_12/08/94:1.4.1.1
	ML_beta_release_03/08/94:1.4;
locks; strict;
comment	@ * @;


1.29
date	98.10.08.13.03.18;	author jont;	state Exp;
branches
	1.29.1.1;
next	1.28;

1.28
date	98.04.23.11.36.51;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	98.04.21.09.27.08;	author mitchell;	state Exp;
branches;
next	1.26;

1.26
date	98.02.23.18.30.50;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	98.02.05.16.40.55;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	98.02.05.14.51.22;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	97.10.09.17.42.21;	author daveb;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	97.10.09.10.29.20;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	97.03.25.17.36.23;	author jont;	state Exp;
branches
	1.21.1.1
	1.21.2.1
	1.21.3.1;
next	1.20;

1.20
date	97.03.25.12.26.05;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	97.02.28.13.00.50;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	96.10.17.14.04.56;	author jont;	state Exp;
branches
	1.18.1.1
	1.18.2.1
	1.18.3.1
	1.18.4.1
	1.18.5.1;
next	1.17;

1.17
date	96.07.24.14.44.10;	author jont;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1;
next	1.16;

1.16
date	96.07.24.12.39.03;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	96.07.23.09.50.12;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	96.07.05.16.14.05;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	96.05.22.13.25.09;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	96.05.20.12.43.53;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	96.05.13.10.38.55;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	96.05.10.15.33.15;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	96.05.10.09.35.51;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	96.04.29.12.14.29;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	96.04.19.11.15.26;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.03.15.16.47.35;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	94.11.08.17.17.37;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	94.06.29.14.25.06;	author jont;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	94.06.14.14.41.38;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.35.19;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.11.01.15;	author nickh;	state Exp;
branches;
next	;

1.4.1.1
date	95.07.05.10.30.52;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	96.09.13.11.24.48;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.10.07.16.15.09;	author hope;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	96.10.08.16.43.43;	author nickb;	state Exp;
branches;
next	;

1.17.3.1
date	96.10.17.11.34.35;	author hope;	state Exp;
branches;
next	;

1.18.1.1
date	96.11.14.13.00.13;	author hope;	state Exp;
branches
	1.18.1.1.1.1;
next	;

1.18.1.1.1.1
date	96.11.28.15.10.17;	author hope;	state Exp;
branches;
next	;

1.18.2.1
date	96.11.22.18.18.03;	author hope;	state Exp;
branches;
next	;

1.18.3.1
date	96.12.17.10.04.47;	author hope;	state Exp;
branches;
next	;

1.18.4.1
date	96.12.17.17.56.21;	author hope;	state Exp;
branches
	1.18.4.1.1.1;
next	;

1.18.4.1.1.1
date	97.02.24.11.47.56;	author hope;	state Exp;
branches;
next	;

1.18.5.1
date	96.12.18.09.51.01;	author hope;	state Exp;
branches;
next	;

1.21.1.1
date	97.05.12.10.44.41;	author hope;	state Exp;
branches
	1.21.1.1.1.1
	1.21.1.1.2.1
	1.21.1.1.3.1;
next	;

1.21.1.1.1.1
date	97.07.28.18.24.32;	author daveb;	state Exp;
branches
	1.21.1.1.1.1.1.1;
next	;

1.21.1.1.1.1.1.1
date	97.10.07.11.50.21;	author jkbrook;	state Exp;
branches;
next	1.21.1.1.1.1.1.2;

1.21.1.1.1.1.1.2
date	97.10.10.17.04.00;	author jkbrook;	state Exp;
branches;
next	1.21.1.1.1.1.1.3;

1.21.1.1.1.1.1.3
date	97.10.12.17.39.34;	author jkbrook;	state Exp;
branches;
next	;

1.21.1.1.2.1
date	97.09.08.17.17.51;	author daveb;	state Exp;
branches;
next	;

1.21.1.1.3.1
date	97.09.09.14.14.04;	author daveb;	state Exp;
branches;
next	1.21.1.1.3.2;

1.21.1.1.3.2
date	97.10.10.15.04.25;	author jkbrook;	state Exp;
branches;
next	1.21.1.1.3.3;

1.21.1.1.3.3
date	97.10.12.17.34.52;	author jkbrook;	state Exp;
branches;
next	;

1.21.2.1
date	97.09.10.19.30.18;	author brucem;	state Exp;
branches;
next	;

1.21.3.1
date	97.09.11.20.59.54;	author daveb;	state Exp;
branches;
next	;

1.23.1.1
date	97.10.31.13.43.05;	author nickb;	state Exp;
branches;
next	;

1.29.1.1
date	99.04.01.18.00.00;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.29
log
@[Bug #70189]
Fix inadequacies in strtod when dealing with ~0.0
@
text
@/*  ==== PERVASIVE REALS ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Revision Log
 *  ------------
 *  $Log: src:reals.c,v $
 * Revision 1.28  1998/04/23  11:36:51  jont
 * [Bug #30397]
 * Make fmt test for nan before inf,
 * as the inf test will also detect nans under NT
 *
 * Revision 1.27  1998/04/21  09:27:08  mitchell
 * [Bug #30336]
 * Stop adding .0 when using GEN format
 *
 * Revision 1.26  1998/02/23  18:30:50  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.25  1998/02/05  16:40:55  jont
 * [Bug #70039]
 * Fix problem in copying for negative zeroes
 *
 * Revision 1.24  1998/02/05  14:51:22  jont
 * [Bug #70039]
 * Call function to check for negative zeroes where necessary
 *
 * Revision 1.23  1997/10/09  17:42:21  daveb
 * [Bug #30276]
 * The format function now sets the terminating null correctly when
 * removing the plus sign.
 * It also checks for illegal precision values.
 *
 * Revision 1.22  1997/10/09  10:29:20  jont
 * [Bug #30279]
 * Fix problems with pow involving infinities under linux
 *
 * Revision 1.21  1997/03/25  17:36:23  jont
 * [Bug #0]
 * Fix missing include of ctype.h
 *
 * Revision 1.20  1997/03/25  12:26:05  jont
 * Ensure relevant number of significant digits are printed
 * for reals following the E
 *
 * Revision 1.19  1997/02/28  13:00:50  matthew
 * Updating for exact integer conversion
 *
 * Revision 1.18  1996/10/17  14:04:56  jont
 * Merging in license server stuff
 *
 * Revision 1.17.2.2  1996/10/08  16:43:43  nickb
 * in_ml_fpe stuff goes.
 *
 * Revision 1.17.2.1  1996/10/07  16:15:09  hope
 * branched from 1.17
 *
 * Revision 1.17  1996/07/24  14:44:10  jont
 * Add include of syscalls.h
 *
 * Revision 1.16  1996/07/24  12:39:03  jont
 * Replace is_nan by library call isnan
 *
 * Revision 1.15  1996/07/23  09:50:12  jont
 * [Bug #1489]
 * Fix problems where some OSes incorrectly return -Inf for ln(negative number)
 *
 * Revision 1.14  1996/07/05  16:14:05  jont
 * Fix missing declare and retract root stuff
 *
 * Revision 1.13  1996/05/22  13:25:09  matthew
 * Adding precision to real printing.
 *
 * Revision 1.12  1996/05/20  12:43:53  matthew
 * Adding pow and atan2 functions
 *
 * Revision 1.11  1996/05/13  10:38:55  matthew
 * Renaming variable near since this is a keyword for many PC compilers
 *
 * Revision 1.10  1996/05/10  15:33:15  matthew
 * Fixing problem with removal of + sign in printed output
 *
 * Revision 1.9  1996/05/10  09:35:51  matthew
 * Extending for new basis
 *
 * Revision 1.8  1996/04/29  12:14:29  matthew
 * Improving printing of nans etc.
 *
 * Revision 1.7  1996/04/19  11:15:26  matthew
 * Changing exceptions
 *
 * Revision 1.6  1995/03/15  16:47:35  nickb
 * record expected exception, so signal handler can raise it.
 *
 * Revision 1.5  1994/11/08  17:17:37  matthew
 * Adding sqrt function for use by MIPS
 *
 * Revision 1.4  1994/06/29  14:25:06  jont
 * Remove floatingpoint.h and fix lack of return from non-void
 *
 * Revision 1.3  1994/06/14  14:41:38  jont
 * Add critical region support for FP signals
 *
 * Revision 1.2  1994/06/09  14:35:19  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:01:15  nickh
 * new file
 *
 *  Revision 1.9  1994/01/18  12:22:35  daveb
 *  Removed case from fpe_handler.
 *
 *  Revision 1.8  1993/11/18  13:29:47  daveb
 *  Minor correction to exception raising code in fpe_handler.
 *  Probably not important..
 *
 *  Revision 1.7  1993/06/02  13:08:10  richard
 *  Removed erroneous prototype for sscanf().
 *
 *  Revision 1.6  1993/01/06  11:19:58  richard
 *  Removed redundant operations.
 *  Added floating point exception handling to deal with all remaining
 *  Infinities and NaNs.
 *
 *  Revision 1.5  1993/01/04  12:25:49  richard
 *  Removed some experimental code that I had checked in by mistake.
 *
 *  Revision 1.4  1992/12/21  16:07:54  matthew
 *  Changed real printing precision to 16.  This is about as much as we can get.
 *
 *  Revision 1.3  1992/12/16  10:34:17  richard
 *  Conversion from reals to strings now uses strtod() which can detect
 *  range errors as well as format errors.
 *
 *  Revision 1.2  1992/12/08  12:21:55  richard
 *  Improved the printing of real numbers.  Numbers are printed to
 *  a greater precision and Infinity and NaN do not have `.0' appended.
 *
 *  Revision 1.1  1992/10/23  16:30:05  richard
 *  Initial revision
 *
 */

#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <errno.h>
#include <ctype.h>

#include "reals.h"
#include "dtoa.h"
#include "os.h"
#include "gc.h"
#include "mltypes.h"
#include "values.h"
#include "exceptions.h"
#include "environment.h"
#include "allocator.h"
#include "diagnostic.h"
#include "interface.h"
#include "utils.h"
#include "syscalls.h"
#include "localreals.h"

static mlval root = MLUNIT;
static mlval root1 = MLUNIT;

static mlval ml_pow (mlval argument)
{
  double field0 = GETREAL(FIELD (argument,0));
  double field1 = GETREAL(FIELD (argument,1));
  mlval r = allocate_real();
  double result;
  if (localpower(field0, field1, &result)) {
    (void)SETREAL(r, result);
  } else {
    (void)SETREAL(r, pow (field0, field1));
  }
  return(r);
}

static mlval ml_arctan(mlval argument)
{
  double arg = GETREAL(argument);
  mlval r = allocate_real();
  (void)SETREAL(r, atan(arg));
  return(r);
}

static mlval ml_atan2(mlval argument)
{
  double field0 = GETREAL(FIELD (argument,0));
  double field1 = GETREAL(FIELD (argument,1));
  mlval r = allocate_real();
  (void)SETREAL(r, atan2(field0, field1));
  return(r);
}

static mlval ml_cos(mlval argument)
{
  double arg = GETREAL(argument);
  mlval r = allocate_real();
  (void)SETREAL(r, cos(arg));
  return(r);
}

static mlval ml_sin(mlval argument)
{
  double arg = GETREAL(argument);
  mlval r = allocate_real();
  (void)SETREAL(r, sin(arg));
  return(r);
}

static mlval ml_exp(mlval argument)
{
  double arg = GETREAL(argument);
  mlval r = allocate_real();
  (void)SETREAL(r, exp(arg));
  return(r);
}

static mlval do_sqrt(double arg)
{
  mlval r = allocate_real();
  (void)SETREAL(r, sqrt(arg));
  return(r);
}

static mlval ml_ln(mlval argument)
{
  double arg = GETREAL(argument);
  if (arg < 0.0) {
    return(do_sqrt(-1.0));
  } else {
    mlval r = allocate_real();
    (void)SETREAL(r, log(arg));
    /* Note, can't this raise an exception? */
    return(r);
  }
}

static mlval ml_sqrt(mlval argument)
{
  double arg = GETREAL(argument);
  return(do_sqrt(arg));
}

static int is_infinity (double x)
{
  return ((x != 0.0) && (x + x == x));
}

static mlval to_string(mlval arg)
{
  char buffer[40];
  size_t length;
  mlval string;

  double x = GETREAL (FIELD (arg,0));
  int prec = CINT (FIELD (arg,1));

  if (isnan(x))
    strcpy (buffer,"nan");
  else 
    if (is_infinity (x))
      if (x > 0.0) 
	strcpy (buffer,"inf");
      else strcpy (buffer,"~inf");
    else
      {
	size_t i, plus = 0;
	int point = 0;
	    
	sprintf(buffer, "%.*G", prec, x);

	length = strlen(buffer);

	for(i=0; i<length; ++i)
	  {
	    char c = buffer[i];

	    if(c == '-')
	      buffer[i] = '~';
	    else if(c == '.' || c == 'E')
	      point = 1;
	    else if(c == '+')
	      plus = i;
	  }
  
	if(plus)
	  {
	    for(i=plus; i<length; ++i)
	      buffer[i] = buffer[i+1];
	    length--;
	    
	  }
	
	if(!point)
	  {
	    buffer[length++] = '.';
	    buffer[length++] = '0';
	    buffer[length] = '\0';
	  }
      }

  length = strlen (buffer);
  string = allocate_string(length+1);
  strcpy(CSTRING(string), buffer);

 return(string);
}

static mlval decimal_rep (mlval arg)
{
  int dec;
  int sign;
  char * digits;
  mlval result;
  digits = dtoa (GETREAL(arg),0,100,&dec,&sign,NULL);
  root = allocate_string (strlen(digits) + 1);
  strcpy (CSTRING(root),digits);
  freedtoa (digits);
  result = allocate_record (3);
  FIELD (result,0) = root;
  FIELD (result,1) = MLINT (dec);
  FIELD (result,2) = sign ? MLTRUE : MLFALSE;
  return (result);
}

/* First arg of fmt is of datatype
   EXACT | SCI of int option | FIX of int option | GEN of int option
*/

/* The relevant tags */
#define EXACT_FORMAT 0
#define FIX_FORMAT 1
#define GEN_FORMAT 2
#define SCI_FORMAT 3

#define MAX_DIGITS 10

static mlval fmt (mlval arg)
{
  char buffer[40];
  size_t length;
  mlval string;
  mlval format = FIELD (arg, 0);
  double x = GETREAL (FIELD (arg,1));
  int prec = 0;
  /* Check the precision first */
  if (format != EXACT_FORMAT) {
    int format_type = CINT (FIELD (format, 0));
    int min_prec = 0;

    /* Minimum precision is 0 for SCI and FIX, 1 for GEN. */
    if (format_type == GEN_FORMAT) 
      min_prec = 1;

    if (FIELD (format,1) == MLINT (0)) {
      /* Argument is NONE => Default precision. */
      prec = -1;
    } else {
      prec = CINT (FIELD (FIELD (format,1),1));
      if (prec < min_prec)
        exn_raise(perv_exn_ref_size);
    }
  }

  if (isnan (x))
    strcpy (buffer,"nan");
  else
    if (is_infinity (x))
      if (x > 0.0) 
	strcpy (buffer,"+inf");
      else strcpy (buffer,"-inf");
    else
      if (format == EXACT_FORMAT) { /* EXACT conversion required */
	/* Note that this doesn't do the right thing with NaN's, but */
	/* this should be taken care of on the ML side of things */
	int dec;
	int sign;
	char * ptr = buffer;
	char * digits = dtoa (x,0,100,&dec,&sign,NULL);
	char * dptr = digits;
	if (sign)
	  *ptr++ = '~';
	*ptr++ = '0';
	*ptr++ = '.';
	/* Don't copy null byte here */
	while (*dptr)
	  *ptr++=*dptr++;
	if (dec != 0){
	  *ptr++ = 'E';
	  if (dec < 0) {
	    dec = -dec;
	    *ptr++ = '~';
	  }
	  /* Now add the exponent */
	  sprintf (ptr,"%d",dec);
	  ptr += strlen (ptr);
	}
	*ptr++ = '\000';
	freedtoa (digits);
      } else {
	/* Now we have to decipher the format */
	size_t i, plus = 0;
	int point = 0;
	int format_type = CINT (FIELD (format,0));

	if (format_type == FIX_FORMAT) /* FIX */
	  sprintf (buffer, "%.*f", prec < 0 ? 6 : prec, x);
	else if (format_type == GEN_FORMAT) /* GEN */
	  sprintf (buffer, "%.*G", prec < 0 ? 12 : prec,x);
	else if (format_type == SCI_FORMAT) /* SCI */
	  sprintf (buffer, "%.*E", prec < 0 ? 6 : prec, x);
	else sprintf(buffer, "%.18G", x);

	length = strlen(buffer);

	/* Now check for correct printing of negative zeroes */
	if (x == 0.0) {
	  switch (check_neg_zero(&x)) {
	  case 2: /* -0.0 */
	    /* May need to modify the output here */
	    if (*buffer != '-') {
	      /* Yes, we do need to modify */
	      if (*buffer == '+') {
		*buffer = '-';
	      } else {
		for (i = length+1; i > 0; i--) {
		  buffer[i] = buffer[i-1]; /* Move the characters along the buffer */
		};
		length++;
		*buffer = '-';
	      }
	    }
	  case 0: /* Not actually 0.0 at all */
	  case 1: /* +0.0 */
	  default: /* This shouldn't happen */
	    /* No action required here */
	    break;
	  }
	}

	for(i=0; i<length; ++i) {
	  char c = buffer[i];

	  if(c == '-')
	    buffer[i] = '~';
	  else if(c == '.' || c == 'E')
	    point = i;
	  else if(c == '+')
	    plus = i;
	}

	/* Win32 screws up G format by printing too many digits */
	/* in the exponent. So we contract that part if necessary */

	if (point && buffer[point] == 'E') {
	  char c = buffer[point+1];
	  if (c == '+' || c == '~') point++;
	  if (buffer[point+1] == '0' &&
	      isdigit(buffer[point+2]) &&
	      isdigit(buffer[point+3])) {
	    buffer[point+1] = buffer[point+2];
	    buffer[point+2] = buffer[point+3];
	    buffer[point+3] = '\0';
	  }
	}

	if(plus) {
	  for(i=plus; i<length; ++i)
	    buffer[i] = buffer[i+1];
	  length--;
	}
	
	if(!point && (format_type != GEN_FORMAT)
                  && !(format_type == FIX_FORMAT && prec == 0)) {
	  buffer[length++] = '.';
	  buffer[length++] = '0';
	  buffer[length] = '\0';
	}
      }

  length = strlen (buffer);
  string = allocate_string(length+1);
  strcpy(CSTRING(string), buffer);

  return(string);
}

static mlval from_string(mlval arg)
{
  double result;
  unsigned int length = CSTRINGLENGTH(arg)+1, i;
  char *original = CSTRING(arg);
  char *buffer = alloc(length, "Couldn't allocate buffer in ml_scan_real"), *end;
  int negative = 0;
  for (i=0; i<length; ++i) {
    if (!(isspace(original[i]))) {
      if (original[i] == '~') {
	original += i+1;
	negative = 1;
	length -= i+1;
      }
      break;
    }
  }
  for(i=0; i<length; ++i)
    switch(original[i])
    {
      case '~':
      buffer[i] = '-';
      break;

      case 'e': case '+':
      exn_raise(perv_exn_ref_string_to_real);

      default:
      buffer[i] = original[i];
    }

  errno = 0;
  result = strtod(buffer, &end);
  if (negative) result = -result;
  if(*end == '\0' && errno == 0)
  {
    mlval real = allocate_real();

    free(buffer);
    (void)SETREAL(real, result);
    return(real);
  }

  free(buffer);
  exn_raise(perv_exn_ref_string_to_real);
  return MLUNIT; /* NOT REACHED */
}


static mlval from_exp (mlval arg)
{
  double x = GETREAL(arg);
  int exp;
  double man;
  mlval result;

  man = frexp (x,&exp);
  root = allocate_real();
  SETREAL (root,man);
  result = allocate_record (2);
  FIELD (result,0) = MLINT (exp);
  FIELD (result,1) = root;
  root = MLUNIT;
  return (result);
}

static mlval load_exp (mlval arg)
{
  int exp = CINT (FIELD (arg,0));
  double man = GETREAL (FIELD (arg,1));
  mlval result = allocate_real();
  SETREAL (result,ldexp (man,exp));
  return (result);
}

static mlval split (mlval arg)
{
  double x = GETREAL(arg);
  double intpart;
  double fracpart = modf (x,&intpart);
  mlval result;

  root = allocate_real();
  SETREAL (root,fracpart);

  root1 = allocate_real();
  SETREAL (root1,intpart);

  result = allocate_record (2);

  FIELD (result,0) = root;
  FIELD (result,1) = root1;

  root = MLUNIT;
  root1 = MLUNIT;
  return (result);
  
}

#define MINLARGE (1<<31)
#define MAXLARGE (~(MINLARGE))

static int checklarge (double x)
{
  if (x > MAXLARGE || x < MINLARGE)
    exn_raise(perv_exn_ref_overflow);
  return ((int)x);
}

/* copied from basis/__prereal */
static double myround (double x)
{
  double new = floor (x);
  double diff = new - x;

  if (diff < 0.0)
    diff = -diff;

  if (diff < 0.5)
    return (new);
  else
    /* gee, what happens if the cast to int fails? */
    if ((diff > 0.5) || ((int)new % 2) == 1)
      return (new + 1.0);
    else return (new);
}

static double myceil (double x)
{
  return (- (floor (-x)));
}

static double mytrunc (double x)
{
  if (x >= 0)
    return (floor (x));
  else
    return (myceil (x));
}

/* mode is TO_NEAREST, TO_NEGINF, TO_POSINF,TO_ZERO */
static mlval to_large_int (mlval arg)
{
  int mode = CINT (FIELD (arg,0));
  double x = GETREAL (FIELD (arg,1));
  int n;
  mlval result = allocate_word32 ();
  switch (mode)
    {
    case (0):
      n = checklarge(myround (x));
      break;
    case (1):
      n = checklarge(floor (x));
      break;
    case (2):
      n = checklarge(myceil (x));
      break;
    case (3):
      n = checklarge(mytrunc (x));
      break;
    default:
      n = -1;
    }
  *CWORD32(result)=n;
  return result;
}

static mlval from_large_int (mlval arg)
{
  int n = (int)*CWORD32(arg);
  mlval result = allocate_real ();
  SETREAL (result,(double)n);
  return (result);
}

/* mode is TO_NEAREST, TO_NEGINF, TO_POSINF,TO_ZERO */
static mlval set_rounding_mode (mlval arg)
{
  int mode;
  switch (CINT (arg))
    {
    case 0:
      mode = 0;
      break;
    case 1:
      mode = 3;
      break;
    case 2:
      mode = 2;
      break;
    case 3:
      mode = 1;
      break;
    default:
      mode = -1;
    }
  os_set_rounding_mode (mode);
  return (MLUNIT);
}

static mlval get_rounding_mode (mlval arg)
{
  int mode;
  switch (os_get_rounding_mode ())
    {
    case 0:
      mode = 0;
      break;
    case 1:
      mode = 3;
      break;
    case 2:
      mode = 2;
      break;
    case 3:
      mode = 1;
      break;
    default:
      mode = -1;
    }
  return (MLINT(mode));
}

void reals_init()
{
  env_function("real arctan", ml_arctan);
  env_function("real atan2", ml_atan2);
  env_function("real cos", ml_cos);
  env_function("real exp", ml_exp);
  env_function("real ln", ml_ln);
  env_function("real sin", ml_sin);
  env_function("real square root", ml_sqrt);
  env_function("real pow", ml_pow);
  env_function("real to string", to_string);
  env_function("real fmt", fmt);
  env_function("real from string", from_string);
  env_function("real decimal rep", decimal_rep);
  env_function("real from exp", from_exp);
  env_function("real load exp", load_exp);
  env_function("real split", split);
  env_function("real from large int", from_large_int);
  env_function("real to large int", to_large_int);
  env_function("real set rounding mode", set_rounding_mode);
  env_function("real get rounding mode", get_rounding_mode);
  declare_root(&root, 0);
  declare_root(&root1, 0);
}
@


1.29.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 4
 * Revision 1.29  1998/10/08  13:03:18  jont
 * [Bug #70189]
 * Fix inadequacies in strtod when dealing with ~0.0
 *
@


1.28
log
@[Bug #30397]
Make fmt test for nan before inf,
as the inf test will also detect nans under NT
@
text
@d8 5
a354 1

d503 11
a513 1

d530 1
a530 1

@


1.27
log
@[Bug #30336]
Stop adding .0 when using GEN format
@
text
@d8 4
d370 2
a371 4
  if (is_infinity (x))
    if (x > 0.0) 
      strcpy (buffer,"+inf");
    else strcpy (buffer,"-inf");
d373 4
a376 2
    if (isnan (x))
      strcpy (buffer,"nan");
@


1.26
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d8 5
d474 2
a475 1
	if(!point && !(format_type == FIX_FORMAT && prec == 0)) {
@


1.25
log
@[Bug #70039]
Fix problem in copying for negative zeroes
@
text
@d8 4
d309 1
a309 1
  mlval string,result;
d311 2
a312 2
  string = allocate_string (strlen(digits) + 1);
  strcpy (CSTRING(string),digits);
a313 1
  declare_root (&string);
d315 1
a315 2
  FIELD (result,0) = string;
  retract_root (&string);
d718 2
a719 2
  declare_root(&root);
  declare_root(&root1);
@


1.24
log
@[Bug #70039]
Call function to check for negative zeroes where necessary
@
text
@d8 4
d420 1
a420 1
		for (i = length+1; i--; i > 0) {
d422 1
a422 1
		}
@


1.23
log
@[Bug #30276]
The format function now sets the terminating null correctly when
removing the plus sign.
It also checks for illegal precision values.
@
text
@d8 6
d348 1
a348 2
    }
    else {
d363 19
a381 10
      if (format == EXACT_FORMAT) /* EXACT conversion required */
	{
	  /* Note that this doesn't do the right thing with NaN's, but */
	  /* this should be taken care of on the ML side of things */
	  int dec;
	  int sign;
	  char * ptr = buffer;
	  char * digits = dtoa (x,0,100,&dec,&sign,NULL);
	  char * dptr = digits;
	  if (sign)
a382 15
	  *ptr++ = '0';
	  *ptr++ = '.';
	  /* Don't copy null byte here */
	  while (*dptr)
	    *ptr++=*dptr++;
	  if (dec != 0){
	    *ptr++ = 'E';
	    if (dec < 0)
	      {
		dec = -dec;
		*ptr++ = '~';
	      }
	    /* Now add the exponent */
	    sprintf (ptr,"%d",dec);
	    ptr += strlen (ptr);
d384 3
a386 2
	  *ptr++ = '\000';
	  freedtoa (digits);
d388 3
a390 1
      else {
d406 35
a440 3
	for(i=0; i<length; ++i)
	  {
	    char c = buffer[i];
a441 8
	    if(c == '-')
	      buffer[i] = '~';
	    else if(c == '.' || c == 'E')
	      point = i;
	    else if(c == '+')
	      plus = i;
	  }
  
d457 5
a461 6
	if(plus)
	  {
	    for(i=plus; i<length; ++i)
	      buffer[i] = buffer[i+1];
	    length--;
	  }
d463 5
a467 6
	if(!point && !(format_type == FIX_FORMAT && prec == 0))
	  {
	    buffer[length++] = '.';
	    buffer[length++] = '0';
	    buffer[length] = '\0';
	  }
@


1.23.1.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a7 6
 * Revision 1.23  1997/10/09  17:42:21  daveb
 * [Bug #30276]
 * The format function now sets the terminating null correctly when
 * removing the plus sign.
 * It also checks for illegal precision values.
 *
@


1.22
log
@[Bug #30279]
Fix problems with pow involving infinities under linux
@
text
@d8 4
d326 1
a326 1
  mlval format = FIELD (arg,0);
d328 21
a392 2
	int prec =
	  FIELD (format,1) == MLINT (0) ? -1 : CINT (FIELD (FIELD (format,1),1));
a432 1
	    length--;
d435 1
@


1.21
log
@[Bug #0]
Fix missing include of ctype.h
@
text
@d8 4
d135 1
d145 6
a150 1
  (void)SETREAL(r, pow (field0, field1));
@


1.21.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 4
 * Revision 1.21  1997/03/25  17:36:23  jont
 * [Bug #0]
 * Fix missing include of ctype.h
 *
@


1.21.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 4
 * Revision 1.21  1997/03/25  17:36:23  jont
 * [Bug #0]
 * Fix missing include of ctype.h
 *
@


1.21.1.1
log
@branched from 1.21
@
text
@a7 4
 * Revision 1.21  1997/03/25  17:36:23  jont
 * [Bug #0]
 * Fix missing include of ctype.h
 *
@


1.21.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.21.1.1  1997/05/12  10:44:41  hope
 * branched from 1.21
 *
@


1.21.1.1.3.2
log
@[Bug #30279]
Merging from trunk:
Correcting pow function on Linux
in cases involving infinity
@
text
@a7 3
 * Revision 1.21.1.1.3.1  1997/09/09  14:14:04  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
a137 1
#include "localreals.h"
d147 1
a147 6
  double result;
  if (localpower(field0, field1, &result)) {
    (void)SETREAL(r, result);
  } else {
    (void)SETREAL(r, pow (field0, field1));
  }
@


1.21.1.1.3.3
log
@[Bug #30276]
Merge from trunk:
Format function now sets terminating null correctly when
removing plus sign.  Also checks for illegal precision values
@
text
@a7 6
 * Revision 1.21.1.1.3.2  1997/10/10  15:04:25  jkbrook
 * [Bug #30279]
 * Merging from trunk:
 * Correcting pow function on Linux
 * in cases involving infinity
 *
d328 1
a328 1
  mlval format = FIELD (arg, 0);
a329 21
  int prec = 0;

  /* Check the precision first */
  if (format != EXACT_FORMAT) {
    int format_type = CINT (FIELD (format, 0));
    int min_prec = 0;

    /* Minimum precision is 0 for SCI and FIX, 1 for GEN. */
    if (format_type == GEN_FORMAT) 
      min_prec = 1;

    if (FIELD (format,1) == MLINT (0)) {
      /* Argument is NONE => Default precision. */
      prec = -1;
    }
    else {
      prec = CINT (FIELD (FIELD (format,1),1));
      if (prec < min_prec)
        exn_raise(perv_exn_ref_size);
    }
  }
d374 2
d416 1
a418 1
	    length--;
@


1.21.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.21.1.1  1997/05/12  10:44:41  hope
 * branched from 1.21
 *
@


1.21.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.21.1.1  1997/05/12  10:44:41  hope
 * branched from 1.21
 *
@


1.21.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.21.1.1.1.1  1997/07/28  18:24:32  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.21.1.1.1.1.1.2
log
@[Bug #30279]
Merging from trunk:
Fixing problems with pow and infinite arguments on Linux
@
text
@a7 3
 * Revision 1.21.1.1.1.1.1.1  1997/10/07  11:50:21  jkbrook
 * branched from MLWorks_11 for label MLWorks_11r1
 *
a140 1
#include "localreals.h"
d150 1
a150 6
  double result;
  if (localpower(field0, field1, &result)) {
    (void)SETREAL(r, result);
  } else {
    (void)SETREAL(r, pow (field0, field1));
  }
@


1.21.1.1.1.1.1.3
log
@[Bug #30276]
Merging from trunk:
Format function now sets terminating null correctly when removing
plus sign.  Also now check for illegal precision values.
@
text
@a7 5
 * Revision 1.21.1.1.1.1.1.2  1997/10/10  17:04:00  jkbrook
 * [Bug #30279]
 * Merging from trunk:
 * Fixing problems with pow and infinite arguments on Linux
 *
d331 1
a331 1
  mlval format = FIELD (arg, 0);
a332 21
  int prec = 0;

  /* Check the precision first */
  if (format != EXACT_FORMAT) {
    int format_type = CINT (FIELD (format, 0));
    int min_prec = 0;

    /* Minimum precision is 0 for SCI and FIX, 1 for GEN. */
    if (format_type == GEN_FORMAT) 
      min_prec = 1;

    if (FIELD (format,1) == MLINT (0)) {
      /* Argument is NONE => Default precision. */
      prec = -1;
    }
    else {
      prec = CINT (FIELD (FIELD (format,1),1));
      if (prec < min_prec)
        exn_raise(perv_exn_ref_size);
    }
  }
d377 2
d419 1
a421 1
	    length--;
@


1.20
log
@Ensure relevant number of significant digits are printed
for reals following the E
@
text
@d8 4
d116 1
@


1.19
log
@Updating for exact integer conversion
@
text
@d8 3
d373 1
a373 1
	      point = 1;
d378 15
@


1.18
log
@Merging in license server stuff
@
text
@d8 3
d111 1
d265 20
a284 1
  return(string);
d288 1
a288 1
   SCI of int option | FIX of int option | GEN of int option
d291 8
d307 7
a313 7
  if (isnan(x))
    strcpy (buffer,"nan");
  else 
    if (is_infinity (x))
      if (x > 0.0) 
	strcpy (buffer,"+inf");
      else strcpy (buffer,"-inf");
d315 31
a345 1
      {
d353 1
a353 1
	if (format_type == 0) /* FIX */
d355 1
a355 1
	else if (format_type == 1) /* GEN */
d357 1
a357 1
	else if (format_type == 2) /* SCI */
d359 1
a359 2
	else
	  sprintf(buffer, "%.18G", x);
d382 1
a382 1
	if(!point)
d624 1
@


1.18.5.1
log
@branched from 1.18
@
text
@a7 3
 * Revision 1.18  1996/10/17  14:04:56  jont
 * Merging in license server stuff
 *
@


1.18.4.1
log
@branched from 1.18
@
text
@a7 3
 * Revision 1.18  1996/10/17  14:04:56  jont
 * Merging in license server stuff
 *
@


1.18.4.1.1.1
log
@branched from 1.18.4.1
@
text
@a7 3
 * Revision 1.18.4.1  1996/12/17  17:56:21  hope
 * branched from 1.18
 *
@


1.18.3.1
log
@branched from 1.18
@
text
@a7 3
 * Revision 1.18  1996/10/17  14:04:56  jont
 * Merging in license server stuff
 *
@


1.18.2.1
log
@branched from 1.18
@
text
@a7 3
 * Revision 1.18  1996/10/17  14:04:56  jont
 * Merging in license server stuff
 *
@


1.18.1.1
log
@branched from 1.18
@
text
@a7 3
 * Revision 1.18  1996/10/17  14:04:56  jont
 * Merging in license server stuff
 *
@


1.18.1.1.1.1
log
@branched from 1.18.1.1
@
text
@a7 3
 * Revision 1.18.1.1  1996/11/14  13:00:13  hope
 * branched from 1.18
 *
@


1.17
log
@Add include of syscalls.h
@
text
@d8 9
a119 3
int in_ml_fpe = 0;
mlval ml_fpe_exn;

a135 2
  in_ml_fpe = 1;
  ml_fpe_exn = perv_exn_ref_overflow;
a136 1
  in_ml_fpe = 0;
a152 2
  in_ml_fpe = 1;
  ml_fpe_exn = perv_exn_ref_overflow;
a153 1
  in_ml_fpe = 0;
a160 2
  in_ml_fpe = 1;
  ml_fpe_exn = perv_exn_ref_overflow;
a161 1
  in_ml_fpe = 0;
a168 2
  in_ml_fpe = 1;
  ml_fpe_exn = perv_exn_ref_exp;
a169 1
  in_ml_fpe = 0;
a175 2
  in_ml_fpe = 1;
  ml_fpe_exn = perv_exn_ref_sqrt;
a176 1
  in_ml_fpe = 0;
a552 2
  in_ml_fpe = 0;
  ml_fpe_exn = perv_exn_ref_overflow;
@


1.17.3.1
log
@branched from 1.17
@
text
@a7 3
 * Revision 1.17  1996/07/24  14:44:10  jont
 * Add include of syscalls.h
 *
@


1.17.2.1
log
@branched from 1.17
@
text
@a7 3
 * Revision 1.17  1996/07/24  14:44:10  jont
 * Add include of syscalls.h
 *
@


1.17.2.2
log
@in_ml_fpe stuff goes.
@
text
@a7 3
 * Revision 1.17.2.1  1996/10/07  16:15:09  hope
 * branched from 1.17
 *
d114 3
d133 2
d136 1
d153 2
d156 1
d164 2
d167 1
d175 2
d178 1
d185 2
d188 1
d565 2
@


1.17.1.1
log
@branched from 1.17
@
text
@a7 3
 * Revision 1.17  1996/07/24  14:44:10  jont
 * Add include of syscalls.h
 *
@


1.16
log
@Replace is_nan by library call isnan
@
text
@d8 3
d109 1
@


1.15
log
@[Bug #1489]
Fix problems where some OSes incorrectly return -Inf for ln(negative number)
@
text
@d8 4
a208 5
static int is_nan (double x)
{
  return (x != x);
}

d218 1
a218 1
  if (is_nan(x))
d281 1
a281 1
  if (is_nan(x))
@


1.14
log
@Fix missing declare and retract root stuff
@
text
@d8 3
d171 10
d184 8
a191 4
  mlval r = allocate_real();
  (void)SETREAL(r, log(arg));
  /* Note, can't this raise an exception? */
  return(r);
d197 1
a197 6
  mlval r = allocate_real();
  in_ml_fpe = 1;
  ml_fpe_exn = perv_exn_ref_sqrt;
  (void)SETREAL(r, sqrt(arg));
  in_ml_fpe = 0;
  return(r);
@


1.13
log
@Adding precision to real printing.
@
text
@d8 3
d103 3
d108 2
d111 1
a111 2
  (void)SETREAL(r, pow (GETREAL(FIELD (argument,0)),
			GETREAL(FIELD (argument,1))));
d117 1
d121 1
a121 1
  (void)SETREAL(r, atan(GETREAL(argument)));
d128 2
d131 1
a131 2
  (void)SETREAL(r, atan2(GETREAL(FIELD (argument,0)),
			 GETREAL(FIELD (argument,1))));
d137 1
d141 1
a141 1
  (void)SETREAL(r, cos(GETREAL(argument)));
d148 1
d152 1
a152 1
  (void)SETREAL(r, sin(GETREAL(argument)));
d159 1
d163 1
a163 1
  (void)SETREAL(r, exp(GETREAL(argument)));
d170 1
d172 2
a173 1
  (void)SETREAL(r, log(GETREAL(argument)));
d179 1
d183 1
a183 1
  (void)SETREAL(r, sqrt(GETREAL(argument)));
a374 1
  mlval real;
d378 2
a379 3
  real = allocate_real();
  SETREAL (real,man);
  declare_root (&real);
d382 2
a383 2
  FIELD (result,1) = real;
  retract_root (&real);
d401 1
a401 1
  mlval mlintpart,mlfracpart,result;
d403 5
a407 7
  mlfracpart = allocate_real();
  SETREAL (mlfracpart,fracpart);
  declare_root (&mlfracpart);

  mlintpart = allocate_real();
  SETREAL (mlintpart,intpart);
  declare_root (&mlintpart);
d411 2
a412 5
  FIELD (result,0) = mlfracpart;
  FIELD (result,1) = mlintpart;

  retract_root (&mlfracpart);  
  retract_root (&mlintpart);
d414 2
d567 2
@


1.12
log
@Adding pow and atan2 functions
@
text
@d8 3
d189 2
a190 1
  double x = GETREAL (arg);
d193 1
a193 1
    strcpy (buffer,"NaN");
d197 2
a198 2
	strcpy (buffer,"Infinity");
      else strcpy (buffer,"~Infinity");
d204 1
a204 1
	sprintf(buffer, "%.18G", x);
d243 1
a243 1
/* First arg of to_string is of datatype
@


1.11
log
@Renaming variable near since this is a keyword for many PC compilers
@
text
@d8 3
d97 8
d115 8
a155 9
  double arg = GETREAL(argument);

  /* have to put this test in separately as no signal is otherwise
   * raised under Irix/MIPS. */
  if (arg < 0.0)
    exn_raise (perv_exn_ref_ln);

  in_ml_fpe = 1;
  ml_fpe_exn = perv_exn_ref_ln;
a156 1
  in_ml_fpe = 0;
d536 1
d542 1
@


1.10
log
@Fixing problem with removal of + sign in printed output
@
text
@d8 3
d410 2
a411 2
  double near = floor (x);
  double diff = near - x;
d417 1
a417 1
    return (near);
d420 3
a422 3
    if ((diff > 0.5) || ((int)near % 2) == 1)
      return (near + 1.0);
    else return (near);
@


1.9
log
@Extending for new basis
@
text
@d8 3
a205 1
	    length--;
d208 2
@


1.8
log
@Improving printing of nans etc.
@
text
@d8 3
d74 2
d223 73
d335 180
d526 1
d528 7
@


1.7
log
@Changing exceptions
@
text
@d8 3
d150 10
d166 1
a166 3
  sprintf(buffer, "%.16G", GETREAL(arg));

  length = strlen(buffer);
d168 27
a194 16
  if(strcmp(buffer, "Infinity") && strcmp(buffer, "NaN"))
  {
    size_t i, plus = 0;
    int point = 0;

    for(i=0; i<length; ++i)
    {
      char c = buffer[i];

      if(c == '-')
	buffer[i] = '~';
      else if(c == '.' || c == 'E')
	point = 1;
      else if(c == '+')
	plus = i;
    }
d196 14
a209 14
    if(plus)
    {
      length--;
      for(i=plus; i<length; ++i)
	buffer[i] = buffer[i+1];
    }

    if(!point)
    {
      buffer[length++] = '.';
      buffer[length++] = '0';
      buffer[length] = '\0';
    }
  }
d211 1
@


1.6
log
@record expected exception, so signal handler can raise it.
@
text
@d8 3
d84 1
a84 1
  ml_fpe_exn = perv_exn_ref_sum;
d94 1
a94 1
  ml_fpe_exn = perv_exn_ref_sum;
d104 1
a104 1
  ml_fpe_exn = perv_exn_ref_sum;
d237 1
a237 1
  ml_fpe_exn = perv_exn_ref_sum;
@


1.5
log
@Adding sqrt function for use by MIPS
@
text
@d8 3
d75 1
d81 1
d91 1
d97 1
a97 1
static mlval ml_exp(mlval argument)
d101 2
a102 1
  (void)SETREAL(r, exp(GETREAL(argument)));
d107 1
a107 1
static mlval ml_ln(mlval argument)
d111 2
a112 1
  (void)SETREAL(r, log(GETREAL(argument)));
d117 1
a117 1
static mlval ml_sin(mlval argument)
d120 11
a130 1
  (void)SETREAL(r, sin(GETREAL(argument)));
d137 2
d140 1
d234 1
@


1.4
log
@Remove floatingpoint.h and fix lack of return from non-void
@
text
@d8 3
d116 6
d218 1
@


1.4.1.1
log
@branched from 1.4
@
text
@a7 3
 * Revision 1.4  1994/06/29  14:25:06  jont
 * Remove floatingpoint.h and fix lack of return from non-void
 *
@


1.3
log
@Add critical region support for FP signals
@
text
@d8 3
a55 1
#include <floatingpoint.h>
d197 1
@


1.2
log
@new file
@
text
@d8 3
d66 2
d71 1
d73 1
d80 1
d82 1
d89 1
d91 1
d98 1
d100 1
d200 1
@


1.1
log
@new file
@
text
@d7 4
a10 1
 *  $Log: reals.c,v $
@
