head	1.22;
access;
symbols
	MLW_daveb_inline_1_4_99:1.22.1
	MLWorks_21c0_1999_03_25:1.22
	MLWorks_20c1_1998_08_20:1.22
	MLWorks_20c0_1998_08_04:1.22
	MLWorks_20b2c2_1998_06_19:1.22
	MLWorks_20b2_Windows_1998_06_12:1.22
	MLWorks_20b1c1_1998_05_07:1.22
	MLWorks_20b0_1998_04_07:1.21
	MLWorks_20b0_1998_03_20:1.21
	MLWorks_20m2_1998_02_16:1.21
	MLWorks_MM_adapt:1.21.3
	MLWorks_20m1_1997_10_23:1.21
	MLWorks_11r1:1.12.1.2.1.1.1
	MLWorks_workspace_97:1.21.2
	MLWorks_dt_wizard:1.21.1
	MLWorks_11c0_1997_09_09:1.12.1.2.1.1
	MLWorks_10r3:1.12.1.2.3
	MLWorks_10r2_551:1.12.1.2.2
	MLWorks_11:1.12.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.12.1.2
	MLWorks_20m0_1997_06_20:1.21
	MLWorks_1_0_r2c2_1997_06_14:1.12.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.12.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.12.1
	MLWorks_BugFix_1997_04_24:1.12
	MLWorks_1_0_r2_Win32_1997_04_11:1.12
	MLWorks_1_0_r2_Unix_1997_04_04:1.12
	MM_ML_release_korma_1997_04_01:1.12
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.10.7.1.1
	MLWorks_gui_1996_12_18:1.10.8
	MLWorks_1_0_Win32_1996_12_17:1.10.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.10.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.10.4.1
	JFHrts:1.10.6
	MLWorks_1_0_Irix_1996_11_28:1.10.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.10.5
	MLWorks_1_0_Unix_1996_11_14:1.10.4
	MLWorks_Open_Beta2_1996_10_11:1.10.3
	MLWorks_License_dev:1.10.2
	MLWorks_1_open_beta_1996_09_13:1.10.1
	MLWorks_Open_Beta_1996_08_22:1.10
	MLWorks_Beta_1996_07_02:1.9
	MLWorks_Beta_1996_06_07:1.9
	MLWorks_Beta_1996_06_06:1.9
	MLWorks_Beta_1996_06_05:1.9
	MLWorks_Beta_1996_06_03:1.9
	MLWorks_Beta_1996_05_31:1.9
	MLWorks_Beta_1996_05_30:1.8
	hope_poo:1.2.1
	ML_beta_release_12/08/94:1.2.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.22
date	98.04.23.13.15.59;	author jont;	state Exp;
branches
	1.22.1.1;
next	1.21;

1.21
date	97.05.19.10.01.01;	author nickb;	state Exp;
branches
	1.21.1.1
	1.21.2.1
	1.21.3.1;
next	1.20;

1.20
date	97.05.19.09.40.19;	author nickb;	state Exp;
branches;
next	1.19;

1.19
date	97.05.16.15.35.44;	author nickb;	state Exp;
branches;
next	1.18;

1.18
date	97.05.16.15.23.16;	author nickb;	state Exp;
branches;
next	1.17;

1.17
date	97.05.16.15.21.18;	author nickb;	state Exp;
branches;
next	1.16;

1.16
date	97.05.16.15.20.27;	author nickb;	state Exp;
branches;
next	1.15;

1.15
date	97.05.16.15.18.59;	author nickb;	state Exp;
branches;
next	1.14;

1.14
date	97.05.16.15.17.55;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	97.05.02.16.40.14;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	97.03.24.15.22.17;	author nickb;	state Exp;
branches
	1.12.1.1;
next	1.11;

1.11
date	97.03.24.15.03.32;	author nickb;	state Exp;
branches;
next	1.10;

1.10
date	96.07.31.11.46.03;	author stephenb;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1
	1.10.4.1
	1.10.5.1
	1.10.6.1
	1.10.7.1
	1.10.8.1;
next	1.9;

1.9
date	96.05.30.15.59.09;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	96.01.22.13.15.17;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.08.30.13.15.42;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	95.08.15.12.11.27;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	95.08.15.12.05.26;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	94.10.14.15.45.55;	author nickb;	state Exp;
branches;
next	1.3;

1.3
date	94.10.03.15.30.09;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.31.38;	author nickh;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	94.06.09.10.56.23;	author nickh;	state Exp;
branches;
next	;

1.2.1.1
date	95.07.05.10.30.28;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	96.09.13.11.25.30;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.10.07.16.15.54;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.10.17.11.35.20;	author hope;	state Exp;
branches;
next	;

1.10.4.1
date	96.11.14.13.00.58;	author hope;	state Exp;
branches
	1.10.4.1.1.1;
next	;

1.10.4.1.1.1
date	96.11.28.15.11.02;	author hope;	state Exp;
branches;
next	;

1.10.5.1
date	96.11.22.18.18.50;	author hope;	state Exp;
branches;
next	;

1.10.6.1
date	96.12.17.10.05.32;	author hope;	state Exp;
branches;
next	;

1.10.7.1
date	96.12.17.17.57.07;	author hope;	state Exp;
branches
	1.10.7.1.1.1;
next	;

1.10.7.1.1.1
date	97.02.24.11.48.48;	author hope;	state Exp;
branches;
next	;

1.10.8.1
date	96.12.18.09.51.46;	author hope;	state Exp;
branches;
next	;

1.12.1.1
date	97.05.12.10.45.28;	author hope;	state Exp;
branches;
next	1.12.1.2;

1.12.1.2
date	97.05.14.13.47.56;	author daveb;	state Exp;
branches
	1.12.1.2.1.1
	1.12.1.2.2.1
	1.12.1.2.3.1;
next	;

1.12.1.2.1.1
date	97.07.28.18.25.06;	author daveb;	state Exp;
branches
	1.12.1.2.1.1.1.1;
next	;

1.12.1.2.1.1.1.1
date	97.10.07.11.51.00;	author jkbrook;	state Exp;
branches;
next	;

1.12.1.2.2.1
date	97.09.08.17.18.20;	author daveb;	state Exp;
branches;
next	;

1.12.1.2.3.1
date	97.09.09.14.14.31;	author daveb;	state Exp;
branches;
next	;

1.21.1.1
date	97.09.10.19.30.56;	author brucem;	state Exp;
branches;
next	;

1.21.2.1
date	97.09.11.21.00.31;	author daveb;	state Exp;
branches;
next	;

1.21.3.1
date	97.10.31.13.43.37;	author nickb;	state Exp;
branches;
next	;

1.22.1.1
date	99.04.01.18.00.38;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.22
log
@[Bug #70034]
Rationalising names in mem.h
@
text
@/*  ==== ROBUST MEMORY ALLOCATION ====
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  Simple address-ordered first fit, with a few limitations:
 * 
 *  - Freed memory is never returned to the arena;
 *  - Chunks of memory obtained from the arena are never merged;
 * - if swap runs out, the arena manager will do its "out of swap"
 *    routines, including a fatal runtime error; malloc() will not
 *    return NULL;
 *  - Attempting to allocate a single object larger than an arena "space"
 *    (currently 16Mb) causes a fatal error;
 *  - Allocating from a large block takes the tail; this interacts badly with
 *    shrinking reallocs and with the common case of a growing heap;
 *  - realloc() is just malloc/copy/free;
 *  - free() traverses the free list for merging, instead of using boundary
 *    tags.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:alloc.c,v $
 * Revision 1.21  1997/05/19  10:01:01  nickb
 * [Bug #30131]
 * General tidying up and improved commenting.
 *
 * Revision 1.20  1997/05/19  09:40:19  nickb
 * [Bug #30131]
 * Keep new blocks in strict address order.
 *
 * Revision 1.19  1997/05/16  15:35:44  nickb
 * [Bug #30131]
 * Improve free() and realloc() protection against bogus arguments.
 *
 * Revision 1.18  1997/05/16  15:23:16  nickb
 * [Bug #30131]
 * Reduce minimum object size.
 *
 * Revision 1.17  1997/05/16  15:21:18  nickb
 * [Bug #30131]
 * Remove DIAGNOSTICs which can cause fatal error.
 *
 * Revision 1.16  1997/05/16  15:20:27  nickb
 * [Bug #30131]
 * Remove unreachable code from realloc().
 *
 * Revision 1.15  1997/05/16  15:18:59  nickb
 * [Bug #30131]
 * Remove inline functions to make debugging easier.
 *
 * Revision 1.14  1997/05/16  15:17:55  nickb
 * [Bug #30131]
 * Make realloc() sign its offcuts so that free() doesn't warn on them.
 *
 * Revision 1.13  1997/05/02  16:40:14  jont
 * [Bug #20027]
 * Make extend take account of struct heap in call to make_heap
 *
 * Revision 1.12  1997/03/24  15:22:17  nickb
 * Stupid comment error.
 *
 * Revision 1.11  1997/03/24  15:03:32  nickb
 * Make malloc() and realloc() edge cases match the OS libraries.
 *
 * Revision 1.10  1996/07/31  11:46:03  stephenb
 * Update the malloc/calloc/free/realloc definitions so that their
 * signatures match the ANSI spec.
 *
 * Revision 1.9  1996/05/30  15:59:09  nickb
 * Add signature checking.
 *
 * Revision 1.8  1996/01/22  13:15:17  nickb
 * Add critical-region flag.
 * In due course malloc() will become re-entrant.
 * For now we have to fail gracefully.
 *
 * Revision 1.7  1995/08/30  13:15:42  jont
 * Add _msize replacement for bogus microsoft version
 * This is only a temporary measure
 *
 * Revision 1.6  1995/08/15  12:11:27  nickb
 * Foolish mistake.
 *
 * Revision 1.4  1994/10/14  15:45:55  nickb
 * Change diagnostic level of message given when freeing NULL (it was 0).
 *
 * Revision 1.3  1994/10/03  15:30:09  jont
 * Fix free to handle NULL pointers
 *
 * Revision 1.2  1994/06/09  14:31:38  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:56:23  nickh
 * new file
 *
 *  Revision 2.3  1994/01/28  17:21:56  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 2.2  1993/04/26  11:47:55  richard
 *  Increased diagnostic level of messages from realloc().
 *
 *  Revision 2.1  1993/01/26  10:29:30  richard
 *  A new version using a simple linked list scheme.  The old version has
 *  bugs in it somewhere, and in any case was very slow.  We are now less
 *  likely to have random memory scrawling bugs -- ML has been running
 *  reliably for some time.
 *
 *  Revision 1.13  1992/10/02  08:38:16  richard
 *  Changed types to become non-standard but compatable with GCC across
 *  platforms.
 *
 *  Revision 1.12  1992/07/20  13:14:22  richard
 *  Removed init_alloc(), and caused allocation to automatically request
 *  an initial area when first called.  This simplifies the interface to
 *  the memory manager.
 *
 *  Revision 1.11  1992/06/30  13:36:04  richard
 *  New areas of C heap are now allocated using a special function to
 *  avoid revealing anything about the memory configuration.
 *
 *  Revision 1.10  1992/04/10  11:17:44  clive
 *  I realloc a call to malloc meant that the side of the object being
 *  reallocated was calculated incorrectly
 *
 *  Revision 1.9  1992/03/27  14:58:54  richard
 *  Corrected several bugs and tidied up.
 *
 *  Revision 1.8  1992/03/12  17:10:31  richard
 *  Changed realloc() to deal with a NULL pointer properly.
 *
 *  Revision 1.7  1992/03/10  13:53:02  richard
 *  Chaned call to allocate_blocks() as memory arrangement has changed.
 *
 *  Revision 1.6  1992/02/13  16:14:17  clive
 *  Forgot to take out my debugging messages
 *
 *  Revision 1.4  1992/02/13  11:42:13  clive
 *  Typo in find_space : (i-1) instead of -1
 *
 *  Revision 1.3  1992/02/13  10:52:08  clive
 *  There was a typo += instead of -= in alloc
 *
 *  Revision 1.2  1992/01/20  13:20:16  richard
 *  Shifted diagnostic level of debugging messages up to 4.
 *
 *  Revision 1.1  1992/01/17  12:17:07  richard
 *  Initial revision
 */

/* Relevant documentation for memory management functions:

   ANSI/ISO C standard 7.10.3:

   "If the space cannot be allocated, a null pointer is returned."

   "If the size of the space requested is zero, the behavior is
   implementation-defined; the value returned shall be either a null
   pointer or a unique pointer."

   "[free] If ptr is a null pointer, no action occurs."

   "[realloc] If ptr is a null pointer, the realloc function behaves
   like the malloc function for the specified size. [...] If size is
   zero and ptr is not a null pointer, the object it points to is
   freed."
   
   Irix man page: "after free is performed this space is made
   available for further allocation, but its contents are left
   undisturbed."

   Irix man page: " When called with size of zero, malloc returns a
   valid pointer to a block of zero bytes.  Storage into a block of
   length zero will corrupt malloc's arena, and may have serious
   consequences."

   SunOS 4 man page: "For backwards compatibility, realloc() accepts a
   pointer to a block freed since the most recent call to malloc(),
   calloc(), realloc(), valloc(), or memalign()."
   [ we don't currently support this case ]

   Irix 5.3 libelf.a has code which frees the same object twice
   consecutively, so we have to handle that case also.

   Every operating system has different behaviour on the edge cases
   malloc(0), realloc(NULL,0), realloc(p,0). Sadly, some libraries,
   such as X, rely on this. We support it by calling os_allocator().
   See os.h and the implementations in OS/$OS/os.c. See 
  <URI:spring://MM_InfoSys/analysis/realloc> for more information.

 */

#include "alloc.h"
#include "utils.h"
#include "mem.h"
#include "diagnostic.h"
#include "extensions.h"
#include "os.h"

#include <stddef.h>
#include <memory.h>

#define ALIGN_BITS              3u            /* number of bits of alignment */
#define ALIGNMENT               (1u << ALIGN_BITS)
#define ALIGN(x)                (((x) + ALIGNMENT-1u) & ~(ALIGNMENT-1u))
#define ALIGNED(p)              ((((word)p) & (ALIGNMENT-1u)) == 0)

#define MINIMUM_CHUNK_SIZE      0x10000         /* see extend() */
#define MINIMUM_BLOCK_SIZE      ALIGN(16)       /* aligned, includes header */
#define BLOCK_TO_P(block)       ((char *)(block+1))
#define P_TO_BLOCK(p)           ((struct header *)((char *)(p)) - 1)

#define AFTER_BLOCK(block)      ((struct header *)((char *)(block) + (block)->size))

/* signature of allocated blocks */

#define MALLOC_SIG              ((struct header *)0xa110c51)


/*  == Block header structure ==
 *
 *  This header is stored at the start of each block, allocated or
 *  unallocated.  It must be of aligned length.
 */

struct header
{
  struct header *next;          /* pointer to next block on free list */
                                /* when allocated, this is MALLOC_SIG */
  size_t size;                  /* size of block including header */
};

static struct header *free_list = NULL;


/*  == Extend C heap ==
 *
 *  Calls the storage manager to fetch a new chunk of memory,
 *  initialises it as one large free block, and inserts that block on the
 *  free list. Chunks of memory are never merged and so allocated objects
 *  never cross the boundary between them.
 */

static void extend(size_t required)
{
  struct c_heap *heap;
  struct header *new;
  struct header *insert, **last;

  required += sizeof(struct c_heap);
  if (required < MINIMUM_CHUNK_SIZE)
    required = MINIMUM_CHUNK_SIZE;

  heap = make_heap(NULL, required);

  new = (struct header *)((char *)heap + ALIGN(sizeof(struct c_heap)));

  new->next = NULL;
  new->size = heap->size - ALIGN(sizeof(struct c_heap));

  /* insert new block into free list */
  insert = free_list;
  last = &free_list;
  while(insert && (insert < new)) {
    last = &insert->next;
    insert = insert->next;
  }
  *last = new;
  new->next = insert;
}

/*  == Calculate block length from request ==  */

static size_t block_size(size_t request)
{
  size_t rounded = ALIGN(request + sizeof(struct header));
  if (rounded < MINIMUM_BLOCK_SIZE)
    rounded = MINIMUM_BLOCK_SIZE;
  return rounded;
}

static int in_malloc_free = 0;

#define ENTER_MALLOC_FREE                                               \
        do {                                                            \
          if (in_malloc_free)                                           \
            error("Re-entering malloc() or free()");                    \
          else                                                          \
            in_malloc_free = 1;                                         \
        } while (0)

#define LEAVE_MALLOC_FREE                                               \
        do {                                                            \
          in_malloc_free = 0;                                           \
        } while(0)

/*  === ALLOCATE MEMORY ===
 *
 *  Searches the free list for the first block large enough to satisfy the
 *  request.  If the block is much larger than requested it is split into
 *  two.  If the end of the list is reached the C heap is extended by
 *  calling the storage manager.  Note that this version never returns NULL.
 */

void *malloc(size_t requested)
{
  size_t required;

  if (requested == 0)
    return os_allocator(OS_ALLOCATOR_MALLOC_ZERO, NULL);

  required = block_size(requested);

  ENTER_MALLOC_FREE;

  for(;;) {
    struct header *block = free_list;
    struct header **last = &free_list;

    while(block) {
      struct header *next = block->next;
      size_t size = block->size;

      if(size >= required) {    /* we have a fit */
        if(size < required + MINIMUM_BLOCK_SIZE) {
          *last = next;         /* return the whole block */
          block->next = MALLOC_SIG;
          LEAVE_MALLOC_FREE;
          return BLOCK_TO_P(block);
        } else {                /* return a tail of the block */
          size_t remaining = size-required;
          struct header *new = (struct header *)((char *)block + remaining);
          new->size = required;
          new->next = MALLOC_SIG;
          block->size = remaining;
          LEAVE_MALLOC_FREE;
          return BLOCK_TO_P(new);
        }
      }

      last = &block->next;
      block = next;
    }

    extend(required);
    /* have to rescan as the new block may be in the middle of the free list */
  }
}



/* Note that this implementation relies on the fact that
 * the malloc used (as defined above) never returns NULL.
 */
void *calloc(size_t number, size_t size)
{
  size_t total = number * size;
  return(memset(malloc(total), 0, total));
}



/* function to check that a pointer has been returned from
 * malloc(). For instance, Motif on Solaris calls free(garbage). */

static struct header *check_malloced(void *p)
{
  struct header *block;
  
  if (TYPE(p) != TYPE_C_HEAP) {
#ifdef DEBUG
    message_stderr("free/realloc(0x%08x), not in the heap",p);
#endif
    return NULL;
  }
  if (!ALIGNED(p)) {
#ifdef DEBUG
    message_stderr("free/realloc(0x%08x), not aligned",p);
#endif
    return NULL;
  }
  block = P_TO_BLOCK(p);
  if (block->next != MALLOC_SIG) {
#ifdef DEBUG
    message_stderr("free/realloc(0x%08x), not returned by malloc()",p);
#endif
    return NULL;
  }
  return block;
}

/* Free an allocated block of memory. Memory is never returned to the arena. */

void free(void *p)
{
  struct header *prev, *next, *block;
  if (p == NULL)
    return;

  block = check_malloced(p);
  if (block == NULL) /* not malloced */
    return;

  ENTER_MALLOC_FREE;
  
  if (free_list && (free_list <= block)) {
    /* find blocks immediately before and after */
    next = free_list;
    do {
      prev = next;
      next = prev->next;
    } while((next != NULL) && (next <= block));
    
    if (block < AFTER_BLOCK(prev)) {
      /* freeing already-free data */
      LEAVE_MALLOC_FREE;
      return;
    }
    /* insert into the list */
    block->next = next;
    prev->next = block;
    
    if (AFTER_BLOCK(block) == next) { /* merge with next */
      block->size += next->size;
      block->next = next->next;
    }
    if (AFTER_BLOCK(prev) == block) { /* merge with previous */
      prev->size += block->size;
      prev->next = block->next;
    }
  } else {
    /* before the first item */
    if (free_list && (AFTER_BLOCK(block) == free_list)) {
      /* merge with the first item */
      block->size += free_list->size;
      free_list = free_list->next;
    }
    /* add to the head of the list */
    block->next = free_list;
    free_list = block;
  }
  LEAVE_MALLOC_FREE;
}


/*  === REALLOCATE MEMORY ===
 *
 *  If the requested size is much smaller than the current size the block is
 *  split, otherwise a simple policy of allocating and moving the contents
 *  is followed.  This could be cleverer and steal memory from the following
 *  block instead, but such cases are relatively rare and it's probably not
 *  worth it.
 */

void *realloc(void *p, size_t requested)
{
  struct header *block;
  size_t required = block_size(requested);
  size_t size;

  if (requested == 0) {
    if (p == NULL)
      return os_allocator(OS_ALLOCATOR_REALLOC_NULL_ZERO, NULL);
    else
      return os_allocator(OS_ALLOCATOR_REALLOC_P_ZERO, p);
  }
  
  if (p == NULL)
    return(malloc(requested));

  block = check_malloced(p);
  if (block == NULL) /* this block never allocated */
    return NULL;

  size = block->size;

  if(size >= required) {
    /* don't copy */
    if(size >= required + MINIMUM_BLOCK_SIZE) {
      /* truncate */
      struct header *new = (struct header *)((char *)block + required);
      new->size = size-required;
      new->next = MALLOC_SIG;
      block->size = required;
      free(BLOCK_TO_P(new));
    }
    return(p);
  } else {
    char *new = malloc(requested);
    
    memcpy(new,p, size - sizeof(struct header));
    free(p);
    
    return(new);
  }
}  

#ifdef OS_NT
/* This function only to replace the bogus Microsoft version */
/* which assumes internals details of malloc/free */

size_t _msize(void *p)
{
  struct header *block = P_TO_BLOCK(p);
  return(block->size);
}
#endif
@


1.22.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a24 4
 * Revision 1.22  1998/04/23  13:15:59  jont
 * [Bug #70034]
 * Rationalising names in mem.h
 *
@


1.21
log
@[Bug #30131]
General tidying up and improved commenting.
@
text
@d25 4
d247 1
a247 1
  struct heap *heap;
d251 1
a251 1
  required += sizeof(struct heap);
d257 1
a257 1
  new = (struct header *)((char *)heap + ALIGN(sizeof(struct heap)));
d260 1
a260 1
  new->size = heap->size - ALIGN(sizeof(struct heap));
d371 1
a371 1
  if (TYPE(p) != TYPE_HEAP) {
@


1.21.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a24 4
 * Revision 1.21  1997/05/19  10:01:01  nickb
 * [Bug #30131]
 * General tidying up and improved commenting.
 *
@


1.21.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a24 4
 * Revision 1.21  1997/05/19  10:01:01  nickb
 * [Bug #30131]
 * General tidying up and improved commenting.
 *
@


1.21.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a24 4
 * Revision 1.21  1997/05/19  10:01:01  nickb
 * [Bug #30131]
 * General tidying up and improved commenting.
 *
@


1.20
log
@[Bug #30131]
Keep new blocks in strict address order.
@
text
@d7 14
a20 1
 *  Simple first fit linked list.
d25 4
a145 1
 *
d200 4
a203 11
#define ALIGN_BITS		3 	      /* number of bits of alignment */
#define ALIGNMENT		(1u << ALIGN_BITS)
#define ALIGN(x)		(((x) + ALIGNMENT-1u) & ~(ALIGNMENT-1u))
#define ALIGNED(p)		((((word)p) & (ALIGNMENT-1u)) == 0)

#define MINIMUM_CHUNK_SIZE	0x10000		/* see extend() */
#define FUDGE_FACTOR		ALIGN(0)	/* added to the end of all blocks */
#define SMUDGE_FACTOR		ALIGN(0)	/* added to the beginning of all blocks */
#define MINIMUM_BLOCK_SIZE	ALIGN(16)	/* aligned, includes header */
#define BLOCK_TO_P(block)	((char *)(block+1) + SMUDGE_FACTOR)
#define P_TO_BLOCK(p)		((struct header *)((char *)(p) - SMUDGE_FACTOR) - 1)
d205 4
a208 1
#define AFTER_BLOCK(block)	((struct header *)((char *)(block) + (block)->size))
d210 5
a214 1
#define MALLOC_SIG		((struct header *)0xa110c51)
d225 3
a227 3
  struct header *next;		/* pointer to next block on free list */
  				/* when allocated, this is MALLOC_SIG */
  size_t size;			/* size of block including header */
d273 4
a276 2
  size_t rounded = ALIGN(request + sizeof(struct header) + SMUDGE_FACTOR + FUDGE_FACTOR);
  return(rounded < MINIMUM_BLOCK_SIZE ? MINIMUM_BLOCK_SIZE : rounded);
d281 12
a292 12
#define ENTER_MALLOC_FREE						\
	do {								\
	  if (in_malloc_free)						\
	    error("Re-entering malloc() or free()");			\
	  else								\
	    in_malloc_free = 1;						\
	} while (0)

#define LEAVE_MALLOC_FREE						\
	do {								\
	  in_malloc_free = 0;						\
	} while(0)
d321 15
a335 15
      if(size >= required) {	/* we have a fit */
	if(size < required + MINIMUM_BLOCK_SIZE) {
	  *last = next;		/* return the whole block */
	  block->next = MALLOC_SIG;
	  LEAVE_MALLOC_FREE;
	  return (BLOCK_TO_P(block));
	} else {		/* return a tail of the block */
	  size_t remaining = size-required;
	  struct header *new = (struct header *)((char *)block + remaining);
	  new->size = required;
	  new->next = MALLOC_SIG;
	  block->size = remaining;
	  LEAVE_MALLOC_FREE;
	  return (BLOCK_TO_P(new));
	}
a348 1

d389 2
d394 1
a394 1
  if (p == NULL) {
a395 1
  }
d467 1
a467 1
  
d488 1
a488 1
    memcpy(new,p, size - sizeof(struct header) - (SMUDGE_FACTOR+FUDGE_FACTOR));
a497 2
/* This is a temporary situation until we sort out using */
/* the system supplied malloc for system supplied calls */
@


1.19
log
@[Bug #30131]
Improve free() and realloc() protection against bogus arguments.
@
text
@d12 4
d219 4
a222 3
 *  Calls the storage manager to fetch a new chunk of memory, and
 *  initialises it as one large free block.  It returns the address of that
 *  block.
d225 1
a225 1
static struct header *extend(size_t required)
d228 2
a229 1
  struct header *start;
d237 1
a237 1
  start = (struct header *)((char *)heap + ALIGN(sizeof(struct heap)));
d239 2
a240 2
  start->next = NULL;
  start->size = heap->size - ALIGN(sizeof(struct heap));
d242 9
a250 1
  return(start);
a252 1

d286 1
a286 2
  struct header *block, **last;
  size_t required = block_size(requested);
d291 2
d295 3
a297 2
  last = &free_list;
  block = free_list;
a298 1
  for(;;) {
d324 2
a325 2
    block = extend(required);
    *last = block;
@


1.18
log
@[Bug #30131]
Reduce minimum object size.
@
text
@d12 4
d180 4
a183 2
#define ALIGNMENT		3 		/* number of bits of alignment */
#define ALIGN(x)		(((x) + (1u<<ALIGNMENT) - 1u) & ~((1u<<ALIGNMENT)-1u))
d329 2
d332 25
d360 1
d363 1
a363 3
  } else {
    struct header *prev, *next, *block;
    block = P_TO_BLOCK(p);
d365 3
a367 2
    /* check signature; we have to survive free(random_crap). For
     * instance, Motif on Solaris does it */
d369 13
a381 4
    if (block->next != MALLOC_SIG) {
#ifdef DEBUG
      message_stderr("free() of 0x%08x, which was not malloc'ed", p);
#endif
d384 18
a401 37
    ENTER_MALLOC_FREE;

    if (free_list && (free_list <= block)) {
      /* find blocks immediately before and after */
      next = free_list;
      do {
	prev = next;
	next = prev->next;
      } while((next != NULL) && (next <= block));
      
      if (block < AFTER_BLOCK(prev)) {
	/* freeing already-free data */
	LEAVE_MALLOC_FREE;
	return;
      }
      /* insert into the list */
      block->next = next;
      prev->next = block;
      
      if (AFTER_BLOCK(block) == next) { /* merge with next */
	block->size += next->size;
	block->next = next->next;
      }
      if (AFTER_BLOCK(prev) == block) { /* merge with previous */
	prev->size += block->size;
	prev->next = block->next;
      }
    } else {
      /* before the first item */
      if (free_list && (AFTER_BLOCK(block) == free_list)) {
	/* merge with the first item */
	block->size += free_list->size;
	free_list = free_list->next;
      }
      /* add to the head of the list */
      block->next = free_list;
      free_list = block;
d403 3
d436 4
a439 1
  block = P_TO_BLOCK(p);
@


1.17
log
@[Bug #30131]
Remove DIAGNOSTICs which can cause fatal error.
@
text
@d12 4
d182 1
a182 1
#define MINIMUM_BLOCK_SIZE	ALIGN(0x80)	/* aligned, includes header */
@


1.16
log
@[Bug #30131]
Remove unreachable code from realloc().
@
text
@d12 4
a221 3

  DIAGNOSTIC(5, "alloc extend(required = 0x%X)", required, 0);
  DIAGNOSTIC(5, "  new memory at 0x%X length 0x%X", heap, heap->size);
@


1.15
log
@[Bug #30131]
Remove inline functions to make debugging easier.
@
text
@d12 4
a404 5
  if (requested == 0) {
    free(p);
    return NULL;
  }

@


1.14
log
@[Bug #30131]
Make realloc() sign its offcuts so that free() doesn't warn on them.
@
text
@d12 4
d202 1
a202 1
static inline struct header *extend(size_t required)
d227 1
a227 1
static inline size_t block_size(size_t request)
@


1.13
log
@[Bug #20027]
Make extend take account of struct heap in call to make_heap
@
text
@d12 4
d411 1
@


1.12
log
@Stupid comment error.
@
text
@d12 3
d199 5
a203 1
  heap = make_heap(NULL, required > MINIMUM_CHUNK_SIZE ? required : MINIMUM_CHUNK_SIZE);
@


1.12.1.1
log
@branched from 1.12
@
text
@a11 3
 * Revision 1.12  1997/03/24  15:22:17  nickb
 * Stupid comment error.
 *
@


1.12.1.2
log
@[Bug #20027]
Make extend take account of struct heap in call to make_heap.
@
text
@a11 8
 *
 * Revision 1.12.1.1  1997/05/12  10:45:28  hope
 * branched from 1.12
 *
 * Revision 1.13  1997/05/02  16:40:14  jont
 * [Bug #20027]
 * Make extend take account of struct heap in call to make_heap
 *
d199 1
a199 5
  required += sizeof(struct heap);
  if (required < MINIMUM_CHUNK_SIZE)
    required = MINIMUM_CHUNK_SIZE;

  heap = make_heap(NULL, required);
@


1.12.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 4
 * Revision 1.12.1.2  1997/05/14  13:47:56  daveb
 * [Bug #20027]
 * Make extend take account of struct heap in call to make_heap.
 *
@


1.12.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 4
 * Revision 1.12.1.2  1997/05/14  13:47:56  daveb
 * [Bug #20027]
 * Make extend take account of struct heap in call to make_heap.
 *
@


1.12.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 4
 * Revision 1.12.1.2  1997/05/14  13:47:56  daveb
 * [Bug #20027]
 * Make extend take account of struct heap in call to make_heap.
 *
@


1.12.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 3
 * Revision 1.12.1.2.1.1  1997/07/28  18:25:06  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.11
log
@Make malloc() and realloc() edge cases match the OS libraries.
@
text
@d12 3
d138 1
a138 1
   See os.h and the implementations in OS/*/os.c. See 
@


1.10
log
@Update the malloc/calloc/free/realloc definitions so that their
signatures match the ANSI spec.
@
text
@d12 4
d130 9
a138 1
   consecutively, so we have to handle that case also. */
d145 1
d243 3
d373 7
@


1.10.8.1
log
@branched from 1.10
@
text
@a11 4
 * Revision 1.10  1996/07/31  11:46:03  stephenb
 * Update the malloc/calloc/free/realloc definitions so that their
 * signatures match the ANSI spec.
 *
@


1.10.7.1
log
@branched from 1.10
@
text
@a11 4
 * Revision 1.10  1996/07/31  11:46:03  stephenb
 * Update the malloc/calloc/free/realloc definitions so that their
 * signatures match the ANSI spec.
 *
@


1.10.7.1.1.1
log
@branched from 1.10.7.1
@
text
@a11 3
 * Revision 1.10.7.1  1996/12/17  17:57:07  hope
 * branched from 1.10
 *
@


1.10.6.1
log
@branched from 1.10
@
text
@a11 4
 * Revision 1.10  1996/07/31  11:46:03  stephenb
 * Update the malloc/calloc/free/realloc definitions so that their
 * signatures match the ANSI spec.
 *
@


1.10.5.1
log
@branched from 1.10
@
text
@a11 4
 * Revision 1.10  1996/07/31  11:46:03  stephenb
 * Update the malloc/calloc/free/realloc definitions so that their
 * signatures match the ANSI spec.
 *
@


1.10.4.1
log
@branched from 1.10
@
text
@a11 4
 * Revision 1.10  1996/07/31  11:46:03  stephenb
 * Update the malloc/calloc/free/realloc definitions so that their
 * signatures match the ANSI spec.
 *
@


1.10.4.1.1.1
log
@branched from 1.10.4.1
@
text
@a11 3
 * Revision 1.10.4.1  1996/11/14  13:00:58  hope
 * branched from 1.10
 *
@


1.10.3.1
log
@branched from 1.10
@
text
@a11 4
 * Revision 1.10  1996/07/31  11:46:03  stephenb
 * Update the malloc/calloc/free/realloc definitions so that their
 * signatures match the ANSI spec.
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a11 4
 * Revision 1.10  1996/07/31  11:46:03  stephenb
 * Update the malloc/calloc/free/realloc definitions so that their
 * signatures match the ANSI spec.
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a11 4
 * Revision 1.10  1996/07/31  11:46:03  stephenb
 * Update the malloc/calloc/free/realloc definitions so that their
 * signatures match the ANSI spec.
 *
@


1.9
log
@Add signature checking.
@
text
@d12 3
d225 1
a225 1
char *malloc(size_t requested)
a265 1
/*  === ALLOCATE AND CLEAR ===  */
d267 6
a272 1
char *calloc(size_t number, size_t size)
a277 1
/*  === FREE ALLOCATED BLOCK ===  */
d279 4
a282 1
int free(void *p)
d284 3
a286 3
  if (p == NULL)
    return 1;
  else {
d297 1
a297 1
      return 1;
d312 1
a312 1
	return 1;
a338 1
  return 1;
d351 1
a351 1
char *realloc(void *p, size_t requested)
@


1.8
log
@Add critical-region flag.
In due course malloc() will become re-entrant.
For now we have to fail gracefully.
@
text
@d12 5
d146 2
d158 1
d240 1
d247 1
d281 9
@


1.7
log
@Add _msize replacement for bogus microsoft version
This is only a temporary measure
@
text
@d12 4
d121 1
d191 15
d219 2
d232 1
d239 1
d271 2
d283 1
d310 1
@


1.6
log
@Foolish mistake.
@
text
@d12 3
d332 13
@


1.5
log
@Allow free() to accept already-free pointers.
@
text
@d108 1
a108 1
   [ this could be hard to ensure ]
d299 1
a299 2
  if (p == NULL) {
    message("realloc(NULL,size)");
a300 1
  }
a302 1
    message("realloc(p,0)");
@


1.4
log
@Change diagnostic level of message given when freeing NULL (it was 0).
@
text
@d12 3
d79 33
d131 2
a179 1

a182 1

a195 3
  DIAGNOSTIC(5, "malloc(requested = 0x%X) requires 0x%X", requested, required);
  DIAGNOSTIC(5, "  free_list = 0x%X", free_list, 0);

d199 2
a200 4
  for(;;)
  {
    while(block)
    {
d204 10
a213 17
      if(size >= required)
      {
	DIAGNOSTIC(5, "  found block at 0x%X size 0x%X", block, size);
	DIAGNOSTIC(5, "  last = 0x%X  next = 0x%X", last, next);

	if(size < required + MINIMUM_BLOCK_SIZE)
	  *last = next;
	else
	{
	  struct header *new = (struct header *)((char *)block + required);

	  DIAGNOSTIC(5, "  splitting at 0x%X", new, 0);

	  block->size = required;
	  *last = new;
	  new->next = next;
	  new->size = size - required;
a214 4

	DIAGNOSTIC(5, "  returning 0x%X", BLOCK_TO_P(block), 0);

	return(BLOCK_TO_P(block));
a221 1

a225 1

a233 23

/*  == Find nearest blocks on free list ==
 *
 *  Searches the free list for the block immediately preceeding the block
 *  passed.  Returns NULL if there is no preceeding block.
 */

static inline struct header *find(struct header *block)
{
  struct header *b = free_list;

  if(b && b < block)
  {
    while(b->next && b->next < block)
      b = b->next;

    return(b);
  }

  return(NULL);
}


d238 1
a238 2
  if (p == NULL) {
    DIAGNOSTIC(5, "Free: zero pointer", 0, 0);
d240 18
a257 14
  } else {
    struct header *block = P_TO_BLOCK(p);
    struct header *prev = find(block);

    DIAGNOSTIC(5, "free(0x%X) free_list = 0x%X", p, free_list);
    DIAGNOSTIC(5, "  block 0x%X  size 0x%X", block, block->size);
  
    if(prev) {
      struct header *next = prev->next;

      DIAGNOSTIC(5, "  prev 0x%X  size 0x%X", prev, prev->size);
      DIAGNOSTIC(5, "  next 0x%X  size 0x%X", next, next ? next->size : 0);

      /* Firstly, insert the block into the free list. */
d259 2
a260 4
      block->next = next;

      /* If the block touches the next free block, merge them. */
      if((struct header *)((char *)block + block->size) == next) {
d262 1
a262 2
	block->next = next->next; 
	DIAGNOSTIC(5, "  merged block with next, size now 0x%X", block->size, 0);
d264 1
a264 3

      /* If the block touches the previous free block, merge them. */
      if((struct header *)((char *)prev + prev->size) == block) {
a266 1
	DIAGNOSTIC(5, "  merged prev with block, size now 0x%X", prev->size, 0);
d269 7
d280 1
a280 1
  return(1);
d299 2
a300 1
  if(!p)
d302 7
d313 4
a316 8
  DIAGNOSTIC(5, "realloc(p = 0x%X, requested = 0x%X)", p, requested);
  DIAGNOSTIC(5, "  requires 0x%X", required, 0);
  DIAGNOSTIC(5, "  block 0x%X current size 0x%X", block, size);

  if(size >= required)
  {
    if(size >= required + MINIMUM_BLOCK_SIZE)
    {
d318 1
a318 4
      struct header *prev = find(block);

      DIAGNOSTIC(5, "  splitting at 0x%X", new, 0);

d320 1
a320 12
      new->size = size - required;

      if(prev)
      {
	new->next = prev->next;
	prev->next = new;
      }
      else
      {
	new->next = free_list;
	free_list = new;
      }
a321 1

d323 1
a323 3
  }
  else
  {
d325 2
a326 2

    memcpy(new, p, size - sizeof(struct header) - (SMUDGE_FACTOR + FUDGE_FACTOR));
d328 1
a328 1

@


1.3
log
@Fix free to handle NULL pointers
@
text
@d12 3
d244 1
a244 1
    DIAGNOSTIC(0, "Free: zero pointer", 0, 0);
@


1.2
log
@new file
@
text
@d12 3
d240 6
a245 2
  struct header *block = P_TO_BLOCK(p);
  struct header *prev = find(block);
d247 2
a248 2
  DIAGNOSTIC(5, "free(0x%X) free_list = 0x%X", p, free_list);
  DIAGNOSTIC(5, "  block 0x%X  size 0x%X", block, block->size);
d250 2
a251 3
  if(prev)
  {
    struct header *next = prev->next;
d253 2
a254 2
    DIAGNOSTIC(5, "  prev 0x%X  size 0x%X", prev, prev->size);
    DIAGNOSTIC(5, "  next 0x%X  size 0x%X", next, next ? next->size : 0);
d256 10
a265 3
    /* Firstly, insert the block into the free list. */
    prev->next = block;
    block->next = next;
d267 9
a275 6
    /* If the block touches the next free block, merge them. */
    if((struct header *)((char *)block + block->size) == next)
    {
      block->size += next->size;
      block->next = next->next; 
      DIAGNOSTIC(5, "  merged block with next, size now 0x%X", block->size, 0);
a276 8

    /* If the block touches the previous free block, merge them. */
    if((struct header *)((char *)prev + prev->size) == block)
    {
      prev->size += block->size;
      prev->next = block->next;
      DIAGNOSTIC(5, "  merged prev with block, size now 0x%X", prev->size, 0);
    }
a277 6
  else
  {
    block->next = free_list;
    free_list = block;
  }

@


1.2.1.1
log
@branched from 1.2
@
text
@a11 3
 * Revision 1.2  1994/06/09  14:31:38  nickh
 * new file
 *
@


1.1
log
@new file
@
text
@d11 4
a14 1
 *  $Log: alloc.c,v $
@
