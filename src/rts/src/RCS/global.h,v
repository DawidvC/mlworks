head	1.8;
access;
symbols
	MLW_daveb_inline_1_4_99:1.8.1
	MLWorks_21c0_1999_03_25:1.8
	MLWorks_20c1_1998_08_20:1.7
	MLWorks_20c0_1998_08_04:1.7
	MLWorks_20b2c2_1998_06_19:1.7
	MLWorks_20b2_Windows_1998_06_12:1.7
	MLWorks_20b1c1_1998_05_07:1.7
	MLWorks_20b0_1998_04_07:1.7
	MLWorks_20b0_1998_03_20:1.7
	MLWorks_20m2_1998_02_16:1.7
	MLWorks_MM_adapt:1.7.12
	MLWorks_20m1_1997_10_23:1.7
	MLWorks_11r1:1.7.9.1.1.1.1
	MLWorks_workspace_97:1.7.11
	MLWorks_dt_wizard:1.7.10
	MLWorks_11c0_1997_09_09:1.7.9.1.1.1
	MLWorks_10r3:1.7.9.1.3
	MLWorks_10r2_551:1.7.9.1.2
	MLWorks_11:1.7.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.7.9.1
	MLWorks_20m0_1997_06_20:1.7
	MLWorks_1_0_r2c2_1997_06_14:1.7.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.7.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.7.9
	MLWorks_BugFix_1997_04_24:1.7
	MLWorks_1_0_r2_Win32_1997_04_11:1.7
	MLWorks_1_0_r2_Unix_1997_04_04:1.7
	MM_ML_release_korma_1997_04_01:1.7
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.7.7.1.1
	MLWorks_gui_1996_12_18:1.7.8
	MLWorks_1_0_Win32_1996_12_17:1.7.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.7.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.7.4.1
	JFHrts:1.7.6
	MLWorks_1_0_Irix_1996_11_28:1.7.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.7.5
	MLWorks_1_0_Unix_1996_11_14:1.7.4
	MLWorks_Open_Beta2_1996_10_11:1.7.3
	MLWorks_License_dev:1.7.2
	MLWorks_1_open_beta_1996_09_13:1.7.1
	MLWorks_Open_Beta_1996_08_22:1.7
	MLWorks_Beta_1996_07_02:1.7
	MLWorks_Beta_1996_06_07:1.5
	MLWorks_Beta_1996_06_06:1.5
	MLWorks_Beta_1996_06_05:1.5
	MLWorks_Beta_1996_06_03:1.5
	MLWorks_Beta_1996_05_31:1.5
	MLWorks_Beta_1996_05_30:1.5
	hope_poo:1.2.1
	ML_beta_release_12/08/94:1.2.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.8
date	98.07.07.16.28.54;	author jont;	state Exp;
branches
	1.8.1.1;
next	1.7;

1.7
date	96.07.01.09.00.30;	author nickb;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1
	1.7.4.1
	1.7.5.1
	1.7.6.1
	1.7.7.1
	1.7.8.1
	1.7.9.1
	1.7.10.1
	1.7.11.1
	1.7.12.1;
next	1.6;

1.6
date	96.06.27.15.49.32;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	96.02.19.13.54.18;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	96.02.16.18.39.22;	author nickb;	state Exp;
branches;
next	1.3;

1.3
date	96.02.16.14.35.10;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.36.39;	author nickh;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	94.06.09.11.03.33;	author nickh;	state Exp;
branches;
next	;

1.2.1.1
date	95.07.05.10.30.12;	author hope;	state Exp;
branches;
next	;

1.7.1.1
date	96.09.13.11.21.14;	author hope;	state Exp;
branches;
next	;

1.7.2.1
date	96.10.07.16.11.15;	author hope;	state Exp;
branches;
next	;

1.7.3.1
date	96.10.17.11.29.47;	author hope;	state Exp;
branches;
next	;

1.7.4.1
date	96.11.14.12.55.42;	author hope;	state Exp;
branches
	1.7.4.1.1.1;
next	;

1.7.4.1.1.1
date	96.11.28.15.06.21;	author hope;	state Exp;
branches;
next	;

1.7.5.1
date	96.11.22.18.14.01;	author hope;	state Exp;
branches;
next	;

1.7.6.1
date	96.12.17.10.00.49;	author hope;	state Exp;
branches;
next	;

1.7.7.1
date	96.12.17.17.52.32;	author hope;	state Exp;
branches
	1.7.7.1.1.1;
next	;

1.7.7.1.1.1
date	97.02.24.11.43.20;	author hope;	state Exp;
branches;
next	;

1.7.8.1
date	96.12.18.09.47.05;	author hope;	state Exp;
branches;
next	;

1.7.9.1
date	97.05.12.10.39.30;	author hope;	state Exp;
branches
	1.7.9.1.1.1
	1.7.9.1.2.1
	1.7.9.1.3.1;
next	;

1.7.9.1.1.1
date	97.07.28.18.27.22;	author daveb;	state Exp;
branches
	1.7.9.1.1.1.1.1;
next	;

1.7.9.1.1.1.1.1
date	97.10.07.11.53.22;	author jkbrook;	state Exp;
branches;
next	;

1.7.9.1.2.1
date	97.09.08.17.20.27;	author daveb;	state Exp;
branches;
next	;

1.7.9.1.3.1
date	97.09.09.14.16.34;	author daveb;	state Exp;
branches;
next	;

1.7.10.1
date	97.09.10.19.34.24;	author brucem;	state Exp;
branches;
next	;

1.7.11.1
date	97.09.11.21.03.28;	author daveb;	state Exp;
branches;
next	;

1.7.12.1
date	97.10.31.13.46.20;	author nickb;	state Exp;
branches;
next	;

1.8.1.1
date	99.04.01.18.02.27;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.8
log
@[Bug #30108]
Implement DLL based ML code
@
text
@/*  ==== GLOBAL C ROOTS ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Description
 *  -----------
 *  The runtime system needs to maintain some global C roots, such as the
 *  module table, debugger hook, etc.  These must be saved with a heap image
 *  and restored when it is reloaded.  This code takes care of organising
 *  the global roots.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:global.h,v $
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
 * Revision 1.6  1996/06/27  15:49:32  jont
 * Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
 *
 * Revision 1.5  1996/02/19  13:54:18  nickb
 * Add weak_save.
 *
 * Revision 1.4  1996/02/16  18:39:22  nickb
 * Add some default flag values.
 *
 * Revision 1.3  1996/02/16  14:35:10  nickb
 * Add more sophistication to global roots.
 *
 * Revision 1.2  1994/06/09  14:36:39  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:03:33  nickh
 * new file
 *
 *  Revision 1.4  1992/08/07  08:44:47  richard
 *  Added weak_length and changed the type of weak_apply.
 *
 *  Revision 1.3  1992/08/05  09:53:10  richard
 *  Added weak list utilities.
 *
 *  Revision 1.2  1992/07/24  10:40:07  richard
 *  Added a hook function to global roots.
 *
 *  Revision 1.1  1992/07/23  11:22:54  richard
 *  Initial revision
 *
 */

#ifndef global_h
#define global_h

#include "mltypes.h"


/*  === DECLARE A ROOT AS GLOBAL ===
 *
 *  This function is similar to declare_root() except that the root is
 *  remembered for inclusion in the global root (see below).  It
 *  performs an implicit declare_root().  The root must be given a
 *  unique name which is used by global_pack() and global_unpack() to
 *  save and restore the root in a value.  (The address of the root is
 *  not used as its `name' to maintain compatability between runtime
 *  systems and images.)
 *
 *  The name passed must not be updated or deallocated.
 *
 *  Various flags and functions may also be passed to control the
 * behaviour of the roots at save, deliver, and load times:
 *
 * 1. At SAVE/DELIVER time:
 *
 * if the save_fn is non-nil, the save_fn is called. If it returns DEAD, the
 *		root is not recorded in the image. Otherwise the value it
 *		returns is recorded.		
 * if the NIL flag is set, the root is set to MLUNIT.
 *              This helps make deliver images smaller.
 * if the save_fn is NULL and the RECORD flag is set, the root is recorded
 * 		in the image.
 * 
 * 2. At LOAD time:
 * 
 * if the load_fn is non-nil, it is applied to the root and the loaded value.
 * otherwise the root is set to the loaded value.
 *
 * 3. If the loaded image is MISSING a name:
 *
 * if the missing_fn is non-nil, it is called.
 * otherwise: if the WARN flag is set, a warning is issued
 *            if either the WARN or UNIT flag is set, the root is set to MLUNIT.
 *            if neither flag is set, a runtime error is caused.
 *
 * 4. If the loaded image contains an UNMATCHED name:
 * 
 * if the IGNORE flag is set, the name is disregarded.
 * otherwise if the WARN flag is set, a warning is issued.
 * if neither flag is set, a runtime error is caused.  */

#define GLOBAL_SAVE_RECORD	 0x1
#define GLOBAL_SAVE_UNIT		 0x2
#define GLOBAL_SAVE_FLAGS	 0x3

#define GLOBAL_DELIVER_RECORD	 0x10
#define GLOBAL_DELIVER_UNIT	 0x20
#define GLOBAL_DELIVER_FLAGS	 0x30
#define GLOBAL_DELIVER_SHIFT	4	    /* turns deliver into save flags */

#define GLOBAL_MISSING_ERROR	0x000
#define GLOBAL_MISSING_UNIT	0x100
#define GLOBAL_MISSING_WARN     0x200
#define GLOBAL_MISSING_FLAGS	0x300

#define GLOBAL_UNMATCHED_ERROR	     0x0000
#define GLOBAL_UNMATCHED_IGNORE	     0x1000
#define GLOBAL_UNMATCHED_WARN        0x2000
#define GLOBAL_UNMATCHED_FLAGS	     0x3000

/* global entries which are weak lists should set this bit in their
 * flags. The lists are then tidied up on delivery. */

#define GLOBAL_WEAK_LIST	     0x10000
#define GLOBAL_MISC_FLAGS	     0x10000

#define GLOBAL_ALL_FLAGS	(GLOBAL_SAVE_FLAGS +		\
				 GLOBAL_DELIVER_FLAGS + 	\
				 GLOBAL_MISSING_FLAGS + 	\
				 GLOBAL_UNMATCHED_FLAGS +       \
				 GLOBAL_MISC_FLAGS)

extern void declare_global
	(const char *name, mlval *root, word flags,
	 mlval (*save_fn)(const char *name, mlval *root, int deliver),
	 void (*load_fn)(const char *name, mlval *root, mlval value),
         void (*missing_fn)(const char *name, mlval *root));

/* global_save_die is a suitable save_fn for a function which should
 * always be recorded as MLUNIT in any saved image. i.e. it always
 * returns DEAD. */

extern mlval global_save_die(const char *name, mlval *root, int deliver);

/* GLOBAL_ENV is the right set of flags for a root which is concerned
 * with the environment: it ensures that the value is preserved on
 * image save but zapped on delivery. Such a root should also either
 * have the GLOBAL_MISSING_UNIT flag (if MLUNIT is a meaningful value
 * for it to have) or have a missing_fn defined, so that it can be
 * reconstructed when loading a delivered image.  */

#define	GLOBAL_ENV		(GLOBAL_SAVE_RECORD + \
				 GLOBAL_DELIVER_UNIT + \
				 GLOBAL_UNMATCHED_ERROR )

/* GLOBAL_TRANSIENT is the right set of flags for a root which holds
 * some value which is only relevant to the current runtime
 * invocation. For instance, a set of callbacks for the user
 * interface. Such a root will be zapped on delivery, and can be
 * zapped on image save (by using global_save_die as the save_fn), and
 * should either be reconstructed by a missing_fn or have
 * GLOBAL_MISSING_UNIT set (and reconstruct on first use) */

#define GLOBAL_TRANSIENT	(GLOBAL_DELIVER_UNIT +   \
				 GLOBAL_UNMATCHED_ERROR)

/* GLOBAL_DEFAULT is the set of flags for a root which even has to be
 * preserved in delivered images. It also matches the behaviour which
 * the runtime had before all these switches were introduced. */

#define GLOBAL_DEFAULT    	(GLOBAL_SAVE_RECORD +		\
				 GLOBAL_DELIVER_RECORD + 	\
				 GLOBAL_MISSING_ERROR + 	\
				 GLOBAL_UNMATCHED_ERROR)

/*
 * A function to declare as global results of setup functions
 * run within dlls. The sole purpose of this is to allow
 * images to be saved and restarted in the presence of
 * dll based code.
 */
extern void declare_global_result(mlval *result, mlval name);

/*  === PACK/UNPACK THE GLOBAL ROOTS ===
 *
 *  global_pack() packs the roots that have been declared as global together
 *  in a single ML value, together with their declared names.
 *  global_tidy() is called by during the image clean, after all dead
 *  values have been GCed away. Its purpose is to allow the shrinking
 *  of weak lists in the global package.
 *  global_unpack() takes a value previously returned by global_pack() and
 * assigns the global roots from the values it contains.  */

extern mlval global_pack(int deliver);
extern void global_tidy(mlval package);
extern void global_unpack(mlval package);

/*  === ROOT UTILITIES ===
 *
 *  One of the common uses for global roots is to keep track of values on
 *  the ML heap, but not to keep them alive by doing so.  These functions
 *  administer lists of such values.
 */


/*  == Make a new list ==
 *
 *  The granularity paramter determines the size of the tables on the list.
 *  It should be larger for lists which are expected to contain more values.
 *  A good value for a small list is 16.
 */

extern mlval weak_new(size_t granularity);


/*  == Add a value to a list ==
 *
 *  Returns the new list.  The list parameter may be updated and should not
 *  be used again.
 */

extern mlval weak_add(mlval list, mlval value);


/*  == Calculate length of list ==
 *
 *  Returns the number of elements in the list.
 */

extern size_t weak_length(mlval list);


/*  == Fix values on a list ==
 *
 *  Applies the function f to all values on a list, including an index.  The
 *  function should return a (possibly different) value to replace the value
 *  to which it is applied.  This returned value may be DEAD to expunge the
 *  value from the list.  Returns the new list.
 */

extern void weak_apply(mlval list, mlval (*f)(unsigned int index, mlval));

#endif
@


1.8.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a14 4
 * Revision 1.8  1998/07/07  16:28:54  jont
 * [Bug #30108]
 * Implement DLL based ML code
 *
@


1.7
log
@Change names of other _NIL flags for consistency.
@
text
@d15 3
d173 7
@


1.7.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a14 3
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.7.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a14 3
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.7.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a14 3
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.7.9.1
log
@branched from 1.7
@
text
@a14 3
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.7.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a14 3
 * Revision 1.7.9.1  1997/05/12  10:39:30  hope
 * branched from 1.7
 *
@


1.7.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a14 3
 * Revision 1.7.9.1  1997/05/12  10:39:30  hope
 * branched from 1.7
 *
@


1.7.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a14 3
 * Revision 1.7.9.1  1997/05/12  10:39:30  hope
 * branched from 1.7
 *
@


1.7.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a14 3
 * Revision 1.7.9.1.1.1  1997/07/28  18:27:22  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.7.8.1
log
@branched from 1.7
@
text
@a14 3
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.7.7.1
log
@branched from 1.7
@
text
@a14 3
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.7.7.1.1.1
log
@branched from 1.7.7.1
@
text
@a14 3
 * Revision 1.7.7.1  1996/12/17  17:52:32  hope
 * branched from 1.7
 *
@


1.7.6.1
log
@branched from 1.7
@
text
@a14 3
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.7.5.1
log
@branched from 1.7
@
text
@a14 3
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.7.4.1
log
@branched from 1.7
@
text
@a14 3
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.7.4.1.1.1
log
@branched from 1.7.4.1
@
text
@a14 3
 * Revision 1.7.4.1  1996/11/14  12:55:42  hope
 * branched from 1.7
 *
@


1.7.3.1
log
@branched from 1.7
@
text
@a14 3
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.7.2.1
log
@branched from 1.7
@
text
@a14 3
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.7.1.1
log
@branched from 1.7
@
text
@a14 3
 * Revision 1.7  1996/07/01  09:00:30  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.6
log
@Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
@
text
@d15 3
d97 1
a97 1
#define GLOBAL_SAVE_NIL		 0x2
d101 1
a101 1
#define GLOBAL_DELIVER_NIL	 0x20
d142 1
a142 1
 * have the GLOBAL_MISSING_NIL flag (if MLUNIT is a meaningful value
d147 1
a147 1
				 GLOBAL_DELIVER_NIL + \
d156 1
a156 1
 * GLOBAL_MISSING_NIL set (and reconstruct on first use) */
d158 1
a158 1
#define GLOBAL_TRANSIENT	(GLOBAL_DELIVER_NIL +   \
@


1.5
log
@Add weak_save.
@
text
@d15 3
d84 1
a84 1
 *            if either the WARN or NIL flag is set, the root is set to MLUNIT.
d103 1
a103 1
#define GLOBAL_MISSING_NIL	0x100
@


1.4
log
@Add some default flag values.
@
text
@d15 3
d109 6
d118 2
a119 1
				 GLOBAL_UNMATCHED_FLAGS)
d169 3
d176 1
a178 2


a222 1

@


1.3
log
@Add more sophistication to global roots.
@
text
@d15 3
d64 4
a67 3
 * otherwise, if the NIL flag is set, the root is set to MLUNIT.
 *                 This helps make deliver images smaller.
 *            if the RECORD flag is set, the root is recorded in the image.
d85 1
a85 2
 * if neither flag is set, a runtime error is caused.
 */
a105 5
#define GLOBAL_DEFAULT    	(GLOBAL_SAVE_RECORD +		\
				 GLOBAL_DELIVER_RECORD + 	\
				 GLOBAL_MISSING_ERROR + 	\
				 GLOBAL_UNMATCHED_ERROR)

d117 37
d160 1
a160 2
 *  assigns the global roots from the values it contains.
 */
@


1.2
log
@new file
@
text
@d15 3
d44 38
a81 11
 *  remembered for inclusion in the global root (see below).  It performs an
 *  implicit delcare_root().  The root must be given a unique name which is
 *  used by global_pack() and global_unpack() to save and restore the root
 *  in a value.  (The of the root is not used as its `name' to maintain
 *  compatability between runtime systems and images.)
 *
 *  A pointer to a function may also be passed.  If this is not NULL then
 *  rather than update the root, global_unpack() calls the function with the
 *  root and its new value.
 *
 *  The string passed must not be updated or deallocated.
d84 34
a117 1
extern void declare_global(const char *name, mlval *root, void (*f)(mlval *root, mlval value));
a125 3
 *
 *  global_unpack() returns zero iff the package passed does not match the
 *  current declared global roots.
d128 2
a129 2
extern mlval global_pack(void);
extern int global_unpack(mlval package);
@


1.2.1.1
log
@branched from 1.2
@
text
@a14 3
 * Revision 1.2  1994/06/09  14:36:39  nickh
 * new file
 *
@


1.1
log
@new file
@
text
@d14 4
a17 1
 *  $Log: global.h,v $
@
