head	1.12;
access;
symbols
	MLW_daveb_inline_1_4_99:1.12.13
	MLWorks_21c0_1999_03_25:1.12
	MLWorks_20c1_1998_08_20:1.12
	MLWorks_20c0_1998_08_04:1.12
	MLWorks_20b2c2_1998_06_19:1.12
	MLWorks_20b2_Windows_1998_06_12:1.12
	MLWorks_20b1c1_1998_05_07:1.12
	MLWorks_20b0_1998_04_07:1.12
	MLWorks_20b0_1998_03_20:1.12
	MLWorks_20m2_1998_02_16:1.12
	MLWorks_MM_adapt:1.12.12
	MLWorks_20m1_1997_10_23:1.12
	MLWorks_11r1:1.12.9.1.1.1.1
	MLWorks_workspace_97:1.12.11
	MLWorks_dt_wizard:1.12.10
	MLWorks_11c0_1997_09_09:1.12.9.1.1.1
	MLWorks_10r3:1.12.9.1.3
	MLWorks_10r2_551:1.12.9.1.2
	MLWorks_11:1.12.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.12.9.1
	MLWorks_20m0_1997_06_20:1.12
	MLWorks_1_0_r2c2_1997_06_14:1.12.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.12.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.12.9
	MLWorks_BugFix_1997_04_24:1.12
	MLWorks_1_0_r2_Win32_1997_04_11:1.12
	MLWorks_1_0_r2_Unix_1997_04_04:1.12
	MM_ML_release_korma_1997_04_01:1.12
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.12.7.1.1
	MLWorks_gui_1996_12_18:1.12.8
	MLWorks_1_0_Win32_1996_12_17:1.12.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.12.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.12.4.1
	JFHrts:1.12.6
	MLWorks_1_0_Irix_1996_11_28:1.12.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.12.5
	MLWorks_1_0_Unix_1996_11_14:1.12.4
	MLWorks_Open_Beta2_1996_10_11:1.12.3
	MLWorks_License_dev:1.12.2
	MLWorks_1_open_beta_1996_09_13:1.12.1
	MLWorks_Open_Beta_1996_08_22:1.12
	MLWorks_Beta_1996_07_02:1.12
	MLWorks_Beta_1996_06_07:1.12
	MLWorks_Beta_1996_06_06:1.12
	MLWorks_Beta_1996_06_05:1.12
	MLWorks_Beta_1996_06_03:1.12
	MLWorks_Beta_1996_05_31:1.12
	MLWorks_Beta_1996_05_30:1.12
	hope_poo:1.2.1
	ML_beta_release_12/08/94:1.2.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.12
date	96.04.30.12.49.07;	author matthew;	state Exp;
branches
	1.12.1.1
	1.12.2.1
	1.12.3.1
	1.12.4.1
	1.12.5.1
	1.12.6.1
	1.12.7.1
	1.12.8.1
	1.12.9.1
	1.12.10.1
	1.12.11.1
	1.12.12.1
	1.12.13.1;
next	1.11;

1.11
date	96.04.19.13.58.52;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	96.02.09.14.22.04;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	96.02.06.15.13.35;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	96.01.31.13.16.04;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	95.09.15.16.20.37;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	95.09.15.10.51.02;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	95.09.11.14.15.19;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	94.11.22.16.02.28;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	94.09.09.16.21.40;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.50.23;	author nickh;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	94.06.09.11.24.46;	author nickh;	state Exp;
branches;
next	;

1.2.1.1
date	95.07.05.10.28.49;	author hope;	state Exp;
branches;
next	;

1.12.1.1
date	96.09.13.11.23.03;	author hope;	state Exp;
branches;
next	;

1.12.2.1
date	96.10.07.16.13.12;	author hope;	state Exp;
branches;
next	;

1.12.3.1
date	96.10.17.11.32.29;	author hope;	state Exp;
branches;
next	;

1.12.4.1
date	96.11.14.12.58.24;	author hope;	state Exp;
branches
	1.12.4.1.1.1;
next	;

1.12.4.1.1.1
date	96.11.28.15.08.21;	author hope;	state Exp;
branches;
next	;

1.12.5.1
date	96.11.22.18.16.02;	author hope;	state Exp;
branches;
next	;

1.12.6.1
date	96.12.17.10.02.45;	author hope;	state Exp;
branches;
next	;

1.12.7.1
date	96.12.17.17.54.27;	author hope;	state Exp;
branches
	1.12.7.1.1.1;
next	;

1.12.7.1.1.1
date	97.02.24.11.45.32;	author hope;	state Exp;
branches;
next	;

1.12.8.1
date	96.12.18.09.49.02;	author hope;	state Exp;
branches;
next	;

1.12.9.1
date	97.05.12.10.41.27;	author hope;	state Exp;
branches
	1.12.9.1.1.1
	1.12.9.1.2.1
	1.12.9.1.3.1;
next	;

1.12.9.1.1.1
date	97.07.28.18.28.12;	author daveb;	state Exp;
branches
	1.12.9.1.1.1.1.1;
next	;

1.12.9.1.1.1.1.1
date	97.10.07.11.54.07;	author jkbrook;	state Exp;
branches;
next	;

1.12.9.1.2.1
date	97.09.08.17.21.11;	author daveb;	state Exp;
branches;
next	;

1.12.9.1.3.1
date	97.09.09.14.17.17;	author daveb;	state Exp;
branches;
next	;

1.12.10.1
date	97.09.10.19.36.01;	author brucem;	state Exp;
branches;
next	;

1.12.11.1
date	97.09.11.21.04.26;	author daveb;	state Exp;
branches;
next	;

1.12.12.1
date	97.10.31.13.47.30;	author nickb;	state Exp;
branches;
next	;

1.12.13.1
date	99.04.01.18.03.16;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.12
log
@Adding some useful functions
@
text
@/*  ==== PERVASIVE INTEGERS ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Revision Log
 *  ------------
 *  $Log: src:integers.c,v $
 * Revision 1.11  1996/04/19  13:58:52  matthew
 * Exception overflow
 *
 * Revision 1.10  1996/02/09  14:22:04  jont
 * Modify int32 divide to raise Overflow on max neg div ~1
 *
 * Revision 1.9  1996/02/06  15:13:35  jont
 * Alter int32_mod to raise Mod on mod by 0
 *
 * Revision 1.8  1996/01/31  13:16:04  jont
 * Add overflow detection to 32 bit integer operations
 *
 * Revision 1.7  1995/09/15  16:20:37  daveb
 * Corrected printing of negative 32-bit integers.
 *
 * Revision 1.6  1995/09/15  10:51:02  daveb
 * Added int32_to_string.
 *
 * Revision 1.5  1995/09/11  14:15:19  daveb
 * Updated for built-in int32 type.
 *
 * Revision 1.4  1994/11/22  16:02:28  matthew
 * Added possible assembler division function
 *
 * Revision 1.3  1994/09/09  16:21:40  nickb
 * Change integer multiply to a pure asm routine, with no C indirection.
 *
 * Revision 1.2  1994/06/09  14:50:23  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:24:46  nickh
 * new file
 *
 *  Revision 1.4  1994/01/28  17:39:20  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.3  1993/11/18  13:26:00  daveb
 *  Added handler for SIGEMT traps, which are raised when tagged integer
 *  operations overflow.
 *
 *  Revision 1.2  1993/02/01  16:04:45  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.1  1992/10/23  16:14:36  richard
 *  Initial revision
 *
 */

#include "integers.h"
#include "mltypes.h"
#include "values.h"
#include "exceptions.h"
#include "environment.h"
#include "syscalls.h"
#include "diagnostic.h"
#include "exceptions.h"
#include "interface.h"
#include "utils.h"
#include "mach.h"

#include "words.h"
#include "allocator.h"
#include "alloc.h"
#include "sys_types.h"

#ifndef MACH_INT_MUL

static mlval multiply (mlval argument)
{
  int arg1 = CINT(FIELD(argument, 0));
  int arg2 = CINT(FIELD(argument, 1));

  double prod = ((double) arg1) * ((double) arg2);
  if ((prod > (double) ML_MAX_INT))
    exn_raise(perv_exn_ref_overflow);
  else if (prod < (double) ML_MIN_INT)
    exn_raise(perv_exn_ref_overflow);
  else
    return MLINT((int)prod);
}

#endif

#ifndef MACH_INT_DIV

static mlval divide (mlval argument)
{
  int divisor = CINT(FIELD(argument, 0));
  int dividend = CINT(FIELD(argument, 1));
  int answer, remainder;

  if(dividend == 0)
    exn_raise(perv_exn_ref_div);

  if((dividend+1)==0 && divisor==0xE0000000)
    exn_raise(perv_exn_ref_overflow);

  answer = divisor/dividend;
  remainder = divisor - answer*dividend;
  if((remainder > 0 && dividend < 0) || (remainder < 0 && dividend > 0))
    answer -= 1; /* Shift into correct range */

  return(MLINT(answer));
}

static mlval modulo (mlval argument)
{
  int divisor = CINT(FIELD(argument, 0));
  int dividend = CINT(FIELD(argument, 1));
  int answer;

  if(dividend == 0)
    exn_raise(perv_exn_ref_div);

  answer = divisor%dividend;
  if ((answer > 0 && dividend < 0) || (answer < 0 && dividend > 0))
    answer += dividend; /* Shift into correct range */

  return(MLINT(answer));
}

#endif

static mlval int32_mul(mlval argument)
{
  int *val1 = CWORD32(FIELD(argument,0)),
      *val2 = CWORD32(FIELD(argument,1));
  mlval result;
  double prod = ((double) *val1) * ((double) *val2);
  if ((prod > (double) ML_MAX_INT32))
    exn_raise(perv_exn_ref_overflow);
  else if (prod < (double) ML_MIN_INT32)
    exn_raise(perv_exn_ref_overflow);

  result = allocate_word32();
  num_to_word32((word)prod,result);

  return(result);
}

static mlval int32_to_int (mlval arg)
{
  int n = *CWORD32(arg);
  if ((n > ML_MAX_INT) || (n < ML_MIN_INT))
    exn_raise (perv_exn_ref_overflow);
  return (MLINT (n));
}

static mlval int_to_int32 (mlval arg)
{
  int n = CINT (arg);
  mlval result = allocate_word32();
  num_to_word32 ((word)n,result);
  return (result);
}

static mlval int32_div(mlval argument)
{
  int answer,
      remainder,
      *divisor = CWORD32(FIELD(argument,0)),
      *dividend = CWORD32(FIELD(argument,1));
  mlval result;

  if (*dividend == 0u) exn_raise(perv_exn_ref_div);
  if((*dividend+1)==0 && *divisor==ML_MIN_INT32)
    exn_raise(perv_exn_ref_overflow);

  answer = (*divisor / *dividend);
  remainder = *divisor - answer * *dividend;
  if((remainder > 0 && *dividend < 0) || (remainder < 0 && *dividend > 0))
    answer -= 1; /* Shift into correct range */


  result = allocate_word32();
  num_to_word32((uint32)answer,result);

  return(result);
}

static mlval int32_mod(mlval argument)
{
  int answer,
     *divisor = CWORD32(FIELD(argument,0)),
     *dividend = CWORD32(FIELD(argument,1));
  mlval result;

  if (*dividend == 0u) exn_raise(perv_exn_ref_div);

  answer = (*divisor % *dividend);
  if ((answer > 0 && *dividend < 0) || (answer < 0 && *dividend > 0))
    answer += *dividend; /* Shift into correct range */

  result = allocate_word32();
  num_to_word32((uint32)answer,result);

  return(result);
}

void integers_init(void)
{
#ifdef MACH_INT_MUL
  env_asm_function("integer multiply", mach_int_mul);
#else
  env_function("integer multiply", multiply);
#endif

#ifdef MACH_INT_DIV
  env_asm_function ("integer divide",mach_int_div);
  env_asm_function ("integer modulo",mach_int_mod);
#else
  env_function("integer divide", divide);
  env_function("integer modulo", modulo);
#endif

  env_function("int32 multiply", int32_mul);
  env_function("int32 divide", int32_div);
  env_function("int32 modulo", int32_mod);

  env_function("int int_to_int32",int_to_int32);
  env_function("int int32_to_int",int32_to_int);
}

@


1.12.13.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.12.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.12.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.12.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.12.9.1
log
@branched from 1.12
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.12.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.12.9.1  1997/05/12  10:41:27  hope
 * branched from 1.12
 *
@


1.12.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.12.9.1  1997/05/12  10:41:27  hope
 * branched from 1.12
 *
@


1.12.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.12.9.1  1997/05/12  10:41:27  hope
 * branched from 1.12
 *
@


1.12.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.12.9.1.1.1  1997/07/28  18:28:12  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.12.8.1
log
@branched from 1.12
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.12.7.1
log
@branched from 1.12
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.12.7.1.1.1
log
@branched from 1.12.7.1
@
text
@a7 3
 * Revision 1.12.7.1  1996/12/17  17:54:27  hope
 * branched from 1.12
 *
@


1.12.6.1
log
@branched from 1.12
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.12.5.1
log
@branched from 1.12
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.12.4.1
log
@branched from 1.12
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.12.4.1.1.1
log
@branched from 1.12.4.1
@
text
@a7 3
 * Revision 1.12.4.1  1996/11/14  12:58:24  hope
 * branched from 1.12
 *
@


1.12.3.1
log
@branched from 1.12
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.12.2.1
log
@branched from 1.12
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.12.1.1
log
@branched from 1.12
@
text
@a7 3
 * Revision 1.12  1996/04/30  12:49:07  matthew
 * Adding some useful functions
 *
@


1.11
log
@Exception overflow
@
text
@d8 3
a130 22
static mlval int32_to_string(mlval argument)
{  
  word *item;
  char *str;
  mlval result;

  /* The minimum value of an Int32 is -2^31 = ~2147483648.  This is 11
     characters.  Add 1 for the trailing null. */
  str = (char *) malloc (12);

  item = CWORD32(argument);
  sprintf(str, "%ld", (long) *item);

  if (str[0] == '-')
    str[0] = '~';

  result = ml_string (str);
  free (str);

  return(result);
}

d148 16
a222 1
  env_function("int32 int to string", int32_to_string);
d226 3
@


1.10
log
@Modify int32 divide to raise Overflow on max neg div ~1
@
text
@d8 3
d79 1
a79 1
    exn_raise(perv_exn_ref_prod);
d81 1
a81 1
    exn_raise(perv_exn_ref_prod);
d100 1
a100 1
    exn_raise(perv_exn_ref_div);
d117 1
a117 1
    exn_raise(perv_exn_ref_mod);
d198 1
a198 1
  if (*dividend == 0u) exn_raise(perv_exn_ref_mod);
@


1.9
log
@Alter int32_mod to raise Mod on mod by 0
@
text
@d8 3
d154 1
a154 1
    exn_raise(perv_exn_ref_prod);
d156 1
a156 1
    exn_raise(perv_exn_ref_prod);
d174 1
a174 1
    exn_raise(perv_exn_ref_div);
@


1.8
log
@Add overflow detection to 32 bit integer operations
@
text
@d8 3
d192 1
a192 1
  if (*dividend == 0u) exn_raise(perv_exn_ref_div);
@


1.7
log
@Corrected printing of negative 32-bit integers.
@
text
@d8 3
d59 1
d121 3
a123 3
   word *item;
   char *str;
   mlval result;
d125 3
a127 3
   /* The minimum value of an Int32 is -2^31 = ~2147483648.  This is 11
      characters.  Add 1 for the trailing null. */
   str = (char *) malloc (12);
d129 2
a130 2
   item = CWORD32(argument);
   sprintf(str, "%ld", (long) *item);
d132 2
a133 2
   if (str[0] == '-')
     str[0] = '~';
d135 2
a136 2
   result = ml_string (str);
   free (str);
d138 1
a138 1
   return(result);
d142 9
a150 7
{  word val, *val1, *val2;
   mlval result;

   val1 = CWORD32(FIELD(argument,0));
   val2 = CWORD32(FIELD(argument,1));

   val = (*val1 * *val2);
d152 2
a153 2
   result = allocate_word32();
   num_to_word32(val,result);
d155 1
a155 1
   return(result);
d159 6
a164 2
{  word val, *val1, *val2;
   mlval result;
d166 3
a168 2
   val1 = CWORD32(FIELD(argument,0));
   val2 = CWORD32(FIELD(argument,1));
d170 4
a173 1
   if (*val2 == 0u) exn_raise(perv_exn_ref_div);
a174 1
   val = (*val1 / *val2);
d176 2
a177 2
   result = allocate_word32();
   num_to_word32(val,result);
d179 1
a179 1
   return(result);
d183 5
a187 5
{  word val, *val1, *val2;
   mlval result;

   val1 = CWORD32(FIELD(argument,0));
   val2 = CWORD32(FIELD(argument,1));
d189 1
a189 1
   if (*val2 == 0u) exn_raise(perv_exn_ref_div);
d191 3
a193 1
   val = (*val1 % *val2);
d195 2
a196 2
   result = allocate_word32();
   num_to_word32(val,result);
d198 1
a198 1
   return(result);
@


1.6
log
@Added int32_to_string.
@
text
@d8 3
d127 3
@


1.5
log
@Updated for built-in int32 type.
@
text
@d8 3
d52 1
d112 19
d196 1
@


1.4
log
@Added possible assembler division function
@
text
@d8 3
d47 3
d108 49
d173 3
d177 1
@


1.3
log
@Change integer multiply to a pure asm routine, with no C indirection.
@
text
@d8 3
d62 2
d100 1
d110 4
d116 2
@


1.2
log
@new file
@
text
@d8 3
a38 8

extern mlval multiply_overflow_fn(int arg1, int arg2, int lo, int hi)
{
  exn_raise(perv_exn_ref_prod);
}

#ifdef MACH_INT_MUL

d41 1
a41 8
static mlval multiply (mlval argument)
{
  int multiplier = FIELD(argument, 0);
  int multiplicand = CINT(FIELD(argument, 1));
  int product = mach_ovfl_mul(multiplier, multiplicand);

  return(product);
}
a42 2
#else /* MACH_INT_MUL */

d49 5
a53 9
  if ((prod > (double) ML_MAX_INT)) {
    int hi = prod / ((double)(1<<ML_INT_BITS));
    int lo = prod - ((double)(1<<ML_INT_BITS) * (double)hi);
    return multiply_overflow_fn (arg1,arg2,hi,lo);
  } else if (prod < (double) ML_MIN_INT) {
    int hi = (int)(prod / ((double)(1<<ML_INT_BITS))) + 1;
    int lo = prod - ((double)(1<<ML_INT_BITS) * (double)hi);
    return multiply_overflow_fn (arg1,arg2,hi,lo);
  } else
d57 1
a57 1
#endif /* MACH_INT_MUL */
d98 3
d102 2
@


1.2.1.1
log
@branched from 1.2
@
text
@a7 3
 * Revision 1.2  1994/06/09  14:50:23  nickh
 * new file
 *
@


1.1
log
@new file
@
text
@d7 4
a10 1
 *  $Log: integers.c,v $
@
