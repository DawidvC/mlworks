head	1.16;
access;
symbols
	MLW_daveb_inline_1_4_99:1.16.4
	MLWorks_21c0_1999_03_25:1.16
	MLWorks_20c1_1998_08_20:1.16
	MLWorks_20c0_1998_08_04:1.16
	MLWorks_20b2c2_1998_06_19:1.16
	MLWorks_20b2_Windows_1998_06_12:1.16
	MLWorks_20b1c1_1998_05_07:1.16
	MLWorks_20b0_1998_04_07:1.16
	MLWorks_20b0_1998_03_20:1.16
	MLWorks_20m2_1998_02_16:1.16
	MLWorks_MM_adapt:1.16.3
	MLWorks_20m1_1997_10_23:1.16
	MLWorks_11r1:1.15.9.1.1.1.1
	MLWorks_workspace_97:1.16.2
	MLWorks_dt_wizard:1.16.1
	MLWorks_11c0_1997_09_09:1.15.9.1.1.1
	MLWorks_10r3:1.15.9.1.3
	MLWorks_10r2_551:1.15.9.1.2
	MLWorks_11:1.15.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.15.9.1
	MLWorks_20m0_1997_06_20:1.16
	MLWorks_1_0_r2c2_1997_06_14:1.15.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.15.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.15.9
	MLWorks_BugFix_1997_04_24:1.16
	MLWorks_1_0_r2_Win32_1997_04_11:1.15
	MLWorks_1_0_r2_Unix_1997_04_04:1.15
	MM_ML_release_korma_1997_04_01:1.15
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.15.7.1.1
	MLWorks_gui_1996_12_18:1.15.8
	MLWorks_1_0_Win32_1996_12_17:1.15.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.15.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.15.4.1
	JFHrts:1.15.6
	MLWorks_1_0_Irix_1996_11_28:1.15.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.15.5
	MLWorks_1_0_Unix_1996_11_14:1.15.4
	MLWorks_Open_Beta2_1996_10_11:1.15.3
	MLWorks_License_dev:1.15.2
	MLWorks_1_open_beta_1996_09_13:1.15.1
	MLWorks_Open_Beta_1996_08_22:1.15
	MLWorks_Beta_1996_07_02:1.15
	MLWorks_Beta_1996_06_07:1.15
	MLWorks_Beta_1996_06_06:1.15
	MLWorks_Beta_1996_06_05:1.15
	MLWorks_Beta_1996_06_03:1.15
	MLWorks_Beta_1996_05_31:1.15
	MLWorks_Beta_1996_05_30:1.15;
locks; strict;
comment	@ * @;


1.16
date	97.04.10.13.56.03;	author andreww;	state Exp;
branches
	1.16.1.1
	1.16.2.1
	1.16.3.1
	1.16.4.1;
next	1.15;

1.15
date	96.05.16.15.42.31;	author brianm;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1
	1.15.4.1
	1.15.5.1
	1.15.6.1
	1.15.7.1
	1.15.8.1
	1.15.9.1;
next	1.14;

1.14
date	96.05.16.14.37.10;	author brianm;	state Exp;
branches;
next	1.13;

1.13
date	96.05.13.13.03.37;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	96.05.07.13.01.31;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	95.09.15.10.49.22;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	95.09.13.16.13.27;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	95.09.11.15.09.26;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	95.09.09.13.14.58;	author brianm;	state Exp;
branches;
next	1.7;

1.7
date	95.09.07.12.13.54;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	95.07.27.13.16.52;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	95.07.24.10.07.28;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	95.07.20.16.49.19;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	95.04.03.12.31.01;	author brianm;	state Exp;
branches;
next	1.2;

1.2
date	95.03.22.16.55.29;	author brianm;	state Exp;
branches;
next	1.1;

1.1
date	95.03.16.18.35.41;	author brianm;	state Exp;
branches;
next	;

1.15.1.1
date	96.09.13.11.24.03;	author hope;	state Exp;
branches;
next	;

1.15.2.1
date	96.10.07.16.14.20;	author hope;	state Exp;
branches;
next	;

1.15.3.1
date	96.10.17.11.33.46;	author hope;	state Exp;
branches;
next	;

1.15.4.1
date	96.11.14.12.59.26;	author hope;	state Exp;
branches
	1.15.4.1.1.1;
next	;

1.15.4.1.1.1
date	96.11.28.15.09.26;	author hope;	state Exp;
branches;
next	;

1.15.5.1
date	96.11.22.18.17.09;	author hope;	state Exp;
branches;
next	;

1.15.6.1
date	96.12.17.10.03.54;	author hope;	state Exp;
branches;
next	;

1.15.7.1
date	96.12.17.17.55.30;	author hope;	state Exp;
branches
	1.15.7.1.1.1;
next	;

1.15.7.1.1.1
date	97.02.24.11.46.50;	author hope;	state Exp;
branches;
next	;

1.15.8.1
date	96.12.18.09.50.05;	author hope;	state Exp;
branches;
next	;

1.15.9.1
date	97.05.12.10.43.47;	author hope;	state Exp;
branches
	1.15.9.1.1.1
	1.15.9.1.2.1
	1.15.9.1.3.1;
next	;

1.15.9.1.1.1
date	97.07.28.18.28.45;	author daveb;	state Exp;
branches
	1.15.9.1.1.1.1.1;
next	;

1.15.9.1.1.1.1.1
date	97.10.07.11.54.36;	author jkbrook;	state Exp;
branches;
next	;

1.15.9.1.2.1
date	97.09.08.17.21.41;	author daveb;	state Exp;
branches;
next	;

1.15.9.1.3.1
date	97.09.09.14.17.46;	author daveb;	state Exp;
branches;
next	;

1.16.1.1
date	97.09.10.19.36.55;	author brucem;	state Exp;
branches;
next	;

1.16.2.1
date	97.09.11.21.05.02;	author daveb;	state Exp;
branches;
next	;

1.16.3.1
date	97.10.31.13.48.05;	author nickb;	state Exp;
branches;
next	;

1.16.4.1
date	99.04.01.18.03.52;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New file.
@


1.16
log
@[Bug #2043]
adding comment to check_int30 routine.
@
text
@/*  ==== C WORD OPERATORS ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  Word values are unsigned natural numbers of some determined fixed size
 *  (in bits).
 *  
 *  This file contains multiplication, division and modulus operations on
 *  words of 30 and 32 bits, and conversion operations on 32-bit words.
 *  
 *  30-bit words are stored in integer values.  32-bit words are stored
 *  in string values (they are represented in 2's complement, not characters!).
 *  
 *  Revision Log
 *  ------------
 *  $Log: src:words.c,v $
 * Revision 1.15  1996/05/16  15:42:31  brianm
 * Returning check_int30 to previous state ...
 *
 * Revision 1.14  1996/05/16  14:37:10  brianm
 * Minor modification to check_int30 - correction for negative nums.
 *
 * Revision 1.13  1996/05/13  13:03:37  matthew
 * Adding real to word conversions
 *
 * Revision 1.12  1996/05/07  13:01:31  matthew
 * Updating for revised basis
 *
 * Revision 1.11  1995/09/15  10:49:22  daveb
 * I forgot to allow for the leading "0w" when calculating the maximum string
 * size in word32_to_string.
 *
 * Revision 1.10  1995/09/13  16:13:27  daveb
 * Fixing typo.
 *
 * Revision 1.8  1995/09/09  13:14:58  brianm
 * Added new functions for conversion between word32 and bytearrays.
 *
 * Revision 1.7  1995/09/07  12:13:54  jont
 * Modify word mod and div to return Div for division by zero rather
 * than Overflow
 *
 * Revision 1.6  1995/07/27  13:16:52  jont
 * Fixes to default word operations to treat arguments as unsigned
 *
 * Revision 1.5  1995/07/24  10:07:28  daveb
 * Fixed warning messages.
 *
 * Revision 1.4  1995/07/20  16:49:19  jont
 * Add default sized word functions for /, div and mod
 *
 * Revision 1.3  1995/04/03  12:31:01  brianm
 * Adding num_to_word32() word32_to_num().
 * Updating to use allocate_word32() and CWORD32().
 * Made code more GC-safe by moving allocation to end of functions.
 *
 * Revision 1.2  1995/03/22  16:55:29  brianm
 * Changing Word32 repn. to immutable byte vectors (i.e. strings).
 *
 * Revision 1.1  1995/03/16  18:35:41  brianm
 * new unit
 * New file.
 *
 * */

#include "mltypes.h"
#include "alloc.h"
#include "allocator.h"
#include "values.h"
#include "diagnostic.h"
#include "environment.h"
#include "exceptions.h"
#include "words.h"


/* Local defines */

#define bit(a)                (1u << (a))
#define bitblk(hi,lo)         (bit(hi) | (bit(hi) - bit(lo)))
#define appmask(x,m)          ((x) & (m))

#define raise_overflow   \
	exn_raise(perv_exn_ref_overflow)

static unsigned check_int30(unsigned argument)
{
   /* the following test makes sure that the top three bits of the
    * word are 0.  The top two take account of the bits required
    * for tagging. Bit 29 is the sign bit. We want this value to
    * be 0 too because we're not converting two's-bit negative numbers
    * into negative integers: just bit patterns into an integer.   Hence
    * overflow if bit 29 is set.  Note that since the argument
    * is unsigned it doesn't make sense to do a simple comparison
    * with ML_MAX_INT and ML_MIN_INT.
    */
   if (appmask(argument,bitblk(31,29)) != 0)  raise_overflow;
   return(argument);
}


/* External Functions */

extern void num_to_word32(unsigned num, mlval word32)
{
   unsigned *object;

   object = (unsigned *)CWORD32(word32);
   *object = num;
}

extern unsigned word32_to_num(mlval word32)
{
   unsigned *object;

   object = (unsigned *)CWORD32(word32);
   return(*object);
}


/* Functions exported to ML */

static mlval word32_to_int(mlval argument)
{  
   unsigned item;
   mlval result;

   item = word32_to_num(argument);
   result = MLINT(check_int30(item)); 
   return(result);
}

static mlval word32_to_word(mlval argument)
{  
   unsigned item;
   mlval result;

   item = word32_to_num(argument);
   result = MLINT(item); 
   return(result);
}

static mlval extend_int_to_word32(mlval argument)
{
   unsigned item;

   mlval result;

   item = (unsigned)CINT(argument);

   result = allocate_word32();
   num_to_word32(item,result);

   return(result);
}

static mlval int_to_word32(mlval argument)
{
   unsigned item;

   mlval result;

   item = (unsigned)CWORD(argument);

   result = allocate_word32();
   num_to_word32(item,result);

   return(result);
}

static mlval word32_to_bytearray(mlval argument)
{  
   unsigned item, *content;
   mlval result;

   item   = word32_to_num(argument);

   result = allocate_bytearray(4);

   content  = (unsigned *)CBYTEARRAY(result);
   *content = item;

   return(result);
}

static mlval bytearray_to_word32(mlval argument)
{  unsigned item, *content;

   mlval result;

   content = (unsigned *)CBYTEARRAY(argument);
   item = *content;

   result = allocate_word32();
   num_to_word32(item,result);

   return(result);
}

static mlval word32_to_string(mlval argument)
{  
   word *item;
   char *str;
   mlval result;

   /* The maximum value of a Word32 is 2^32-1 = 4294967295.  This is 10
      characters.  Add 1 for the trailing null, and 2 for the leading 0w. */
   str = (char *) malloc (13);

   item = CWORD32(argument);
   sprintf(str, "0w%lu", (unsigned long) *item);

   result = ml_string (str);
   free (str);

   return(result);
}

static mlval word32_times(mlval argument)
{  unsigned val, *val1, *val2;
   mlval result;

   val1 = (unsigned *)CWORD32(FIELD(argument,0));
   val2 = (unsigned *)CWORD32(FIELD(argument,1));

   val = (*val1 * *val2);

   result = allocate_word32();
   num_to_word32(val,result);

   return(result);
}

static mlval word32_div(mlval argument)
{  unsigned val, *val1, *val2;
   mlval result;

   val1 = (unsigned *)CWORD32(FIELD(argument,0));
   val2 = (unsigned *)CWORD32(FIELD(argument,1));

   if (*val2 == 0u) exn_raise(perv_exn_ref_div);

   val = (*val1 / *val2);

   result = allocate_word32();
   num_to_word32(val,result);

   return(result);
}


static mlval word32_mod(mlval argument)
{  unsigned val, *val1, *val2;
   mlval result;

   val1 = (unsigned *)CWORD32(FIELD(argument,0));
   val2 = (unsigned *)CWORD32(FIELD(argument,1));

   if (*val2 == 0u) exn_raise(perv_exn_ref_div);

   val = (*val1 % *val2);

   result = allocate_word32();
   num_to_word32(val,result);

   return(result);
}


static mlval word_times(mlval argument)
{
  unsigned val1 = CWORD(FIELD(argument, 0));
  unsigned val2 = CWORD(FIELD(argument, 1));
  return MLINT(val1 * val2);
}

static mlval word_div(mlval argument)
{
  unsigned val1 = CWORD(FIELD(argument, 0));
  unsigned val2 = CWORD(FIELD(argument, 1));
  if (val2 == 0u) exn_raise(perv_exn_ref_div);
  return MLINT(val1 / val2);
}

static mlval word_mod(mlval argument)
{
  unsigned val1 = CWORD(FIELD(argument, 0));
  unsigned val2 = CWORD(FIELD(argument, 1));
  if (val2 == 0u) exn_raise(perv_exn_ref_div);
  return MLINT(val1 % val2);
}

/* Convert between reals and words */

static mlval word_to_real (mlval argument)
{
  double x = (double)(CWORD (argument));
  mlval result = allocate_real ();
  SETREAL (result,x);
  return (result);
}

static mlval word32_to_real (mlval argument)
{
  double x = (double)*CWORD32 (argument);
  mlval result = allocate_real ();
  SETREAL (result,x);
  return (result);
}

/* These only need to work for whole reals */
static mlval real_to_word (mlval argument)
{
  unsigned n = (unsigned)GETREAL (argument);
  return MLINT (n);
}

static mlval real_to_word32 (mlval argument)
{
  unsigned int n = (unsigned int)GETREAL (argument);
  mlval result = allocate_word32();

  num_to_word32(n,result);

  return (result);
}

extern void words_init(void)
{
  env_function("word32 word to int",  word32_to_int);
  env_function("word32 extend int to word32",  extend_int_to_word32);
  env_function("word32 int to word32",  int_to_word32);
  env_function("word32 word32 to word",  word32_to_word);
  env_function("word32 word to string",	 word32_to_string);

  env_function("word word to real",	 word_to_real);
  env_function("word word32 to real",	 word32_to_real);

  env_function("word real to word",	 real_to_word);
  env_function("word real to word32",	 real_to_word32);

  env_function("word32 word to bytearray",  word32_to_bytearray);
  env_function("word32 bytearray to word",  bytearray_to_word32);

  env_function("word32 div",    word32_div);
  env_function("word32 mod",    word32_mod);
  env_function("word32 times",  word32_times);

  env_function("word multiply", word_times);
  env_function("word divide",   word_div);
  env_function("word modulus",  word_mod);
}
@


1.16.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a18 4
 * Revision 1.16  1997/04/10  13:56:03  andreww
 * [Bug #2043]
 * adding comment to check_int30 routine.
 *
@


1.16.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a18 4
 * Revision 1.16  1997/04/10  13:56:03  andreww
 * [Bug #2043]
 * adding comment to check_int30 routine.
 *
@


1.16.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a18 4
 * Revision 1.16  1997/04/10  13:56:03  andreww
 * [Bug #2043]
 * adding comment to check_int30 routine.
 *
@


1.16.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a18 4
 * Revision 1.16  1997/04/10  13:56:03  andreww
 * [Bug #2043]
 * adding comment to check_int30 routine.
 *
@


1.15
log
@Returning check_int30 to previous state ...
@
text
@d19 3
d89 9
@


1.15.9.1
log
@branched from 1.15
@
text
@a18 3
 * Revision 1.15  1996/05/16  15:42:31  brianm
 * Returning check_int30 to previous state ...
 *
@


1.15.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a18 3
 * Revision 1.15.9.1  1997/05/12  10:43:47  hope
 * branched from 1.15
 *
@


1.15.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a18 3
 * Revision 1.15.9.1  1997/05/12  10:43:47  hope
 * branched from 1.15
 *
@


1.15.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a18 3
 * Revision 1.15.9.1  1997/05/12  10:43:47  hope
 * branched from 1.15
 *
@


1.15.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a18 3
 * Revision 1.15.9.1.1.1  1997/07/28  18:28:45  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.15.8.1
log
@branched from 1.15
@
text
@a18 3
 * Revision 1.15  1996/05/16  15:42:31  brianm
 * Returning check_int30 to previous state ...
 *
@


1.15.7.1
log
@branched from 1.15
@
text
@a18 3
 * Revision 1.15  1996/05/16  15:42:31  brianm
 * Returning check_int30 to previous state ...
 *
@


1.15.7.1.1.1
log
@branched from 1.15.7.1
@
text
@a18 3
 * Revision 1.15.7.1  1996/12/17  17:55:30  hope
 * branched from 1.15
 *
@


1.15.6.1
log
@branched from 1.15
@
text
@a18 3
 * Revision 1.15  1996/05/16  15:42:31  brianm
 * Returning check_int30 to previous state ...
 *
@


1.15.5.1
log
@branched from 1.15
@
text
@a18 3
 * Revision 1.15  1996/05/16  15:42:31  brianm
 * Returning check_int30 to previous state ...
 *
@


1.15.4.1
log
@branched from 1.15
@
text
@a18 3
 * Revision 1.15  1996/05/16  15:42:31  brianm
 * Returning check_int30 to previous state ...
 *
@


1.15.4.1.1.1
log
@branched from 1.15.4.1
@
text
@a18 3
 * Revision 1.15.4.1  1996/11/14  12:59:26  hope
 * branched from 1.15
 *
@


1.15.3.1
log
@branched from 1.15
@
text
@a18 3
 * Revision 1.15  1996/05/16  15:42:31  brianm
 * Returning check_int30 to previous state ...
 *
@


1.15.2.1
log
@branched from 1.15
@
text
@a18 3
 * Revision 1.15  1996/05/16  15:42:31  brianm
 * Returning check_int30 to previous state ...
 *
@


1.15.1.1
log
@branched from 1.15
@
text
@a18 3
 * Revision 1.15  1996/05/16  15:42:31  brianm
 * Returning check_int30 to previous state ...
 *
@


1.14
log
@Minor modification to check_int30 - correction for negative nums.
@
text
@d19 3
d77 6
a82 1
#define raise_overflow        exn_raise(perv_exn_ref_overflow)
d86 2
a87 7
   unsigned i = (argument >> 29) & 0x7;

   switch (i) {
     case 0   :                      /* all 30 bit positive number */
     case 7   :  return(argument);   /* all 30 bit negative number */
     default  :  raise_overflow;
   }
@


1.13
log
@Adding real to word conversions
@
text
@d19 3
d74 1
a74 6
#define bit(a)                (1u << (a))
#define bitblk(hi,lo)         (bit(hi) | (bit(hi) - bit(lo)))
#define appmask(x,m)          ((x) & (m))

#define raise_overflow   \
	exn_raise(perv_exn_ref_overflow)
d78 7
a84 2
   if (appmask(argument,bitblk(31,29)) != 0)  raise_overflow;
   return(argument);
@


1.12
log
@Updating for revised basis
@
text
@d19 3
d126 3
a128 2
static mlval int_to_word32(mlval argument)
{  unsigned item;
d132 1
a132 1
   item = (unsigned)CWORD(argument);
d140 3
a142 2
static mlval word_to_word32(mlval argument)
{  unsigned item;
d276 35
d314 2
a315 2
  env_function("word32 int to word",  int_to_word32);
  env_function("word32 word to word32",  word_to_word32);
d318 6
@


1.11
log
@I forgot to allow for the leading "0w" when calculating the maximum string
size in word32_to_string.
@
text
@d19 4
d106 1
d108 8
d119 3
d123 9
a131 1
   result = MLINT(check_int30(item)); 
d136 1
a136 1
static mlval int_to_word32(mlval argument)
d141 1
a141 1
   item = (unsigned)CINT(argument);
d275 2
@


1.10
log
@Fixing typo.
@
text
@d19 3
d161 2
a162 2
      characters.  Add 1 for the trailing null. */
   str = (char *) malloc (11);
@


1.9
log
@Updated for built-in word32 type.
@
text
@d255 1
a255 1
  env_function("word32 times",  word32_mod);
@


1.8
log
@Added new functions for conversion between word32 and bytearrays.
@
text
@d8 1
a8 2
 *  (in bits).  Our implementation will only consider byte-multiple sizes
 *  for the time being.
d10 2
a11 10
 *  Words with sizes of 4 bytes or more are represented as string
 *  values (i.e. immutable byte vector values).  Words whose size
 *  (i.e. 8, 16, 24) can fit into a standard MLWorks integer (i.e. 30
 *  bits) can be given an arithmetic implementation purely within
 *  MLWorks (using in part the Bits operations on integers that
 *  MLWorks provides).
 *  
 *  The operations given here are for the Word32 case - the others can be
 *  provided by arithmetic means.  In time, all of these implementations
 *  may/should be superceded by direct in-lined implementations.
d13 2
d19 3
d50 1
a63 11
#define setmask(x,m)          ((x) | (m))
#define xormask(x,m)          ((x) ^ (m))
#define rshift(x,lo)          ((unsigned)(x) >> (lo))
#define getbitblk(u,hi,lo)    (appmask(rshift((u),(lo)),bitblk(1+(hi) - (lo),0)))
#define set1bitblk(u,hi,lo)   (setmask((u),bitblk((hi),(lo))))
#define set0bitblk(u,hi,lo)   (appmask((u),~(bitblk((hi),(lo)))))
#define setbitblk(u,hi,lo,v)  (setmask(set0bitblk((u),(hi),(lo)), \
                                       getbitblk((v),1 + (hi) - (lo),0) << (lo)))
#define invbitblk(u,hi,lo)    (xormask((u),bitblk((hi),(lo))))
#define signextend(u,a)       ((appmask(u,bit(a))) ? (setmask((u),(0 - bit(a)))) : u)

d66 1
a66 3
        exn_raise_string(perv_exn_ref_value, "words: unsigned overflow")

#define raise_New_Overflow exn_raise(perv_exn_ref_overflow)
d96 1
a96 1
static mlval word_to_int(mlval argument)
d109 1
a109 1
static mlval word_int_to_word(mlval argument)
d122 1
a122 1
static mlval word_to_bytearray(mlval argument)
d137 1
a137 1
static mlval word_bytearray_to_word(mlval argument)
d151 1
a151 17

static mlval word_orbyte(mlval argument)
{  unsigned val, *val1, *val2;
   mlval result;

   val1 = (unsigned *)CWORD32(FIELD(argument,0));
   val2 = (unsigned *)CWORD32(FIELD(argument,1));

   val = (*val1 | *val2);

   result = allocate_word32();
   num_to_word32(val,result);

   return(result);
}

static mlval word_xorbyte(mlval argument)
d153 2
a154 2
   unsigned val, *val1, *val2;

d157 3
a159 2
   val1 = (unsigned *)CWORD32(FIELD(argument,0));
   val2 = (unsigned *)CWORD32(FIELD(argument,1));
d161 2
a162 1
   val = (*val1 ^ *val2);
d164 2
a165 2
   result = allocate_word32();
   num_to_word32(val,result);
d170 1
a170 107
static mlval word_andbyte(mlval argument)
{  unsigned val, *val1, *val2;
   mlval result;

   val1 = (unsigned *)CWORD32(FIELD(argument,0));
   val2 = (unsigned *)CWORD32(FIELD(argument,1));

   val = (*val1 & *val2);

   result = allocate_word32();
   num_to_word32(val,result);

   return(result);
}


static mlval word_notbyte(mlval argument)
{  unsigned *item, val;
   mlval result;

   item = (unsigned *)CWORD32(argument);

   val = (unsigned)~*item;

   result = allocate_word32();
   num_to_word32(val,result);

   return(result);
}


static mlval word_shift(mlval argument)
{  int shift;
   unsigned val, *item;
   mlval result;

   item = (unsigned *)CWORD32(FIELD(argument,0));
   shift = (int)CINT(FIELD(argument,1));

   if (!(-31 <= shift && shift <= 31))
     raise_overflow;

   if (shift > 0)
	{ val = (unsigned)(*item << shift); }
   else { val = (unsigned)(*item >> -shift); };

   result = allocate_word32();
   num_to_word32(val,result);

   return(result);
}

static mlval word_arith_shift(mlval argument)
{  int shift;
   unsigned val, *item;
   mlval result;

   item = (unsigned *)CWORD32(FIELD(argument,0));
   shift = (int)CINT(FIELD(argument,1));

   if (!(-31 <= shift && shift <= 31))
     raise_overflow;

   if (shift > 0)
	{ val = (unsigned)(*item << shift); }
   else { val = (unsigned)(*item >> -shift);
          val = signextend(val,31 + shift);
        };

   result = allocate_word32();
   num_to_word32(val,result);

   return(result);
}

static mlval word_plus(mlval argument)
{  unsigned val, *val1, *val2;
   mlval result;

   val1 = (unsigned *)CWORD32(FIELD(argument,0));
   val2 = (unsigned *)CWORD32(FIELD(argument,1));

   val = (*val1 + *val2);

   result = allocate_word32();
   num_to_word32(val,result);

   return(result);
}


static mlval word_minus(mlval argument)
{  unsigned val, *val1, *val2;
   mlval result;

   val1 = (unsigned *)CWORD32(FIELD(argument,0));
   val2 = (unsigned *)CWORD32(FIELD(argument,1));

   val = (*val1 - *val2);

   result = allocate_word32();
   num_to_word32(val,result);

   return(result);
}

static mlval word_times(mlval argument)
d185 1
a185 1
static mlval word_div(mlval argument)
d203 1
a203 1
static mlval word_mod(mlval argument)
d221 1
a221 41
static mlval word_less_than(mlval argument)
{  unsigned *val1, *val2;

   val1 = (unsigned *)CWORD32(FIELD(argument,0));
   val2 = (unsigned *)CWORD32(FIELD(argument,1));

   if (*val1 < *val2) { return(MLTRUE); }
   else return(MLFALSE); 
}

static mlval word_less_than_or_equal(mlval argument)
{  unsigned *val1, *val2;

   val1 = (unsigned *)CWORD32(FIELD(argument,0));
   val2 = (unsigned *)CWORD32(FIELD(argument,1));

   if (*val1 <= *val2) { return(MLTRUE); }
   else return(MLFALSE); 
}

static mlval word_greater_than(mlval argument)
{  unsigned *val1, *val2;

   val1 = (unsigned *)CWORD32(FIELD(argument,0));
   val2 = (unsigned *)CWORD32(FIELD(argument,1));

   if (*val1 > *val2) { return(MLTRUE); }
   else return(MLFALSE); 
}

static mlval word_greater_than_or_equal(mlval argument)
{  unsigned *val1, *val2;

   val1 = (unsigned *)CWORD32(FIELD(argument,0));
   val2 = (unsigned *)CWORD32(FIELD(argument,1));

   if (*val1 >= *val2) { return(MLTRUE); }
   else return(MLFALSE); 
}

static mlval def_word_times(mlval argument)
d228 1
a228 1
static mlval def_word_div(mlval argument)
d236 1
a236 1
static mlval def_word_mod(mlval argument)
d246 14
a259 28
  env_function("word32 to int",       word_to_int);
  env_function("word32 int to word",  word_int_to_word);

  env_function("word32 to bytearray",       word_to_bytearray);
  env_function("word32 bytearray to word",  word_bytearray_to_word);

  env_function("word32 or byte",   word_orbyte);
  env_function("word32 xor byte",  word_xorbyte);
  env_function("word32 and byte",  word_andbyte);
  env_function("word32 not byte",  word_notbyte);

  env_function("word32 shift",        word_shift);
  env_function("word32 arith shift",  word_arith_shift);

  env_function("word32 plus",   word_plus);
  env_function("word32 minus",  word_minus);
  env_function("word32 times",  word_times);
  env_function("word32 div",    word_div);
  env_function("word32 mod",    word_mod);

  env_function("word32 less than",              word_less_than);
  env_function("word32 less than or equal",     word_less_than_or_equal);
  env_function("word32 greater than",           word_greater_than);
  env_function("word32 greater than or equal",  word_greater_than_or_equal);

  env_function("word multiply", def_word_times);
  env_function("word divide", def_word_div);
  env_function("word modulus", def_word_mod);
@


1.7
log
@Modify word mod and div to return Div for division by zero rather
than Overflow
@
text
@d26 4
d138 30
d424 3
@


1.6
log
@Fixes to default word operations to treat arguments as unsigned
@
text
@d26 3
d294 1
a294 1
   if (*val2 == 0u) raise_overflow;
d312 1
a312 1
   if (*val2 == 0u) raise_overflow;
a366 3
/*
  fprintf(stderr, "def_word_times val1 = %u, 0x%x, val2 = %u, ox%x, returning %u\n", val1, val1, val2, val2, val1 * val2);
*/
d374 1
a374 4
  if (val2 == 0) raise_New_Overflow;
/*
  fprintf(stderr, "def_word_div val1 = %u, 0x%x, val2 = %u, ox%x, returning %u\n", val1, val1, val2, val2, val1 / val2);
*/
d382 1
a382 4
  if (val2 == 0) raise_New_Overflow;
/*
  fprintf(stderr, "def_word_mod val1 = %u, 0x%x, val2 = %u, ox%x, returning %u\n", val1, val1, val2, val2, val1 % val2);
*/
@


1.5
log
@Fixed warning messages.
@
text
@d26 3
d362 5
a366 2
  unsigned val1 = (unsigned)CINT(FIELD(argument, 0));
  unsigned val2 = (unsigned)CINT(FIELD(argument, 1));
d372 2
a373 2
  unsigned val1 = (unsigned)CINT(FIELD(argument, 0));
  unsigned val2 = (unsigned)CINT(FIELD(argument, 1));
d375 3
d383 2
a384 2
  unsigned val1 = (unsigned)CINT(FIELD(argument, 0));
  unsigned val2 = (unsigned)CINT(FIELD(argument, 1));
d386 3
@


1.4
log
@Add default sized word functions for /, div and mod
@
text
@d26 3
d357 1
a357 1
static def_word_times(mlval argument)
d364 1
a364 1
static def_word_div(mlval argument)
d372 1
a372 1
static def_word_mod(mlval argument)
@


1.3
log
@Adding num_to_word32() word32_to_num().
Updating to use allocate_word32() and CWORD32().
Made code more GC-safe by moving allocation to end of functions.
@
text
@d26 5
d69 1
d354 6
d361 15
d400 4
@


1.2
log
@Changing Word32 repn. to immutable byte vectors (i.e. strings).
@
text
@d26 3
d71 22
d95 1
a95 1
   unsigned *item;
d99 3
a101 1
   item = (unsigned *)CSTRING(argument);
a102 1
   result = MLINT(check_int30(*item)); 
d107 1
a107 1
{  unsigned item, *addr;
d113 2
a114 3
   result = allocate_string(5);
   addr = (unsigned *)CSTRING(result);
   *addr = (unsigned)item;
d120 1
a120 1
{  unsigned *addr, *val1, *val2;
d123 2
a124 2
   val1 = (unsigned *)CSTRING(FIELD(argument,0));
   val2 = (unsigned *)CSTRING(FIELD(argument,1));
d126 1
a126 1
   result = allocate_string(5);
d128 2
a129 2
   addr = (unsigned *)CSTRING(result);
   *addr = (*val1 | *val2);
d136 1
a136 1
   unsigned *addr, *val1, *val2;
d140 2
a141 2
   val1 = (unsigned *)CSTRING(FIELD(argument,0));
   val2 = (unsigned *)CSTRING(FIELD(argument,1));
d143 1
a143 1
   result = allocate_string(5);
d145 2
a146 2
   addr = (unsigned *)CSTRING(result);
   *addr = (*val1 ^ *val2);
d152 1
a152 1
{  unsigned *addr, *val1, *val2;
d155 2
a156 2
   val1 = (unsigned *)CSTRING(FIELD(argument,0));
   val2 = (unsigned *)CSTRING(FIELD(argument,1));
d158 1
a158 1
   result = allocate_string(5);
d160 2
a161 2
   addr = (unsigned *)CSTRING(result);
   *addr = (*val1 & *val2);
d168 1
a168 1
{  unsigned *item, *addr;
d171 1
a171 1
   item = (unsigned *)CSTRING(argument);
d173 1
a173 1
   result = allocate_string(5);
d175 2
a176 2
   addr = (unsigned *)CSTRING(result);
   *addr = (unsigned)~*item;
d184 1
a184 1
   unsigned *addr, *item;
d187 1
a187 1
   item = (unsigned *)CSTRING(FIELD(argument,0));
d193 3
a195 2
   result = allocate_string(5);
   addr = (unsigned *)CSTRING(result);
d197 2
a198 3
   if (shift > 0)
	{ *addr = (unsigned)(*item << shift); }
   else { *addr = (unsigned)(*item >> -shift); };
d205 1
a205 1
   unsigned *addr, *item;
d208 1
a208 1
   item = (unsigned *)CSTRING(FIELD(argument,0));
a213 3
   result = allocate_string(5);
   addr = (unsigned *)CSTRING(result);

d215 3
a217 3
	{ *addr = (unsigned)(*item << shift); }
   else { *addr = (unsigned)(*item >> -shift);
          *addr = signextend(*addr,31 + shift);
d220 3
d227 1
a227 1
{  unsigned *addr, *val1, *val2;
d230 2
a231 2
   val1 = (unsigned *)CSTRING(FIELD(argument,0));
   val2 = (unsigned *)CSTRING(FIELD(argument,1));
d233 1
a233 1
   result = allocate_string(5);
d235 2
a236 2
   addr = (unsigned *)CSTRING(result);
   *addr = (*val1 + *val2);
d243 1
a243 1
{  unsigned *addr, *val1, *val2;
d246 2
a247 2
   val1 = (unsigned *)CSTRING(FIELD(argument,0));
   val2 = (unsigned *)CSTRING(FIELD(argument,1));
d249 1
a249 1
   result = allocate_string(5);
d251 2
a252 2
   addr = (unsigned *)CSTRING(result);
   *addr = (*val1 - *val2);
d258 1
a258 1
{  unsigned *addr, *val1, *val2;
d261 2
a262 2
   val1 = (unsigned *)CSTRING(FIELD(argument,0));
   val2 = (unsigned *)CSTRING(FIELD(argument,1));
d264 1
a264 1
   result = allocate_string(5);
d266 2
a267 2
   addr = (unsigned *)CSTRING(result);
   *addr = (*val1 * *val2);
d273 1
a273 1
{  unsigned *addr, *val1, *val2;
d276 2
a277 2
   val1 = (unsigned *)CSTRING(FIELD(argument,0));
   val2 = (unsigned *)CSTRING(FIELD(argument,1));
d281 1
a281 1
   result = allocate_string(5);
d283 2
a284 2
   addr = (unsigned *)CSTRING(result);
   *addr = (*val1 / *val2);
d291 1
a291 1
{  unsigned *addr, *val1, *val2;
d294 2
a295 2
   val1 = (unsigned *)CSTRING(FIELD(argument,0));
   val2 = (unsigned *)CSTRING(FIELD(argument,1));
d299 1
a299 1
   result = allocate_string(5);
d301 2
a302 2
   addr = (unsigned *)CSTRING(result);
   *addr = (*val1 % *val2);
d311 2
a312 2
   val1 = (unsigned *)CSTRING(FIELD(argument,0));
   val2 = (unsigned *)CSTRING(FIELD(argument,1));
d321 2
a322 2
   val1 = (unsigned *)CSTRING(FIELD(argument,0));
   val2 = (unsigned *)CSTRING(FIELD(argument,1));
d331 2
a332 2
   val1 = (unsigned *)CSTRING(FIELD(argument,0));
   val2 = (unsigned *)CSTRING(FIELD(argument,1));
d341 2
a342 2
   val1 = (unsigned *)CSTRING(FIELD(argument,0));
   val2 = (unsigned *)CSTRING(FIELD(argument,1));
@


1.1
log
@new unit
New file.
@
text
@d11 6
a16 5
 *  Words with sizes of 4 bytes or more are represented as bytearray
 *  values.  Words whose size (i.e. 8, 16, 24) can fit into a standard
 *  MLWorks integer (i.e. 30 bits) can be given an arithmetic
 *  implementation purely within MLWorks (using in part the Bits
 *  operations on integers that MLWorks provides).
d25 4
a28 1
 *  $Log$
d30 1
a30 1
 */
d64 1
a64 1
   if (appmask(argument,bitblk(31,30)) != 0)  raise_overflow;
d74 1
a74 1
   item = (unsigned *)CBYTEARRAY(argument);
d87 2
a88 2
   result = allocate_bytearray(4);
   addr = (unsigned *)CBYTEARRAY(result);
d98 2
a99 2
   val1 = (unsigned *)CBYTEARRAY(FIELD(argument,0));
   val2 = (unsigned *)CBYTEARRAY(FIELD(argument,1));
d101 1
a101 1
   result = allocate_bytearray(4);
d103 1
a103 1
   addr = (unsigned *)CBYTEARRAY(result);
d115 2
a116 2
   val1 = (unsigned *)CBYTEARRAY(FIELD(argument,0));
   val2 = (unsigned *)CBYTEARRAY(FIELD(argument,1));
d118 1
a118 1
   result = allocate_bytearray(4);
d120 1
a120 1
   addr = (unsigned *)CBYTEARRAY(result);
d130 2
a131 2
   val1 = (unsigned *)CBYTEARRAY(FIELD(argument,0));
   val2 = (unsigned *)CBYTEARRAY(FIELD(argument,1));
d133 1
a133 1
   result = allocate_bytearray(4);
d135 1
a135 1
   addr = (unsigned *)CBYTEARRAY(result);
d146 1
a146 1
   item = (unsigned *)CBYTEARRAY(argument);
d148 1
a148 1
   result = allocate_bytearray(4);
d150 1
a150 1
   addr = (unsigned *)CBYTEARRAY(result);
d162 1
a162 1
   item = (unsigned *)CBYTEARRAY(FIELD(argument,0));
d168 2
a169 2
   result = allocate_bytearray(4);
   addr = (unsigned *)CBYTEARRAY(result);
d183 1
a183 1
   item = (unsigned *)CBYTEARRAY(FIELD(argument,0));
d189 2
a190 2
   result = allocate_bytearray(4);
   addr = (unsigned *)CBYTEARRAY(result);
d205 2
a206 2
   val1 = (unsigned *)CBYTEARRAY(FIELD(argument,0));
   val2 = (unsigned *)CBYTEARRAY(FIELD(argument,1));
d208 1
a208 1
   result = allocate_bytearray(4);
d210 1
a210 1
   addr = (unsigned *)CBYTEARRAY(result);
d221 2
a222 2
   val1 = (unsigned *)CBYTEARRAY(FIELD(argument,0));
   val2 = (unsigned *)CBYTEARRAY(FIELD(argument,1));
d224 1
a224 1
   result = allocate_bytearray(4);
d226 1
a226 1
   addr = (unsigned *)CBYTEARRAY(result);
d236 2
a237 2
   val1 = (unsigned *)CBYTEARRAY(FIELD(argument,0));
   val2 = (unsigned *)CBYTEARRAY(FIELD(argument,1));
d239 1
a239 1
   result = allocate_bytearray(4);
d241 1
a241 1
   addr = (unsigned *)CBYTEARRAY(result);
d251 2
a252 2
   val1 = (unsigned *)CBYTEARRAY(FIELD(argument,0));
   val2 = (unsigned *)CBYTEARRAY(FIELD(argument,1));
d256 1
a256 1
   result = allocate_bytearray(4);
d258 1
a258 1
   addr = (unsigned *)CBYTEARRAY(result);
d269 2
a270 2
   val1 = (unsigned *)CBYTEARRAY(FIELD(argument,0));
   val2 = (unsigned *)CBYTEARRAY(FIELD(argument,1));
d274 1
a274 1
   result = allocate_bytearray(4);
d276 1
a276 1
   addr = (unsigned *)CBYTEARRAY(result);
d286 2
a287 2
   val1 = (unsigned *)CBYTEARRAY(FIELD(argument,0));
   val2 = (unsigned *)CBYTEARRAY(FIELD(argument,1));
d296 2
a297 2
   val1 = (unsigned *)CBYTEARRAY(FIELD(argument,0));
   val2 = (unsigned *)CBYTEARRAY(FIELD(argument,1));
d306 2
a307 2
   val1 = (unsigned *)CBYTEARRAY(FIELD(argument,0));
   val2 = (unsigned *)CBYTEARRAY(FIELD(argument,1));
d316 2
a317 2
   val1 = (unsigned *)CBYTEARRAY(FIELD(argument,0));
   val2 = (unsigned *)CBYTEARRAY(FIELD(argument,1));
@
