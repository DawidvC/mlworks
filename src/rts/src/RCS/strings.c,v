head	1.10;
access;
symbols
	MLW_daveb_inline_1_4_99:1.10.1
	MLWorks_21c0_1999_03_25:1.10
	MLWorks_20c1_1998_08_20:1.10
	MLWorks_20c0_1998_08_04:1.10
	MLWorks_20b2c2_1998_06_19:1.10
	MLWorks_20b2_Windows_1998_06_12:1.10
	MLWorks_20b1c1_1998_05_07:1.10
	MLWorks_20b0_1998_04_07:1.10
	MLWorks_20b0_1998_03_20:1.10
	MLWorks_20m2_1998_02_16:1.9
	MLWorks_MM_adapt:1.9.12
	MLWorks_20m1_1997_10_23:1.9
	MLWorks_11r1:1.9.9.1.1.1.1
	MLWorks_workspace_97:1.9.11
	MLWorks_dt_wizard:1.9.10
	MLWorks_11c0_1997_09_09:1.9.9.1.1.1
	MLWorks_10r3:1.9.9.1.3
	MLWorks_10r2_551:1.9.9.1.2
	MLWorks_11:1.9.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.9.9.1
	MLWorks_20m0_1997_06_20:1.9
	MLWorks_1_0_r2c2_1997_06_14:1.9.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.9.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.9.9
	MLWorks_BugFix_1997_04_24:1.9
	MLWorks_1_0_r2_Win32_1997_04_11:1.9
	MLWorks_1_0_r2_Unix_1997_04_04:1.9
	MM_ML_release_korma_1997_04_01:1.9
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.9.7.1.1
	MLWorks_gui_1996_12_18:1.9.8
	MLWorks_1_0_Win32_1996_12_17:1.9.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.9.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.9.4.1
	JFHrts:1.9.6
	MLWorks_1_0_Irix_1996_11_28:1.9.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.9.5
	MLWorks_1_0_Unix_1996_11_14:1.9.4
	MLWorks_Open_Beta2_1996_10_11:1.9.3
	MLWorks_License_dev:1.9.2
	MLWorks_1_open_beta_1996_09_13:1.9.1
	MLWorks_Open_Beta_1996_08_22:1.9
	MLWorks_Beta_1996_07_02:1.9
	MLWorks_Beta_1996_06_07:1.9
	MLWorks_Beta_1996_06_06:1.9
	MLWorks_Beta_1996_06_05:1.9
	MLWorks_Beta_1996_06_03:1.8
	MLWorks_Beta_1996_05_31:1.8
	MLWorks_Beta_1996_05_30:1.8
	hope_poo:1.3.1
	ML_beta_release_12/08/94:1.3.1.1
	ML_beta_release_03/08/94:1.3;
locks; strict;
comment	@ * @;


1.10
date	98.02.23.18.33.25;	author jont;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	96.06.04.14.15.36;	author io;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1
	1.9.4.1
	1.9.5.1
	1.9.6.1
	1.9.7.1
	1.9.8.1
	1.9.9.1
	1.9.10.1
	1.9.11.1
	1.9.12.1;
next	1.8;

1.8
date	96.05.03.14.04.18;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.08.02.10.59.26;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.05.26.10.53.26;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.05.23.10.50.46;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	95.03.17.12.21.46;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	94.07.11.14.09.54;	author matthew;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	94.06.09.14.43.04;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.11.11.18;	author nickh;	state Exp;
branches;
next	;

1.3.1.1
date	95.07.05.10.28.22;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	96.09.13.11.23.57;	author hope;	state Exp;
branches;
next	;

1.9.2.1
date	96.10.07.16.14.15;	author hope;	state Exp;
branches;
next	;

1.9.3.1
date	96.10.17.11.33.40;	author hope;	state Exp;
branches;
next	;

1.9.4.1
date	96.11.14.12.59.21;	author hope;	state Exp;
branches
	1.9.4.1.1.1;
next	;

1.9.4.1.1.1
date	96.11.28.15.09.21;	author hope;	state Exp;
branches;
next	;

1.9.5.1
date	96.11.22.18.17.05;	author hope;	state Exp;
branches;
next	;

1.9.6.1
date	96.12.17.10.03.49;	author hope;	state Exp;
branches;
next	;

1.9.7.1
date	96.12.17.17.55.26;	author hope;	state Exp;
branches
	1.9.7.1.1.1;
next	;

1.9.7.1.1.1
date	97.02.24.11.46.40;	author hope;	state Exp;
branches;
next	;

1.9.8.1
date	96.12.18.09.50.01;	author hope;	state Exp;
branches;
next	;

1.9.9.1
date	97.05.12.10.43.43;	author hope;	state Exp;
branches
	1.9.9.1.1.1
	1.9.9.1.2.1
	1.9.9.1.3.1;
next	;

1.9.9.1.1.1
date	97.07.28.18.27.10;	author daveb;	state Exp;
branches
	1.9.9.1.1.1.1.1;
next	;

1.9.9.1.1.1.1.1
date	97.10.07.11.53.13;	author jkbrook;	state Exp;
branches;
next	;

1.9.9.1.2.1
date	97.09.08.17.20.17;	author daveb;	state Exp;
branches;
next	;

1.9.9.1.3.1
date	97.09.09.14.16.22;	author daveb;	state Exp;
branches;
next	;

1.9.10.1
date	97.09.10.19.34.07;	author brucem;	state Exp;
branches;
next	;

1.9.11.1
date	97.09.11.21.03.14;	author daveb;	state Exp;
branches;
next	;

1.9.12.1
date	97.10.31.13.46.06;	author nickb;	state Exp;
branches;
next	;

1.10.1.1
date	99.04.01.18.02.20;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.10
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@/*  ==== PERVASIVE STRINGS ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Revision Log
 *  ------------
 *  $Log: src:strings.c,v $
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
 * Revision 1.8  1996/05/03  14:04:18  matthew
 * Fixing problem with string equality -- compare the terminating bytes too!.
 *
 * Revision 1.7  1995/08/02  10:59:26  nickb
 * GC root error in implode_char().
 *
 * Revision 1.6  1995/05/26  10:53:26  matthew
 * Changing interface to implode_char function -- now takes a size parameter
 *
 * Revision 1.5  1995/05/23  10:50:46  daveb
 * Added unsafe_string_substring.
 *
 * Revision 1.4  1995/03/17  12:21:46  matthew
 * Adding implode_char function
 *
 * Revision 1.3  1994/07/11  14:09:54  matthew
 * Added "internal" entry points for string le & ge, for the convenience of
 * new lambda optimiser.
 *
 * Revision 1.2  1994/06/09  14:43:04  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:11:18  nickh
 * new file
 *
 *  Revision 1.7  1994/01/28  17:39:52  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.6  1993/09/02  14:25:02  jont
 *  Merging in bug fixes
 *
 *  Revision 1.5.1.2  1993/09/02  13:27:01  jont
 *  Modified concatenate to return one of the original strings if the other is empty
 *
 *  Revision 1.5.1.1  1993/03/30  16:38:41  jont
 *  Fork for bug fixing
 *
 *  Revision 1.5  1993/03/30  16:38:41  jont
 *  Minor efficiency improvement for imploding lots of single character strings
 *
 *  Revision 1.4  1993/02/01  16:04:37  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.3  1993/01/14  15:19:29  daveb
 *  Changed explode to use new representation of lists.
 *
 *  Revision 1.2  1992/11/17  15:00:38  jont
 *  Modified to use poly_eq for string eq and sparc coded versions
 *  of string < and >
 *
 *  Revision 1.1  1992/10/23  16:01:39  richard
 *  Initial revision
 *
 */

#include <string.h>

#include "strings.h"
#include "gc.h"
#include "allocator.h"
#include "mltypes.h"
#include "values.h"
#include "environment.h"
#include "exceptions.h"

static mlval string1, string2, stringlist;

#ifdef MACH_STRINGS

#include "mach.h"

#else /* use a C version */

/*  === STRINGS ===
 *
 *  NOTE: The current definitions of string_less() and string_greater() are
 *  incorrect as they do not take into account signed or unsigned
 *  characters.  ML requires unsigned comparison.
 */

static mlval string_equal(mlval argument)
{
  char *s1 = CSTRING(FIELD(argument, 0)),
       *s2 = CSTRING(FIELD(argument, 1));
  int length1 = LENGTH(GETHEADER(FIELD(argument,0)));
  int length2 = LENGTH(GETHEADER(FIELD(argument,1)));

  if(length1 == length2 && memcmp(s1, s2, (size_t) length1) == 0)
    return(MLTRUE);

  return(MLFALSE);
}

static mlval string_not_equal(mlval argument)
{
  char *s1 = CSTRING(FIELD(argument, 0)),
       *s2 = CSTRING(FIELD(argument, 1));
  int length1 = LENGTH(GETHEADER(FIELD(argument,0)));
  int length2 = LENGTH(GETHEADER(FIELD(argument,1)));

  if(length1 == length2 && memcmp(s1, s2, (size_t) length1) == 0)
    return(MLFALSE);

  return(MLTRUE);
}

static mlval string_less(mlval argument)
{
  char *s1 = CSTRING(FIELD(argument, 0)),
       *s2 = CSTRING(FIELD(argument, 1));
  int length1 = LENGTH(GETHEADER(FIELD(argument, 0)));
  int length2 = LENGTH(GETHEADER(FIELD(argument, 1)));
  int result;

  result = memcmp(s1,s2,(size_t)((length1 < length2) ? length1 : length2));
  return(MLINT((result < 0) || ((result == 0) && (length1 < length2))));
}

static mlval string_greater(mlval argument)
{
  char *s1 = CSTRING(FIELD(argument, 0)),
       *s2 = CSTRING(FIELD(argument, 1));
  int length1 = LENGTH(GETHEADER(FIELD(argument, 0)));
  int length2 = LENGTH(GETHEADER(FIELD(argument, 1)));
  int result;

  result = memcmp(s1,s2,(size_t)((length1 < length2) ? length1 : length2));
  return (MLINT((result > 0) || ((result == 0) && (length1 > length2))));
}

#endif /* MACH_STRINGS */

static mlval unsafe_substring(mlval argument)
{
  int start = CINT(FIELD(argument,1));
  int length = CINT(FIELD(argument,2));
  int bound;
  mlval result;

  string1 = FIELD(argument, 0);
  bound = LENGTH(GETHEADER(string1)) - 1;

  result = allocate_string((size_t) (length+1));
  memcpy(CSTRING(result), CSTRING(string1) + start, (size_t) length);
  CSTRING(result)[length] = '\0';

  string1 = MLUNIT;

  return(result);
}

static mlval concatenate(mlval argument)
{
  size_t length1, length2;
  mlval result;

  string1 = FIELD(argument, 0);
  string2 = FIELD(argument, 1);
  length1 = LENGTH(GETHEADER(string1)) - 1;
  length2 = LENGTH(GETHEADER(string2)) - 1;

  if (length1 == 0) {
    result = string2;
    string1 = string2 = MLUNIT;
    return (result);
  } else if (length2 == 0) {
    result = string1;
    string1 = string2 = MLUNIT;
    return (result);
  };
  result = allocate_string(length1 + length2 + 1);

  memcpy(CSTRING(result), CSTRING(string1),length1);
  memcpy(CSTRING(result) + length1, CSTRING(string2), length2 + 1);

  string1 = string2 = MLUNIT;

  return(result);
}

static mlval explode(mlval argument)
{
  mlval result;
  size_t length = CSTRINGLENGTH(argument);

  string1 = argument;
  stringlist = MLNIL;

  while(length > 0)
  {
    mlval *start;
    size_t chunk = allocate_multiple(4, length, &start);

    if(chunk > 0)
    {
      char *string = CSTRING(string1);
      mlval *cell, list = stringlist;
      size_t i;

      for(i=0, cell=start; i<chunk; ++i, --length, cell+=4)
      {
	cell[0] = MLPTR(POINTER, &cell[2]);
	cell[1] = list;
	cell[2] = MAKEHEAD(STRING, 2);
	((char *)&cell[3])[0] = string[length-1];
	((char *)&cell[3])[1] = '\0';
	list = MLPTR(PAIRPTR, &cell[0]);
      }

      stringlist = list;
    }
    else
    {
      char *string;
      mlval tmp;

      string2 = allocate_string(2);

      string = CSTRING(string2);
      string[0] = CSTRING(string1)[length-1];
      string[1] = '\0';

      tmp = allocate_record(2);
      FIELD(tmp, 0) = string2;
      FIELD(tmp, 1) = stringlist;
      stringlist = tmp;
      --length;
    }
  }

  result = stringlist;
  string1 = string2 = stringlist = MLUNIT;

  return(result);
}


/*  == Implode a list of strings into a string ==
 *
 *  This function scans the list twice: once to find the length, and
 *  again to build the result string.  This is undesirable, but
 *  inevitable if the function is to be completely general.  However,
 *  for short strings it might be possible to fill up a local buffer
 *  and copy it, and only resort to length counting for long strings.
 *
 *  Raises: Size
 */

static mlval implode(mlval argument)
{
  word length = 0;
  mlval result, list;
  char *res;
  list = stringlist = argument;

  while(!MLISNIL(list))
  {
    length += LENGTH(GETHEADER(MLHEAD(list))) - 1;
    list = MLTAIL(list);
  }

  if (length > ML_MAX_STRING)
  {
    exn_raise (perv_exn_ref_size);
  }

  result = allocate_string(length + 1);
  res = CSTRING(result);
  CSTRING(result)[length] = '\0';

  list = stringlist;
  length = 0;

  while(!MLISNIL(list))
  {
    mlval hd = MLHEAD(list);
    word l = LENGTH(GETHEADER(hd)) - 1;
    char *str = CSTRING(hd);
    if (l == 1) res[length++] = *str;
    else {
      memcpy(res + length, str, l);
      length += l;
    };
    list = MLTAIL(list);
  }

  stringlist = MLUNIT;

  return(result);
}

/* This variant implodes a list of integers 
 * parameter is char list * size 
 * Raises: Size
 */
static mlval implode_char(mlval argument)
{
  word length;
  mlval result, list;
  char *res;
  stringlist = FIELD (argument,0);
  length = CINT (FIELD (argument,1));

  if (length > ML_MAX_STRING){
    exn_raise (perv_exn_ref_size);
  }
  result = allocate_string(length + 1);
  res = CSTRING(result);
  CSTRING(result)[length] = '\0';

  list = stringlist;
  length = 0;

  while(!MLISNIL(list))
  {
    res[length++] = (char) (CINT (MLHEAD(list)) & 0xFF);
    list = MLTAIL(list);
  }

  stringlist = MLUNIT;

  return(result);
}

/* This is the single argument revised basis implode()
 * val implode : char list -> string
 * Raises: Size
 */
static mlval string_implode (mlval argument)
{
  word length = 0;
  mlval result, list;
  char *res;
  stringlist = list = argument;
  
  /* pass1: determine length of list */
  while (!MLISNIL(list)){
    length += 1;
    list = MLTAIL (list);
  }
  if (length > ML_MAX_STRING){
    exn_raise (perv_exn_ref_size);
  }
  /* pass2: copy characters to string */
  result = allocate_string (length + 1);
  res = CSTRING(result);
  CSTRING(result)[length] = '\0';
  
  list = stringlist;
  length = 0;
  while (!MLISNIL(list)){
    res[length++] = (char) (CINT (MLHEAD(list)) & 0xff);
    list = MLTAIL(list);
  }
  stringlist = MLUNIT;
  return (result);
}

/*  === INITIALISE ===  */

void strings_init()
{
  string1 = string2 = stringlist = MLUNIT;
  declare_root(&string1, 0);
  declare_root(&string2, 0);
  declare_root(&stringlist, 0);

#ifdef MACH_STRINGS
  env_asm_function("string equal", poly_equal);
  env_asm_function("string not equal", poly_not_equal);
  env_asm_function("string less", ml_string_less);
  env_asm_function("string greater", ml_string_greater);
#else
  env_function("string equal", string_equal);
  env_function("string not equal", string_not_equal);
  env_function("string less", string_less);
  env_function("string greater", string_greater);
#endif /* MACH_STRINGS */

  env_function("string concatenate", concatenate);
  env_function("string explode", explode);
  env_function("string implode", implode);
  env_function("string c implode char", implode_char);
  env_function("string implode char", string_implode);
  env_function("string unsafe substring", unsafe_substring);
}
@


1.10.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 5
 * Revision 1.10  1998/02/23  18:33:25  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
@


1.9
log
@add exn Size
@
text
@d8 3
d374 3
a376 3
  declare_root(&string1);
  declare_root(&string2);
  declare_root(&stringlist);
@


1.9.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a7 3
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
@


1.9.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 3
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
@


1.9.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 3
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
@


1.9.9.1
log
@branched from 1.9
@
text
@a7 3
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
@


1.9.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.9.9.1  1997/05/12  10:43:43  hope
 * branched from 1.9
 *
@


1.9.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.9.9.1  1997/05/12  10:43:43  hope
 * branched from 1.9
 *
@


1.9.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.9.9.1  1997/05/12  10:43:43  hope
 * branched from 1.9
 *
@


1.9.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.9.9.1.1.1  1997/07/28  18:27:10  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.9.8.1
log
@branched from 1.9
@
text
@a7 3
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
@


1.9.7.1
log
@branched from 1.9
@
text
@a7 3
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
@


1.9.7.1.1.1
log
@branched from 1.9.7.1
@
text
@a7 3
 * Revision 1.9.7.1  1996/12/17  17:55:26  hope
 * branched from 1.9
 *
@


1.9.6.1
log
@branched from 1.9
@
text
@a7 3
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
@


1.9.5.1
log
@branched from 1.9
@
text
@a7 3
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
@


1.9.4.1
log
@branched from 1.9
@
text
@a7 3
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
@


1.9.4.1.1.1
log
@branched from 1.9.4.1
@
text
@a7 3
 * Revision 1.9.4.1  1996/11/14  12:59:21  hope
 * branched from 1.9
 *
@


1.9.3.1
log
@branched from 1.9
@
text
@a7 3
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
@


1.9.2.1
log
@branched from 1.9
@
text
@a7 3
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
@


1.9.1.1
log
@branched from 1.9
@
text
@a7 3
 * Revision 1.9  1996/06/04  14:15:36  io
 * add exn Size
 *
@


1.8
log
@Fixing problem with string equality -- compare the terminating bytes too!.
@
text
@d8 3
d252 2
d269 5
d299 4
a302 2
/* This variant implodes a list of integers */
/* parameter is char list * size */
d311 3
d332 34
d391 1
@


1.7
log
@GC root error in implode_char().
@
text
@d8 3
d89 2
a90 2
  int length1 = LENGTH(GETHEADER(FIELD(argument,0)))-1;
  int length2 = LENGTH(GETHEADER(FIELD(argument,1)))-1;
d102 2
a103 2
  int length1 = LENGTH(GETHEADER(FIELD(argument,0)))-1;
  int length2 = LENGTH(GETHEADER(FIELD(argument,1)))-1;
d115 2
a116 2
  int length1 = LENGTH(GETHEADER(FIELD(argument, 0)))-1;
  int length2 = LENGTH(GETHEADER(FIELD(argument, 1)))-1;
d127 2
a128 2
  int length1 = LENGTH(GETHEADER(FIELD(argument, 0)))-1;
  int length2 = LENGTH(GETHEADER(FIELD(argument, 1)))-1;
a330 2
  env_asm_function("internal string less", ml_string_less);
  env_asm_function("internal string greater", ml_string_greater);
a335 2
  env_function("internal string less", string_less);
  env_function("internal string greater", string_greater);
@


1.6
log
@Changing interface to implode_char function -- now takes a size parameter
@
text
@d8 3
d293 1
a293 1
  list = stringlist = FIELD (argument,0);
d300 1
@


1.5
log
@Added unsafe_string_substring.
@
text
@d8 3
d284 1
d287 1
a287 1
  word length = 0;
d290 2
a291 7
  list = stringlist = argument;

  while(!MLISNIL(list))
  {
    length ++;
    list = MLTAIL(list);
  }
a296 1
  list = stringlist;
d338 1
a338 1
  env_function("string implode char", implode_char);
@


1.4
log
@Adding implode_char function
@
text
@d8 3
d128 1
a128 1
static mlval substring(mlval argument)
a137 3
  if(start < 0 || length < 0 || start > bound || start+length > bound)
    exn_raise(perv_exn_ref_substring);

d341 1
a341 1
  env_function("string substring", substring);
@


1.3
log
@Added "internal" entry points for string le & ge, for the convenience of
new lambda optimiser.
@
text
@d8 4
d280 31
d340 1
@


1.3.1.1
log
@branched from 1.3
@
text
@a7 4
 * Revision 1.3  1994/07/11  14:09:54  matthew
 * Added "internal" entry points for string le & ge, for the convenience of
 * new lambda optimiser.
 *
@


1.2
log
@new file
@
text
@d8 3
d291 2
d298 2
@


1.1
log
@new file
@
text
@d7 4
a10 1
 *  $Log: strings.c,v $
@
