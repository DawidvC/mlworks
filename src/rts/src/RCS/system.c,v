head	1.35;
access;
symbols
	MLW_daveb_inline_1_4_99:1.35.1
	MLWorks_21c0_1999_03_25:1.35
	MLWorks_20c1_1998_08_20:1.35
	MLWorks_20c0_1998_08_04:1.34
	MLWorks_20b2c2_1998_06_19:1.33
	MLWorks_20b2_Windows_1998_06_12:1.33
	MLWorks_20b1c1_1998_05_07:1.30
	MLWorks_20b0_1998_04_07:1.30
	MLWorks_20b0_1998_03_20:1.30
	MLWorks_20m2_1998_02_16:1.29
	MLWorks_MM_adapt:1.27.3
	MLWorks_20m1_1997_10_23:1.27
	MLWorks_11r1:1.24.9.3.1.1.1
	MLWorks_workspace_97:1.27.2
	MLWorks_dt_wizard:1.27.1
	MLWorks_11c0_1997_09_09:1.24.9.3.1.1
	MLWorks_10r3:1.24.9.3.3
	MLWorks_10r2_551:1.24.9.3.2
	MLWorks_11:1.24.9.3.1
	MLWorks_1_0_r2c2_1997_07_28:1.24.9.3
	MLWorks_20m0_1997_06_20:1.25
	MLWorks_1_0_r2c2_1997_06_14:1.24.9.3
	MLWorks_1_0_r2c1_released_1997_05_23:1.24.9.2
	MLWorks_1_0_r2c1_1997_05_12:1.24.9
	MLWorks_BugFix_1997_04_24:1.24
	MLWorks_1_0_r2_Win32_1997_04_11:1.24
	MLWorks_1_0_r2_Unix_1997_04_04:1.24
	MM_ML_release_korma_1997_04_01:1.24
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.24.7.1.1
	MLWorks_gui_1996_12_18:1.24.8
	MLWorks_1_0_Win32_1996_12_17:1.24.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.24.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.24.4.1
	JFHrts:1.24.6
	MLWorks_1_0_Irix_1996_11_28:1.24.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.24.5
	MLWorks_1_0_Unix_1996_11_14:1.24.4
	MLWorks_Open_Beta2_1996_10_11:1.24.3
	MLWorks_License_dev:1.24.2
	MLWorks_1_open_beta_1996_09_13:1.24.1
	MLWorks_Open_Beta_1996_08_22:1.23
	MLWorks_Beta_1996_07_02:1.22
	MLWorks_Beta_1996_06_07:1.22
	MLWorks_Beta_1996_06_06:1.22
	MLWorks_Beta_1996_06_05:1.22
	MLWorks_Beta_1996_06_03:1.22
	MLWorks_Beta_1996_05_31:1.22
	MLWorks_Beta_1996_05_30:1.22
	hope_poo:1.4.1
	ML_beta_release_12/08/94:1.4.1.1
	ML_beta_release_03/08/94:1.4;
locks; strict;
comment	@ * @;


1.35
date	98.08.17.13.41.51;	author jkbrook;	state Exp;
branches
	1.35.1.1;
next	1.34;

1.34
date	98.07.17.15.15.50;	author jkbrook;	state Exp;
branches;
next	1.33;

1.33
date	98.06.12.09.01.41;	author jkbrook;	state Exp;
branches;
next	1.32;

1.32
date	98.06.10.14.09.52;	author mitchell;	state Exp;
branches;
next	1.31;

1.31
date	98.06.09.15.11.00;	author mitchell;	state Exp;
branches;
next	1.30;

1.30
date	98.02.23.18.35.27;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	97.11.26.10.09.18;	author johnh;	state Exp;
branches;
next	1.28;

1.28
date	97.11.18.12.32.20;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	97.06.30.11.18.13;	author andreww;	state Exp;
branches
	1.27.1.1
	1.27.2.1
	1.27.3.1;
next	1.26;

1.26
date	97.06.17.14.05.44;	author andreww;	state Exp;
branches;
next	1.25;

1.25
date	97.06.13.13.32.42;	author jkbrook;	state Exp;
branches;
next	1.24;

1.24
date	96.09.06.14.56.55;	author jont;	state Exp;
branches
	1.24.1.1
	1.24.2.1
	1.24.3.1
	1.24.4.1
	1.24.5.1
	1.24.6.1
	1.24.7.1
	1.24.8.1
	1.24.9.1;
next	1.23;

1.23
date	96.07.29.10.05.20;	author stephenb;	state Exp;
branches;
next	1.22;

1.22
date	96.05.01.08.53.14;	author nickb;	state Exp;
branches;
next	1.21;

1.21
date	96.04.17.10.33.30;	author stephenb;	state Exp;
branches;
next	1.20;

1.20
date	96.03.19.15.02.11;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	96.02.16.15.41.18;	author nickb;	state Exp;
branches;
next	1.18;

1.18
date	96.02.14.15.10.37;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	96.02.14.10.20.36;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	96.02.08.17.53.23;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	96.01.16.12.02.01;	author nickb;	state Exp;
branches;
next	1.14;

1.14
date	95.09.26.14.39.11;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	95.09.19.10.31.25;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	95.09.15.14.33.24;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	95.09.13.14.09.43;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.09.13.10.03.05;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	95.06.09.15.09.12;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.05.05.14.20.58;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	95.05.02.14.45.05;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	94.12.09.15.43.51;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.08.30.15.07.10;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	94.06.24.10.50.38;	author nickh;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	94.06.21.16.02.03;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.49.36;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.11.23.32;	author nickh;	state Exp;
branches;
next	;

1.4.1.1
date	95.07.05.10.30.11;	author hope;	state Exp;
branches;
next	;

1.24.1.1
date	96.09.13.11.24.55;	author hope;	state Exp;
branches;
next	;

1.24.2.1
date	96.10.07.16.15.17;	author hope;	state Exp;
branches;
next	;

1.24.3.1
date	96.10.17.11.34.43;	author hope;	state Exp;
branches;
next	;

1.24.4.1
date	96.11.14.13.00.24;	author hope;	state Exp;
branches
	1.24.4.1.1.1;
next	;

1.24.4.1.1.1
date	96.11.28.15.10.27;	author hope;	state Exp;
branches;
next	;

1.24.5.1
date	96.11.22.18.18.14;	author hope;	state Exp;
branches;
next	;

1.24.6.1
date	96.12.17.10.04.57;	author hope;	state Exp;
branches;
next	;

1.24.7.1
date	96.12.17.17.56.32;	author hope;	state Exp;
branches
	1.24.7.1.1.1;
next	;

1.24.7.1.1.1
date	97.02.24.11.48.08;	author hope;	state Exp;
branches;
next	;

1.24.8.1
date	96.12.18.09.51.10;	author hope;	state Exp;
branches;
next	;

1.24.9.1
date	97.05.12.10.44.51;	author hope;	state Exp;
branches;
next	1.24.9.2;

1.24.9.2
date	97.05.20.17.02.01;	author daveb;	state Exp;
branches;
next	1.24.9.3;

1.24.9.3
date	97.06.09.10.38.50;	author daveb;	state Exp;
branches
	1.24.9.3.1.1
	1.24.9.3.2.1
	1.24.9.3.3.1;
next	;

1.24.9.3.1.1
date	97.07.28.18.26.18;	author daveb;	state Exp;
branches
	1.24.9.3.1.1.1.1;
next	;

1.24.9.3.1.1.1.1
date	97.10.07.11.52.08;	author jkbrook;	state Exp;
branches;
next	;

1.24.9.3.2.1
date	97.09.08.17.19.30;	author daveb;	state Exp;
branches;
next	;

1.24.9.3.3.1
date	97.09.09.14.15.38;	author daveb;	state Exp;
branches;
next	;

1.27.1.1
date	97.09.10.19.32.49;	author brucem;	state Exp;
branches;
next	;

1.27.2.1
date	97.09.11.21.02.06;	author daveb;	state Exp;
branches;
next	;

1.27.3.1
date	97.10.31.13.45.00;	author nickb;	state Exp;
branches;
next	;

1.35.1.1
date	99.04.01.18.01.36;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.35
log
@[Bug #50100]
Remove use of env_lookup("license edition")
@
text
@/*  ==== PERVASIVE TIME ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Revision Log
 *  ------------
 *  $Log: src:system.c,v $
 * Revision 1.34  1998/07/17  15:15:50  jkbrook
 * [Bug #30436]
 * Update edition names
 *
 * Revision 1.33  1998/06/12  09:01:41  jkbrook
 * [Bug #30411]
 * Adding FREE edition
 *
 * Revision 1.32  1998/06/10  14:09:52  mitchell
 * [Bug #30419]
 * Fix missing include of license.h
 *
 * Revision 1.31  1998/06/09  15:11:00  mitchell
 * [Bug #30419]
 * Disable session saving and delivery in free edition
 *
 * Revision 1.30  1998/02/23  18:35:27  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.29  1997/11/26  10:09:18  johnh
 * [Bug #30134]
 * add extra arg to save_excutable.
 *
 * Revision 1.28  1997/11/18  12:32:20  jont
 * [Bug #30089]
 * Remove include of mltime.h which is no longer needed
 *
 * Revision 1.27  1997/06/30  11:18:13  andreww
 * [Bug #20014]
 * cleaning up.
 *
 * Revision 1.25  1997/06/13  13:32:42  jkbrook
 * [Bug #50004]
 * Merging changes from 1.0r2c2 into 2.0m0
 *
 * Revision 1.24.9.3  1997/06/09  10:38:50  daveb
 * [Bug #50004]
 * Moved test for file creation from ml_deliver_function to Win32-specific code.
 *
 * Revision 1.24.9.2  1997/05/20  17:02:01  daveb
 * [Bug #02035]
 * Check that file can be written before beginning to deliver.
 *
 * Revision 1.24.9.1  1997/05/12  10:44:51  hope
 * branched from 1.24
 *
 * Revision 1.24  1996/09/06  14:56:55  jont
 * Add CSTRING to use of load_external in error message
 *
 * Revision 1.23  1996/07/29  10:05:20  stephenb
 * Add a comment to arguments explaining why there is no retract_root
 * to match the declare_root.
 *
 * Revision 1.22  1996/05/01  08:53:14  nickb
 * Change to save_executable.
 *
 * Revision 1.21  1996/04/17  10:33:30  stephenb
 * Remove ml_system and ml_exit.  They are now provided in OS/{Win32,Unix}
 * since they raise OS specific values on error.
 *
 * Revision 1.20  1996/03/19  15:02:11  daveb
 * Made the ELOADEXTERNAL error message include the value of load_external.
 *
 * Revision 1.19  1996/02/16  15:41:18  nickb
 * Change to global_pack().
 *
 * Revision 1.18  1996/02/14  15:10:37  jont
 * Changing ERROR to MLERROR
 *
 * Revision 1.17  1996/02/14  10:20:36  jont
 * Add a dummy return value to ml_exit to keep VC++ happy
 *
 * Revision 1.16  1996/02/08  17:53:23  jont
 * Include export.h, which now has the interface to do_exportFn
 *
 * Revision 1.15  1996/01/16  12:02:01  nickb
 * Remove "storage manager" interface; replace it with regular functions.
 *
 * Revision 1.14  1995/09/26  14:39:11  jont
 * Add executable image save
 *
 * Revision 1.13  1995/09/19  10:31:25  jont
 * Fix problems with C ordering of evaluation of function parameters
 * interaction with gc and C roots
 *
 * Revision 1.12  1995/09/15  14:33:24  jont
 * Work on using fork for exportFn
 *
 * Revision 1.11  1995/09/13  14:09:43  jont
 * Remove extra garbage collections during exportFn
 *
 * Revision 1.10  1995/09/13  10:03:05  jont
 * Add ml_save_function for use by exportFn
 *
 * Revision 1.9  1995/06/09  15:09:12  nickb
 * Move profiler interface to profiler.c
 *
 * Revision 1.8  1995/05/05  14:20:58  jont
 * Change call to internal_load_link not be verbose
 *
 * Revision 1.7  1995/05/02  14:45:05  jont
 * Make error strings consistent by removing full stops.
 * Add file names to error messages where files are mentioned
 *
 * Revision 1.6  1994/12/09  15:43:51  jont
 * Change time.h to mltime.h
 *
 * Revision 1.5  1994/08/30  15:07:10  matthew
 * filename needs to be a root in ml_image_save
 *
 * Revision 1.4  1994/06/24  10:50:38  nickh
 * Declare profiler result as a root.
 *
 * Revision 1.3  1994/06/21  16:02:03  nickh
 * New ancillary structure and forced GC on image save.
 *
 * Revision 1.2  1994/06/09  14:49:36  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:23:32  nickh
 * new file
 *
 *  Revision 1.13  1994/03/24  18:12:38  nickh
 *  New profiler, with a slightly different interface.
 *
 *  Revision 1.12  1994/01/10  13:43:58  matthew
 *  Added ml_load_link
 *
 *  Revision 1.11  1993/06/02  13:09:40  richard
 *  Fixed benign =/== confusion.
 *
 *  Revision 1.10  1993/06/01  12:13:28  richard
 *  *** empty log message ***
 *
 *  Revision 1.9  1993/05/17  13:10:01  richard
 *  Corrected the profile selector to select everything when passed
 *  an empty list.
 *
 *  Revision 1.8  1993/04/14  13:29:29  richard
 *  Moved UNIX stuff to unix.c.
 *
 *  Revision 1.7  1993/04/02  14:31:59  jont
 *  New exception for bad iage when reading table of contents
 *
 *  Revision 1.6  1993/03/11  18:33:57  jont
 *  Added code to do image cleaning, and connected it into the rts
 *
 *  Revision 1.5  1993/02/25  09:56:42  nosa
 *  A minor Bug Fix
 *
 *  Revision 1.4  1993/02/24  14:08:56  nosa
 *  Implemented a multi-level profiler
 *
 *  Revision 1.3  1993/02/01  16:04:36  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.2  1992/12/18  15:22:31  clive
 *  Made the profiler take the generalised streams
 *
 *  Revision 1.1  1992/11/03  12:51:24  richard
 *  Initial revision
 *
 */

#include <stdlib.h>
#include <errno.h>
#include <string.h>

#include "system.h"
#include "exceptions.h"
#include "mltypes.h"
#include "values.h"
#include "gc.h"
#include "allocator.h"
#include "environment.h"
#include "main.h"
#include "profiler.h"
#include "ansi.h"
#include "interface.h"
#include "global.h"
#include "loader.h"
#include "utils.h"
#include "intercept.h"
#include "pervasives.h"
#include "event.h"
#include "threads.h"
#include "diagnostic.h"
#include "image.h"
#include "exec_delivery.h"
#include "export.h"
#include "mlw_mklic.h"
#include "license.h"

static mlval ml_save_image(mlval argument)
{
  mlval global, filename;

  /* license_edition is a global C enum */

  if ((license_edition == PERSONAL) || act_as_free) {
    display_simple_message_box(
      "Saving images is not enabled in the Personal edition of MLWorks");
    return MLUNIT;
  }

  filename = FIELD(argument, 0);
  image_continuation = FIELD(argument, 1);
  declare_root(&filename, 1);

  global = global_pack(0);	/* 0 = not delivery */
  declare_root(&global, 1);

  {
    mlval old_message_level = MLSUB(gc_message_level,0);
    MLUPDATE(gc_message_level,0,MLINT(-1));
    gc_collect_all();
    MLUPDATE(gc_message_level,0,old_message_level);
  }

  argument = allocate_record(2);
  FIELD(argument, 0) = filename;
  FIELD(argument, 1) = global;
  retract_root(&filename);
  retract_root(&global);

  if(image_save(argument) == MLERROR)
    switch(errno)
    {
      case EIMPL:
      exn_raise_string(perv_exn_ref_save, "Image save not implemented");

      case EIMAGEWRITE:
      exn_raise_string(perv_exn_ref_save, "Error writing opened image file");

      case EIMAGEOPEN:
      exn_raise_string(perv_exn_ref_save, "Unable to open image file");

      default:
      exn_raise_string(perv_exn_ref_save, "Unexpected error from image_save()");
    }

  argument = image_continuation;
  image_continuation = MLUNIT;
  return(argument);
}

static mlval ml_save_exec_image(mlval argument)
{
  mlval global, filename;

  if ((license_edition == PERSONAL) || act_as_free) {
    display_simple_message_box(
      "Saving executables is not enabled in the Personal edition of MLWorks");
    return MLUNIT;
  }

  filename = FIELD(argument, 0);
  image_continuation = FIELD(argument, 1);
  declare_root(&filename, 1);

  global = global_pack(0);	/* 0 = not delivery */
  declare_root(&global, 1);

  {
    mlval old_message_level = MLSUB(gc_message_level,0);
    MLUPDATE(gc_message_level,0,MLINT(-1));
    gc_collect_all();
    MLUPDATE(gc_message_level,0,old_message_level);
  }

  retract_root(&filename);
  retract_root(&global);

  if(save_executable(CSTRING(filename), global, APP_CURRENT) == MLERROR)
    switch(errno)
    {
      case EIMPL:
      exn_raise_string(perv_exn_ref_save, "Executable image save not implemented");

      case EIMAGEWRITE:
      exn_raise_string(perv_exn_ref_save, "Error writing opened image file");

      case EIMAGEOPEN:
      exn_raise_string(perv_exn_ref_save, "Unable to open image file");

      default:
      exn_raise_string(perv_exn_ref_save, "Unexpected error from image_save()");
    }

  argument = image_continuation;
  image_continuation = MLUNIT;
  return(argument);
}

static mlval ml_deliver_function(mlval argument)
{
  if ((license_edition == PERSONAL) || act_as_free) {
    display_simple_message_box(
      "Delivering executables is not enabled in the Personal edition of MLWorks");
    /* exn_raise_string(perv_exn_ref_save, 
         "Delivery not enabled for this edition"); */
    return MLUNIT;
  }

  declare_root(&argument, 1);
  gc_collect_all(); /* Do a full gc before forking */
  retract_root(&argument);
  return deliverFn(argument);
}

static mlval ml_image_table(mlval argument)
{
  argument = image_table(argument);
  if(argument == MLERROR)
    switch(errno)
    {
      case EIMPL:
      exn_raise_string(perv_exn_ref_save, "Image table not implemented");

      case EIMAGEREAD:
      exn_raise_string(perv_exn_ref_save, "Error reading opened image file");

      case EIMAGEOPEN:
      exn_raise_string(perv_exn_ref_save, "Unable to open image file");

      default:
      exn_raise_string(perv_exn_ref_save,
		       "Unexpected error from image_table()");
    }

  return(argument);
}




/* arguments: unit -> string list
 *
 * To avoid consing up the list each time this is called, the list
 * is created once and cached.  This is the reason for the declare_root
 * with no corresponding retract_root.
 */
static mlval arguments(mlval unit)
{
  static mlval result= DEAD;
  int i;

  if(result == DEAD)
  {
    result = MLNIL;
    declare_root(&result, 0);

    for(i=module_argc-1; i >= 0; --i) {
      mlval temp= ml_string(module_argv[i]);  /* Do NOT inline this */
      result= mlw_cons(temp, result);
    }
  }

  return result;
}

static mlval name(mlval unit)
{
  mlval string = ml_string(runtime);
  return string;
}





static mlval clean_code(unsigned int index, mlval code)
{
  /* maybe we should do something for the names? */

  CCODE_SET_PROFILE(code,(mlval)NULL);
  if (CCODE_CAN_INTERCEPT(code)) {
    code_nop(code);		/* turn off intercepting */
    CCODE_SET_INTERFN(code,MLUNIT);
  }
  return(code);
}

static mlval ml_clean_image(mlval unit)
{
  weak_apply(loader_code, clean_code);
  return(MLUNIT);
}

static mlval ml_load_wordset(mlval wordset)
{
  mlval result = load_wordset(wordset);

  if(result == MLERROR)
    switch(errno)
    {
      case ELOADNEWER:
      exn_raise_string(perv_exn_ref_load, "Newer format than expected");

      case ELOADOLDER:
      exn_raise_string(perv_exn_ref_load, "Older format than expected");

      case ELOADALIGN:
      exn_raise_string(perv_exn_ref_load, "Code string of unaligned length");

      case ELOADEMPTY:
      exn_raise_string(perv_exn_ref_load, "Empty wordset");

      default:
      error("load_wordset() returned an unexpected error code %d", errno);
    }

  return(result);
}

/* This should raise an exception when an error occurs */
static mlval ml_load_link(mlval arg)
{
  const char *filename = CSTRING(arg);
  /* Maybe this should use options properly -- how are they propagated here? */

  mlval mod_name = MLUNIT;
  mlval result = internal_load_link(filename,&mod_name,0,1,0);

  if(result == MLERROR)
    switch(errno)
      {
      case ELOADREAD:
	exn_raise_format (perv_exn_ref_load,"The loader was unable to read from the file '%s'", filename);
      case ELOADOPEN:
	exn_raise_format (perv_exn_ref_load,"The loader was unable to open the file '%s'", filename);
      case ELOADALLOC:
	exn_raise_string (perv_exn_ref_load,"The loader was unable to allocate enough memory");
      case ELOADVERSION:
	exn_raise_format (perv_exn_ref_load,"The file '%s' contains a module of a version the loader does not understand", filename);
      case ELOADFORMAT:
	exn_raise_format (perv_exn_ref_load,"The file '%s' is not in the correct loader format", filename);
      case ELOADEXTERNAL:
	exn_raise_format (perv_exn_ref_load,"The module in the file '%s' references an unloaded external module '%s'", filename, CSTRING(load_external));
      default:
	exn_raise_string (perv_exn_ref_load,"The loader returned an invalid error code.");
      }
  else
    {
      mlval pair;
      declare_root (&mod_name, 0);
      declare_root (&result, 0);
      pair = allocate_record(2);
      FIELD(pair, 0) = mod_name;
      FIELD(pair, 1) = result;
      retract_root (&mod_name);
      retract_root (&result);
      return(pair);
    }
}

static mlval ml_collect_gen(mlval arg)
{
  int number = CINT(arg);
  if (number >= 0)
    gc_collect_gen((unsigned int)number);
  return MLUNIT;
}

static mlval ml_collect_all(mlval unit)
{
  gc_collect_all();
  return MLUNIT;
}

static mlval ml_promote_all(mlval unit)
{
  gc_promote_all();
  return MLUNIT;
}

void system_init()
{
  env_function("system os name", name);
  env_function("system os arguments", arguments);
  env_function("system load wordset", ml_load_wordset);
  env_function("system load link",ml_load_link);
  env_function("image save", ml_save_image);
  env_function("exec image save", ml_save_exec_image);
  env_function("image table", ml_image_table);
  env_function("function deliver", ml_deliver_function);
  env_function("clean code vectors", ml_clean_image);

  env_function("gc collect generation", ml_collect_gen);
  env_function("gc collect all", ml_collect_all);
  env_function("gc promote all", ml_promote_all);
  env_function("gc collections", gc_collections);
}
@


1.35.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 4
 * Revision 1.35  1998/08/17  13:41:51  jkbrook
 * [Bug #50100]
 * Remove use of env_lookup("license edition")
 *
@


1.34
log
@[Bug #30436]
Update edition names
@
text
@d8 4
a205 1
  enum edition license_edition;
d207 1
a207 1
  license_edition = env_lookup("license edition");
d211 1
a211 1
      "Saving images is not enabled in the free edition of MLWorks");
a258 3
  enum edition license_edition;

  license_edition = env_lookup("license edition");
d262 1
a262 1
      "Saving executables is not enabled in the free edition of MLWorks");
a305 4
  enum edition license_edition;

  license_edition = env_lookup("license edition");

d308 1
a308 1
      "Delivering executables is not enabled in the free edition of MLWorks");
@


1.33
log
@[Bug #30411]
Adding FREE edition
@
text
@d8 4
d206 1
a206 1
  if ((license_edition == STUDENT) || (license_edition == FREE) || act_as_free) {
d260 1
a260 1
  if ((license_edition == STUDENT) || (license_edition == FREE) || act_as_free) {
d310 1
a310 1
  if ((license_edition == STUDENT) || (license_edition == FREE) || act_as_free) {
@


1.32
log
@[Bug #30419]
Fix missing include of license.h
@
text
@d8 4
d192 1
a193 1
#include "mlw_mklic.h"
d198 1
d200 3
a202 1
  if ( EDITION == STUDENT ) {
d252 3
d256 1
a256 1
  if ( EDITION == STUDENT ) {
d302 5
a306 1
  if ( EDITION == STUDENT ) {
@


1.31
log
@[Bug #30419]
Disable session saving and delivery in free edition
@
text
@d8 4
d188 1
@


1.30
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d8 5
d184 1
d190 6
d241 6
d287 8
@


1.29
log
@[Bug #30134]
add extra arg to save_excutable.
@
text
@d8 4
d186 1
a186 1
  declare_root(&filename);
d189 1
a189 1
  declare_root(&global);
d231 1
a231 1
  declare_root(&filename);
d234 1
a234 1
  declare_root(&global);
d269 1
a269 1
  declare_root(&argument);
d315 1
a315 1
    declare_root(&result);
d410 2
a411 2
      declare_root (&mod_name);
      declare_root (&result);
@


1.28
log
@[Bug #30089]
Remove include of mltime.h which is no longer needed
@
text
@d8 4
d242 1
a242 1
  if(save_executable(CSTRING(filename), global) == MLERROR)
@


1.27
log
@[Bug #20014]
cleaning up.
@
text
@d8 4
a156 1
#include "mltime.h"
@


1.27.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a7 4
 * Revision 1.27  1997/06/30  11:18:13  andreww
 * [Bug #20014]
 * cleaning up.
 *
@


1.27.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 4
 * Revision 1.27  1997/06/30  11:18:13  andreww
 * [Bug #20014]
 * cleaning up.
 *
@


1.27.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 4
 * Revision 1.27  1997/06/30  11:18:13  andreww
 * [Bug #20014]
 * cleaning up.
 *
@


1.26
log
@[Bug #20014]
adding system os name call to return the name of the executable.
@
text
@a316 1
  size_t length;
d318 1
a318 1
  return(string);
@


1.25
log
@[Bug #50004]
Merging changes from 1.0r2c2 into 2.0m0
@
text
@d8 4
d315 8
d433 1
@


1.24
log
@Add CSTRING to use of load_external in error message
@
text
@d8 14
@


1.24.9.1
log
@branched from 1.24
@
text
@a7 3
 * Revision 1.24  1996/09/06  14:56:55  jont
 * Add CSTRING to use of load_external in error message
 *
@


1.24.9.2
log
@[Bug #02035]
Check that file can be written before beginning to deliver.
@
text
@a7 3
 * Revision 1.24.9.1  1997/05/12  10:44:51  hope
 * branched from 1.24
 *
a126 1
#include <stdio.h>
a242 13
  char* filename = CSTRING(FIELD(argument, 0));
  FILE *tmp;

  /* Check that we can write the file before going any further, because
   * once we're past this stage on Windows, the process is doomed to die.
   */
  tmp = fopen(filename, "wb");
  if (tmp == NULL) {
    exn_raise_string(perv_exn_ref_save, "Unable to open file for delivery");
  } else {
    fclose(tmp);
  }

@


1.24.9.3
log
@[Bug #50004]
Moved test for file creation from ml_deliver_function to Win32-specific code.
@
text
@a7 4
 * Revision 1.24.9.2  1997/05/20  17:02:01  daveb
 * [Bug #02035]
 * Check that file can be written before beginning to deliver.
 *
d130 1
d247 13
@


1.24.9.3.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 4
 * Revision 1.24.9.3  1997/06/09  10:38:50  daveb
 * [Bug #50004]
 * Moved test for file creation from ml_deliver_function to Win32-specific code.
 *
@


1.24.9.3.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 4
 * Revision 1.24.9.3  1997/06/09  10:38:50  daveb
 * [Bug #50004]
 * Moved test for file creation from ml_deliver_function to Win32-specific code.
 *
@


1.24.9.3.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 4
 * Revision 1.24.9.3  1997/06/09  10:38:50  daveb
 * [Bug #50004]
 * Moved test for file creation from ml_deliver_function to Win32-specific code.
 *
@


1.24.9.3.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.24.9.3.1.1  1997/07/28  18:26:18  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.24.8.1
log
@branched from 1.24
@
text
@a7 3
 * Revision 1.24  1996/09/06  14:56:55  jont
 * Add CSTRING to use of load_external in error message
 *
@


1.24.7.1
log
@branched from 1.24
@
text
@a7 3
 * Revision 1.24  1996/09/06  14:56:55  jont
 * Add CSTRING to use of load_external in error message
 *
@


1.24.7.1.1.1
log
@branched from 1.24.7.1
@
text
@a7 3
 * Revision 1.24.7.1  1996/12/17  17:56:32  hope
 * branched from 1.24
 *
@


1.24.6.1
log
@branched from 1.24
@
text
@a7 3
 * Revision 1.24  1996/09/06  14:56:55  jont
 * Add CSTRING to use of load_external in error message
 *
@


1.24.5.1
log
@branched from 1.24
@
text
@a7 3
 * Revision 1.24  1996/09/06  14:56:55  jont
 * Add CSTRING to use of load_external in error message
 *
@


1.24.4.1
log
@branched from 1.24
@
text
@a7 3
 * Revision 1.24  1996/09/06  14:56:55  jont
 * Add CSTRING to use of load_external in error message
 *
@


1.24.4.1.1.1
log
@branched from 1.24.4.1
@
text
@a7 3
 * Revision 1.24.4.1  1996/11/14  13:00:24  hope
 * branched from 1.24
 *
@


1.24.3.1
log
@branched from 1.24
@
text
@a7 3
 * Revision 1.24  1996/09/06  14:56:55  jont
 * Add CSTRING to use of load_external in error message
 *
@


1.24.2.1
log
@branched from 1.24
@
text
@a7 3
 * Revision 1.24  1996/09/06  14:56:55  jont
 * Add CSTRING to use of load_external in error message
 *
@


1.24.1.1
log
@branched from 1.24
@
text
@a7 3
 * Revision 1.24  1996/09/06  14:56:55  jont
 * Add CSTRING to use of load_external in error message
 *
@


1.23
log
@Add a comment to arguments explaining why there is no retract_root
to match the declare_root.
@
text
@d8 4
d367 1
a367 1
	exn_raise_format (perv_exn_ref_load,"The module in the file '%s' references an unloaded external module '%s'", filename, load_external);
@


1.22
log
@Change to save_executable.
@
text
@d8 3
d267 7
d276 1
a276 1
  static mlval result = DEAD;
d285 2
a286 2
      mlval temp = ml_string(module_argv[i]);  /* Do NOT inline this */
      result = cons(temp, result);
d290 1
a290 1
  return(result);
d292 3
@


1.21
log
@Remove ml_system and ml_exit.  They are now provided in OS/{Win32,Unix}
since they raise OS specific values on error.
@
text
@d8 4
a206 3
  argument = allocate_record(2);
  FIELD(argument, 0) = filename;
  FIELD(argument, 1) = global;
d210 1
a210 1
  if(save_executable(argument) == MLERROR)
@


1.20
log
@Made the ELOADEXTERNAL error message include the value of load_external.
@
text
@d8 3
a260 4
static mlval ml_system(mlval arg)
{
  return(MLINT(system(CSTRING(arg))));
}
a261 6
static mlval ml_exit(mlval arg)
{
  exit(CINT(arg));
  /*** NOT REACHED ***/
  return MLUNIT;
}
a388 2
  env_function("system os system", ml_system);
  env_function("system exit", ml_exit);
@


1.19
log
@Change to global_pack().
@
text
@d8 3
d356 1
a356 1
	exn_raise_format (perv_exn_ref_load,"The module in the file '%s' references an unloaded external module", filename);
@


1.18
log
@Changing ERROR to MLERROR
@
text
@d8 3
d142 1
a142 1
  global = global_pack();
d187 1
a187 1
  global = global_pack();
d224 1
a224 1
static mlval ml_save_function(mlval argument)
d229 1
a229 1
  return do_exportFn(argument);
d401 1
a401 1
  env_function("function save", ml_save_function);
@


1.17
log
@Add a dummy return value to ml_exit to keep VC++ happy
@
text
@d8 3
d155 1
a155 1
  if(image_save(argument) == ERROR)
d200 1
a200 1
  if(save_executable(argument) == ERROR)
d232 1
a232 1
  if(argument == ERROR)
d305 1
a305 1
  if(result == ERROR)
d336 1
a336 1
  if(result == ERROR)
@


1.16
log
@Include export.h, which now has the interface to do_exportFn
@
text
@d8 3
d257 2
@


1.15
log
@Remove "storage manager" interface; replace it with regular functions.
@
text
@d8 3
a119 1
#include "signals.h"
d123 1
@


1.14
log
@Add executable image save
@
text
@d8 3
d119 2
d136 1
a136 1
    (void) sm_interface(SM_COLLECT_ALL,1, MLUNIT);
d146 1
a146 1
  if(sm_interface(SM_IMAGE_SAVE, 1, argument) == ERROR)
d181 1
a181 1
    (void) sm_interface(SM_COLLECT_ALL,1, MLUNIT);
d191 1
a191 1
  if(sm_interface(SM_EXEC_IMAGE_SAVE, 1, argument) == ERROR)
d215 1
a215 1
  (void) sm_interface(SM_COLLECT_ALL, 1, MLUNIT); /* Do a full gc before forking */
d222 1
a222 1
  argument = sm_interface(SM_IMAGE_TABLE, 1, argument);
d357 20
d389 5
@


1.13
log
@Fix problems with C ordering of evaluation of function parameters
interaction with gc and C roots
@
text
@d8 4
d162 1
a162 1
static mlval ml_save_function(mlval argument)
d164 1
a164 8
  declare_root(&argument);
  (void) sm_interface(SM_COLLECT_ALL, 1, MLUNIT); /* Do a full gc before forking */
  retract_root(&argument);
  return do_exportFn(argument);
#if 0
  clear_export_child_status();
  signal_export_watch_child();
  child_pid = fork();
d166 3
a168 6
  if(child_pid == -1) {
    switch(errno)
      {
      case EAGAIN:
      exn_raise_string(perv_exn_ref_save,
		       "Too many processes running to fork exportFn process");
d170 2
a171 3
      case ENOMEM:
      exn_raise_string(perv_exn_ref_save,
		       "Insufficient memory to fork licensing process");
d173 6
a178 13
      default:
      {
	char error_message[200];
	sprintf(error_message, "fork() returned an unexpected error code %d", errno);
	exn_raise_string(perv_exn_ref_save, error_message);
      }
    }
  } else {
    if (child_pid == 0) {
      /* The child process */
      filename = FIELD(argument, 0);
      image_continuation = FIELD(argument, 1); /* This is a global, and hence a root */
      declare_root(&filename);
d180 5
a184 2
      global = global_pack();
      declare_root(&global);
d186 3
a188 48
      {
	mlval old_message_level = MLSUB(gc_message_level,0);
	clear_handlers(); /* Don't follow the signal handlers */
	clear_thread_roots(); /* Don't follow roots in ml_state etc */
	MLUPDATE(modules, 0, MLNIL); /* Clear the module table */
	MLUPDATE(gc_message_level,0,MLINT(-1));
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* Don't scan the stack during gc */
	MLUPDATE(gc_message_level,0,old_message_level);
      }

      argument = allocate_record(2);
      FIELD(argument, 0) = filename;
      FIELD(argument, 1) = global;
      retract_root(&filename);
      retract_root(&global);

      if(sm_interface(SM_IMAGE_SAVE, 1, argument) == ERROR)
	switch(errno)
	  {
	  case EIMPL:
	    exit(EIMPL);
	    error("Function save not implemented");

	  case EIMAGEWRITE:
	    exit(EIMAGEWRITE);
	    error("Error writing opened image file");

	  case EIMAGEOPEN:
	    exit(EIMAGEOPEN);
	    error("Unable to open image file");

	  default:
	    exit(errno ? errno : -1);
	    error("Unexpected error from exportFn");
	  }

      exit(0);
    } else {
      /* The parent process */
      DIAGNOSTIC(4, "Setting signal_export_child_pid to %d", child_pid, 0);
      signal_export_child_pid = child_pid;
      /* Now wait for the child to complete, and get its return status */
      /* Busy wait, is there a better way to do this? */
      while (check_export_child_status() == 0);
      signal_export_unwatch_child();
      switch (read_export_child_status()) {
      case 0:
	break;
d190 1
a190 1
	exn_raise_string(perv_exn_ref_save, "Function save not implemented");
d193 1
a193 1
	exn_raise_string(perv_exn_ref_save, "Error writing opened image file");
d196 1
a196 1
	exn_raise_string(perv_exn_ref_save, "Unable to open image file");
d199 1
a199 3
	exn_raise_string(perv_exn_ref_save, "Unexpected error from exportFn");
      }
      return MLUNIT; /* Should later change to return to MLWorks */
d201 12
a212 2
  }
#endif
d360 1
@


1.12
log
@Work on using fork for exportFn
@
text
@d8 3
d306 4
a309 2
    for(i=module_argc-1; i >= 0; --i)
      result = cons(ml_string(module_argv[i]), result);
@


1.11
log
@Remove extra garbage collections during exportFn
@
text
@d8 3
d107 2
d157 8
a164 1
  mlval global, filename;
d166 10
a175 3
  filename = FIELD(argument, 0);
  image_continuation = FIELD(argument, 1); /* This is a global, and hence a root */
  declare_root(&filename);
d177 65
a241 23
  global = global_pack();
  declare_root(&global);

  {
    mlval old_message_level = MLSUB(gc_message_level,0);
    /* Some work here to avoid collecting the stack, dump the module table etc. */
    clear_handlers();
    clear_thread_roots();
    MLUPDATE(modules, 0, MLNIL); /* Clear the module table */
    MLUPDATE(gc_message_level,0,MLINT(-1));
    (void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* Don't scan the stack during gc */
    MLUPDATE(gc_message_level,0,old_message_level);
  }

  argument = allocate_record(2);
  FIELD(argument, 0) = filename;
  FIELD(argument, 1) = global;
  retract_root(&filename);
  retract_root(&global);

  if(sm_interface(SM_IMAGE_SAVE, 1, argument) == ERROR)
    switch(errno)
    {
d243 1
a243 1
      error("Function save not implemented");
d246 1
a246 1
      error("Error writing opened image file");
d249 1
a249 1
      error("Unable to open image file");
d252 3
a254 1
      error("Unexpected error from exportFn");
d256 2
a257 4

  argument = image_continuation;
  image_continuation = MLUNIT;
  exit(0);
@


1.10
log
@Add ml_save_function for use by exportFn
@
text
@d8 3
a167 3
    (void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* Don't scan the stack during gc */
    (void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* Don't scan the stack during gc */
    (void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* Don't scan the stack during gc */
@


1.9
log
@Move profiler interface to profiler.c
@
text
@d8 3
d99 2
d116 1
a116 1
    (void) sm_interface(SM_COLLECT_ALL,MLUNIT);
d126 1
a126 1
  if(sm_interface(SM_IMAGE_SAVE, argument) == ERROR)
d147 52
d201 1
a201 1
  argument = sm_interface(SM_IMAGE_TABLE, argument);
d343 1
@


1.8
log
@Change call to internal_load_link not be verbose
@
text
@d8 3
a164 113
/* A selector function for ML profiling; ML provides a list of
strings, which we put into profile_selector, and code vectors are
selected iff a substring of their name is on this list */

static mlval profile_selector;
static int profile_select(mlval code)
{
  char *name = CSTRING(CCODENAME(code));
  mlval list;

  if(profile_selector == MLNIL)
    return(1);

  for(list=profile_selector; list!=MLNIL; list=MLTAIL(list))
    if(strstr(name, CSTRING(MLHEAD(list))))
      return(1);

  return(0);
}

/*
 * ML profiling.
 *
 * Called by MLWorks.Profile.profile, q.v.
 * It passes a triple
 *
 * - options 	: {depth : int, scan : int, select : string list}
 * - write 	: string -> unit
 * - wrapper    : unit -> 'a
 *
 * Inside the profile, wrapper is applied to unit. (wrapper is so
 * constructed - in the definition of MLWorks.Profile.profile - as to
 * encapsulate exceptions in the result, not allowing them to escape).
 * After profiling, the result of this application is returned.
 *
 * If we are already profiling, a warning is output and no additional
 * profiling is done.
 */

static mlval ml_profile(mlval argument)
{
  struct profile_options options;
  mlval result, profiled_function, profiled_output;

  profiled_output = FIELD(argument,1);
  profiled_function = FIELD(argument,2);
  declare_root (&profiled_function);

  if (!profile_on) {
    /* we're not already profiling: */

    /* set up the profile options */
    options.interval = CINT(FIELD(FIELD(argument, 0), 1));
    options.depth = CINT(FIELD(FIELD(argument, 0), 0));
    options.printer_type = PROFILE_OPT_ML;
    options.print.ml = profiled_output;

    /* use the ML profile selector (defined above) */
    profile_selector = FIELD(FIELD(argument, 0), 2);
    options.select = profile_select;

    declare_root (&options.print.ml);
    declare_root (&profile_selector);

    /* start the profiler */
    if(profile_begin(&options)) {       /* error starting the profiler */
      retract_root (&profile_selector);
      retract_root (&options.print.ml);
      retract_root (&profiled_function);
      switch(errno) {
        case EPROFILEDEPTH:
	  exn_raise_string(perv_exn_ref_profile,
			   "Cannot profile to that depth.");
	  /* EPROFILENEST is unexpected here, so comes under 'default' */
        default:
	  exn_raise_string(perv_exn_ref_profile,
			   "Unexpected error from profile_begin()");
	}
    }

    /* call the profiled function */
    result = callml(MLUNIT, profiled_function);
    declare_root (&result);

    /* stop the profiler */
    if(profile_end()) {		/* error stopping the profiler */
      retract_root (&profile_selector);
      retract_root (&options.print.ml);
      retract_root (&profiled_function);
      retract_root (&result);
      exn_raise_string(perv_exn_ref_profile,
		       "Unexpected error from profile_end()");
    }

    retract_root (&profile_selector);
    retract_root (&options.print.ml);
    retract_root(&result);
  } else {
    /* we're already profiling */
    /* print a warning */
    mlval s;
    declare_root (&profiled_output);
    s = ml_string ("Profile report over-ridden by enclosing profile.\n");
    (void) callml(s, profiled_output);
    retract_root (&profiled_output);
    /* call the function */
    result = callml(MLUNIT, profiled_function);
  }

  retract_root (&profiled_function);
  return(result);
}

a285 1
  env_function("profile", ml_profile);
@


1.7
log
@Make error strings consistent by removing full stops.
Add file names to error messages where files are mentioned
@
text
@d8 4
d353 1
a353 1
  mlval result = internal_load_link(filename,&mod_name,1,1,0);
@


1.6
log
@Change time.h to mltime.h
@
text
@d8 3
d355 1
a355 1
	exn_raise_string (perv_exn_ref_load,"The loader was unable to read from the file");
d357 1
a357 1
	exn_raise_string (perv_exn_ref_load,"The loader was unable to open the file");
d361 1
a361 1
	exn_raise_string (perv_exn_ref_load,"The file contains a module of a version the loader does not understand.");
d363 1
a363 1
	exn_raise_string (perv_exn_ref_load,"The file is not in the correct loader format.");
d365 1
a365 1
	exn_raise_string (perv_exn_ref_load,"The module in the file references an unloaded external module");
@


1.5
log
@filename needs to be a root in ml_image_save
@
text
@d8 3
d77 1
a77 1
#include "time.h"
@


1.4
log
@Declare profiler result as a root.
@
text
@d8 3
d88 1
d90 1
a93 2
  filename = FIELD(argument, 0);
  declare_root(&filename);
@


1.4.1.1
log
@branched from 1.4
@
text
@a7 3
 * Revision 1.4  1994/06/24  10:50:38  nickh
 * Declare profiler result as a root.
 *
@


1.3
log
@New ancillary structure and forced GC on image save.
@
text
@d8 3
a194 1
  declare_root (&profiled_output);
a199 3
    declare_root (&options.print.ml);
    declare_root (&profile_selector);

d204 1
a204 1
    options.print.ml = FIELD(argument,1);
d210 3
a216 1
      retract_root (&profiled_output);
d231 1
a234 2
      retract_root (&profiled_output);
      retract_root (&profiled_function);
d237 2
d245 1
d249 3
a251 1
    mlval s = ml_string ("Profile report over-ridden by enclosing profile.\n");
d253 1
a257 1
  retract_root (&profiled_output);
@


1.2
log
@new file
@
text
@d8 3
d75 2
d88 8
d286 7
a292 5
  CCODEANCUPDATE(code, NAMES, MLUNIT);
  CCODEANCUPDATE(code, LEAFS, MLUNIT);
  CCODEANCUPDATE(code, PROFILES, MLUNIT);
  CCODEANCUPDATE(code, INTERCEPTS, MLUNIT);
  CCODEANCUPDATE(code, INTERFNS, MLUNIT);
@


1.1
log
@new file
@
text
@d7 4
a10 1
 *  $Log: system.c,v $
@
