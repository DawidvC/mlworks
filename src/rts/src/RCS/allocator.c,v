head	1.16;
access;
symbols
	MLW_daveb_inline_1_4_99:1.16.1
	MLWorks_21c0_1999_03_25:1.16
	MLWorks_20c1_1998_08_20:1.15
	MLWorks_20c0_1998_08_04:1.15
	MLWorks_20b2c2_1998_06_19:1.15
	MLWorks_20b2_Windows_1998_06_12:1.15
	MLWorks_20b1c1_1998_05_07:1.15
	MLWorks_20b0_1998_04_07:1.14
	MLWorks_20b0_1998_03_20:1.14
	MLWorks_20m2_1998_02_16:1.14
	MLWorks_MM_adapt:1.14.1
	MLWorks_20m1_1997_10_23:1.14
	MLWorks_11r1:1.11.1.1.1.1.1
	MLWorks_workspace_97:1.12.2
	MLWorks_dt_wizard:1.12.1
	MLWorks_11c0_1997_09_09:1.11.1.1.1.1
	MLWorks_10r3:1.11.1.1.3
	MLWorks_10r2_551:1.11.1.1.2
	MLWorks_11:1.11.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.11.1.1
	MLWorks_20m0_1997_06_20:1.11
	MLWorks_1_0_r2c2_1997_06_14:1.11.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.11.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.11.1
	MLWorks_BugFix_1997_04_24:1.11
	MLWorks_1_0_r2_Win32_1997_04_11:1.11
	MLWorks_1_0_r2_Unix_1997_04_04:1.11
	MM_ML_release_korma_1997_04_01:1.11
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.10.7.1.1
	MLWorks_gui_1996_12_18:1.10.8
	MLWorks_1_0_Win32_1996_12_17:1.10.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.10.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.10.4.1
	JFHrts:1.10.6
	MLWorks_1_0_Irix_1996_11_28:1.10.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.10.5
	MLWorks_1_0_Unix_1996_11_14:1.10.4
	MLWorks_Open_Beta2_1996_10_11:1.10.3
	MLWorks_License_dev:1.10.2
	MLWorks_1_open_beta_1996_09_13:1.10.1
	MLWorks_Open_Beta_1996_08_22:1.10
	MLWorks_Beta_1996_07_02:1.10
	MLWorks_Beta_1996_06_07:1.10
	MLWorks_Beta_1996_06_06:1.10
	MLWorks_Beta_1996_06_05:1.10
	MLWorks_Beta_1996_06_03:1.10
	MLWorks_Beta_1996_05_31:1.10
	MLWorks_Beta_1996_05_30:1.10
	hope_poo:1.3.1
	ML_beta_release_12/08/94:1.3.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.16
date	98.07.29.13.12.02;	author jont;	state Exp;
branches
	1.16.1.1;
next	1.15;

1.15
date	98.04.23.13.23.43;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	97.10.21.12.42.51;	author daveb;	state Exp;
branches
	1.14.1.1;
next	1.13;

1.13
date	97.10.14.12.22.20;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	97.08.19.15.13.51;	author nickb;	state Exp;
branches
	1.12.1.1
	1.12.2.1;
next	1.11;

1.11
date	96.12.19.10.05.16;	author stephenb;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	96.02.13.16.05.25;	author jont;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1
	1.10.4.1
	1.10.5.1
	1.10.6.1
	1.10.7.1
	1.10.8.1;
next	1.9;

1.9
date	95.09.09.14.56.28;	author brianm;	state Exp;
branches;
next	1.8;

1.8
date	95.09.09.00.51.32;	author brianm;	state Exp;
branches;
next	1.7;

1.7
date	95.08.08.09.56.56;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.04.03.11.20.12;	author brianm;	state Exp;
branches;
next	1.5;

1.5
date	95.03.01.16.15.50;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	94.09.21.12.24.02;	author brianm;	state Exp;
branches;
next	1.3;

1.3
date	94.08.11.11.19.02;	author matthew;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	94.06.09.14.32.08;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.10.57.02;	author nickh;	state Exp;
branches;
next	;

1.3.1.1
date	95.07.05.10.31.35;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	96.09.13.11.25.20;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.10.07.16.15.44;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.10.17.11.35.09;	author hope;	state Exp;
branches;
next	;

1.10.4.1
date	96.11.14.13.00.48;	author hope;	state Exp;
branches
	1.10.4.1.1.1;
next	;

1.10.4.1.1.1
date	96.11.28.15.10.51;	author hope;	state Exp;
branches;
next	;

1.10.5.1
date	96.11.22.18.18.38;	author hope;	state Exp;
branches;
next	;

1.10.6.1
date	96.12.17.10.05.22;	author hope;	state Exp;
branches;
next	;

1.10.7.1
date	96.12.17.17.56.55;	author hope;	state Exp;
branches
	1.10.7.1.1.1;
next	;

1.10.7.1.1.1
date	97.02.24.11.48.36;	author hope;	state Exp;
branches;
next	;

1.10.8.1
date	96.12.18.09.51.36;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	97.05.12.10.45.18;	author hope;	state Exp;
branches
	1.11.1.1.1.1
	1.11.1.1.2.1
	1.11.1.1.3.1;
next	;

1.11.1.1.1.1
date	97.07.28.18.27.27;	author daveb;	state Exp;
branches
	1.11.1.1.1.1.1.1;
next	;

1.11.1.1.1.1.1.1
date	97.10.07.11.53.27;	author jkbrook;	state Exp;
branches;
next	1.11.1.1.1.1.1.2;

1.11.1.1.1.1.1.2
date	97.10.07.14.22.13;	author jkbrook;	state Exp;
branches;
next	;

1.11.1.1.2.1
date	97.09.08.17.20.31;	author daveb;	state Exp;
branches;
next	1.11.1.1.2.2;

1.11.1.1.2.2
date	97.09.09.10.16.02;	author daveb;	state Exp;
branches;
next	;

1.11.1.1.3.1
date	97.09.09.14.16.38;	author daveb;	state Exp;
branches;
next	1.11.1.1.3.2;

1.11.1.1.3.2
date	97.09.22.15.42.40;	author jkbrook;	state Exp;
branches;
next	;

1.12.1.1
date	97.09.10.19.34.36;	author brucem;	state Exp;
branches;
next	;

1.12.2.1
date	97.09.11.21.03.33;	author daveb;	state Exp;
branches;
next	;

1.14.1.1
date	97.10.31.13.46.27;	author nickb;	state Exp;
branches;
next	;

1.16.1.1
date	99.04.01.18.02.35;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.16
log
@[Bug #20133]
Modify to use GC_HEAP_REAL_LIMIT
@
text
@/*  ==== ML VALUE HEAP ALLOCATION ====
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  The allocation functions attempt to allocate space by simply
 *  incrementing the value of ml_state.heap_start, just as an ML program
 *  would.  If this takes the heap_start over the heap_limit the garbage
 *  collector is called.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:allocator.c,v $
 * Revision 1.15  1998/04/23  13:23:43  jont
 * [Bug #70034]
 * Rationalising names in mem.h
 *
 * Revision 1.14  1997/10/21  12:42:51  daveb
 * [Bug #30259]
 * Merging from MLWorks_10r3:
 * ALLOCATE_STATIC has to multiply its parameter by sizeof(mlval).
 *
 * Revision 1.13  1997/10/14  12:22:20  jont
 * [Bug #70014]
 * Fix bad parameter to ALLOCATOR_INITIALIZE under debugging runtime
 *
 * Revision 1.12  1997/08/19  15:13:51  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
 * Revision 1.11  1996/12/19  10:05:16  stephenb
 * [Bug #1791]
 * ALLOCATE+ALLOCATE_STATIC: wrap the macro bodies in do { ... } while (0)
 * to avoid binding problems.
 *
 * Revision 1.10  1996/02/13  16:05:25  jont
 * Add a type cast to remove compilation warnings from Visual C
 *
 * Revision 1.9  1995/09/09  14:56:28  brianm
 * Reversion to version 1.7.
 *
 * Revision 1.8  1995/09/09  00:51:32  brianm
 * Word32 string repn. needs an extra byte to allow correct bit-wise access.
 *
 * Revision 1.7  1995/08/08  09:56:56  matthew
 * Changing representation of word32's to strings
 *
 * Revision 1.6  1995/04/03  11:20:12  brianm
 * Adding allocate_word32.
 *
 * Revision 1.5  1995/03/01  16:15:50  nickb
 * Add static object allocation.
 *
 * Revision 1.4  1994/09/21  12:24:02  brianm
 * Since X call can return NULL for a null string (a touch naughty), so
 * added check to ml_string for NULL pointer case.
 *
 * Revision 1.3  1994/08/11  11:19:02  matthew
 * Adding allocate_vector
 *
 * Revision 1.2  1994/06/09  14:32:08  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:57:02  nickh
 * new file
 *
 *  Revision 1.25  1994/01/28  17:22:10  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.24  1993/03/23  15:20:57  jont
 *  Changed allocation of bytearrays to be ref tagged
 *
 *  Revision 1.23  1992/09/08  14:30:47  richard
 *  Added `allocate_multiple'.
 *
 *  Revision 1.22  1992/08/24  14:41:09  richard
 *  Added allocate_bytearray.
 *
 *  Revision 1.21  1992/08/24  08:05:14  richard
 *  Added allocate_bytearray.
 *
 *  Revision 1.20  1992/08/05  17:18:54  richard
 *  Added allocate_code().
 *
 *  Revision 1.19  1992/07/30  11:19:17  richard
 *  Added static_string.  Corrected use of MLPTR().
 *
 *  Revision 1.18  1992/07/23  11:22:45  richard
 *  `ml_string' now takes a const char *.
 *
 *  Revision 1.17  1992/07/14  08:20:13  richard
 *  Added allocate_array() and allocate_weak_array().
 *
 *  Revision 1.16  1992/06/30  16:16:26  richard
 *  Reworked to use declarations in storeman.h.
 *
 *  Revision 1.15  1992/03/11  14:25:25  richard
 *  Tidied up and increased level of diagnostic messages.
 *
 *  Revision 1.14  1992/03/05  09:20:30  richard
 *  Caused allocate_record to zero out the padding word in the case of
 *  an unaligned record length.
 *
 *  Revision 1.13  1992/02/26  11:46:23  richard
 *  Corrected calls to the gc() to pass sizes in bytes, not words.
 *
 *  Revision 1.12  1992/01/08  16:55:34  richard
 *  Sorted out the malformatted diagnostics.
 *
 *  Revision 1.11  1991/12/20  16:59:20  richard
 *  Reworked allocate_record() and changed diagnostic output
 *  to use DIAGNOSTIC so that it can be switched on and off.
 *
 *  Revision 1.10  91/12/17  16:55:32  nickh
 *  oops.
 *
 *  Revision 1.9  91/12/17  16:02:29  nickh
 *  rewrote to remove bugs, but return to gc-calling style. Note that declaring
 *  and retracting roots is now in gc.c
 *
 *  Revision 1.5  91/11/11  18:00:23  jont
 *  Added allocate_real
 *
 *  Revision 1.4  91/10/29  14:54:12  davidt
 *  Changed allocation routines to call the garbage collector if they
 *  run out of free space. They should now behave exactly as a ML
 *  program behaves when allocating stuuf on the heap.
 *
 *  Revision 1.3  91/10/23  15:40:44  davidt
 *  Now uses ml_state.heap_start and ml_state.heap_limit to allocate
 *  on the ML heap.
 *
 *  Revision 1.2  91/10/21  09:20:02  davidt
 *  Changed the types of declare_root and retract_root so that the
 *  garbage collector is free to move the root objects (updating
 *  their new values using the address provided).
 *
 *  Revision 1.1  91/10/18  16:13:23  davidt
 *  Initial revision
 */


#include "allocator.h"
#include "diagnostic.h"
#include "state.h"
#include "utils.h"
#include "values.h"
#include "gc.h"

#include <string.h>
#include <stddef.h>
#include <assert.h>

#define ALLOCATE(p, words)                      \
do { 						\
  size_t w = ((words)+1u) & ~1u;		\
						\
  p = GC_HEAP_START;				\
  GC_HEAP_START += w;				\
  if(GC_HEAP_START >= GC_HEAP_REAL_LIMIT)		\
  {						\
    gc(w * sizeof(mlval), MLUNIT);		\
    p = GC_RETURN;				\
  }						\
} while (0)

#define ALLOCATE_STATIC(p, words)               \
do { 						\
  size_t w = ((words)+1u) & ~1u;		\
						\
  struct ml_static_object *result = make_static_object(w * sizeof(mlval)); \
  result->forward = &creation->statics;		\
  result->back = creation->statics.back;	\
  result->forward->back = result;		\
  result->back->forward = result;		\
   p = &result->object[0];			\
} while (0)

#ifdef DEBUG

/* A macro to preinitialise memory for improved debugging */
#define ALLOCATOR_INITIALIZE(ptr, words)        \
do {                                            \
  mlval *p = (ptr);                             \
  size_t w = (size_t)(words);                   \
  while(w --)                                   \
    *p++ = DEAD;                                \
} while (0)

#else

#define ALLOCATOR_INITIALIZE(ptr, words) do { } while(0)

#endif

/*  == Allocate a record ==
 *
 *  Records of size 2 are headerless, and are aligned differently to others.
 *  (See primary tags in values.h for details.)
 */

mlval allocate_record(size_t nr_fields)
{
  mlval *record;

  if(nr_fields == 2)
  {
    ALLOCATE(record, 2);

    DIAGNOSTIC(5, "Allocate pair  : New ml_heap 0x%lx", GC_HEAP_START, 0);
    DIAGNOSTIC(5, "               : Tagged value 0x%lx", MLPTR(PAIRPTR, record), 0);
    ALLOCATOR_INITIALIZE(record, nr_fields);

    return(MLPTR(PAIRPTR, record));
  }
  else
  {
    ALLOCATE(record, nr_fields+1);

    record[0] = MAKEHEAD(RECORD, nr_fields);

    /* Make sure the extra word added for alignment purposes is scannable by */
    /* the garabge collector. */
    if(!(nr_fields & 1))
      record[nr_fields+1] = 0;

    DIAGNOSTIC(5, "Allocate record: Fields 0x%lx", nr_fields, 0);
    DIAGNOSTIC(5, "               : Header 0x%lx", MAKEHEAD(RECORD,nr_fields), 0);
    DIAGNOSTIC(5, "               : New ml_heap 0x%lx", GC_HEAP_START, 0);
    DIAGNOSTIC(5, "               : Tagged value 0x%lx", MLPTR(POINTER, record), 0);
    ALLOCATOR_INITIALIZE(record+1, nr_fields);

    return(MLPTR(POINTER, record));
  }
}


mlval allocate_vector(size_t nr_fields)
{
  mlval *vector;

  {
    ALLOCATE(vector, nr_fields+1);

    vector[0] = MAKEHEAD(RECORD, nr_fields);

    /* Make sure the extra word added for alignment purposes is scannable by */
    /* the garabge collector. */
    if(!(nr_fields & 1))
      vector[nr_fields+1] = 0;

    DIAGNOSTIC(5, "Allocate vector: Fields 0x%lx", nr_fields, 0);
    DIAGNOSTIC(5, "               : Header 0x%lx", MAKEHEAD(RECORD,nr_fields), 0);
    DIAGNOSTIC(5, "               : New ml_heap 0x%lx", GC_HEAP_START, 0);
    DIAGNOSTIC(5, "               : Tagged value 0x%lx", MLPTR(POINTER, vector), 0);
    ALLOCATOR_INITIALIZE(vector+1, nr_fields);

    return(MLPTR(POINTER, vector));
  }
}


/*  == Allocate a string ==  */

mlval allocate_string(size_t length)
{
  mlval *string;

  ALLOCATE(string, WLENGTH(length)+1);

  string[0] = MAKEHEAD(STRING,length);

  DIAGNOSTIC(5, "Allocate string: Size in bytes 0x%lx", length, 0);
  DIAGNOSTIC(5, "               : Wrote header 0x%lx", MAKEHEAD(STRING,length), 0);
  DIAGNOSTIC(5, "               : New ml_heap 0x%lx", GC_HEAP_START, 0);
  DIAGNOSTIC(5, "               : Tagged pointer 0x%lx", MLPTR(POINTER, string), 0);

  return(MLPTR(POINTER, string));
}

mlval allocate_bytearray(size_t length)
{
  mlval *bytearray;

  ALLOCATE(bytearray, WLENGTH(length)+1);

  bytearray[0] = MAKEHEAD(BYTEARRAY, length);

  DIAGNOSTIC(5, "Allocate bytearray: Size in bytes 0x%lx", length, 0);
  DIAGNOSTIC(5, "                  : Wrote header 0x%lx", MAKEHEAD(BYTEARRAY,length), 0);
  DIAGNOSTIC(5, "                  : New ml_heap 0x%lx", GC_HEAP_START, 0);
  DIAGNOSTIC(5, "                  : Tagged pointer 0x%lx", MLPTR(POINTER, bytearray), 0);

  return(MLPTR(REFPTR, bytearray));
}


/*  == Allocate a code vector ==  */

mlval allocate_code(size_t length)
{
  mlval *code;

  ALLOCATE(code, length+1);

  code[0] = MAKEHEAD(CODE, length);

  if(!(length & 1))
    code[length+1] = 0;

  DIAGNOSTIC(5, "Allocate code: Size in words 0x%X", length, 0);
  DIAGNOSTIC(5, "             : Header 0x%X", MAKEHEAD(CODE, length), 0);
  DIAGNOSTIC(5, "             : New ml_heap 0x%X", GC_HEAP_START, 0);
  DIAGNOSTIC(5, "             : Tagged pointer 0x%X", MLPTR(POINTER, code), 0);

  /* initialize the ancillary ptr */
  ALLOCATOR_INITIALIZE(code+1, 1);

  return(MLPTR(POINTER, code));
}


/*  == Allocate an array ==  */

mlval allocate_array(size_t length)
{
  mlval *array;
  union ml_array_header *entry;

  ALLOCATE(array, length+3);
  entry = (union ml_array_header *)array;

  entry->the.header  = MAKEHEAD(ARRAY, length);
  entry->the.forward = (union ml_array_header *)MLINT(1);
  entry->the.back    = (union ml_array_header *)MLINT(0);

  if(!(length & 1))
    array[length+3] = 0;

  DIAGNOSTIC(5, "Allocate array: Length 0x%X", length, 0);
  DIAGNOSTIC(5, "              : Header 0x%X", array[0], 0);
  DIAGNOSTIC(5, "              : New heap 0x%X", GC_HEAP_START, 0);
  DIAGNOSTIC(5, "              : Tagged value 0x%X", MLPTR(REFPTR, array), 0);

  ALLOCATOR_INITIALIZE(array+3, length);

  return(MLPTR(REFPTR, array));
}


/*  == Allocate a weak array ==
 *
 *  The weak array is placed on the modified list so that the garbage
 *  collector can find it.
 */

mlval allocate_weak_array(size_t length)
{
  mlval *array;
  union ml_array_header *entry;

  ALLOCATE(array, length+3);
  entry = (union ml_array_header *)array;
  entry->the.header  = MAKEHEAD(WEAKARRAY, length);
  entry->the.forward = 0;
  entry->the.back    = GC_MODIFIED_LIST;
  GC_MODIFIED_LIST = entry;;
  
  if(!(length & 1))
    array[length+3] = 0;

  DIAGNOSTIC(5, "Allocate weak array: Length 0x%X", length, 0);
  DIAGNOSTIC(5, "                   : Header 0x%X", array[0], 0);
  DIAGNOSTIC(5, "                   : New heap 0x%X", GC_HEAP_START, 0);
  DIAGNOSTIC(5, "                   : Tagged value 0x%X", MLPTR(REFPTR, array), 0);

  ALLOCATOR_INITIALIZE(array+3, length);

  return(MLPTR(REFPTR, array));
}


/*  == Allocate a real ==
 *
 *  Only double-sized reals are supported at present.
 *  An extra word of padding is inserted before the double itself to ensure
 *  that it is double-aligned.
 */

mlval allocate_real(void)
{
  mlval *bytearray;

  ALLOCATE(bytearray, 4);

  bytearray[0] = MAKEHEAD(BYTEARRAY, sizeof(double) + 4);

  DIAGNOSTIC(5, "Allocate real  : Wrote header 0x%lx", MAKEHEAD(BYTEARRAY,sizeof(double) + 4), 0);
  DIAGNOSTIC(5, "               : New ml_heap 0x%lx", GC_HEAP_START, 0);
  DIAGNOSTIC(5, "               : Tagged pointer 0x%lx", MLPTR(POINTER, bytearray), 0);

  return(MLPTR(POINTER, bytearray));
}

/*  === STATIC BYTEARRAYS === */

mlval allocate_static_bytearray(size_t length)
{
  mlval *bytearray;

  ALLOCATE_STATIC(bytearray,WLENGTH(length)+1);
  bytearray[0] = MAKEHEAD(BYTEARRAY,length);

  DIAGNOSTIC(5, "Allocate static bytearray: Size in bytes 0x%lx", length, 0);
  DIAGNOSTIC(5, "                         : Tagged pointer 0x%lx",
	     MLPTR(POINTER, bytearray), 0);

 return(MLPTR(REFPTR, bytearray));
}


/*  == Allocate a Word32 ==
 *
 *  Word32 objects are strings of (real) length 4.
 *
 */
mlval allocate_word32(void)
{
   return(allocate_string(4));
}


/*  === EMPTY C STRING === */

const char *null_cstring = "";



/*  === MAKE ML STRING FROM C STRING ===  */

mlval ml_string (const char *cstring)
{
  mlval mlstring;

  if (NULL == cstring) { cstring = null_cstring ;};
                       /* e.g. X can return NULL */

  mlstring = allocate_string(strlen(cstring) + 1);
  strcpy(CSTRING(mlstring), cstring);
  return(mlstring);
}


/*  === ALLOCATE MULTIPLE OBJECTS ===  */

size_t allocate_multiple(size_t size, size_t number, mlval **start)
{
  signed long available = (GC_HEAP_REAL_LIMIT - GC_HEAP_START)/size;

  assert(available >= 0);

  available = available > (signed long)number ? number : available;
  *start = GC_HEAP_START;
  GC_HEAP_START = GC_HEAP_START + available * size;
  ALLOCATOR_INITIALIZE(*start, available * size);
  return(available);
}
@


1.16.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a14 4
 * Revision 1.16  1998/07/29  13:12:02  jont
 * [Bug #20133]
 * Modify to use GC_HEAP_REAL_LIMIT
 *
@


1.15
log
@[Bug #70034]
Rationalising names in mem.h
@
text
@d15 4
d161 1
a161 1
  if(GC_HEAP_START >= GC_HEAP_LIMIT)		\
d459 1
a459 1
  signed long available = (GC_HEAP_LIMIT - GC_HEAP_START)/size;
@


1.14
log
@[Bug #30259]
Merging from MLWorks_10r3:
ALLOCATE_STATIC has to multiply its parameter by sizeof(mlval).
@
text
@d15 5
d168 1
a168 1
  struct static_object *result = make_static_object(w * sizeof(mlval)); \
@


1.14.1.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a14 5
 * Revision 1.14  1997/10/21  12:42:51  daveb
 * [Bug #30259]
 * Merging from MLWorks_10r3:
 * ALLOCATE_STATIC has to multiply its parameter by sizeof(mlval).
 *
@


1.13
log
@[Bug #70014]
Fix bad parameter to ALLOCATOR_INITIALIZE under debugging runtime
@
text
@d15 4
d148 1
a148 1
  size_t w = (words+1u) & ~1u;			\
d161 1
a161 1
  size_t w = (words+1u) & ~1u;			\
d163 1
a163 1
  struct static_object *result = make_static_object(w); \
@


1.12
log
@[Bug #30250]
Bugs in use of allocate_record and allocate_array: add debug-filling code.
@
text
@d15 4
d169 1
d453 1
a453 1
  ALLOCATOR_INITIALIZE(start, available * size);
@


1.12.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a14 4
 * Revision 1.12  1997/08/19  15:13:51  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.12.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a14 4
 * Revision 1.12  1997/08/19  15:13:51  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.11
log
@[Bug #1791]
ALLOCATE+ALLOCATE_STATIC: wrap the macro bodies in do { ... } while (0)
to avoid binding problems.
@
text
@d15 5
d163 16
d195 1
d214 1
d239 1
d299 3
d328 2
d360 2
d448 1
@


1.11.1.1
log
@branched from 1.11
@
text
@a14 5
 * Revision 1.11  1996/12/19  10:05:16  stephenb
 * [Bug #1791]
 * ALLOCATE+ALLOCATE_STATIC: wrap the macro bodies in do { ... } while (0)
 * to avoid binding problems.
 *
@


1.11.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a14 3
 * Revision 1.11.1.1  1997/05/12  10:45:18  hope
 * branched from 1.11
 *
@


1.11.1.1.3.2
log
@[Bug #30259]
Merging from 1.0r2#551 into 1.0r3
ALLOCATE_STATIC has to multiply its parameter by sizeof(mlval).
@
text
@a14 3
 * Revision 1.11.1.1.3.1  1997/09/09  14:16:38  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
d143 1
a143 1
  size_t w = ((words)+1u) & ~1u;		\
d156 1
a156 1
  size_t w = ((words)+1u) & ~1u;		\
d158 1
a158 1
  struct static_object *result = make_static_object(w * sizeof(mlval)); \
@


1.11.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a14 3
 * Revision 1.11.1.1  1997/05/12  10:45:18  hope
 * branched from 1.11
 *
@


1.11.1.1.2.2
log
@[Bug #30259]
ALLOCATE_STATIC has to multiply its parameter by sizeof(mlval).
@
text
@a14 3
 * Revision 1.11.1.1.2.1  1997/09/08  17:20:31  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
 *
d143 1
a143 1
  size_t w = ((words)+1u) & ~1u;		\
d156 1
a156 1
  size_t w = ((words)+1u) & ~1u;		\
d158 1
a158 1
  struct static_object *result = make_static_object(w * sizeof(mlval)); \
@


1.11.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a14 3
 * Revision 1.11.1.1  1997/05/12  10:45:18  hope
 * branched from 1.11
 *
@


1.11.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a14 3
 * Revision 1.11.1.1.1.1  1997/07/28  18:27:27  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.11.1.1.1.1.1.2
log
@[Bug #30259]
Merging from MLWorks_10r3:
ALLOCATE_STATIC has to multiply its parameter by sizeof(mlval)
@
text
@a14 3
 * Revision 1.11.1.1.1.1.1.1  1997/10/07  11:53:27  jkbrook
 * branched from MLWorks_11 for label MLWorks_11r1
 *
d146 1
a146 1
  size_t w = ((words)+1u) & ~1u;		\
d159 1
a159 1
  size_t w = ((words)+1u) & ~1u;		\
d161 1
a161 1
  struct static_object *result = make_static_object(w * sizeof(mlval)); \
@


1.10
log
@Add a type cast to remove compilation warnings from Visual C
@
text
@d15 3
d133 2
a134 2
#define ALLOCATE(p, words) \
{ 						\
d144 1
a144 1
}
d146 2
a147 2
#define ALLOCATE_STATIC(p, words) \
{ 						\
d156 1
a156 1
}
@


1.10.8.1
log
@branched from 1.10
@
text
@a14 3
 * Revision 1.10  1996/02/13  16:05:25  jont
 * Add a type cast to remove compilation warnings from Visual C
 *
@


1.10.7.1
log
@branched from 1.10
@
text
@a14 3
 * Revision 1.10  1996/02/13  16:05:25  jont
 * Add a type cast to remove compilation warnings from Visual C
 *
@


1.10.7.1.1.1
log
@branched from 1.10.7.1
@
text
@a14 3
 * Revision 1.10.7.1  1996/12/17  17:56:55  hope
 * branched from 1.10
 *
@


1.10.6.1
log
@branched from 1.10
@
text
@a14 3
 * Revision 1.10  1996/02/13  16:05:25  jont
 * Add a type cast to remove compilation warnings from Visual C
 *
@


1.10.5.1
log
@branched from 1.10
@
text
@a14 3
 * Revision 1.10  1996/02/13  16:05:25  jont
 * Add a type cast to remove compilation warnings from Visual C
 *
@


1.10.4.1
log
@branched from 1.10
@
text
@a14 3
 * Revision 1.10  1996/02/13  16:05:25  jont
 * Add a type cast to remove compilation warnings from Visual C
 *
@


1.10.4.1.1.1
log
@branched from 1.10.4.1
@
text
@a14 3
 * Revision 1.10.4.1  1996/11/14  13:00:48  hope
 * branched from 1.10
 *
@


1.10.3.1
log
@branched from 1.10
@
text
@a14 3
 * Revision 1.10  1996/02/13  16:05:25  jont
 * Add a type cast to remove compilation warnings from Visual C
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a14 3
 * Revision 1.10  1996/02/13  16:05:25  jont
 * Add a type cast to remove compilation warnings from Visual C
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a14 3
 * Revision 1.10  1996/02/13  16:05:25  jont
 * Add a type cast to remove compilation warnings from Visual C
 *
@


1.9
log
@Reversion to version 1.7.
@
text
@d15 3
d411 1
a411 1
  available = available > number ? number : available;
@


1.8
log
@Word32 string repn. needs an extra byte to allow correct bit-wise access.
@
text
@d15 3
d370 2
a371 1
 *  Word32 objects are strings of length 4 - extra byte is required.
d375 1
a375 1
   return(allocate_string(5));
@


1.7
log
@Changing representation of word32's to strings
@
text
@d15 3
d367 1
a367 1
 *  Word32 objects are strings of length 4.
d371 1
a371 1
   return(allocate_string(4));
@


1.6
log
@Adding allocate_word32.
@
text
@d15 3
d364 1
a364 1
 *  Word32 objects are bytearrays of length 4.
d368 1
a368 1
   return(allocate_bytearray(4));
@


1.5
log
@Add static object allocation.
@
text
@d15 3
d19 2
a20 2
 * Since X call can return NULL for a null string (a touch naughty), added check to
 * ml_string for NULL pointer case.
d358 9
@


1.4
log
@Since X call can return NULL for a null string (a touch naughty), added check to
ml_string for NULL pointer case.
@
text
@d15 4
d128 11
a260 19
/*  == Allocate a static string ==  */

mlval static_string(size_t length)
{
  mlval *string;

  string = alloc(sizeof(mlval) + length,
		 "Unable to allocate static string of length %u", length);

  string[0] = MAKEHEAD(STRING, length);

  DIAGNOSTIC(5, "Static string: Size in bytes 0x%lx", length, 0);
  DIAGNOSTIC(5, "             : Wrote header 0x%lx", MAKEHEAD(STRING,length), 0);
  DIAGNOSTIC(5, "             : Tagged pointer 0x%lx", MLPTR(POINTER, string), 0);

  return(MLPTR(POINTER, string));
}


d337 16
@


1.3
log
@Adding allocate_vector
@
text
@d15 3
d345 6
d355 6
a360 1
  mlval mlstring = allocate_string(strlen(cstring) + 1);
@


1.3.1.1
log
@branched from 1.3
@
text
@a14 3
 * Revision 1.3  1994/08/11  11:19:02  matthew
 * Adding allocate_vector
 *
@


1.2
log
@new file
@
text
@d15 3
d158 24
@


1.1
log
@new file
@
text
@d14 4
a17 1
 *  $Log: allocator.c,v $
@
