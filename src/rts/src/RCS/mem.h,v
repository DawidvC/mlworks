head	1.21;
access;
symbols
	MLW_daveb_inline_1_4_99:1.21.1
	MLWorks_21c0_1999_03_25:1.21
	MLWorks_20c1_1998_08_20:1.20
	MLWorks_20c0_1998_08_04:1.19
	MLWorks_20b2c2_1998_06_19:1.19
	MLWorks_20b2_Windows_1998_06_12:1.19
	MLWorks_20b1c1_1998_05_07:1.18
	MLWorks_20b0_1998_04_07:1.16
	MLWorks_20b0_1998_03_20:1.16
	MLWorks_20m2_1998_02_16:1.15
	MLWorks_MM_adapt:1.15.9
	MLWorks_20m1_1997_10_23:1.15
	MLWorks_11r1:1.15.6.1.1.1.1
	MLWorks_workspace_97:1.15.8
	MLWorks_dt_wizard:1.15.7
	MLWorks_11c0_1997_09_09:1.15.6.1.1.1
	MLWorks_10r3:1.15.6.1.3
	MLWorks_10r2_551:1.15.6.1.2
	MLWorks_11:1.15.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.15.6.1
	MLWorks_20m0_1997_06_20:1.15
	MLWorks_1_0_r2c2_1997_06_14:1.15.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.15.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.15.6
	MLWorks_BugFix_1997_04_24:1.15
	MLWorks_1_0_r2_Win32_1997_04_11:1.15
	MLWorks_1_0_r2_Unix_1997_04_04:1.15
	MM_ML_release_korma_1997_04_01:1.15
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.15.4.1.1
	MLWorks_gui_1996_12_18:1.15.5
	MLWorks_1_0_Win32_1996_12_17:1.15.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.15.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.15.1.1
	JFHrts:1.15.3
	MLWorks_1_0_Irix_1996_11_28:1.15.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.15.2
	MLWorks_1_0_Unix_1996_11_14:1.15.1
	MLWorks_Open_Beta2_1996_10_11:1.14.3
	MLWorks_License_dev:1.14.2
	MLWorks_1_open_beta_1996_09_13:1.14.1
	MLWorks_Open_Beta_1996_08_22:1.12
	MLWorks_Beta_1996_07_02:1.12
	MLWorks_Beta_1996_06_07:1.12
	MLWorks_Beta_1996_06_06:1.12
	MLWorks_Beta_1996_06_05:1.12
	MLWorks_Beta_1996_06_03:1.12
	MLWorks_Beta_1996_05_31:1.12
	MLWorks_Beta_1996_05_30:1.12
	hope_poo:1.2.1
	ML_beta_release_12/08/94:1.2.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.21
date	98.10.23.14.17.30;	author jont;	state Exp;
branches
	1.21.1.1;
next	1.20;

1.20
date	98.08.17.10.56.40;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	98.05.19.14.49.29;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	98.04.24.10.19.26;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	98.04.23.14.09.29;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	98.03.03.14.15.46;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	96.10.29.16.06.43;	author nickb;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1
	1.15.4.1
	1.15.5.1
	1.15.6.1
	1.15.7.1
	1.15.8.1
	1.15.9.1;
next	1.14;

1.14
date	96.08.28.11.36.27;	author nickb;	state Exp;
branches
	1.14.1.1
	1.14.2.1
	1.14.3.1;
next	1.13;

1.13
date	96.08.23.15.24.22;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	96.05.21.15.43.26;	author nickb;	state Exp;
branches;
next	1.11;

1.11
date	96.05.14.16.08.08;	author nickb;	state Exp;
branches;
next	1.10;

1.10
date	96.01.15.17.32.23;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	95.03.15.17.10.38;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.03.07.16.12.38;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.03.02.10.55.21;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.02.28.16.44.29;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	95.02.27.16.50.22;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	94.12.05.15.55.47;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.10.21.14.37.35;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.51.31;	author nickh;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	94.06.09.11.26.23;	author nickh;	state Exp;
branches;
next	;

1.2.1.1
date	95.07.05.10.29.23;	author hope;	state Exp;
branches;
next	;

1.14.1.1
date	96.09.13.11.23.38;	author hope;	state Exp;
branches;
next	;

1.14.2.1
date	96.10.07.16.13.50;	author hope;	state Exp;
branches;
next	;

1.14.3.1
date	96.10.17.11.33.16;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	96.11.14.12.59.00;	author hope;	state Exp;
branches
	1.15.1.1.1.1;
next	;

1.15.1.1.1.1
date	96.11.28.15.08.58;	author hope;	state Exp;
branches;
next	;

1.15.2.1
date	96.11.22.18.16.42;	author hope;	state Exp;
branches;
next	;

1.15.3.1
date	96.12.17.10.03.27;	author hope;	state Exp;
branches;
next	;

1.15.4.1
date	96.12.17.17.55.04;	author hope;	state Exp;
branches
	1.15.4.1.1.1;
next	;

1.15.4.1.1.1
date	97.02.24.11.46.12;	author hope;	state Exp;
branches;
next	;

1.15.5.1
date	96.12.18.09.49.39;	author hope;	state Exp;
branches;
next	;

1.15.6.1
date	97.05.12.10.42.05;	author hope;	state Exp;
branches
	1.15.6.1.1.1
	1.15.6.1.2.1
	1.15.6.1.3.1;
next	;

1.15.6.1.1.1
date	97.07.28.18.29.42;	author daveb;	state Exp;
branches
	1.15.6.1.1.1.1.1;
next	;

1.15.6.1.1.1.1.1
date	97.10.07.11.55.32;	author jkbrook;	state Exp;
branches;
next	;

1.15.6.1.2.1
date	97.09.08.17.22.41;	author daveb;	state Exp;
branches;
next	;

1.15.6.1.3.1
date	97.09.09.14.18.44;	author daveb;	state Exp;
branches;
next	;

1.15.7.1
date	97.09.10.19.38.17;	author brucem;	state Exp;
branches;
next	;

1.15.8.1
date	97.09.11.21.06.00;	author daveb;	state Exp;
branches;
next	;

1.15.9.1
date	97.10.31.13.49.04;	author nickb;	state Exp;
branches;
next	;

1.21.1.1
date	99.04.01.18.04.41;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.21
log
@[Bug #70219]
Make stack backtrace function easily available
@
text
@/*  ==== GLOBAL MEMORY MANAGEMENT ====
 *
 *  Copyright (C) 1992 Harelquin Ltd
 *
 *  Description
 *  -----------
 *  These declarations deal with the allocation of memory, including
 *  creation of generations, stacks, etc. for the garbage collector.
 *
 *  We deal with 5 kinds of objects: ML stack blocks, C stack blocks,
 * C heap blocks, generations, and static ML object spaces. The C
 * struct declarations are here, as are functions to make, delete,
 * resize, &c.
 *
 *  This module requests pieces of memory from the arena manager, in
 *  'blocks' (fixed size, typically 64k) and 'spaces' (variable size
 *  with fixed alignment, typically 16 Mb). Generations are given a
 *  space each. Static objects are allocated in static spaces. The ML
 *  stack and the C heap are allocated in blocks. See arena.h for more
 *  information.
 *
 *  We define several new types for memory: TYPE_STATIC, TYPE_GEN,
 *  TYPE_FROM, TYPE_STACK, TYPE_HEAP. These are used in the type maps
 *  defined by the arena manager.
 *
 *  For more information, see the comments below.
 *  
 *  Revision Log
 *  ------------
 *  $Log: src:mem.h,v $
 * Revision 1.20  1998/08/17  10:56:40  jont
 * [Bug #70153]
 * Add validate_ml_address
 *
 * Revision 1.19  1998/05/19  14:49:29  jont
 * [Bug #70120]
 * Add prototype for validate_address
 *
 * Revision 1.18  1998/04/24  10:19:26  jont
 * [Bug #70032]
 * gen->values now measured in bytes
 *
 * Revision 1.17  1998/04/23  14:09:29  jont
 * [Bug #70034]
 * Clean up TYPEs and structs
 *
 * Revision 1.16  1998/03/03  14:15:46  jont
 * [Bug #70018]
 * Add field to struct gen to indicate image save high water mark
 *
 * Revision 1.15  1996/10/29  16:06:43  nickb
 * Fix space lookup for pointers with top bit set.
 *
 * Revision 1.14  1996/08/28  11:36:27  nickb
 * DEFAULT_ARENA_LIMIT should be in bytes, not megabytes.
 *
 * Revision 1.13  1996/08/23  15:24:22  nickb
 * Storage manager no longer has its own options.
 *
 * Revision 1.12  1996/05/21  15:43:26  nickb
 * Clear up comment for VALUE_GEN.
 *
 * Revision 1.11  1996/05/14  16:08:08  nickb
 * Add out-of-memory hook.
 *
 * Revision 1.10  1996/01/15  17:32:23  nickb
 * Remove "storage manager" interface; replace it with regular functions.
 *
 * Revision 1.9  1995/03/15  17:10:38  nickb
 * Add C stack support for threads.
 *
 * Revision 1.8  1995/03/07  16:12:38  nickb
 * Extend static object header to have a generation pointer.
 *
 * Revision 1.7  1995/03/02  10:55:21  nickb
 * space_gen becomes SPACE_GEN
 * Also new macros for static objects.
 *
 * Revision 1.6  1995/02/28  16:44:29  nickb
 * Partially implemented static objects.
 *
 * Revision 1.5  1995/02/27  16:50:22  nickb
 * TYPE_LARGE becomes TYPE_STATIC
 *
 * Revision 1.4  1994/12/05  15:55:47  jont
 * Remove double align from large_object
 *
 * Revision 1.3  1994/10/21  14:37:35  nickb
 * Correct comment.
 *
 * Revision 1.2  1994/06/09  14:51:31  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:26:23  nickh
 * new file
 *
 *  Revision 2.5  1993/12/15  14:19:42  nickh
 *  Added a comment.
 *
 *  Revision 2.3  1993/10/12  16:11:23  matthew
 *  Merging bug fixes
 *
 *  Revision 2.2.1.2  1993/10/12  15:03:33  matthew
 *  Added extend_max_stack_block_count and set_max_stack_block_count
 *
 *  Revision 2.2.1.1  1992/10/15  16:44:20  jont
 *  Fork for bug fixing
 *
 *  Revision 2.2  1992/10/15  16:44:20  richard
 *  Removed the padding word from the large object header.  It was causing
 *  the mark word to be misaligned.
 *
 *  Revision 2.1  1992/08/04  10:31:51  richard
 *  New version using a separate arena manager.  This code
 *  now deals with descriptors only.
 *
 *  Revision 1.18  1992/07/28  15:05:51  jont
 *  Increased mamximum generations to 15
 *
 *  Revision 1.17  1992/07/27  15:06:23  richard
 *  Increased MAXBLKS to 8192.
 *
 *  Revision 1.16  1992/07/23  13:34:01  richard
 *  Added a `top' field to the large object header.
 *
 *  Revision 1.15  1992/06/30  14:14:32  richard
 *  Moved storage manager independent declarations to storeman.h.
 *  Changed some types in space and generation descriptors.
 *
 *  Revision 1.14  1992/06/29  14:57:36  richard
 *  Added GRAINROUNDUP.
 *
 *  Revision 1.13  1992/06/23  13:57:16  richard
 *  Added large_object and deallocate_blocks().
 *
 *  Revision 1.12  1992/03/19  16:44:20  richard
 *  Generation sizes are fetched from arrays defined in mem.h rather than
 *  calculated by macros.
 *
 *  Revision 1.11  1992/03/16  11:23:27  richard
 *  Moved MAXGEN here from mem.c.  Added BLKBASE macro.
 *
 *  Revision 1.10  1992/03/12  12:29:40  richard
 *  Added top_generation parameter to specify number of generations to
 *  allocate initially.
 *
 *  Revision 1.9  1992/03/10  17:25:29  richard
 *  Major revision:  Memory is now arranged in terms of spaces rather than
 *  generations, and descriptors for spaces and generations are allocated
 *  on the C heap rather than the ML one.  This should improved robustness
 *  and locality of reference when dealing with generation descriptors.
 *  genmap replaced with spacemap.
 *
 *  Revision 1.8  1992/02/13  15:04:13  clive
 *  First attempt at using allocate_blocks to get memory at loading time
 *
 *  Revision 1.7  1992/01/27  14:12:24  richard
 *  Added entry table, and exported make_gen() and unmake_gen() for use in the
 *  garbage collector controller.  Removed generation size macros: there are
 *  replaced by more general macros in "gc.h".
 *
 *  Revision 1.6  1992/01/20  11:43:40  richard
 *  Added entry list link structure to generation header.
 *
 *  Revision 1.5  1992/01/17  11:41:54  richard
 *  Removed dodgy version of malloc() and free().  See new alloc.h.
 *
 *  Revision 1.4  1992/01/08  11:47:58  richard
 *  Changed the type of stacktop to a void *.  Added INITIAL_STACK_SIZE.
 *
 *  Revision 1.3  1991/12/23  13:22:07  richard
 *  Changed the types of malloc and free to reflect ANSI definitions.
 *
 *  Revision 1.2  91/12/17  17:22:28  nickh
 *  added header and comment
 *  
 *  Revision 1.1  91/12/17  16:15:29  nickh
 *  Initial revision */

#ifndef mem_h
#define mem_h

#include "mltypes.h"
#include "types.h"
#include "arena.h"

/*  == ML stack area header ==
 *
 *  The stack structure appears immediately before the memory which makes up
 *  the stack.
 */

struct ml_stack
{
  struct ml_stack *parent;     	/* link to previous stack */
  struct stack_frame *top;	/* the top of the stack area */
};

/*  == C stack area header ==
 *
 *  The stack structure appears immediately before the memory which makes up
 *  the stack.
 */

struct c_stack
{
  struct stack_frame *top;	/* the top of the stack area */
  char *base;
};

/*  == C heap area header ==
 *
 *  The heap structure appears immediately before the memory which makes up
 *  the C heap area.
 */

struct c_heap
{
  struct c_heap *parent;		/* link to previous heap */
  size_t size;			/* total size of area, including this struct */
};

/*  == Static object descriptor ==
 *
 *  ML objects which should not be moved by the GC (e.g. large
 * objects, objects used in the foreign interface) are allocated in
 * spaces of their own (see static space descriptor, below) and
 * chained together using this descriptor.  Each generation (see
 * below) is on a doubly-linked list of static objects which it
 * logically contains.  This header must be 16 bytes long, and the
 * word immediately before the object must be the mark word.  */

struct ml_static_object
{
  struct ml_static_object *forward, *back;
  struct ml_heap *gen;		/* the generation of the object */
  word mark;			/* used to mark and sweep object in GC */
  mlval object[1];		/* the first word of the object */
};

/* STATIC_ALIGN  aligns values to 16-byte boundaries.
 * STATIC_SIZE   gives the total size of a static object including n user bytes
 * STATIC_HEADER gives the static object header given a ptr to the ML header
 */

#define STATIC_ALIGN(addr)	(((word)(addr)+15) & ~15u)
#define STATIC_SIZE(bytes)	STATIC_ALIGN((bytes) - sizeof(mlval) +   \
					     sizeof(struct ml_static_object))
#define STATIC_HEADER(ml_header)	((struct ml_static_object *)	\
					 (((byte*)(ml_header)) -	\
					  sizeof(struct ml_static_object) + \
					  sizeof(mlval)))

/*  == Static space descriptor ==
 * 
 * Static ML objects are in specially tagged spaces. Each such space
 * has a descriptor like the one below. These are on a doubly-linked
 * list in address order. 
 */

struct ml_static_space
{
  struct ml_static_space *forward, *back;
  unsigned int space;		/* space number occupied */
  size_t mapped;		/* number of bytes mapped for this space */
  size_t free;			/* number of bytes in 'holes' in this space */
  struct ml_static_object free_list; /* first hole */
};

/* SPACE_STATIC(space) gives the static space descriptor for the space */

#define SPACE_STATIC(space)	((struct ml_static_space *)space_info[space])

/*  == Generation descriptor ==
 *
 *  A generation contains data of a particular age.
 */

struct ml_heap
{
  int number;			   /* generation number */
  struct ml_heap *parent, *child;  /* adjacent generations */
  unsigned int space;		   /* space number occupied */
  float collect;		   /* used to time collections */
  size_t values;		   /* maximum extent in values */
  mlval *start, *end;		   /* current extent of memory in the space */
  mlval *top;			   /* top of live data in this space */
  mlval *image_top;		   /* top of live data for image save */
  union ml_array_header entry;     /* entry list */
  union ml_array_header last;      /* end of the entry list for image save */
  unsigned nr_entries;		   /* number of entries in the above list (for stats) */
  struct ml_static_object statics; /* chain of static objects `in' space */
  unsigned nr_static;		   /* number of static objects (for stats) */
};

/* GENERATION(obj) gives the generation of an ML value which points to
 *			 a true header (not a back pointer or shared closure).
 * VALUE_GEN(val)  gives the generation of any ML value except shared closures.
 */

#define GENERATION(ml_object)	(SPACE_TYPE(ml_object) == TYPE_ML_STATIC ?	      \
				 STATIC_HEADER(OBJECT((word)ml_object))->gen: \
				 space_gen[SPACE(ml_object)])

#define VALUE_GEN(ml_value)     (SPACE_TYPE(ml_value) == TYPE_ML_STATIC ?	      \
				 STATIC_HEADER(TRUE_HEAD(ml_value))->gen :    \
				 space_gen[SPACE(ml_value)])

/* ML uses spaces from the arena manager as generations and large
 * objects. It uses blocks as stack and C heap. */

#define TYPE_ML_HEAP	1	/* an ML heap generation */
#define TYPE_FROM	2	/* ditto, currently being copied from */
#define TYPE_ML_STACK	3	/* ML stack area */
#define TYPE_C_HEAP	4	/* C heap area */
#define TYPE_ML_STATIC	5	/* static ML objects */
#define TYPE_C_STACK	6	/* C stack area */

extern struct ml_heap *space_gen[SPACES_IN_ARENA];

/* functions on static objects */

extern struct ml_static_object *make_static_object(size_t bytes);
extern void unmake_static_object(struct ml_static_object *stat);

/* functions on generations */

extern struct ml_heap *make_ml_heap(size_t values, size_t extent);
extern void resize_ml_heap(struct ml_heap *gen, size_t extent);
extern void unmake_ml_heap(struct ml_heap *gen);

/* functions on C heap blocks */

extern struct c_heap *make_heap(struct c_heap *parent, size_t size);
extern struct c_heap *unmake_heap(struct c_heap *heap);

/* functions on stack blocks */

extern struct ml_stack *make_ml_stack(struct ml_stack *parent, size_t size);
extern struct ml_stack *unmake_ml_stack(struct ml_stack *stack);
extern void unwind_stack(struct stack_frame *sp);

extern struct c_stack *make_c_stack(void);
extern void free_c_stack(struct c_stack *stack);
extern void free_ml_stacks(struct ml_stack *stack);

/* stack overflow handling macros */

#define STACK_LIMIT(base)					\
  (struct ml_stack *)(((int)(base))+STACK_BUFFER+DEFAULT_STACK_SIZE)
#define STACK_BASE(limit)					\
  (struct ml_stack *)(((int)(limit))-STACK_BUFFER-DEFAULT_STACK_SIZE)

/* predicates on addresses */

extern int is_ml_stack (void *p);
extern int is_ml_heap (void *p);

/* This callback is called when the memory manager fails due to a lack
 * of underlying OS memory. It returns zero for abort or non-zero for
 * retry. 'attempt' is unique to a single request and all its retries.
 * 'extent' is the currently allocated arena, 'length' is the size of
 * the attempted request. */

extern int (*out_of_memory_dialog)(unsigned long int attempt,
				   size_t extent, size_t length);

/* A function for address validation during eg backtraces */

extern int validate_address(void *addr);

/* A function for ml address validation during eg profiling */

extern int validate_ml_address(void *addr);

/* Initialise the storage manager; this interface will change when the
   new GC adds options to the runtime. */

extern void sm_init(void);

/* For now, the only storage manager option is -limit n, where n
 * is a number of megabytes. The default is 100 megabytes. */

#define DEFAULT_ARENA_LIMIT	(100<<20)

extern size_t arena_limit;

/* Stack backtrace (easy version) */

extern void ml_backtrace(int depth_max);

#endif
@


1.21.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a30 4
 * Revision 1.21  1998/10/23  14:17:30  jont
 * [Bug #70219]
 * Make stack backtrace function easily available
 *
@


1.20
log
@[Bug #70153]
Add validate_ml_address
@
text
@d31 4
d387 4
@


1.19
log
@[Bug #70120]
Add prototype for validate_address
@
text
@d31 4
d367 4
@


1.18
log
@[Bug #70032]
gen->values now measured in bytes
@
text
@d31 4
d359 4
@


1.17
log
@[Bug #70034]
Clean up TYPEs and structs
@
text
@d31 4
d316 3
a318 3
extern struct ml_heap *make_gen(size_t values, size_t extent);
extern void resize_gen(struct ml_heap *gen, size_t extent);
extern void unmake_gen(struct ml_heap *gen);
@


1.16
log
@[Bug #70018]
Add field to struct gen to indicate image save high water mark
@
text
@d31 4
d201 1
a201 1
struct heap
d203 1
a203 1
  struct heap *parent;		/* link to previous heap */
d217 1
a217 1
struct static_object
d219 2
a220 2
  struct static_object *forward, *back;
  struct gen *gen;		/* the generation of the object */
d232 2
a233 2
					     sizeof(struct static_object))
#define STATIC_HEADER(ml_header)	((struct static_object *)	\
d235 1
a235 1
					  sizeof(struct static_object) + \
d245 1
a245 1
struct static_space
d247 1
a247 1
  struct static_space *forward, *back;
d251 1
a251 1
  struct static_object free_list; /* first hole */
d256 1
a256 1
#define SPACE_STATIC(space)	((struct static_space *)space_info[space])
d263 1
a263 1
struct gen
d265 13
a277 13
  int number;			/* generation number */
  struct gen *parent, *child;	/* adjacent generations */
  unsigned int space;		/* space number occupied */
  float collect;		/* used to time collections */
  size_t values;		/* maximum extent in values */
  mlval *start, *end;		/* current extent of memory in the space */
  mlval *top;			/* top of live data in this space */
  mlval *image_top;		/* top of live data for image save */
  union ml_array_header entry;  /* entry list */
  union ml_array_header last;   /* end of the entry list for image save */
  unsigned nr_entries;		/* number of entries in the above list (for stats) */
  struct static_object statics;	/* chain of static objects `in' space */
  unsigned nr_static;		/* number of static objects (for stats) */
d285 1
a285 1
#define GENERATION(ml_object)	(SPACE_TYPE(ml_object) == TYPE_STATIC ?	      \
d289 1
a289 1
#define VALUE_GEN(ml_value)     (SPACE_TYPE(ml_value) == TYPE_STATIC ?	      \
d296 1
a296 1
#define TYPE_GEN	1	/* an ML heap generation */
d298 3
a300 3
#define TYPE_STACK	3	/* ML stack area */
#define TYPE_HEAP	4	/* C heap area */
#define TYPE_STATIC	5	/* static ML objects */
d303 1
a303 1
extern struct gen *space_gen[SPACES_IN_ARENA];
d307 2
a308 2
extern struct static_object *make_static_object(size_t bytes);
extern void unmake_static_object(struct static_object *stat);
d312 3
a314 3
extern struct gen *make_gen(size_t values, size_t extent);
extern void resize_gen(struct gen *gen, size_t extent);
extern void unmake_gen(struct gen *gen);
d318 2
a319 2
extern struct heap *make_heap(struct heap *parent, size_t size);
extern struct heap *unmake_heap(struct heap *heap);
@


1.15
log
@Fix space lookup for pointers with top bit set.
@
text
@d31 3
d268 1
d270 1
@


1.15.9.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a30 3
 * Revision 1.15  1996/10/29  16:06:43  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.8.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a30 3
 * Revision 1.15  1996/10/29  16:06:43  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.7.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a30 3
 * Revision 1.15  1996/10/29  16:06:43  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.6.1
log
@branched from 1.15
@
text
@a30 3
 * Revision 1.15  1996/10/29  16:06:43  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a30 3
 * Revision 1.15.6.1  1997/05/12  10:42:05  hope
 * branched from 1.15
 *
@


1.15.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a30 3
 * Revision 1.15.6.1  1997/05/12  10:42:05  hope
 * branched from 1.15
 *
@


1.15.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a30 3
 * Revision 1.15.6.1  1997/05/12  10:42:05  hope
 * branched from 1.15
 *
@


1.15.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a30 3
 * Revision 1.15.6.1.1.1  1997/07/28  18:29:42  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.15.5.1
log
@branched from 1.15
@
text
@a30 3
 * Revision 1.15  1996/10/29  16:06:43  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.4.1
log
@branched from 1.15
@
text
@a30 3
 * Revision 1.15  1996/10/29  16:06:43  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.4.1.1.1
log
@branched from 1.15.4.1
@
text
@a30 3
 * Revision 1.15.4.1  1996/12/17  17:55:04  hope
 * branched from 1.15
 *
@


1.15.3.1
log
@branched from 1.15
@
text
@a30 3
 * Revision 1.15  1996/10/29  16:06:43  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.2.1
log
@branched from 1.15
@
text
@a30 3
 * Revision 1.15  1996/10/29  16:06:43  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.1.1
log
@branched from 1.15
@
text
@a30 3
 * Revision 1.15  1996/10/29  16:06:43  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.1.1.1.1
log
@branched from 1.15.1.1
@
text
@a30 3
 * Revision 1.15.1.1  1996/11/14  12:59:00  hope
 * branched from 1.15
 *
@


1.14
log
@DEFAULT_ARENA_LIMIT should be in bytes, not megabytes.
@
text
@d31 3
d294 1
a294 1
extern struct gen *space_gen[NR_SPACES];
@


1.14.3.1
log
@branched from 1.14
@
text
@a30 3
 * Revision 1.14  1996/08/28  11:36:27  nickb
 * DEFAULT_ARENA_LIMIT should be in bytes, not megabytes.
 *
@


1.14.2.1
log
@branched from 1.14
@
text
@a30 3
 * Revision 1.14  1996/08/28  11:36:27  nickb
 * DEFAULT_ARENA_LIMIT should be in bytes, not megabytes.
 *
@


1.14.1.1
log
@branched from 1.14
@
text
@a30 3
 * Revision 1.14  1996/08/28  11:36:27  nickb
 * DEFAULT_ARENA_LIMIT should be in bytes, not megabytes.
 *
@


1.13
log
@Storage manager no longer has its own options.
@
text
@d31 3
d346 1
a346 1
 * is a number of megabytes. The default is 100. */
d348 1
a348 1
#define DEFAULT_ARENA_LIMIT	100
@


1.12
log
@Clear up comment for VALUE_GEN.
@
text
@d31 3
a289 2
extern size_t arena_limit;	/* determined from the -size parameter */

d337 2
a338 8
/* Initialise the storage manager; this interface will go away soon.
 *
 *  The storage manager is passed the arguments specified by the user using
 *  the `-storeman' option.  argv is a pointer to an array of arguments, and
 *  argc is the number of arguments.  Unlike the parameters to main(),
 *  argv[argc] does not exist.  If `-storeman' is not specified, argv is
 *  NULL.
 */
a339 1
extern void sm_options(int argc, const char *const *argv);
d342 4
a345 7
/*  == Description of options ==
 *
 *  This is a string describing the meaning of the parameters passed
 *  to sm_init() for use in the runtime system help message.  It is
 *  less than eighty columns wide, and indented by ten spaces.  It
 *  ends with a newline.
 */
d347 1
a347 1
extern const char *sm_help;
@


1.11
log
@Add out-of-memory hook.
@
text
@d31 3
d263 2
a264 2
 *			 a true header (not a back pointer).
 * VALUE_GEN(val)  gives the generation of any ML value
@


1.10
log
@Remove "storage manager" interface; replace it with regular functions.
@
text
@d31 3
d323 9
@


1.9
log
@Add C stack support for threads.
@
text
@d31 3
a307 6

/* functions on stack block count. */

extern void extend_max_stack_block_count (int n);
extern void set_max_stack_block_count (int n);
extern int get_max_stack_block_count (void);
@


1.8
log
@Extend static object header to have a generation pointer.
@
text
@d10 4
a13 3
 *  We deal with 4 kinds of objects: ML stack blocks, C heap blocks,
 * generations, and static ML objects. The C struct declarations are
 * here, as are functions to make, delete, resize, &c.
d31 3
d146 13
a158 1
/*  == Stack area header ==
d164 1
a164 1
struct stack
a165 1
  struct stack *parent;		/* link to previous stack */
d167 1
a167 1
  unsigned int tag;		/* available for use by storage manager */
d274 1
d298 2
a299 2
extern struct stack *make_stack(struct stack *parent, size_t size);
extern struct stack *unmake_stack(struct stack *stack);
d302 4
d315 1
a315 1
  (struct stack *)(((int)(base))+STACK_BUFFER+DEFAULT_STACK_SIZE)
d317 1
a317 1
  (struct stack *)(((int)(limit))-STACK_BUFFER-DEFAULT_STACK_SIZE)
d333 2
a334 2
extern void sm_init(int argc, const char *const *argv);

@


1.7
log
@space_gen becomes SPACE_GEN
Also new macros for static objects.
@
text
@d30 4
d174 2
a175 3
 * logically contains.  This header must be an even number of words
 * long, and the word immediately before the object must be the mark
 * word.  */
d180 1
a180 1
  size_t values;		/* size of the object in values */
d185 13
d214 2
a217 4
#define STATIC_ALIGN(addr)	(((word)(addr)+15) & ~15u)
#define STATIC_SIZE(values)	STATIC_ALIGN((values-1) * sizeof(mlval) +   \
					     sizeof(struct static_object))

d238 13
d266 1
a266 1
extern struct static_object *make_static_object(size_t values);
@


1.6
log
@Partially implemented static objects.
@
text
@d30 3
d195 1
a195 4
  struct static_object *first_free;
				/* first hole */
  struct static_object *largest_hole;
				/* optimize looking for a hole 'large enough'*/
d197 6
@


1.5
log
@TYPE_LARGE becomes TYPE_STATIC
@
text
@d30 3
d164 14
a177 5
 * spaces of their own and chained together using this descriptor.
 * Each generation (see below) is on a doubly-linked list of static
 * objects which it logically contains.  This header must be an even
 * number of words long, and the word immediately before the object
 * must be the mark word.  */
d179 8
a186 1
union static_object
d188 8
a195 7
  struct
  {
    union static_object *forward, *back;
    size_t values;		/* size of the object in values */
    word mark;			/* used to mark and sweep object in GC */
    mlval object[1];		/* the first word of the object */
  } the;
d214 1
a214 1
  union static_object statics;	/* chain of static objects `in' space */
d233 2
a234 2
extern union static_object *make_static_object(size_t values);
extern void unmake_static_object(union static_object *stat);
@


1.4
log
@Remove double align from large_object
@
text
@d11 2
a12 2
 * generations, and large objects. The C struct declarations are here,
 * as are functions to make, delete, resize, &c.
d16 4
a19 3
 *  with fixed alignment, typically 16 Mb). Generations and large
 *  objects are given a space each. The ML stack and the C heap are
 *  allocated in blocks. See arena.h for more information.
d21 1
a21 1
 *  We define several new types for memory: TYPE_LARGE, TYPE_GEN,
d30 3
d157 1
a157 1
/*  == Large object descriptor ==
d159 7
a165 7
 *  Objects which are too large to fit in the generational memory
 *  model are allocated blocks of their own and chained together using
 *  this descriptor.  Each generation (see below) is on a
 *  doubly-linked list of large objects which it logically contains.
 *  This header must be an even number of words long, and the word
 *  immediately before the object must be the mark word.
 */
d167 1
a167 1
union large_object
d171 1
a171 1
    union large_object *forward, *back;
d194 2
a195 2
  union large_object large;	/* chain of large objects `in' space */
  unsigned nr_large;		/* number of large objects (for stats) */
d205 1
a205 1
#define TYPE_LARGE	5	/* large ML object */
d211 1
a211 1
/* functions on large objects */
d213 2
a214 2
extern union large_object *make_large(size_t values);
extern void unmake_large(union large_object *large);
@


1.3
log
@Correct comment.
@
text
@d29 3
a164 1
  double align;
@


1.2
log
@new file
@
text
@d10 15
a24 11
 *  The entire memory is divided into aligned blocks, of size BLKSIZE, with
 *  MAXBLKS number of blocks maximum.  This includes the text segment and
 *  the part of memory beyond the brk limit of the data segment.  Maps of
 *  the blocks are keps: a byte for each block giving the generation number
 *  (NOGEN if not in the heap), and a byte giving the type of the block.
 *  This enables us to readily discover the generation number of any
 *  pointer, and also to mark `from-space' blocks during collection.
 *  
 *  The allocator uses brk and sbrk, and so malloc() etc. are redefined in
 *  "alloc.h".  Fortunately, the system library links to our versions,
 *  although this may not always be true.
d29 3
d116 1
a116 2
 *  Initial revision
 */
@


1.2.1.1
log
@branched from 1.2
@
text
@a24 3
 * Revision 1.2  1994/06/09  14:51:31  nickh
 * new file
 *
@


1.1
log
@new file
@
text
@d24 4
a27 1
 *  $Log: mem.h,v $
@
