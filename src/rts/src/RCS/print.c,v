head	1.9;
access;
symbols
	MLW_daveb_inline_1_4_99:1.9.4
	MLWorks_21c0_1999_03_25:1.9
	MLWorks_20c1_1998_08_20:1.9
	MLWorks_20c0_1998_08_04:1.9
	MLWorks_20b2c2_1998_06_19:1.9
	MLWorks_20b2_Windows_1998_06_12:1.9
	MLWorks_20b1c1_1998_05_07:1.9
	MLWorks_20b0_1998_04_07:1.9
	MLWorks_20b0_1998_03_20:1.9
	MLWorks_20m2_1998_02_16:1.9
	MLWorks_MM_adapt:1.9.3
	MLWorks_20m1_1997_10_23:1.9
	MLWorks_11r1:1.7.9.1.1.1.1
	MLWorks_workspace_97:1.9.2
	MLWorks_dt_wizard:1.9.1
	MLWorks_11c0_1997_09_09:1.7.9.1.1.1
	MLWorks_10r3:1.7.9.1.3
	MLWorks_10r2_551:1.7.9.1.2
	MLWorks_11:1.7.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.7.9.1
	MLWorks_20m0_1997_06_20:1.9
	MLWorks_1_0_r2c2_1997_06_14:1.7.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.7.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.7.9
	MLWorks_BugFix_1997_04_24:1.7
	MLWorks_1_0_r2_Win32_1997_04_11:1.7
	MLWorks_1_0_r2_Unix_1997_04_04:1.7
	MM_ML_release_korma_1997_04_01:1.7
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.7.7.1.1
	MLWorks_gui_1996_12_18:1.7.8
	MLWorks_1_0_Win32_1996_12_17:1.7.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.7.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.7.4.1
	JFHrts:1.7.6
	MLWorks_1_0_Irix_1996_11_28:1.7.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.7.5
	MLWorks_1_0_Unix_1996_11_14:1.7.4
	MLWorks_Open_Beta2_1996_10_11:1.7.3
	MLWorks_License_dev:1.7.2
	MLWorks_1_open_beta_1996_09_13:1.7.1
	MLWorks_Open_Beta_1996_08_22:1.7
	MLWorks_Beta_1996_07_02:1.7
	MLWorks_Beta_1996_06_07:1.7
	MLWorks_Beta_1996_06_06:1.7
	MLWorks_Beta_1996_06_05:1.7
	MLWorks_Beta_1996_06_03:1.7
	MLWorks_Beta_1996_05_31:1.7
	MLWorks_Beta_1996_05_30:1.7
	hope_poo:1.4.1
	ML_beta_release_12/08/94:1.4.1.1
	ML_beta_release_03/08/94:1.4;
locks; strict;
comment	@ * @;


1.9
date	97.06.03.12.54.15;	author jont;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1
	1.9.4.1;
next	1.8;

1.8
date	97.05.20.18.35.39;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	96.02.14.15.07.46;	author jont;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1
	1.7.4.1
	1.7.5.1
	1.7.6.1
	1.7.7.1
	1.7.8.1
	1.7.9.1;
next	1.6;

1.6
date	96.02.13.17.28.00;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	95.03.28.12.57.54;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	94.06.23.13.38.04;	author nickh;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	94.06.21.16.00.18;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.45.19;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.11.14.37;	author nickh;	state Exp;
branches;
next	;

1.4.1.1
date	95.07.05.10.28.53;	author hope;	state Exp;
branches;
next	;

1.7.1.1
date	96.09.13.11.24.12;	author hope;	state Exp;
branches;
next	;

1.7.2.1
date	96.10.07.16.14.30;	author hope;	state Exp;
branches;
next	;

1.7.3.1
date	96.10.17.11.33.57;	author hope;	state Exp;
branches;
next	;

1.7.4.1
date	96.11.14.12.59.37;	author hope;	state Exp;
branches
	1.7.4.1.1.1;
next	;

1.7.4.1.1.1
date	96.11.28.15.09.39;	author hope;	state Exp;
branches;
next	;

1.7.5.1
date	96.11.22.18.17.24;	author hope;	state Exp;
branches;
next	;

1.7.6.1
date	96.12.17.10.04.07;	author hope;	state Exp;
branches;
next	;

1.7.7.1
date	96.12.17.17.55.43;	author hope;	state Exp;
branches
	1.7.7.1.1.1;
next	;

1.7.7.1.1.1
date	97.02.24.11.47.16;	author hope;	state Exp;
branches;
next	;

1.7.8.1
date	96.12.18.09.50.20;	author hope;	state Exp;
branches;
next	;

1.7.9.1
date	97.05.12.10.44.01;	author hope;	state Exp;
branches
	1.7.9.1.1.1
	1.7.9.1.2.1
	1.7.9.1.3.1;
next	;

1.7.9.1.1.1
date	97.07.28.18.29.00;	author daveb;	state Exp;
branches
	1.7.9.1.1.1.1.1;
next	;

1.7.9.1.1.1.1.1
date	97.10.07.11.54.51;	author jkbrook;	state Exp;
branches;
next	;

1.7.9.1.2.1
date	97.09.08.17.21.57;	author daveb;	state Exp;
branches;
next	;

1.7.9.1.3.1
date	97.09.09.14.18.01;	author daveb;	state Exp;
branches;
next	;

1.9.1.1
date	97.09.10.19.37.19;	author brucem;	state Exp;
branches;
next	;

1.9.2.1
date	97.09.11.21.05.18;	author daveb;	state Exp;
branches;
next	;

1.9.3.1
date	97.10.31.13.48.21;	author nickb;	state Exp;
branches;
next	;

1.9.4.1
date	99.04.01.18.04.02;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.9
log
@[Bug #30076]
Modify to make NONGC spills be counted in words
@
text
@/*  ==== RUNTIME VALUE PRINTER ====
 *
 *  Copyright (C) 1993 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  The value printer is table-driven as far as possible.  This makes is
 *  nicely maintainable and extensible.  DON'T test for tags explicitly if
 *  you can possibly help it.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:print.c,v $
 * Revision 1.8  1997/05/20  18:35:39  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
 * Revision 1.7  1996/02/14  15:07:46  jont
 * Changing ERROR to MLERROR
 *
 * Revision 1.6  1996/02/13  17:28:00  jont
 * Add some type casts to allow compilation without warnings under VC++
 *
 * Revision 1.5  1995/03/28  12:57:54  nickb
 * Add printing on the message stream.
 *
 * Revision 1.4  1994/06/23  13:38:04  nickh
 * Looks up CCODEINTERFN without checking it's valid.
 *
 * Revision 1.3  1994/06/21  16:00:18  nickh
 * New ancillary structure.
 *
 * Revision 1.2  1994/06/09  14:45:19  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:14:37  nickh
 * new file
 *
 *  Revision 1.2  1994/01/28  17:23:27  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.1  1993/04/21  13:01:28  richard
 *  Initial revision
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "ansi.h"
#include "print.h"
#include "mltypes.h"
#include "values.h"
#include "tags.h"
#include "extensions.h"
#include "utils.h"


struct print_options print_defaults = {0, 0, 0, 0};

static FILE *print_stream;
static int print_message_stream;

void print_a_bit(const char *string, ...);

void print_a_bit(const char *string, ...)
{
  va_list arg;
  va_start (arg,string);
  if (print_message_stream)
    vmessage_content(string,arg);
  else
    vfprintf(print_stream,string,arg);
  va_end(arg);
}

void p(struct print_options *options, int depth, int indent_next, mlval value);

static inline void indent(int depth)
{
  print_a_bit("\n");
  depth *= 2;
  while(depth--) print_a_bit(" ");
}

static void p_record(struct print_options *options,
		     int depth,
		     mlval value,
		     mlval primary,
		     mlval header,
		     mlval secondary)
{
  size_t i, length = LENGTH(header);

  if(options->tags && options->indent) indent(depth);
  print_a_bit("{");
  for(i=0; i<length; ++i)
  {
    if(i) print_a_bit(", ");
    p(options, depth+1, 1, FIELD(value, i));
  }
  if(options->indent) indent(depth);
  print_a_bit("}");
}

static void p_substring(const char *s, size_t length)
{
  while(length--)
  {
    char c = *s++;
    if(c == '"') print_a_bit("\\\"");
    else if(c == '\\') print_a_bit("\\\\");
    else if(c >= 21 && c < 127) print_a_bit("%c",c);
    else if(c == '\n') print_a_bit("\\n");
    else if(c == '\t') print_a_bit("\\t");
    else if((unsigned char)c <= 26) print_a_bit("\\^%c", c+64);
    else print_a_bit("\\%03u", (unsigned char)c);
  }
}

static void p_string(struct print_options *options,
		     int depth,
		     mlval value,
		     mlval primary,
		     mlval header,
		     mlval secondary)
{
  size_t length = LENGTH(header)-1;
  const char *s = CSTRING(value);

  print_a_bit("\"");
  if(options->string_length_max &&
     length > options->string_length_max)
  {
    p_substring(s, options->string_length_max);
    print_a_bit("...");
  }
  else
    p_substring(s, length);
  print_a_bit("\"");
}

static void p_array(struct print_options *options,
		    int depth,
		    mlval value,
		    mlval primary,
		    mlval header,
		    mlval secondary)
{
  size_t i, length = LENGTH(header);
  if(options->tags && options->indent) indent(depth);
  print_a_bit("[");
  for(i=0; i<length; ++i)
  {
    if(i) print_a_bit(", ");
    p(options, depth+1, 1, MLSUB(value, i));
  }
  if(options->indent) indent(depth);
  print_a_bit("]");
}

static void p_bytearray(struct print_options *options,
			int depth,
			mlval value,
			mlval primary,
			mlval header,
			mlval secondary)
{
  size_t i, length = LENGTH(header);
  unsigned char *bytes =
    primary == POINTER ?
      (unsigned char *)CSTRING(value) : CBYTEARRAY(value);

  if(options->tags && options->indent) indent(depth);
  print_a_bit("byte[");
  for(i=0; i<length; ++i)
  {
    if(i) print_a_bit(", ");
    if(options->indent && i%16 == 0) indent(depth+1);
    print_a_bit("%02X", bytes[i]);
  }
  if(options->indent) indent(depth);
  print_a_bit("]byte");
}

static void p_backptr(struct print_options *options,
		      int depth,
		      mlval value,
		      mlval primary,
		      mlval header,
		      mlval secondary)
{
  if(options->tags)
    print_a_bit("code %d of 0x%X ancillary 0x%X",
		CCODENUMBER(value), FOLLOWBACK(value), CCODEANCILLARY(value));

  if(options->tags && options->indent) indent(depth);
  print_a_bit("code{");
  if(options->indent) indent(depth+1);
  print_a_bit("name = ");
  p(options, depth+2, 0, CCODENAME(value));
  print_a_bit(", ");
  if(options->indent) indent(depth+1);
  print_a_bit("non_gc spills = %u words, leaf = %u, profile = %ux, intercept = %u, ",
	  CCODENONGC(value), CCODELEAF(value), CCODEPROFILE(value),
	  CCODEINTERCEPT(value));
  if (CCODE_CAN_INTERCEPT(value)) {
    if(options->indent) indent(depth+1);
    print_a_bit("interfn = ");
    p(options, depth+2, 0, CCODEINTERFN(value));
  }
  if(options->indent) indent(depth);
  print_a_bit("}code");
}

static void p_code(struct print_options *options,
		   int depth,
		   mlval value,
		   mlval primary,
		   mlval header,
		   mlval secondary)
{
  print_a_bit("code vector printer not implemented");
}

static void p_illegal_secondary(struct print_options *options,
				int depth,
				mlval value,
				mlval primary,
				mlval header,
				mlval secondary)
{
  print_a_bit("illegal");
}

static struct
{
  const char *name;
  void (*printer)(struct print_options *options,
		  int depth,
		  mlval value,
		  mlval primary,
		  mlval header,
		  mlval secondary);
} secondaries[64] =
{
  {NULL,	NULL},		{NULL,	NULL},
  {"RECORD",	p_record},	{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {"STRING",	p_string},	{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {"ARRAY",	p_array},	{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {"BYTEARRAY", p_bytearray},	{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {"BACKPTR",   p_backptr},	{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {"CODE",      p_code},	{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {"HEADER50",  p_illegal_secondary},	{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {"WEAKARRAY", p_array},	{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL},
  {NULL,	NULL},		{NULL,	NULL}
};


static void p_int(struct print_options *options,
		  int depth,
		  mlval value,
		  mlval primary)
{
  print_a_bit("%d", CINT(value));
}

static void p_header(struct print_options *options,
		     int depth,
		     mlval value,
		     mlval primary)
{
  print_a_bit("for %s length %u",
	  secondaries[SECONDARY(value)].name,
	  LENGTH(value));
}

static void p_illegal(struct print_options *options,
		      int depth,
		      mlval value,
		      mlval primary)
{
  print_a_bit("illegal");
}

static void p_pair(struct print_options *options,
		   int depth,
		   mlval value,
		   mlval primary)
{
  if(options->tags && options->indent) indent(depth);
  print_a_bit("{");
  p(options, depth+1, 1, FIELD(value, 0));
  print_a_bit(", ");
  p(options, depth+1, 1, FIELD(value, 1));
  if(options->indent) indent(depth);
  print_a_bit("}");
}

static void p_pointer(struct print_options *options,
		      int depth,
		      mlval value,
		      mlval primary)
{
  mlval header = GETHEADER(value), secondary = SECONDARY(header);
  const char *name = secondaries[secondary].name;

  if(name)
  {
    if(options->tags)
      print_a_bit("0x%X %s ", header, name);

    (*secondaries[secondary].printer)(options, depth, value,
				      primary, header, secondary);
  }
  else
    print_a_bit("0x%X bad secondary %d", header, secondary);
}

static void p_ref(struct print_options *options,
		  int depth,
		  mlval value,
		  mlval primary)
{
  mlval header = ARRAYHEADER(value), secondary = SECONDARY(header);

  const char *name = secondaries[secondary].name;

  if(name)
  {
    if(options->tags)
      print_a_bit("0x%X %s ", header, name);

    (*secondaries[secondary].printer)(options, depth, value,
				      primary, header, secondary);
  }
  else
    print_a_bit("0x%X bad secondary %d", header, secondary);
}

static struct
{
  const char *name;
  void (*printer)(struct print_options *options,
		  int depth,
		  mlval value,
		  mlval primary);
} primaries[8] =
{
  {"INTEGER0", p_int},
  {"PAIRPTR",  p_pair},
  {"HEADER",   p_header},
  {"REFPTR",   p_ref},
  {"INTEGER1", p_int},
  {"POINTER",  p_pointer},
  {"PRIMARY6", p_illegal},
  {"PRIMARY7", p_illegal}
};


static struct
{
  mlval value;
  const char *name;
} specials[] =
{
  {MLERROR, "ERROR"},
  {EVACUATED, "EVACUATED"},
  {DEAD, "DEAD"}
};


void p(struct print_options *options,
       int depth, int indent_next, mlval value)
{
  mlval primary = PRIMARY(value);
  int i;

  if(indent_next && options->indent) indent(depth);
  if(options->tags)
    print_a_bit("<0x%X %s ", value, primaries[primary].name);

  if(options->depth_max && (unsigned)depth > options->depth_max)
    print_a_bit("...");
  else
  {
    for(i=0; i<sizeof(specials)/sizeof(specials)[0]; ++i)
      if(value == specials[i].value)
      {
	print_a_bit(specials[i].name);
	goto special;
      }

    (*primaries[primary].printer)(options, depth, value, primary);

    special:;
  }

  if(options->tags) print_a_bit(">");
}

void print(struct print_options *options, FILE *stream, mlval value)
{
  print_stream = stream;
  print_message_stream = 0;
  p(options ? options : &print_defaults, 0, 0, value);
}

void message_print(struct print_options *options, mlval value)
{
  print_stream = NULL;
  print_message_stream = 1;
  p(options ? options : &print_defaults, 0, 0, value);
}
@


1.9.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a13 4
 * Revision 1.9  1997/06/03  12:54:15  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
@


1.9.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a13 4
 * Revision 1.9  1997/06/03  12:54:15  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
@


1.9.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a13 4
 * Revision 1.9  1997/06/03  12:54:15  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
@


1.9.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a13 4
 * Revision 1.9  1997/06/03  12:54:15  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
@


1.8
log
@[Bug #30076]
Modifications to allow stack based parameter passing on the I386
@
text
@d14 4
d206 1
a206 1
  print_a_bit("non_gc spills = %u, leaf = %u, profile = %ux, intercept = %u, ",
@


1.7
log
@Changing ERROR to MLERROR
@
text
@d14 3
d202 2
a203 2
  print_a_bit("spills = %u, leaf = %u, profile = %ux, intercept = %u, ",
	  CCODESPILLS(value), CCODELEAF(value), CCODEPROFILE(value),
@


1.7.9.1
log
@branched from 1.7
@
text
@a13 3
 * Revision 1.7  1996/02/14  15:07:46  jont
 * Changing ERROR to MLERROR
 *
@


1.7.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a13 3
 * Revision 1.7.9.1  1997/05/12  10:44:01  hope
 * branched from 1.7
 *
@


1.7.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a13 3
 * Revision 1.7.9.1  1997/05/12  10:44:01  hope
 * branched from 1.7
 *
@


1.7.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a13 3
 * Revision 1.7.9.1  1997/05/12  10:44:01  hope
 * branched from 1.7
 *
@


1.7.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a13 3
 * Revision 1.7.9.1.1.1  1997/07/28  18:29:00  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.7.8.1
log
@branched from 1.7
@
text
@a13 3
 * Revision 1.7  1996/02/14  15:07:46  jont
 * Changing ERROR to MLERROR
 *
@


1.7.7.1
log
@branched from 1.7
@
text
@a13 3
 * Revision 1.7  1996/02/14  15:07:46  jont
 * Changing ERROR to MLERROR
 *
@


1.7.7.1.1.1
log
@branched from 1.7.7.1
@
text
@a13 3
 * Revision 1.7.7.1  1996/12/17  17:55:43  hope
 * branched from 1.7
 *
@


1.7.6.1
log
@branched from 1.7
@
text
@a13 3
 * Revision 1.7  1996/02/14  15:07:46  jont
 * Changing ERROR to MLERROR
 *
@


1.7.5.1
log
@branched from 1.7
@
text
@a13 3
 * Revision 1.7  1996/02/14  15:07:46  jont
 * Changing ERROR to MLERROR
 *
@


1.7.4.1
log
@branched from 1.7
@
text
@a13 3
 * Revision 1.7  1996/02/14  15:07:46  jont
 * Changing ERROR to MLERROR
 *
@


1.7.4.1.1.1
log
@branched from 1.7.4.1
@
text
@a13 3
 * Revision 1.7.4.1  1996/11/14  12:59:37  hope
 * branched from 1.7
 *
@


1.7.3.1
log
@branched from 1.7
@
text
@a13 3
 * Revision 1.7  1996/02/14  15:07:46  jont
 * Changing ERROR to MLERROR
 *
@


1.7.2.1
log
@branched from 1.7
@
text
@a13 3
 * Revision 1.7  1996/02/14  15:07:46  jont
 * Changing ERROR to MLERROR
 *
@


1.7.1.1
log
@branched from 1.7
@
text
@a13 3
 * Revision 1.7  1996/02/14  15:07:46  jont
 * Changing ERROR to MLERROR
 *
@


1.6
log
@Add some type casts to allow compilation without warnings under VC++
@
text
@d14 3
d384 1
a384 1
  {ERROR, "ERROR"},
@


1.5
log
@Add printing on the message stream.
@
text
@d14 3
d397 1
a397 1
  if(options->depth_max && depth > options->depth_max)
@


1.4
log
@Looks up CCODEINTERFN without checking it's valid.
@
text
@d14 3
d45 1
d50 17
a66 2
void p(struct print_options *options, FILE *stream,
       int depth, int indent_next, mlval value);
d68 1
a68 1
static inline void indent(FILE *stream, int depth)
d70 1
a70 1
  putc('\n', stream);
d72 1
a72 1
  while(depth--) putc(' ', stream);
a75 1
		     FILE *stream,
d84 2
a85 2
  if(options->tags && options->indent) indent(stream, depth);
  putc('{', stream);
d88 2
a89 2
    if(i) fputs(", ", stream);
    p(options, stream, depth+1, 1, FIELD(value, i));
d91 2
a92 2
  if(options->indent) indent(stream, depth);
  putc('}', stream);
d95 1
a95 1
static void p_substring(FILE *stream, const char *s, size_t length)
d100 7
a106 7
    if(c == '"') fprintf(stream, "\\\"");
    else if(c == '\\') fprintf(stream, "\\\\");
    else if(c >= 21 && c < 127) putc(c, stream);
    else if(c == '\n') fprintf(stream, "\\n");
    else if(c == '\t') fprintf(stream, "\\t");
    else if((unsigned char)c <= 26) fprintf(stream, "\\^%c", c+64);
    else fprintf(stream, "\\%03u", (unsigned char)c);
a110 1
		     FILE *stream,
d120 1
a120 1
  putc('"', stream);
d124 2
a125 2
    p_substring(stream, s, options->string_length_max);
    fputs("...", stream);
d128 2
a129 2
    p_substring(stream, s, length);
  putc('"', stream);
a132 1
		    FILE *stream,
d140 2
a141 2
  if(options->tags && options->indent) indent(stream, depth);
  putc('[', stream);
d144 2
a145 2
    if(i) fputs(", ", stream);
    p(options, stream, depth+1, 1, MLSUB(value, i));
d147 2
a148 2
  if(options->indent) indent(stream, depth);
  putc(']', stream);
a151 1
			FILE *stream,
d163 2
a164 2
  if(options->tags && options->indent) indent(stream, depth);
  fputs("byte[", stream);
d167 3
a169 3
    if(i) fputs(", ", stream);
    if(options->indent && i%16 == 0) indent(stream, depth+1);
    fprintf(stream, "%02X", bytes[i]);
d171 2
a172 2
  if(options->indent) indent(stream, depth);
  fputs("]byte", stream);
a175 1
		      FILE *stream,
d183 2
a184 2
    fprintf(stream, "code %d of 0x%X ancillary 0x%X",
	    CCODENUMBER(value), FOLLOWBACK(value), CCODEANCILLARY(value));
d186 8
a193 8
  if(options->tags && options->indent) indent(stream, depth);
  fputs("code{", stream);
  if(options->indent) indent(stream, depth+1);
  fputs("name = ", stream);
  p(options, stream, depth+2, 0, CCODENAME(value));
  fputs(", ", stream);
  if(options->indent) indent(stream, depth+1);
  fprintf(stream, "spills = %u, leaf = %u, profile = %ux, intercept = %u, ",
d197 3
a199 3
    if(options->indent) indent(stream, depth+1);
    fputs("interfn = ", stream);
    p(options, stream, depth+2, 0, CCODEINTERFN(value));
d201 2
a202 2
  if(options->indent) indent(stream, depth);
  fputs("}code", stream);
a205 1
		   FILE *stream,
d212 1
a212 1
  fputs("code vector printer not implemented", stream);
a215 1
				FILE *stream,
d222 1
a222 1
  fputs("illegal", stream);
a228 1
		  FILE *stream,
a271 1
		  FILE *stream,
d276 1
a276 1
  fprintf(stream, "%d", CINT(value));
a279 1
		     FILE *stream,
d284 1
a284 1
  fprintf(stream, "for %s length %u",
a289 1
		      FILE *stream,
d294 1
a294 1
  fputs("illegal", stream);
a297 1
		   FILE *stream,
d302 7
a308 7
  if(options->tags && options->indent) indent(stream, depth);
  putc('{', stream);
  p(options, stream, depth+1, 1, FIELD(value, 0));
  fputs(", ", stream);
  p(options, stream, depth+1, 1, FIELD(value, 1));
  if(options->indent) indent(stream, depth);
  putc('}', stream);
a311 1
		      FILE *stream,
d322 1
a322 1
      fprintf(stream, "0x%X %s ", header, name);
d324 1
a324 1
    (*secondaries[secondary].printer)(options, stream, depth, value,
d328 1
a328 1
    fprintf(stream, "0x%X bad secondary %d", header, secondary);
a331 1
		  FILE *stream,
d343 1
a343 1
      fprintf(stream, "0x%X %s ", header, name);
d345 1
a345 1
    (*secondaries[secondary].printer)(options, stream, depth, value,
d349 1
a349 1
    fprintf(stream, "0x%X bad secondary %d", header, secondary);
a355 1
		  FILE *stream,
d384 1
a384 1
void p(struct print_options *options, FILE *stream,
d390 1
a390 1
  if(indent_next && options->indent) indent(stream, depth);
d392 1
a392 1
    fprintf(stream, "<0x%X %s ", value, primaries[primary].name);
d395 1
a395 1
    fputs("...", stream);
d401 1
a401 1
	fputs(specials[i].name, stream);
d405 1
a405 1
    (*primaries[primary].printer)(options, stream, depth, value, primary);
d410 1
a410 1
  if(options->tags) putc('>', stream);
d415 10
a424 1
  p(options ? options : &print_defaults, stream, 0, 0, value);
@


1.4.1.1
log
@branched from 1.4
@
text
@a13 3
 * Revision 1.4  1994/06/23  13:38:04  nickh
 * Looks up CCODEINTERFN without checking it's valid.
 *
@


1.3
log
@New ancillary structure.
@
text
@d14 3
d182 5
a186 3
  if(options->indent) indent(stream, depth+1);
  fputs("interfn = ", stream);
  p(options, stream, depth+2, 0, CCODEINTERFN(value));
@


1.2
log
@new file
@
text
@d14 3
d176 3
a178 15
  fputs("spills = ", stream);
  p(options, stream, depth+2, 0, CCODEANCSUB(value, SPILLS));
  fputs(", ", stream);
  if(options->indent) indent(stream, depth+1);
  fputs("leaf = ", stream);
  p(options, stream, depth+2, 0, CCODEANCSUB(value, LEAFS));
  fputs(", ", stream);
  if(options->indent) indent(stream, depth+1);
  fputs("profile = ", stream);
  p(options, stream, depth+2, 0, CCODEANCSUB(value, PROFILES));
  fputs(", ", stream);
  if(options->indent) indent(stream, depth+1);
  fputs("intercept = ", stream);
  p(options, stream, depth+2, 0, CCODEANCSUB(value, INTERCEPTS));
  fputs(", ", stream);
d181 1
a181 1
  p(options, stream, depth+2, 0, CCODEANCSUB(value, INTERFNS));
@


1.1
log
@new file
@
text
@d13 4
a16 1
 *  $Log: print.c,v $
@
