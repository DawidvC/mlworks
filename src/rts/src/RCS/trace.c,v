head	1.11;
access;
symbols
	MLW_daveb_inline_1_4_99:1.11.1
	MLWorks_21c0_1999_03_25:1.11
	MLWorks_20c1_1998_08_20:1.11
	MLWorks_20c0_1998_08_04:1.11
	MLWorks_20b2c2_1998_06_19:1.11
	MLWorks_20b2_Windows_1998_06_12:1.11
	MLWorks_20b1c1_1998_05_07:1.11
	MLWorks_20b0_1998_04_07:1.11
	MLWorks_20b0_1998_03_20:1.11
	MLWorks_20m2_1998_02_16:1.10
	MLWorks_MM_adapt:1.9.12
	MLWorks_20m1_1997_10_23:1.9
	MLWorks_11r1:1.9.9.1.1.1.1
	MLWorks_workspace_97:1.9.11
	MLWorks_dt_wizard:1.9.10
	MLWorks_11c0_1997_09_09:1.9.9.1.1.1
	MLWorks_10r3:1.9.9.1.3
	MLWorks_10r2_551:1.9.9.1.2
	MLWorks_11:1.9.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.9.9.1
	MLWorks_20m0_1997_06_20:1.9
	MLWorks_1_0_r2c2_1997_06_14:1.9.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.9.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.9.9
	MLWorks_BugFix_1997_04_24:1.9
	MLWorks_1_0_r2_Win32_1997_04_11:1.9
	MLWorks_1_0_r2_Unix_1997_04_04:1.9
	MM_ML_release_korma_1997_04_01:1.9
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.9.7.1.1
	MLWorks_gui_1996_12_18:1.9.8
	MLWorks_1_0_Win32_1996_12_17:1.9.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.9.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.9.4.1
	JFHrts:1.9.6
	MLWorks_1_0_Irix_1996_11_28:1.9.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.9.5
	MLWorks_1_0_Unix_1996_11_14:1.9.4
	MLWorks_Open_Beta2_1996_10_11:1.9.3
	MLWorks_License_dev:1.9.2
	MLWorks_1_open_beta_1996_09_13:1.9.1
	MLWorks_Open_Beta_1996_08_22:1.9
	MLWorks_Beta_1996_07_02:1.9
	MLWorks_Beta_1996_06_07:1.8
	MLWorks_Beta_1996_06_06:1.8
	MLWorks_Beta_1996_06_05:1.8
	MLWorks_Beta_1996_06_03:1.8
	MLWorks_Beta_1996_05_31:1.8
	MLWorks_Beta_1996_05_30:1.8
	hope_poo:1.4.1
	ML_beta_release_12/08/94:1.4.1.1
	ML_beta_release_03/08/94:1.4;
locks; strict;
comment	@ * @;


1.11
date	98.02.23.18.42.20;	author jont;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	98.01.29.16.24.27;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	96.06.19.13.40.39;	author nickb;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1
	1.9.4.1
	1.9.5.1
	1.9.6.1
	1.9.7.1
	1.9.8.1
	1.9.9.1
	1.9.10.1
	1.9.11.1
	1.9.12.1;
next	1.8;

1.8
date	96.02.16.12.50.24;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.03.15.12.34.43;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.02.20.15.04.42;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	94.10.19.14.31.05;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	94.06.23.09.35.51;	author nickh;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	94.06.21.16.02.17;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.53.56;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.11.30.01;	author nickh;	state Exp;
branches;
next	;

1.4.1.1
date	95.07.05.10.28.35;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	96.09.13.11.22.03;	author hope;	state Exp;
branches;
next	;

1.9.2.1
date	96.10.07.16.12.08;	author hope;	state Exp;
branches;
next	;

1.9.3.1
date	96.10.17.11.31.03;	author hope;	state Exp;
branches;
next	;

1.9.4.1
date	96.11.14.12.56.57;	author hope;	state Exp;
branches
	1.9.4.1.1.1;
next	;

1.9.4.1.1.1
date	96.11.28.15.07.13;	author hope;	state Exp;
branches;
next	;

1.9.5.1
date	96.11.22.18.14.54;	author hope;	state Exp;
branches;
next	;

1.9.6.1
date	96.12.17.10.01.41;	author hope;	state Exp;
branches;
next	;

1.9.7.1
date	96.12.17.17.53.26;	author hope;	state Exp;
branches
	1.9.7.1.1.1;
next	;

1.9.7.1.1.1
date	97.02.24.11.44.24;	author hope;	state Exp;
branches;
next	;

1.9.8.1
date	96.12.18.09.47.59;	author hope;	state Exp;
branches;
next	;

1.9.9.1
date	97.05.12.10.40.24;	author hope;	state Exp;
branches
	1.9.9.1.1.1
	1.9.9.1.2.1
	1.9.9.1.3.1;
next	;

1.9.9.1.1.1
date	97.07.28.18.26.09;	author daveb;	state Exp;
branches
	1.9.9.1.1.1.1.1;
next	;

1.9.9.1.1.1.1.1
date	97.10.07.11.51.58;	author jkbrook;	state Exp;
branches;
next	;

1.9.9.1.2.1
date	97.09.08.17.19.22;	author daveb;	state Exp;
branches;
next	;

1.9.9.1.3.1
date	97.09.09.14.15.30;	author daveb;	state Exp;
branches;
next	;

1.9.10.1
date	97.09.10.19.32.35;	author brucem;	state Exp;
branches;
next	;

1.9.11.1
date	97.09.11.21.01.53;	author daveb;	state Exp;
branches;
next	;

1.9.12.1
date	97.10.31.13.44.48;	author nickb;	state Exp;
branches;
next	;

1.11.1.1
date	99.04.01.18.01.28;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.11
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@/*  ==== PERVASIVE TRACE ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Description
 *  -----------
 *
 *  Revision Log
 *  ------------
 *  $Log: src:trace.c,v $
 * Revision 1.10  1998/01/29  16:24:27  jont
 * [Bug #70054]
 * Add missing declare and retract root calls
 * Also added missing declare_root call for trace_ml_apply_all_function
 *
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
 * Revision 1.8  1996/02/16  12:50:24  nickb
 * Change to declare_global().
 *
 * Revision 1.7  1995/03/15  12:34:43  nickb
 * Manipulation of new implicit vector entries changes for threads.
 *
 * Revision 1.6  1995/02/20  15:04:42  matthew
 * Adding interface to implicit vector debugger functions
 *
 * Revision 1.5  1994/10/19  14:31:05  nickb
 * Use the invalid value from code_status enum.
 *
 * Revision 1.4  1994/06/23  09:35:51  nickh
 * Add untrace_all.
 *
 * Revision 1.3  1994/06/21  16:02:17  nickh
 * New ancillary structure and forced GC on image save.
 *
 * Revision 1.2  1994/06/09  14:53:56  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:30:01  nickh
 * new file
 *
 * Revision 1.5  1993/04/15  13:12:33  richard
 * Ripped out old tracing mechanism and installed a new one.
 *
 * Revision 1.4  1993/02/01  16:04:33  richard
 * Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 * Revision 1.3  1992/11/19  15:12:56  clive
 * Removed the maintaince of a list of traced functions
 *
 * Revision 1.2  1992/11/16  14:11:04  clive
 * Need to make the address of call_traced_code available to stacks.c
 *
 * Revision 1.1  1992/11/13  16:43:53  clive
 * Initial revision
 *
 *
 */

#include <errno.h>

#include "environment.h"
#include "values.h"
#include "allocator.h"
#include "implicit.h"
#include "tags.h"
#include "interface.h"
#include "intercept.h"
#include "exceptions.h"
#include "utils.h"
#include "trace.h"
#include "loader.h"
#include "global.h"
#include "gc.h"

static void internal_trace_intercept(mlval code,mlval f)
{
  if(code_intercept(code)) {
    switch(errno) {
    case EINTERCEPTFORM:
      exn_raise_string(perv_exn_ref_trace, "Function was not compiled with tracing enabled");
      
    default:
      error("internal_trace_intercept: Unexpected error %d from code_intercept()", errno);
    }
  } else
    CCODE_SET_INTERFN(code,f);
}

static mlval trace_intercept(mlval arg)
{
  mlval code = FIELD(FIELD(arg, 0), 0);
  mlval f = FIELD (arg,1);
  internal_trace_intercept (code,f);
  return (MLUNIT);
}

static mlval trace_code_intercept(mlval arg)
{
  mlval code = FIELD(arg, 0);
  mlval f = FIELD (arg,1);
  internal_trace_intercept (code,f);
  return (MLUNIT);
}

static void internal_trace_replace(mlval code,mlval f)
{
  if(code_replace(code)) {
    switch(errno) {
    case EINTERCEPTFORM:
      exn_raise_string(perv_exn_ref_trace, "Function was not compiled with tracing enabled");
      
    default:
      error("trace_replace: Unexpected error %d from code_replace()", errno);

    }
  } else
    CCODE_SET_INTERFN(code, f);
}


static mlval trace_replace(mlval arg)
{
  mlval code = FIELD(FIELD(arg, 0), 0);
  mlval f = FIELD (arg,1);
  internal_trace_replace (code,f);
  return (MLUNIT);
}

static mlval trace_code_replace(mlval arg)
{
  mlval code = FIELD(arg, 0);
  mlval f = FIELD (arg,1);
  internal_trace_replace (code,f);
  return (MLUNIT);
}

static mlval trace_restore(mlval arg)
{
  mlval code = FIELD(arg, 0);

  if(code_nop(code)) {
    switch(errno) {
    case EINTERCEPTFORM:
      exn_raise_string(perv_exn_ref_trace, "Function was not compiled with tracing enabled");
      
    default:
      error("trace_restore: Unexpected error %d from code_nop()", errno);
    }
  } else 
    CCODE_SET_INTERFN(code, MLUNIT);

  return(MLUNIT);
}
/*
                datatype status = INTERCEPT | NONE | REPLACE | UNTRACEABLE
*/
static mlval trace_status(mlval arg)
{
  switch(code_status(FIELD(arg, 0)))
  {
    /* See datatype MLWorks.Internal.Trace.status */
    /*      = INTERCEPT | NONE | REPLACE | UNTRACEABLE */
    case CS_INTERCEPT:	return(MLINT(0));
    case CS_NOP:	return(MLINT(1));
    case CS_REPLACE:	return(MLINT(2));
    case CS_INVALID:
      switch(errno) {
      case EINTERCEPTFORM:
	return (MLINT(3));

      default:
      error("trace_status: Unexpected error %d from code_status()", errno);
    }

    default:
    error("trace_status: Unexpected return value from code_status()");
  }
}

static mlval trace_restore_code(unsigned int index, mlval code)
{
  if (CCODE_CAN_INTERCEPT(code) && code_nop(code))
    error("trace_restore_code: Unexpected error %d from code_nop()", errno);

  return code;
}

static mlval trace_restore_all(mlval unit)
{
  weak_apply(loader_code,trace_restore_code);
  return MLUNIT;
}

static mlval trace_ml_apply_all_function = MLUNIT;

/* This only called on functions compiled for tracing */
static mlval trace_ml_apply (unsigned int index, mlval code)
{
  if (trace_ml_apply_all_function == MLUNIT)
    error("trace_ml_apply: function not set");
  else
    if (CCODE_CAN_INTERCEPT(code)) {
      declare_root(&code, 0);
      callml (code,trace_ml_apply_all_function);
      retract_root(&code);
    }
  return (code);
}

static mlval trace_ml_apply_all (mlval f)
{
  trace_ml_apply_all_function = f;
  weak_apply (loader_code,trace_ml_apply);
  trace_ml_apply_all_function = MLUNIT;
  return (MLUNIT);
}

static mlval trace_loader_ml_function = MLUNIT;

static void trace_loader_function (mlval code)
{
  if (trace_loader_ml_function != MLUNIT)
    if (CCODE_CAN_INTERCEPT(code))
      callml (code,trace_loader_ml_function);
}

static mlval trace_set_code_loader_function (mlval arg)
{
  trace_loader_ml_function = arg;
  loader_code_trace_observer = trace_loader_function;
  return (MLUNIT);
}

static mlval trace_unset_code_loader_function (mlval unit)
{
  trace_loader_ml_function = MLUNIT;
  loader_code_trace_observer = NULL;
  return (MLUNIT);
}
  
void trace_init()
{
  declare_global("trace loader ml function", &trace_loader_ml_function,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);

  env_function("trace ml apply all", trace_ml_apply_all);
  env_function("trace set code loader function", trace_set_code_loader_function);
  env_function("trace unset code loader function", trace_unset_code_loader_function);
  env_function("trace intercept", trace_intercept);
  env_function("trace replace", trace_replace);
  env_function("trace code intercept", trace_code_intercept);
  env_function("trace code replace", trace_code_replace);
  env_function("trace restore", trace_restore);
  env_function("trace status", trace_status);
  env_function("trace restore all", trace_restore_all);
  declare_root(&trace_ml_apply_all_function, 1);
}
@


1.11.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a10 5
 * Revision 1.11  1998/02/23  18:42:20  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
@


1.10
log
@[Bug #70054]
Add missing declare and retract root calls
Also added missing declare_root call for trace_ml_apply_all_function
@
text
@d11 5
d205 1
a205 1
      declare_root(&code);
d258 1
a258 1
  declare_root(&trace_ml_apply_all_function);
@


1.9
log
@Make trace status return a new code for "not traceable".
@
text
@d11 3
d70 1
d199 5
a203 2
    if (CCODE_CAN_INTERCEPT(code))
	callml (code,trace_ml_apply_all_function);
d253 1
@


1.9.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a10 3
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
@


1.9.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a10 3
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
@


1.9.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a10 3
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
@


1.9.9.1
log
@branched from 1.9
@
text
@a10 3
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
@


1.9.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a10 3
 * Revision 1.9.9.1  1997/05/12  10:40:24  hope
 * branched from 1.9
 *
@


1.9.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a10 3
 * Revision 1.9.9.1  1997/05/12  10:40:24  hope
 * branched from 1.9
 *
@


1.9.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a10 3
 * Revision 1.9.9.1  1997/05/12  10:40:24  hope
 * branched from 1.9
 *
@


1.9.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a10 3
 * Revision 1.9.9.1.1.1  1997/07/28  18:26:09  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.9.8.1
log
@branched from 1.9
@
text
@a10 3
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
@


1.9.7.1
log
@branched from 1.9
@
text
@a10 3
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
@


1.9.7.1.1.1
log
@branched from 1.9.7.1
@
text
@a10 3
 * Revision 1.9.7.1  1996/12/17  17:53:26  hope
 * branched from 1.9
 *
@


1.9.6.1
log
@branched from 1.9
@
text
@a10 3
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
@


1.9.5.1
log
@branched from 1.9
@
text
@a10 3
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
@


1.9.4.1
log
@branched from 1.9
@
text
@a10 3
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
@


1.9.4.1.1.1
log
@branched from 1.9.4.1
@
text
@a10 3
 * Revision 1.9.4.1  1996/11/14  12:56:57  hope
 * branched from 1.9
 *
@


1.9.3.1
log
@branched from 1.9
@
text
@a10 3
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
@


1.9.2.1
log
@branched from 1.9
@
text
@a10 3
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
@


1.9.1.1
log
@branched from 1.9
@
text
@a10 3
 * Revision 1.9  1996/06/19  13:40:39  nickb
 * Make trace status return a new code for "not traceable".
 *
@


1.8
log
@Change to declare_global().
@
text
@d11 3
d147 3
a149 1

d155 1
a158 1

d160 1
a160 2
    switch(errno)
    {
d162 1
a162 1
      exn_raise_string(perv_exn_ref_trace, "Function was not compiled with tracing enabled");
@


1.7
log
@Manipulation of new implicit vector entries changes for threads.
@
text
@d11 3
d229 2
a230 1
  declare_global("trace loader ml function", &trace_loader_ml_function, NULL);
@


1.6
log
@Adding interface to implicit vector debugger functions
@
text
@d11 3
a223 24
static mlval set_breakpoint_function (mlval arg)
{
  implicit_vector.breakpoint_fn = arg;
  return (MLUNIT);
}

static mlval set_exit_breakpoint_function (mlval arg)
{
  implicit_vector.exit_breakpoint_fn = arg;
  return (MLUNIT);
}

static mlval set_stepper_function (mlval arg)
{
  implicit_vector.stepper_fn = arg;
  return (MLUNIT);
}

static mlval set_stepper_handler_function (mlval arg)
{
  implicit_vector.stepper_handler_fn = arg;
  return (MLUNIT);
}

a225 5
  declare_global("debugger breakpoint fn", &implicit_vector.breakpoint_fn, NULL);
  declare_global("debugger stepper fn", &implicit_vector.stepper_fn, NULL);
  declare_global("debugger exit breakpoint fn", &implicit_vector.exit_breakpoint_fn, NULL);
  declare_global("debugger stepper handler fn", &implicit_vector.stepper_handler_fn, NULL);

a227 4
  env_function("debugger set breakpoint function",set_breakpoint_function);
  env_function("debugger set stepper function",set_stepper_function);
  env_function("debugger set exit breakpoint function",set_exit_breakpoint_function);
  env_function("debugger set stepper handler function",set_stepper_handler_function);
@


1.5
log
@Use the invalid value from code_status enum.
@
text
@d11 3
d59 1
a59 1
static mlval trace_intercept(mlval arg)
a60 2
  mlval code = FIELD(FIELD(arg, 0), 0);

d67 1
a67 1
      error("trace_intercept: Unexpected error %d from code_intercept()", errno);
d70 2
a71 1
    CCODE_SET_INTERFN(code, FIELD(arg, 1));
d73 6
a78 1
  return(MLUNIT);
d81 1
a81 1
static mlval trace_replace(mlval arg)
d83 5
a87 1
  mlval code = FIELD(FIELD(arg, 0), 0);
d89 2
d101 11
a111 1
    CCODE_SET_INTERFN(code, FIELD(arg, 1));
d113 6
a118 1
  return(MLUNIT);
d176 69
a244 1
    
d247 14
d263 2
@


1.4
log
@Add untrace_all.
@
text
@d11 3
d120 1
a120 1
    case -1:
@


1.4.1.1
log
@branched from 1.4
@
text
@a10 3
 * Revision 1.4  1994/06/23  09:35:51  nickh
 * Add untrace_all.
 *
@


1.3
log
@New ancillary structure and forced GC on image save.
@
text
@d11 3
d50 2
d131 14
d152 1
@


1.2
log
@new file
@
text
@d11 3
d52 3
a54 6
  CCODEANCUPDATE(code, INTERFNS, FIELD(arg, 1));

  if(code_intercept(code))
    switch(errno)
    {
      case EINTERCEPTFORM:
d56 2
a57 2

      default:
d60 2
d70 3
a72 6
  CCODEANCUPDATE(code, INTERFNS, FIELD(arg, 1));

  if(code_replace(code))
    switch(errno)
    {
      case EINTERCEPTFORM:
d74 3
a77 2
      default:
      error("trace_replace: Unexpected error %d from code_replace()", errno);
d79 2
d89 3
a91 6
  CCODEANCUPDATE(code, INTERFNS, MLUNIT);

  if(code_nop(code))
    switch(errno)
    {
      case EINTERCEPTFORM:
d93 2
a94 2

      default:
d97 2
@


1.1
log
@new file
@
text
@d10 4
a13 1
 *  $Log: trace.c,v $
@
