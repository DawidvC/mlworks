head	1.23;
access;
symbols
	MLW_daveb_inline_1_4_99:1.23.1
	MLWorks_21c0_1999_03_25:1.23
	MLWorks_20c1_1998_08_20:1.22
	MLWorks_20c0_1998_08_04:1.21
	MLWorks_20b2c2_1998_06_19:1.19
	MLWorks_20b2_Windows_1998_06_12:1.19
	MLWorks_20b1c1_1998_05_07:1.18
	MLWorks_20b0_1998_04_07:1.16
	MLWorks_20b0_1998_03_20:1.16
	MLWorks_20m2_1998_02_16:1.16
	MLWorks_MM_adapt:1.16.3
	MLWorks_20m1_1997_10_23:1.16
	MLWorks_11r1:1.15.6.1.1.1.1
	MLWorks_workspace_97:1.16.2
	MLWorks_dt_wizard:1.16.1
	MLWorks_11c0_1997_09_09:1.15.6.1.1.1
	MLWorks_10r3:1.15.6.1.3
	MLWorks_10r2_551:1.15.6.1.2
	MLWorks_11:1.15.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.15.6.1
	MLWorks_20m0_1997_06_20:1.16
	MLWorks_1_0_r2c2_1997_06_14:1.15.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.15.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.15.6
	MLWorks_BugFix_1997_04_24:1.16
	MLWorks_1_0_r2_Win32_1997_04_11:1.15
	MLWorks_1_0_r2_Unix_1997_04_04:1.15
	MM_ML_release_korma_1997_04_01:1.15
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.15.4.1.1
	MLWorks_gui_1996_12_18:1.15.5
	MLWorks_1_0_Win32_1996_12_17:1.15.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.15.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.15.1.1
	JFHrts:1.15.3
	MLWorks_1_0_Irix_1996_11_28:1.15.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.15.2
	MLWorks_1_0_Unix_1996_11_14:1.15.1
	MLWorks_Open_Beta2_1996_10_11:1.14.3
	MLWorks_License_dev:1.14.2
	MLWorks_1_open_beta_1996_09_13:1.14.1
	MLWorks_Open_Beta_1996_08_22:1.13
	MLWorks_Beta_1996_07_02:1.13
	MLWorks_Beta_1996_06_07:1.13
	MLWorks_Beta_1996_06_06:1.13
	MLWorks_Beta_1996_06_05:1.13
	MLWorks_Beta_1996_06_03:1.13
	MLWorks_Beta_1996_05_31:1.13
	MLWorks_Beta_1996_05_30:1.13
	hope_poo:1.2.1
	ML_beta_release_12/08/94:1.2.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.23
date	98.10.23.14.09.15;	author jont;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	98.08.17.11.34.54;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	98.07.15.15.21.02;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	98.07.09.12.19.44;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	98.05.20.14.03.21;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	98.04.24.13.11.25;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	98.04.23.14.12.19;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	97.04.11.13.49.24;	author stephenb;	state Exp;
branches
	1.16.1.1
	1.16.2.1
	1.16.3.1;
next	1.15;

1.15
date	96.10.29.16.07.52;	author nickb;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1
	1.15.4.1
	1.15.5.1
	1.15.6.1;
next	1.14;

1.14
date	96.08.23.15.24.32;	author nickb;	state Exp;
branches
	1.14.1.1
	1.14.2.1
	1.14.3.1;
next	1.13;

1.13
date	96.05.14.16.08.57;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	96.02.13.17.24.57;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	96.01.16.11.52.02;	author nickb;	state Exp;
branches;
next	1.10;

1.10
date	96.01.09.11.19.20;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	95.07.17.08.58.41;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.03.28.13.08.08;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.03.07.16.25.51;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.03.02.11.48.05;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	95.02.28.16.49.19;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	95.02.27.16.54.55;	author nickb;	state Exp;
branches;
next	1.3;

1.3
date	94.10.13.12.36.28;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.46.37;	author nickh;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	94.06.09.11.17.11;	author nickh;	state Exp;
branches;
next	;

1.2.1.1
date	95.07.05.10.31.11;	author hope;	state Exp;
branches;
next	;

1.14.1.1
date	96.09.13.11.23.33;	author hope;	state Exp;
branches;
next	;

1.14.2.1
date	96.10.07.16.13.45;	author hope;	state Exp;
branches;
next	;

1.14.3.1
date	96.10.17.11.33.11;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	96.11.14.12.58.55;	author hope;	state Exp;
branches
	1.15.1.1.1.1;
next	;

1.15.1.1.1.1
date	96.11.28.15.08.54;	author hope;	state Exp;
branches;
next	;

1.15.2.1
date	96.11.22.18.16.37;	author hope;	state Exp;
branches;
next	;

1.15.3.1
date	96.12.17.10.03.22;	author hope;	state Exp;
branches;
next	;

1.15.4.1
date	96.12.17.17.55.00;	author hope;	state Exp;
branches
	1.15.4.1.1.1;
next	;

1.15.4.1.1.1
date	97.02.24.11.46.08;	author hope;	state Exp;
branches;
next	;

1.15.5.1
date	96.12.18.09.49.35;	author hope;	state Exp;
branches;
next	;

1.15.6.1
date	97.05.12.10.42.00;	author hope;	state Exp;
branches
	1.15.6.1.1.1
	1.15.6.1.2.1
	1.15.6.1.3.1;
next	;

1.15.6.1.1.1
date	97.07.28.18.29.37;	author daveb;	state Exp;
branches
	1.15.6.1.1.1.1.1;
next	;

1.15.6.1.1.1.1.1
date	97.10.07.11.55.27;	author jkbrook;	state Exp;
branches;
next	;

1.15.6.1.2.1
date	97.09.08.17.22.36;	author daveb;	state Exp;
branches;
next	;

1.15.6.1.3.1
date	97.09.09.14.18.39;	author daveb;	state Exp;
branches;
next	;

1.16.1.1
date	97.09.10.19.38.11;	author brucem;	state Exp;
branches;
next	;

1.16.2.1
date	97.09.11.21.05.53;	author daveb;	state Exp;
branches;
next	;

1.16.3.1
date	97.10.31.13.48.57;	author nickb;	state Exp;
branches;
next	;

1.23.1.1
date	99.04.01.18.04.35;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.23
log
@[Bug #70219]
Make stack backtrace function easily available
@
text
@/*  ==== GLOBAL MEMORY MANAGEMENT ====
 *
 *  Copyright (C) 1992 Harelquin Ltd
 *
 *  Revision Log
 *  ------------
 *  $Log: src:mem.c,v $
 * Revision 1.22  1998/08/17  11:34:54  jont
 * [Bug #70153]
 * Add validate_ml_address
 *
 * Revision 1.21  1998/07/15  15:21:02  jont
 * [Bug #20134]
 * Use address validation outside of ml heap
 *
 * Revision 1.20  1998/07/09  12:19:44  jont
 * [Bug #70122]
 * Update space_gen when arrays are unmade to avoid dangling pointers
 *
 * Revision 1.19  1998/05/20  14:03:21  jont
 * [Bug #70035]
 * Add a validate address function
 *
 * Revision 1.18  1998/04/24  13:11:25  jont
 * [Bug #70032]
 * gen->values now measured in bytes
 *
 * Revision 1.17  1998/04/23  14:12:19  jont
 * [Bug #70034]
 * Rationalising names in mem.h
 *
 * Revision 1.16  1997/04/11  13:49:24  stephenb
 * [Bug #1659]
 * Double C_STACK_SIZE to avoid the stack overflowing when
 * MakeCachedDirEntry in the OpenWindows library is called
 * which wants to allocate 65K of stack!
 *
 * Revision 1.15  1996/10/29  16:07:52  nickb
 * Fix space lookup for pointers with top bit set.
 *
 * Revision 1.14  1996/08/23  15:24:32  nickb
 * Extend generation structure to allow better GC triggering.
 *
 * Revision 1.13  1996/05/14  16:08:57  nickb
 * Add out-of-memory hook.
 *
 * Revision 1.12  1996/02/13  17:24:57  jont
 * Add some type casts to allow compilation without warnings under VC++
 *
 * Revision 1.11  1996/01/16  11:52:02  nickb
 * Remove "storage manager" interface; replace it with regular functions.
 *
 * Revision 1.10  1996/01/09  11:19:20  nickb
 * change event signalling for stack overflow.
 *
 * Revision 1.9  1995/07/17  08:58:41  nickb
 * Change to definition of OBJECT_SIZE macro.
 *
 * Revision 1.8  1995/03/28  13:08:08  nickb
 * Add C stack support for threads.
 *
 * Revision 1.7  1995/03/07  16:25:51  nickb
 * Extend static object header to have a generation pointer.
 *
 * Revision 1.6  1995/03/02  11:48:05  nickb
 * Finish static object allocation code
 *
 * Revision 1.4  1995/02/27  16:54:55  nickb
 * TYPE_LARGE becomes TYPE_STATIC
 *
 * Revision 1.3  1994/10/13  12:36:28  nickb
 * Change to the arena manager to allow arbitrary numbers of blocks.
 *
 * Revision 1.2  1994/06/09  14:46:37  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:17:11  nickh
 * new file
 *
 *  Revision 2.13  1994/01/28  17:47:57  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 2.11  1993/12/15  14:45:17  nickh
 *  Added get_stack_block_limit() and some comments.
 *
 *  Revision 2.10  1993/10/12  16:12:50  matthew
 *  Merging bug fixes
 *
 *  Revision 2.9.1.2  1993/10/12  15:02:19  matthew
 *  Added stack_block_count stuff -- do a kill 30 if limit exceeded and go into debugger
 *  If stack_block_count <= 0, then behave as before
 *
 *  Revision 2.9.1.1  1993/06/02  13:14:00  jont
 *  Fork for bug fixing
 *
 *  Revision 2.9  1993/06/02  13:14:00  richard
 *  Improved the use of const on the argv parameter type.
 *
 *  Revision 2.8  1993/04/30  14:29:31  jont
 *  Changed to distinguish the real base of the stack from the stack limit
 *  pointer
 *
 *  Revision 2.7  1993/04/30  12:54:10  richard
 *  Multiple arguments can now be passed to the storage manager in a general
 *  way.
 *
 *  Revision 2.6  1993/04/28  13:24:57  richard
 *  Increased diagnostic levels.
 *  Rewrote Matthew's code for caching stack blocks.
 *
 *  Revision 2.5  1993/01/27  13:36:40  matthew
 *  Added a cache of stack blocks that get reused rather than deallocated.
 *
 *  Revision 2.4  1992/12/07  16:53:37  richard
 *  Corrected method of creation the heap on the first call.
 *
 *  Revision 2.3  1992/08/18  11:20:01  richard
 *  Changed the types of is_ml_stack and is_ml_heap.
 *
 *  Revision 2.2  1992/08/17  10:48:01  richard
 *  Added a missing newline at the end of sm_size_help.
 *
 *  Revision 2.1  1992/08/04  11:25:59  richard
 *  New version using a separate arena manager.  This code
 *  now deals with descriptors only.
 *
 *  Revision 1.23  1992/07/28  15:06:51  jont
 *  Increased mamximum generations to 15
 *
 *  Revision 1.22  1992/07/27  15:04:54  richard
 *  Corrected the check for memory overflow.
 *
 *  Revision 1.21  1992/07/21  15:25:16  richard
 *  Removed call to init_alloc() according to new interface with runtime
 *  system.  Added a help string for the `-size' option.  Changed the
 *  generation configuration as an experiment.
 *
 *  Revision 1.20  1992/07/16  16:14:56  richard
 *  Added an efficient implementation of is_ml_frame().  Removed the
 *  stack base field from stack descriptors.  GC_SP is no longer
 *  initialised here.
 *
 *  Revision 1.19  1992/07/14  15:43:10  richard
 *  Added stack_base field to stacks.  Initially set GC_HEAP_START
 *  and _LIMIT to zero to force a call to the GC.
 *
 *  Revision 1.18  1992/07/01  11:26:40  richard
 *  Changed the types of some fields in generation and space
 *  structures to reduce the number of casts.  Removed references
 *  to ml_state in favour of stuff declared in storeman.h.
 *
 *  Revision 1.17  1992/06/29  15:00:04  richard
 *  Added some missing initialization.  Implemented experimental
 *  memory mapping scheme.
 *
 *  Revision 1.17  1992/06/26  15:57:01  richard
 *  Added some missing initialization of large space pointers.
 *  Installed an experimental memory mapping scheme.
 *
 *  Revision 1.16  1992/06/23  14:15:28  richard
 *  Implemented deallocate_blocks() and resize() to introduce some hysteresis
 *  into process extension.
 *
 *  Revision 1.15  1992/06/04  10:32:36  richard
 *  Changed generation size tables to something more sensible.
 *  Added check for maximum number of generations.
 *
 *  Revision 1.14  1992/03/19  16:50:06  richard
 *  Generation sizes are fetched from arrays defined in mem.h rather than
 *  calculated by macros.
 *
 *  Revision 1.13  1992/03/16  14:23:54  richard
 *  Corrected definition of unmake_space().  Moved MAXGEN to mem.h.
 *
 *  Revision 1.12  1992/03/12  12:42:17  richard
 *  Added top_generation parameter to specify number of generations to
 *  allocate initially.
 *
 *  Revision 1.10  1992/02/13  15:08:30  clive
 *  First attempt at using allocate_blocks to get memory at loading time
 *
 *  Revision 1.9  1992/01/27  14:13:07  richard
 *  Changed the way the malloc() zone is set up.  Changed make_gen() to
 *  make_semispace() and wrote a new make_gen() which makes a whole
 *  generation.  Added entry table with initialization.  Removed
 *  initial creation of generations: they are now created on demand by
 *  the garbage collector controller.
 *
 *  Revision 1.8  1992/01/20  11:43:42  richard
 *  Added initialization of entry lists in generations.
 *
 *  Revision 1.7  1992/01/17  11:43:18  richard
 *  Removed fragile version of malloc() and free().  See new alloc.h.
 *
 *  Revision 1.6  1992/01/13  14:41:40  richard
 *  Added unmake_stack.
 *
 *  Revision 1.5  1992/01/08  12:50:50  richard
 *  Added a stack size parameter to make_stack().
 *
 *  Revision 1.4  1991/12/23  13:24:01  richard
 *  Added some missing type casts now that we have some more ANSI-like
 *  headers.
 *
 *  Revision 1.3  91/12/19  16:08:46  richard
 *  Rewrote get_blocks so that it works.  Changed crash output so
 *  that it fits in with the rest of the system.
 *
 *  Revision 1.2  91/12/17  17:23:01  nickh
 *  added header and comment.
 *
 *  Revision 1.1  91/12/17  16:17:58  nickh
 *  Initial revision
 */

#include "syscalls.h"
#include "mem.h"
#include "gc.h"
#include "arena.h"
#include "types.h"
#include "state.h"
#include "utils.h"
#include "values.h"
#include "alloc.h"
#include "diagnostic.h"
#include "extensions.h"
#include "options.h"
#include "event.h"
#include "pervasives.h"
#include "stubs.h"
#include "os.h"
#include "stacks.h"

#include <errno.h>
#include <sys/types.h>

struct ml_heap *space_gen[SPACES_IN_ARENA];

/*  === STACK AND HEAP AREAS ===
 *
 *  These are allocated from the `blocked' part of the arena.
 */

/*  == Stack block cache ==
 *
 *  Stack blocks are cached in a simple free list in order to provide some
 *  hysteresis on stack extensions.  This prevents too many allocations and
 *  deallocations of blocks from the arena.
 */

#define STACK_CACHE_SIZE_MAX	10

static struct ml_stack *stack_cache = NULL;
static size_t stack_cache_size = 0, stack_total = 0;

static stack_blocks = 0;

/*  == Making and unmaking stacks == */

struct ml_stack *make_ml_stack(struct ml_stack *parent, size_t size)
{
  struct ml_stack *stack;

  DIAGNOSTIC(4, "make_ml_stack(0x%lX, 0x%lX)", parent, size);

  /* If there is a stack block on the free list and it is large enough, use */
  /* it first. */

  if(stack_cache && (byte *)stack_cache->top - (byte *)stack_cache >= (int)size) {
    stack = stack_cache;
    stack_cache = stack->parent;
    stack->parent = parent;
    --stack_cache_size;
  } else {
    int max_blocks =
      (max_stack_blocks == MLUNIT) ? 0 :
	CINT(DEREF(max_stack_blocks));

    /* allocate a new stack block */
    size = BLOCKROUND(size);
    stack = (struct ml_stack *)block_alloc(TYPE_ML_STACK, size);
    stack->parent = parent;
    stack->top    = (struct stack_frame *)((byte *)stack + size);
    DIAGNOSTIC(4, "  at 0x%lX with top at 0x%X", stack, stack->top);

    /* check for stack overflow. If overflowed, we record an event */
    stack_blocks++;
    if ((max_blocks > 0) &&
	(stack_blocks > max_blocks))
      record_event(EV_STACK,(word)0);

    stack_total += size;
    DIAGNOSTIC(1, "Stack increased to %uK", stack_total>>10, 0);
  }

  return(stack);
}

struct ml_stack *unmake_ml_stack(struct ml_stack *stack)
{
  struct ml_stack *parent = stack->parent;

  DIAGNOSTIC(4, "unmake_ml_stack(0x%lX) parent 0x%lX", stack, stack->parent);

  if(stack_cache_size >= STACK_CACHE_SIZE_MAX)
  {
    /* free this block */
    size_t size = (byte *)stack->top - (byte *)stack;
    block_free((byte *)stack, size);
    stack_total -= size;
    --stack_blocks;
    DIAGNOSTIC(1, "Stack decreased to %uK", stack_total>>10, 0);
  }
  else
  {
    /* return this block to the stack cache */
    stack->parent = stack_cache;
    stack_cache = stack;
    ++stack_cache_size;
  }

  return(parent);
}

/* unwind a stack back to a particular frame; this is called from
 * an assembly-language routine to unwind when handling exceptions */

void unwind_stack(struct stack_frame *sp)
{
  struct ml_stack *stack = STACK_BASE(GC_STACK(CURRENT_THREAD));

  while(sp < (struct stack_frame *)stack || sp >= stack->top)
    stack = unmake_ml_stack(stack);

  GC_STACK(CURRENT_THREAD) = (mlval) STACK_LIMIT(stack);
}



/*
** The maximum initial stack space (in words) needed by any architecture.
** Currently, the maximum value comes from the SPARC where 16 words
** are needed for a register window.
*/
#define C_STACK_ADJUST 16


/*
** The original value (65536) was chosen so that it was (to quote NickB) :-
**
**   big enough to run MLWorks, small enough that it won't bloat memory
**   even if we have lots of threads
**
** It has been doubled as the initial fix to bug 1659.  The size should
** be re-evaluated again when bug/task 2047 is tackled.
*/
#define C_STACK_SIZE (2*65536)


struct c_stack *make_c_stack(void)
{
  struct c_stack *stack = 
    (struct c_stack *)alloc(sizeof (struct c_stack),"C stack descriptor");

  stack->base = (char*)block_alloc(TYPE_C_STACK,C_STACK_SIZE);
  stack->top =
    (struct stack_frame *)((word)stack->base + C_STACK_SIZE-C_STACK_ADJUST);
  return stack;
}



void free_c_stack(struct c_stack *stack)
{
  block_free((byte*)stack->base,C_STACK_SIZE);
  free(stack);
}

void free_ml_stacks(struct ml_stack *stack)
{
  while(stack)
    stack = unmake_ml_stack(stack);
}

/* == Areas for the C heap in the block area == */

struct c_heap *make_heap(struct c_heap *parent, size_t size)
{
  struct c_heap *heap;

  size = BLOCKROUND(size);

  heap = (struct c_heap *)block_alloc(TYPE_C_HEAP, size);

  heap->parent = parent;
  heap->size = size;

  DIAGNOSTIC(4, "make_heap(0x%lX, 0x%lX)", parent, size);
  DIAGNOSTIC(4, "  at 0x%lX", heap, 0);

  return(heap);
}

struct c_heap *unmake_heap(struct c_heap *heap)
{
  struct c_heap *parent = heap->parent;

  DIAGNOSTIC(4, "unmake_heap(0xX) parent 0x%X", heap, parent);

  block_free((byte *)heap, heap->size);

  return(parent);
}

/* == pointer predicates == */

int is_ml_stack(void *p)
{
  return(TYPE(p) == TYPE_ML_STACK);
}

int is_ml_heap(void *p)
{
  unsigned char type = TYPE(p);

  return(type == TYPE_ML_HEAP || type == TYPE_FROM || type == TYPE_ML_STATIC);
}

/*  === STATIC OBJECTS ===
 *
 *  Static objects occupy special spaces in the arena. They are
 * allocated according to a simple first-fit algorithm in the first
 * static space which will accommodate them. */

static struct ml_static_space *static_spaces;

/* allocate a new static space. */

static struct ml_static_space *make_new_static_space(void)
{
  byte *space_ptr = space_alloc(TYPE_ML_STATIC, 0);
  struct ml_static_space *result = 
    (struct ml_static_space *)
      alloc(sizeof(struct ml_static_space),
	    "creating descriptor for space reserved for static objects"); 
  result->forward = static_spaces;
  result->back = static_spaces->back;
  result->forward->back = result;
  result->back->forward = result;
  result->space = SPACE(space_ptr);
  result->mapped = 0;
  result->free_list.mark = 0;
  result->free_list.gen = NULL;
  result->free_list.forward = &result->free_list;
  result->free_list.back = &result->free_list;
  SPACE_STATIC(SPACE(space_ptr)) = result;
  return result;
}
  
/* initialize the static object world by creating a single static space */

static void init_static_objects(void)
{
  /* initialize the first 'static' space */
  static_spaces =
    (struct ml_static_space *)
      alloc(sizeof(struct ml_static_space),
	    "creating descriptor for dummy static object space"); 
  static_spaces->forward = static_spaces;
  static_spaces->back     = static_spaces;
  static_spaces->space    = 0;
  static_spaces->mapped  = SPACE_SIZE;
  static_spaces->free    = 0;
  static_spaces->free_list.mark = 0;
  static_spaces->free_list.gen = NULL;
  static_spaces->free_list.forward = &static_spaces->free_list;
  static_spaces->free_list.back = &static_spaces->free_list;
}

/* Allocate a static object. We do this by first looking for a hole of
 * sufficient size, and failing that by extending one of the static
 * spaces.
 *
 * Notice that holes use the 'mark' slot of the header to register the
 * size in bytes of the hole, including the header. */

struct ml_static_object *make_static_object(size_t bytes)
{
  struct ml_static_space *mappable, *current;
  size_t size = STATIC_SIZE(bytes);
  struct ml_static_object *result;
  
  DIAGNOSTIC(4,"make_static_object(%d)",bytes,0);
  
  if (size > SPACE_SIZE)
    error("Trying to make a static object size %d > %d",size, SPACE_SIZE);
  
  mappable = NULL;
  current = static_spaces->forward;
  while (current != static_spaces) {
    DIAGNOSTIC(5,"  trying space %d",current->space,0);
    if (size <= SPACE_SIZE - current->mapped)
      mappable = current;
    if (size <= current->free) {
      result = current->free_list.forward;
      while(result != &current->free_list) {
	if (size <= result->mark) {
	  DIAGNOSTIC(5,"    hole at 0x%8x size %d",result, result->mark);
	  current->free -= size;
	  if (size == result->mark) {
	    space_remove_hole((byte*)result, size);
	    result->back->forward = result->forward;
	    result->forward->back = result->back;
	    result->mark = 0;
	    return result;
	  } 
	  /* allocate the object in a suffix of this hole */
	  result->mark -= size;
	  result = (struct ml_static_object *)
	    ((byte*)result + result->mark);
	  space_remove_hole((byte*)result, size);
	  result->mark = 0;
	  return result;
	} else
	  /* try the next hole */
	  result = result->forward;
      }
    }
    current = current->forward;
  }

  /* if we get to here, there is no hole large enough, so we map the
   * object at the end of one of the static spaces. If none of the
   * gaps at the end of the static spaces are large enough, we make a
   * new static space. */

  if (!mappable)
    mappable = make_new_static_space();

  DIAGNOSTIC(5,"  appending to space %d",mappable->space,0);
  /* put it at the end of the mappable space */
  result = (struct ml_static_object *)
    (SPACE_BASE(mappable->space) + mappable->mapped);
  mappable->mapped += size;
  space_resize(SPACE_BASE(mappable->space), mappable->mapped);
  result->mark = 0;
  return result;
}

/* Remove a static object. This is called from the GC when it detects
 * that a static object is no longer reachable. It simply adds the
 * object to the free list for that space and merges it with adjacent
 * objects. */

void unmake_static_object(struct ml_static_object *stat)
{
  unsigned int space = SPACE(stat);
  struct ml_static_space *stat_space = SPACE_STATIC(space);
  struct ml_static_object *before, *after;
  mlval header = stat->object[0];
  mlval secondary = SECONDARY(header);
  mlval length = LENGTH(header);

  DIAGNOSTIC(4, "unmake_static_object(0x%X)", stat, 0);

  stat->mark = STATIC_SIZE(OBJECT_SIZE(secondary,length));
  stat->gen = NULL;
  stat_space->free += stat->mark;

  after = &stat_space->free_list;
  do {
    after = after->forward;
  } while (after < stat && after != &stat_space->free_list);
  before = after->back;

  if ((byte*)stat + stat->mark == (byte*) after) {
    stat->mark += after->mark;
    stat->forward = after->forward;
  } else
    stat->forward = after;
  
  if ((byte*)before + before->mark == (byte*) stat) {
    before->mark += stat->mark;
    before->forward = stat->forward;
    stat = before;
  } else
    stat->back = before;
  
  stat->back->forward = stat;
  stat->forward->back = stat;
  
  space_allow_hole((byte*)&stat->object[0],
		   stat->mark-sizeof(struct ml_static_object)+sizeof(mlval));
}

/* When the static objects code breaks, this function is useful to be
   called from gdb:

void print_static_objects(void)
{
  struct ml_static_space *current = static_spaces->forward;
  struct ml_heap *gen = creation;
  printf("free objects: \n");
  while(current != static_spaces) {
    struct ml_static_object *free = current->free_list.forward;
    printf(" static space %d: 0x%x-0x%x\n",current->space,
	   SPACE_BASE(current->space),
	   SPACE_BASE(current->space)+current->mapped);
    while(free != &current->free_list) {
      printf("  object 0x%x-0x%x, size 0x%x\n",free,
	     ((byte*) free) + free->mark,
	     free->mark);
      free = free->forward;
    }
    current = current->forward;
  }
  printf("live objects: \n");
  while (gen != NULL) {
    struct ml_static_object *obj = gen->statics.forward;
    printf(" generation %d\n",gen->number);
    while(obj != &gen->statics) {
      mlval header = obj->object[0];
      mlval secondary = SECONDARY(header);
      mlval length = LENGTH(header);
      size_t size = STATIC_SIZE(OBJECT_SIZE(secondary,length));
      printf("  object 0x%x-0x%x, values 0x%x\n",obj,
	     ((byte*) obj) + size, size);
      obj = obj->forward;
    }
    gen = gen->parent;
  }
}

*/

/*  === GENERATIONS ===
 *
 * Each generation occupies a single `space' in the arena and has a
 * descriptor on the C heap.
 * values and extent are given in bytes
 */

struct ml_heap *make_ml_heap(size_t values, size_t extent)
{
  struct ml_heap *gen;
  byte *space;

  DIAGNOSTIC(2, "make_gen(values = %u, extent = %u)", values, extent);

  if(values > SPACE_SIZE)
    error("An attempt was made to create a generation of size %u",
	  values * sizeof(mlval));

  space = space_alloc(TYPE_ML_HEAP, extent);
  gen = alloc(sizeof(struct ml_heap), "Unable to allocate generation descriptor.");

  gen->number	= 0;
  gen->parent	= gen->child = NULL;
  gen->values	= values;
  gen->start	= (mlval *)space;
  gen->end	= gen->start + space_extent[SPACE(space)]/sizeof(mlval);
  gen->top	= gen->start;
  gen->space    = SPACE(space);
  gen->collect	= (float)0.0;
  gen->entry.the.forward = gen->entry.the.back = &gen->entry;
  gen->nr_entries = 0;
  gen->statics.forward = gen->statics.back = &gen->statics;
  gen->nr_static = 0;

  space_gen[SPACE(space)] = gen;

  DIAGNOSTIC(3, "  descriptor 0x%X  space %d", gen, space);
  DIAGNOSTIC(3, "  start 0x%X  end 0x%X", gen->start, gen->end);

  return(gen);
}

void unmake_ml_heap(struct ml_heap *gen)
{
  space_gen[SPACE(gen->start)] = NULL;
  space_free((byte *)gen->start);
  free(gen);
}

void resize_ml_heap(struct ml_heap *gen, size_t extent)
{
  unsigned int space = gen->space;
  size_t e = extent;

  DIAGNOSTIC(2, "resize_gen(gen = 0x%X, extent = %u)", gen, extent);
  DIAGNOSTIC(3, "  start 0x%X  end 0x%X", gen->start, gen->end);

  if(e > SPACE_SIZE)
    error("An attempt was made to extend a generation to size %u", e);

  space_resize((byte *)gen->start, e);
  gen->end = gen->start + space_extent[space]/sizeof(mlval);

  DIAGNOSTIC(3, "  new end 0x%X", gen->end, 0);
}
  


/*  === INITIALISE MEMORY ===  */

size_t arena_limit;

void sm_init(void)
{
  int i;
  arena_init();
  arena_limit = DEFAULT_ARENA_LIMIT;

  for(i=0; i<SPACES_IN_ARENA; ++i)
    space_gen[i] = NULL;

  init_static_objects();

  /* Make sure that the first allocation enters the gc() and causes the heap */
  /* to be created. */

  creation = NULL;
}

int (*out_of_memory_dialog)(unsigned long int attempt,
			    size_t extent, size_t length) = NULL;

int validate_ml_address(void *addr)
{
  int space = SPACE(addr);
  int type = space_type[space];
  switch(type) {
  case TYPE_RESERVED:
    /* Not managed by the mm */
    /* Possibly in the text or data segments */
    return system_validate_ml_address(addr);
  case TYPE_FREE:
    /* Managed by the mm, but not in use */
    return 0;
  case TYPE_BLOCKS:
    /* Managed for stacks and heaps */
    switch (TYPE(addr)) {
    case TYPE_ML_STACK:
    case TYPE_C_HEAP:
    case TYPE_C_STACK:
      return 1;
    case TYPE_FREE:
      return 0;
    default:
      error_without_alloc("Unknown block type found in validate_ml_address");
    }
  case TYPE_ML_HEAP:
  case TYPE_FROM:
    /* FROM is just a special case of ML_HEAP */
  case TYPE_ML_STATIC:
    return (((void *)(SPACE_BASE(space))) <= addr) && (addr <= ((void *)((SPACE_BASE(space)) + space_extent[space])));
  default:
    error_without_alloc("Unknown space type found in validate_ml_address");
  }
}

int validate_address(void *addr)
{
  if (validate_ml_address(addr)) {
    return 1;
  } else {
    int space = SPACE(addr);
    int type = space_type[space];
    switch(type) {
    case TYPE_RESERVED:
      /* Not managed by the mm */
      /* Possibly in the text or data segments */
      return system_validate_address(addr);
    default:
      /* Don't bother with system_validate_address for this case */
      return 0;
    }
  }
}

extern void ml_backtrace(int depth_max)
{
  backtrace((struct stack_frame *)&(CURRENT_THREAD->ml_state.sp), CURRENT_THREAD, depth_max);
}
@


1.23.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 4
 * Revision 1.23  1998/10/23  14:09:15  jont
 * [Bug #70219]
 * Make stack backtrace function easily available
 *
@


1.22
log
@[Bug #70153]
Add validate_ml_address
@
text
@d8 4
d232 1
d779 5
@


1.21
log
@[Bug #20134]
Use address validation outside of ml heap
@
text
@d8 4
d227 1
d723 1
a723 1
int validate_address(void *addr)
d731 1
a731 1
    return system_validate_address(addr);
d745 1
a745 1
      error_without_alloc("Unknown block type found in validate_address");
d753 20
a772 1
    error_without_alloc("Unknown space type found in validate_address");
@


1.20
log
@[Bug #70122]
Update space_gen when arrays are unmade to avoid dangling pointers
@
text
@d8 4
d725 2
a726 4
    /* Could be standard C space */
    /* All we care about here are the stubs */
    return ((stubs_code_end > addr && addr >= stubs_code_start) ||
	    (stubs_data_end > addr && addr >= stubs_data_start));
@


1.19
log
@[Bug #70035]
Add a validate address function
@
text
@d8 4
d666 1
@


1.18
log
@[Bug #70032]
gen->values now measured in bytes
@
text
@d8 4
d214 1
d708 36
@


1.17
log
@[Bug #70034]
Rationalising names in mem.h
@
text
@d8 4
d615 4
a618 2
 *  Each generation occupies a single `space' in the arena and has a
 * descriptor on the C heap.  */
d620 1
a620 1
struct ml_heap *make_gen(size_t values, size_t extent)
d627 1
a627 1
  if(values * sizeof(mlval) > SPACE_SIZE)
d631 1
a631 1
  space = space_alloc(TYPE_ML_HEAP, extent * sizeof(mlval));
d655 1
a655 1
void unmake_gen(struct ml_heap *gen)
d661 1
a661 1
void resize_gen(struct ml_heap *gen, size_t extent)
d664 1
a664 1
  size_t e = extent * sizeof(mlval);
@


1.16
log
@[Bug #1659]
Double C_STACK_SIZE to avoid the stack overflowing when
MakeCachedDirEntry in the OpenWindows library is called
which wants to allocate 65K of stack!
@
text
@d8 6
d210 1
a210 1
struct gen *space_gen[SPACES_IN_ARENA];
d254 1
a254 1
    stack = (struct ml_stack *)block_alloc(TYPE_STACK, size);
d360 1
a360 1
struct heap *make_heap(struct heap *parent, size_t size)
d362 1
a362 1
  struct heap *heap;
d366 1
a366 1
  heap = (struct heap *)block_alloc(TYPE_HEAP, size);
d377 1
a377 1
struct heap *unmake_heap(struct heap *heap)
d379 1
a379 1
  struct heap *parent = heap->parent;
d392 1
a392 1
  return(TYPE(p) == TYPE_STACK);
d399 1
a399 1
  return(type == TYPE_GEN || type == TYPE_FROM || type == TYPE_STATIC);
d408 1
a408 1
static struct static_space *static_spaces;
d412 1
a412 1
static struct static_space *make_new_static_space(void)
d414 4
a417 4
  byte *space_ptr = space_alloc(TYPE_STATIC, 0);
  struct static_space *result = 
    (struct static_space *)
      alloc(sizeof(struct static_space),
d439 2
a440 2
    (struct static_space *)
      alloc(sizeof(struct static_space),
d460 1
a460 1
struct static_object *make_static_object(size_t bytes)
d462 1
a462 1
  struct static_space *mappable, *current;
d464 1
a464 1
  struct static_object *result;
d492 1
a492 1
	  result = (struct static_object *)
d515 1
a515 1
  result = (struct static_object *)
d528 1
a528 1
void unmake_static_object(struct static_object *stat)
d531 2
a532 2
  struct static_space *stat_space = SPACE_STATIC(space);
  struct static_object *before, *after;
d566 1
a566 1
		   stat->mark-sizeof(struct static_object)+sizeof(mlval));
d574 2
a575 2
  struct static_space *current = static_spaces->forward;
  struct gen *gen = creation;
d578 1
a578 1
    struct static_object *free = current->free_list.forward;
d592 1
a592 1
    struct static_object *obj = gen->statics.forward;
d614 1
a614 1
struct gen *make_gen(size_t values, size_t extent)
d616 1
a616 1
  struct gen *gen;
d625 2
a626 2
  space = space_alloc(TYPE_GEN, extent * sizeof(mlval));
  gen = alloc(sizeof(struct gen), "Unable to allocate generation descriptor.");
d649 1
a649 1
void unmake_gen(struct gen *gen)
d655 1
a655 1
void resize_gen(struct gen *gen, size_t extent)
@


1.16.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a7 6
 * Revision 1.16  1997/04/11  13:49:24  stephenb
 * [Bug #1659]
 * Double C_STACK_SIZE to avoid the stack overflowing when
 * MakeCachedDirEntry in the OpenWindows library is called
 * which wants to allocate 65K of stack!
 *
@


1.16.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 6
 * Revision 1.16  1997/04/11  13:49:24  stephenb
 * [Bug #1659]
 * Double C_STACK_SIZE to avoid the stack overflowing when
 * MakeCachedDirEntry in the OpenWindows library is called
 * which wants to allocate 65K of stack!
 *
@


1.16.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 6
 * Revision 1.16  1997/04/11  13:49:24  stephenb
 * [Bug #1659]
 * Double C_STACK_SIZE to avoid the stack overflowing when
 * MakeCachedDirEntry in the OpenWindows library is called
 * which wants to allocate 65K of stack!
 *
@


1.15
log
@Fix space lookup for pointers with top bit set.
@
text
@d8 3
d305 7
d313 13
a325 1
#define C_STACK_SIZE 65536
d337 2
@


1.15.6.1
log
@branched from 1.15
@
text
@a7 3
 * Revision 1.15  1996/10/29  16:07:52  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.15.6.1  1997/05/12  10:42:00  hope
 * branched from 1.15
 *
@


1.15.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.15.6.1  1997/05/12  10:42:00  hope
 * branched from 1.15
 *
@


1.15.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.15.6.1  1997/05/12  10:42:00  hope
 * branched from 1.15
 *
@


1.15.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.15.6.1.1.1  1997/07/28  18:29:37  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.15.5.1
log
@branched from 1.15
@
text
@a7 3
 * Revision 1.15  1996/10/29  16:07:52  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.4.1
log
@branched from 1.15
@
text
@a7 3
 * Revision 1.15  1996/10/29  16:07:52  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.4.1.1.1
log
@branched from 1.15.4.1
@
text
@a7 3
 * Revision 1.15.4.1  1996/12/17  17:55:00  hope
 * branched from 1.15
 *
@


1.15.3.1
log
@branched from 1.15
@
text
@a7 3
 * Revision 1.15  1996/10/29  16:07:52  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.2.1
log
@branched from 1.15
@
text
@a7 3
 * Revision 1.15  1996/10/29  16:07:52  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.1.1
log
@branched from 1.15
@
text
@a7 3
 * Revision 1.15  1996/10/29  16:07:52  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.15.1.1.1.1
log
@branched from 1.15.1.1
@
text
@a7 3
 * Revision 1.15.1.1  1996/11/14  12:58:55  hope
 * branched from 1.15
 *
@


1.14
log
@Extend generation structure to allow better GC triggering.
@
text
@d8 3
d201 1
a201 1
struct gen *space_gen[NR_SPACES];
d654 1
a654 1
  for(i=0; i<NR_SPACES; ++i)
@


1.14.3.1
log
@branched from 1.14
@
text
@a7 3
 * Revision 1.14  1996/08/23  15:24:32  nickb
 * Extend generation structure to allow better GC triggering.
 *
@


1.14.2.1
log
@branched from 1.14
@
text
@a7 3
 * Revision 1.14  1996/08/23  15:24:32  nickb
 * Extend generation structure to allow better GC triggering.
 *
@


1.14.1.1
log
@branched from 1.14
@
text
@a7 3
 * Revision 1.14  1996/08/23  15:24:32  nickb
 * Extend generation structure to allow better GC triggering.
 *
@


1.13
log
@Add out-of-memory hook.
@
text
@d8 3
a642 10




const char *sm_help =
  "          -limit s\n"
  "            Specifies an advisory arena extent size in Mb (default 100).\n"
  "            Collection frequency will increase as the amount of\n"
  "            virtual memory used by the process approaches this amount.\n";

a644 40
void sm_options(int argc, const char *const *argv)
{
  static struct option
    opt_limit = {"limit", 1, 0, NULL},
    opt_end   = {NULL, 0, 0, NULL};
  static struct option *options[] = {&opt_limit, &opt_end};

  DIAGNOSTIC(4, "sm_options(argc=%u, argv=0x%X)", argc, argv);

  if(!option_parse(&argc, &argv, options))
    switch(errno)
    {
      case EOPTIONARGS:
      error("The wrong number of arguments were specified for the "
	    "option `%s'.  Use `-help' for help.", argv[0]);

      case EOPTIONUNKNOWN:
      error("An unknown option `%s' was specified.  Use `-help' for help.", argv[0]);

      case EOPTIONDELIM:
      error("Missing delimiter after option `%s'.  Use `-help' for help.", argv[0]);

      default:
      error("The option parser returned an unknown error code %d.", errno);
    }

  if(argc > 0)
    error("Unknown parameter `%s' passed to storage manager.", argv[0]);

  if(opt_limit.specified)
  {
    unsigned int size = to_unsigned(opt_limit.arguments[0]);

    if(size >= 4096)
      error("A limit of %uMb is too large.", size);

    arena_limit = size<<20;
  }
}

d649 1
a649 1
  arena_limit = 100<<20;
@


1.12
log
@Add some type casts to allow compilation without warnings under VC++
@
text
@d8 3
d709 2
@


1.11
log
@Remove "storage manager" interface; replace it with regular functions.
@
text
@d8 3
d224 1
a224 1
  if(stack_cache && (byte *)stack_cache->top - (byte *)stack_cache >= size) {
d596 1
a596 1
  gen->collect	= 0.0;
@


1.10
log
@change event signalling for stack overflow.
@
text
@d8 3
d184 1
d208 1
a208 24
/*  == Stack block count ==
 *
 * We can place a restriction on stack size. If this is non-zero and
 * we try to extend the stack past this limit, we report a stack
 * overflow event.
 * */

static max_stack_block_count = 0;
static stack_block_count = 0;

void extend_max_stack_block_count (int n)
{
  max_stack_block_count = n * max_stack_block_count;
}

void set_max_stack_block_count (int n)
{
  max_stack_block_count = n;
}

int get_max_stack_block_count (void)
{
  return max_stack_block_count;
}
d221 1
a221 2
  if(stack_cache && (byte *)stack_cache->top - (byte *)stack_cache >= size)
  {
d226 5
a230 3
  }
  else
  {
d238 4
a241 5
    /* check for stack overflow. If overflowed, we signal ourselves */

    stack_block_count++;
    if ((max_stack_block_count > 0) &&
	(stack_block_count > max_stack_block_count))
d263 1
a263 1
    --stack_block_count;
d633 4
@


1.9
log
@Change to definition of OBJECT_SIZE macro.
@
text
@d8 3
d180 1
a180 1
#include "signals.h"
a182 1
#include <signal.h>
d207 3
a209 4
 * we try to extend the stack past this limit, we send ourselves a
 * signal SIGUSR1
 *
 */
d261 1
a261 1
      self_signal (signal_stack_overflow);
@


1.8
log
@Add C stack support for threads.
@
text
@d8 3
d509 3
d515 1
a515 1
  stat->mark = STATIC_SIZE(OBJECT_SIZE(stat->object[0]));
d571 4
a574 1
      size_t size = STATIC_SIZE(OBJECT_SIZE(obj->object[0]));
@


1.7
log
@Extend static object header to have a generation pointer.
@
text
@d8 3
d196 1
a196 1
static struct stack *stack_cache = NULL;
d227 1
a227 1
struct stack *make_stack(struct stack *parent, size_t size)
d229 1
a229 1
  struct stack *stack;
d231 1
a231 1
  DIAGNOSTIC(4, "make_stack(0x%lX, 0x%lX)", parent, size);
d247 1
a247 1
    stack = (struct stack *)block_alloc(TYPE_STACK, size);
d266 1
a266 1
struct stack *unmake_stack(struct stack *stack)
d268 1
a268 1
  struct stack *parent = stack->parent;
d270 1
a270 1
  DIAGNOSTIC(4, "unmake_stack(0x%lX) parent 0x%lX", stack, stack->parent);
d297 1
a297 1
  struct stack *stack = STACK_BASE(GC_STACK);
d300 24
a323 1
    stack = unmake_stack(stack);
d325 4
a328 1
  GC_STACK = STACK_LIMIT(stack);
d651 1
a651 1
void sm_init(int argc, const char *const *argv)
a656 4
  int i;

  arena_init();
  arena_limit = 100<<20;	/* default */
d658 1
a658 1
  DIAGNOSTIC(4, "sm_init(argc=%u, argv=0x%X)", argc, argv);
d689 7
a705 1
  GC_HEAP_START = GC_HEAP_LIMIT = 0;
@


1.6
log
@Finish static object allocation code
@
text
@d8 3
d348 3
a350 2
 *  Static objects occupy special spaces in the arena.
 */
d354 2
d369 2
a372 1
  result->free_list.values = 0;
d377 1
d391 2
a394 1
  static_spaces->free_list.values = 0;
d397 8
a404 1
struct static_object *make_static_object(size_t values)
d407 1
a407 1
  size_t size = STATIC_SIZE(values);
d410 1
a410 1
  DIAGNOSTIC(4,"make_static_object(%d)",values,0);
d424 2
a425 2
	if (size <= result->values) {
	  DIAGNOSTIC(5,"    hole at 0x%8x size %d",result, values);
d427 1
a427 1
	  if (size == result->values) {
d431 1
a431 1
	    result->values = values;
d435 1
a435 1
	  result->values -= size;
d437 1
a437 1
	    ((byte*)result + result->values);
d439 1
a439 1
	  result->values = values;
d463 1
a463 1
  result->values = values;
d467 5
d480 3
a482 2
  stat->values = STATIC_SIZE(stat->values);
  stat_space->free += stat->values;
d490 2
a491 2
  if ((byte*)stat + stat->values == (byte*) after) {
    stat->values += after->values;
d496 2
a497 2
  if ((byte*)before + before->values == (byte*) stat) {
    before->values += stat->values;
d507 1
a507 1
		   stat->values-sizeof(struct static_object)+sizeof(mlval));
d525 2
a526 2
	     ((byte*) free) + free->values,
	     free->values);
d536 1
d538 1
a538 2
	     ((byte*) obj) + STATIC_SIZE(obj->values),
	     obj->values);
@


1.5
log
@Partially implemented static objects.
@
text
@a348 1
static struct static_object *free_statics;
d350 21
a373 1
  byte *space_ptr = space_alloc(TYPE_STATIC, 0);
d377 1
a377 1
	    "creating descriptor for space reserved for static objects"); 
d380 2
a381 2
  static_spaces->space    = SPACE(space_ptr);
  static_spaces->mapped  = 0;
d383 3
a385 3
  static_spaces->largest_hole = NULL;
  static_spaces->first_free = NULL;
  free_statics = NULL;
d390 60
a449 1
  size_t size = values * sizeof(mlval) + sizeof(struct static_object);
d451 5
a455 2
  struct static_object *stat =
    (struct static_object *)space_alloc(TYPE_STATIC, size);
d457 1
a457 2
  stat->forward = stat->back = stat;
  stat->values = values;
d459 2
a460 1
  DIAGNOSTIC(4, "make_static_object(0x%X) at 0x%X", values, stat);
d462 24
a485 1
  return(stat);
d488 4
a491 1
void unmake_static_object(struct static_object *stat)
d493 28
a520 3
  DIAGNOSTIC(4, "unmake_static_object(0x%X)", stat, 0);

  space_free((byte *)stat);
d523 1
a523 1

d528 1
a528 2
 *  descriptor on the C heap.
 */
@


1.4
log
@TYPE_LARGE becomes TYPE_STATIC
@
text
@d8 3
a342 2


d348 4
a351 1
union static_object *make_static_object(size_t values)
d353 22
a374 3
  size_t size = values * sizeof(mlval) + sizeof(union static_object);
  union static_object *stat =
    (union static_object *)space_alloc(TYPE_STATIC, size);
d376 2
a377 2
  stat->the.forward = stat->the.back = stat;
  stat->the.values = values;
d384 1
a384 1
void unmake_static_object(union static_object *stat)
d423 1
a423 1
  gen->statics.the.forward = gen->statics.the.back = &gen->statics;
d514 2
@


1.3
log
@Change to the arena manager to allow arbitrary numbers of blocks.
@
text
@d8 3
d337 1
a337 1
  return(type == TYPE_GEN || type == TYPE_FROM || type == TYPE_LARGE);
d342 1
a342 1
/*  === LARGE OBJECTS ===
d344 1
a344 2
 *  Each large object occupies a single `space' in the arena.  This is
 *  probably not good enough as they are fairly limited in number.
d347 1
a347 1
union large_object *make_large(size_t values)
d349 3
a351 3
  size_t size = values * sizeof(mlval) + sizeof(union large_object);
  union large_object *large =
    (union large_object *)space_alloc(TYPE_LARGE, size);
d353 2
a354 2
  large->the.forward = large->the.back = large;
  large->the.values = values;
d356 1
a356 1
  DIAGNOSTIC(4, "make_large(0x%X) at 0x%X", values, large);
d358 1
a358 1
  return(large);
d361 1
a361 1
void unmake_large(union large_object *large)
d363 1
a363 1
  DIAGNOSTIC(4, "unmake_large(0x%X)", large, 0);
d365 1
a365 1
  space_free((byte *)large);
d400 2
a401 2
  gen->large.the.forward = gen->large.the.back = &gen->large;
  gen->nr_large = 0;
@


1.2
log
@new file
@
text
@d8 3
d235 1
a235 1
    stack = (struct stack *)BLOCK_BASE(block_alloc(TYPE_STACK, size));
d264 1
a264 1
    block_free(BLOCK(stack), size);
d301 1
a301 1
  heap = (struct heap *)BLOCK_BASE(block_alloc(TYPE_HEAP, size));
d318 1
a318 1
  block_free(BLOCK(heap), heap->size);
d349 1
a349 1
    (union large_object *)SPACE_BASE(space_alloc(TYPE_LARGE, size));
d363 1
a363 1
  space_free(SPACE(large));
d377 1
a377 1
  int space;
a389 1
  gen->space	= space;
d391 2
a392 2
  gen->start	= (mlval *)SPACE_BASE(space);
  gen->end	= gen->start + space_extent[space]/sizeof(mlval);
d394 1
a394 1
  gen->space	= space;
d401 1
a401 1
  space_gen[space] = gen;
d411 1
a411 1
  space_free(gen->space);
d426 1
a426 1
  space_resize(space, e);
@


1.2.1.1
log
@branched from 1.2
@
text
@a7 3
 * Revision 1.2  1994/06/09  14:46:37  nickh
 * new file
 *
@


1.1
log
@new file
@
text
@d7 4
a10 1
 *  $Log: mem.c,v $
@
