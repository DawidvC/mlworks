head	1.11;
access;
symbols
	MLW_daveb_inline_1_4_99:1.11.1
	MLWorks_21c0_1999_03_25:1.11
	MLWorks_20c1_1998_08_20:1.10
	MLWorks_20c0_1998_08_04:1.10
	MLWorks_20b2c2_1998_06_19:1.10
	MLWorks_20b2_Windows_1998_06_12:1.10
	MLWorks_20b1c1_1998_05_07:1.10
	MLWorks_20b0_1998_04_07:1.10
	MLWorks_20b0_1998_03_20:1.10
	MLWorks_20m2_1998_02_16:1.10
	MLWorks_MM_adapt:1.10.3
	MLWorks_20m1_1997_10_23:1.10
	MLWorks_11r1:1.9.9.1.1.1.1
	MLWorks_workspace_97:1.10.2
	MLWorks_dt_wizard:1.10.1
	MLWorks_11c0_1997_09_09:1.9.9.1.1.1
	MLWorks_10r3:1.9.9.1.3
	MLWorks_10r2_551:1.9.9.1.2
	MLWorks_11:1.9.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.9.9.1
	MLWorks_20m0_1997_06_20:1.10
	MLWorks_1_0_r2c2_1997_06_14:1.9.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.9.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.9.9
	MLWorks_BugFix_1997_04_24:1.9
	MLWorks_1_0_r2_Win32_1997_04_11:1.9
	MLWorks_1_0_r2_Unix_1997_04_04:1.9
	MM_ML_release_korma_1997_04_01:1.9
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.9.7.1.1
	MLWorks_gui_1996_12_18:1.9.8
	MLWorks_1_0_Win32_1996_12_17:1.9.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.9.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.9.4.1
	JFHrts:1.9.6
	MLWorks_1_0_Irix_1996_11_28:1.9.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.9.5
	MLWorks_1_0_Unix_1996_11_14:1.9.4
	MLWorks_Open_Beta2_1996_10_11:1.9.3
	MLWorks_License_dev:1.9.2
	MLWorks_1_open_beta_1996_09_13:1.9.1
	MLWorks_Open_Beta_1996_08_22:1.8
	MLWorks_Beta_1996_07_02:1.8
	MLWorks_Beta_1996_06_07:1.8
	MLWorks_Beta_1996_06_06:1.8
	MLWorks_Beta_1996_06_05:1.8
	MLWorks_Beta_1996_06_03:1.8
	MLWorks_Beta_1996_05_31:1.8
	MLWorks_Beta_1996_05_30:1.8
	hope_poo:1.5.1
	ML_beta_release_12/08/94:1.5.1.1
	ML_beta_release_03/08/94:1.5;
locks; strict;
comment	@ * @;


1.11
date	98.11.10.15.58.02;	author mitchell;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	97.04.30.13.51.11;	author stephenb;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1;
next	1.9;

1.9
date	96.08.27.14.23.44;	author nickb;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1
	1.9.4.1
	1.9.5.1
	1.9.6.1
	1.9.7.1
	1.9.8.1
	1.9.9.1;
next	1.8;

1.8
date	96.02.16.12.43.28;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.03.15.15.18.10;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	94.09.16.10.16.09;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.07.19.09.21.17;	author nickh;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	94.07.18.14.33.42;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.07.12.13.40.20;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.38.49;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.11.06.03;	author nickh;	state Exp;
branches;
next	;

1.5.1.1
date	95.07.05.10.31.09;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	96.09.13.11.25.31;	author hope;	state Exp;
branches;
next	;

1.9.2.1
date	96.10.07.16.15.55;	author hope;	state Exp;
branches;
next	;

1.9.3.1
date	96.10.17.11.35.21;	author hope;	state Exp;
branches;
next	;

1.9.4.1
date	96.11.14.13.00.59;	author hope;	state Exp;
branches
	1.9.4.1.1.1;
next	;

1.9.4.1.1.1
date	96.11.28.15.11.03;	author hope;	state Exp;
branches;
next	;

1.9.5.1
date	96.11.22.18.18.51;	author hope;	state Exp;
branches;
next	;

1.9.6.1
date	96.12.17.10.05.33;	author hope;	state Exp;
branches;
next	;

1.9.7.1
date	96.12.17.17.57.08;	author hope;	state Exp;
branches
	1.9.7.1.1.1;
next	;

1.9.7.1.1.1
date	97.02.24.11.48.49;	author hope;	state Exp;
branches;
next	;

1.9.8.1
date	96.12.18.09.51.47;	author hope;	state Exp;
branches;
next	;

1.9.9.1
date	97.05.12.10.45.29;	author hope;	state Exp;
branches
	1.9.9.1.1.1
	1.9.9.1.2.1
	1.9.9.1.3.1;
next	;

1.9.9.1.1.1
date	97.07.28.18.29.48;	author daveb;	state Exp;
branches
	1.9.9.1.1.1.1.1;
next	;

1.9.9.1.1.1.1.1
date	97.10.07.11.55.37;	author jkbrook;	state Exp;
branches;
next	;

1.9.9.1.2.1
date	97.09.08.17.22.46;	author daveb;	state Exp;
branches;
next	;

1.9.9.1.3.1
date	97.09.09.14.18.50;	author daveb;	state Exp;
branches;
next	;

1.10.1.1
date	97.09.10.19.38.24;	author brucem;	state Exp;
branches;
next	;

1.10.2.1
date	97.09.11.21.06.04;	author daveb;	state Exp;
branches;
next	;

1.10.3.1
date	97.10.31.13.49.09;	author nickb;	state Exp;
branches;
next	;

1.11.1.1
date	99.04.01.18.04.46;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.11
log
@[Bug #70242]
Initialise sockets support
@
text
@/*
 * initialise.c
 * Initialise the run-time system.
 * $Log: src:initialise.c,v $
 * Revision 1.10  1997/04/30  13:51:11  stephenb
 * Add a call to mlw_c_init to support new C interface.
 *
 * Revision 1.9  1996/08/27  14:23:44  nickb
 * storeman arguments no longer passed to initializer.
 *
 * Revision 1.8  1996/02/16  12:43:28  nickb
 * Change to declare_global().
 *
 * Revision 1.7  1995/03/15  15:18:10  nickb
 * Change to thread system.
 *
 * Revision 1.6  1994/09/16  10:16:09  jont
 * Change for smaller handler frames
 *
 * Revision 1.5  1994/07/19  09:21:17  nickh
 * Abstract state initialising into state_initialise().
 *
 * Revision 1.4  1994/07/18  14:33:42  jont
 * Add initialisation of c_state
 *
 * Revision 1.3  1994/07/12  13:40:20  jont
 * Add call to stubs_init
 *
 * Revision 1.2  1994/06/09  14:38:49  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:06:03  nickh
 * new file
 *
 * Revision 1.31  1993/06/22  11:04:53  richard
 * Moved and tidied the code to produce the static top-level exception
 * handler record.  This code was formerly _before_ the initialization
 * of the global root package, so it tended to forget the address.
 *
 * Revision 1.30  1993/06/02  13:03:26  richard
 * Improved the use of const in the argv argument type.
 *
 * Revision 1.29  1993/04/30  14:31:01  jont
 * Changed to distinguish the real base of the stack from the stack limit pointer
 *
 * Revision 1.28  1993/04/30  12:36:43  richard
 * Multiple arguments can now be passed to the storage manager in a general
 * way.
 *
 * Revision 1.27  1993/04/28  15:33:23  jont
 * Make the top level handler a real handler
 *
 * Revision 1.26  1993/03/11  16:44:30  richard
 * Removed an unused root in the implicit vector.
 *
 * Revision 1.25  1992/11/16  13:34:04  clive
 * Need to declare the trace_hook as a root
 *
 * Revision 1.24  1992/10/26  14:07:15  richard
 * Removed stuff related to debugger and added initialisation of
 * the event handler.
 *
 * Revision 1.23  1992/08/19  14:01:12  clive
 * The fix for the ^C exiting problem
 *
 * Revision 1.22  1992/08/17  10:56:24  richard
 * Corrected the initialisation of the interrupt handler.  This must
 * use sigvec() to be well defined.
 *
 * Revision 1.21  1992/07/31  13:32:08  clive
 * Set up interrupt signal handler
 *
 * Revision 1.20  1992/07/29  14:28:48  richard
 * Added profile_init().
 *
 * Revision 1.19  1992/07/24  10:41:12  richard
 * Added NULL hooks to calls to declare_global().
 *
 * Revision 1.18  1992/07/23  11:51:17  richard
 * Changed several declare_roots to declare_global so that they are
 * preserved over image saves and restores.  (See global.h and main.c.)
 *
 * Revision 1.17  1992/07/20  14:13:36  richard
 * The initial ML stack and signal stack are allocated here rather
 * than in the memory manager.  This simplifies the requirements on the
 * memory manager, and allows several signals to share the signal stack.
 *
 * Revision 1.16  1992/07/16  16:14:46  richard
 * Initialised ml_state.base and GC_SP.
 *
 * Revision 1.15  1992/07/14  10:59:51  richard
 * Added missing load_init(), and removed obsolete profiler
 * interrupt setup.  Initialised gc_clock to zero.
 *
 * Revision 1.14  1992/07/03  09:31:44  richard
 * Set up the interrupt flag in the implicit vector.
 *
 * Revision 1.13  1992/07/01  14:45:44  richard
 * Declared garbage collectible things in ml_state as C roots so
 * that the GC doesn't need to know about them.  Changed module
 * table initialisation.
 *
 * Revision 1.12  1992/06/11  11:48:03  clive
 * Moved the setting up of the interrupt stack to this function
 *
 * Revision 1.11  1992/03/12  16:06:33  richard
 * Added pervasives_init().
 *
 * Revision 1.9  1992/01/22  12:55:17  richard
 * Added code to empty the modified ref chain.
 *
 * Revision 1.8  1992/01/14  10:13:38  richard
 * Removed top-level handler record initialization.  The top-level handler is
 * now represented by a zero.
 *
 * Revision 1.7  1991/12/23  15:12:37  richard
 * Added code to generate and initialize a top level handler record.
 *
 * Revision 1.6  91/12/17  16:31:28  nickh
 *  Now calls mem_init (from mem.c) which does most of the actual work. Note
 * that malloc will not work until mem_init has been called, so this must be
 * done before anything else.
 * 
 * Revision 1.5  91/10/29  14:11:06  davidt
 * Heap initialisation is now done in the garbage collector. The initial
 * ML state is now set up here to have a zero sized heap.
 * 
 * Revision 1.4  91/10/28  12:22:02  davidt
 * Trivial changes to comments.
 * 
 * Revision 1.3  91/10/24  17:16:56  davidt
 * Now initialises the toplevel exception handler.
 * 
 * Revision 1.2  91/10/24  16:07:59  davidt
 * Now sets up the pointer to the implicit vector.
 * 
 * Revision 1.1  91/10/23  15:44:25  davidt
 * Initial revision
 * 
 * 
 * Copyright (c) Harlequin 1991.
 */


#include "initialise.h"
#include "modules.h"
#include "mem.h"
#include "gc.h"
#include "stacks.h"
#include "implicit.h"
#include "state.h"
#include "utils.h"
#include "values.h"
#include "pervasives.h"
#include "profiler.h"
#include "loader.h"
#include "main.h"
#include "global.h"
#include "event.h"
#include "environment.h"
#include "tags.h"
#include "diagnostic.h"
#include "os.h"
#include "signals.h"
#include "stubs.h"
#include "threads.h"
#include "sockets.h"
#include "mlw_ci_init.h"


void initialise()
{
  image_continuation = MLUNIT;
  declare_global("image continuation", &image_continuation, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  profile_init();
  load_init();
  pervasives_init();
  ev_init();
  os_init();
  signals_init();
  threads_init();
  implicit_init();
  mlw_ci_init();
  sockets_init();

  gc_clock = 0.0;
  in_GC = 0;
}
@


1.11.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a4 4
 * Revision 1.11  1998/11/10  15:58:02  mitchell
 * [Bug #70242]
 * Initialise sockets support
 *
@


1.10
log
@Add a call to mlw_c_init to support new C interface.
@
text
@d5 3
d167 1
d185 1
@


1.10.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a4 3
 * Revision 1.10  1997/04/30  13:51:11  stephenb
 * Add a call to mlw_c_init to support new C interface.
 *
@


1.10.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a4 3
 * Revision 1.10  1997/04/30  13:51:11  stephenb
 * Add a call to mlw_c_init to support new C interface.
 *
@


1.10.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a4 3
 * Revision 1.10  1997/04/30  13:51:11  stephenb
 * Add a call to mlw_c_init to support new C interface.
 *
@


1.9
log
@storeman arguments no longer passed to initializer.
@
text
@d5 3
d164 2
d180 1
@


1.9.9.1
log
@branched from 1.9
@
text
@a4 3
 * Revision 1.9  1996/08/27  14:23:44  nickb
 * storeman arguments no longer passed to initializer.
 *
@


1.9.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a4 3
 * Revision 1.9.9.1  1997/05/12  10:45:29  hope
 * branched from 1.9
 *
@


1.9.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a4 3
 * Revision 1.9.9.1  1997/05/12  10:45:29  hope
 * branched from 1.9
 *
@


1.9.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a4 3
 * Revision 1.9.9.1  1997/05/12  10:45:29  hope
 * branched from 1.9
 *
@


1.9.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a4 3
 * Revision 1.9.9.1.1.1  1997/07/28  18:29:48  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.9.8.1
log
@branched from 1.9
@
text
@a4 3
 * Revision 1.9  1996/08/27  14:23:44  nickb
 * storeman arguments no longer passed to initializer.
 *
@


1.9.7.1
log
@branched from 1.9
@
text
@a4 3
 * Revision 1.9  1996/08/27  14:23:44  nickb
 * storeman arguments no longer passed to initializer.
 *
@


1.9.7.1.1.1
log
@branched from 1.9.7.1
@
text
@a4 3
 * Revision 1.9.7.1  1996/12/17  17:57:08  hope
 * branched from 1.9
 *
@


1.9.6.1
log
@branched from 1.9
@
text
@a4 3
 * Revision 1.9  1996/08/27  14:23:44  nickb
 * storeman arguments no longer passed to initializer.
 *
@


1.9.5.1
log
@branched from 1.9
@
text
@a4 3
 * Revision 1.9  1996/08/27  14:23:44  nickb
 * storeman arguments no longer passed to initializer.
 *
@


1.9.4.1
log
@branched from 1.9
@
text
@a4 3
 * Revision 1.9  1996/08/27  14:23:44  nickb
 * storeman arguments no longer passed to initializer.
 *
@


1.9.4.1.1.1
log
@branched from 1.9.4.1
@
text
@a4 3
 * Revision 1.9.4.1  1996/11/14  13:00:59  hope
 * branched from 1.9
 *
@


1.9.3.1
log
@branched from 1.9
@
text
@a4 3
 * Revision 1.9  1996/08/27  14:23:44  nickb
 * storeman arguments no longer passed to initializer.
 *
@


1.9.2.1
log
@branched from 1.9
@
text
@a4 3
 * Revision 1.9  1996/08/27  14:23:44  nickb
 * storeman arguments no longer passed to initializer.
 *
@


1.9.1.1
log
@branched from 1.9
@
text
@a4 3
 * Revision 1.9  1996/08/27  14:23:44  nickb
 * storeman arguments no longer passed to initializer.
 *
@


1.8
log
@Change to declare_global().
@
text
@d5 3
d162 1
a162 1
void initialise(int storeman_argc, const char *const *storeman_argv)
a163 2
  sm_options(storeman_argc, storeman_argv);

@


1.7
log
@Change to thread system.
@
text
@d5 3
a162 3
  modules = mt_empty();
  declare_global("module table", &modules, NULL);

d164 2
a165 2
  declare_global("image continuation", &image_continuation, NULL);

@


1.6
log
@Change for smaller handler frames
@
text
@d5 3
a143 1
#include "handler.h"
d154 1
a154 4

#define INITIAL_STACK_AREA	65536

static mlval toplevel_handler_frame[6];
d158 1
a158 4
  mlval closure;
  struct stack *initial_stack;
  /* Initialise the storage manager */
  sm_init(storeman_argc, storeman_argv);
a159 3
  initial_stack = make_stack(NULL, INITIAL_STACK_AREA);
  state_initialise(initial_stack);

a167 1
  stubs_init();
d172 2
a173 8

  closure = env_function("top level exception handler", handler);
  DIAGNOSTIC(4, "  handler stub closure 0x%X", closure, 0);
  toplevel_handler_frame[2] = closure;
  ml_state.handler = MLPTR(PAIRPTR, toplevel_handler_frame);
  declare_root(&ml_state.handler);
  declare_global("toplevel exception handler stub",
		 toplevel_handler_frame+2, NULL);
@


1.5
log
@Abstract state initialising into state_initialise().
@
text
@d5 3
d183 1
a183 1
  toplevel_handler_frame[3] = closure;
d187 1
a187 1
		 toplevel_handler_frame+3, NULL);
@


1.5.1.1
log
@branched from 1.5
@
text
@a4 3
 * Revision 1.5  1994/07/19  09:21:17  nickh
 * Abstract state initialising into state_initialise().
 *
@


1.4
log
@Add initialisation of c_state
@
text
@d5 3
d162 1
a162 11
  GC_STACK = STACK_LIMIT(initial_stack);
  ml_state.base = initial_stack->top;
  GC_SP = initial_stack->top;

  c_state.sp = NULL; /* Required by MIPS for spotting top of stack */

  ml_state.implicit = &implicit_vector;
  GC_MODIFIED_LIST = NULL;

  ml_state.g7 = MLUNIT;
  declare_root(&ml_state.g7);
@


1.3
log
@Add call to stubs_init
@
text
@d5 3
d161 3
a163 1
  GC_SP = NULL;
@


1.2
log
@new file
@
text
@d5 3
d142 1
d174 1
@


1.1
log
@new file
@
text
@d4 4
a7 1
 * $Log: initialise.c,v $
@
