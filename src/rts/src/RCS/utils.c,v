head	1.24;
access;
symbols
	MLW_daveb_inline_1_4_99:1.24.1
	MLWorks_21c0_1999_03_25:1.24
	MLWorks_20c1_1998_08_20:1.23
	MLWorks_20c0_1998_08_04:1.22
	MLWorks_20b2c2_1998_06_19:1.21
	MLWorks_20b2_Windows_1998_06_12:1.21
	MLWorks_20b1c1_1998_05_07:1.18
	MLWorks_20b0_1998_04_07:1.17
	MLWorks_20b0_1998_03_20:1.16
	MLWorks_20m2_1998_02_16:1.16
	MLWorks_MM_adapt:1.15.12
	MLWorks_20m1_1997_10_23:1.15
	MLWorks_11r1:1.15.9.1.1.1.1
	MLWorks_workspace_97:1.15.11
	MLWorks_dt_wizard:1.15.10
	MLWorks_11c0_1997_09_09:1.15.9.1.1.1
	MLWorks_10r3:1.15.9.1.3
	MLWorks_10r2_551:1.15.9.1.2
	MLWorks_11:1.15.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.15.9.1
	MLWorks_20m0_1997_06_20:1.15
	MLWorks_1_0_r2c2_1997_06_14:1.15.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.15.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.15.9
	MLWorks_BugFix_1997_04_24:1.15
	MLWorks_1_0_r2_Win32_1997_04_11:1.15
	MLWorks_1_0_r2_Unix_1997_04_04:1.15
	MM_ML_release_korma_1997_04_01:1.15
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.15.7.1.1
	MLWorks_gui_1996_12_18:1.15.8
	MLWorks_1_0_Win32_1996_12_17:1.15.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.15.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.15.4.1
	JFHrts:1.15.6
	MLWorks_1_0_Irix_1996_11_28:1.15.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.15.5
	MLWorks_1_0_Unix_1996_11_14:1.15.4
	MLWorks_Open_Beta2_1996_10_11:1.15.3
	MLWorks_License_dev:1.15.2
	MLWorks_1_open_beta_1996_09_13:1.15.1
	MLWorks_Open_Beta_1996_08_22:1.15
	MLWorks_Beta_1996_07_02:1.15
	MLWorks_Beta_1996_06_07:1.15
	MLWorks_Beta_1996_06_06:1.15
	MLWorks_Beta_1996_06_05:1.15
	MLWorks_Beta_1996_06_03:1.15
	MLWorks_Beta_1996_05_31:1.15
	MLWorks_Beta_1996_05_30:1.15
	hope_poo:1.5.1
	ML_beta_release_12/08/94:1.5.1.1
	ML_beta_release_03/08/94:1.5;
locks; strict;
comment	@ * @;


1.24
date	98.08.24.15.44.39;	author jont;	state Exp;
branches
	1.24.1.1;
next	1.23;

1.23
date	98.08.17.13.28.43;	author jkbrook;	state Exp;
branches;
next	1.22;

1.22
date	98.07.17.15.16.28;	author jkbrook;	state Exp;
branches;
next	1.21;

1.21
date	98.06.11.14.48.24;	author jkbrook;	state Exp;
branches;
next	1.20;

1.20
date	98.05.27.10.13.26;	author mitchell;	state Exp;
branches;
next	1.19;

1.19
date	98.05.26.16.40.56;	author mitchell;	state Exp;
branches;
next	1.18;

1.18
date	98.04.15.15.23.16;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	98.03.26.15.07.14;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	97.11.18.12.32.10;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	96.05.14.16.00.48;	author nickb;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1
	1.15.4.1
	1.15.5.1
	1.15.6.1
	1.15.7.1
	1.15.8.1
	1.15.9.1
	1.15.10.1
	1.15.11.1
	1.15.12.1;
next	1.14;

1.14
date	96.01.12.14.57.25;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	96.01.11.17.30.28;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	95.08.03.11.02.01;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	95.06.09.15.54.07;	author nickb;	state Exp;
branches;
next	1.10;

1.10
date	95.04.27.11.53.04;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	95.02.23.16.48.34;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.01.24.15.03.46;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	94.12.09.15.44.13;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	94.10.19.15.43.25;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	94.07.22.14.11.55;	author nickh;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	94.06.30.11.48.24;	author nickh;	state Exp;
branches;
next	1.3;

1.3
date	94.06.29.14.48.56;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.50.59;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.11.25.38;	author nickh;	state Exp;
branches;
next	;

1.5.1.1
date	95.07.05.10.30.24;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	96.09.13.11.24.14;	author hope;	state Exp;
branches;
next	;

1.15.2.1
date	96.10.07.16.14.31;	author hope;	state Exp;
branches;
next	;

1.15.3.1
date	96.10.17.11.33.59;	author hope;	state Exp;
branches;
next	;

1.15.4.1
date	96.11.14.12.59.39;	author hope;	state Exp;
branches
	1.15.4.1.1.1;
next	;

1.15.4.1.1.1
date	96.11.28.15.09.41;	author hope;	state Exp;
branches;
next	;

1.15.5.1
date	96.11.22.18.17.26;	author hope;	state Exp;
branches;
next	;

1.15.6.1
date	96.12.17.10.04.09;	author hope;	state Exp;
branches;
next	;

1.15.7.1
date	96.12.17.17.55.45;	author hope;	state Exp;
branches
	1.15.7.1.1.1;
next	;

1.15.7.1.1.1
date	97.02.24.11.47.18;	author hope;	state Exp;
branches;
next	;

1.15.8.1
date	96.12.18.09.50.21;	author hope;	state Exp;
branches;
next	;

1.15.9.1
date	97.05.12.10.44.03;	author hope;	state Exp;
branches
	1.15.9.1.1.1
	1.15.9.1.2.1
	1.15.9.1.3.1;
next	;

1.15.9.1.1.1
date	97.07.28.18.29.02;	author daveb;	state Exp;
branches
	1.15.9.1.1.1.1.1;
next	;

1.15.9.1.1.1.1.1
date	97.10.07.11.54.52;	author jkbrook;	state Exp;
branches;
next	;

1.15.9.1.2.1
date	97.09.08.17.22.00;	author daveb;	state Exp;
branches;
next	;

1.15.9.1.3.1
date	97.09.09.14.18.03;	author daveb;	state Exp;
branches;
next	;

1.15.10.1
date	97.09.10.19.37.21;	author brucem;	state Exp;
branches;
next	;

1.15.11.1
date	97.09.11.21.05.19;	author daveb;	state Exp;
branches;
next	;

1.15.12.1
date	97.10.31.13.48.22;	author nickb;	state Exp;
branches;
next	;

1.24.1.1
date	99.04.01.18.04.04;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.24
log
@[Bug #70170]
Add a fflush stderr at the end of message_end
@
text
@/*  ==== MISCELLANEOUS UTILITY FUNCTIONS ====
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  $Log: src:utils.c,v $
 * Revision 1.23  1998/08/17  13:28:43  jkbrook
 * [Bug #50100]
 * Remove use of env_lookup("license edition")
 *
 * Revision 1.22  1998/07/17  15:16:28  jkbrook
 * [Bug #30436]
 * Update edition names
 *
 * Revision 1.21  1998/06/11  14:48:24  jkbrook
 * [Bug #30411]
 * Adding FREE edition
 *
 * Revision 1.20  1998/05/27  10:13:26  mitchell
 * [Bug #30411]
 * Remove stray editing character
 *
 * Revision 1.19  1998/05/26  16:40:56  mitchell
 * [Bug #30411]
 * Support for time-limited runtime
 *
 * Revision 1.18  1998/04/15  15:23:16  jont
 * [Bug #20037]
 * Make fatal errors abort on re-entry
 *
 * Revision 1.17  1998/03/26  15:07:14  jont
 * [Bug #30090]
 * Add format_to_ml_string for use when making syserr
 *
 * Revision 1.16  1997/11/18  12:32:10  jont
 * [Bug #30089]
 * Remove include of mltime.h which is no longer needed
 *
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
 * Revision 1.14  1996/01/12  14:57:25  matthew
 * Changing ] to [ in message_start
 *
 * Revision 1.13  1996/01/11  17:30:28  nickb
 * Runtime error message buffer problem.
 *
 * Revision 1.12  1995/08/03  11:02:01  matthew
 * Increasing bound on runtime message size
 *
 * Revision 1.11  1995/06/09  15:54:07  nickb
 * Add alloc_zero.
 *
 * Revision 1.10  1995/04/27  11:53:04  daveb
 * Added call to message_flusher to message_end.
 *
 * Revision 1.9  1995/02/23  16:48:34  nickb
 * Remove "bug-fix" which neither fixes the bug nor
 * compiles without warnings.
 *
 * Revision 1.8  1995/01/24  15:03:46  daveb
 * Replaced fixed bound on error messages.
 *
 * Revision 1.7  1994/12/09  15:44:13  jont
 * Change time.h to mltime.h
 *
 * Revision 1.6  1994/10/19  15:43:25  nickb
 * The method of declaring functions to be non-returning has changed.
 *
 * Revision 1.5  1994/07/22  14:11:55  nickh
 * Should not terminate sprintf-written strings with a NUL.
 * Also restrict message length checks to the debugging runtime.
 *
 * Revision 1.4  1994/06/30  11:48:24  nickh
 * Add messaging function hooks.
 *
 * Revision 1.3  1994/06/29  14:48:56  jont
 * Add nonreturning to error
 *
 * Revision 1.2  1994/06/09  14:50:59  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:25:38  nickh
 * new file
 *
 *  Revision 1.22  1994/01/28  17:23:48  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.21  1993/08/26  18:45:57  daveb
 *  The runtime reads the module name from the consistency information in the
 *  file.  Therefore module_name() isn't needed any more.
 *
 *  Revision 1.20  1993/08/24  14:27:36  richard
 *  The is_ml_frame function didn't cope with shared closures.
 *
 *  Revision 1.19  1993/08/12  14:18:52  daveb
 *  Replaced basename with module_name.
 *
 *  Revision 1.18  1993/06/22  11:14:53  richard
 *  Moved stack backtrace here from GC and top-level handler.
 *
 *  Revision 1.17  1993/06/02  13:15:15  richard
 *  Added nonreturning qualifier to verror().
 *  Added missing include of extensions.h.
 *  Added prototype for getrusage().
 *
 *  Revision 1.16  1993/02/10  17:02:05  jont
 *  Changes for code vector reform, and also fixed a bug whereby time based
 *  profiling only worked on the first of a set of mutually recursive code
 *  vectors
 *
 *  Revision 1.15  1993/02/02  17:21:39  jont
 *  Made is_ml_frame check for the right sort of pointer (ie not a ref)
 *
 *  Revision 1.14  1993/02/01  16:04:24  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.13  1992/12/07  14:32:42  richard
 *  Added user_clock().
 *
 *  Revision 1.12  1992/10/01  15:37:37  richard
 *  Added ansi.h.
 *
 *  Revision 1.11  1992/08/24  15:44:36  richard
 *  More checks in is_ml_frame().
 *
 *  Revision 1.10  1992/08/18  09:48:47  richard
 *  Corrected ml_frame to return the code vector from the frame
 *  it is passed and not its parent frame.
 *
 *  Revision 1.9  1992/08/05  17:50:40  richard
 *  Code vectors are now tagged differently to strings.
 *  This information is used by is_ml_frame() to avoid finding
 *  assembler subroutines etc.
 *
 *  Revision 1.8  1992/07/21  13:54:52  richard
 *  Added is_ml_frame(), derived from is_ml_stack() in a storage manager
 *  independent way.  Implemented alloc().
 *
 *  Revision 1.7  1992/03/12  16:58:06  richard
 *  Made basename() take a const argument.
 *
 *  Revision 1.6  1992/03/11  11:46:50  richard
 *  Changed call to allocate_string() in basename() to include terminator.
 *
 *  Revision 1.5  1992/01/20  16:03:15  richard
 *  Changed message() and error() to use variable argument lists.
 *
 *  Revision 1.4  1992/01/09  15:55:13  richard
 *  Fixed an error in basename().
 *
 *  Revision 1.3  1991/12/23  13:18:44  richard
 *  Added basename().
 *
 *  Revision 1.2  91/12/19  13:36:23  richard
 *  Rewrote runtime_message() in terms of fputs so that it doesn't
 *  call malloc().  This can now be used before memory is initialized.
 * 
 *  Revision 1.1  91/10/18  13:03:11  davidt
 *  Initial revision
 */

#include "ansi.h"
#include "syscalls.h"
#include "utils.h"
#include "alloc.h"
#include "extensions.h"
#include "exceptions.h"
#include "allocator.h"
#include "license.h"
#include "mlw_mklic.h"
#include "environment.h"

#include <stdio.h>
#include <string.h>
#include <stdarg.h>

void (*messager_function)(const char * message) = NULL;
void (*message_flusher)(void) = NULL;

#define MAXIMUM_RUNTIME_MESSAGE_SIZE 256

void message_string (const char *string)
{
  if (messager_function)
    messager_function(string);
  else
    fputs(string,stderr);
}

void vmessage_content(const char *format, va_list arg)
{
  char message_buffer[MAXIMUM_RUNTIME_MESSAGE_SIZE+1];
  int length;

  length = vsprintf(message_buffer, format, arg);

#ifdef DEBUG

#ifdef SPRINTF_IS_BROKEN
  length = strlen(message_buffer);
#endif

  if (length > MAXIMUM_RUNTIME_MESSAGE_SIZE)
    error ("Runtime message too long : %u %s\n",length, message_buffer);

#endif

  message_string(message_buffer);
}

extern void message_content (const char *format, ...)
{
  va_list arg;
  
  va_start (arg,format);
  vmessage_content (format, arg);
  va_end (arg);
}

extern void message_start (void)
{
  message_string("[");
}

extern void message_end (void)
{
  if (messager_function) {
    messager_function("]\n");
    if (message_flusher)
      message_flusher ();
  } else {
    fputs("]\n",stderr);
    fflush(stderr);
  }
}

extern void message(const char *format, ...)
{
  va_list arg;

  va_start (arg,format);
  message_start();
  vmessage_content(format, arg);
  message_end();
  va_end (arg);
}

extern void message_stderr(const char *format, ...)
{
  va_list arg;

  putc('[',stderr);
  va_start(arg, format);
  vfprintf(stderr, format, arg);
  va_end(arg);
  fputs("]\n",stderr);
  fflush(stderr);
}

/* Have to give a prototype so we know it's non-returning */

nonreturning(static void, verror,
	     (const char *pfx, const char *format, va_list arg));

static void verror(const char *prefix,
		   const char *format,
		   va_list arg)
{
  fprintf(stderr, "%s:\n ", prefix);
  vfprintf(stderr, format, arg);
  putc('\n', stderr);
  fflush(stderr);
  exit(EXIT_FAILURE);
}

static int aborting = 0;

void error(const char *format, ...)
{
  va_list arg;
  if (aborting) abort();
  aborting = 1;
  va_start(arg, format);
  verror("Fatal error in runtime system", format, arg);
}

/* error_without_alloc has to print an error message and exit without
calling anything which allocates (as printf does sometimes). This is
for use before the arena is initialized. */

extern void error_without_alloc(const char *string)
{
  fputs("Fatal error in runtime system: \n", stderr);
  fputs(string, stderr);
  exit(EXIT_FAILURE);
}

void *alloc(size_t size, const char *format, ...)
{
  void *p = malloc(size);
  va_list arg;

  if(p == NULL)
  {
    va_start(arg, format);
    verror("Fatal allocation error in runtime system", format, arg);
  }

  return(p);
}

void *alloc_zero(size_t size, const char *format, ...)
{
  void *p = calloc(1,size);
  va_list arg;

  if(p == NULL)
  {
    va_start(arg, format);
    verror("Fatal zeroing allocation error in runtime system", format, arg);
  }

  return(p);
}

/* standard_out_of_memory_dialog uses the standard streams to conduct
 * an out-of-memory dialog with the user. It returns non-zero iff a
 * retry is appropriate. */

int standard_out_of_memory_dialog(unsigned long int attempt,
				  size_t extent,
				  size_t size)
{
  putc('\n', stderr);
  message_stderr("Unable to obtain virtual memory "
		 "(%uMb used, %uKb requested);\n"
		 "Enter q to quit mlworks, c to continue.",
		 extent >> 20, size >> 10);
  while (1) {
    int c = getchar();
    if (c == EOF || c == 'q')
      return 0; /* abort */
    else if (c == 'c')
      return 1;	/* retry */
  }
}


/* Bounded elapsed time */

#define COUNT_DOWN  5        /* MINUTES */
#define MAX_ELAPSED_TIME 60  /* MINUTES */

static time_t  start_time = 0;
static int     max_elapsed_time = (MAX_ELAPSED_TIME - COUNT_DOWN) * 60;
static int     count_down = COUNT_DOWN;

void check_elapsed_time(void)
{
  if ((license_edition != PERSONAL) && !act_as_free) /* Do nothing */;
  else if (start_time == 0) start_time = time(NULL);
  else {
    long so_far;
    so_far = (long)(difftime(time(NULL), start_time));
    if (so_far > max_elapsed_time) {
      char message[80];
      if (count_down > 0) {
        if (count_down == 1) 
          sprintf(message, "This session of Free MLWorks will stop in 1 minute\n");
        else
          sprintf(message, "This session of Free MLWorks will stop in %d minutes\n",
                           count_down);
        display_simple_message_box(message);
        count_down--;
        start_time = time(NULL);
        max_elapsed_time = 60; 
      } else {
        display_simple_message_box("Free MLWorks time limit has been exceeded\n");
        exit(EXIT_FAILURE);
      }
    }   
  }
}

mlval format_to_ml_string(const char *format, ...)
{
  va_list arg;
  char buffer[EXN_RAISE_FORMAT_BUFFER_SIZE+1];

  va_start(arg, format);
  vsprintf(buffer, format, arg);
  va_end(arg);

  return ml_string(buffer);
}

@


1.24.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 4
 * Revision 1.24  1998/08/24  15:44:39  jont
 * [Bug #70170]
 * Add a fflush stderr at the end of message_end
 *
@


1.23
log
@[Bug #50100]
Remove use of env_lookup("license edition")
@
text
@d6 4
d231 1
a231 1
  } else
d233 2
@


1.22
log
@[Bug #30436]
Update edition names
@
text
@d6 4
a353 4
  enum edition license_edition;

  license_edition = env_lookup("license edition");

@


1.21
log
@[Bug #30411]
Adding FREE edition
@
text
@d6 4
d354 1
a354 1
  if ((license_edition != STUDENT) && (license_edition != FREE) && !act_as_free) /* Do nothing */;
@


1.20
log
@[Bug #30411]
Remove stray editing character
@
text
@d6 4
d159 1
d337 1
a337 1
#define COUNT_DOWN 5         /* MINUTES */
d346 5
a350 1
  if (EDITION != STUDENT) /* Do nothing */;
@


1.19
log
@[Bug #30411]
Support for time-limited runtime
@
text
@d6 4
d355 1
a355 1
        count_down--;1
@


1.18
log
@[Bug #20037]
Make fatal errors abort on re-entry
@
text
@d6 4
d149 2
d322 37
@


1.17
log
@[Bug #30090]
Add format_to_ml_string for use when making syserr
@
text
@d6 4
d247 2
d252 2
@


1.16
log
@[Bug #30089]
Remove include of mltime.h which is no longer needed
@
text
@d6 4
d139 2
d310 13
@


1.15
log
@Add standard streams out-of-memory dialog.
@
text
@d6 3
a134 1
#include "mltime.h"
@


1.15.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a5 3
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
@


1.15.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 3
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
@


1.15.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 3
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
@


1.15.9.1
log
@branched from 1.15
@
text
@a5 3
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
@


1.15.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 3
 * Revision 1.15.9.1  1997/05/12  10:44:03  hope
 * branched from 1.15
 *
@


1.15.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 3
 * Revision 1.15.9.1  1997/05/12  10:44:03  hope
 * branched from 1.15
 *
@


1.15.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 3
 * Revision 1.15.9.1  1997/05/12  10:44:03  hope
 * branched from 1.15
 *
@


1.15.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 3
 * Revision 1.15.9.1.1.1  1997/07/28  18:29:02  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.15.8.1
log
@branched from 1.15
@
text
@a5 3
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
@


1.15.7.1
log
@branched from 1.15
@
text
@a5 3
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
@


1.15.7.1.1.1
log
@branched from 1.15.7.1
@
text
@a5 3
 * Revision 1.15.7.1  1996/12/17  17:55:45  hope
 * branched from 1.15
 *
@


1.15.6.1
log
@branched from 1.15
@
text
@a5 3
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
@


1.15.5.1
log
@branched from 1.15
@
text
@a5 3
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
@


1.15.4.1
log
@branched from 1.15
@
text
@a5 3
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
@


1.15.4.1.1.1
log
@branched from 1.15.4.1
@
text
@a5 3
 * Revision 1.15.4.1  1996/11/14  12:59:39  hope
 * branched from 1.15
 *
@


1.15.3.1
log
@branched from 1.15
@
text
@a5 3
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
@


1.15.2.1
log
@branched from 1.15
@
text
@a5 3
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
@


1.15.1.1
log
@branched from 1.15
@
text
@a5 3
 * Revision 1.15  1996/05/14  16:00:48  nickb
 * Add standard streams out-of-memory dialog.
 *
@


1.14
log
@Changing ] to [ in message_start
@
text
@d6 3
d279 22
@


1.13
log
@Runtime error message buffer problem.
@
text
@d6 3
d180 1
a180 1
  message_string("]");
@


1.12
log
@Increasing bound on runtime message size
@
text
@d6 3
d137 9
a145 1
void vmessage_content(const char *string, va_list arg)
d150 1
a150 1
  length = vsprintf(message_buffer, string, arg);
d162 2
a163 5
  
  if (messager_function)
    messager_function(message_buffer);
  else
    fputs(message_buffer,stderr);
d166 1
a166 1
extern void message_content (const char *string, ...)
d170 2
a171 2
  va_start (arg,string);
  vmessage_content (string, arg);
d177 1
a177 4
  if (messager_function)
    messager_function("[");
  else
    putc('[',stderr);
d190 1
a190 1
extern void message(const char *string, ...)
d194 1
a194 1
  va_start (arg,string);
d196 1
a196 1
  vmessage_content(string, arg);
d201 1
a201 1
extern void message_stderr(const char *string, ...)
d206 2
a207 2
  va_start(arg, string);
  vfprintf(stderr, string, arg);
d216 1
a216 1
	     (const char *pfx, const char *string, va_list arg));
d219 1
a219 1
		   const char *string,
d223 1
a223 1
  vfprintf(stderr, string, arg);
d229 1
a229 1
void error(const char *string, ...)
d232 2
a233 2
  va_start(arg, string);
  verror("Fatal error in runtime system", string, arg);
d247 1
a247 1
void *alloc(size_t size, const char *string, ...)
d254 2
a255 2
    va_start(arg, string);
    verror("Fatal allocation error in runtime system", string, arg);
d261 1
a261 1
void *alloc_zero(size_t size, const char *string, ...)
d268 2
a269 2
    va_start(arg, string);
    verror("Fatal zeroing allocation error in runtime system", string, arg);
@


1.11
log
@Add alloc_zero.
@
text
@d6 3
d132 1
a132 1
#define MAXIMUM_RUNTIME_MESSAGE_SIZE 160
@


1.10
log
@Added call to message_flusher to message_end.
@
text
@d6 3
d248 14
@


1.9
log
@Remove "bug-fix" which neither fixes the bug nor
compiles without warnings.
@
text
@d6 4
d171 1
a171 1
  if (messager_function)
d173 3
a175 1
  else
@


1.8
log
@Replaced fixed bound on error messages.
@
text
@d6 3
d122 1
a122 4
#define INITIAL_RUNTIME_MESSAGE_SIZE 160

static char *message_buffer;
static int message_buffer_length;
d126 1
d129 1
a129 6
  if (message_buffer == NULL) {
    message_buffer = malloc (INITIAL_RUNTIME_MESSAGE_SIZE + 1);
    message_buffer_length = INITIAL_RUNTIME_MESSAGE_SIZE;
    if (message_buffer == NULL) 
      error ("Can't allocate message buffer\n");
  }
d131 1
a131 1
  length = vsprintf(message_buffer, string, arg);
d137 6
a142 7
  if (length > message_buffer_length) {
    message_buffer_length *= 2;
    message_buffer = malloc (message_buffer_length + 1);
    if (message_buffer == NULL)
      error ("Can't allocate message buffer\n");
    vmessage_content(string, arg);
  } else if (messager_function)
@


1.7
log
@Change time.h to mltime.h
@
text
@d6 3
d119 4
a122 1
#define MAXIMUM_RUNTIME_MESSAGE_SIZE 160
a125 1
  char message_buffer[MAXIMUM_RUNTIME_MESSAGE_SIZE+1];
d128 7
a136 4
#ifdef DEBUG

/* Check that the message fits inside the buffer */

d141 7
a147 6
  if (length > MAXIMUM_RUNTIME_MESSAGE_SIZE)
    error ("Overflowed runtime message : %u %s\n",length, message_buffer);

#endif /* DEBUG */

  if (messager_function)
@


1.6
log
@The method of declaring functions to be non-returning has changed.
@
text
@d6 3
d107 1
a107 1
#include "time.h"
@


1.5
log
@Should not terminate sprintf-written strings with a NUL.
Also restrict message length checks to the debugging runtime.
@
text
@d6 4
d189 8
a196 3
static nonreturning void verror(const char *prefix,
				const char *string,
				va_list arg)
d205 1
a205 1
void nonreturning error(const char *string, ...)
@


1.5.1.1
log
@branched from 1.5
@
text
@a5 4
 * Revision 1.5  1994/07/22  14:11:55  nickh
 * Should not terminate sprintf-written strings with a NUL.
 * Also restrict message length checks to the debugging runtime.
 *
@


1.4
log
@Add messaging function hooks.
@
text
@d6 3
d118 4
d129 1
a129 1
  message_buffer[length]=0;
@


1.3
log
@Add nonreturning to error
@
text
@d6 3
d103 64
a166 1
void message(const char *string, ...)
d170 1
a170 1
  putc('[', stderr);
d174 1
a174 1
  fputs("]\n", stderr);
@


1.2
log
@new file
@
text
@d6 3
d123 1
a123 1
void error(const char *string, ...)
@


1.1
log
@new file
@
text
@d5 4
a8 1
 *  $Log: utils.c,v $
@
