head	1.13;
access;
symbols
	MLW_daveb_inline_1_4_99:1.13.1
	MLWorks_21c0_1999_03_25:1.13
	MLWorks_20c1_1998_08_20:1.12
	MLWorks_20c0_1998_08_04:1.12
	MLWorks_20b2c2_1998_06_19:1.12
	MLWorks_20b2_Windows_1998_06_12:1.12
	MLWorks_20b1c1_1998_05_07:1.12
	MLWorks_20b0_1998_04_07:1.12
	MLWorks_20b0_1998_03_20:1.12
	MLWorks_20m2_1998_02_16:1.11
	MLWorks_MM_adapt:1.11.3
	MLWorks_20m1_1997_10_23:1.11
	MLWorks_11r1:1.10.9.1.1.1.1
	MLWorks_workspace_97:1.11.2
	MLWorks_dt_wizard:1.11.1
	MLWorks_11c0_1997_09_09:1.10.9.1.1.1
	MLWorks_10r3:1.10.9.1.3
	MLWorks_10r2_551:1.10.9.1.2
	MLWorks_11:1.10.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.10.9.1
	MLWorks_20m0_1997_06_20:1.10
	MLWorks_1_0_r2c2_1997_06_14:1.10.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.10.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.10.9
	MLWorks_BugFix_1997_04_24:1.10
	MLWorks_1_0_r2_Win32_1997_04_11:1.10
	MLWorks_1_0_r2_Unix_1997_04_04:1.10
	MM_ML_release_korma_1997_04_01:1.10
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.10.7.1.1
	MLWorks_gui_1996_12_18:1.10.8
	MLWorks_1_0_Win32_1996_12_17:1.10.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.10.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.10.4.1
	JFHrts:1.10.6
	MLWorks_1_0_Irix_1996_11_28:1.10.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.10.5
	MLWorks_1_0_Unix_1996_11_14:1.10.4
	MLWorks_Open_Beta2_1996_10_11:1.10.3
	MLWorks_License_dev:1.10.2
	MLWorks_1_open_beta_1996_09_13:1.10.1
	MLWorks_Open_Beta_1996_08_22:1.10
	MLWorks_Beta_1996_07_02:1.10
	MLWorks_Beta_1996_06_07:1.8
	MLWorks_Beta_1996_06_06:1.8
	MLWorks_Beta_1996_06_05:1.8
	MLWorks_Beta_1996_06_03:1.8
	MLWorks_Beta_1996_05_31:1.8
	MLWorks_Beta_1996_05_30:1.8
	hope_poo:1.2.1
	ML_beta_release_12/08/94:1.2.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.13
date	98.07.17.16.30.18;	author jont;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	98.03.02.13.21.56;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	97.08.19.15.14.09;	author nickb;	state Exp;
branches
	1.11.1.1
	1.11.2.1
	1.11.3.1;
next	1.10;

1.10
date	96.07.01.09.00.52;	author nickb;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1
	1.10.4.1
	1.10.5.1
	1.10.6.1
	1.10.7.1
	1.10.8.1
	1.10.9.1;
next	1.9;

1.9
date	96.06.27.15.30.41;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	96.02.29.12.00.20;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	96.02.19.17.13.25;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	96.02.16.19.00.57;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	96.02.16.16.00.47;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	95.09.19.10.25.24;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.08.31.13.55.51;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.36.18;	author nickh;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	94.06.09.11.03.07;	author nickh;	state Exp;
branches;
next	;

1.2.1.1
date	95.07.05.10.28.43;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	96.09.13.11.25.49;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.10.07.16.16.19;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.10.17.11.35.39;	author hope;	state Exp;
branches;
next	;

1.10.4.1
date	96.11.14.13.01.16;	author hope;	state Exp;
branches
	1.10.4.1.1.1;
next	;

1.10.4.1.1.1
date	96.11.28.15.11.22;	author hope;	state Exp;
branches;
next	;

1.10.5.1
date	96.11.22.18.19.08;	author hope;	state Exp;
branches;
next	;

1.10.6.1
date	96.12.17.10.05.52;	author hope;	state Exp;
branches;
next	;

1.10.7.1
date	96.12.17.17.57.25;	author hope;	state Exp;
branches
	1.10.7.1.1.1;
next	;

1.10.7.1.1.1
date	97.02.24.11.49.09;	author hope;	state Exp;
branches;
next	;

1.10.8.1
date	96.12.18.09.52.06;	author hope;	state Exp;
branches;
next	;

1.10.9.1
date	97.05.12.10.47.06;	author hope;	state Exp;
branches
	1.10.9.1.1.1
	1.10.9.1.2.1
	1.10.9.1.3.1;
next	;

1.10.9.1.1.1
date	97.07.28.18.27.17;	author daveb;	state Exp;
branches
	1.10.9.1.1.1.1.1;
next	;

1.10.9.1.1.1.1.1
date	97.10.07.11.53.19;	author jkbrook;	state Exp;
branches;
next	;

1.10.9.1.2.1
date	97.09.08.17.20.22;	author daveb;	state Exp;
branches;
next	;

1.10.9.1.3.1
date	97.09.09.14.16.29;	author daveb;	state Exp;
branches;
next	;

1.11.1.1
date	97.09.10.19.34.16;	author brucem;	state Exp;
branches;
next	;

1.11.2.1
date	97.09.11.21.03.22;	author daveb;	state Exp;
branches;
next	;

1.11.3.1
date	97.10.31.13.46.13;	author nickb;	state Exp;
branches;
next	;

1.13.1.1
date	99.04.01.18.02.23;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.13
log
@[Bug #30108]
Implement DLL based ML code
@
text
@/*  ==== GLOBAL C ROOTS ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Implementation
 *  --------------
 *  The global roots are maintained as a simple extensible table.  The
 *  global root package is an ML record containing the global root names and
 *  their values.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:global.c,v $
 * Revision 1.12  1998/03/02  13:21:56  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.11  1997/08/19  15:14:09  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
 * Revision 1.10  1996/07/01  09:00:52  nickb
 * Change names of other _NIL flags for consistency.
 *
 * Revision 1.9  1996/06/27  15:30:41  jont
 * Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
 *
 * Revision 1.8  1996/02/29  12:00:20  nickb
 * fix MISSING_NIL bug.
 *
 * Revision 1.7  1996/02/19  17:13:25  nickb
 * A couple of bugs in global_unpack and weak table handling.
 *
 * Revision 1.5  1996/02/16  16:00:47  nickb
 * Add more sophistication to global roots.
 *
 * Revision 1.4  1995/09/19  10:25:24  jont
 * Fix problems with C ordering of evaluation of function parameters
 * interaction with gc and C roots
 *
 * Revision 1.3  1994/08/31  13:55:51  nickb
 * global_pack changed so it no longer mutates a record.
 *
 * Revision 1.2  1994/06/09  14:36:18  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:03:07  nickh
 * new file
 *
 *  Revision 1.8  1993/11/16  17:14:20  nickh
 *  Added root declaration and retraction in weak_add().
 *  (bug fix).
 *
 *  Revision 1.7  1993/04/30  14:19:47  richard
 *  Added some diagnostics to help with image inconsistency problems.
 *
 *  Revision 1.6  1993/04/29  12:23:02  richard
 *  Corrected a stylistically bad use of a macro which could trip
 *  us up later.
 *
 *  Revision 1.5  1993/02/01  14:38:27  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.4  1992/08/07  08:46:11  richard
 *  Added weak_length and changed the type of weak_apply.
 *
 *  Revision 1.3  1992/08/05  09:53:08  richard
 *  Added weak list utilities.
 *
 *  Revision 1.2  1992/07/24  14:06:46  richard
 *  Added a duplication test to declare_global().
 *  Added a hook to global roots so that other functions are called when they
 *  are unpacked.
 *
 *  Revision 1.1  1992/07/23  12:03:06  richard
 *  Initial revision
 *
 */

#include "global.h"
#include "gc.h"
#include "utils.h"
#include "values.h"
#include "allocator.h"
#include "diagnostic.h"

#include <string.h>
#include <stdlib.h>


struct entry
{
  const char *name;
  mlval *root;
  word flags;
  mlval (*save_fn)(const char *name, mlval *root, int deliver);
  void (*load_fn)(const char *name, mlval *root, mlval value);
  void (*missing_fn)(const char *name, mlval *root);
} *table = NULL;
size_t table_size = 16, table_used = 0;
  

extern void declare_global
	(const char *name, mlval *root, word flags,
	 mlval (*save_fn)(const char *name, mlval *root, int deliver),
	 void (*load_fn)(const char *name, mlval *root, mlval value),
         void (*missing_fn)(const char *name, mlval *root))
{
  size_t i;

  if ((flags & ~(word)GLOBAL_ALL_FLAGS) != 0)
    error("Unknown flag(s) 0x%x used for global declaration of name `%s'.",
	  flags & ~(word)GLOBAL_ALL_FLAGS, name);
  if ((missing_fn != NULL) && (flags & (GLOBAL_MISSING_FLAGS)))
    error("`Missing' flags 0x%x used with `missing' function in "
	  "global declaration of name `%s'.",
	  flags & GLOBAL_MISSING_FLAGS, name);

  for(i=0; i<table_used; ++i)
    if(strcmp(table[i].name, name) == 0)
      error("Duplicate global root definition for name `%s'.", name);

  if(table == NULL || table_used >= table_size) {
    table_size *= 2;
    table = (struct entry *)realloc(table, sizeof(struct entry) * table_size);
    if(table == NULL)
      error("Unable to expand global root table.");
  }

  table[table_used].name = name;
  table[table_used].root = root;
  table[table_used].flags = flags;
  table[table_used].save_fn = save_fn;
  table[table_used].load_fn = load_fn;
  table[table_used].missing_fn = missing_fn;
  ++table_used;

  declare_root(root, 1);
}

/* global_save_die is a save_fn which returns DEAD */

mlval global_save_die(const char *name, mlval *root, int deliver)
{
  return DEAD;
}

extern void declare_global_result(mlval *result, mlval name)
{
  word flags = GLOBAL_SAVE_RECORD | GLOBAL_MISSING_UNIT;
  declare_global(CSTRING(name), result, flags, NULL, NULL, NULL);
}

/* when packing the global table, we want to create a record
   containing all of the names (as ML strings) and all of the
   roots. So we must allocate the names on the ML heap before we
   create the record. So we create an array of the names, clear it,
   fill it with the names, then create the record and write into it */

mlval global_pack(int deliver)
{
  mlval name_array, val_array, flags_array, package;
  size_t i, array_index;

  name_array = allocate_array(table_used);
  for(i=0; i < table_used; i++)
    MLUPDATE(name_array,i,MLUNIT);
  declare_root (&name_array, 0);

  val_array = allocate_array(table_used);
  for(i=0; i < table_used; i++)
    MLUPDATE(val_array,i,MLUNIT);
  declare_root (&val_array, 0);

  flags_array = allocate_array(table_used);
  for(i=0; i < table_used; i++)
    MLUPDATE(flags_array,i,MLUNIT);
  declare_root (&flags_array, 0);

  array_index = 0;
  for(i=0; i < table_used; i++) {
    mlval temp = DEAD;			/* DEAD means "do not save" */
    word flags = table[i].flags;
    if (deliver)
      flags >>= GLOBAL_DELIVER_SHIFT;

    if (table[i].save_fn != NULL)
      temp = table[i].save_fn (table[i].name, table[i].root, deliver);
    else if (flags & GLOBAL_SAVE_RECORD)
      temp = (flags & GLOBAL_SAVE_UNIT) ? MLUNIT : *table[i].root;
    if (flags & GLOBAL_SAVE_UNIT) 	/* then we nil it out */
      *table[i].root = MLUNIT;
    if ((flags & GLOBAL_SAVE_RECORD) ||
	(temp != DEAD)) {	/* then it goes in the table */
      MLUPDATE(val_array,array_index,temp);
      temp = ml_string(table[i].name); /* Do NOT inline this */
      MLUPDATE(name_array,array_index,temp);
      MLUPDATE(flags_array,array_index,MLINT(table[i].flags));
      array_index++;
    }
  }

  package = allocate_record(4);
  FIELD(package,0) = MLINT(array_index);
  FIELD(package,1) = name_array;
  FIELD(package,2) = flags_array;
  FIELD(package,3) = val_array;

  retract_root(&name_array);
  retract_root(&val_array);
  retract_root(&flags_array);
  return(package);
}

void global_unpack(mlval package)
{
  size_t i, j, length, found;
  mlval name_array, val_array, flags_array;

  DIAGNOSTIC(2, "global_unpack(0x%X)", package, 0);

  name_array = FIELD(package,1);
  flags_array = FIELD(package,2);
  val_array = FIELD(package,3);
  declare_root(&name_array, 0);
  declare_root(&val_array, 0);
  declare_root(&flags_array, 0);

  length = CINT(FIELD(package,0));
  found = 0;
  /* first wipe out all the global roots, in case there's a GC while
   * we're here */
  for(i=0; i<table_used; ++i) {
    *table[i].root = DEAD;
  }
  /* for each global root, find it in the new image */
  for(i=0; i<table_used; ++i) {
    const char *name = table[i].name;
    for (j=0; j < length; ++j) {
      mlval image_name = MLSUB(name_array,j);
      if(image_name != MLUNIT && (strcmp(CSTRING(image_name), name) == 0)) {
	/* found */
	DIAGNOSTIC(4, "  %s: 0x%X", name, MLSUB(val_array, j));
	found++;
	MLUPDATE(name_array, j, MLUNIT);
	if(table[i].load_fn != NULL) {
	  DIAGNOSTIC(4, "  invoking fix function 0x%X", table[i].load_fn, 0);
	  (*table[i].load_fn)(name, table[i].root, MLSUB(val_array, j));
	} else
	  *table[i].root = MLSUB(val_array,j);
	goto next;
      }
    }
    /* not found */
    if (table[i].missing_fn)
      table[i].missing_fn(table[i].name, table[i].root);
    else {
      word flags = table[i].flags;
      if (flags & GLOBAL_MISSING_WARN)
	message("global root `%s' missing from loaded image",name);
      if ((flags & GLOBAL_MISSING_WARN) || (flags & GLOBAL_MISSING_UNIT))
	*table[i].root = MLUNIT;
      else
	error("global root `%s' missing from loaded image.", name);
    }
  next:
    ;	/* empty statement: required by Visual C++ */
  }
  if (found != length) { /* there are unmatched entries */
    for (j=0; j < length; ++j) {
      mlval image_name = MLSUB(name_array,j);
      if(image_name != MLUNIT) {
	word flags = MLSUB(flags_array,j);
	DIAGNOSTIC(4, "  unmatched entry %s",CSTRING(image_name),0);
	if ((flags & GLOBAL_UNMATCHED_IGNORE) == 0) {
	  if ((flags & GLOBAL_UNMATCHED_WARN))
	    message("loaded image has unmatched global root `%s'",
		    CSTRING(image_name));
	  else 
	    error("Loaded image has unmatched global root `%s'",
		  CSTRING(image_name));
	}
      }
    }
  }
  retract_root(&name_array);
  retract_root(&val_array);
  retract_root(&flags_array);
}


mlval weak_new(size_t granularity)
{
  mlval new = allocate_array(2);

  MLUPDATE(new, 0, MLINT(granularity));
  MLUPDATE(new, 1, MLNIL);

  return(new);
}

mlval weak_add(mlval list, mlval value)
{
  size_t granularity = CINT(MLSUB(list, 0)), i;
  mlval l, array;

  for(l = MLSUB(list, 1); l != MLNIL; l = MLTAIL(l)) {
    mlval array = MLHEAD(l);
    size_t length = LENGTH(ARRAYHEADER(array)), i;

    for(i=0; i<length; ++i)
      if(MLSUB(array, i) == DEAD) {
	MLUPDATE(array, i, value);
	return(list);
      }
  }

  declare_root(&list, 0);
  declare_root(&value, 0);
  array = allocate_weak_array(granularity);
  retract_root(&value);

  MLUPDATE(array, 0, value);
  for(i=1; i<granularity; ++i) {
    MLUPDATE(array, i, DEAD);
  }

  l = mlw_cons(array, MLSUB(list, 1)); /* Do NOT inline this */
  MLUPDATE(list, 1, l);
  retract_root(&list);

  return(list);
}

size_t weak_length(mlval list)
{
  size_t total = 0;
  mlval l;

  for(l = MLSUB(list, 1); l != MLNIL; l = MLTAIL(l))
  {
    mlval array = MLHEAD(l);
    size_t length = LENGTH(ARRAYHEADER(array)), i;

    for(i=0; i<length; ++i)
      if(MLSUB(array, i) != DEAD)
	++total;
  }

  return(total);
}

void weak_apply(mlval list, mlval (*f)(unsigned int, mlval))
{
  mlval l = MLUNIT, array = MLUNIT;
  unsigned int index = 0;

  declare_root(&list, 0);
  declare_root(&l, 0);
  declare_root(&array, 0);

  for(l=MLSUB(list, 1); l!=MLNIL; l=MLTAIL(l))
  {
    size_t length, i;

    array = MLHEAD(l);
    length = LENGTH(ARRAYHEADER(array));

    for(i=0; i<length; ++i)
    {
      mlval value = MLSUB(array, i);

      if(value != DEAD)
      {
	value = (*f)(index++, value);
	MLUPDATE(array, i, value);
      }
    }
  }

  retract_root(&array);
  retract_root(&l);
  retract_root(&list);
}

/* weak_tidy tidies up a weak list. It iterates over the table,
 * compacting the contents. */

static void weak_tidy(mlval value)
{
  size_t length = weak_length(value), index = 0;
  mlval new_array, new_cons, l;
  declare_root(&value, 0);
  new_array = allocate_weak_array(length);
  for(l = MLSUB(value, 1); l != MLNIL; l = MLTAIL(l)) {
    mlval array = MLHEAD(l);
    size_t alength = LENGTH(ARRAYHEADER(array)), i;
    for(i=0; i<alength; ++i) {
      mlval value = MLSUB(array,i);
      if (value != DEAD)
	MLUPDATE(new_array,index++,value);
    }
  }
  new_cons = mlw_cons(new_array,MLNIL);
  MLUPDATE(value,1,new_cons);
  retract_root(&value);
}

void global_tidy(mlval package)
{
  size_t array_size = CINT(FIELD(package,0));
  mlval val_array = FIELD(package,3);
  mlval flags_array = FIELD(package,2);
  size_t i;
  declare_root(&flags_array, 0);
  declare_root(&val_array, 0);
  for (i=0 ; i < array_size; i ++) {
    word flags = CINT(MLSUB(flags_array,i));
    mlval value = MLSUB(val_array,i);
    if (flags & GLOBAL_WEAK_LIST)
      weak_tidy(value);
  }
  retract_root(&flags_array);
  retract_root(&val_array);
}
@


1.13.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a13 4
 * Revision 1.13  1998/07/17  16:30:18  jont
 * [Bug #30108]
 * Implement DLL based ML code
 *
@


1.12
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d14 5
d149 6
d329 1
a329 1
  l = cons(array, MLSUB(list, 1)); /* Do NOT inline this */
d405 1
a405 1
  new_cons = cons(new_array,MLNIL);
@


1.11
log
@[Bug #30250]
Bugs in use of allocate_record and allocate_array: add debug-filling code.
@
text
@d14 4
d134 1
a134 1
  declare_root(root);
d158 1
a158 1
  declare_root (&name_array);
d163 1
a163 1
  declare_root (&val_array);
d168 1
a168 1
  declare_root (&flags_array);
d215 3
a217 3
  declare_root(&name_array);
  declare_root(&val_array);
  declare_root(&flags_array);
d308 2
a309 2
  declare_root(&list);
  declare_root(&value);
d348 3
a350 3
  declare_root(&list);
  declare_root(&l);
  declare_root(&array);
d383 1
a383 1
  declare_root(&value);
d396 1
d405 2
a406 2
  declare_root(&flags_array);
  declare_root(&val_array);
@


1.11.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a13 4
 * Revision 1.11  1997/08/19  15:14:09  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.11.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a13 4
 * Revision 1.11  1997/08/19  15:14:09  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.11.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a13 4
 * Revision 1.11  1997/08/19  15:14:09  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.10
log
@Change names of other _NIL flags for consistency.
@
text
@d14 3
d152 2
d155 1
d157 2
d160 1
d162 2
a165 6
  /* clear the arrays, then fill them */
  for(i=0; i < table_used; i++) {
    MLUPDATE(name_array,i,MLUNIT);
    MLUPDATE(flags_array,i,MLUNIT);
    MLUPDATE(val_array,i,MLUNIT);
  }
@


1.10.9.1
log
@branched from 1.10
@
text
@a13 3
 * Revision 1.10  1996/07/01  09:00:52  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.10.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a13 3
 * Revision 1.10.9.1  1997/05/12  10:47:06  hope
 * branched from 1.10
 *
@


1.10.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a13 3
 * Revision 1.10.9.1  1997/05/12  10:47:06  hope
 * branched from 1.10
 *
@


1.10.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a13 3
 * Revision 1.10.9.1  1997/05/12  10:47:06  hope
 * branched from 1.10
 *
@


1.10.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a13 3
 * Revision 1.10.9.1.1.1  1997/07/28  18:27:17  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.10.8.1
log
@branched from 1.10
@
text
@a13 3
 * Revision 1.10  1996/07/01  09:00:52  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.10.7.1
log
@branched from 1.10
@
text
@a13 3
 * Revision 1.10  1996/07/01  09:00:52  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.10.7.1.1.1
log
@branched from 1.10.7.1
@
text
@a13 3
 * Revision 1.10.7.1  1996/12/17  17:57:25  hope
 * branched from 1.10
 *
@


1.10.6.1
log
@branched from 1.10
@
text
@a13 3
 * Revision 1.10  1996/07/01  09:00:52  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.10.5.1
log
@branched from 1.10
@
text
@a13 3
 * Revision 1.10  1996/07/01  09:00:52  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.10.4.1
log
@branched from 1.10
@
text
@a13 3
 * Revision 1.10  1996/07/01  09:00:52  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.10.4.1.1.1
log
@branched from 1.10.4.1
@
text
@a13 3
 * Revision 1.10.4.1  1996/11/14  13:01:16  hope
 * branched from 1.10
 *
@


1.10.3.1
log
@branched from 1.10
@
text
@a13 3
 * Revision 1.10  1996/07/01  09:00:52  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a13 3
 * Revision 1.10  1996/07/01  09:00:52  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a13 3
 * Revision 1.10  1996/07/01  09:00:52  nickb
 * Change names of other _NIL flags for consistency.
 *
@


1.9
log
@Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
@
text
@d14 3
d171 2
a172 2
      temp = (flags & GLOBAL_SAVE_NIL) ? MLUNIT : *table[i].root;
    if (flags & GLOBAL_SAVE_NIL) 	/* then we nil it out */
@


1.8
log
@fix MISSING_NIL bug.
@
text
@d14 3
d239 1
a239 1
      if ((flags & GLOBAL_MISSING_WARN) || (flags & GLOBAL_MISSING_NIL))
@


1.7
log
@A couple of bugs in global_unpack and weak table handling.
@
text
@d14 3
d237 1
a237 1
	table[i].root = MLUNIT;
@


1.6
log
@Add global_save_die().
@
text
@d165 1
a165 1
    if ((flags & GLOBAL_SAVE_RECORD) &&
d203 5
d239 1
d276 1
a276 1
  size_t granularity = MLSUB(list, 0), i;
d279 1
a279 2
  for(l = MLSUB(list, 1); l != MLNIL; l = MLTAIL(l))
  {
d284 1
a284 2
      if(MLSUB(array, i) == DEAD)
      {
d296 1
a296 1
  for(i=1; i<granularity; ++i)
a297 4
  declare_root(&array);
  {
    mlval temp = cons(array, MLSUB(list, 1)); /* Do NOT inline this */
    MLUPDATE(list, 1, temp);
d299 3
a301 1
  retract_root(&array);
d356 40
@


1.5
log
@Add more sophistication to global roots.
@
text
@d14 3
a93 5
  if ((save_fn != NULL) &&
      ((flags & (GLOBAL_SAVE_FLAGS | GLOBAL_DELIVER_FLAGS))))
    error("Save/deliver flags 0x%x used with save function in "
	  "global declaration of name `%s'.",
	  flags & (GLOBAL_SAVE_FLAGS | GLOBAL_DELIVER_FLAGS), name);
d121 7
d149 1
d158 1
a158 2
    if (flags & GLOBAL_SAVE_NIL)	/* then we nil it out */
      *table[i].root = MLUNIT;
d162 5
a166 2
      temp = *table[i].root;
    if (temp != DEAD) {			/* then it goes in the table */
d175 5
a179 4
  package = allocate_record(3);
  FIELD(package,0) = name_array;
  FIELD(package,1) = flags_array;
  FIELD(package,2) = val_array;
d194 3
a196 3
  name_array = FIELD(package,0);
  flags_array = FIELD(package,1);
  val_array = FIELD(package,2);
d201 1
a201 1
  length = LENGTH(ARRAYHEADER(name_array));
@


1.4
log
@Fix problems with C ordering of evaluation of function parameters
interaction with gc and C roots
@
text
@d14 4
d72 4
a75 1
  void (*f)(mlval *root, mlval value);
d80 5
a84 1
void declare_global(const char *name, mlval *root, void (*f)(mlval *root, mlval value))
d88 13
d105 1
a105 2
  if(table == NULL || table_used >= table_size)
  {
d114 4
a117 1
  table[table_used].f = f;
d129 1
a129 1
mlval global_pack(void)
d131 2
a132 2
  mlval name_array, package;
  size_t i;
d136 4
d141 2
a142 3
  /* clear the array, then fill it */

  for(i=0; i < table_used; i++)
d144 3
d148 17
a164 2
    mlval temp = ml_string(table[i].name); /* Do NOT inline this */
    MLUPDATE(name_array,i,temp);
d167 4
a170 6
  package = allocate_record(table_used * 2);

  for(i=0; i<table_used; ++i) {
    FIELD(package, i*2)   = MLSUB(name_array,i);
    FIELD(package, i*2+1) = *table[i].root;
  }
d173 2
d178 1
a178 2

int global_unpack(mlval package)
d180 2
a181 1
  size_t i, j, length;
d185 11
a195 11
  declare_root(&package);

  length = LENGTH(GETHEADER(package))/2;

#ifndef DEBUG			/* don't short cut */
  if(length != table_used)
    return(0);
#endif

  for(i=0; i<table_used; ++i)
  {
d197 44
a240 15

    for(j=0; j<length; ++j)
      if(strcmp(CSTRING(FIELD(package, j*2)), name) == 0)
	goto found;

    DIAGNOSTIC(2, "  failed to match `%s'", name, 0);
    retract_root(&package);
    return(0);

    found:
    DIAGNOSTIC(2, "  %s: 0x%X", name, FIELD(package, j*2+1));
    if(table[i].f != NULL)
    {
      DIAGNOSTIC(2, "  invoking fix function 0x%X", table[i].f, 0);
      (*table[i].f)(table[i].root, FIELD(package, j*2+1));
a241 2
    else
      *table[i].root = FIELD(package, j*2+1);
d243 3
a245 3

  retract_root(&package);
  return(1);
@


1.3
log
@global_pack changed so it no longer mutates a record.
@
text
@d14 3
d115 4
a118 2
  for(i=0; i < table_used; i++)
    MLUPDATE(name_array,i,ml_string(table[i].name));
d212 4
a215 1
  MLUPDATE(list, 1, cons(array, MLSUB(list, 1)));
@


1.2
log
@new file
@
text
@d14 3
d94 5
d102 1
a102 1
  mlval package = allocate_record(table_used * 2);
d105 9
a113 1
  declare_root(&package);
d115 4
a118 3
  for(i=0; i<table_used; ++i)
  {
    FIELD(package, i*2)   = ml_string(table[i].name);
d122 1
a122 2
  retract_root(&package);

@


1.2.1.1
log
@branched from 1.2
@
text
@a13 3
 * Revision 1.2  1994/06/09  14:36:18  nickh
 * new file
 *
@


1.1
log
@new file
@
text
@d13 4
a16 1
 *  $Log: global.c,v $
@
