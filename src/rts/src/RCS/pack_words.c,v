head	1.11;
access;
symbols
	MLW_daveb_inline_1_4_99:1.11.1
	MLWorks_21c0_1999_03_25:1.11
	MLWorks_20c1_1998_08_20:1.11
	MLWorks_20c0_1998_08_04:1.5
	MLWorks_20b2c2_1998_06_19:1.5
	MLWorks_20b2_Windows_1998_06_12:1.5
	MLWorks_20b1c1_1998_05_07:1.5
	MLWorks_20b0_1998_04_07:1.5
	MLWorks_20b0_1998_03_20:1.5
	MLWorks_20m2_1998_02_16:1.5
	MLWorks_MM_adapt:1.5.12
	MLWorks_20m1_1997_10_23:1.5
	MLWorks_11r1:1.5.9.1.1.1.1
	MLWorks_workspace_97:1.5.11
	MLWorks_dt_wizard:1.5.10
	MLWorks_11c0_1997_09_09:1.5.9.1.1.1
	MLWorks_10r3:1.5.9.1.3
	MLWorks_10r2_551:1.5.9.1.2
	MLWorks_11:1.5.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.5.9.1
	MLWorks_20m0_1997_06_20:1.5
	MLWorks_1_0_r2c2_1997_06_14:1.5.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.5.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.5.9
	MLWorks_BugFix_1997_04_24:1.5
	MLWorks_1_0_r2_Win32_1997_04_11:1.5
	MLWorks_1_0_r2_Unix_1997_04_04:1.5
	MM_ML_release_korma_1997_04_01:1.5
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.5.7.1.1
	MLWorks_gui_1996_12_18:1.5.8
	MLWorks_1_0_Win32_1996_12_17:1.5.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.5.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.5.4.1
	JFHrts:1.5.6
	MLWorks_1_0_Irix_1996_11_28:1.5.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.5.5
	MLWorks_1_0_Unix_1996_11_14:1.5.4
	MLWorks_Open_Beta2_1996_10_11:1.5.3
	MLWorks_License_dev:1.5.2
	MLWorks_1_open_beta_1996_09_13:1.5.1
	MLWorks_Open_Beta_1996_08_22:1.5
	MLWorks_Beta_1996_07_02:1.5
	MLWorks_Beta_1996_06_07:1.5
	MLWorks_Beta_1996_06_06:1.5
	MLWorks_Beta_1996_06_05:1.5
	MLWorks_Beta_1996_06_03:1.5
	MLWorks_Beta_1996_05_31:1.5
	MLWorks_Beta_1996_05_30:1.5;
locks; strict;
comment	@ * @;


1.11
date	98.08.17.16.18.29;	author jont;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	98.08.17.14.14.32;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	98.08.13.16.49.18;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	98.08.06.11.27.59;	author mitchell;	state Exp;
branches;
next	1.7;

1.7
date	98.08.06.11.12.25;	author mitchell;	state Exp;
branches;
next	1.6;

1.6
date	98.08.05.14.36.14;	author mitchell;	state Exp;
branches;
next	1.5;

1.5
date	96.05.17.16.10.38;	author jont;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1
	1.5.4.1
	1.5.5.1
	1.5.6.1
	1.5.7.1
	1.5.8.1
	1.5.9.1
	1.5.10.1
	1.5.11.1
	1.5.12.1;
next	1.4;

1.4
date	95.09.04.10.56.17;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	95.04.03.13.20.03;	author brianm;	state Exp;
branches;
next	1.2;

1.2
date	95.03.22.18.38.12;	author brianm;	state Exp;
branches;
next	1.1;

1.1
date	95.03.17.15.50.38;	author brianm;	state Exp;
branches;
next	;

1.5.1.1
date	96.09.13.11.24.29;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.10.07.16.14.49;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.10.17.11.34.14;	author hope;	state Exp;
branches;
next	;

1.5.4.1
date	96.11.14.12.59.53;	author hope;	state Exp;
branches
	1.5.4.1.1.1;
next	;

1.5.4.1.1.1
date	96.11.28.15.09.55;	author hope;	state Exp;
branches;
next	;

1.5.5.1
date	96.11.22.18.17.42;	author hope;	state Exp;
branches;
next	;

1.5.6.1
date	96.12.17.10.04.25;	author hope;	state Exp;
branches;
next	;

1.5.7.1
date	96.12.17.17.56.01;	author hope;	state Exp;
branches
	1.5.7.1.1.1;
next	;

1.5.7.1.1.1
date	97.02.24.11.47.33;	author hope;	state Exp;
branches;
next	;

1.5.8.1
date	96.12.18.09.50.38;	author hope;	state Exp;
branches;
next	;

1.5.9.1
date	97.05.12.10.44.19;	author hope;	state Exp;
branches
	1.5.9.1.1.1
	1.5.9.1.2.1
	1.5.9.1.3.1;
next	;

1.5.9.1.1.1
date	97.07.28.18.28.41;	author daveb;	state Exp;
branches
	1.5.9.1.1.1.1.1;
next	;

1.5.9.1.1.1.1.1
date	97.10.07.11.54.32;	author jkbrook;	state Exp;
branches;
next	;

1.5.9.1.2.1
date	97.09.08.17.21.37;	author daveb;	state Exp;
branches;
next	;

1.5.9.1.3.1
date	97.09.09.14.17.43;	author daveb;	state Exp;
branches;
next	;

1.5.10.1
date	97.09.10.19.36.51;	author brucem;	state Exp;
branches;
next	;

1.5.11.1
date	97.09.11.21.05.00;	author daveb;	state Exp;
branches;
next	;

1.5.12.1
date	97.10.31.13.48.03;	author nickb;	state Exp;
branches;
next	;

1.11.1.1
date	99.04.01.18.03.46;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New file.
@


1.11
log
@[Bug #30465]
Undo change for endianness of 16 bits values, which were correct before
@
text
@/*  ==== C PACK_WORD OPERATORS ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  Pack word operators are used to map word values onto bytearrays
 *  (Word8Arrays).  This also allows for operations of differing
 *  endianness.
 *  
 *  
 *  Revision Log
 *  ------------
 *  $Log: src:pack_words.c,v $
 * Revision 1.10  1998/08/17  14:14:32  jont
 * [Bug #30465]
 * Fix compiler warning
 * Fixed a compiler warning caused by use of = instead of ==
 * which the stupid MS compiler didn't point out.
 *
 * Revision 1.9  1998/08/13  16:49:18  jont
 * [Bug #30465]
 * Fix endianness problems with little endian machines
 *
 * Revision 1.8  1998/08/06  11:27:59  mitchell
 * [Bug #30467]
 * Remove the 24 bit word packing functions
 *
 * Revision 1.7  1998/08/06  11:12:25  mitchell
 * [Bug #30466]
 * Fix Pack16/24 subVec functions
 *
 * Revision 1.6  1998/08/05  14:36:14  mitchell
 * [Bug #30464]
 * Fix Pack32Big.subVec implementation
 *
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
 * Revision 1.4  1995/09/04  10:56:17  daveb
 * Changed unsigned to word.
 *
 * Revision 1.3  1995/04/03  13:20:03  brianm
 * Updating to use allocate_word32() and CWORD32().
 *
 * Revision 1.2  1995/03/22  18:38:12  brianm
 * Changing Word32 repn. to immutable byte vectors (i.e. strings).
 *
 * Revision 1.1  1995/03/17  15:50:38  brianm
 * new unit
 * New file.
 *
 *
 */

#include "mltypes.h"
#include "allocator.h"
#include "values.h"
#include "diagnostic.h"
#include "environment.h"
#include "exceptions.h"
#include "words.h"
#include "pack_words.h"
#include "utils.h"

/* Local defines */

#define bit(a)                (1u << (a))
#define bitblk(hi,lo)         (bit(hi) | (bit(hi) - bit(lo)))
#define appmask(x,m)          ((x) & (m))
#define setmask(x,m)          ((x) | (m))
#define xormask(x,m)          ((x) ^ (m))
#define rshift(x,lo)          ((unsigned)(x) >> (lo))
#define getbitblk(u,hi,lo)    (appmask(rshift((u),(lo)),bitblk(1+(hi) - (lo),0)))
#define set1bitblk(u,hi,lo)   (setmask((u),bitblk((hi),(lo))))
#define set0bitblk(u,hi,lo)   (appmask((u),~(bitblk((hi),(lo)))))
#define setbitblk(u,hi,lo,v)  (setmask(set0bitblk((u),(hi),(lo)), \
                                       getbitblk((v),1 + (hi) - (lo),0) << (lo)))
#define invbitblk(u,hi,lo)    (xormask((u),bitblk((hi),(lo))))
#define signextend(u,a)       ((appmask(u,bit(a))) ? (setmask((u),(0 - bit(a)))) : u)


#define raise_subscript   \
        exn_raise_string(perv_exn_ref_value, "pack_words: subscript")

typedef enum endian { BIG, LITTLE } endian;

static endian machine_endian;

static void swop_bytes(byte *x, byte *y)
{
   byte temp;

   temp = *x;
   *x = *y;
   *y = temp;
}

static void rev_unsigned(unsigned *val)
{
   byte *x0, *x1, *x2, *x3;

   x0 = (byte *)val;
   x1 = (byte *)x0 + 1;
   x2 = (byte *)x1 + 1;
   x3 = (byte *)x2 + 1;

   swop_bytes(x0,x3);
   swop_bytes(x1,x2);
}

static void endian_change_word(endian end, unsigned *val) {
  if (end == machine_endian) {
    rev_unsigned(val);
  }
}

/* ==== 16 bit words ====
 *
 */

static mlval subV_word16(mlval argument)
{
  int len, index, word;
  mlval vector; 

  byte val1, val2, *addr;

  vector = FIELD(argument,0);
  index = 2 * CINT(FIELD(argument, 1));

  len = CSTRINGLENGTH(vector);

  if (!(0 <= index && index+1 < len)) raise_subscript;

  addr = (byte *)(CSTRING(vector));

  val1 = addr[index++];
  val2 = addr[index];

  word = (val1 << 8) | val2;

  return(MLINT(word));
}

static mlval subV_rev_word16(mlval argument)
{
  int len, index, word;
  mlval vector; 

  byte val1, val2, *addr;

  vector = FIELD(argument,0);
  index = 2 * CINT(FIELD(argument, 1));

  len = CSTRINGLENGTH(vector);

  if (!(0 <= index && index+1 < len)) raise_subscript;

  addr = (byte *)(CSTRING(vector));

  val1 = addr[index++];
  val2 = addr[index];

  word = (val2 << 8) | val1;

  return(MLINT(word));
}

static mlval subA_word16(mlval argument)
{
  int len, index, word;
  mlval array; 

  byte val1, val2, *addr;

  array = FIELD(argument,0);
  index = 2 * CINT(FIELD(argument, 1));

  len = LENGTH(GETHEADER(array));

  if (!(0 <= index && index+1 < len)) raise_subscript;

  addr = (byte *)(CBYTEARRAY(array));

  val1 = addr[index++];
  val2 = addr[index];

  word = (val1 << 8) | val2;

  return(MLINT(word));
}

static mlval subA_rev_word16(mlval argument)
{
  int len, index, word;
  mlval array; 

  byte val1, val2, *addr;

  array = FIELD(argument,0);
  index = 2 * CINT(FIELD(argument, 1));

  len = LENGTH(GETHEADER(array));

  if (!(0 <= index && index+1 < len)) raise_subscript;

  addr = (byte *)(CBYTEARRAY(array));

  val1 = addr[index++];
  val2 = addr[index];

  word = (val2 << 8) | val1;

  return(MLINT(word));
}

static mlval update_word16(mlval argument)
{
  int len, index;
  mlval array, word; 

  byte val1, val2, *addr;

  array = FIELD(argument,0);
  index = 2 * CINT(FIELD(argument, 1));
  word  = CINT(FIELD(argument, 2));

  len = LENGTH(GETHEADER(array));

  if (!(0 <= index && index+1 < len)) raise_subscript;

  addr = (byte *)CBYTEARRAY(array);

  val1 = (byte) rshift(word,8);
  val2 = (byte) word;

  addr[index++]   = val1;
  addr[index] = val2;

  return(MLUNIT);
}

static mlval update_rev_word16(mlval argument)
{
  int len, index;
  mlval array, word; 

  byte val1, val2, *addr;

  array = FIELD(argument,0);
  index = 2 * CINT(FIELD(argument, 1));
  word  = CINT(FIELD(argument, 2));

  len = LENGTH(GETHEADER(array));

  if (!(0 <= index && index+1 < len)) raise_subscript;

  addr = (byte *)CBYTEARRAY(array);

  val2 = (byte) word;
  val1 = (byte) rshift(word,8);

  addr[index++]   = val2;
  addr[index] = val1;

  return(MLUNIT);
}

/* ===== 32 bit words ====
 *
 */

static mlval subV_word32(mlval argument)
{
  int len, index;
  mlval vector, w; 

  byte *addr;

  word *item, val;

  vector = FIELD(argument,0);
  index = sizeof(word) * CINT(FIELD(argument, 1));

  len = CSTRINGLENGTH(vector);

  if (!(0 <= index && index+3 < len)) raise_subscript;

  addr = (byte *)(index + CSTRING(vector));

  item = (word *)addr;
  val  = *item;

  endian_change_word(LITTLE, &val);

  w = allocate_word32();
  num_to_word32(val,w);

  return(w);
}

static mlval subV_rev_word32(mlval argument)
{
  int len, index;
  mlval vector, w; 

  byte *addr;

  word *item, val;

  vector = FIELD(argument,0);
  index = sizeof(word) * CINT(FIELD(argument, 1));

  len = CSTRINGLENGTH(vector);

  if (!(0 <= index && index+3 < len)) raise_subscript;

  addr = (byte *)(index + CSTRING(vector));
  item = (word *)addr;
  val  = *item;

  endian_change_word(BIG, &val);

  w = allocate_word32();
  num_to_word32(val,w);

  return(w);
}

static mlval subA_word32(mlval argument)
{
  int len, index;
  mlval array, w; 

  byte *addr;

  word *item, val;

  array = FIELD(argument,0);
  index = 4 * CINT(FIELD(argument, 1));

  len = LENGTH(GETHEADER(array));

  if (!(0 <= index && index+3 < len)) raise_subscript;

  addr = (byte *)(CBYTEARRAY(array))+index;

  item = (word *)addr;
  val  = *item;

  endian_change_word(LITTLE, &val);

  w = allocate_word32();
  num_to_word32(val,w);

  return(w);
}

static mlval subA_rev_word32(mlval argument)
{
  int len, index;
  mlval array, w; 

  byte *addr;

  word *item, val;

  array = FIELD(argument,0);
  index = 4 * CINT(FIELD(argument, 1));

  len = LENGTH(GETHEADER(array));

  if (!(0 <= index && index+3 < len)) raise_subscript;

  addr = (byte *)(CBYTEARRAY(array))+index;

  item = (word *)addr;
  val  = *item;

  endian_change_word(BIG, &val);

  w = allocate_word32();
  num_to_word32(val,w);

  return(w);
}

static mlval update_word32(mlval argument)
{
  int len, index;
  mlval array, w; 

  byte *addr;

  word *val, *item;

  array = FIELD(argument,0);
  index = sizeof(word) * CINT(FIELD(argument, 1));
  w  = FIELD(argument, 2);

  len = LENGTH(GETHEADER(array));

  if (!(0 <= index && index+3 < len)) raise_subscript;

  addr = (byte *)(index + (word)CBYTEARRAY(array));

  item = (word *)addr;
  val  = CWORD32(w);

  *item = *val;
  endian_change_word(LITTLE, item);

  return(MLUNIT);
}

static mlval update_rev_word32(mlval argument)
{
  int len, index;
  mlval array, w; 

  byte *addr;

  word *val, *item;

  array = FIELD(argument,0);
  index = 4 * CINT(FIELD(argument, 1));
  w  = FIELD(argument, 2);

  len = LENGTH(GETHEADER(array));

  if (!(0 <= index && index+3 < len))  raise_subscript;

  addr = (byte *)(index + (word)CBYTEARRAY(array));

  item = (word *)addr;
  val  = CWORD32(w);

  *item = *val;
  endian_change_word(BIG, item);

  return(MLUNIT);
}

extern void pack_words_init(void)
{
  char foo[4] = "\0\0\0\377";
  unsigned int *bar = (unsigned int *)foo;
  if (*bar == 0xff) {
    machine_endian = BIG;
  } else if (*bar == 0xff000000) {
    machine_endian = LITTLE;
  } else {
    error("pack_words: Unable to determine machine endianness\n");
  }
  env_function("subV word16", subV_word16);
  env_function("subV reverse word16", subV_rev_word16);
  env_function("subV word32", subV_word32);
  env_function("subV reverse word32", subV_rev_word32);

  env_function("subA word16", subA_word16);
  env_function("subA reverse word16", subA_rev_word16);
  env_function("subA word32", subA_word32);
  env_function("subA reverse word32", subA_rev_word32);

  env_function("update word16", update_word16);
  env_function("update reverse word16", update_rev_word16);
  env_function("update word32", update_word32);
  env_function("update reverse word32", update_rev_word32);
}
@


1.11.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a14 4
 * Revision 1.11  1998/08/17  16:18:29  jont
 * [Bug #30465]
 * Undo change for endianness of 16 bits values, which were correct before
 *
@


1.10
log
@[Bug #30465]
Fix compiler warning
Fixed a compiler warning caused by use of = instead of ==
which the stupid MS compiler didn't point out.
@
text
@d15 6
a117 6
static void endian_change_bytes(endian end, byte *val1, byte *val2) {
  if (end == machine_endian) {
    swop_bytes(val1, val2);
  }
}

a140 1
  endian_change_bytes(LITTLE, &val1, &val2);
a164 1
  endian_change_bytes(LITTLE, &val1, &val2);
a188 1
  endian_change_bytes(LITTLE, &val1, &val2);
a212 1
  endian_change_bytes(LITTLE, &val1, &val2);
a237 1
  endian_change_bytes(LITTLE, &val1, &val2);
a263 1
  endian_change_bytes(LITTLE, &val1, &val2);
@


1.9
log
@[Bug #30465]
Fix endianness problems with little endian machines
@
text
@d15 4
d457 1
a457 1
  } else if (*bar = 0xff000000) {
@


1.8
log
@[Bug #30467]
Remove the 24 bit word packing functions
@
text
@d15 4
d54 1
a54 1

d76 3
d102 12
d137 1
d162 1
d187 1
d212 1
d238 1
d265 1
d297 2
d325 1
a325 1
  rev_unsigned(&val);
d354 2
d383 1
a383 1
  rev_unsigned(&val);
d414 1
d442 1
a442 1
  rev_unsigned(item);
d449 9
@


1.7
log
@[Bug #30466]
Fix Pack16/24 subVec functions
@
text
@d15 4
a246 160
/* ==== 24 bit words ====
 *
 */

static mlval subV_word24(mlval argument)
{
  int len, index, word;
  mlval vector; 

  byte val1, val2, val3, *addr;

  vector = FIELD(argument,0);
  index = 3 * CINT(FIELD(argument, 1));

  len = CSTRINGLENGTH(vector);

  if (!(0 <= index && index+2 < len)) raise_subscript;

  addr = (byte *)(CSTRING(vector));

  val1 = addr[index++];
  val2 = addr[index++];
  val3 = addr[index];

  word = (val1 << 16) | (val2 << 8) | val3;

  return(MLINT(word));
}

static mlval subV_rev_word24(mlval argument)
{
  int len, index, word;
  mlval vector; 

  byte val1, val2, val3, *addr;

  vector = FIELD(argument,0);
  index = 3 * CINT(FIELD(argument, 1));

  len = CSTRINGLENGTH(vector);

  if (!(0 <= index && index+2 < len)) raise_subscript;

  addr = (byte *)(CSTRING(vector));

  val1 = addr[index++];
  val2 = addr[index++];
  val3 = addr[index];

  word = (val3 << 16) | (val2 << 8) | val1;

  return(MLINT(word));
}

static mlval subA_word24(mlval argument)
{
  int len, index, word;
  mlval array; 

  byte val1, val2, val3, *addr;

  array = FIELD(argument,0);
  index = 3 * CINT(FIELD(argument, 1));

  len = LENGTH(GETHEADER(array));

  if (!(0 <= index && index+2 < len)) raise_subscript;

  addr = (byte *)(CBYTEARRAY(array));

  val1 = addr[index++];
  val2 = addr[index++];
  val3 = addr[index];

  word = (val1 << 16) | (val2 << 8) | val3;

  return(MLINT(word));
}

static mlval subA_rev_word24(mlval argument)
{
  int len, index, word;
  mlval array; 

  byte val1, val2, val3, *addr;

  array = FIELD(argument,0);
  index = 3 * CINT(FIELD(argument, 1));

  len = LENGTH(GETHEADER(array));

  if (!(0 <= index && index+2 < len)) raise_subscript;

  addr = (byte *)(CBYTEARRAY(array));

  val1 = addr[index++];
  val2 = addr[index++];
  val3 = addr[index];

  word = (val3 << 16) | (val2 << 8) | val1;

  return(MLINT(word));
}

static mlval update_word24(mlval argument)
{
  int len, index;
  mlval array, word; 

  byte val1, val2, val3, *addr;

  array = FIELD(argument,0);
  index = 3 * CINT(FIELD(argument, 1));
  word  = CINT(FIELD(argument, 2));

  len = LENGTH(GETHEADER(array));

  if (!(0 <= index && index+2 < len)) raise_subscript;

  addr = (byte *)CBYTEARRAY(array);

  val1 = (byte) rshift(word,16);
  val2 = (byte) rshift(word,8);
  val3 = (byte) word;

  addr[index++]   = val1;
  addr[index++] = val2;
  addr[index] = val3;

  return(MLUNIT);
}

static mlval update_rev_word24(mlval argument)
{
  int len, index;
  mlval array, word; 

  byte val1, val2, val3, *addr;

  array = FIELD(argument,0);
  index = 3 * CINT(FIELD(argument, 1));
  word  = CINT(FIELD(argument, 2));

  len = LENGTH(GETHEADER(array));

  if (!(0 <= index && index+2 < len)) raise_subscript;

  addr = (byte *)CBYTEARRAY(array);

  val1 = (byte) rshift(word,16);
  val2 = (byte) rshift(word,8);
  val3 = (byte) word;

  addr[index++]   = val3;
  addr[index++] = val2;
  addr[index] = val1;

  return(MLUNIT);
}

a420 2
  env_function("subV word24", subV_word24);
  env_function("subV reverse word24", subV_rev_word24);
a425 2
  env_function("subA word24", subA_word24);
  env_function("subA reverse word24", subA_rev_word24);
a430 2
  env_function("update word24", update_word24);
  env_function("update reverse word24", update_rev_word24);
@


1.6
log
@[Bug #30464]
Fix Pack32Big.subVec (implementation
@
text
@d15 4
d111 2
a112 2
  val1 = addr[index];
  val2 = addr[index++];
d135 2
a136 2
  val1 = addr[index];
  val2 = addr[index++];
d159 2
a160 2
  val1 = addr[index];
  val2 = addr[index++];
d183 2
a184 2
  val1 = addr[index];
  val2 = addr[index++];
d211 2
a212 2
  addr[index]   = val1;
  addr[index++] = val2;
d237 2
a238 2
  addr[index]   = val2;
  addr[index++] = val1;
d263 1
a263 1
  val1 = addr[index];
d265 1
a265 1
  val3 = addr[index++];
d288 1
a288 1
  val1 = addr[index];
d290 1
a290 1
  val3 = addr[index++];
d313 1
a313 1
  val1 = addr[index];
d315 1
a315 1
  val3 = addr[index++];
d338 1
a338 1
  val1 = addr[index];
d340 1
a340 1
  val3 = addr[index++];
d368 1
a368 2
  addr[index]   = val1;
  addr[index++] = val2;
d370 1
d396 1
a396 1
  addr[index]   = val3;
d398 1
a398 1
  addr[index++] = val1;
@


1.5
log
@Add new functions required by latest pack_word signature
@
text
@d15 3
d410 1
a410 1
  word *item;
d420 1
d422 1
d425 1
a425 1
  num_to_word32((word)item,w);
@


1.5.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a14 3
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
@


1.5.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a14 3
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
@


1.5.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a14 3
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
@


1.5.9.1
log
@branched from 1.5
@
text
@a14 3
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
@


1.5.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a14 3
 * Revision 1.5.9.1  1997/05/12  10:44:19  hope
 * branched from 1.5
 *
@


1.5.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a14 3
 * Revision 1.5.9.1  1997/05/12  10:44:19  hope
 * branched from 1.5
 *
@


1.5.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a14 3
 * Revision 1.5.9.1  1997/05/12  10:44:19  hope
 * branched from 1.5
 *
@


1.5.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a14 3
 * Revision 1.5.9.1.1.1  1997/07/28  18:28:41  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.5.8.1
log
@branched from 1.5
@
text
@a14 3
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
@


1.5.7.1
log
@branched from 1.5
@
text
@a14 3
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
@


1.5.7.1.1.1
log
@branched from 1.5.7.1
@
text
@a14 3
 * Revision 1.5.7.1  1996/12/17  17:56:01  hope
 * branched from 1.5
 *
@


1.5.6.1
log
@branched from 1.5
@
text
@a14 3
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
@


1.5.5.1
log
@branched from 1.5
@
text
@a14 3
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
@


1.5.4.1
log
@branched from 1.5
@
text
@a14 3
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
@


1.5.4.1.1.1
log
@branched from 1.5.4.1
@
text
@a14 3
 * Revision 1.5.4.1  1996/11/14  12:59:53  hope
 * branched from 1.5
 *
@


1.5.3.1
log
@branched from 1.5
@
text
@a14 3
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a14 3
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a14 3
 * Revision 1.5  1996/05/17  16:10:38  jont
 * Add new functions required by latest pack_word signature
 *
@


1.4
log
@Changed unsigned to word.
@
text
@d15 3
d62 22
d88 1
a88 1
static mlval sub_word16(mlval argument)
d91 1
a91 1
  mlval array; 
d95 1
a95 1
  array = FIELD(argument,0);
d98 1
a98 1
  len = LENGTH(GETHEADER(array));
d100 1
a100 1
  if (!(0 <= index && index < len))  raise_subscript;
d102 1
a102 1
  addr = (byte *)(CBYTEARRAY(array));
d112 23
d136 1
a136 1
static mlval update_word16(mlval argument)
d138 2
a139 2
  int len, index;
  mlval array, word; 
a144 1
  word  = CINT(FIELD(argument, 2));
d148 1
a148 1
  if (!(0 <= index && index < len))  raise_subscript;
d150 1
a150 1
  addr = (byte *)CBYTEARRAY(array);
d152 2
a153 2
  val1 = (byte) rshift(word,8);
  val2 = (byte) word;
d155 1
a155 2
  addr[index]   = val1;
  addr[index++] = val2;
d157 1
a157 1
  return(MLUNIT);
d160 1
a160 2

static mlval sub_rev_word16(mlval argument)
d172 1
a172 1
  if (!(0 <= index && index < len))  raise_subscript;
d175 1
d184 25
d223 1
a223 1
  if (!(0 <= index && index < len))  raise_subscript;
a235 1

d240 1
a240 1
static mlval sub_word24(mlval argument)
d243 1
a243 1
  mlval array; 
d247 1
a247 1
  array = FIELD(argument,0);
d250 1
a250 1
  len = LENGTH(GETHEADER(array));
d252 1
a252 1
  if (!(0 <= index && index < len))  raise_subscript;
d254 1
a254 1
  addr = (byte *)(CBYTEARRAY(array));
d265 15
d281 10
a290 1
static mlval update_word24(mlval argument)
d292 2
a293 2
  int len, index;
  mlval array, word; 
a298 1
  word  = CINT(FIELD(argument, 2));
d302 1
a302 1
  if (!(0 <= index && index < len))  raise_subscript;
d304 1
a304 1
  addr = (byte *)CBYTEARRAY(array);
d306 3
a308 3
  val1 = (byte) rshift(word,16);
  val2 = (byte) rshift(word,8);
  val3 = (byte) word;
d310 1
a310 3
  addr[index]   = val1;
  addr[index++] = val2;
  addr[index++] = val2;
d312 1
a312 1
  return(MLUNIT);
d315 1
a315 2

static mlval sub_rev_word24(mlval argument)
d327 1
a327 1
  if (!(0 <= index && index < len))  raise_subscript;
d340 27
d381 1
a381 1
  if (!(0 <= index && index < len))  raise_subscript;
a395 2


d400 1
a400 1
static mlval sub_word32(mlval argument)
d403 1
a403 1
  mlval array, w; 
d409 1
a409 1
  array = FIELD(argument,0);
d412 1
a412 1
  len = LENGTH(GETHEADER(array));
d414 1
a414 1
  if (!(0 <= index && index < len))  raise_subscript;
d416 1
a416 1
  addr = (byte *)(index + (word)CBYTEARRAY(array));
d425 1
a425 2

static mlval update_word32(mlval argument)
d428 1
a428 1
  mlval array, w; 
d432 1
a432 1
  word *val, *item;
d434 1
a434 1
  array = FIELD(argument,0);
a435 1
  w  = FIELD(argument, 2);
d437 1
a437 1
  len = LENGTH(GETHEADER(array));
d439 1
a439 1
  if (!(0 <= index && index < len))  raise_subscript;
d441 3
a443 1
  addr = (byte *)(index + (word)CBYTEARRAY(array));
d445 1
a445 2
  item = (word *)addr;
  val  = CWORD32(w);
d447 2
a448 1
  *item = *val;
d450 1
a450 1
  return(MLUNIT);
d453 1
a453 1
static void swop_bytes(byte *x, byte *y)
d455 13
a467 1
   byte temp;
d469 1
a469 4
   temp = *x;
   *x = *y;
   *y = temp;
}
d471 2
a472 3
static void rev_unsigned(unsigned *val)
{
   byte *x0, *x1, *x2, *x3;
d474 2
a475 4
   x0 = (byte *)val;
   x1 = (byte *)x0 + 1;
   x2 = (byte *)x1 + 1;
   x3 = (byte *)x2 + 1;
d477 1
a477 2
   swop_bytes(x0,x3);
   swop_bytes(x1,x2);
d480 1
a480 1
static mlval sub_rev_word32(mlval argument)
d490 1
a490 1
  index = sizeof(word) * CINT(FIELD(argument, 1));
d494 3
a496 1
  if (!(0 <= index && index < len))  raise_subscript;
a497 1
  addr = (byte *)(index + (word)CBYTEARRAY(array));
d509 1
a509 2

static mlval update_rev_word32(mlval argument)
d519 1
a519 1
  index = 4 * CINT(FIELD(argument, 1));
d524 1
a524 1
  if (!(0 <= index && index < len))  raise_subscript;
a531 1
  rev_unsigned(item);
d536 8
d545 3
a547 4
extern void pack_words_init(void)
{
  env_function("sub word16",sub_word16);
  env_function("update word16",update_word16);
d549 1
a549 2
  env_function("sub reverse word16",sub_rev_word16);
  env_function("update reverse word16",update_rev_word16);
d551 1
a551 2
  env_function("sub word24",sub_word24);
  env_function("update word24",update_word24);
d553 1
a553 2
  env_function("sub reverse word24",sub_rev_word24);
  env_function("update reverse word24",update_rev_word24);
d555 2
a556 2
  env_function("sub word32",sub_word32);
  env_function("update word32",update_word32);
d558 2
a559 2
  env_function("sub reverse word32",sub_rev_word32);
  env_function("update reverse word32",update_rev_word32);
d561 25
@


1.3
log
@Updating to use allocate_word32() and CWORD32().
@
text
@d15 3
d288 1
a288 1
  mlval array, word; 
d292 1
a292 1
  unsigned *item;
d295 1
a295 1
  index = sizeof(unsigned) * CINT(FIELD(argument, 1));
d301 2
a302 2
  addr = (byte *)(index + (unsigned)CBYTEARRAY(array));
  item = (unsigned *)addr;
d304 2
a305 2
  word = allocate_word32();
  num_to_word32((unsigned)item,word);
d307 1
a307 1
  return(word);
d314 1
a314 1
  mlval array, word; 
d318 1
a318 1
  unsigned *val, *item;
d321 2
a322 2
  index = sizeof(unsigned) * CINT(FIELD(argument, 1));
  word  = FIELD(argument, 2);
d328 1
a328 1
  addr = (byte *)(index + (unsigned)CBYTEARRAY(array));
d330 2
a331 2
  item = (unsigned *)addr;
  val  = (unsigned *)CWORD32(word);
d363 1
a363 1
  mlval array, word; 
d367 1
a367 1
  unsigned *item, val;
d370 1
a370 1
  index = sizeof(unsigned) * CINT(FIELD(argument, 1));
d376 2
a377 2
  addr = (byte *)(index + (unsigned)CBYTEARRAY(array));
  item = (unsigned *)addr;
d382 2
a383 2
  word = allocate_word32();
  num_to_word32(val,word);
d385 1
a385 1
  return(word);
d392 1
a392 1
  mlval array, word; 
d396 1
a396 1
  unsigned *val, *item;
d400 1
a400 1
  word  = FIELD(argument, 2);
d406 1
a406 1
  addr = (byte *)(index + (unsigned)CBYTEARRAY(array));
d408 2
a409 2
  item = (unsigned *)addr;
  val  = (unsigned *)CWORD32(word);
@


1.2
log
@Changing Word32 repn. to immutable byte vectors (i.e. strings).
@
text
@a9 5
 *
 *  Note that Word32 objects are represented here by strings of length
 *  4 - we allocate an extra byte at the end for a null sentinel.
 *  Hence we use allocate_string(5) to provide for Word32 values and
 *  CSTRING to access them (see also words.c).
d15 3
d31 1
d289 1
a289 1
  unsigned *item, *val;
d292 1
a292 1
  index = 4 * CINT(FIELD(argument, 1));
d301 2
a302 2
  word = allocate_string(5);
  val  = (unsigned *)CSTRING(word);
a303 2
  *val = *item;

d318 1
a318 1
  index = 4 * CINT(FIELD(argument, 1));
d328 1
a328 1
  val  = (unsigned *)CSTRING(word);
d364 1
a364 1
  unsigned *item, *val;
d367 1
a367 1
  index = 4 * CINT(FIELD(argument, 1));
d375 1
d377 1
a377 2
  word = allocate_string(5);
  val  = (unsigned *)CSTRING(word);
d379 2
a380 2
  *val = *item;
  rev_unsigned(val);
d406 1
a406 1
  val  = (unsigned *)CSTRING(word);
@


1.1
log
@new unit
New file.
@
text
@d7 1
a7 1
 *  Pack word operators are used to map words onto bytearrays
d10 5
d19 5
a23 1
 *  $Log$
d302 2
a303 2
  word = allocate_bytearray(4);
  val  = (unsigned *)CBYTEARRAY(word);
d331 1
a331 1
  val  = (unsigned *)CBYTEARRAY(word);
d379 2
a380 2
  word = allocate_bytearray(4);
  val  = (unsigned *)CBYTEARRAY(word);
d409 1
a409 1
  val  = (unsigned *)CBYTEARRAY(word);
a438 1

@
