head	1.11;
access;
symbols
	MLW_daveb_inline_1_4_99:1.11.1
	MLWorks_21c0_1999_03_25:1.11
	MLWorks_20c1_1998_08_20:1.11
	MLWorks_20c0_1998_08_04:1.11
	MLWorks_20b2c2_1998_06_19:1.11
	MLWorks_20b2_Windows_1998_06_12:1.11
	MLWorks_20b1c1_1998_05_07:1.11
	MLWorks_20b0_1998_04_07:1.11
	MLWorks_20b0_1998_03_20:1.11
	MLWorks_20m2_1998_02_16:1.10
	MLWorks_MM_adapt:1.10.12
	MLWorks_20m1_1997_10_23:1.10
	MLWorks_11r1:1.10.9.1.1.1.1
	MLWorks_workspace_97:1.10.11
	MLWorks_dt_wizard:1.10.10
	MLWorks_11c0_1997_09_09:1.10.9.1.1.1
	MLWorks_10r3:1.10.9.1.3
	MLWorks_10r2_551:1.10.9.1.2
	MLWorks_11:1.10.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.10.9.1
	MLWorks_20m0_1997_06_20:1.10
	MLWorks_1_0_r2c2_1997_06_14:1.10.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.10.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.10.9
	MLWorks_BugFix_1997_04_24:1.10
	MLWorks_1_0_r2_Win32_1997_04_11:1.10
	MLWorks_1_0_r2_Unix_1997_04_04:1.10
	MM_ML_release_korma_1997_04_01:1.10
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.10.7.1.1
	MLWorks_gui_1996_12_18:1.10.8
	MLWorks_1_0_Win32_1996_12_17:1.10.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.10.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.10.4.1
	JFHrts:1.10.6
	MLWorks_1_0_Irix_1996_11_28:1.10.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.10.5
	MLWorks_1_0_Unix_1996_11_14:1.10.4
	MLWorks_Open_Beta2_1996_10_11:1.10.3
	MLWorks_License_dev:1.10.2
	MLWorks_1_open_beta_1996_09_13:1.10.1
	MLWorks_Open_Beta_1996_08_22:1.10
	MLWorks_Beta_1996_07_02:1.9
	MLWorks_Beta_1996_06_07:1.9
	MLWorks_Beta_1996_06_06:1.9
	MLWorks_Beta_1996_06_05:1.9
	MLWorks_Beta_1996_06_03:1.8
	MLWorks_Beta_1996_05_31:1.8
	MLWorks_Beta_1996_05_30:1.8
	hope_poo:1.2.1
	ML_beta_release_12/08/94:1.2.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.11
date	98.02.23.17.58.15;	author jont;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	96.08.19.11.02.49;	author daveb;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1
	1.10.4.1
	1.10.5.1
	1.10.6.1
	1.10.7.1
	1.10.8.1
	1.10.9.1
	1.10.10.1
	1.10.11.1
	1.10.12.1;
next	1.9;

1.9
date	96.06.04.10.24.10;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.07.24.11.09.28;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.04.17.13.43.10;	author brianm;	state Exp;
branches;
next	1.6;

1.6
date	95.04.03.12.51.07;	author brianm;	state Exp;
branches;
next	1.5;

1.5
date	95.03.24.19.16.54;	author brianm;	state Exp;
branches;
next	1.4;

1.4
date	95.03.09.17.47.26;	author brianm;	state Exp;
branches;
next	1.3;

1.3
date	95.03.08.10.37.25;	author brianm;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.48.48;	author nickh;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	94.06.09.11.21.41;	author nickh;	state Exp;
branches;
next	;

1.2.1.1
date	95.07.05.10.30.43;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	96.09.13.11.22.42;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.10.07.16.12.48;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.10.17.11.31.58;	author hope;	state Exp;
branches;
next	;

1.10.4.1
date	96.11.14.12.57.58;	author hope;	state Exp;
branches
	1.10.4.1.1.1;
next	;

1.10.4.1.1.1
date	96.11.28.15.07.57;	author hope;	state Exp;
branches;
next	;

1.10.5.1
date	96.11.22.18.15.38;	author hope;	state Exp;
branches;
next	;

1.10.6.1
date	96.12.17.10.02.21;	author hope;	state Exp;
branches;
next	;

1.10.7.1
date	96.12.17.17.54.06;	author hope;	state Exp;
branches
	1.10.7.1.1.1;
next	;

1.10.7.1.1.1
date	97.02.24.11.45.09;	author hope;	state Exp;
branches;
next	;

1.10.8.1
date	96.12.18.09.48.41;	author hope;	state Exp;
branches;
next	;

1.10.9.1
date	97.05.12.10.41.05;	author hope;	state Exp;
branches
	1.10.9.1.1.1
	1.10.9.1.2.1
	1.10.9.1.3.1;
next	;

1.10.9.1.1.1
date	97.07.28.18.26.22;	author daveb;	state Exp;
branches
	1.10.9.1.1.1.1.1;
next	;

1.10.9.1.1.1.1.1
date	97.10.07.11.52.12;	author jkbrook;	state Exp;
branches;
next	;

1.10.9.1.2.1
date	97.09.08.17.19.33;	author daveb;	state Exp;
branches;
next	;

1.10.9.1.3.1
date	97.09.09.14.15.41;	author daveb;	state Exp;
branches;
next	;

1.10.10.1
date	97.09.10.19.32.55;	author brucem;	state Exp;
branches;
next	;

1.10.11.1
date	97.09.11.21.02.11;	author daveb;	state Exp;
branches;
next	;

1.10.12.1
date	97.10.31.13.45.02;	author nickb;	state Exp;
branches;
next	;

1.11.1.1
date	99.04.01.18.01.37;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.11
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@/*  ==== PERVASIVE BYTEARRAYS ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Revision Log
 *  ------------
 *  $Log: src:bytearrays.c,v $
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
 * Revision 1.9  1996/06/04  10:24:10  nickb
 * Reset bytearray_root when raising Substring.
 *
 * Revision 1.8  1995/07/24  11:09:28  matthew
 * Fixing problem with substring
 *
 * Revision 1.7  1995/04/17  13:43:10  brianm
 * Added a peek_memory operation.
 *
 * Revision 1.6  1995/04/03  12:51:07  brianm
 * Adding num_to_word32() word32_to_num().
 * Updating to use allocate_word32() and CWORD32().
 * Made code I had added more GC-safe by moving allocation to
 * end of functions.
 *
 * Revision 1.5  1995/03/24  19:16:54  brianm
 * Adding address operation for static bytearrays.
 *
 * Revision 1.4  1995/03/09  17:47:26  brianm
 * Adding make_static_bytearray
 *
 * Revision 1.3  1995/03/08  10:37:25  brianm
 * Added static_from_string - a version of `from_string' for
 * static bytearrays.
 *
 * Revision 1.2  1994/06/09  14:48:48  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:21:41  nickh
 * new file
 *
 *  Revision 1.4  1993/03/25  16:21:38  jont
 *  Modified use of HEADER for ARRAYHEADER as byte arrays are now ref tagged
 *
 *  Revision 1.3  1993/03/23  15:27:01  jont
 *  Tiny modification
 *
 *  Revision 1.2  1993/02/01  14:49:21  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.1  1992/10/26  13:05:35  richard
 *  Initial revision
 *
 */

#include <string.h>

#include "bytearrays.h"
#include "mltypes.h"
#include "values.h"
#include "exceptions.h"
#include "allocator.h"
#include "environment.h"
#include "gc.h"
#include "words.h"


static mlval bytearray_root;

static mlval make_static_bytearray(mlval argument)
{
  size_t length;
  mlval result;

  length = CINT(argument);
  result = allocate_static_bytearray(length);
  return(result);
}

static mlval static_address_of(mlval argument)
{
  unsigned val;
  int   array, offset;
  mlval result;

  array   = (int)CBYTEARRAY(FIELD(argument,0)); /* must be static bytearray */
  offset  = (int)CINT(FIELD(argument,1));

  val     = (unsigned)(array + offset);

  result  = allocate_word32();
  num_to_word32(val,result);

  return(result);
}

static mlval peek_memory(mlval argument)
{
  unsigned addr, target, start;
  int offset, size, length;
  mlval array;

  addr    = (unsigned)word32_to_num(FIELD(argument,0));

  array   = FIELD(argument,1);
  length  = LENGTH(ARRAYHEADER(array));
  target  = (unsigned)CBYTEARRAY(array);

  offset  = (int)CINT(FIELD(argument,2));
  size    = (int)CINT(FIELD(argument,3));

  /* Check array bounds ... */
  if ((0 > offset) || (0 > size) || (offset >= length) || (offset + size > length))
    exn_raise_string(perv_exn_ref_value, "peek : array bounds");

  if (size == 0) return(MLUNIT);

  start = (unsigned)(target + offset);

  /* Check for overlapping regions ... */
  if ((start <= addr) && (addr < start + size))
    exn_raise_string(perv_exn_ref_value, "peek : overlap");

  if ((addr <= start) && (start < addr + size))
    exn_raise_string(perv_exn_ref_value, "peek : overlap");

  /* Copy non-overlapping regions ... */
  memcpy((void *)start, (void *)addr, (size_t)size);

  return(MLUNIT);
}


/* to_string assumes that the bytearray is null-terminated. */
static mlval to_string(mlval argument)
{
  size_t length = LENGTH(ARRAYHEADER(argument));
  mlval result;

  result = allocate_string(length);
  memcpy(CSTRING(result), CBYTEARRAY(argument), length);

  return(result);
}

static mlval from_string(mlval argument)
{
  size_t length = LENGTH(GETHEADER(argument));
  mlval result;

  result = allocate_bytearray(length);
  memcpy(CBYTEARRAY(result), CSTRING(argument), length);

  return(result);
}

static mlval static_from_string(mlval argument)
{
  size_t length = LENGTH(GETHEADER(argument));
  mlval result;

  result = allocate_static_bytearray(length);
  memcpy(CBYTEARRAY(result), CSTRING(argument), length);

  return(result);
}

static mlval substring(mlval argument)
{
  int start = CINT(FIELD(argument,1));
  int length = CINT(FIELD(argument,2));
  int bound;
  mlval result;

  bytearray_root = FIELD(argument, 0);
  bound = LENGTH(ARRAYHEADER(bytearray_root));

  if(start < 0 || length < 0 || start > bound || start+length > bound) {
    bytearray_root = MLUNIT;
    exn_raise(perv_exn_ref_substring);
  }

  result = allocate_string((size_t) (length+1));
  memcpy(CSTRING(result), CBYTEARRAY(bytearray_root) + start, (size_t) length);
  CSTRING(result)[length] = '\0';
  bytearray_root = MLUNIT;

  return(result);
}


void bytearrays_init()
{
  bytearray_root = MLUNIT;
  declare_root(&bytearray_root, 0);

  env_function("make static bytearray",        make_static_bytearray);
  env_function("static bytearray address of",  static_address_of);
  env_function("bytearray peek memory",        peek_memory);
  env_function("bytearray to string",          to_string);
  env_function("bytearray from string",        from_string);
  env_function("static bytearray from string", static_from_string);
  env_function("bytearray substring",          substring);
}
@


1.11.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 5
 * Revision 1.11  1998/02/23  17:58:15  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
@


1.10
log
@[Bug #1551]
Made to_string and from_string preserve terminating null characters.
@
text
@d8 4
d196 1
a196 1
  declare_root(&bytearray_root);
@


1.10.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a7 4
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
@


1.10.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 4
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
@


1.10.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 4
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
@


1.10.9.1
log
@branched from 1.10
@
text
@a7 4
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
@


1.10.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.10.9.1  1997/05/12  10:41:05  hope
 * branched from 1.10
 *
@


1.10.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.10.9.1  1997/05/12  10:41:05  hope
 * branched from 1.10
 *
@


1.10.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.10.9.1  1997/05/12  10:41:05  hope
 * branched from 1.10
 *
@


1.10.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.10.9.1.1.1  1997/07/28  18:26:22  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.10.8.1
log
@branched from 1.10
@
text
@a7 4
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
@


1.10.7.1
log
@branched from 1.10
@
text
@a7 4
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
@


1.10.7.1.1.1
log
@branched from 1.10.7.1
@
text
@a7 3
 * Revision 1.10.7.1  1996/12/17  17:54:06  hope
 * branched from 1.10
 *
@


1.10.6.1
log
@branched from 1.10
@
text
@a7 4
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
@


1.10.5.1
log
@branched from 1.10
@
text
@a7 4
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
@


1.10.4.1
log
@branched from 1.10
@
text
@a7 4
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
@


1.10.4.1.1.1
log
@branched from 1.10.4.1
@
text
@a7 3
 * Revision 1.10.4.1  1996/11/14  12:57:58  hope
 * branched from 1.10
 *
@


1.10.3.1
log
@branched from 1.10
@
text
@a7 4
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a7 4
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a7 4
 * Revision 1.10  1996/08/19  11:02:49  daveb
 * [Bug #1551]
 * Made to_string and from_string preserve terminating null characters.
 *
@


1.9
log
@Reset bytearray_root when raising Substring.
@
text
@d8 3
d130 2
d137 1
a137 1
  result = allocate_string(length+1);
a138 1
  CSTRING(result)[length] = '\0';
d148 2
a149 2
  result = allocate_bytearray(length-1);
  memcpy(CBYTEARRAY(result), CSTRING(argument), length-1);
d159 2
a160 2
  result = allocate_static_bytearray(length-1);
  memcpy(CBYTEARRAY(result), CSTRING(argument), length-1);
@


1.8
log
@Fixing problem with substring
@
text
@d8 3
d171 2
a172 1
  if(start < 0 || length < 0 || start > bound || start+length > bound)
d174 1
@


1.7
log
@Added a peek_memory operation.
@
text
@d8 3
d166 1
a166 1
  bound = LENGTH(ARRAYHEADER(bytearray_root)) - 1;
@


1.6
log
@Adding num_to_word32() word32_to_num().
Updating to use allocate_word32() and CWORD32().
Made code more GC-safe by moving allocation to end of functions.
@
text
@d8 6
a57 1

d74 1
a74 1
  array   = (int)CBYTEARRAY(FIELD(argument,0));
d85 36
d184 1
@


1.5
log
@Adding address operation for static bytearrays.
@
text
@d8 3
d47 2
d65 1
a65 1
  unsigned *object;
d72 1
a72 1
  result  = allocate_string(5); /* Word32 object */
d74 2
a75 2
  object  = (unsigned *)CSTRING(result);
  *object = (unsigned)(array + offset);
@


1.4
log
@Adding make_static_bytearray
@
text
@d8 3
d58 17
d136 4
a139 3
  env_function("make static bytearray", make_static_bytearray);
  env_function("bytearray to string", to_string);
  env_function("bytearray from string", from_string);
d141 1
a141 1
  env_function("bytearray substring", substring);
@


1.3
log
@Added static_from_string - a version of `from_string' for
static bytearrays.
@
text
@d8 4
d45 10
d116 1
@


1.2
log
@new file
@
text
@d8 3
d64 11
d104 1
@


1.2.1.1
log
@branched from 1.2
@
text
@a7 3
 * Revision 1.2  1994/06/09  14:48:48  nickh
 * new file
 *
@


1.1
log
@new file
@
text
@d7 4
a10 1
 *  $Log: bytearrays.c,v $
@
