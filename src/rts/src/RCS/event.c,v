head	1.18;
access;
symbols
	MLW_daveb_inline_1_4_99:1.18.5
	MLWorks_21c0_1999_03_25:1.18
	MLWorks_20c1_1998_08_20:1.18
	MLWorks_20c0_1998_08_04:1.18
	MLWorks_20b2c2_1998_06_19:1.18
	MLWorks_20b2_Windows_1998_06_12:1.18
	MLWorks_20b1c1_1998_05_07:1.18
	MLWorks_20b0_1998_04_07:1.18
	MLWorks_20b0_1998_03_20:1.18
	MLWorks_20m2_1998_02_16:1.18
	MLWorks_MM_adapt:1.18.4
	MLWorks_20m1_1997_10_23:1.18
	MLWorks_11r1:1.18.1.1.1.1.1
	MLWorks_workspace_97:1.18.3
	MLWorks_dt_wizard:1.18.2
	MLWorks_11c0_1997_09_09:1.18.1.1.1.1
	MLWorks_10r3:1.18.1.1.3
	MLWorks_10r2_551:1.18.1.1.2
	MLWorks_11:1.18.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.18.1.1
	MLWorks_20m0_1997_06_20:1.18
	MLWorks_1_0_r2c2_1997_06_14:1.18.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.18.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.18.1
	MLWorks_BugFix_1997_04_24:1.18
	MLWorks_1_0_r2_Win32_1997_04_11:1.18
	MLWorks_1_0_r2_Unix_1997_04_04:1.18
	MM_ML_release_korma_1997_04_01:1.18
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.17.7.1.1
	MLWorks_gui_1996_12_18:1.17.8
	MLWorks_1_0_Win32_1996_12_17:1.17.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.17.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.17.4.1
	JFHrts:1.17.6
	MLWorks_1_0_Irix_1996_11_28:1.17.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.17.5
	MLWorks_1_0_Unix_1996_11_14:1.17.4
	MLWorks_Open_Beta2_1996_10_11:1.17.3
	MLWorks_License_dev:1.17.2
	MLWorks_1_open_beta_1996_09_13:1.17.1
	MLWorks_Open_Beta_1996_08_22:1.17
	MLWorks_Beta_1996_07_02:1.17
	MLWorks_Beta_1996_06_07:1.16
	MLWorks_Beta_1996_06_06:1.16
	MLWorks_Beta_1996_06_05:1.16
	MLWorks_Beta_1996_06_03:1.16
	MLWorks_Beta_1996_05_31:1.16
	MLWorks_Beta_1996_05_30:1.16
	hope_poo:1.3.1
	ML_beta_release_12/08/94:1.3.1.1
	ML_beta_release_03/08/94:1.3;
locks; strict;
comment	@ * @;


1.18
date	97.01.27.16.41.12;	author andreww;	state Exp;
branches
	1.18.1.1
	1.18.2.1
	1.18.3.1
	1.18.4.1
	1.18.5.1;
next	1.17;

1.17
date	96.06.27.15.29.38;	author jont;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1
	1.17.4.1
	1.17.5.1
	1.17.6.1
	1.17.7.1
	1.17.8.1;
next	1.16;

1.16
date	96.02.19.13.58.00;	author nickb;	state Exp;
branches;
next	1.15;

1.15
date	96.02.16.18.39.06;	author nickb;	state Exp;
branches;
next	1.14;

1.14
date	96.02.16.14.38.30;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	96.02.13.16.30.56;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	96.02.07.11.04.54;	author nickb;	state Exp;
branches;
next	1.11;

1.11
date	96.01.19.11.36.45;	author nickb;	state Exp;
branches;
next	1.10;

1.10
date	96.01.17.15.23.41;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	96.01.12.15.16.50;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	96.01.11.14.48.27;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	96.01.05.17.35.46;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.09.13.12.56.47;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	95.04.24.13.45.33;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	95.03.29.15.06.54;	author nickb;	state Exp;
branches;
next	1.3;

1.3
date	94.07.08.10.04.48;	author nickh;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	94.06.09.14.41.49;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.11.09.35;	author nickh;	state Exp;
branches;
next	;

1.3.1.1
date	95.07.05.10.29.18;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	96.09.13.11.24.40;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.10.07.16.14.59;	author hope;	state Exp;
branches;
next	;

1.17.3.1
date	96.10.17.11.34.25;	author hope;	state Exp;
branches;
next	;

1.17.4.1
date	96.11.14.13.00.04;	author hope;	state Exp;
branches
	1.17.4.1.1.1;
next	;

1.17.4.1.1.1
date	96.11.28.15.10.07;	author hope;	state Exp;
branches;
next	;

1.17.5.1
date	96.11.22.18.17.53;	author hope;	state Exp;
branches;
next	;

1.17.6.1
date	96.12.17.10.04.36;	author hope;	state Exp;
branches;
next	;

1.17.7.1
date	96.12.17.17.56.12;	author hope;	state Exp;
branches
	1.17.7.1.1.1;
next	;

1.17.7.1.1.1
date	97.02.24.11.47.47;	author hope;	state Exp;
branches;
next	;

1.17.8.1
date	96.12.18.09.50.51;	author hope;	state Exp;
branches;
next	;

1.18.1.1
date	97.05.12.10.44.30;	author hope;	state Exp;
branches
	1.18.1.1.1.1
	1.18.1.1.2.1
	1.18.1.1.3.1;
next	;

1.18.1.1.1.1
date	97.07.28.18.29.40;	author daveb;	state Exp;
branches
	1.18.1.1.1.1.1.1;
next	;

1.18.1.1.1.1.1.1
date	97.10.07.11.55.29;	author jkbrook;	state Exp;
branches;
next	;

1.18.1.1.2.1
date	97.09.08.17.22.39;	author daveb;	state Exp;
branches;
next	;

1.18.1.1.3.1
date	97.09.09.14.18.42;	author daveb;	state Exp;
branches;
next	;

1.18.2.1
date	97.09.10.19.38.14;	author brucem;	state Exp;
branches;
next	;

1.18.3.1
date	97.09.11.21.05.57;	author daveb;	state Exp;
branches;
next	;

1.18.4.1
date	97.10.31.13.49.01;	author nickb;	state Exp;
branches;
next	;

1.18.5.1
date	99.04.01.18.04.38;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.18
log
@[Bug #1891]
Making event EV_SWITCH yield its thread only if its not in
a critical section.
@
text
@/*  ==== EVENT HANDLER ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Implementation
 *  --------------
 *  This is a mostly-portable interface to ML events. The harder,
 *  non-portable stuff is mostly in signals.[ch] now.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:event.c,v $
 * Revision 1.17  1996/06/27  15:29:38  jont
 * Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
 *
 * Revision 1.16  1996/02/19  13:58:00  nickb
 * Get rid of clear_handlers().
 *
 * Revision 1.15  1996/02/16  18:39:06  nickb
 * Clear up roots on export.
 *
 * Revision 1.14  1996/02/16  14:38:30  nickb
 * Change to declare_global().
 *
 * Revision 1.13  1996/02/13  16:30:56  jont
 * Add some type casts to get compilation under VC++ to work without warnings
 *
 * Revision 1.12  1996/02/07  11:04:54  nickb
 * Reduce allocation at event time by pre-allocating a bunch of event structures.
 *
 * Revision 1.11  1996/01/19  11:36:45  nickb
 * Need global state fix for ml_interrupt_handler.
 *
 * Revision 1.10  1996/01/17  15:23:41  nickb
 * Disable interrupt handling except when a handler is defined.
 *
 * Revision 1.9  1996/01/12  15:16:50  nickb
 * Change protocol of thread_preemption_pending.
 *
 * Revision 1.8  1996/01/11  14:48:27  nickb
 * Remove "every n event" window updates; these are now done by a timer.
 *
 * Revision 1.7  1996/01/05  17:35:46  nickb
 * Add interrupt and stack-overflow events.
 *
 * Revision 1.6  1995/09/13  12:56:47  jont
 * Add a clear_handlers function for use by exportFn
 *
 * Revision 1.5  1995/04/24  13:45:33  nickb
 * Add thread_preemption_pending stuff, and X expose events.
 *
 * Revision 1.4  1995/03/29  15:06:54  nickb
 * Threads system.
 *
 * Revision 1.3  1994/07/08  10:04:48  nickh
 * Add explicit stack overflow and interrupt interfaces.
 *
 * Revision 1.2  1994/06/09  14:41:49  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:09:35  nickh
 * new file
 *
 *  Revision 1.4  1994/01/28  17:22:29  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.3  1993/04/26  11:46:58  richard
 *  Increased diagnostic level of various messages.
 *
 *  Revision 1.2  1992/11/10  11:35:06  clive
 *  Modified to allow nested event polling
 *
 *  Revision 1.1  1992/11/04  14:23:30  richard
 *  Initial revision
 *
 */

#include "syscalls.h"
#include "event.h"
#include "global.h"
#include "values.h"
#include "allocator.h"
#include "diagnostic.h"
#include "interface.h"
#include "implicit.h"
#include "utils.h"
#include "gc.h"
#include "alloc.h"
#include "signals.h"
#include "exceptions.h"
#include "environment.h"
#include "threads.h"
#include "os.h"

#include <errno.h>

/*  == ML event handlers ==
 * 
 * We have some ML event handlers for non-signal events, and an ML array of
 * handlers for signal events */

static mlval ml_interrupt_handler = MLUNIT;
static mlval ml_stack_overflow_handler = MLUNIT;
static mlval ml_signal_handlers = MLUNIT;

/*  This routine is called by the global state handler when an image is
 *  reloaded.  It runs through the ML signal handler table and sets up the
 *  C signal handler for any declared handlers.
 */

static void fix_ml_signal_handlers(const char *name, mlval *root, mlval value)
{
  int i;

  *root = value;

  for(i=1; i<(int)signal_nr_signals; ++i)
  {
    mlval handler = MLSUB(value, i);

    DIAGNOSTIC(4, "  handler for %d is 0x%X", i, handler);

    if(handler != MLUNIT)
      if (signal_set_ml_handler(i))
	error ("Couldn't fix signal handler for signal %d. "
	       "errno set to %d", i, errno);
  }
}

static mlval make_ml_signal_handler_array(void)
{
  mlval result = allocate_array(signal_nr_signals);
  unsigned int i;
  for(i=0; i<signal_nr_signals; ++i)
    MLUPDATE(result, i, MLUNIT);
  return result;
}

static void replace_ml_signal_handlers(const char *name, mlval *root)
{
  *root = make_ml_signal_handler_array();
}

static void fix_ml_interrupt_handler(const char *name,
				     mlval *root, mlval value)
{
  *root = value;
  if (value != MLUNIT)
    if (signal_set_interrupt_handler())
      error("Couldn't set interrupt handler");
}

/* the event queue */

struct event {
  int type;	/* from the enum defined in event.h */
  word value;	/* some ancillary value */
  struct event *forward, *back;
} event_queue, *free_events;

/* establish the free event list */

#define EVENT_BUFFER_SIZE		20

static void allocate_some_events(void)
{
  int i;
  struct event *event;

  event = (struct event *)alloc(sizeof(struct event) * EVENT_BUFFER_SIZE,
				"Couldn't allocate events");
  free_events = event;
  for (i = EVENT_BUFFER_SIZE-1; i; i--) {
    event->forward = event+1;
    event++;
  }
  event->forward = NULL;
}

static void free_event(struct event *event)
{
  event->forward = free_events;
  free_events = event;
}

static struct event *alloc_event(void)
{
  struct event *event;
  if (free_events == NULL)
    allocate_some_events();
  event = free_events;
  free_events = event->forward;
  return event;
}

/*  === POLL EVENTS ===  */

void ev_poll()
{
  DIAGNOSTIC(2, "ev_poll()  %d pending events", event_queue.value, 0);

  /* Always check the start of the queue in case there are nested calls to */
  /* ev_poll() or more events are introduced during a handler. */

  while(event_queue.forward->type != EV_SENTINEL)
  {
    struct event *current = event_queue.forward;
    struct event event = *current;

    event.back->forward = event.forward;
    event.forward->back = event.back;
    --event_queue.value;
    free_event(current);

    switch(event.type) {
    case EV_SIGNAL:
      callml(MLINT(event.value), MLSUB(ml_signal_handlers, event.value));
      break;
    case EV_STACK:
      if (ml_stack_overflow_handler != MLUNIT)
	callml(MLUNIT, ml_stack_overflow_handler);
      break;
    case EV_INTERRUPT:
      if (ml_interrupt_handler != MLUNIT) {
	thread_in_critical_section = 0;
	callml(MLUNIT, ml_interrupt_handler);}
      break;
    case EV_SWITCH:
      if (!thread_in_critical_section) {(void)thread_yield(MLUNIT);}
	else return;
      break;
    case EV_WINDOWS:
      os_update_windows();
      break;
    default:
      error("Unknown event type %d found on event queue", event.type);
    }
  }
}

/* add an event to the event queue */

extern void record_event(int type, word value)
{
  struct event *event;

  event = alloc_event();
  event->type = type;
  event->value = value;

  event->forward = &event_queue;
  event->back = event_queue.back;
  event->forward->back = event;
  event->back->forward = event;
  ++event_queue.value;
  signal_event();
}

/* install/remove a signal event handler */

static inline void event_set_signal_handler(int sig, mlval handler)
{
  if (handler == MLUNIT ?
      signal_clear_ml_handler(sig)
      : signal_set_ml_handler(sig))
    switch(errno) {
    case ESIGNALNO:
      exn_raise_string (perv_exn_ref_signal, "Illegal signal number");
    default:
      exn_raise_string (perv_exn_ref_signal, "Unexpected error");
    }
   
  MLUPDATE(ml_signal_handlers, (unsigned) sig, handler);
}

/*  === REGISTER A SIGNAL EVENT HANDLER ===
 *
 *  An ML function may be registered to be called when a signal occurs.  (In
 *  fact, it will be called at the next `safe' opportunity).
 *
 *  event_signal takes a pair: a signal number and an ML function,
 *  (type int -> unit) to call. It return MLUNIT.
 */

static mlval event_signal(mlval argument)
{
  int sig = CINT(FIELD(argument, 0));
  mlval handler = FIELD(argument,1);

  DIAGNOSTIC(2, "event_signal(sig = %d, handler = 0x%X)", sig, handler);

  if (sig <= 0 || sig >= (int)signal_nr_signals)
    exn_raise_string (perv_exn_ref_signal, "Illegal signal number");

  event_set_signal_handler(sig, handler);

  return (MLUNIT);
}

/* set/unset the stack overflow handler */

static mlval event_stack_overflow(mlval handler)
{
  ml_stack_overflow_handler = handler;
  return MLUNIT;
}

/* set/unset the interrupt handler */

static mlval event_interrupt(mlval handler)
{
  ml_interrupt_handler = handler;
  if (handler == MLUNIT ?
      signal_clear_interrupt_handler() :
      signal_set_interrupt_handler())
    exn_raise_string (perv_exn_ref_signal, "Unexpected error");
  return MLUNIT;
}

/*  === INITIALISE ===  */

void ev_init(void)
{
  /* Empty the event queue */
  event_queue.forward = event_queue.back = &event_queue;
  event_queue.value = 0;

  allocate_some_events();

  ml_signal_handlers = make_ml_signal_handler_array();
  ml_interrupt_handler = MLUNIT;
  ml_stack_overflow_handler = MLUNIT;

  declare_global("signal event handler table", &ml_signal_handlers,
		 GLOBAL_ENV, NULL, fix_ml_signal_handlers,
		 replace_ml_signal_handlers);
  declare_global("interrupt handler", &ml_interrupt_handler,
		 GLOBAL_ENV+GLOBAL_MISSING_UNIT,
		 NULL, fix_ml_interrupt_handler, NULL);
  declare_global("stack overflow handler", &ml_stack_overflow_handler,
		 GLOBAL_ENV+GLOBAL_MISSING_UNIT, NULL, NULL, NULL);

  env_function ("event signal", event_signal);
  env_function ("event signal stack overflow", event_stack_overflow);
  env_function ("event signal interrupt", event_interrupt);
}
@


1.18.5.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a12 5
 * Revision 1.18  1997/01/27  16:41:12  andreww
 * [Bug #1891]
 * Making event EV_SWITCH yield its thread only if its not in
 * a critical section.
 *
@


1.18.4.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a12 5
 * Revision 1.18  1997/01/27  16:41:12  andreww
 * [Bug #1891]
 * Making event EV_SWITCH yield its thread only if its not in
 * a critical section.
 *
@


1.18.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a12 5
 * Revision 1.18  1997/01/27  16:41:12  andreww
 * [Bug #1891]
 * Making event EV_SWITCH yield its thread only if its not in
 * a critical section.
 *
@


1.18.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a12 5
 * Revision 1.18  1997/01/27  16:41:12  andreww
 * [Bug #1891]
 * Making event EV_SWITCH yield its thread only if its not in
 * a critical section.
 *
@


1.18.1.1
log
@branched from 1.18
@
text
@a12 5
 * Revision 1.18  1997/01/27  16:41:12  andreww
 * [Bug #1891]
 * Making event EV_SWITCH yield its thread only if its not in
 * a critical section.
 *
@


1.18.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 3
 * Revision 1.18.1.1  1997/05/12  10:44:30  hope
 * branched from 1.18
 *
@


1.18.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 3
 * Revision 1.18.1.1  1997/05/12  10:44:30  hope
 * branched from 1.18
 *
@


1.18.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 3
 * Revision 1.18.1.1  1997/05/12  10:44:30  hope
 * branched from 1.18
 *
@


1.18.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a12 3
 * Revision 1.18.1.1.1.1  1997/07/28  18:29:40  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.17
log
@Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
@
text
@d13 3
d224 3
a226 2
      if (ml_interrupt_handler != MLUNIT)
	callml(MLUNIT, ml_interrupt_handler);
d229 2
a230 1
      (void)thread_yield(MLUNIT);
@


1.17.8.1
log
@branched from 1.17
@
text
@a12 3
 * Revision 1.17  1996/06/27  15:29:38  jont
 * Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
 *
@


1.17.7.1
log
@branched from 1.17
@
text
@a12 3
 * Revision 1.17  1996/06/27  15:29:38  jont
 * Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
 *
@


1.17.7.1.1.1
log
@branched from 1.17.7.1
@
text
@a12 3
 * Revision 1.17.7.1  1996/12/17  17:56:12  hope
 * branched from 1.17
 *
@


1.17.6.1
log
@branched from 1.17
@
text
@a12 3
 * Revision 1.17  1996/06/27  15:29:38  jont
 * Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
 *
@


1.17.5.1
log
@branched from 1.17
@
text
@a12 3
 * Revision 1.17  1996/06/27  15:29:38  jont
 * Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
 *
@


1.17.4.1
log
@branched from 1.17
@
text
@a12 3
 * Revision 1.17  1996/06/27  15:29:38  jont
 * Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
 *
@


1.17.4.1.1.1
log
@branched from 1.17.4.1
@
text
@a12 3
 * Revision 1.17.4.1  1996/11/14  13:00:04  hope
 * branched from 1.17
 *
@


1.17.3.1
log
@branched from 1.17
@
text
@a12 3
 * Revision 1.17  1996/06/27  15:29:38  jont
 * Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
 *
@


1.17.2.1
log
@branched from 1.17
@
text
@a12 3
 * Revision 1.17  1996/06/27  15:29:38  jont
 * Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a12 3
 * Revision 1.17  1996/06/27  15:29:38  jont
 * Change GLOBAL_MISSING_NIL to GLOBAL_MISSING_UNIT since this is what it really means
 *
@


1.16
log
@Get rid of clear_handlers().
@
text
@d13 3
d333 1
a333 1
		 GLOBAL_ENV+GLOBAL_MISSING_NIL,
d336 1
a336 1
		 GLOBAL_ENV+GLOBAL_MISSING_NIL, NULL, NULL, NULL);
@


1.15
log
@Clear up roots on export.
@
text
@d13 3
a309 4
}

void clear_handlers(void)
{
@


1.14
log
@Change to declare_global().
@
text
@d13 3
d105 1
d121 14
a310 5
  unsigned int i;
  for(i=0; i<signal_nr_signals; ++i)
    MLUPDATE(ml_signal_handlers, i, MLUNIT);
  ml_interrupt_handler = MLUNIT;
  ml_stack_overflow_handler = MLUNIT;
d323 4
a326 2
  ml_signal_handlers = allocate_array(signal_nr_signals);
  clear_handlers();
d328 2
a329 1
		 GLOBAL_DEFAULT, NULL, fix_ml_signal_handlers, NULL);
d331 2
a332 1
		 GLOBAL_DEFAULT, NULL, fix_ml_interrupt_handler, NULL);
d334 1
a334 1
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
@


1.13
log
@Add some type casts to get compilation under VC++ to work without warnings
@
text
@d13 3
d99 1
a99 1
static void fix_ml_signal_handlers(mlval *root, mlval value)
d117 2
a118 1
static void fix_ml_interrupt_handler(mlval *root, mlval value)
d313 1
a313 1
		 fix_ml_signal_handlers);
d315 3
a317 2
		 fix_ml_interrupt_handler);
  declare_global("stack overflow handler", &ml_stack_overflow_handler, NULL);
@


1.12
log
@Reduce allocation at event time by pre-allocating a bunch of event structures.
@
text
@d13 3
d101 1
a101 1
  for(i=1; i<signal_nr_signals; ++i)
d259 1
a259 1
  if (sig <= 0 || sig >= signal_nr_signals)
@


1.11
log
@Need global state fix for ml_interrupt_handler.
@
text
@d13 3
d119 1
d125 36
a160 1
} event_queue;
d179 1
a179 1
    free(current);
d211 1
a211 1
  event = alloc(sizeof(struct event), "Couldn't allocate event");
d300 2
@


1.10
log
@Disable interrupt handling except when a handler is defined.
@
text
@d13 3
d108 9
d266 2
a267 1
  declare_global("interrupt handler", &ml_interrupt_handler, NULL);
@


1.9
log
@Change protocol of thread_preemption_pending.
@
text
@d13 3
d226 4
@


1.8
log
@Remove "every n event" window updates; these are now done by a timer.
@
text
@d13 3
a139 1
      thread_preemption_pending = 0;
@


1.7
log
@Add interrupt and stack-overflow events.
@
text
@d13 3
a106 7
/* 'every so often', we call os_update_windows(). This means that when
 * we're running in a pre-emptive mode, the display is kept up-to-date
 * even when no major GCs occur. */

#define UPDATE_WINDOWS_EVERY 30
int event_count = 0;

a109 6

  event_count++;
  if (UPDATE_WINDOWS_EVERY == event_count) {
    event_count = 0;
    os_update_windows();
  }
@


1.6
log
@Add a clear_handlers function for use by exportFn
@
text
@d13 3
d64 8
a71 7
/*  == ML signal event handler table ==
 *
 *  This is an ML array of signal handler functions, indexed by signal
 *  number.
 */

static mlval ml_handlers = MLUNIT;
d73 1
a73 3
/*  == Fix the signal event handler table ==
 *
 *  This routine is called by the global state handler when an image is
d78 1
a78 1
static void fix_ml_handlers(mlval *root, mlval value)
a80 3

  DIAGNOSTIC(4, "fix_ml_handlers(root = 0x%X, value = 0x%X)", root, value);

d96 5
a100 1
struct event event_queue;
d113 1
a113 1
  DIAGNOSTIC(2, "ev_poll()  %d pending events", event_queue.the.sentinel_count, 0);
d116 1
a116 1
  if (event_count == UPDATE_WINDOWS_EVERY) {
a120 5
  if (thread_preemption_pending) {
    thread_preemption_pending = 0;
    (void)thread_yield(MLUNIT);
  }

d124 1
a124 1
  while(event_queue.forward->type != SENTINEL)
a128 2
    DIAGNOSTIC(3, "  event 0x%X  type %d", event, event.type);

d131 1
a131 1
    --event_queue.the.sentinel_count;
d134 18
a151 5
    switch(event.type)
    {
      case SIGNAL:
      DIAGNOSTIC(3, "    signal %d  code %d", event.the.signal, 0);
      callml(MLINT(event.the.signal), MLSUB(ml_handlers, event.the.signal));
d153 1
a153 2

      default:
d159 18
d179 1
a179 1
static inline void event_set_handler(int sig, mlval handler)
d191 1
a191 1
  MLUPDATE(ml_handlers, (unsigned) sig, handler);
d213 1
a213 4
  if (signal_reserved(sig))
    exn_raise_string (perv_exn_ref_signal, "Reserved signal");

  event_set_handler(sig, handler);
d218 1
a218 1
/* set/unset the stack overflow handler (no reservation checking) */
d222 2
a223 4
  DIAGNOSTIC(2, "event_stack_overflow(handler = 0x%X)", handler, 0);

  event_set_handler(signal_stack_overflow, handler);
  return (MLUNIT);
d226 1
a226 1
/* set/unset the interrupt handler (no reservation checking) */
d230 1
a230 53
  DIAGNOSTIC(2, "event_interrupt(handler = 0x%X)", handler, 0);

  event_set_handler(signal_interrupt, handler);
  return (MLUNIT);
}

/* Signals can be reserved by the runtime or from ML */

static mlval event_signal_reserved(mlval argument)
{
 int result = signal_reserved(CINT(argument));
  
  switch (result) {
  case 0:
    return MLFALSE;
  case 1:
    return MLTRUE;
  default:
    exn_raise_string (perv_exn_ref_signal, "Illegal signal number");
  }
}

static mlval event_reserve_signal(mlval argument)
{
  int result = signal_reserve(CINT(argument));

  if (result == -1) {
    switch (errno) {
      case ESIGNALNO:
      exn_raise_string (perv_exn_ref_signal, "Illegal signal number");
    case ESIGNALRES:
      exn_raise_string (perv_exn_ref_signal, "Signal already reserved");
    default:
      exn_raise_string (perv_exn_ref_signal, "Unexpected error");
    }
  }
  return MLUNIT;
}

static mlval event_release_signal(mlval argument)
{
  int result = signal_release(CINT(argument));

  if (result == -1) {
    switch (errno) {
    case ESIGNALNO:
      exn_raise_string (perv_exn_ref_signal, "Illegal signal number");
    case ESIGNALRES:
      exn_raise_string (perv_exn_ref_signal, "Signal not reserved");
    default:
      exn_raise_string (perv_exn_ref_signal, "Unexpected error");
    }
  }
d238 3
a240 1
    MLUPDATE(ml_handlers, i, MLUNIT);
d249 1
a249 1
  event_queue.the.sentinel_count = 0;
d251 1
a251 2
  /* Initialise the ML signal event handler table */
  ml_handlers = allocate_array(signal_nr_signals);
d253 4
a256 1
  declare_global("signal event handler table", &ml_handlers, fix_ml_handlers);
a258 3
  env_function ("event signal reserve", event_reserve_signal);
  env_function ("event signal release", event_release_signal);
  env_function ("event signal reserved", event_signal_reserved);
@


1.5
log
@Add thread_preemption_pending stuff, and X expose events.
@
text
@d13 3
d265 7
a275 1
  unsigned int i;
d282 1
a282 2
  for(i=0; i<signal_nr_signals; ++i)
    MLUPDATE(ml_handlers, i, MLUNIT);
@


1.4
log
@Threads system.
@
text
@d13 3
d54 1
d98 7
d109 8
a116 1
  if (thread_preemption_on)
d118 1
@


1.3
log
@Add explicit stack overflow and interrupt interfaces.
@
text
@d13 3
d50 1
d97 3
@


1.3.1.1
log
@branched from 1.3
@
text
@a12 3
 * Revision 1.3  1994/07/08  10:04:48  nickh
 * Add explicit stack overflow and interrupt interfaces.
 *
@


1.2
log
@new file
@
text
@d13 3
d122 17
d142 1
a142 2
 *  fact, it will be called at the next `safe' opportunity, so this isn't
 *  much good for SIGBUS etc.).
a147 2
/*  === REGISTER A SIGNAL EVENT HANDLER ===  */

d161 20
a180 9
  if (handler == MLUNIT ?
      signal_clear_ml_handler(sig)
      : signal_set_ml_handler(sig))
    switch(errno) {
    case ESIGNALNO:
      exn_raise_string (perv_exn_ref_signal, "Illegal signal number");
    default:
      exn_raise_string (perv_exn_ref_signal, "Unexpected error");
    }
d182 1
a182 2
  MLUPDATE(ml_handlers, (unsigned) sig, handler);
  
d255 2
@


1.1
log
@new file
@
text
@d12 4
a15 1
 *  $Log: event.c,v $
@
