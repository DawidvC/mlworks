head	1.3;
access;
symbols
	MLW_daveb_inline_1_4_99:1.3.1
	MLWorks_21c0_1999_03_25:1.3
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2
	MLWorks_20b1c1_1998_05_07:1.2
	MLWorks_20b0_1998_04_07:1.2
	MLWorks_20b0_1998_03_20:1.2
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_MM_adapt:1.2.3
	MLWorks_20m1_1997_10_23:1.2
	MLWorks_workspace_97:1.2.2
	MLWorks_dt_wizard:1.2.1
	MLWorks_20m0_1997_06_20:1.1;
locks; strict;
comment	@ * @;


1.3
date	99.03.17.17.26.21;	author johnh;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	97.07.01.14.13.39;	author stephenb;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1;
next	1.1;

1.1
date	97.04.30.14.14.09;	author stephenb;	state Exp;
branches;
next	;

1.2.1.1
date	97.09.10.19.38.07;	author brucem;	state Exp;
branches;
next	;

1.2.2.1
date	97.09.11.21.05.50;	author daveb;	state Exp;
branches;
next	;

1.2.3.1
date	97.10.31.13.48.53;	author nickb;	state Exp;
branches;
next	;

1.3.1.1
date	99.04.01.18.04.31;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
[Bug #30030]
@


1.3
log
@[Bug #190529]
Add support (expose declaring/retracting of gc roots) for stub generator.
@
text
@/* Copyright 1997 The Harlequin Group Limited.  All rights reserved.
 *
 * The C side of the C<->ML Interface.
 *
 *.builtin: various functions defined here should be builtin to
 * the compiler for improved performance.
 *
 *.os: The interface is split into two parts, the OS independent part which
 * resides in this file and the OS dependent part which resides in mlw_ci_os.c
 * The split has been done such that the only function that the OS part
 * exports is the initialisation function (mlw_ci_os_init).  An alternative
 * would be do all initialisation here and have the OS dependent part export
 * those functions that need to be registered.  There are pros and cons
 * either way.  If the current mechanism is too constraining, then by all
 * means change to the alternative one.
 *
 * Revision Log
 * ------------
 *
 * $Log: src:mlw_ci.c,v $
 * Revision 1.2  1997/07/01  14:13:39  stephenb
 * [Bug #30029]
 * Renaming
 *
 * Revision 1.1  1997/04/30  14:14:09  stephenb
 * new unit
 * [Bug #30030]
 *
 */

#include <string.h>		/* memcpy */
#include "alloc.h"		/* malloc, free, realloc */
#include "allocator.h"		/* allocate_word32, allocate_string */
#include "values.h"		/* CWORD32 */
#include "gc.h"			/* declare_root, retract_root */
#include "environment.h"	/* env_function */
#include "mlw_ci.h"
#include "mlw_ci_init.h"	/* mlw_ci_init */
#include "mlw_ci_os_init.h"	/* mlw_ci_os_init */
#include "mlw_ci_io.h"		/* mlw_ci_io_init */



/*
** A generic boxed integer constructor -- allocates in ML heap.
** With the assumption that sizeof(int) == sizeof(long) == ... etc.,
** and with enough casts, this can be used to construct all boxed 
** values.
*/
mlw_ci_export mlw_val mlw_ci_boxi_make(unsigned int i)
{
  mlw_val v= allocate_word32();
  unsigned int * vp= (unsigned int *)CWORD32(v);
  *vp= i;
  return v;
}

/* 
** Needed to be able to pass back several or more values to ML.
*/
mlw_ci_export mlw_val mlw_ci_tuple_make(int n)
{
  mlw_val v = allocate_record(n);
  return v;
}

/* Used in conjunction with the above tuple making function to 
** ensure gc safety when allocating multiple ML values.
*/
mlw_ci_export void declare_gc_root (mlw_val v)
{
  declare_root (&v, 0);
}

mlw_ci_export void retract_gc_root (mlw_val v)
{
  retract_root (&v);
}



mlw_ci_export mlw_val mlw_ci_real_make(double d)
{
  mlw_val r= allocate_real();
  SETREAL(r, d);
  return r;
}




/*
** C.deRef8 : C.void C.ptr -> Word8.word
**
** Could and should be made into a compiler builtin.
*/
static mlw_val mlw_ci_void_ptr_de_ref8(mlw_val arg)
{
  unsigned char * cp= (unsigned char *)mlw_ci_void_ptr_to_voidp(arg);
  return mlw_ci_uchar_from_uchar(*cp);
}



/*
** C.deRef16 : C.void C.ptr -> Word16.word
**
** Could and should be made into a compiler builtin.
*/
static mlw_val mlw_ci_void_ptr_de_ref16(mlw_val arg)
{
  unsigned short * p= (unsigned short *)mlw_ci_void_ptr_to_voidp(arg);
  return mlw_ci_ushort_from_ushort(*p);
}



/*
** C.deRef32 : C.void C.ptr -> Word32.word
**
** Could and should be made into a compiler builtin.
*/
static mlw_val mlw_ci_void_ptr_de_ref32(mlw_val arg)
{
  void * wp= mlw_ci_void_ptr_to_voidp(arg);
  unsigned int w= *(unsigned int *)wp;
  return mlw_ci_word32_from_uint(w);
}



/*
** C.deRef32 : C.void C.ptr -> Word32.word
**
** Could and should be made into a compiler builtin.
*/
static mlw_val mlw_ci_void_ptr_de_ref_real(mlw_val arg)
{
  void * vp= mlw_ci_void_ptr_to_voidp(arg);
  double d= *(double *)vp;
  return mlw_ci_real_from_double(d);
}




/*
** C.update8 : C.void C.ptr * Word8.word -> unit
**
** Could and should be made into a compiler builtin.
*/
static mlw_val mlw_ci_void_ptr_update8(mlw_val arg)
{
  unsigned char * cp= (unsigned char *)mlw_ci_void_ptr_to_voidp(mlw_arg(arg, 0));
  unsigned char c= mlw_ci_uchar_to_uchar(mlw_arg(arg, 1));
  *cp= c;
  return mlw_val_unit;
}



/*
** C.update16 : C.void C.ptr * Word.word -> unit
**
** Could and should be made into a compiler builtin.
*/
static mlw_val mlw_ci_void_ptr_update16(mlw_val arg)
{
  unsigned short * sp= mlw_ci_void_ptr_to_voidp(mlw_arg(arg, 0));
  unsigned short s= mlw_ci_ushort_to_ushort(mlw_arg(arg, 1));
  *sp= s;
  return mlw_val_unit;
}



/*
** C.update32 : C.void C.ptr * Word32.word -> unit
**
** Could and should be made into a compiler builtin.
*/
static mlw_val mlw_ci_void_ptr_update32(mlw_val arg)
{
  unsigned int * wp= mlw_ci_void_ptr_to_voidp(mlw_arg(arg, 0));
  unsigned int w= mlw_ci_word32_to_uint(mlw_arg(arg, 1));
  *wp= w;
  return mlw_val_unit;
}



/*
** C.updateReal : C.void C.ptr * Real.real -> unit
**
** Could and should be made into a compiler builtin.
*/
static mlw_val mlw_ci_void_ptr_update_real(mlw_val arg)
{
  double * dp= (double *)mlw_ci_void_ptr_to_voidp(mlw_arg(arg, 0));
  double   d= mlw_ci_real_to_double(mlw_arg(arg, 1));
  *dp= d;
  return mlw_val_unit;
}




/*
** C.malloc : Word.word -> C.void C.ptr
**
*/
static mlw_val mlw_ci_malloc(mlw_val arg)
{
  size_t sz= (size_t)mlw_val_word_to_uint(arg);
  void *p= malloc(sz);
  return mlw_ci_void_ptr_from_voidp(p);
}



/*
** C.realloc : C.void C.ptr * Word.word -> C.void C.ptr
**
*/
static mlw_val mlw_ci_realloc(mlw_val arg)
{
  void *p= mlw_ci_void_ptr_to_voidp(mlw_arg(arg, 0));
  size_t sz= (size_t)mlw_val_word_to_uint(mlw_arg(arg, 1));
  void *np= realloc(p, sz);
  return mlw_ci_void_ptr_from_voidp(np);
}



/*
** C.free : C.void C.ptr -> unit
**
*/
static mlw_val mlw_ci_free(mlw_val arg)
{
  void *p= mlw_ci_void_ptr_to_voidp(arg);
  free(p);
  return mlw_val_unit;
}




/*
** C.memcpy : {from: C.void C.ptr, to: C.void C.ptr, size: Word.word} -> unit
**
*/
static mlw_val mlw_ci_memcpy(mlw_val arg)
{
  void *fp= mlw_ci_void_ptr_to_voidp(mlw_arg(arg, 0));
  size_t sz= (size_t)mlw_val_word_to_uint(mlw_arg(arg, 1));
  void *tp= mlw_ci_void_ptr_to_voidp(mlw_arg(arg, 2));
  (void)memcpy(tp, fp, sz);
  return mlw_val_unit;
}



/*
** C.CharPtr.fromString : string -> C.Char.char C.ptr
**
*/
static mlw_val mlw_ci_char_ptr_from_string(mlw_val arg)
{
  char const *s= mlw_ci_str_to_charp(arg);
  size_t l= mlw_ci_str_length(arg);
  char *p= malloc(l);
  if (p != NULL)
    memcpy(p, s, l);
  return mlw_ci_char_ptr_from_charp(p);
}



/*
** C.CharPtr.toString : C.Char.char C.ptr -> string
**
*/
static mlw_val mlw_ci_char_ptr_to_string(mlw_val arg)
{
  char *p= mlw_ci_char_ptr_to_charp(arg);
  return ml_string(p);
}


/*
** C.CharPtr.toStringN : C.CharPtr.ptr * Word.word -> string
**
*/
static mlw_val mlw_ci_char_ptr_to_string_n(mlw_val arg)
{
  char *p= mlw_ci_char_ptr_to_charp(mlw_arg(arg, 0));
  unsigned int l= mlw_val_word_to_uint(mlw_arg(arg, 1));
  mlw_val s= allocate_string(l+1);
  memcpy(CSTRING(s), p, l);
  CSTRING(s)[l]= '\0';
  return s;
}



void mlw_ci_init(void)
{
  env_function("C.VoidPtr.deRef8",     mlw_ci_void_ptr_de_ref8);
  env_function("C.VoidPtr.deRef16",    mlw_ci_void_ptr_de_ref16);
  env_function("C.VoidPtr.deRef32",    mlw_ci_void_ptr_de_ref32);
  env_function("C.VoidPtr.deRefReal",  mlw_ci_void_ptr_de_ref_real);
  env_function("C.VoidPtr.update8",    mlw_ci_void_ptr_update8);
  env_function("C.VoidPtr.update16",   mlw_ci_void_ptr_update16);
  env_function("C.VoidPtr.update32",   mlw_ci_void_ptr_update32);
  env_function("C.VoidPtr.updateReal", mlw_ci_void_ptr_update_real);

  env_function("C.Memory.malloc",  mlw_ci_malloc);
  env_function("C.Memory.realloc", mlw_ci_realloc);
  env_function("C.Memory.free",    mlw_ci_free);
  env_function("C.Memory.copy",    mlw_ci_memcpy);

  env_function("C.CharPtr.fromString", mlw_ci_char_ptr_from_string);
  env_function("C.CharPtr.toString",   mlw_ci_char_ptr_to_string);
  env_function("C.CharPtr.toStringN",  mlw_ci_char_ptr_to_string_n);

  mlw_ci_os_init();
  mlw_ci_io_init();
}
@


1.3.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a20 4
 * Revision 1.3  1999/03/17  17:26:21  johnh
 * [Bug #190529]
 * Add support (expose declaring/retracting of gc roots) for stub generator.
 *
@


1.2
log
@[Bug #30029]
Renaming
@
text
@d21 4
d58 21
@


1.2.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a20 4
 * Revision 1.2  1997/07/01  14:13:39  stephenb
 * [Bug #30029]
 * Renaming
 *
@


1.2.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a20 4
 * Revision 1.2  1997/07/01  14:13:39  stephenb
 * [Bug #30029]
 * Renaming
 *
@


1.2.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a20 4
 * Revision 1.2  1997/07/01  14:13:39  stephenb
 * [Bug #30029]
 * Renaming
 *
@


1.1
log
@new unit
[Bug #30030]
@
text
@d2 24
a25 20
**
** The C side of the C<->ML Interface.
**
**.builtin: various functions defined here should be builtin to
** the compiler for improved performance.
**
**.os: The interface is split into two parts, the OS independent part which
** resides in this file and the OS dependent part which resides in mlw_ci_os.c
** The split has been done such that the only function that the OS part
** exports is the initialisation function (mlw_ci_os_init).  An alternative
** would be do all initialisation here and have the OS dependent part export
** those functions that need to be registered.  There are pros and cons
** either way.  If the current mechanism is too constraining, then by all
** means change to the alterative one.
**
** Revision Log
** ------------
**
** $Log$
*/
a30 1
#include "exceptions.h"		/* exn_raise_syserr */
d36 1
d46 1
a46 1
mlw_ci_export mlw_val mlw_ml_boxi_make(unsigned int i)
d57 10
d68 1
a68 1
** C.VoidPtr.deRef8 : C.VoidPtr.ptr -> char
d74 2
a75 2
  char * cp= (char *)mlw_val_c_void_ptr_to_voidp(arg);
  return mlw_val_int_from_int((int)*cp);
d81 1
a81 1
** C.VoidPtr.deRef16 : C.VoidPtr.ptr -> int
d87 2
a88 2
  unsigned short * p= (unsigned short *)mlw_val_c_void_ptr_to_voidp(arg);
  return mlw_val_int_from_int((int)*p);
d94 1
a94 1
** C.VoidPtr.deRef32 : C.VoidPtr.ptr -> Word32.word
d100 1
a100 1
  void * wp= mlw_val_c_void_ptr_to_voidp(arg);
d102 15
a116 1
  return mlw_val_word32_from_uint(w);
d123 1
a123 1
** C.VoidPtr.update8 : C.VoidPtr.ptr * char -> unit
d129 2
a130 2
  char * cp= (char *)mlw_val_c_void_ptr_to_voidp(mlw_arg(arg, 0));
  char c= mlw_val_char_to_char(mlw_arg(arg, 1));
d138 1
a138 1
** C.VoidPtr.update16 : C.VoidPtr.ptr * Word.word -> unit
d144 2
a145 2
  unsigned short * sp= mlw_val_c_void_ptr_to_voidp(mlw_arg(arg, 0));
  unsigned short s= mlw_val_word_to_uint(mlw_arg(arg, 1));
d153 1
a153 1
** C.VoidPtr.update32 : C.VoidPtr.ptr * Word32.word -> unit
d159 2
a160 2
  unsigned int * wp= mlw_val_c_void_ptr_to_voidp(mlw_arg(arg, 0));
  unsigned int w= mlw_val_word32_to_uint(mlw_arg(arg, 1));
d168 17
a184 1
** C.Memory.malloc : Word.word -> C.VoidPtr.ptr
d187 1
a187 1
static mlw_val mlw_ci_memory_malloc(mlw_val arg)
d191 1
a191 1
  return mlw_val_c_void_ptr_from_voidp(p);
d197 1
a197 1
** C.Memory.realloc : C.VoidPtr.ptr * Word.word -> C.VoidPtr.ptr
d200 1
a200 1
static mlw_val mlw_ci_memory_realloc(mlw_val arg)
d202 1
a202 1
  void *p= mlw_val_c_void_ptr_to_voidp(mlw_arg(arg, 0));
d205 1
a205 1
  return mlw_val_c_void_ptr_from_voidp(np);
d211 1
a211 1
** C.Memory.free : C.VoidPtr.addr -> unit
d214 1
a214 1
static mlw_val mlw_ci_memory_free(mlw_val arg)
d216 1
a216 1
  void *p= mlw_val_c_void_ptr_to_voidp(arg);
d225 1
a225 1
** C.Memory.copy : {from: C.VoidPtr.ptr, to: C.VoidPtr.ptr, size: Word.word} -> unit
d228 1
a228 1
static mlw_val mlw_ci_memory_copy(mlw_val arg)
d230 1
a230 1
  void *fp= mlw_val_c_void_ptr_to_voidp(mlw_arg(arg, 0));
d232 1
a232 1
  void *tp= mlw_val_c_void_ptr_to_voidp(mlw_arg(arg, 2));
d240 1
a240 1
** C.CharPtr.fromString : string -> C.CharPtr.ptr
d245 2
a246 2
  char const *s= mlw_val_str_to_charp(arg);
  size_t l= mlw_val_str_length(arg);
d248 3
a250 5
  if (p == NULL) {
    /* XXX: do something here */
  }
  memcpy(p, s, l);
  return mlw_val_c_char_ptr_from_charp(p);
d256 1
a256 1
** C.CharPtr.toString : C.CharPtr.ptr -> string
d261 1
a261 1
  char *p= mlw_val_c_char_ptr_to_charp(arg);
d272 1
a272 1
  char *p= mlw_val_c_char_ptr_to_charp(mlw_arg(arg, 0));
d284 13
a296 11
  env_function("C.VoidPtr.deRef8",    mlw_ci_void_ptr_de_ref8);
  env_function("C.VoidPtr.deRef16",   mlw_ci_void_ptr_de_ref16);
  env_function("C.VoidPtr.deRef32",   mlw_ci_void_ptr_de_ref32);
  env_function("C.VoidPtr.update8",   mlw_ci_void_ptr_update8);
  env_function("C.VoidPtr.update16",  mlw_ci_void_ptr_update16);
  env_function("C.VoidPtr.update32",  mlw_ci_void_ptr_update32);

  env_function("C.Memory.malloc",  mlw_ci_memory_malloc);
  env_function("C.Memory.realloc", mlw_ci_memory_realloc);
  env_function("C.Memory.free",    mlw_ci_memory_free);
  env_function("C.Memory.copy",    mlw_ci_memory_copy);
d303 1
@
