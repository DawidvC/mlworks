head	1.23;
access;
symbols
	MLW_daveb_inline_1_4_99:1.23.1
	MLWorks_21c0_1999_03_25:1.23
	MLWorks_20c1_1998_08_20:1.22
	MLWorks_20c0_1998_08_04:1.22
	MLWorks_20b2c2_1998_06_19:1.22
	MLWorks_20b2_Windows_1998_06_12:1.22
	MLWorks_20b1c1_1998_05_07:1.22
	MLWorks_20b0_1998_04_07:1.20
	MLWorks_20b0_1998_03_20:1.20
	MLWorks_20m2_1998_02_16:1.19
	MLWorks_MM_adapt:1.19.9
	MLWorks_20m1_1997_10_23:1.19
	MLWorks_11r1:1.19.6.1.1.1.1
	MLWorks_workspace_97:1.19.8
	MLWorks_dt_wizard:1.19.7
	MLWorks_11c0_1997_09_09:1.19.6.1.1.1
	MLWorks_10r3:1.19.6.1.3
	MLWorks_10r2_551:1.19.6.1.2
	MLWorks_11:1.19.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.19.6.1
	MLWorks_20m0_1997_06_20:1.19
	MLWorks_1_0_r2c2_1997_06_14:1.19.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.19.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.19.6
	MLWorks_BugFix_1997_04_24:1.19
	MLWorks_1_0_r2_Win32_1997_04_11:1.19
	MLWorks_1_0_r2_Unix_1997_04_04:1.19
	MM_ML_release_korma_1997_04_01:1.19
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.19.4.1.1
	MLWorks_gui_1996_12_18:1.19.5
	MLWorks_1_0_Win32_1996_12_17:1.19.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.19.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.19.1.1
	JFHrts:1.19.3
	MLWorks_1_0_Irix_1996_11_28:1.19.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.19.2
	MLWorks_1_0_Unix_1996_11_14:1.19.1
	MLWorks_Open_Beta2_1996_10_11:1.18.3
	MLWorks_License_dev:1.18.2
	MLWorks_1_open_beta_1996_09_13:1.18.1
	MLWorks_Open_Beta_1996_08_22:1.18
	MLWorks_Beta_1996_07_02:1.17
	MLWorks_Beta_1996_06_07:1.17
	MLWorks_Beta_1996_06_06:1.17
	MLWorks_Beta_1996_06_05:1.17
	MLWorks_Beta_1996_06_03:1.17
	MLWorks_Beta_1996_05_31:1.17
	MLWorks_Beta_1996_05_30:1.17
	hope_poo:1.2.1
	ML_beta_release_12/08/94:1.2.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.23
date	98.08.21.16.33.35;	author jont;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	98.04.24.10.30.15;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	98.04.23.13.51.56;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	98.03.03.17.23.19;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	96.10.29.17.40.48;	author nickb;	state Exp;
branches
	1.19.1.1
	1.19.2.1
	1.19.3.1
	1.19.4.1
	1.19.5.1
	1.19.6.1
	1.19.7.1
	1.19.8.1
	1.19.9.1;
next	1.18;

1.18
date	96.08.05.14.02.54;	author jont;	state Exp;
branches
	1.18.1.1
	1.18.2.1
	1.18.3.1;
next	1.17;

1.17
date	96.05.22.15.18.40;	author nickb;	state Exp;
branches;
next	1.16;

1.16
date	96.05.01.08.53.07;	author nickb;	state Exp;
branches;
next	1.15;

1.15
date	96.02.14.17.21.18;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	96.02.14.14.56.24;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	96.02.13.17.15.36;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	96.01.11.16.43.31;	author nickb;	state Exp;
branches;
next	1.11;

1.11
date	95.11.27.17.59.42;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.09.26.13.11.27;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	95.09.07.16.00.12;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	95.07.14.10.56.51;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.05.21.16.00.30;	author brianm;	state Exp;
branches;
next	1.6;

1.6
date	95.03.07.10.59.51;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	95.02.28.13.16.03;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	95.02.27.16.53.07;	author nickb;	state Exp;
branches;
next	1.3;

1.3
date	94.11.09.16.42.12;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.48.13;	author nickh;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	94.06.09.11.20.20;	author nickh;	state Exp;
branches;
next	;

1.2.1.1
date	95.07.05.10.29.40;	author hope;	state Exp;
branches;
next	;

1.18.1.1
date	96.09.13.11.22.15;	author hope;	state Exp;
branches;
next	;

1.18.2.1
date	96.10.07.16.12.21;	author hope;	state Exp;
branches;
next	;

1.18.3.1
date	96.10.17.11.31.17;	author hope;	state Exp;
branches;
next	;

1.19.1.1
date	96.11.14.12.57.14;	author hope;	state Exp;
branches
	1.19.1.1.1.1;
next	;

1.19.1.1.1.1
date	96.11.28.15.07.26;	author hope;	state Exp;
branches;
next	;

1.19.2.1
date	96.11.22.18.15.07;	author hope;	state Exp;
branches;
next	;

1.19.3.1
date	96.12.17.10.01.53;	author hope;	state Exp;
branches;
next	;

1.19.4.1
date	96.12.17.17.53.37;	author hope;	state Exp;
branches
	1.19.4.1.1.1;
next	;

1.19.4.1.1.1
date	97.02.24.11.44.37;	author hope;	state Exp;
branches;
next	;

1.19.5.1
date	96.12.18.09.48.11;	author hope;	state Exp;
branches;
next	;

1.19.6.1
date	97.05.12.10.40.35;	author hope;	state Exp;
branches
	1.19.6.1.1.1
	1.19.6.1.2.1
	1.19.6.1.3.1;
next	;

1.19.6.1.1.1
date	97.07.28.18.26.16;	author daveb;	state Exp;
branches
	1.19.6.1.1.1.1.1;
next	;

1.19.6.1.1.1.1.1
date	97.10.07.11.52.07;	author jkbrook;	state Exp;
branches;
next	;

1.19.6.1.2.1
date	97.09.08.17.19.29;	author daveb;	state Exp;
branches;
next	;

1.19.6.1.3.1
date	97.09.09.14.15.37;	author daveb;	state Exp;
branches;
next	;

1.19.7.1
date	97.09.10.19.32.48;	author brucem;	state Exp;
branches;
next	;

1.19.8.1
date	97.09.11.21.02.04;	author daveb;	state Exp;
branches;
next	;

1.19.9.1
date	97.10.31.13.44.57;	author nickb;	state Exp;
branches;
next	;

1.23.1.1
date	99.04.01.18.01.33;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.23
log
@[Bug #20133]
Modify to use GC_HEAP_REAL_LIMIT
@
text
@/*  ==== IMAGE SAVE, LOAD, AND DELIVERY ====
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  The live regions of the ML heap are written out in a straightforward
 *  manner, and a simple fixup() function is used to correct pointers when
 *  the heap is reloaded.  I have endeavoured to do any processing when the
 *  image is loaded rather than when it is saved in order to make saving
 *  fast and non-disruptive.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:image.c,v $
 * Revision 1.22  1998/04/24  10:30:15  jont
 * [Bug #70032]
 * gen->values now measured in bytes
 *
 * Revision 1.21  1998/04/23  13:51:56  jont
 * [Bug #70034]
 * Rationalising names in mem.h
 *
 * Revision 1.20  1998/03/03  17:23:19  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.19  1996/10/29  17:40:48  nickb
 * Fix space lookup for pointers with top bit set.
 *
 * Revision 1.18  1996/08/05  14:02:54  jont
 * [Bug #1529]
 * Add a break at the end of the STORE_STREAM case of read
 *
 * Revision 1.17  1996/05/22  15:18:40  nickb
 * Make fix_entry spot static arrays and weakarrays.
 * Also correct use of static sizes -- they are in bytes, not words.
 *
 * Revision 1.16  1996/05/01  08:53:07  nickb
 * Rearrange stream-independent load and store.
 *
 * Revision 1.15  1996/02/14  17:21:18  jont
 * ISPTR becomes MLVALISPTR
 *
 * Revision 1.14  1996/02/14  14:56:24  jont
 * Changing ERROR to MLERROR
 *
 * Revision 1.13  1996/02/13  17:15:36  jont
 * Add some type casts to preent compiler warnings under VC++
 *
 * Revision 1.12  1996/01/11  16:43:31  nickb
 * Runtime error message buffer problem.
 *
 * Revision 1.11  1995/11/27  17:59:42  jont
 * Add image_load_with_open_file for loading from NT saved executables
 * Add image_save_with_open_file for saving NT saved executables
 *
 * Revision 1.10  1995/09/26  13:11:27  jont
 * Add a version of image_load that can read from store
 * Add a version of image_save that can save to store
 * Add a function to determine how much store is required for an image save
 *
 * Revision 1.9  1995/09/07  16:00:12  jont
 * Delete image files when the write fails
 *
 * Revision 1.8  1995/07/14  10:56:51  nickb
 * Change to definition of OBJECT_SIZE macro.
 *
 * Revision 1.7  1995/05/21  16:00:30  brianm
 * Static objects can now be restored from images.
 *
 * Revision 1.6  1995/03/07  10:59:51  nickb
 * Static object header changed to have a generation pointer.
 *
 * Revision 1.5  1995/02/28  13:16:03  nickb
 * union static_object has become struct static_object.
 *
 * Revision 1.4  1995/02/27  16:53:07  nickb
 * TYPE_LARGE becomes TYPE_STATIC
 *
 * Revision 1.3  1994/11/09  16:42:12  nickb
 * Add instruction cache flushing.
 *
 * Revision 1.2  1994/06/09  14:48:13  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:20:20  nickh
 * new file
 *
 *  Revision 1.22  1994/01/28  17:47:46  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.21  1993/06/02  13:12:56  richard
 *  Changed some print formats from %08X to %p.
 *
 *  Revision 1.20  1993/05/11  13:23:07  daveb
 *  Increased some diagnostic levels.
 *
 *  Revision 1.19  1993/04/29  10:40:46  richard
 *  Increased diagnostic levels.
 *  Rewrote Jon's code for the contents table.
 *
 *  Revision 1.18  1993/04/02  15:38:03  jont
 *  Modified image format to include a header and table of contents
 *  Added an image_table function to return the table as a list of ml strings
 *
 *  Revision 1.17  1993/02/12  13:53:06  jont
 *  Changes for code vector reform.
 *
 *  Revision 1.16  1993/02/01  16:04:26  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.15  1992/11/02  13:07:44  richard
 *  Changed arguments to an ml value.
 *
 *  Revision 1.14  1992/10/02  09:40:41  richard
 *  Added missing consts.
 *
 *  Revision 1.13  1992/08/05  17:33:09  richard
 *  Code vectors are now tagged differently to strings.
 *
 *  Revision 1.12  1992/08/04  06:31:04  richard
 *  New version to deal with a new memory organisation using an
 *  arena manager.  See new gc.c and mem.h.
 *
 *  Revision 1.11  1992/07/30  11:28:07  richard
 *  Allowed pointers outside the heap.
 *
 *  Revision 1.10  1992/07/23  13:56:50  richard
 *  Reimplemented a lot of this to deal with large objects and return
 *  the correct error codes.  It now has more consistency checking as well.
 *
 *  Revision 1.9  1992/07/20  13:16:31  richard
 *  Replaced alloc() by allocate() to avoid clashing with a call in the
 *  memory manager.
 *
 *  Revision 1.8  1992/07/15  15:31:07  richard
 *  image_load now empties the GC_MODIFIED_LIST, as this is empty
 *  when the image is saved.  Changed the array header structure
 *  slightly.
 *
 *  Revision 1.7  1992/07/14  10:31:41  richard
 *  Implemented weak arrays.
 *
 *  Revision 1.6  1992/07/01  15:24:16  richard
 *  Corrected code for large objects, and removed some storage manager specific
 *  things.
 *
 *  Revision 1.5  1992/06/09  10:34:20  richard
 *  NIL is now a valid empty structure.
 *
 *  Revision 1.4  1992/03/23  15:53:58  richard
 *  Removed redundant diagnostics.
 *
 *  Revision 1.3  1992/03/19  11:56:46  richard
 *  Added checksums to images.
 *
 *  Revision 1.2  1992/03/18  15:49:35  richard
 *  Corrected fixup of zero.
 *
 *  Revision 1.1  1992/03/17  16:49:57  richard
 *  Initial revision
 *
 */

#include "ansi.h"
#include "arena.h"
#include "image.h"
#include "mem.h"
#include "gc.h"
#include "diagnostic.h"
#include "alloc.h"
#include "allocator.h"
#include "values.h"
#include "state.h"
#include "pervasives.h"
#include "cache.h"
#include "utils.h"

#include <stddef.h>
#include <stdio.h>
#include <errno.h>
#include <setjmp.h>
#include <string.h>


/*
 * Image format
 * Images now have a header, with three entries
 * plus the data refered to by these entries
 *
 * Entry offset Value
 * 0            Pointer to id string (NULL terminated)
 * 4            Pointer to files contents table (NULL terminated string)
 * 8            Pointer to the image data
 *
 * All pointers are word aligned
 */

#define IMAGE_HEADER_SIZE 12

/*  == Image id string ==
 *
 *  This string is written at the beginning of each image to ensure
 *  consistency.
 */

#define MAX_ID_LENGTH	40
static const char *id = "MLWorks image format 1.5\n";

/*
 * A type suitable for reading from both files and store
 */
struct stream {
  union {
    FILE *file;
    struct {
      void *ptr;
      size_t extent;
      size_t index;
    } store;
    size_t size;
  } the;
  word type;
};

enum stream_tag {
  FILE_STREAM,		/* a real stream */
  STORE_STREAM,		/* reading or writing into store */
  SIZE_STREAM		/* computing the size of a written image */
};

/*  == Bulletproof read, write, and allocate ==
 *
 *  These versions of fread(), fwrite(), and malloc() perform a non-local
 *  jump to the state saved in `problem' if they are unable to read, write,
 *  or allocate.  Both image_save() and image_load() set up an error handler
 *  to deal with this method, which eliminates a lot of checking elsewhere.
 */

static jmp_buf problem;

static void write(const void *whence, size_t size, size_t number, struct stream *stream)
{
  switch (stream->type) {
  case FILE_STREAM:
    if(fwrite(whence, size, number, stream->the.file) != number) 
      longjmp(problem, EIMAGEWRITE);
    break;
  case STORE_STREAM:
    {
      size_t extent = stream->the.store.extent;
      size_t index = stream->the.store.index;
      size_t bytes = size*number;
      void *ptr = stream->the.store.ptr;
      if ((double)size * (double)number > (double)(0xffffffff) || /* Multiply overflow */
	  index > index + bytes || /* Addition overflow */
	  index + bytes > extent /* Run off the end */
	  ) {
	longjmp(problem, EIMAGEWRITE);
      }
      memcpy(((char *)ptr)+index, whence, bytes);
      DIAGNOSTIC(4, "write writing %d bytes at offset %d", bytes,
		 stream->the.store.index);
      stream->the.store.index = index+bytes;
    }
    break;
  case SIZE_STREAM:
    {
      size_t bytes = size*number;
      if ((double)size * (double)number > (double)(0xffffffff)) /* Multiply overflow */
	longjmp(problem, EIMAGEWRITE);
      stream->the.size += bytes;
    }
    break;
  default:
    longjmp(problem, EIMAGEWRITE);
  }
}

static void read(void *whither, size_t size, size_t number, struct stream *stream)
{
  DIAGNOSTIC(4, "read %d of size %d\n", number, size);
  switch (stream->type) {
  case FILE_STREAM:
    DIAGNOSTIC(4, "FILE_STREAM, reading %d of size %d", number, size);
    if(fread(whither, size, number, stream->the.file) != number)
      longjmp(problem, EIMAGEREAD);
    break;
  case STORE_STREAM:
    {
      size_t extent = stream->the.store.extent;
      size_t index = stream->the.store.index;
      size_t bytes = size*number;
      void *ptr = stream->the.store.ptr;
      DIAGNOSTIC(4, "STORE_STREAM, extent %d, index %d", extent, index);
      if ((double)size * (double)number > (double)(0xffffffff) || /* Multiply overflow */
	  index > index + bytes || /* Addition overflow */
	  index + bytes > extent /* Run off the end */
	  ) {
	longjmp(problem, EIMAGEREAD);
      }
      memcpy(whither, ((char *)ptr)+index, bytes);
      stream->the.store.index += bytes;
    }
    break;
  case SIZE_STREAM:
    /* meaningless for reads */
    /* Fall through */
  default:
    longjmp(problem, EIMAGEREAD);
  }
}

static void *allocate(size_t size)
{
  void *p = malloc(size);

  if(p == NULL)
    longjmp(problem, EIMAGEALLOC);

  return(p);
}

/*  == Checksum an area of memory ==  */

static word checksum(word *start, word *end)
{
  word sum = 0xDEC0DE;

  while(start < end)
    sum ^= *start++;

  return(sum);
}



/*  === SAVE AN IMAGE OF THE CURRENT HEAP ===
 *
 *  No processing of the image data is done when writing the image out to
 *  the file.  All pointers are fixed using the information recovered when
 *  it is loaded.
 */

static void image_save_common(struct stream *image, mlval root)
{
  struct ml_heap *gen;
  size_t nr_gens, nr_static;
  unsigned int id_len = word_align(strlen(id));
  unsigned int id_offset = IMAGE_HEADER_SIZE;
  unsigned int table_len = 0;
  unsigned int table_offset = id_offset + id_len;
  mlval table;
  unsigned int image_offset = 0;
  unsigned int i=0;

  /* Calculate the space required for the table of contents. */
  for(table=DEREF(modules); table!=MLNIL; table=MLTAIL(table)) {
    mlval name = FIELD(MLHEAD(table), 0);
    table_len += LENGTH(GETHEADER(name))-1 + 1;
  }
  table_len = word_align(table_len);
  image_offset = table_offset + table_len;

  /* Write the table of contents */

  write(&id_offset, sizeof(unsigned int), 1, image);
  write(&table_offset, sizeof(unsigned int), 1, image);
  write(&image_offset, sizeof(unsigned int), 1, image);

  i = strlen(id);
  write(id, sizeof(char), i, image);
  for(; i < id_len; i++) {
    char c = '\0';
    write(&c, sizeof(char), 1, image);
  }

  for(i=0, table = DEREF(modules); table != MLNIL; table = MLTAIL(table)) {
    mlval name = FIELD(MLHEAD(table), 0);
    unsigned int len = LENGTH(GETHEADER(name))-1;

    write(CSTRING(name), sizeof(char), len, image);

    if (MLTAIL(table) != MLNIL) {
      char c = ' ';
      write(&c, sizeof(char), 1, image);
      i++;
    }

    i += len;
  }
  for(; i < table_len; i++) write("\0", sizeof(char), 1, image);

  /* Write the heap root */
  write(&root, sizeof(mlval), 1, image);

  /* Count the number of generations and static objects so that */
  /* image_load() knows how large to make its tables. */

  nr_gens = nr_static = 0;
  for(gen = creation; gen != NULL; gen = gen->parent) {
    nr_static += gen->nr_static;
    ++nr_gens;
  }

  DIAGNOSTIC(4, "  writing table sizes", 0, 0);
  DIAGNOSTIC(4, "    nr_gens = %u  nr_static = %u", nr_gens, nr_static);

  write(&nr_gens, sizeof(size_t), 1, image);
  write(&nr_static, sizeof(size_t), 1, image);

  /* Write out generation and space descriptors (including their addresses), */
  /* and the live contents of the spaces.  Static objects are not */
  /* included at this stage. */

  DIAGNOSTIC(4, "  writing main heap contents", 0, 0);
  
  for(gen = creation; gen != NULL; gen=gen->parent) {
    word sum;
    mlval *top = (gen == creation) ? gen->top : gen->image_top;
    size_t live = top - gen->start;

    DIAGNOSTIC(4, "    generation 0x%X (%d)", gen, gen->number);
    DIAGNOSTIC(4, "      start 0x%X  top 0x%X", gen->start, top);

    write(&gen, sizeof(struct ml_heap *), 1, image);
    write(gen, sizeof(struct ml_heap), 1, image);
    sum = checksum(gen->start, top);

    DIAGNOSTIC(4, "      checksum 0x%X  live %u", sum, live);
    
    write(gen->start, sizeof(mlval), live, image);
    write(&sum, sizeof(word), 1, image);

  }

  if(nr_static > 0) {
    /* Write out the static objects, including their addresses. */
    
    DIAGNOSTIC(4, "  writing %u static objects", nr_static, 0);

    for(gen = creation; gen != NULL; gen = gen->parent) {
      struct ml_static_object *stat = gen->statics.forward;
      DIAGNOSTIC(4, "   generation %d, sentinel 0x%08x", gen->number, &gen->statics);

      while(stat != &gen->statics) {
	mlval header = stat->object[0];
	mlval secondary = SECONDARY(header);
	mlval length = LENGTH(header);
	size_t size = OBJECT_SIZE(secondary,length);
	word *base = stat->object;
	word *top = (word*)((byte*)base + size);
	word sum = checksum(base, top);

	DIAGNOSTIC(4, "    stat object 0x%08x, %u bytes", stat, size);
	DIAGNOSTIC(4, "      forward 0x%08x back 0x%08x", stat->forward, stat->back);

	write(&stat, sizeof(struct ml_static_object *), 1, image);
	write(stat, sizeof(struct ml_static_object), 1, image);
	write(&size, sizeof(size_t), 1, image);
	write(base, 1, size, image);
	write(&sum, sizeof(word), 1, image);
	stat = stat->forward;
      }
    }
  }
  return;
}

mlval image_save(mlval argument)
{
  char *filename = CSTRING(FIELD(argument, 0));
  mlval root = FIELD(argument, 1);
  FILE *volatile image;
  int code = setjmp(problem);
  struct stream stream;

  if(code != 0) {
    (void)fclose(image);
    /* have to print the message this way because it is of unknown length */
    message_start();
    message_string("image save to '");
    message_string(filename);
    message_string("' failed, '");
    message_string(filename);
    message_string("' removed");
    message_end();
    if (remove(filename) != 0) {
      message_stderr("remove failed on '%s'", filename);
    }
    errno = code;
    return(MLERROR);
  }

  DIAGNOSTIC(2, "image_save(filename = \"%s\", root = 0x%X):", filename, root);

  image = fopen(filename, "wb");
  if(image == NULL) {
    DIAGNOSTIC(4, "  couldn't open file", 0, 0);
    errno = EIMAGEOPEN;
    return(MLERROR);
  }

  stream.type = FILE_STREAM;
  stream.the.file = image;
  (void)image_save_common(&stream, root);
  if(fclose(image) == EOF)
    longjmp(problem, EIMAGEWRITE);

  return(MLUNIT);
}

mlval image_save_with_open_file(FILE *image, mlval root, const char *filename)
{
  int code = setjmp(problem);
  struct stream stream;


  if(code != 0) {
    errno = code;
    return(MLERROR);
  }

  DIAGNOSTIC(2, "image_save(filename = \"%s\", root = 0x%X):", filename, root);

  stream.type = FILE_STREAM;
  stream.the.file = image;
  (void)image_save_common(&stream, root);

  return(MLUNIT);
}

mlval memory_image_save(mlval root, void *ptr, size_t limit, size_t *extent)
{
  int code = setjmp(problem);
  struct stream stream;

  if(code != 0) {
    message("executable image save failed");
    errno = code;
    return(MLERROR);
  }

  stream.type = STORE_STREAM;
  stream.the.store.ptr = ptr;
  stream.the.store.extent = limit;
  stream.the.store.index = 0;
  (void)image_save_common(&stream, root);

  *extent = stream.the.store.index; /* Remember how much used */
  DIAGNOSTIC(1, "Saving heap of size %d", *extent, 0);
  return MLUNIT;
}

mlval memory_image_save_size(mlval root, size_t *extent)
{
  int code = setjmp(problem);
  struct stream stream;

  if(code != 0) {
    message("executable image save failed");
    errno = code;
    return(MLERROR);
  }

  stream.type = SIZE_STREAM;
  stream.the.size = 0;
  (void)image_save_common(&stream, root);

  *extent = stream.the.size; /* Remember how much used */
  DIAGNOSTIC(1, "Heap size computed to be %d", *extent, 0);
  return MLUNIT;
}

/*  === LOAD AN IMAGE, REPLACING THE CURRENT HEAP ===  */


/*  == Pointer conversion tables ==
 *
 *  These static variables point to tables which are used to work out the
 *  correspondence between the memory configuration when the image was saved
 *  and its configuration on loading.
 *
 *  old_gen_table	pointers to where the generation descriptors were
 *  new_gen_table	where they are now
 *  old_stat_table	ditto for stat object headers
 *  new_stat_table
 *  stat_sizes		the size in bytes of the static objects
 *  old_basemap		maps old space numbers to their base address at
 			save time, or NULL if the space was outside the ML heap
 *  new_basemap         maps old space numbers to their new base address
 */

static size_t nr_gens, nr_static;
static struct ml_heap **old_gen_table, **new_gen_table;
static struct ml_static_object **old_stat_table, **new_stat_table;
static size_t *stat_sizes;
static mlval **old_basemap, **new_basemap;


/*  == Fixup an old image pointer ==
 *
 *  This function examines a save-time pointer and finds the object that it
 *  should point to using the pointer conversion tables above.
 */

static void fix(mlval *what)
{
  mlval value = *what;
  int space;
  mlval *base, *object, primary;
  size_t i;

  if(!MLVALISPTR(value))
    return;

  space = SPACE(value);

  if(space >= SPACES_IN_ARENA)
    return;

  base = old_basemap[space];
  object = OBJECT(value);
  primary = PRIMARY(value);

  /* Is the pointer to ML heap? */
  if(base != NULL) {
    *what = MLPTR(object-base+new_basemap[space], primary);
    return;
  }

  /* Is it a pointer to a static object? */
  for(i=0; i<nr_static; ++i) {
    word offset = (word)object - (word)(old_stat_table[i]->object);
    if (offset < (word)stat_sizes[i]) {
      *what = MLPTR((word)(new_stat_table[i]->object) + offset, primary);
      return;
    }
  }

  /* It's outside the heap, so leave it. */
}

#if 0
static void remove_dead_entry(union ml_array_header *array)
{
  array->the.back->the.forward = array->the.forward;
  array->the.forward->the.back = array->the.back;
}
#endif

static void fix_entry(union ml_array_header **what)
{
  union ml_array_header *entry = *what;
  int space = SPACE(entry);
  mlval *base = old_basemap[space];
  size_t i;

  /* Is is a pointer to an array on the dynamic heap? */
  if(base != NULL) {
    *what = (union ml_array_header *)((mlval *)entry-base+new_basemap[space]);
    return;
  }

  /* Maybe it's a pointer to an entry list header in one of the
   * generation descriptors. */

  for(i=0; i<nr_gens; ++i)
    if(entry == &old_gen_table[i]->entry) {
      *what = &new_gen_table[i]->entry;
      return;
    }

  /* Last chance: an entry list header for a static array */
  for(i=0; i<nr_static; ++i) {
    if (entry ==  (union ml_array_header *)(old_stat_table[i]->object)) {
      *what = (union ml_array_header *)(new_stat_table[i]->object);
      return;
    }
  }

  DIAGNOSTIC(4, "bad array header pointer 0x%X at 0x%X", entry, what);
  longjmp(problem, EIMAGEFORMAT);
}

static void fix_static(struct ml_static_object **what)
{
  struct ml_static_object *stat = *what;
  size_t i;

  /* The old positions of the static objects are all in the old_stat_table. */

  for(i=0; i<nr_static; ++i)
    if(stat == old_stat_table[i]) {
      *what = new_stat_table[i];
      return;
    }

  /* If it isn't actually a static object it must be a pointer to a static */
  /* object list header in one of the generation descriptors. */

  for(i=0; i<nr_gens; ++i)
    if(stat == &old_gen_table[i]->statics) {
      *what = &new_gen_table[i]->statics;
      return;
    }

  DIAGNOSTIC(4, "bad static object header pointer 0x%X at 0x%X", stat, what);
  longjmp(problem, EIMAGEFORMAT);
}

static void scan(mlval *start, mlval *end)
{
  while(start < end) {
    mlval value = *start;
    
    switch(PRIMARY(value)) {
      case INTEGER0:
      case INTEGER1:
      case PRIMARY6:
      case PRIMARY7:
      ++start;
      break;
      
      case HEADER:
      switch(SECONDARY(value)) {
	case STRING:
	case BYTEARRAY:
	start = (mlval *)double_align((byte *)(start+1) + LENGTH(value));
	continue;

	case CODE:
	fix(start+1);
	cache_flush((void*)(start+2), (LENGTH(value)+1) * sizeof(mlval));
	start += LENGTH(value)+1;
	continue;
	
	case ARRAY:
	case WEAKARRAY:
	{
	  union ml_array_header *array = (union ml_array_header *)start;
	  
	  if(array->the.back != NULL) {
	    fix_entry(&array->the.forward);
	    fix_entry(&array->the.back);
	  }
	  
	  start = &array->the.element[0];
	}
	break;
	
	default:
	++start;
      }
      break;
      
      default:
      fix(start);
      ++start;
    }
  }
}

static mlval image_load_common (struct stream *image)
{
  struct ml_heap *gen;
  size_t id_length;
  char file_id[MAX_ID_LENGTH];
  mlval root;
  int i;
  unsigned int id_offset, table_offset, image_offset;

  old_gen_table   = new_gen_table   = NULL;
  old_stat_table = new_stat_table   = NULL;
  old_basemap     = new_basemap     = NULL;
  stat_sizes			    = NULL;

  /* Does the image have the correct id? */

  DIAGNOSTIC(4, "  reading id_offset", 0, 0);
  read(&id_offset, sizeof(unsigned int), 1, image);
  DIAGNOSTIC(4, "  reading table_offset", 0, 0);
  read(&table_offset, sizeof(unsigned int), 1, image);
  DIAGNOSTIC(4, "  reading image_offset", 0, 0);
  read(&image_offset, sizeof(unsigned int), 1, image);
  DIAGNOSTIC(4, "  id_offset = %u  table_offset = %u", id_offset, table_offset);
  DIAGNOSTIC(4, "  image_offset = %u", image_offset, 0);
  if(id_offset!=IMAGE_HEADER_SIZE || id_offset>=table_offset || table_offset>image_offset)
    longjmp(problem, EIMAGEFORMAT);

  id_length = strlen(id);
  read(file_id, sizeof(char), id_length, image);
  DIAGNOSTIC(4, "id read was `%.24s'", id, 0);
  if(strncmp(id, file_id, id_length) != 0)
    longjmp(problem, EIMAGEVERSION);
  id_length += id_offset;

  /* Now ignore the name table, not necessary for real loading */
  while(id_length < image_offset) {
    char dummy;
    read(&dummy, sizeof(char), 1, image);
    ++id_length;
  }

  /* Read the heap root */

  read(&root, sizeof(mlval), 1, image);

  /* Allocate tables of pointers to the old and new positions of the */
  /* generations and static objects. */

  read(&nr_gens, sizeof(size_t), 1, image);
  read(&nr_static, sizeof(size_t), 1, image);

  DIAGNOSTIC(4, "  nr_gens = %u  nr_static = %u", nr_gens, nr_static);

  old_gen_table   = (struct ml_heap **)allocate(sizeof(struct ml_heap *) * nr_gens);
  new_gen_table   = (struct ml_heap **)allocate(sizeof(struct ml_heap *) * nr_gens);
  old_stat_table  = (struct ml_static_object **)allocate(sizeof(struct ml_static_object *) * nr_static);
  new_stat_table  = (struct ml_static_object **)allocate(sizeof(struct ml_static_object *) * nr_static);
  stat_sizes      = (size_t *)allocate(sizeof(size_t) * nr_static);
  old_basemap     = (mlval **)allocate(sizeof(mlval *) * SPACES_IN_ARENA);
  new_basemap     = (mlval **)allocate(sizeof(mlval *) * SPACES_IN_ARENA);

  for(i=0; i<SPACES_IN_ARENA; ++i)
    old_basemap[i] = new_basemap[i] = NULL;

  /* Delete the current heap. */
  gen = creation;
  while(gen != NULL) {
    struct ml_heap *parent = gen->parent;
    unmake_ml_heap(gen);
    gen = parent;
  }

  DIAGNOSTIC(4, "  reading main heap contents", 0, 0);

  for(i=0; i<(int)nr_gens; ++i) {
    size_t size, live;
    struct ml_heap *gen, descriptor;
    word old_sum, new_sum;
    mlval *top;

    DIAGNOSTIC(4, "    generation %i", i, 0);

    read(&old_gen_table[i], sizeof(struct ml_heap *), 1, image);
    read(&descriptor, sizeof(struct ml_heap), 1, image);

    DIAGNOSTIC(4, "      old descriptor was at 0x%X numbered %d", old_gen_table[i], descriptor.number);
    DIAGNOSTIC(4, "        parent 0x%X  child 0x%X", descriptor.parent, descriptor.child);
    DIAGNOSTIC(4, "        start 0x%X  end 0x%X", descriptor.start, descriptor.end);
    DIAGNOSTIC(4, "        entry forward 0x%X  back 0x%X", descriptor.entry.the.forward, descriptor.entry.the.back);
    DIAGNOSTIC(4, "        stat forward 0x%X  back 0x%X", descriptor.statics.forward, descriptor.statics.back);

    if(descriptor.number != i) {
      DIAGNOSTIC(4, "      bad generation number %d", descriptor.number, 0);
      longjmp(problem, EIMAGEFORMAT);
    }

    top = (i == 0) ? descriptor.top : descriptor.image_top;
    size = (descriptor.end - descriptor.start)*sizeof(mlval);
    live = (top - descriptor.start)*sizeof(mlval);

    DIAGNOSTIC(4, "        size 0x%X values  live 0x%X values", size, live);

    new_gen_table[i] = gen = make_ml_heap(descriptor.values, size);

    if(i == 0)
      creation = gen;
    else {
      gen->child = new_gen_table[i-1];
      new_gen_table[i-1]->parent = gen;
    }

    gen->number		= descriptor.number;
    gen->collect	= descriptor.collect;
    gen->values		= descriptor.values;
    gen->top		= gen->start + live/sizeof(mlval);
    gen->image_top	= gen->top; /* A suitable starting value */
    gen->entry		= descriptor.entry;
    gen->last		= descriptor.last;
    gen->nr_entries	= descriptor.nr_entries;
    gen->statics	= descriptor.statics;
    gen->nr_static	= descriptor.nr_static;

    DIAGNOSTIC(4, "      new descriptor is at 0x%X numbered %d", gen, gen->number);
    DIAGNOSTIC(4, "        start 0x%X  end 0x%X", gen->start, gen->end);

    read(gen->start, 1, live, image);

    read(&old_sum, sizeof(word), 1, image);
    new_sum = checksum(gen->start, gen->top);
    DIAGNOSTIC(4, "        checksum old 0x%X  new 0x%X", old_sum, new_sum);

    if(old_sum != new_sum)
      longjmp(problem, EIMAGEFORMAT);

    old_basemap[descriptor.space] = descriptor.start;
    new_basemap[descriptor.space] = gen->start;
  }

  if(nr_static > 0) {
    DIAGNOSTIC(4, "  reading stat objects", 0, 0);

    for(i=0; i<(int)nr_static; ++i) {
      struct ml_static_object *stat, descriptor;
      word old_sum, new_sum;
      word *base, *top;

      read(&old_stat_table[i], sizeof(struct ml_static_object *), 1, image);
      read(&descriptor, sizeof(struct ml_static_object), 1, image);
      read(&stat_sizes[i], sizeof(size_t), 1, image);

      DIAGNOSTIC(4, "    stat object was at 0x%X, %u bytes", old_stat_table[i], stat_sizes[i]);

      new_stat_table[i] = stat = make_static_object(stat_sizes[i]);

      stat -> forward = descriptor.forward;
      stat -> back    = descriptor.back; 

      DIAGNOSTIC(4, "         forward was at 0x%X back at 0x%X", (unsigned)stat -> forward, (unsigned)stat-> back);

      base = stat->object;
      read(base, 1, stat_sizes[i], image);
      top = (mlval *)((byte*)base + stat_sizes[i]);
      read(&old_sum, sizeof(word), 1, image);
      new_sum = checksum(base, top);

      DIAGNOSTIC(4, "      checksum old 0x%X  new 0x%X", old_sum, new_sum);

      if(old_sum != new_sum)
	longjmp(problem, EIMAGEFORMAT);
    };

  }

  DIAGNOSTIC(4, "  fixing root", 0, 0);
  fix(&root);

  DIAGNOSTIC(4, "  fixing heap values", 0, 0);
  for(gen = creation; gen != NULL; gen = gen->parent) {
    struct ml_static_object *stat;

    DIAGNOSTIC(4, "  generation 0x%X %d", gen, gen->number);

    DIAGNOSTIC(4, "    fixing entry forward 0x%X back 0x%X", gen->entry.the.forward, gen->entry.the.back);
    fix_entry(&gen->entry.the.forward);
    fix_entry(&gen->entry.the.back);
    DIAGNOSTIC(4, "    to           forward 0x%X back 0x%X", gen->entry.the.forward, gen->entry.the.back);

    DIAGNOSTIC(4, "    fixing stat  forward 0x%X back 0x%X", gen->statics.forward, gen->statics.back);
    fix_static(&gen->statics.forward);
    fix_static(&gen->statics.back);
    DIAGNOSTIC(4, "    to           forward 0x%X back 0x%X", gen->statics.forward, gen->statics.back);

    gen->statics.gen = gen;
    stat = gen->statics.forward;

    while(stat != &gen->statics) {
      mlval header = stat->object[0];
      mlval secondary = SECONDARY(header);
      mlval length = LENGTH(header);
      size_t size = OBJECT_SIZE(secondary,length);
      mlval *base = &stat->object[0];
      mlval *top = (mlval*) ((byte*)base + size);

      stat->gen = gen;
      DIAGNOSTIC(4, "        static object at 0x%X", stat, 0);
      DIAGNOSTIC(4, "          fixing forward 0x%X back 0x%X", stat->forward, stat->back);
      fix_static(&stat->forward);
      fix_static(&stat->back);
      DIAGNOSTIC(4, "          to     forward 0x%X back 0x%X", stat->forward, stat->back);

      DIAGNOSTIC(4, "          scanning 0x%X to 0x%X", base, top);
      scan(base, top);

      stat = stat->forward;
    }

    DIAGNOSTIC(4, "    scanning 0x%X to 0x%X", gen->start, gen->top);
    scan(gen->start, gen->top);
  }

  /* Fix any pointers dangling off the end of the entry lists */
#if 0
  for (gen = creation; gen!= NULL; gen=gen->parent) {
    union ml_array_header *array = gen->entry.the.forward, *last = &gen->entry;
    while (array != &gen->entry) {
      struct ml_heap *array_gen = GENERATION(array);
      if ((mlval *)array < array_gen->start || (mlval *)array >= array_gen->top) {
	/* Gone off the end, so point last back at gen->entry */
	DIAGNOSTIC(0, "Fixing off end pointer in entry list for generation %d", gen->number, 0);
	last->the.forward = &gen->entry;
	gen->entry.the.back = last;
	break; /* Finished while loop here */
      } else {
	last = array;
	array = array->the.forward;
      }
    }
  }
#else
  for (gen = creation; gen!= NULL; gen=gen->parent) {
    union ml_array_header *array;
    if (gen->nr_entries != 0) {
      fix_entry(&gen->last.the.back); /* This now points to the right place */
      /* Now fix the thing pointed to back into the entry list */
      array = gen->last.the.back;
      array->the.forward = &gen->entry;
      gen->entry.the.back = array;
    }
  }
#endif

  /* Copy the creation space pointers to the ML registers so that ML can use */
  /* them. */
  GC_HEAP_LIMIT = creation->end;
  GC_HEAP_REAL_LIMIT = creation->end;
  GC_HEAP_START = creation->top;
  GC_MODIFIED_LIST = NULL;

  return(root);
}

mlval image_load(mlval argument)
{
  char *filename = CSTRING(argument);
  FILE *volatile image;
  struct stream stream;
  mlval root;
  int code;

  /* Catch errors generated by a longjmp to problem and clean up before */
  /* exiting with the error code specified. */
  
  if((code = setjmp(problem)) != 0) {
    (void)fclose(image);
    if(old_gen_table   != NULL) free(old_gen_table);
    if(new_gen_table   != NULL) free(new_gen_table);
    if(old_stat_table  != NULL) free(old_stat_table);
    if(new_stat_table  != NULL) free(new_stat_table);
    if(old_basemap     != NULL) free(old_basemap);
    if(new_basemap     != NULL) free(new_basemap);
    if(stat_sizes      != NULL) free(stat_sizes);
    errno = code;
    return(MLERROR);
  }

  DIAGNOSTIC(2, "image_load(\"%s\"):", filename, 0);

  image = fopen(filename, "rb");
  if(image == NULL) {
    DIAGNOSTIC(4, "  couldn't open image file", 0, 0);
    errno = EIMAGEOPEN;
    return(MLERROR);
  }

  stream.type = FILE_STREAM;
  stream.the.file = image;
  root = image_load_common(&stream);
  
  (void)fclose(image);

  return(root);
}

mlval image_load_with_open_file(FILE *image, const char *filename)
{
  struct stream stream;
  mlval root;
  int code;

  /* Catch errors generated by a longjmp to problem and clean up before */
  /* exiting with the error code specified. */
  
  if((code = setjmp(problem)) != 0) {
    if(old_gen_table   != NULL) free(old_gen_table);
    if(new_gen_table   != NULL) free(new_gen_table);
    if(old_stat_table  != NULL) free(old_stat_table);
    if(new_stat_table  != NULL) free(new_stat_table);
    if(old_basemap     != NULL) free(old_basemap);
    if(new_basemap     != NULL) free(new_basemap);
    if(stat_sizes      != NULL) free(stat_sizes);
    errno = code;
    return(MLERROR);
  }

  DIAGNOSTIC(2, "image_load(\"%s\"):", filename, 0);

  stream.type = FILE_STREAM;
  stream.the.file = image;
  root = image_load_common(&stream);
  
  return(root);
}

mlval memory_image_load(void *ptr, size_t extent)
{
  struct stream stream;
  mlval root;
  int code;

  /* Catch errors generated by a longjmp to problem and clean up before */
  /* exiting with the error code specified. */
  
  if((code = setjmp(problem)) != 0) {
    if(old_gen_table   != NULL) free(old_gen_table);
    if(new_gen_table   != NULL) free(new_gen_table);
    if(old_stat_table  != NULL) free(old_stat_table);
    if(new_stat_table  != NULL) free(new_stat_table);
    if(old_basemap     != NULL) free(old_basemap);
    if(new_basemap     != NULL) free(new_basemap);
    if(stat_sizes      != NULL) free(stat_sizes);
    errno = code;
    return(MLERROR);
  }

  stream.type = STORE_STREAM;
  stream.the.store.ptr = ptr;
  stream.the.store.extent = extent;
  stream.the.store.index = 0;
  root = image_load_common(&stream);

  return(root);
}


/*  ==== READ THE CONTENTS TABLE FOR AN IMAGE ====
 *
 *  Returns an ml list of strings representing the filenames that made up
 *  this image.
 */

mlval image_table(mlval argument)
{
  char *filename = CSTRING(argument);
  FILE *volatile image;
  unsigned int id_offset, id_length, table_offset, table_len, image_offset;
  char *table, *scan;
  mlval result;
  char file_id[MAX_ID_LENGTH];
  int code;
  struct stream stream;

  image = fopen(filename, "rb");
  if(image == NULL) {
    DIAGNOSTIC(4, "  couldn't open image file", 0, 0);
    errno = EIMAGEOPEN;
    return(MLERROR);
  }

  if((code = setjmp(problem)) != 0) {
    (void)fclose(image);
    errno = code;
    return(MLERROR);
  }

  stream.type = FILE_STREAM;
  stream.the.file = image;

  /* Does the image have the correct id? */

  read(&id_offset, sizeof(unsigned int), 1, &stream);
  read(&table_offset, sizeof(unsigned int), 1, &stream);
  read(&image_offset, sizeof(unsigned int), 1, &stream);
  DIAGNOSTIC(3, "  id_offset = %u  table_offset = %u", id_offset, table_offset);
  DIAGNOSTIC(3, "  image_offset = %u", image_offset, 0);

  if(id_offset!=IMAGE_HEADER_SIZE || id_offset>=table_offset || table_offset>image_offset)
    longjmp(problem, EIMAGEVERSION);

  id_length = strlen(id);
  read(file_id, sizeof(char), id_length, &stream);
  DIAGNOSTIC(3, "id read was `%.24s'", id, 0);
  if(strncmp(id, file_id, id_length) != 0)
    longjmp(problem, EIMAGEVERSION);
  id_length += id_offset;

  while (id_length < table_offset) {
    char dummy;
    read(&dummy, sizeof(char), 1, &stream);
    ++id_length;
  }

  table_len = image_offset - table_offset;

  DIAGNOSTIC(3, "  Read up to the table. table_len = %u", table_len, 0);

  if(table_len == 0) {
    fclose(image);
    return(MLNIL);
  }

  table = malloc(table_len);
  read(table, sizeof(char), table_len, &stream);
  fclose(image);

  DIAGNOSTIC(3, "  table `%s'", table, 0);

  if(table[table_len-1] != '\0') {
    free(table);
    longjmp(problem, EIMAGEFORMAT);
  }

  result = MLNIL;
  declare_root(&result, 0);
  for(scan=strtok(table, " "); scan!=NULL; scan=strtok(NULL, " ")) {
    mlval s = ml_string(scan);
    result = mlw_cons(s, result);
  }
  retract_root(&result);
  free(table);

  return(result);
}
@


1.23.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a15 4
 * Revision 1.23  1998/08/21  16:33:35  jont
 * [Bug #20133]
 * Modify to use GC_HEAP_REAL_LIMIT
 *
@


1.22
log
@[Bug #70032]
gen->values now measured in bytes
@
text
@d16 4
d1020 1
d1211 1
a1211 1
    result = cons(s, result);
@


1.21
log
@[Bug #70034]
Rationalising names in mem.h
@
text
@d16 4
d283 1
a283 1
    DIAGNOSTIC(4, "FILE_STREAM", 0, 0);
d830 1
a830 1
    unmake_gen(gen);
d859 2
a860 2
    size = descriptor.end - descriptor.start;
    live = top - descriptor.start;
d864 1
a864 1
    new_gen_table[i] = gen = make_gen(descriptor.values, size);
d876 1
a876 1
    gen->top		= gen->start + live;
d887 1
a887 1
    read(gen->start, sizeof(mlval), live, image);
@


1.20
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d16 5
d341 1
a341 1
  struct gen *gen;
d420 2
a421 2
    write(&gen, sizeof(struct gen *), 1, image);
    write(gen, sizeof(struct gen), 1, image);
d437 1
a437 1
      struct static_object *stat = gen->statics.forward;
d452 2
a453 2
	write(&stat, sizeof(struct static_object *), 1, image);
	write(stat, sizeof(struct static_object), 1, image);
d589 2
a590 2
static struct gen **old_gen_table, **new_gen_table;
static struct static_object **old_stat_table, **new_stat_table;
d680 1
a680 1
static void fix_static(struct static_object **what)
d682 1
a682 1
  struct static_object *stat = *what;
d760 1
a760 1
  struct gen *gen;
d811 4
a814 4
  old_gen_table   = (struct gen **)allocate(sizeof(struct gen *) * nr_gens);
  new_gen_table   = (struct gen **)allocate(sizeof(struct gen *) * nr_gens);
  old_stat_table  = (struct static_object **)allocate(sizeof(struct static_object *) * nr_static);
  new_stat_table  = (struct static_object **)allocate(sizeof(struct static_object *) * nr_static);
d825 1
a825 1
    struct gen *parent = gen->parent;
d834 1
a834 1
    struct gen *gen, descriptor;
d840 2
a841 2
    read(&old_gen_table[i], sizeof(struct gen *), 1, image);
    read(&descriptor, sizeof(struct gen), 1, image);
d900 1
a900 1
      struct static_object *stat, descriptor;
d904 2
a905 2
      read(&old_stat_table[i], sizeof(struct static_object *), 1, image);
      read(&descriptor, sizeof(struct static_object), 1, image);
d936 1
a936 1
    struct static_object *stat;
d983 1
a983 1
      struct gen *array_gen = GENERATION(array);
@


1.19
log
@Fix space lookup for pointers with top bit set.
@
text
@d16 3
a353 4
  /* Ensure that the heap is consistent with the ML registers, entry lists */
  /* are clear, etc. */
  gc(0, MLUNIT);

d409 2
a410 1
    size_t live = gen->top - gen->start;
d413 1
a413 1
    DIAGNOSTIC(4, "      start 0x%X  top 0x%X", gen->start, gen->top);
d417 1
a417 1
    sum = checksum(gen->start, gen->top);
d633 8
d831 1
d849 1
d851 1
a851 1
    live = descriptor.top - descriptor.start;
d868 1
d870 1
d973 31
d1194 1
a1194 1
  declare_root(&result);
@


1.19.9.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a15 3
 * Revision 1.19  1996/10/29  17:40:48  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.19.8.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a15 3
 * Revision 1.19  1996/10/29  17:40:48  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.19.7.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a15 3
 * Revision 1.19  1996/10/29  17:40:48  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.19.6.1
log
@branched from 1.19
@
text
@a15 3
 * Revision 1.19  1996/10/29  17:40:48  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.19.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a15 3
 * Revision 1.19.6.1  1997/05/12  10:40:35  hope
 * branched from 1.19
 *
@


1.19.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a15 3
 * Revision 1.19.6.1  1997/05/12  10:40:35  hope
 * branched from 1.19
 *
@


1.19.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a15 3
 * Revision 1.19.6.1  1997/05/12  10:40:35  hope
 * branched from 1.19
 *
@


1.19.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a15 3
 * Revision 1.19.6.1.1.1  1997/07/28  18:26:16  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.19.5.1
log
@branched from 1.19
@
text
@a15 3
 * Revision 1.19  1996/10/29  17:40:48  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.19.4.1
log
@branched from 1.19
@
text
@a15 3
 * Revision 1.19  1996/10/29  17:40:48  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.19.4.1.1.1
log
@branched from 1.19.4.1
@
text
@a15 3
 * Revision 1.19.4.1  1996/12/17  17:53:37  hope
 * branched from 1.19
 *
@


1.19.3.1
log
@branched from 1.19
@
text
@a15 3
 * Revision 1.19  1996/10/29  17:40:48  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.19.2.1
log
@branched from 1.19
@
text
@a15 3
 * Revision 1.19  1996/10/29  17:40:48  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.19.1.1
log
@branched from 1.19
@
text
@a15 3
 * Revision 1.19  1996/10/29  17:40:48  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.19.1.1.1.1
log
@branched from 1.19.1.1
@
text
@a15 3
 * Revision 1.19.1.1  1996/11/14  12:57:14  hope
 * branched from 1.19
 *
@


1.18
log
@[Bug #1529]
Add a break at the end of the STORE_STREAM case of read
@
text
@d16 4
d608 1
a608 1
  if(space >= NR_SPACES)
d803 2
a804 2
  old_basemap     = (mlval **)allocate(sizeof(mlval *) * NR_SPACES);
  new_basemap     = (mlval **)allocate(sizeof(mlval *) * NR_SPACES);
d806 1
a806 1
  for(i=0; i<NR_SPACES; ++i)
@


1.18.3.1
log
@branched from 1.18
@
text
@a15 4
 * Revision 1.18  1996/08/05  14:02:54  jont
 * [Bug #1529]
 * Add a break at the end of the STORE_STREAM case of read
 *
@


1.18.2.1
log
@branched from 1.18
@
text
@a15 4
 * Revision 1.18  1996/08/05  14:02:54  jont
 * [Bug #1529]
 * Add a break at the end of the STORE_STREAM case of read
 *
@


1.18.1.1
log
@branched from 1.18
@
text
@a15 4
 * Revision 1.18  1996/08/05  14:02:54  jont
 * [Bug #1529]
 * Add a break at the end of the STORE_STREAM case of read
 *
@


1.17
log
@Make fix_entry spot static arrays and weakarrays.
Also correct use of static sizes -- they are in bytes, not words.
@
text
@d16 4
a246 1
      break;
d248 1
a254 1
      break;
d256 1
d264 1
d267 1
d277 1
d287 1
d290 1
d757 1
d759 1
d761 1
@


1.16
log
@Rearrange stream-independent load and store.
@
text
@d16 3
d420 1
d431 2
a432 1
	DIAGNOSTIC(4, "    stat object 0x%X, %u bytes", stat, size);
d494 1
d610 3
a612 3
    long offset = object - old_stat_table[i]->object;
    if (offset >= 0 && offset < (long)stat_sizes[i]) {
      *what = MLPTR(new_stat_table[i]->object + offset, primary);
d627 1
a627 1
  /* Is is a pointer to an array on the heap? */
d633 2
a634 2
  /* If it isn't on the heap then it must be a pointer to an entry list */
  /* header in one of the generation descriptors. */
d642 8
d877 1
a877 1
      new_stat_table[i] = stat = make_static_object(stat_sizes[i]);;
@


1.15
log
@ISPTR becomes MLVALISPTR
@
text
@d16 3
d188 18
a205 8
typedef union u {
  FILE *file;
  struct {
    void *ptr;
    size_t extent;
    size_t index;
  } store;
} stream;
d217 1
a217 1
static void write(const void *whence, size_t size, size_t number, FILE *stream)
d219 32
a250 1
  if(fwrite(whence, size, number, stream) != number)
d252 1
d255 1
a255 1
static void read(void *whither, size_t size, size_t number, FILE *stream)
d257 23
a279 1
  if(fread(whither, size, number, stream) != number)
d281 1
a293 60

static void store_read(void *whither, size_t size, size_t number, stream *str)
{
  size_t extent = str->store.extent;
  size_t index = str->store.index;
  size_t bytes = size*number;
  void *ptr = str->store.ptr;
  if ((double)size * (double)number > (double)(0xffffffff) || /* Multiply overflow */
      index > index + bytes || /* Addition overflow */
      index + bytes > extent /* Run off the end */
      ) {
    longjmp(problem, EIMAGEREAD);
  }
  memcpy(whither, ((char *)ptr)+index, bytes);
  str->store.index += bytes;
}

static void store_write(const void *whither, size_t size, size_t number, stream *str)
{
  size_t extent = str->store.extent;
  size_t index = str->store.index;
  size_t bytes = size*number;
  void *ptr = str->store.ptr;
  if ((double)size * (double)number > (double)(0xffffffff) || /* Multiply overflow */
      index > index + bytes || /* Addition overflow */
      index + bytes > extent /* Run off the end */
      ) {
    longjmp(problem, EIMAGEWRITE);
  }
  memcpy(((char *)ptr)+index, whither, bytes);
  DIAGNOSTIC(4, "store_write writing %d bytes at offset %d", bytes, str->store.index);
  str->store.index += bytes;
}

static void write_size(const void *whither, size_t size, size_t number, stream *str)
{
  size_t extent = str->store.extent;
  size_t index = str->store.index;
  size_t bytes = size*number;
  if ((double)size * (double)number > (double)(0xffffffff) || /* Multiply overflow */
      index > index + bytes || /* Addition overflow */
      index + bytes > extent /* Run off the end */
      ) {
    longjmp(problem, EIMAGEWRITE);
  }
  /* We leave out the memory copy, as we're just computing the size needed */
  DIAGNOSTIC(4, "write_size writing %d bytes at offset %d", bytes, str->store.index);
  str->store.index += bytes;
}

static void file_read(void *whither, size_t size, size_t number, stream *str)
{
  read(whither, size, number, str->file);
}

static void file_write(const void *whither, size_t size, size_t number, stream *str)
{
  write(whither, size, number, str->file);
}

d315 1
a315 2
static void image_save_common
(stream *image, void (*write)(const void *, size_t, size_t, stream *), mlval root)
d328 1
a328 2
  for(table=DEREF(modules); table!=MLNIL; table=MLTAIL(table))
  {
d341 3
a343 3
  (*write)(&id_offset, sizeof(unsigned int), 1, image);
  (*write)(&table_offset, sizeof(unsigned int), 1, image);
  (*write)(&image_offset, sizeof(unsigned int), 1, image);
d346 2
a347 3
  (*write)(id, sizeof(char), i, image);
  for(; i < id_len; i++)
  {
d349 1
a349 1
    (*write)(&c, sizeof(char), 1, image);
d352 1
a352 2
  for(i=0, table = DEREF(modules); table != MLNIL; table = MLTAIL(table))
  {
d356 1
a356 1
    (*write)(CSTRING(name), sizeof(char), len, image);
d358 1
a358 2
    if (MLTAIL(table) != MLNIL)
    {
d360 1
a360 1
      (*write)(&c, sizeof(char), 1, image);
d366 1
a366 1
  for(; i < table_len; i++) (*write)("\0", sizeof(char), 1, image);
d369 1
a369 1
  (*write)(&root, sizeof(mlval), 1, image);
d383 2
a384 2
  (*write)(&nr_gens, sizeof(size_t), 1, image);
  (*write)(&nr_static, sizeof(size_t), 1, image);
d392 1
a392 2
  for(gen = creation; gen != NULL; gen=gen->parent)
  {
d399 2
a400 2
    (*write)(&gen, sizeof(struct gen *), 1, image);
    (*write)(gen, sizeof(struct gen), 1, image);
d405 2
a406 2
    (*write)(gen->start, sizeof(mlval), live, image);
    (*write)(&sum, sizeof(word), 1, image);
d410 1
a410 2
  if(nr_static > 0)
  {
d415 1
a415 2
    for(gen = creation; gen != NULL; gen = gen->parent)
    {
d418 1
a418 2
      while(stat != &gen->statics)
      {
d429 5
a433 5
	(*write)(&stat, sizeof(struct static_object *), 1, image);
	(*write)(stat, sizeof(struct static_object), 1, image);
	(*write)(&size, sizeof(size_t), 1, image);
	(*write)(base, 1, size, image);
	(*write)(&sum, sizeof(word), 1, image);
d447 1
a447 1
  stream str;
d449 1
a449 2
  if(code != 0)
  {
d469 1
a469 2
  if(image == NULL)
  {
d475 3
a477 2
  str.file = image;
  (void)image_save_common(&str, file_write, root);
d487 1
a487 1
  stream str;
d489 1
a489 2
  if(code != 0)
  {
d496 3
a498 2
  str.file = image;
  (void)image_save_common(&str, file_write, root);
d506 1
a506 1
  stream str;
d508 1
a508 2
  if(code != 0)
  {
d514 5
a518 4
  str.store.ptr = ptr;
  str.store.extent = limit;
  str.store.index = 0;
  (void)image_save_common(&str, store_write, root);
d520 1
a520 1
  *extent = str.store.index; /* Remember how much used */
d528 1
a528 1
  stream str;
d530 1
a530 2
  if(code != 0)
  {
d536 3
a538 4
  str.store.ptr = NULL;
  str.store.extent = (size_t)0xffffffff;
  str.store.index = 0;
  (void)image_save_common(&str, write_size, root);
d540 1
a540 1
  *extent = str.store.index; /* Remember how much used */
d597 1
a597 2
  if(base != NULL)
  {
d622 1
a622 2
  if(base != NULL)
  {
d631 1
a631 2
    if(entry == &old_gen_table[i]->entry)
    {
d648 1
a648 2
    if(stat == old_stat_table[i])
    {
d657 1
a657 2
    if(stat == &old_gen_table[i]->statics)
    {
d668 1
a668 2
  while(start < end)
  {
d671 1
a671 2
    switch(PRIMARY(value))
    {
d680 1
a680 2
      switch(SECONDARY(value))
      {
d697 1
a697 2
	  if(array->the.back != NULL)
	  {
d718 1
a718 2
static mlval image_load_common
(stream *image, void (*read)(void *, size_t, size_t, stream *))
d734 3
a736 3
  (*read)(&id_offset, sizeof(unsigned int), 1, image);
  (*read)(&table_offset, sizeof(unsigned int), 1, image);
  (*read)(&image_offset, sizeof(unsigned int), 1, image);
d743 1
a743 1
  (*read)(file_id, sizeof(char), id_length, image);
d750 1
a750 2
  while(id_length < image_offset)
  {
d752 1
a752 1
    (*read)(&dummy, sizeof(char), 1, image);
d758 1
a758 1
  (*read)(&root, sizeof(mlval), 1, image);
d763 2
a764 2
  (*read)(&nr_gens, sizeof(size_t), 1, image);
  (*read)(&nr_static, sizeof(size_t), 1, image);
d781 1
a781 2
  while(gen != NULL)
  {
d789 1
a789 2
  for(i=0; i<(int)nr_gens; ++i)
  {
d796 2
a797 2
    (*read)(&old_gen_table[i], sizeof(struct gen *), 1, image);
    (*read)(&descriptor, sizeof(struct gen), 1, image);
d805 1
a805 2
    if(descriptor.number != i)
    {
d819 1
a819 2
    else
    {
d836 1
a836 1
    (*read)(gen->start, sizeof(mlval), live, image);
d838 1
a838 1
    (*read)(&old_sum, sizeof(word), 1, image);
d849 1
a849 2
  if(nr_static > 0)
  {
d852 1
a852 2
    for(i=0; i<(int)nr_static; ++i)
    {
d857 3
a859 3
      (*read)(&old_stat_table[i], sizeof(struct static_object *), 1, image);
      (*read)(&descriptor, sizeof(struct static_object), 1, image);
      (*read)(&stat_sizes[i], sizeof(size_t), 1, image);
d871 1
a871 1
      (*read)(base, 1, stat_sizes[i], image);
d873 1
a873 1
      (*read)(&old_sum, sizeof(word), 1, image);
d888 1
a888 2
  for(gen = creation; gen != NULL; gen = gen->parent)
  {
d906 1
a906 2
    while(stat != &gen->statics)
    {
d944 1
a944 1
  stream str;
d951 1
a951 2
  if((code = setjmp(problem)) != 0)
  {
d967 1
a967 2
  if(image == NULL)
  {
d973 3
a975 2
  str.file = image;
  root = image_load_common(&str, file_read);
d984 1
a984 1
  stream str;
d991 1
a991 2
  if((code = setjmp(problem)) != 0)
  {
d1005 3
a1007 2
  str.file = image;
  root = image_load_common(&str, file_read);
d1014 1
a1014 1
  stream str;
d1021 1
a1021 2
  if((code = setjmp(problem)) != 0)
  {
d1033 5
a1037 4
  str.store.ptr = ptr;
  str.store.extent = extent;
  str.store.index = 0;
  root = image_load_common(&str, store_read);
d1058 1
d1061 1
a1061 2
  if(image == NULL)
  {
d1067 1
a1067 2
  if((code = setjmp(problem)) != 0)
  {
d1073 3
d1078 3
a1080 3
  read(&id_offset, sizeof(unsigned int), 1, image);
  read(&table_offset, sizeof(unsigned int), 1, image);
  read(&image_offset, sizeof(unsigned int), 1, image);
d1088 1
a1088 1
  read(file_id, sizeof(char), id_length, image);
d1094 1
a1094 2
  while (id_length < table_offset)
  {
d1096 1
a1096 1
    read(&dummy, sizeof(char), 1, image);
d1104 1
a1104 2
  if(table_len == 0)
  {
d1110 1
a1110 1
  read(table, sizeof(char), table_len, image);
d1115 1
a1115 2
  if(table[table_len-1] != '\0')
  {
d1122 1
a1122 2
  for(scan=strtok(table, " "); scan!=NULL; scan=strtok(NULL, " "))
  {
@


1.14
log
@Changing ERROR to MLERROR
@
text
@d16 3
d588 1
a588 1
  if(!ISPTR(value))
@


1.13
log
@Add some type casts to preent compiler warnings under VC++
@
text
@d16 3
d462 1
a462 1
    return(ERROR);
d472 1
a472 1
    return(ERROR);
d491 1
a491 1
    return(ERROR);
d511 1
a511 1
    return(ERROR);
d533 1
a533 1
    return(ERROR);
d982 1
a982 1
    return(ERROR);
d992 1
a992 1
    return(ERROR);
d1022 1
a1022 1
    return(ERROR);
d1052 1
a1052 1
    return(ERROR);
d1085 1
a1085 1
    return(ERROR);
d1092 1
a1092 1
    return(ERROR);
@


1.12
log
@Runtime error message buffer problem.
@
text
@d16 3
d604 1
a604 1
    if (offset >= 0 && offset < stat_sizes[i]) {
d799 1
a799 1
  for(i=0; i<nr_gens; ++i)
d866 1
a866 1
    for(i=0; i<nr_static; ++i)
@


1.11
log
@Add image_load_with_open_file for loading from NT saved executables
Add image_save_with_open_file for saving NT saved executables
@
text
@d16 4
d444 8
a451 1
    message("image save to '%s' failed, '%s' removed", filename, filename);
@


1.10
log
@Add a version of image_load that can read from store
Add a version of image_save that can save to store
Add a function to determine how much store is required for an image save
@
text
@d16 5
d466 19
d983 30
@


1.9
log
@Delete image files when the write fails
@
text
@d16 3
d164 11
d209 59
d289 2
a290 1
mlval image_save(mlval argument)
a291 3
  char *filename = CSTRING(FIELD(argument, 0));
  mlval root = FIELD(argument, 1);
  FILE *volatile image;
a293 1
  int code = setjmp(problem);
a301 13
  if(code != 0)
  {
    (void)fclose(image);
    message("image save to '%s' failed, '%s' removed", filename, filename);
    if (remove(filename) != 0) {
      message_stderr("remove failed on '%s'", filename);
    }
    errno = code;
    return(ERROR);
  }

  DIAGNOSTIC(2, "image_save(filename = \"%s\", root = 0x%X):", filename, root);

a310 8
  image = fopen(filename, "wb");
  if(image == NULL)
  {
    DIAGNOSTIC(4, "  couldn't open file", 0, 0);
    errno = EIMAGEOPEN;
    return(ERROR);
  }

d317 3
a319 3
  write(&id_offset, sizeof(unsigned int), 1, image);
  write(&table_offset, sizeof(unsigned int), 1, image);
  write(&image_offset, sizeof(unsigned int), 1, image);
d322 1
a322 1
  write(id, sizeof(char), i, image);
d326 1
a326 1
    write(&c, sizeof(char), 1, image);
d334 1
a334 1
    write(CSTRING(name), sizeof(char), len, image);
d339 1
a339 1
      write(&c, sizeof(char), 1, image);
d345 1
a345 1
  for(; i < table_len; i++) write("\0", sizeof(char), 1, image);
d348 1
a348 1
  write(&root, sizeof(mlval), 1, image);
d362 2
a363 2
  write(&nr_gens, sizeof(size_t), 1, image);
  write(&nr_static, sizeof(size_t), 1, image);
d379 2
a380 2
    write(&gen, sizeof(struct gen *), 1, image);
    write(gen, sizeof(struct gen), 1, image);
d385 2
a386 2
    write(gen->start, sizeof(mlval), live, image);
    write(&sum, sizeof(word), 1, image);
d412 5
a416 5
	write(&stat, sizeof(struct static_object *), 1, image);
	write(stat, sizeof(struct static_object), 1, image);
	write(&size, sizeof(size_t), 1, image);
	write(base, 1, size, image);
	write(&sum, sizeof(word), 1, image);
d421 34
a454 1
  
d461 44
d687 2
a688 1
mlval image_load(mlval argument)
a689 2
  char *filename = CSTRING(argument);
  FILE *volatile image;
d694 1
a694 1
  int code, i;
a701 27
  /* Catch errors generated by a longjmp to problem and clean up before */
  /* exiting with the error code specified. */
  
  if((code = setjmp(problem)) != 0)
  {
    (void)fclose(image);
    if(old_gen_table   != NULL) free(old_gen_table);
    if(new_gen_table   != NULL) free(new_gen_table);
    if(old_stat_table  != NULL) free(old_stat_table);
    if(new_stat_table  != NULL) free(new_stat_table);
    if(old_basemap     != NULL) free(old_basemap);
    if(new_basemap     != NULL) free(new_basemap);
    if(stat_sizes      != NULL) free(stat_sizes);
    errno = code;
    return(ERROR);
  }

  DIAGNOSTIC(2, "image_load(\"%s\"):", filename, 0);

  image = fopen(filename, "rb");
  if(image == NULL)
  {
    DIAGNOSTIC(4, "  couldn't open image file", 0, 0);
    errno = EIMAGEOPEN;
    return(ERROR);
  }

d704 3
a706 3
  read(&id_offset, sizeof(unsigned int), 1, image);
  read(&table_offset, sizeof(unsigned int), 1, image);
  read(&image_offset, sizeof(unsigned int), 1, image);
d713 1
a713 1
  read(file_id, sizeof(char), id_length, image);
d723 1
a723 1
    read(&dummy, sizeof(char), 1, image);
a725 2
  DIAGNOSTIC(4, "  after table file pointer = %ld\n", ftell(image), 0);

d729 1
a729 1
  read(&root, sizeof(mlval), 1, image);
d734 2
a735 2
  read(&nr_gens, sizeof(size_t), 1, image);
  read(&nr_static, sizeof(size_t), 1, image);
d769 2
a770 2
    read(&old_gen_table[i], sizeof(struct gen *), 1, image);
    read(&descriptor, sizeof(struct gen), 1, image);
d811 1
a811 1
    read(gen->start, sizeof(mlval), live, image);
d813 1
a813 1
    read(&old_sum, sizeof(word), 1, image);
d834 3
a836 3
      read(&old_stat_table[i], sizeof(struct static_object *), 1, image);
      read(&descriptor, sizeof(struct static_object), 1, image);
      read(&stat_sizes[i], sizeof(size_t), 1, image);
d848 1
a848 1
      read(base, 1, stat_sizes[i], image);
d850 1
a850 1
      read(&old_sum, sizeof(word), 1, image);
a860 15
  (void)fclose(image);

#ifdef DIAGNOSTICS
  if(diagnostic_level >= 2)
  {
    fprintf(stderr, "translation tables\n  generation descriptors\n");
    for(i=0; i<nr_gens; ++i)
      fprintf(stderr, "    %p -> %p\n", old_gen_table[i], new_gen_table[i]);

    fprintf(stderr, "  static objects\n");
    for(i=0; i<nr_static; ++i)
      fprintf(stderr, "    %p -> %p\n", old_stat_table[i], new_stat_table[i]);
  }
#endif
	  
d915 73
@


1.8
log
@Change to definition of OBJECT_SIZE macro.
@
text
@d16 3
d128 1
d235 4
@


1.7
log
@Static objects can now be restored from images.
@
text
@d16 3
d345 4
a348 1
	size_t size = word_align(OBJECT_SIZE(stat->object[0]));
d797 4
a800 1
      size_t size = word_align(OBJECT_SIZE(stat->object[0]));
@


1.6
log
@Static object header changed to have a generation pointer.
@
text
@d16 3
d129 1
d327 1
d348 1
d468 1
a468 1
  /* The old positions of the large objects are all in the old_stat_table. */
d477 1
a477 1
  /* If it isn't actually a large object is must be a pointer to a large */
d487 1
a487 1
  DIAGNOSTIC(4, "bad large object header pointer 0x%X at 0x%X", stat, what);
d622 1
a622 1
  /* generations and large objects. */
d730 7
a736 1
      new_stat_table[i] = stat = make_static_object(stat_sizes[i]);
d742 1
d747 2
a748 1
    }
d760 1
a760 1
    fprintf(stderr, "  large objects\n");
d781 1
a781 1
    DIAGNOSTIC(4, "    fixing stat forward 0x%X back 0x%X", gen->statics.forward, gen->statics.back);
d788 1
d796 1
a796 1
      DIAGNOSTIC(4, "        large object at 0x%X", stat, 0);
d812 1
a812 1
  /* Copy the creation space pointers to the ML registers to that ML can use */
@


1.5
log
@union static_object has become struct static_object.
@
text
@d16 3
d290 2
a291 10
  for(gen = creation; gen != NULL; gen = gen->parent)
  {
    struct static_object *stat = gen->statics.forward;

    while(stat != &gen->statics)
    {
      ++nr_static;
      stat = stat->forward;
    }

d337 4
a340 1
	word sum = checksum(&stat->object[0], &stat->object[stat->values]);
d342 1
a342 1
	DIAGNOSTIC(4, "    stat object 0x%X, %u values", stat, stat->values);
d345 2
a346 1
	write(&stat->object[0], sizeof(mlval), stat->values, image);
d372 4
a375 5
 *  old_basemap		maps old block numbers to the base address of the
 *			space they occupied at save time, or NULL if the
 *			block is outside the ML heap
 *  new_basemap         maps old block numbers to the base address of the
 *			space their object will occupy now
d381 1
d418 4
a421 4
  for(i=0; i<nr_static; ++i)
    if(object == old_stat_table[i]->object)
    {
      *what = MLPTR(new_stat_table[i]->object, primary);
d424 1
d553 1
a553 1
  old_stat_table = new_stat_table = NULL;
d555 1
d565 2
a566 2
    if(old_stat_table != NULL) free(old_stat_table);
    if(new_stat_table != NULL) free(new_stat_table);
d569 1
d625 3
a627 2
  old_stat_table = (struct static_object **)allocate(sizeof(struct static_object *) * nr_static);
  new_stat_table = (struct static_object **)allocate(sizeof(struct static_object *) * nr_static);
d716 1
d720 1
a720 2

      DIAGNOSTIC(4, "    stat object was at 0x%X, %u values", old_stat_table[i], descriptor.values);
d722 1
a722 1
      new_stat_table[i] = stat = make_static_object(descriptor.values);
d724 4
a727 4
      stat->values = descriptor.values;

      read(&stat->object[0], sizeof(mlval), stat->values, image);

d729 1
a729 1
      new_sum = checksum(&stat->object[0], &stat->object[stat->values]);
d772 1
d776 5
d787 2
a788 2
      DIAGNOSTIC(4, "          scanning 0x%X to 0x%X", &stat->object, &stat->object[stat->values]);
      scan(&stat->object[0], &stat->object[stat->values]);
@


1.4
log
@TYPE_LARGE becomes TYPE_STATIC
@
text
@d16 3
d289 1
a289 1
    union static_object *stat = gen->statics.the.forward;
d294 1
a294 1
      stat = stat->the.forward;
d338 1
a338 1
      union static_object *stat = gen->statics.the.forward;
d342 1
a342 1
	word sum = checksum(&stat->the.object[0], &stat->the.object[stat->the.values]);
d344 4
a347 4
	DIAGNOSTIC(4, "    stat object 0x%X, %u values", stat, stat->the.values);
	write(&stat, sizeof(union static_object *), 1, image);
	write(stat, sizeof(union static_object), 1, image);
	write(&stat->the.object[0], sizeof(mlval), stat->the.values, image);
d349 1
a349 1
	stat = stat->the.forward;
d382 1
a382 1
static union static_object **old_stat_table, **new_stat_table;
d420 1
a420 1
    if(object == old_stat_table[i]->the.object)
d422 1
a422 1
      *what = MLPTR(new_stat_table[i]->the.object, primary);
d457 1
a457 1
static void fix_static(union static_object **what)
d459 1
a459 1
  union static_object *stat = *what;
d623 2
a624 2
  old_stat_table = (union static_object **)allocate(sizeof(union static_object *) * nr_static);
  new_stat_table = (union static_object **)allocate(sizeof(union static_object *) * nr_static);
d657 1
a657 1
    DIAGNOSTIC(4, "        stat forward 0x%X  back 0x%X", descriptor.statics.the.forward, descriptor.statics.the.back);
d711 1
a711 1
      union static_object *stat, descriptor;
d714 2
a715 2
      read(&old_stat_table[i], sizeof(union static_object *), 1, image);
      read(&descriptor, sizeof(union static_object), 1, image);
d717 1
a717 1
      DIAGNOSTIC(4, "    stat object was at 0x%X, %u values", old_stat_table[i], descriptor.the.values);
d719 1
a719 1
      new_stat_table[i] = stat = make_static_object(descriptor.the.values);
d721 1
a721 1
      stat->the.values = descriptor.the.values;
d723 1
a723 1
      read(&stat->the.object[0], sizeof(mlval), stat->the.values, image);
d726 1
a726 1
      new_sum = checksum(&stat->the.object[0], &stat->the.object[stat->the.values]);
d755 1
a755 1
    union static_object *stat;
d764 4
a767 4
    DIAGNOSTIC(4, "    fixing stat forward 0x%X back 0x%X", gen->statics.the.forward, gen->statics.the.back);
    fix_static(&gen->statics.the.forward);
    fix_static(&gen->statics.the.back);
    DIAGNOSTIC(4, "    to           forward 0x%X back 0x%X", gen->statics.the.forward, gen->statics.the.back);
d769 1
a769 1
    stat = gen->statics.the.forward;
d773 4
a776 4
      DIAGNOSTIC(4, "          fixing forward 0x%X back 0x%X", stat->the.forward, stat->the.back);
      fix_static(&stat->the.forward);
      fix_static(&stat->the.back);
      DIAGNOSTIC(4, "          to     forward 0x%X back 0x%X", stat->the.forward, stat->the.back);
d778 2
a779 2
      DIAGNOSTIC(4, "          scanning 0x%X to 0x%X", &stat->the.object, &stat->the.object[stat->the.values]);
      scan(&stat->the.object[0], &stat->the.object[stat->the.values]);
d781 1
a781 1
      stat = stat->the.forward;
@


1.3
log
@Add instruction cache flushing.
@
text
@d16 3
d205 1
a205 1
  size_t nr_gens, nr_large;
d280 1
a280 1
  /* Count the number of generations and large objects so that */
d283 1
a283 1
  nr_gens = nr_large = 0;
d286 1
a286 1
    union large_object *large = gen->large.the.forward;
d288 1
a288 1
    while(large != &gen->large)
d290 2
a291 2
      ++nr_large;
      large = large->the.forward;
d298 1
a298 1
  DIAGNOSTIC(4, "    nr_gens = %u  nr_large = %u", nr_gens, nr_large);
d301 1
a301 1
  write(&nr_large, sizeof(size_t), 1, image);
d304 2
a305 2
  /* and the live contents of the spaces.  Large objects are not included at */
  /* this stage. */
d327 1
a327 1
  if(nr_large > 0)
d329 1
a329 1
    /* Write out the large objects, including their addresses. */
d331 1
a331 1
    DIAGNOSTIC(4, "  writing %u large objects", nr_large, 0);
d335 1
a335 1
      union large_object *large = gen->large.the.forward;
d337 1
a337 1
      while(large != &gen->large)
d339 1
a339 1
	word sum = checksum(&large->the.object[0], &large->the.object[large->the.values]);
d341 4
a344 4
	DIAGNOSTIC(4, "    large object 0x%X, %u values", large, large->the.values);
	write(&large, sizeof(union large_object *), 1, image);
	write(large, sizeof(union large_object), 1, image);
	write(&large->the.object[0], sizeof(mlval), large->the.values, image);
d346 1
a346 1
	large = large->the.forward;
d368 2
a369 2
 *  old_large_table	ditto for large object headers
 *  new_large_table
d377 1
a377 1
static size_t nr_gens, nr_large;
d379 1
a379 1
static union large_object **old_large_table, **new_large_table;
d415 3
a417 3
  /* Is it a pointer to a large object? */
  for(i=0; i<nr_large; ++i)
    if(object == old_large_table[i]->the.object)
d419 1
a419 1
      *what = MLPTR(new_large_table[i]->the.object, primary);
d454 1
a454 1
static void fix_large(union large_object **what)
d456 1
a456 1
  union large_object *large = *what;
d459 1
a459 1
  /* The old positions of the large objects are all in the old_large_table. */
d461 2
a462 2
  for(i=0; i<nr_large; ++i)
    if(large == old_large_table[i])
d464 1
a464 1
      *what = new_large_table[i];
d472 1
a472 1
    if(large == &old_gen_table[i]->large)
d474 1
a474 1
      *what = &new_gen_table[i]->large;
d478 1
a478 1
  DIAGNOSTIC(4, "bad large object header pointer 0x%X at 0x%X", large, what);
d550 1
a550 1
  old_large_table = new_large_table = NULL;
d561 2
a562 2
    if(old_large_table != NULL) free(old_large_table);
    if(new_large_table != NULL) free(new_large_table);
d614 1
a614 1
  read(&nr_large, sizeof(size_t), 1, image);
d616 1
a616 1
  DIAGNOSTIC(4, "  nr_gens = %u  nr_large = %u", nr_gens, nr_large);
d620 2
a621 2
  old_large_table = (union large_object **)allocate(sizeof(union large_object *) * nr_large);
  new_large_table = (union large_object **)allocate(sizeof(union large_object *) * nr_large);
d654 1
a654 1
    DIAGNOSTIC(4, "        large forward 0x%X  back 0x%X", descriptor.large.the.forward, descriptor.large.the.back);
d683 2
a684 2
    gen->large		= descriptor.large;
    gen->nr_large	= descriptor.nr_large;
d702 1
a702 1
  if(nr_large > 0)
d704 1
a704 1
    DIAGNOSTIC(4, "  reading large objects", 0, 0);
d706 1
a706 1
    for(i=0; i<nr_large; ++i)
d708 1
a708 1
      union large_object *large, descriptor;
d711 2
a712 2
      read(&old_large_table[i], sizeof(union large_object *), 1, image);
      read(&descriptor, sizeof(union large_object), 1, image);
d714 1
a714 1
      DIAGNOSTIC(4, "    large object was at 0x%X, %u values", old_large_table[i], descriptor.the.values);
d716 1
a716 1
      new_large_table[i] = large = make_large(descriptor.the.values);
d718 1
a718 1
      large->the.values = descriptor.the.values;
d720 1
a720 1
      read(&large->the.object[0], sizeof(mlval), large->the.values, image);
d723 1
a723 1
      new_sum = checksum(&large->the.object[0], &large->the.object[large->the.values]);
d741 2
a742 2
    for(i=0; i<nr_large; ++i)
      fprintf(stderr, "    %p -> %p\n", old_large_table[i], new_large_table[i]);
d752 1
a752 1
    union large_object *large;
d761 13
a773 13
    DIAGNOSTIC(4, "    fixing large forward 0x%X back 0x%X", gen->large.the.forward, gen->large.the.back);
    fix_large(&gen->large.the.forward);
    fix_large(&gen->large.the.back);
    DIAGNOSTIC(4, "    to           forward 0x%X back 0x%X", gen->large.the.forward, gen->large.the.back);

    large = gen->large.the.forward;
    while(large != &gen->large)
    {
      DIAGNOSTIC(4, "        large object at 0x%X", large, 0);
      DIAGNOSTIC(4, "          fixing forward 0x%X back 0x%X", large->the.forward, large->the.back);
      fix_large(&large->the.forward);
      fix_large(&large->the.back);
      DIAGNOSTIC(4, "          to     forward 0x%X back 0x%X", large->the.forward, large->the.back);
d775 2
a776 2
      DIAGNOSTIC(4, "          scanning 0x%X to 0x%X", &large->the.object, &large->the.object[large->the.values]);
      scan(&large->the.object[0], &large->the.object[large->the.values]);
d778 1
a778 1
      large = large->the.forward;
@


1.2
log
@new file
@
text
@d16 3
d109 1
d504 1
@


1.2.1.1
log
@branched from 1.2
@
text
@a15 3
 * Revision 1.2  1994/06/09  14:48:13  nickh
 * new file
 *
@


1.1
log
@new file
@
text
@d15 4
a18 1
 *  $Log: image.c,v $
@
