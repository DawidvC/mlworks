head	1.17;
access;
symbols
	MLW_daveb_inline_1_4_99:1.17.1
	MLWorks_21c0_1999_03_25:1.17
	MLWorks_20c1_1998_08_20:1.17
	MLWorks_20c0_1998_08_04:1.17
	MLWorks_20b2c2_1998_06_19:1.17
	MLWorks_20b2_Windows_1998_06_12:1.17
	MLWorks_20b1c1_1998_05_07:1.17
	MLWorks_20b0_1998_04_07:1.17
	MLWorks_20b0_1998_03_20:1.16
	MLWorks_20m2_1998_02_16:1.15
	MLWorks_MM_adapt:1.15.3
	MLWorks_20m1_1997_10_23:1.15
	MLWorks_11r1:1.13.9.1.1.1.1
	MLWorks_workspace_97:1.15.2
	MLWorks_dt_wizard:1.15.1
	MLWorks_11c0_1997_09_09:1.13.9.1.1.1
	MLWorks_10r3:1.13.9.1.3
	MLWorks_10r2_551:1.13.9.1.2
	MLWorks_11:1.13.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.13.9.1
	MLWorks_20m0_1997_06_20:1.14
	MLWorks_1_0_r2c2_1997_06_14:1.13.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.13.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.13.9
	MLWorks_BugFix_1997_04_24:1.13
	MLWorks_1_0_r2_Win32_1997_04_11:1.13
	MLWorks_1_0_r2_Unix_1997_04_04:1.13
	MM_ML_release_korma_1997_04_01:1.13
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.13.7.1.1
	MLWorks_gui_1996_12_18:1.13.8
	MLWorks_1_0_Win32_1996_12_17:1.13.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.13.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.13.4.1
	JFHrts:1.13.6
	MLWorks_1_0_Irix_1996_11_28:1.13.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.13.5
	MLWorks_1_0_Unix_1996_11_14:1.13.4
	MLWorks_Open_Beta2_1996_10_11:1.13.3
	MLWorks_License_dev:1.13.2
	MLWorks_1_open_beta_1996_09_13:1.13.1
	MLWorks_Open_Beta_1996_08_22:1.13
	MLWorks_Beta_1996_07_02:1.13
	MLWorks_Beta_1996_06_07:1.13
	MLWorks_Beta_1996_06_06:1.13
	MLWorks_Beta_1996_06_05:1.13
	MLWorks_Beta_1996_06_03:1.12
	MLWorks_Beta_1996_05_31:1.12
	MLWorks_Beta_1996_05_30:1.12
	hope_poo:1.3.1
	ML_beta_release_12/08/94:1.3.1.1
	ML_beta_release_03/08/94:1.3;
locks; strict;
comment	@ * @;


1.17
date	98.03.26.16.20.31;	author jont;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	98.02.23.18.01.26;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	97.08.19.15.14.07;	author nickb;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1;
next	1.14;

1.14
date	97.05.22.08.32.23;	author johnh;	state Exp;
branches;
next	1.13;

1.13
date	96.06.04.13.33.31;	author io;	state Exp;
branches
	1.13.1.1
	1.13.2.1
	1.13.3.1
	1.13.4.1
	1.13.5.1
	1.13.6.1
	1.13.7.1
	1.13.8.1
	1.13.9.1;
next	1.12;

1.12
date	96.04.22.14.30.14;	author stephenb;	state Exp;
branches;
next	1.11;

1.11
date	96.04.19.10.00.42;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	96.03.29.10.04.22;	author stephenb;	state Exp;
branches;
next	1.9;

1.9
date	96.02.16.12.42.15;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	96.01.22.11.28.55;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	96.01.16.12.09.19;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.07.20.16.37.53;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	95.03.15.17.37.22;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	94.10.19.15.14.18;	author nickb;	state Exp;
branches;
next	1.3;

1.3
date	94.06.28.14.31.50;	author jont;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	94.06.09.14.49.52;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.11.24.05;	author nickh;	state Exp;
branches;
next	;

1.3.1.1
date	95.07.05.10.31.55;	author hope;	state Exp;
branches;
next	;

1.13.1.1
date	96.09.13.11.21.56;	author hope;	state Exp;
branches;
next	;

1.13.2.1
date	96.10.07.16.12.00;	author hope;	state Exp;
branches;
next	;

1.13.3.1
date	96.10.17.11.30.52;	author hope;	state Exp;
branches;
next	;

1.13.4.1
date	96.11.14.12.56.46;	author hope;	state Exp;
branches
	1.13.4.1.1.1;
next	;

1.13.4.1.1.1
date	96.11.28.15.07.07;	author hope;	state Exp;
branches;
next	;

1.13.5.1
date	96.11.22.18.14.47;	author hope;	state Exp;
branches;
next	;

1.13.6.1
date	96.12.17.10.01.35;	author hope;	state Exp;
branches;
next	;

1.13.7.1
date	96.12.17.17.53.19;	author hope;	state Exp;
branches
	1.13.7.1.1.1;
next	;

1.13.7.1.1.1
date	97.02.24.11.44.15;	author hope;	state Exp;
branches;
next	;

1.13.8.1
date	96.12.18.09.47.52;	author hope;	state Exp;
branches;
next	;

1.13.9.1
date	97.05.12.10.40.16;	author hope;	state Exp;
branches
	1.13.9.1.1.1
	1.13.9.1.2.1
	1.13.9.1.3.1;
next	;

1.13.9.1.1.1
date	97.07.28.18.25.31;	author daveb;	state Exp;
branches
	1.13.9.1.1.1.1.1;
next	;

1.13.9.1.1.1.1.1
date	97.10.07.11.51.22;	author jkbrook;	state Exp;
branches;
next	;

1.13.9.1.2.1
date	97.09.08.17.18.44;	author daveb;	state Exp;
branches;
next	;

1.13.9.1.3.1
date	97.09.09.14.14.53;	author daveb;	state Exp;
branches;
next	;

1.15.1.1
date	97.09.10.19.31.38;	author brucem;	state Exp;
branches;
next	;

1.15.2.1
date	97.09.11.21.01.02;	author daveb;	state Exp;
branches;
next	;

1.15.3.1
date	97.10.31.13.44.03;	author nickb;	state Exp;
branches;
next	;

1.17.1.1
date	99.04.01.18.00.57;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.17
log
@[Bug #30090]
Remove perv_exn_ref_io
@
text
@/*  === PERVASIVE EXCEPTIONS ===
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Revision Log
 *  ------------
 *  $Log: src:exceptions.c,v $
 * Revision 1.16  1998/02/23  18:01:26  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.15  1997/08/19  15:14:07  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
 * Revision 1.14  1997/05/22  08:32:23  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr to include an ml string.
 *
 * Revision 1.13  1996/06/04  13:33:31  io
 * add exn Size
 *
 * Revision 1.12  1996/04/22  14:30:14  stephenb
 * exn_raise_syserr: change the second argument to an int and
 * make it raise (string * NONE) if the int is 0.
 *
 * Revision 1.11  1996/04/19  10:00:42  matthew
 * Removing some exceptions
 *
 * Revision 1.10  1996/03/29  10:04:22  stephenb
 * Add exn_raise_syserror and corresponding exception to support
 * latest verison of OS.* in the basis.
 *
 * Revision 1.9  1996/02/16  12:42:15  nickb
 * Change to declare_global().
 *
 * Revision 1.8  1996/01/22  11:28:55  matthew
 * Adding exceptions initialized value
 *
 * Revision 1.7  1996/01/16  12:09:19  nickb
 * Remove StorageManager exception.
 *
 * Revision 1.6  1995/07/20  16:37:53  jont
 * Add exception Overflow
 *
 * Revision 1.5  1995/03/15  17:37:22  nickb
 * Add threads exception.
 *
 * Revision 1.4  1994/10/19  15:14:18  nickb
 * The method of declaring functions to be non-returning has changed.
 *
 * Revision 1.3  1994/06/28  14:31:50  jont
 * Add nonreturning to function declarations
 *
 * Revision 1.2  1994/06/09  14:49:52  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  11:24:05  nickh
 * new file
 *
 *  Revision 1.9  1994/01/28  17:39:00  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.8  1993/07/23  11:11:36  richard
 *  Added X exception.
 *
 *  Revision 1.7  1993/06/02  13:07:23  richard
 *  Added extra parentheses around conditionals as suggested by GCC 2.
 *  Improved use of const.
 *
 *  Revision 1.6  1993/04/20  12:49:07  richard
 *  Removed obsolete CLMError exception.  Added Unix and Trace exceptions.
 *  Added exn_raise_strings() to deal with errors from streams.c.
 *
 *  Revision 1.5  1993/04/02  14:18:38  jont
 *  New exception for bad iage when reading table of contents
 *
 *  Revision 1.4  1993/03/31  16:28:24  jont
 *  Made the size of the exception string buffer a #define value
 *
 *  Revision 1.3  1993/02/01  16:04:46  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.2  1993/01/05  16:46:45  richard
 *  Added more floating point exceptions.
 *
 *  Revision 1.1  1992/11/02  14:51:16  richard
 *  Initial revision
 *
 */

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>

#include "exceptions.h"
#include "values.h"
#include "global.h"
#include "environment.h"
#include "interface.h"
#include "utils.h"
#include "allocator.h"
#include "ansi.h"
#include "gc.h"

mlval exns_initialised;
mlval exn_default;
mlval perv_exn_ref_size;
mlval perv_exn_ref_div;
mlval perv_exn_ref_overflow;
mlval perv_exn_ref_substring;
mlval perv_exn_ref_profile;
mlval perv_exn_ref_save;
mlval perv_exn_ref_value;
mlval perv_exn_ref_load;
mlval perv_exn_ref_table;
mlval perv_exn_ref_string_to_real;
mlval perv_exn_ref_ln;
mlval perv_exn_ref_abs;
mlval perv_exn_ref_exp;
mlval perv_exn_ref_sqrt;
mlval perv_exn_ref_unbound;
mlval perv_exn_ref_signal;
mlval perv_exn_ref_trace;
mlval perv_exn_ref_threads;
mlval perv_exn_ref_syserr;

static mlval exception_name;


void exn_init()
{
  exns_initialised = ref (MLFALSE);
  declare_global("exception exns_initialised", &exns_initialised,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value ("exception exns_initialised", exns_initialised);

  exn_default = exn(exn_name("default runtime exception"), MLUNIT);
  declare_global("default runtime exception", &exn_default,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);

  perv_exn_ref_size = ref(exn_default);
  declare_global("pervasive exception Size", &perv_exn_ref_size,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Size", perv_exn_ref_size);

  perv_exn_ref_div = ref(exn_default);
  declare_global("pervasive exception Div", &perv_exn_ref_div, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Div", perv_exn_ref_div);

  perv_exn_ref_overflow = ref(exn_default);
  declare_global("pervasive exception Overflow", &perv_exn_ref_overflow, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Overflow", perv_exn_ref_overflow);

  perv_exn_ref_substring = ref(exn_default);
  declare_global("pervasive exception Substring", &perv_exn_ref_substring, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Substring", perv_exn_ref_substring);

  perv_exn_ref_save = ref(exn_default);
  declare_global("pervasive exception Save", &perv_exn_ref_save, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Save", perv_exn_ref_save);

  perv_exn_ref_profile = ref(exn_default);
  declare_global("pervasive exception Profile", &perv_exn_ref_profile, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Profile", perv_exn_ref_profile);

  perv_exn_ref_value = ref(exn_default);
  declare_global("pervasive exception Value", &perv_exn_ref_value, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Value", perv_exn_ref_value);

  perv_exn_ref_unbound = ref(exn_default);
  declare_global("pervasive exception Unbound", &perv_exn_ref_unbound, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Unbound", perv_exn_ref_unbound);

  perv_exn_ref_load = ref(exn_default);
  declare_global("pervasive exception Load", &perv_exn_ref_load, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Load", perv_exn_ref_load);

  perv_exn_ref_table = ref(exn_default);
  declare_global("pervasive exception Table", &perv_exn_ref_table, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Table", perv_exn_ref_table);

  perv_exn_ref_ln = ref(exn_default);
  declare_global("pervasive exception Ln", &perv_exn_ref_ln, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Ln", perv_exn_ref_ln);

  perv_exn_ref_abs = ref(exn_default);
  declare_global("pervasive exception Abs", &perv_exn_ref_abs, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Abs", perv_exn_ref_abs);

  perv_exn_ref_exp = ref(exn_default);
  declare_global("pervasive exception Exp", &perv_exn_ref_exp, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Exp", perv_exn_ref_exp);

  perv_exn_ref_sqrt = ref(exn_default);
  declare_global("pervasive exception Sqrt", &perv_exn_ref_sqrt, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Sqrt", perv_exn_ref_sqrt);

  perv_exn_ref_string_to_real = ref(exn_default);
  env_value("exception StringToReal", perv_exn_ref_string_to_real);
  declare_global("pervasive exception StringToReal",
		 &perv_exn_ref_string_to_real, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);

  perv_exn_ref_signal = ref(exn_default);
  env_value("exception Signal", perv_exn_ref_signal);
  declare_global("pervasive exception Signal", &perv_exn_ref_signal, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);

  perv_exn_ref_trace = ref(exn_default);
  env_value("exception Trace", perv_exn_ref_trace);
  declare_global("pervasive exception Trace", &perv_exn_ref_trace, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);

  perv_exn_ref_threads = ref(exn_default);
  env_value("exception Threads", perv_exn_ref_threads);
  declare_global("pervasive exception Threads", &perv_exn_ref_threads, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);


  perv_exn_ref_syserr = ref(exn_default);
  env_value("exception syserr", perv_exn_ref_syserr);
  declare_global("pervasive exception syserr", &perv_exn_ref_syserr, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);

  exception_name = MLUNIT;
  declare_root(&exception_name, 0);
}


void exn_raise(mlval exn_ref)
{
  c_raise(DEREF(exn_ref));
}

void exn_raise_ml_string(mlval exn_ref, mlval ml_str)
{
  mlval name;

  exception_name = FIELD(DEREF(exn_ref), 0);
  name = exception_name;
  exception_name = MLUNIT;
  c_raise(exn(name, ml_str));
}

void exn_raise_string(mlval exn_ref, const char *string)
{
  exn_raise_ml_string(exn_ref, ml_string(string));
}

void exn_raise_strings(mlval exn_ref, ...)
{
  va_list arg;
  size_t total;
  const char *arg_string;
  char *to, *buffer;
  mlval string, name;

  /* Calculate the total length of the strings in the argument list. */

  va_start(arg, exn_ref);
  total = 0;
  while((arg_string = va_arg(arg, const char *)))
    total += strlen(arg_string);
  va_end(arg);

  /* Concatenate the argument strings into a C buffer.  (NOTE: an ML string */
  /* can't be allocated until they've been copied because they might be on */
  /* the heap. */

  buffer = to = alloc(total, "exn_raise_strings");
  va_start(arg, exn_ref);
  while((arg_string = va_arg(arg, const char *)))
  {
    size_t length = strlen(arg_string);
    memcpy(to, arg_string, length);
    to += length;
  }
  va_end(arg);

  /* Allocate an ML string and copy the buffer into it. */

  exception_name = FIELD(DEREF(exn_ref), 0);
  string = allocate_string(total+1);
  name = exception_name;
  exception_name = MLUNIT;

  memcpy(CSTRING(string), buffer, total);
  CSTRING(string)[total] = '\0';
  free(buffer);

  c_raise(exn(name, string));
}

void exn_raise_int(mlval exn_ref, int i)
{
  c_raise(exn(FIELD(DEREF(exn_ref), 0), MLINT(i)));
}



/* Raise an Os.SysErr exception.  This has the form :-
** 
**   type syserror = int
**   exception SysErr of (string * syserror option)
**
** If the error_code is 0 then (string * NONE) will be raised.
*/
void exn_raise_syserr(mlval error_message, int error_code)
{
  mlval option,  exn_packet;

  declare_root(&error_message, 0);

  if (error_code == 0) {
    option= MLINT(0);
  } else {
    option= allocate_record(2);
    FIELD(option, 0)= MLINT(1);
    FIELD(option, 1)= MLINT(error_code);
  }
  declare_root(&option, 0);

  exn_packet= allocate_record(2);
  FIELD(exn_packet, 0)= error_message;
  FIELD(exn_packet, 1)= option;
  retract_root(&option);
  retract_root(&error_message);

  c_raise(exn(FIELD(DEREF(perv_exn_ref_syserr), 0), exn_packet));
}



void exn_raise_format(mlval exn_ref, const char *format, ...)
{
  va_list arg;
  char buffer[EXN_RAISE_FORMAT_BUFFER_SIZE+1];
  mlval name, s;

  va_start(arg, format);
  vsprintf(buffer, format, arg);
  va_end(arg);

  exception_name = FIELD(DEREF(exn_ref), 0);
  s = ml_string(buffer);
  name = exception_name;
  exception_name = MLUNIT;
  c_raise(exn(name, s));
}
@


1.17.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 4
 * Revision 1.17  1998/03/26  16:20:31  jont
 * [Bug #30090]
 * Remove perv_exn_ref_io
 *
@


1.16
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d8 5
a111 1
mlval perv_exn_ref_io;
a148 5

  perv_exn_ref_io = ref(exn_default);
  declare_global("pervasive exception Io", &perv_exn_ref_io,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Io", perv_exn_ref_io);
@


1.15
log
@[Bug #30250]
Bugs in use of allocate_record and allocate_array: add debug-filling code.
@
text
@d8 4
d244 1
a244 1
  declare_root(&exception_name);
d330 1
a330 1
  declare_root(&error_message);
d339 1
a339 1
  declare_root(&option);
@


1.15.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a7 4
 * Revision 1.15  1997/08/19  15:14:07  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.15.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 4
 * Revision 1.15  1997/08/19  15:14:07  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.15.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 4
 * Revision 1.15  1997/08/19  15:14:07  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.14
log
@[Bug #01702]
Changed definition of exn_raise_syserr to include an ml string.
@
text
@d8 4
d326 2
a327 5
  exn_packet= allocate_record(2);
  FIELD(exn_packet, 0)= error_message;
  FIELD(exn_packet, 1)= MLUNIT;
  error_message= MLUNIT;
  declare_root(&exn_packet);
d335 4
a338 1
  retract_root(&exn_packet);
d340 3
@


1.13
log
@add exn Size
@
text
@d8 3
d245 1
a245 1
void exn_raise_string(mlval exn_ref, const char *string)
d247 1
a247 1
  mlval name, s;
a249 1
  s = ml_string(string);
d252 6
a257 1
  c_raise(exn(name, s));
d318 1
a318 1
void exn_raise_syserr(char const *error_message, int error_code)
a321 1
  exception_name= ml_string(error_message);
d323 1
a323 1
  FIELD(exn_packet, 0)= exception_name;
d325 1
a325 1
  exception_name= MLUNIT;
@


1.13.9.1
log
@branched from 1.13
@
text
@a7 3
 * Revision 1.13  1996/06/04  13:33:31  io
 * add exn Size
 *
@


1.13.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.13.9.1  1997/05/12  10:40:16  hope
 * branched from 1.13
 *
@


1.13.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.13.9.1  1997/05/12  10:40:16  hope
 * branched from 1.13
 *
@


1.13.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.13.9.1  1997/05/12  10:40:16  hope
 * branched from 1.13
 *
@


1.13.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.13.9.1.1.1  1997/07/28  18:25:31  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.13.8.1
log
@branched from 1.13
@
text
@a7 3
 * Revision 1.13  1996/06/04  13:33:31  io
 * add exn Size
 *
@


1.13.7.1
log
@branched from 1.13
@
text
@a7 3
 * Revision 1.13  1996/06/04  13:33:31  io
 * add exn Size
 *
@


1.13.7.1.1.1
log
@branched from 1.13.7.1
@
text
@a7 3
 * Revision 1.13.7.1  1996/12/17  17:53:19  hope
 * branched from 1.13
 *
@


1.13.6.1
log
@branched from 1.13
@
text
@a7 3
 * Revision 1.13  1996/06/04  13:33:31  io
 * add exn Size
 *
@


1.13.5.1
log
@branched from 1.13
@
text
@a7 3
 * Revision 1.13  1996/06/04  13:33:31  io
 * add exn Size
 *
@


1.13.4.1
log
@branched from 1.13
@
text
@a7 3
 * Revision 1.13  1996/06/04  13:33:31  io
 * add exn Size
 *
@


1.13.4.1.1.1
log
@branched from 1.13.4.1
@
text
@a7 3
 * Revision 1.13.4.1  1996/11/14  12:56:46  hope
 * branched from 1.13
 *
@


1.13.3.1
log
@branched from 1.13
@
text
@a7 3
 * Revision 1.13  1996/06/04  13:33:31  io
 * add exn Size
 *
@


1.13.2.1
log
@branched from 1.13
@
text
@a7 3
 * Revision 1.13  1996/06/04  13:33:31  io
 * add exn Size
 *
@


1.13.1.1
log
@branched from 1.13
@
text
@a7 3
 * Revision 1.13  1996/06/04  13:33:31  io
 * add exn Size
 *
@


1.12
log
@exn_raise_syserr: change the second argument to an int and
make it raise (string * NONE) if the int is 0.
@
text
@d8 4
d95 1
d129 5
@


1.11
log
@Removing some exceptions
@
text
@d8 3
d299 1
d301 1
a301 1
void exn_raise_syserr(char const *error_message, mlval error_code)
d303 3
a305 7
  mlval some, exn_packet,  error_name;
  some= allocate_record(2);
  FIELD(some, 0)= MLINT(1);
  FIELD(some, 1)= MLINT(error_code);
  declare_root(&some);
  error_name= ml_string(error_message);
  declare_root(&error_name);
d307 13
a319 4
  FIELD(exn_packet, 0)= error_name;
  FIELD(exn_packet, 1)= some;
  retract_root(&some);
  retract_root(&error_name);
@


1.10
log
@Add exn_raise_syserror and corresponding exception to support
latest verison of OS.* in the basis.
@
text
@d8 4
a88 5
mlval perv_exn_ref_sum;
mlval perv_exn_ref_diff;
mlval perv_exn_ref_prod;
mlval perv_exn_ref_quot;
mlval perv_exn_ref_mod;
a90 1
mlval perv_exn_ref_floor;
a126 25
  perv_exn_ref_sum = ref(exn_default);
  declare_global("pervasive exception Sum", &perv_exn_ref_sum, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Sum", perv_exn_ref_sum);

  perv_exn_ref_diff = ref(exn_default);
  declare_global("pervasive exception Diff", &perv_exn_ref_diff, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Diff", perv_exn_ref_diff);

  perv_exn_ref_prod = ref(exn_default);
  declare_global("pervasive exception Prod", &perv_exn_ref_prod, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Prod", perv_exn_ref_prod);

  perv_exn_ref_quot = ref(exn_default);
  declare_global("pervasive exception Quot", &perv_exn_ref_quot, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Quot", perv_exn_ref_quot);

  perv_exn_ref_mod = ref(exn_default);
  declare_global("pervasive exception Mod", &perv_exn_ref_mod, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Mod", perv_exn_ref_mod);

a135 5

  perv_exn_ref_floor = ref(exn_default);
  declare_global("pervasive exception Floor", &perv_exn_ref_floor, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("exception Floor", perv_exn_ref_floor);
@


1.9
log
@Change to declare_global().
@
text
@d8 3
d108 1
d245 6
d320 27
@


1.8
log
@Adding exceptions initialized value
@
text
@d8 3
d112 2
a113 1
  declare_global("exception exns_initialised", &exns_initialised,NULL);
d117 2
a118 1
  declare_global("default runtime exception", &exn_default, NULL);
d121 2
a122 1
  declare_global("pervasive exception Io", &perv_exn_ref_io, NULL);
d126 2
a127 1
  declare_global("pervasive exception Sum", &perv_exn_ref_sum, NULL);
d131 2
a132 1
  declare_global("pervasive exception Diff", &perv_exn_ref_diff, NULL);
d136 2
a137 1
  declare_global("pervasive exception Prod", &perv_exn_ref_prod, NULL);
d141 2
a142 1
  declare_global("pervasive exception Quot", &perv_exn_ref_quot, NULL);
d146 2
a147 1
  declare_global("pervasive exception Mod", &perv_exn_ref_mod, NULL);
d151 2
a152 1
  declare_global("pervasive exception Div", &perv_exn_ref_div, NULL);
d156 2
a157 1
  declare_global("pervasive exception Overflow", &perv_exn_ref_overflow, NULL);
d161 2
a162 1
  declare_global("pervasive exception Floor", &perv_exn_ref_floor, NULL);
d166 2
a167 1
  declare_global("pervasive exception Substring", &perv_exn_ref_substring, NULL);
d171 2
a172 1
  declare_global("pervasive exception Save", &perv_exn_ref_save, NULL);
d176 2
a177 1
  declare_global("pervasive exception Profile", &perv_exn_ref_profile, NULL);
d181 2
a182 1
  declare_global("pervasive exception Value", &perv_exn_ref_value, NULL);
d186 2
a187 1
  declare_global("pervasive exception Unbound", &perv_exn_ref_unbound, NULL);
d191 2
a192 1
  declare_global("pervasive exception Load", &perv_exn_ref_load, NULL);
d196 2
a197 1
  declare_global("pervasive exception Table", &perv_exn_ref_table, NULL);
d201 2
a202 1
  declare_global("pervasive exception Ln", &perv_exn_ref_ln, NULL);
d206 2
a207 1
  declare_global("pervasive exception Abs", &perv_exn_ref_abs, NULL);
d211 2
a212 1
  declare_global("pervasive exception Exp", &perv_exn_ref_exp, NULL);
d216 2
a217 1
  declare_global("pervasive exception Sqrt", &perv_exn_ref_sqrt, NULL);
d223 2
a224 1
		 &perv_exn_ref_string_to_real, NULL);
d228 2
a229 1
  declare_global("pervasive exception Signal", &perv_exn_ref_signal, NULL);
d233 2
a234 1
  declare_global("pervasive exception Trace", &perv_exn_ref_trace, NULL);
d238 2
a239 1
  declare_global("pervasive exception Threads", &perv_exn_ref_threads, NULL);
@


1.7
log
@Remove StorageManager exception.
@
text
@d8 3
d76 1
d108 4
@


1.6
log
@Add exception Overflow
@
text
@d8 3
a84 1
mlval perv_exn_ref_StorageManager;
a145 4

  perv_exn_ref_StorageManager = ref(exn_default);
  declare_global("pervasive exception StorageManager", &perv_exn_ref_StorageManager, NULL);
  env_value("exception StorageManager", perv_exn_ref_StorageManager);
@


1.5
log
@Add threads exception.
@
text
@d8 3
d78 1
d132 4
@


1.4
log
@The method of declaring functions to be non-returning has changed.
@
text
@d8 3
d91 1
d193 4
@


1.3
log
@Add nonreturning to function declarations
@
text
@d8 3
d195 1
a195 1
nonreturning void exn_raise(mlval exn_ref)
d200 1
a200 1
nonreturning void exn_raise_string(mlval exn_ref, const char *string)
d211 1
a211 1
nonreturning void exn_raise_strings(mlval exn_ref, ...)
d255 1
a255 1
nonreturning void exn_raise_int(mlval exn_ref, int i)
d260 1
a260 1
nonreturning void exn_raise_format(mlval exn_ref, const char *format, ...)
@


1.3.1.1
log
@branched from 1.3
@
text
@a7 3
 * Revision 1.3  1994/06/28  14:31:50  jont
 * Add nonreturning to function declarations
 *
@


1.2
log
@new file
@
text
@d8 3
d192 1
a192 1
void exn_raise(mlval exn_ref)
d197 1
a197 1
void exn_raise_string(mlval exn_ref, const char *string)
d208 1
a208 1
void exn_raise_strings(mlval exn_ref, ...)
d252 1
a252 1
void exn_raise_int(mlval exn_ref, int i)
d257 1
a257 1
void exn_raise_format(mlval exn_ref, const char *format, ...)
@


1.1
log
@new file
@
text
@d7 4
a10 1
 *  $Log: exceptions.c,v $
@
