head	1.44;
access;
symbols
	MLW_daveb_inline_1_4_99:1.44.1
	MLWorks_21c0_1999_03_25:1.44
	MLWorks_20c1_1998_08_20:1.42
	MLWorks_20c0_1998_08_04:1.42
	MLWorks_20b2c2_1998_06_19:1.42
	MLWorks_20b2_Windows_1998_06_12:1.42
	MLWorks_20b1c1_1998_05_07:1.42
	MLWorks_20b0_1998_04_07:1.40
	MLWorks_20b0_1998_03_20:1.40
	MLWorks_20m2_1998_02_16:1.37
	MLWorks_MM_adapt:1.36.1
	MLWorks_20m1_1997_10_23:1.35
	MLWorks_11r1:1.31.1.1.1.1.1
	MLWorks_workspace_97:1.34.2
	MLWorks_dt_wizard:1.34.1
	MLWorks_11c0_1997_09_09:1.31.1.1.1.1
	MLWorks_10r3:1.31.1.1.3
	MLWorks_10r2_551:1.31.1.1.2
	MLWorks_11:1.31.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.31.1.1
	MLWorks_20m0_1997_06_20:1.33
	MLWorks_1_0_r2c2_1997_06_14:1.31.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.31.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.31.1
	MLWorks_BugFix_1997_04_24:1.31
	MLWorks_1_0_r2_Win32_1997_04_11:1.31
	MLWorks_1_0_r2_Unix_1997_04_04:1.31
	MM_ML_release_korma_1997_04_01:1.31
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.30.7.1.1
	MLWorks_gui_1996_12_18:1.30.8
	MLWorks_1_0_Win32_1996_12_17:1.30.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.30.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.30.4.1
	JFHrts:1.30.6
	MLWorks_1_0_Irix_1996_11_28:1.30.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.30.5
	MLWorks_1_0_Unix_1996_11_14:1.30.4
	MLWorks_Open_Beta2_1996_10_11:1.30.3
	MLWorks_License_dev:1.30.2
	MLWorks_1_open_beta_1996_09_13:1.30.1
	MLWorks_Open_Beta_1996_08_22:1.30
	MLWorks_Beta_1996_07_02:1.30
	MLWorks_Beta_1996_06_07:1.29
	MLWorks_Beta_1996_06_06:1.29
	MLWorks_Beta_1996_06_05:1.29
	MLWorks_Beta_1996_06_03:1.29
	MLWorks_Beta_1996_05_31:1.29
	MLWorks_Beta_1996_05_30:1.29
	hope_poo:1.9.1
	ML_beta_release_12/08/94:1.9.1.1
	ML_beta_release_03/08/94:1.9;
locks; strict;
comment	@ * @;


1.44
date	98.09.30.14.53.23;	author jont;	state Exp;
branches
	1.44.1.1;
next	1.43;

1.43
date	98.08.21.16.36.05;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	98.04.23.14.23.11;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	98.04.22.15.06.06;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	98.03.19.11.40.36;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	98.03.19.10.52.11;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	98.02.27.14.37.05;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	97.11.18.12.31.53;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	97.10.21.09.01.34;	author jont;	state Exp;
branches
	1.36.1.1;
next	1.35;

1.35
date	97.10.10.18.25.18;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	97.07.22.11.57.24;	author jont;	state Exp;
branches
	1.34.1.1
	1.34.2.1;
next	1.33;

1.33
date	97.06.03.16.26.34;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	97.06.03.08.57.22;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	97.02.10.14.05.01;	author matthew;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	96.06.26.11.40.44;	author stephenb;	state Exp;
branches
	1.30.1.1
	1.30.2.1
	1.30.3.1
	1.30.4.1
	1.30.5.1
	1.30.6.1
	1.30.7.1
	1.30.8.1;
next	1.29;

1.29
date	96.02.19.13.54.21;	author nickb;	state Exp;
branches;
next	1.28;

1.28
date	96.02.16.14.40.16;	author nickb;	state Exp;
branches;
next	1.27;

1.27
date	96.02.14.14.59.39;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	96.01.11.16.46.45;	author nickb;	state Exp;
branches;
next	1.25;

1.25
date	95.11.09.11.01.58;	author nickb;	state Exp;
branches;
next	1.24;

1.24
date	95.10.25.17.03.54;	author nickb;	state Exp;
branches;
next	1.23;

1.23
date	95.09.19.10.27.36;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	95.07.27.09.37.00;	author nickb;	state Exp;
branches;
next	1.21;

1.21
date	95.05.05.14.21.19;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	95.05.02.15.32.06;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	95.05.02.14.30.48;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	95.04.07.09.27.38;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	95.02.20.15.01.16;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	94.12.09.17.54.21;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	94.12.09.15.42.01;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	94.11.09.16.41.47;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	94.10.07.16.54.02;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	94.10.06.11.51.09;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	94.10.04.10.58.21;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	94.09.07.10.33.13;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	94.07.25.09.49.32;	author nickh;	state Exp;
branches
	1.9.1.1;
next	1.8;

1.8
date	94.07.19.16.55.29;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	94.06.30.12.10.15;	author nickh;	state Exp;
branches;
next	1.6;

1.6
date	94.06.24.15.21.30;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.06.22.15.11.32;	author nickh;	state Exp;
branches;
next	1.4;

1.4
date	94.06.21.15.59.24;	author nickh;	state Exp;
branches;
next	1.3;

1.3
date	94.06.13.11.53.55;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.33.07;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.10.58.21;	author nickh;	state Exp;
branches;
next	;

1.9.1.1
date	95.07.05.10.29.05;	author hope;	state Exp;
branches;
next	;

1.30.1.1
date	96.09.13.11.25.38;	author hope;	state Exp;
branches;
next	;

1.30.2.1
date	96.10.07.16.16.05;	author hope;	state Exp;
branches;
next	;

1.30.3.1
date	96.10.17.11.35.29;	author hope;	state Exp;
branches;
next	;

1.30.4.1
date	96.11.14.13.01.07;	author hope;	state Exp;
branches
	1.30.4.1.1.1;
next	;

1.30.4.1.1.1
date	96.11.28.15.11.11;	author hope;	state Exp;
branches;
next	;

1.30.5.1
date	96.11.22.18.18.59;	author hope;	state Exp;
branches;
next	;

1.30.6.1
date	96.12.17.10.05.41;	author hope;	state Exp;
branches;
next	;

1.30.7.1
date	96.12.17.17.57.16;	author hope;	state Exp;
branches
	1.30.7.1.1.1;
next	;

1.30.7.1.1.1
date	97.02.24.11.48.58;	author hope;	state Exp;
branches;
next	;

1.30.8.1
date	96.12.18.09.51.56;	author hope;	state Exp;
branches;
next	;

1.31.1.1
date	97.05.12.10.45.37;	author hope;	state Exp;
branches
	1.31.1.1.1.1
	1.31.1.1.2.1
	1.31.1.1.3.1;
next	;

1.31.1.1.1.1
date	97.07.28.18.26.57;	author daveb;	state Exp;
branches
	1.31.1.1.1.1.1.1;
next	;

1.31.1.1.1.1.1.1
date	97.10.07.11.52.56;	author jkbrook;	state Exp;
branches;
next	;

1.31.1.1.2.1
date	97.09.08.17.20.05;	author daveb;	state Exp;
branches;
next	;

1.31.1.1.3.1
date	97.09.09.14.16.12;	author daveb;	state Exp;
branches;
next	;

1.34.1.1
date	97.09.10.19.33.45;	author brucem;	state Exp;
branches;
next	;

1.34.2.1
date	97.09.11.21.02.55;	author daveb;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	97.10.29.12.06.18;	author daveb;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	97.10.29.14.14.39;	author daveb;	state Exp;
branches;
next	;

1.36.1.1
date	97.10.31.13.45.47;	author nickb;	state Exp;
branches;
next	;

1.44.1.1
date	99.04.01.18.02.06;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.44
log
@[Bug #70108]
Make sure stat.h is included before syscalls.h to avoid problems with lstat
@
text
@/*  ==== MODULE LOADER ====
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  Needs documenting.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:loader.c,v $
 * Revision 1.43  1998/08/21  16:36:05  jont
 * [Bug #30108]
 * Implement DLL based ML code
 *
 * Revision 1.42  1998/04/23  14:23:11  jont
 * [Bug #70034]
 * Rationalising names in mem.h
 *
 * Revision 1.41  1998/04/22  15:06:06  jont
 * [Bug #70091]
 * Remove require_name from consistency info as it's not needed now
 *
 * Revision 1.40  1998/03/19  11:40:36  jont
 * [Bug #70026]
 * Allow profiling of stub_c functions, recording the time according
 * to the name of the runtime system functions
 *
 * Revision 1.39  1998/03/19  10:52:11  jont
 * [Bug #70018]
 * Add cast to call to live_in_gen
 *
 * Revision 1.38  1998/02/27  14:37:05  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.37  1997/11/18  12:31:53  jont
 * [Bug #30089]
 * Remove include of mltime.h which is no longer needed
 *
 * Revision 1.36  1997/10/21  09:01:34  jont
 * [Bug #30089]
 * Timestamps changed to be pairs of integers representing
 * stamp div 10**6 and stamp mod 10**6
 *
 * Revision 1.35  1997/10/10  18:25:18  daveb
 * [Bug #20090]
 * Changed the module table to store the time stamps from the consistency
 * information, instead of the modification times of the files themselves.
 *
 * Revision 1.34  1997/07/22  11:57:24  jont
 * [Bug #20069]
 * Check validity of stack_params to make_ancill
 *
 * Revision 1.33  1997/06/03  16:26:34  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
 * Revision 1.32  1997/06/03  08:57:22  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
 * Revision 1.31  1997/02/10  14:05:01  matthew
 * Reverse bytes in read_real
 *
 * Revision 1.30  1996/06/26  11:40:44  stephenb
 * Fix #1439 - NT: Stack browswer frame hiding doesn't work properly.
 * Make read_delivered_name work for Win32 i.e. remove the assumption
 * that files use "/" as separators.
 *
 * Revision 1.29  1996/02/19  13:54:21  nickb
 * Delivered images still contain long empty loader_code tables.
 *
 * Revision 1.28  1996/02/16  14:40:16  nickb
 * Change to declare_global().
 *
 * Revision 1.27  1996/02/14  14:59:39  jont
 * Changing ERROR to MLERROR
 *
 * Revision 1.26  1996/01/11  16:46:45  nickb
 * Runtime error message buffer problem.
 *
 * Revision 1.25  1995/11/09  11:01:58  nickb
 * Strange bug in delivery names.
 *
 * Revision 1.24  1995/10/25  17:03:54  nickb
 * Change delivery names to make them recognisable to the debugger.
 *
 * Revision 1.23  1995/09/19  10:27:36  jont
 * Fix problems with C ordering of evaluation of function parameters
 * interaction with gc and C roots
 *
 * Revision 1.22  1995/07/27  09:37:00  nickb
 * Postpone loader_code_add() until the code object is complete.
 *
 * Revision 1.21  1995/05/05  14:21:19  jont
 * Make load_module static, as it's only called internally.
 *
 * Revision 1.20  1995/05/02  15:32:06  jont
 * Remove superfluous error causing line
 *
 * Revision 1.19  1995/05/02  14:30:48  jont
 * Handle unable to access mo files by returning an error which can be
 * translated into an exception
 *
 * Revision 1.18  1995/04/07  09:27:38  matthew
 * Use OBJECT_CODE_VERSION to check version of code
 *
 * Revision 1.17  1995/02/20  15:01:16  matthew
 * Adding ml_observer function
 *
 * Revision 1.16  1994/12/09  17:54:21  jont
 * Change file opening to be rb
 *
 * Revision 1.15  1994/12/09  15:42:01  jont
 * Change time.h to mltime.h
 *
 * Revision 1.14  1994/11/09  16:41:47  nickb
 * Add instruction cache flushing.
 *
 * Revision 1.13  1994/10/07  16:54:02  jont
 * Changed to be more vigilant about spotting non-aligned code vector total size
 *
 * Revision 1.12  1994/10/06  11:51:09  jont
 * Added routine read_raw_word which does not attempt to change endian
 * before returning its result. This is used to determine the endianness
 * of each mo file. Put this one down to the horrors of imperative programming!
 *
 * Revision 1.11  1994/10/04  10:58:21  jont
 * Control change_endian on the code by machine specific value
 *
 * Revision 1.10  1994/09/07  10:33:13  nickb
 * Make incompatible timestamp message a warning (not a diagnostic).
 *
 * Revision 1.9  1994/07/25  09:49:32  nickh
 * Fix load_wordset to handle object version 14.
 *
 * Revision 1.8  1994/07/19  16:55:29  jont
 * Add callee saves to ancillary information
 *
 * Revision 1.7  1994/06/30  12:10:15  nickh
 * Change to code name delivery, and to printing of diagnostic messages.
 *
 * Revision 1.6  1994/06/24  15:21:30  jont
 * Increase version to 13
 *
 * Revision 1.5  1994/06/22  15:11:32  nickh
 * Fix interception treatment of loaded wordsets.
 *
 * Revision 1.4  1994/06/21  15:59:24  nickh
 * New ancillary structure.
 *
 * Revision 1.3  1994/06/13  11:53:55  nickh
 * Bump version number.
 *
 * Revision 1.2  1994/06/09  14:33:07  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:58:21  nickh
 * new file
 *
 *  Revision 1.61  1994/04/08  15:53:55  jont
 *  Add original require file names to consistency info.
 *
 *  Revision 1.60  1994/03/14  16:17:09  jont
 *  Fixed such that when timestamp tests find module missing, the same
 *  error is produced as if the time stamps weren't being done. In
 *  particular, errno is now set in this case.
 *
 *  Revision 1.59  1994/01/28  17:23:00  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.58  1994/01/10  13:43:20  matthew
 *  Added function internal_load_link for use by image builder and by the ml mo loader.
 *
 *  Revision 1.57  1993/12/22  11:37:32  jont
 *  Added delivery option which discards code vector names
 *
 *  Revision 1.56  1993/12/07  12:19:58  daveb
 *  Checked return value of mt_lookup_time.
 *
 *  Revision 1.55  1993/12/01  12:49:54  matthew
 *  Made it understand version 9 too.  There must be a better way of doing this!
 *
 *  Revision 1.54  1993/11/24  10:13:03  jont
 *  Changed to allow detection of inconsistent mo sets
 *
 *  Revision 1.53  1993/08/27  19:22:11  daveb
 *  Bug in read_opt_int (I wrote << instead of <<=).
 *
 *  Revision 1.52  1993/08/26  17:36:58  daveb
 *  load_module sets the module name from the consistency information in the
 *  file.
 *
 *  Revision 1.51  1993/08/12  11:24:32  daveb
 *  mt_lookup takes an extra argument.
 *
 *  Revision 1.50  1993/08/06  17:13:02  richard
 *  Increased the level of a diagnostic.
 *
 *  Revision 1.49  1993/06/18  08:52:33  daveb
 *  New object file format.  Runtime is compatible with old version.
 *
 *  Revision 1.48  1993/05/27  15:10:27  jont
 *  New version cos encapsulator has changed
 *
 *  Revision 1.47  1993/05/18  10:46:28  richard
 *  Changed the layout of code vectors in the encapsulator in order to
 *  reduce the amount of root juggling that would have been necessary
 *  to correct a bug calling the loader code observer.
 *
 *  Revision 1.46  1993/05/10  15:43:37  jont
 *  Fixed problem with superfluous mlupdate(spills, ...) outside scope
 *  of declare/retract. Removed superfluous reallocation of code vector.
 *  Added declare/retract round call to weak_add in loader_code_add
 *
 *  Revision 1.45  1993/04/15  13:37:46  richard
 *  All ancillary slots are now loaded.
 *
 *  Revision 1.44  1993/03/18  11:56:57  jont
 *  New version to account for code changes for leaf and intercept offset
 *
 *  Revision 1.43  1993/03/11  18:17:58  jont
 *  Moved ANCILLARY_SLOT_SIZE into values.h
 *
 *  Revision 1.42  1993/02/12  16:36:07  jont
 *  Changes for code vector reform
 *
 *  Revision 1.41  1993/02/01  14:47:24  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.40  1993/01/15  10:25:53  daveb
 *  Changed runtime_version to object_file_version.
 *
 *  Revision 1.39  1993/01/05  13:48:04  daveb
 *  Added version parameter to load_wordset.  Changed current version to 3,
 *  which has the new representation of lists.
 *
 *  Revision 1.38  1992/08/25  13:27:25  richard
 *  Changed the action when the loader finds a wrongly sized real
 *  number.  It now exits with an error code.
 *
 *  Revision 1.37  1992/08/18  11:19:17  richard
 *  Added missing root declarations.  (Oops)
 *
 *  Revision 1.36  1992/08/13  18:47:57  davidt
 *  Small change to the object file format.
 *
 *  Revision 1.35  1992/08/07  10:42:26  richard
 *  Implemented load_wordset.
 *
 *  Revision 1.34  1992/08/07  08:46:13  richard
 *  The loader keeps track of code vectors (again) but an observer
 *  function can be declared from any profiler.  This gives more
 *  flexibility for use by the memory auditer.
 *
 *  Revision 1.33  1992/08/05  17:22:41  richard
 *  Removed incorrect load_wordset() temporarily.
 *  Code vectors are now tagged differently to strings.
 *
 *  Revision 1.32  1992/08/04  15:01:27  richard
 *  Changed read_wordset to cope with a garbage collection caused by
 *  profile_new().
 *
 *  Revision 1.31  1992/07/29  14:22:41  richard
 *  The profiler, rather than the loader, maintains a list of code vectors.
 *
 *  Revision 1.30  1992/07/27  13:00:27  richard
 *  Changed delcare_code_vector() to declare_code(), exported it, and
 *  increased the size of the arrays it uses.
 *
 *  Revision 1.29  1992/07/20  12:24:38  richard
 *  Removed redundant include of "gc.h".
 *
 *  Revision 1.28  1992/07/15  17:24:28  richard
 *  Added load_wordset().
 *
 *  Revision 1.27  1992/07/14  09:21:17  richard
 *  Implemented load_code_vectors, and changed the way the loader
 *  interacts with the profiler.
 *
 *  Revision 1.26  1992/07/02  09:12:42  richard
 *  Returns ERROR to indicate error rather than IMPOSSIBLE.
 *
 *  Revision 1.25  1992/07/01  13:47:45  richard
 *  Changed module table types.  See modules.h.
 *
 *  Revision 1.24  1992/06/11  09:56:58  clive
 *  Fixes for the profiler
 *
 *  Revision 1.23  1992/05/12  19:45:54  jont
 *  Allowed comprehension of version 2, created when the magic number was
 *
 *  Revision 1.22  1992/05/05  09:54:01  clive
 *  Function called by value of ml_vector needs to declare it
 *
 *  Revision 1.21  1992/04/14  11:59:48  clive
 *  First version of the profiler
 *
 *  Revision 1.20  1992/03/20  15:49:05  richard
 *  Corrected calculatio of backpointers.
 *
 *  Revision 1.19  1992/03/20  14:46:26  richard
 *  New module format.  Added code to deal with different module versions.
 *
 *  Revision 1.18  1992/03/17  17:26:35  richard
 *  Changed error behaviour and parameterised the module table.
 *
 *  Revision 1.17  1992/02/13  16:13:57  clive
 *  Never closed any files - it does now
 *
 *  Revision 1.16  1992/01/14  13:32:03  richard
 *  Changed the call of callml to pass the closure rather than the ml_vector
 *
 *  Revision 1.15  1992/01/09  16:23:52  richard
 *  Fixed an error in the loading of codesets.
 *
 *  Revision 1.14  1991/12/23  13:18:42  richard
 *  Changed the name of the fatal runtime error handler to error().
 *
 *  Revision 1.13  91/12/20  17:07:39  richard
 *  Rewrote read_codeset so that it works.  Changed diagnostic output to be
 *  switchable.
 *  
 *  Revision 1.12  91/12/17  16:47:40  nickh
 *  add in_ML flag.
 *  
 *  Revision 1.11  91/12/17  16:35:41  richard
 *  Added code to add suffices to module names.  Restricted the sizes
 *  of reals to doubles only.
 *  
 *  Revision 1.10  91/11/11  18:00:57  jont
 *  Added read_real. Modified read_string to put the actual string length
 *  into the header word, as opposed to the padded length
 *  
 *  Revision 1.9  91/10/24  16:17:04  davidt
 *  Changed name of callml.h to interface.h
 *  
 *  Revision 1.8  91/10/23  16:46:51  davidt
 *  Fixed size put into backpointers in codesets to be in bytes as required.
 *  
 *  Revision 1.7  91/10/21  11:35:40  davidt
 *  Made some minor changes and finished implementation of read_codeset.
 *  read_codeset now reads each individual function in using one big
 *  read and also puts in the separating backpointers between functions
 *  in the same codeset.
 *  
 *  Revision 1.6  91/10/18  16:10:31  davidt
 *  Actually calls ML now! loader_error now takes three arguments.
 *  Strings now have a word_aligned size.
 *  
 *  Revision 1.5  91/10/17  16:58:47  davidt
 *  Big hacks all over the place which have nearly got the thing loading
 *  object files properly. Codesets are done properly yet.
 *  
 *  Revision 1.4  91/10/16  14:04:42  davidt
 *  Major revision after change to object file format (not quite
 *  finished yet).
 *  
 *  Revision 1.3  91/05/17  17:11:09  jont
 *  Reals allocated as strings
 *  
 *  Revision 1.2  91/05/15  15:32:14  jont
 *  Revised interface for second version of load format
 *  
 *  Revision 1.1  91/05/14  11:11:27  jont
 *  Initial revision
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
#include <errno.h>
#include <memory.h>
#include <sys/stat.h>
#include <sys/types.h>

#include "ansi.h"
#include "syscalls.h"
#include "mltypes.h"
#include "values.h"
#include "loader.h"
#include "objectfile.h"
#include "allocator.h"
#include "interface.h"
#include "endian.h"
#include "modules.h"
#include "diagnostic.h"
#include "utils.h"
#include "global.h"
#include "pervasives.h"
#include "options.h"
#include "gc.h"
#include "mach_values.h"
#include "cache.h"
#include "loader_local.h"	/* mlw_path_dir_separator, mlw_path_src_tag */
#include "mem.h"		/* GENERATION */

/*  == Loaded code vector list ==  */

mlval loader_code;
void (*loader_code_observer)(mlval code) = NULL;

void (*loader_code_trace_observer)(mlval code) = NULL;

void loader_code_add(mlval code)
{
  declare_root(&code, 0);
  loader_code = weak_add(loader_code, code); /* This may call gc, hence declare */
  if(loader_code_observer != NULL)
    loader_code_observer(code);
  if(loader_code_trace_observer != NULL)
    loader_code_trace_observer(code);
  retract_root(&code);
}

static mlval disable(unsigned int index, mlval code)
{
  int type = SPACE_TYPE(code);
  int ok = 0;
  if (type == TYPE_RESERVED && validate_ml_address((void *)code)) {
    ok = 1;
  } else if (type == TYPE_ML_HEAP) {
    struct ml_heap *gen = VALUE_GEN(code);
    ok = live_in_gen(gen, (mlval *)code);
  }
  if (ok) {
    CCODE_SET_PROFILE(code,(mlval)NULL);
    return(code);
  } else {
    return DEAD;
  }
}

static void loader_code_fix(const char *name, mlval *root, mlval value)
{
  weak_apply(value, disable);
  *root = value;
}



/*  === INITIALISE LOADER ===
 *
 *  This functions declares external ML values as roots.
 */

mlval load_external = MLUNIT;

void load_init(void)
{
  declare_root(&load_external, 0);
  loader_code = weak_new(256);
  declare_global("loaded code list", &loader_code,
		 GLOBAL_DEFAULT+GLOBAL_WEAK_LIST, NULL, loader_code_fix, NULL);
}



/*  == Bulletproof object file reading functions ==
 *
 *  These functions read data from a stream and cause a non-local jump to
 *  `problem' if an error occurs.
 *
 *  NOTE: I'm not sure that the endian changing code is necessary or
 *  correct.
 */

static jmp_buf problem;

static void safe_read(void *whither, size_t size, size_t number, FILE *stream)
{
  if(fread(whither, size, number, stream) != number)
    longjmp(problem, feof(stream) ? ELOADFORMAT : ELOADREAD);
}

static int safe_read_byte(FILE *stream)
{
  int c;

  c = getc(stream);
  if (c == -1)
    longjmp(problem, feof(stream) ? ELOADFORMAT : ELOADREAD);
  return c;
}

static word read_raw_word(FILE *stream)
{
  word w;

  fread(&w, sizeof(word), 1, stream);
  return(w);
}

static word read_word(FILE *stream)
{
  word w;

  fread(&w, sizeof(word), 1, stream);
  change_endian(&w, 1);
  return(w);
}

static mlval read_pair(FILE *stream)
{
  word a = read_word(stream);
  word b = read_word(stream);
  return mlw_cons(MLINT(a), MLINT(b));
}

static int pairs_eq(mlval pair1, mlval pair2)
{
  return ((FIELD(pair1, 0) == FIELD(pair2, 0)) && (FIELD(pair1, 1) == FIELD(pair2, 1)));
}

static word read_opt_int(FILE *stream)
{
  unsigned char c;
  word w;

  c = safe_read_byte(stream);
  if (c == 255)
    w = read_word(stream);
  else if (c == 254) {
    w = (word)safe_read_byte(stream);
    w <<= 8;
    w += (word)safe_read_byte(stream);
  }
  else
    w = (word)c;
  return w;
}

static mlval read_real(FILE *stream)
{
  double the_real;

  mlval ml_real = allocate_real();
  safe_read(&the_real, sizeof(double), 1, stream);

  /* REVERSE_REAL_BYTES defined in mach_values.h for I386 */
  #ifdef REVERSE_REAL_BYTES
  {
    char *bottom = (char *)&the_real;
    char *top = bottom + sizeof(double) - 1;
    while (top > bottom)
      {
	char t = *bottom;
	*bottom = *top;
	*top = t;
	bottom++;
	top--;
      }
  }
  #endif

  (void)SETREAL(ml_real, the_real);
  return(ml_real);
}

static mlval read_string(word string_size, FILE *stream)
{
  mlval ml_string = allocate_string(string_size);

  safe_read(CSTRING(ml_string), word_align(string_size), 1, stream);
  return(ml_string);
}



/* This function is called when loading modules into a debugging
runtime invoked with the -delivery switch. It abbreviates long code
names (from building MLWorks):

"initial_listener[/home/ml/sml/MLW/src/interpreter/_tty_listener.sml:320,7 to 320,54]" becomes "initial_listener[ interpreter._tty_listener:320]"

It's not completely straightforward; some code names include two
location strings:

"Builtin o of pad argument 1[/nfs/ml/home/ml/sml/MLW/src/sparc/_sparc_assembly.sml:465,23 to 467,25] and decode_load_and_store'[/nfs/ml/home/ml/sml/MLW/src/sparc/_sparc_assembly.sml:474,7 to 483,38]"

becomes 

"Builtin o of pad argument 1[ sparc._sparc_assembly:465] and decode_load_and_store'[ sparc._sparc_assembly:474]"

*/

static mlval read_delivery_name(word string_size, FILE *stream)
{
  char *str = (char*)malloc(string_size);
  char *start_of_locn = str, *end_of_locn, *workptr;
  mlval result_string;

  safe_read (str,word_align(string_size),1,stream);

  while (((start_of_locn = strchr(start_of_locn,'[')) != NULL) &&
	 ((end_of_locn = strchr(start_of_locn,']')) != NULL)) {

    /* found a location string, from start_of_locn to end_of_locn */

    /* remove "foo/bar/baz/src/" substring */
    workptr = strstr(start_of_locn+1, mlw_path_src_tag);
    if ((workptr != NULL) && (workptr < end_of_locn)) {
      start_of_locn[1] = ' '; /* distinguishing delivered code names */
      strcpy (start_of_locn+2,workptr+5);
      end_of_locn -= (workptr+3-start_of_locn);

      /* change remaining slashes to dots */
      workptr = start_of_locn;
      while (((workptr = strchr(workptr, mlw_path_dir_separator)) != NULL) &&
	     (workptr < end_of_locn))
	*workptr = '.';

      /* remove any ".sml" */
      if (((workptr = strstr(start_of_locn,".sml")) != NULL) &&
	  (workptr < end_of_locn)) {
	strcpy(workptr,workptr+4);	
	end_of_locn -= 4;
      }
    }
    
    /* remove ",45 to 456,65" tail of the location string */
    if ((workptr = strchr(start_of_locn,',')) != NULL)
      strcpy(workptr,end_of_locn);

    start_of_locn = end_of_locn;
  }

  result_string = ml_string (str);
  free(str);
  return result_string;
}

static word read_cons_size(FILE *stream)
{
  word list_size;

  fseek(stream, HEADER_SIZE, 0);
  list_size = read_opt_int(stream);
  DIAGNOSTIC(3, "             stream = 0x%X, cons_size = %u)", stream, list_size);
  return list_size;
}

static mlval read_name(FILE *stream)
{
  mlval name;
  word string_size;
  
  string_size = read_opt_int(stream);
  name = allocate_string(string_size + 1);
  safe_read(CSTRING(name), string_size, 1, stream);
  CSTRING(name)[string_size] = '\0';
  return name;
}

/* make ancillary word with checking */

extern mlval make_ancill(word saves,
			 word spill,
			 word leaf,
			 int intercept, /* signed! */
			 word stack_param,
			 word code_no)
{
  if (spill % sizeof(mlval) != 0) {
    error("Trying to load code vector with non word aligned nongc spill area (%x)",
	  spill);
  }
  spill /= sizeof(mlval);
  if (code_no > CCODE_MAX_NUMBER)
    error ("Trying to load object code vector with too many items : %x",
	   code_no);
  if (intercept > CCODE_MAX_INTERCEPT || intercept < -1)
    error ("Trying to load object code with intercept offset too large : %d, %x",
	   intercept, CCODE_MAX_INTERCEPT);
  if (spill > CCODE_MAX_NONGC)
    error ("Trying to load object code with too many non-gc spill slots : %x",
	   spill);

  /* don't check leaf; it's a boolean */

  if (stack_param > CCODE_MAX_ARGS)
    error ("Trying to load object code with too many stacked parameters : %x",
	   stack_param);

  return CCODE_MAKE_ANCILL(saves, spill,leaf,intercept,stack_param, code_no);
}

/*  == Load codeset ==
 *
 *  A codeset is a set of procedures which are allocated in the same
 *  code vector.  The procedures have back-pointers to the start of the
 *  string between them so that the garbage collector knows what to do
 *  with them.  The code sizes in the input file do not take account
 *  of the back pointers, and so these are inserted here.
 *
 *  The start address of each procedure is inserted into the array objects.
 *
 *  The delivery option affects how code names read are treated.
 */

static int read_codeset(unsigned int nr_procedures,
			 mlval objects,
			 FILE *stream,
			 unsigned int version,
			 int delivery)
{
  mlval vector, ancillary, *next;
  mlval names, profiles;
  size_t i, offset, length, file_length;
  word *proc_positions;

  DIAGNOSTIC(3, "read_codeset(nr_procedures = %u, objects = 0x%X",
	        nr_procedures, objects);
  DIAGNOSTIC(3, "             stream = 0x%X, version = %d)", stream, version);

  declare_root(&objects, 0);

  /* Read and calculate the length of code vector required.  This is one */
  /* word for each instruction, plus two words per code item for the item */
  /* header, plus one words for the ancillary pointer. */

  file_length = read_word(stream);
  if(word_align(file_length) != file_length) {
    errno = ELOADALIGN;
    return(MLERROR);
  }

  length = file_length/sizeof(word) + 2*nr_procedures + 1;

  /* build the record of names */
  if (nr_procedures == 1) {	/* by far the commonest case */

    size_t size = read_word(stream);
    mlval name = (delivery ? read_delivery_name(size,stream)
		  : read_string(size,stream));
    declare_root (&name, 0);
    DIAGNOSTIC(3, "  name = %s",CSTRING(name),0);
    names = allocate_record(1);
    FIELD(names,0) = name;
    retract_root (&name);
    declare_root (&names, 0);

  } else {
    /* not such a common case */
    /* have to allocate an array for the names, read them in, then copy to a record */

    mlval names_array = allocate_array(nr_procedures);
    for (i=0; i<nr_procedures; ++i)
      MLUPDATE(names_array, i, MLUNIT);
    declare_root(&names_array, 0);

    for (i=0; i<nr_procedures; ++i) {
      size_t size = read_word(stream);
      mlval name = (delivery ? read_delivery_name(size,stream)
		    : read_string(size,stream));
      MLUPDATE(names_array, i, name);
    }
    /* Now copy to a record */
    names = allocate_record(nr_procedures);
    for (i=0; i<nr_procedures;i++)
      FIELD(names,i) = MLSUB(names_array,i);
    retract_root(&names_array);
    declare_root(&names, 0);
  }

  profiles = allocate_record(nr_procedures);
  for (i=0; i < nr_procedures; i++)
    FIELD(profiles,i) = (mlval) 0;
  declare_root (&profiles, 0);

  /* If we're not interceptible, we don't create an array or put a
     slot in the ancillary record for the intercept functions*/

  {
    word interceptible = read_word(stream);
    if (interceptible) {
      mlval interfns = allocate_array(nr_procedures);
      for(i=0; i<nr_procedures; ++i)
	MLUPDATE(interfns, i, MLUNIT);
      declare_root(&interfns, 0);
      ancillary = allocate_record (3);
      FIELD(ancillary,ANC_INTERFNS) = interfns;
      retract_root(&interfns);
    } else
      ancillary = allocate_record (2);
  }

  FIELD(ancillary,ANC_PROFILES) = profiles;
  FIELD(ancillary,ANC_NAMES) = names;

  retract_root (&names);
  retract_root (&profiles);
  declare_root (&ancillary, 0);

  vector = allocate_code(length);
  CCVANCILLARY(vector) = ancillary;
  declare_root(&vector, 0);
  retract_root(&ancillary);

  /* Read the code items */

  DIAGNOSTIC(3, "code vector 0x%X of %d items", vector, nr_procedures);

  proc_positions = (word*)alloc(sizeof(word)*nr_procedures,
				"Code loading procedure positions");
  offset = 2;
  for(i=0; i<nr_procedures; ++i) {
    word size, position, spill, saves, leaf, stack_param;
    int intercept;
    mlval code;

    /* Read the position in the closure */
    position = read_word(stream);
    proc_positions[i] = position;

    /* Read the ancillary information: number of non-GC spills, */
    /* the leaf flag, the intercept offset */
    /* and the number of stacked parameters */

    spill = read_word(stream);
    saves = read_word(stream);
    leaf = read_word(stream) ? 1 : 0;
    intercept = CINT(MLINT(read_word(stream)));	/* to get the sign right */
    stack_param = read_word(stream);

    /* Now insert the actual code into the vector */

    next = (mlval *)OBJECT(vector) + offset;
    code = MLPTR(POINTER, next);

    /* Insert a BACKPTR to the real header. */
    *next = MAKEHEAD(BACKPTR, offset * sizeof(mlval));

    /* Insert the code pointer into the closure */
    MLUPDATE(objects, position, code);

    /* Make the ancillary number */
    next[1] = make_ancill(saves, spill,leaf,intercept, stack_param,i);

    size = read_word(stream);
    safe_read(&next[2], size, 1, stream);
    if (change_code_endian) change_endian(&next[2], size);
    cache_flush((void*) &next[2], (size_t) size);

    offset += double_align(size + 2*sizeof(mlval))/sizeof(mlval);

    DIAGNOSTIC(3, "  %3u: 0x%X", i, code);
    DIAGNOSTIC(3, "       position %u  length 0x%X bytes", position, size);
    DIAGNOSTIC(3, "       non-GC spills %u  %sleaf", spill, leaf ? "" : "non-");
    DIAGNOSTIC(3, "       intercept offset %d", intercept, 0);

  }

  /* Have to apply loader_code_add() to all the code items after the whole
   * code object is complete */

  for(i=0; i<nr_procedures; ++i) {
    mlval code = MLSUB(objects, proc_positions[i]);
    loader_code_add(code);	/* this could cause a GC */
  }
  free(proc_positions);

  retract_root(&vector);
  retract_root(&objects);
  return 0;
}



/*  === LOAD AN ML MODULE ===
 *
 *  Loading a module consists of reading ML objects from the module file and
 *  putting them in an ML record which record becomes the closure of the
 *  setup function for the module.
 *
 * This also checks the consistency of the loading if required.
 *
 * The delivery option affects how code names are treated.
 */

static mlval load_module(const char *filename, mlval *mod_name, mlval *source_time,
			 mlval modules, int verbose, int dont_check_cons, int delivery)
{
  unsigned int i, opcode, module_size, table_size, code_offset, version;
  mlval objects = MLUNIT, closure, mo_time = MLUNIT;
  mlval require_name = MLUNIT;
  FILE *volatile stream;
  size_t length, cons_size;

  /* Attempt to open object file with the given name.  If that fails */
  /* and the name doesn't end in `.mo', try adding that. */
  stream = fopen(filename, "rb");

  if(stream == NULL &&
     strcmp(filename + (length = (unsigned)strlen(filename)) - 3u, ".mo"))
  {
    char *name_with_suffix = (char *)malloc(length + 3 + 1);

    if(name_with_suffix == NULL)
    {
      errno = ELOADALLOC;
      return(MLERROR);
    }

    strcpy(name_with_suffix, filename);
    strcpy(name_with_suffix + length, ".mo");

    stream = fopen(name_with_suffix, "rb");

    free(name_with_suffix);
  }

  if(stream == NULL)
  {
    errno = ELOADOPEN;
    return(MLERROR);
  }

  declare_root(&modules, 0);
  declare_root(&objects, 0);
  declare_root(&mo_time, 0);
  declare_root(&require_name, 0);

  /* Set up an error handler for the reading functions.  See read() above. */
  {
    int code = setjmp(problem);

    if(code != 0)
    {
      errno = code;
      retract_root(&modules);
      retract_root(&objects);
      retract_root(&require_name);
      retract_root(&mo_time);
      fclose(stream);
      return(MLERROR);
    }
  }

  /* Find endianess of object file, check the version number and code */
  /* size, and seek to the start of the code. */
  if(!find_endian(read_raw_word(stream)))
  {
    errno = ELOADFORMAT;
    return(MLERROR);
  }

  version = read_word(stream);

  /* Check that the version of the mo is compatible with the current loader */
  /* see objectfile.h for OBJECT_CODE_VERSION */

  if(version < OBJECT_CODE_VERSION)
    longjmp(problem, ELOADVERSION);

  /* Get code offset */

  code_offset = read_word(stream);
  cons_size = read_cons_size(stream);

  *mod_name = read_name(stream);

  *source_time = read_pair(stream);
  /* This is the first item of the consistency information */
  /* We don't care about the time here */

  while (--cons_size > 0) {
    /* Check the other time stamps */
    require_name = read_name(stream);

    mo_time = read_pair(stream);
    if (!dont_check_cons) {
      mlval mt_time = mt_lookup_time(modules, require_name, *mod_name);
      if (mt_time == MLERROR) {
	load_external = require_name;
	longjmp(problem, ELOADEXTERNAL);
      }
      if (!pairs_eq(mo_time,mt_time)) {
	message_start();
	message_string("Warning: module '");
	message_string(CSTRING(*mod_name));
	message_string("' references module '");
	message_string(CSTRING(require_name));
	message_string("' with incompatible time stamp. Recompilation recommended.");
	message_end();
#ifdef DIAGNOSTICS
	if (4 <= diagnostic_level) {
	  unsigned int *foo = (unsigned int *)(((int)mo_time)-1);
	  int len,i;
	  message_stderr("mo_time = 0x",0,0);
	  len = LENGTH(foo[-1]);
	  for(i=0;i<len;i++)
	    message_stderr(" %x",foo[i]);
	  
	  foo = (unsigned int *)((int)(mt_lookup_time(modules, require_name, *mod_name))-1);
	  message_stderr("\nrequire_time = 0x");
	  len = LENGTH(foo[-1]);
	  for(i=0;i<len;i++)
	    message_stderr(" %x",foo[i]);
	}
	message_stderr("\n");
#endif /* DIAGNOSTICS */
      }
    }
  }

  /* Seek to the code */

  fseek(stream, (signed int) code_offset, 0);

  if (verbose) {
    message_start();
    message_string("Loading module `");
    message_string(CSTRING(*mod_name));
    message_string("'");
    message_end();
  }

  module_size = read_word(stream);
  table_size = read_word(stream);

  DIAGNOSTIC(4, "  module size %d  table size %d", module_size, table_size);

  /* Get a vector if appropriate size */
  objects = allocate_array(table_size);
  for(i = 0; i < table_size; i++)
    MLUPDATE(objects, i, MLUNIT);

  /* Load objects into vector */
  for (i = 0; i < module_size; i++)
  {
    opcode = read_word(stream);

    switch (opcode)
    {
      case OPCODE_CODESET:
      {
	word codeset_size = read_word(stream);
	if (read_codeset(codeset_size, objects, stream, version, delivery) == MLERROR)
	  longjmp(problem, errno);
      }
      break;

      case OPCODE_REAL:
      {
	word offset = read_word(stream);
	word real_size = read_word(stream);

	if(real_size != 2)
	  longjmp(problem, ELOADFORMAT);

        DIAGNOSTIC(4, "  real to position 0x%lX", offset, 0);

	{
	  mlval temp = read_real(stream);  /* Do NOT inline this */
	  MLUPDATE(objects, offset, temp);
	}
      }
      break;

      case OPCODE_STRING:
      {
	word offset = read_word(stream);
	word string_size = read_word(stream);

        DIAGNOSTIC(4, "  string to position 0x%lX", offset, 0);

	{
	  mlval temp = read_string(string_size,stream);  /* Do NOT inline this */
	  MLUPDATE(objects, offset, temp);
	}
      }
      break;

      case OPCODE_EXTERNAL:
      {
	/* Find out the name of the module referred to by the external */
	/* and look it up in the module table. */
	word offset = read_word(stream);
	word string_size = read_word(stream);
	mlval name = read_string(string_size, stream);
	mlval module = mt_lookup(modules, name, *mod_name);

	if(module == MLERROR)
	{
	  load_external = name;
	  longjmp(problem, ELOADEXTERNAL);
	}

        DIAGNOSTIC(4, "  external reference to module %s in "
		      "position 0x%lX", CSTRING(name), offset);

	MLUPDATE(objects, offset, module);
      }
      break;

      default:
      longjmp(problem, ELOADFORMAT);
    }
  }

  fclose(stream);


  closure = allocate_record(table_size);
  for(i=0; i<table_size; ++i)
    FIELD(closure, i) = MLSUB(objects, i);

  retract_root(&modules);
  retract_root(&require_name);
  retract_root(&mo_time);
  retract_root(&objects);

/* The consistency information follows on immediately from the code */

  return(closure);
}


/* internal_load_link, called from main.c to load a module, and also
 * callable from ML to load a .mo file into a running image.
 * 
 * The delivery option doesn't do anything at present. */

mlval internal_load_link(const char *filename, 
			 mlval *mod_name_ptr,
			 int verbose, 
			 int dont_check_cons,
			 int delivery)
{
  mlval closure;
  mlval structure;
  mlval time;

  declare_root(mod_name_ptr, 0);
  declare_root(&time, 0);

  closure = load_module(filename, mod_name_ptr, &time, DEREF(modules),
			verbose, dont_check_cons, delivery);

  if(closure == MLERROR)
    {
      retract_root(mod_name_ptr);
      retract_root(&time);
      return (MLERROR);
    }
  else
    {
      structure = callml(closure, closure);
      {
	mlval temp = mt_add(DEREF(modules), *mod_name_ptr, structure, time);
	/* Do NOT inline this */
	MLUPDATE(modules, 0, temp);
      }
      retract_root(mod_name_ptr);
      retract_root(&time);

      return(structure);
    }
}


/*  === LOAD A COMPILED WORDSET ===
 *
 *  From main/code_module.sml:MachTypes:

 datatype wordset =
    WORD_SET of
    {a_names:string list,
    b: {a_clos:int,
        b_spills:int,
	c_saves:int,
	d_code:string} list,
    c_leafs:bool list,
    d_intercept:int list,
    e_stack_parameters:int list}
 *
 *  The first argument to load_wordset is the runtime version required for
 *  this wordset.
 *
 *  See also: read_codeset() which loads the same object from a `.mo' file.
 */

mlval load_wordset(mlval argument)
{
  size_t length = 0, offset;
  mlval result = MLNIL, vector, list = MLUNIT, code = MLUNIT;
  unsigned int version = CINT(FIELD(argument, 0)), i, nr_procedures = 0;
  mlval wordset = FIELD(argument, 1);
  mlval names, ancillary, profiles, interceptible, leafs;
  mlval intercepts, stack_params;

  DIAGNOSTIC(2, "load_wordset(version = %d, wordset = 0x%X)", version, wordset);

  if(version != OBJECT_FILE_VERSION)
  {
    errno = version > OBJECT_FILE_VERSION ? ELOADNEWER : ELOADOLDER;
    return(MLERROR);
  }

  /* Calculate the length of the code vector and perform consistency checks. */

  for(list=FIELD(wordset, 1); list!=MLNIL; list=MLTAIL(list))
  {
    mlval quadruple = MLHEAD(list);
    size_t l = word_align(CSTRINGLENGTH(FIELD(quadruple,3)));
    if(word_align(l) != l)
    {
      errno = ELOADALIGN;
      return(MLERROR);
    }
    /* One for back pointer, one for number within set */
    length += l/sizeof(word) + 2;

    ++nr_procedures;
  }

  if(length == 0)
  {
    errno = ELOADEMPTY;
    return(MLERROR);
  }

  DIAGNOSTIC(3, "  nr_procedures=%u  length=%u", nr_procedures, length);

  declare_root(&wordset, 0);

  /* Create the names record */
  names = allocate_record(nr_procedures);
  DIAGNOSTIC(3, "  function names record 0x%X:", names, 0);
  for (i=0, list=FIELD(wordset, 0); i<nr_procedures; ++i, list=MLTAIL(list))
  {
    FIELD(names,i) = MLHEAD(list);
    DIAGNOSTIC(3, "    %3d: `%s'", i, CSTRING(MLHEAD(list)));
  }
  declare_root (&names, 0);

  profiles = allocate_record(nr_procedures);
  for (i=0; i < nr_procedures; i++)
    FIELD(profiles,i) = (mlval) 0;
  declare_root (&profiles, 0);

  /* Determine whether any code items are interceptible. */

  interceptible = 0;
  for(list=FIELD(wordset, 3); list!=MLNIL; list=MLTAIL(list))
    interceptible |= (MLHEAD(list) != MLINT(-1));

  if (interceptible) {
    mlval interfns = allocate_array(nr_procedures);
    for(i=0; i<nr_procedures; ++i)
      MLUPDATE(interfns, i, MLUNIT);
    declare_root(&interfns, 0);
    ancillary = allocate_record (3);
    FIELD(ancillary,ANC_INTERFNS) = interfns;
    retract_root(&interfns);
  } else
    ancillary = allocate_record (2);
    
  FIELD(ancillary,ANC_PROFILES) = profiles;
  FIELD(ancillary,ANC_NAMES) = names;

  retract_root (&profiles);
  retract_root (&names);
  declare_root (&ancillary, 0);

  vector = allocate_code(length+1);
  CCVANCILLARY(vector) = ancillary;

  declare_root(&vector, 0);
  retract_root(&ancillary);

  retract_root(&wordset);

  /* only root now is vector; have to declare these next four as roots
     because they will be pointing into the wordset structure when we do
     allocation. */

  declare_root(&list, 0);
  declare_root(&leafs, 0);
  declare_root(&intercepts, 0);
  declare_root(&stack_params, 0);

  /* this will be pointing to the list of results that we build up */

  declare_root(&result, 0);

  /* this will be pointing at the current code item when we do a cons */

  declare_root(&code, 0);

  DIAGNOSTIC(3, "  code vector 0x%X", vector, 0);

  /* prepare for the loop: */

  offset = 2;
  list=FIELD(wordset, 1);
  leafs=FIELD(wordset,2);
  intercepts=FIELD(wordset,3);
  stack_params=FIELD(wordset,4);
  /* do the loop: */

  for(i=0; list!=MLNIL; ++i)
  {
    mlval quad = MLHEAD(list);		  /* (position,non_gcs,saves,code) */
    mlval string = FIELD(quad, 3);	  /* the code itself */
    mlval position = FIELD(quad, 0);	  /* the position in the closure */
    word spills = CINT(FIELD(quad,1));	  /* the number of non-GC spills */
    word saves = CINT(FIELD(quad,2));	  /* the number of callee saves */
    word leaf = CINT(MLHEAD(leafs));	  /* is it a leaf? */
    int intercept = CINT(MLHEAD(intercepts)); /* where to intercept it? */
    int stack_param = CINT(MLHEAD(stack_params)); /* How many stacked parameters */
    size_t length = CSTRINGLENGTH(string); /* size of the code itself */
    mlval *next = (mlval *)OBJECT(vector) + offset; /* where do we write it? */
    mlval pair;

    code = MLPTR(POINTER, next);

    next[0] = MAKEHEAD(BACKPTR, offset * sizeof(mlval));

    next[1] = make_ancill(saves, spills,leaf,intercept, stack_param,i);

    memcpy((char *)&next[2], CSTRING(string), length);
    cache_flush((void *)&next[2], length);

    DIAGNOSTIC(3, "    %3d: position %d", i, position);
    DIAGNOSTIC(3, "         offset 0x%X  spills %u", offset, CINT(FIELD(quad, 1)));

    /* prepare for next time around the loop: */

    offset += double_align(length + 2*sizeof(mlval))/sizeof(mlval);
    intercepts = MLTAIL(intercepts);
    leafs = MLTAIL(leafs);
    list = MLTAIL(list);
    stack_params = MLTAIL(stack_params);

    /* build the result pair and cons it onto the list */

    pair = allocate_record(2);
    FIELD(pair, 0) = position;
    FIELD(pair, 1) = code;
    result = mlw_cons(pair, result);
  }

  /* When the code object is complete, we can apply loader_code_add() */

  for (list = result; list != MLNIL; list = MLTAIL(list)) {
    mlval pair = MLHEAD(list);
    loader_code_add(FIELD(pair,1));
  }

  retract_root(&list);
  retract_root(&leafs);
  retract_root(&intercepts);
  retract_root(&stack_params);
  retract_root(&vector);
  retract_root(&code);
  retract_root(&result);

  return(result);
}
@


1.44.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 * Revision 1.44  1998/09/30  14:53:23  jont
 * [Bug #70108]
 * Make sure stat.h is included before syscalls.h to avoid problems with lstat
 *
@


1.43
log
@[Bug #30108]
Implement DLL based ML code
@
text
@d12 4
d371 9
a399 9

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
#include <errno.h>
#include <memory.h>
#include <sys/stat.h>
#include <sys/types.h>
@


1.42
log
@[Bug #70034]
Rationalising names in mem.h
@
text
@d12 4
d404 1
a404 1
static void loader_code_add(mlval code)
d417 9
a425 2
  struct ml_heap *gen = VALUE_GEN(code);
  if (live_in_gen(gen, (mlval *)code)) {
d1341 1
a1341 1
    result = cons(pair, result);
@


1.41
log
@[Bug #70091]
Remove require_name from consistency info as it's not needed now
@
text
@d12 4
d413 1
a413 1
  struct gen *gen = VALUE_GEN(code);
@


1.40
log
@[Bug #70026]
Allow profiling of stub_c functions, recording the time according
to the name of the runtime system functions
@
text
@d12 5
a616 11


static mlval ignore_unaligned_string(word string_size, FILE *stream)
{
  mlval ml_string = allocate_string(1);
  while (string_size--)
    safe_read(CSTRING(ml_string), 1, 1, stream); /* Ignore the string */
  *(CSTRING(ml_string)) = '\0'; /* Finally set it to be null string */
  return(ml_string);
}

a631 3
/*
  fseek(stream, HEADER_SIZE+1, 0);
*/
d870 1
a870 1
  mlval require_name = MLUNIT, source_require_name = MLUNIT;
a945 2
  i = read_opt_int(stream); /* req_name size */
  source_require_name = ignore_unaligned_string(i, stream);
a954 3
    i = read_opt_int(stream); /* req_name size */
    source_require_name = ignore_unaligned_string(i, stream);

a959 3
/*
	message_stderr("Time stamp failure, mod_name = '%s', require_name = '%s', source_require_name = '%s'\n", CSTRING(*mod_name), CSTRING(require_name), CSTRING(source_require_name));
*/
a1070 3
/*
	  message_stderr("External reference failure, mod_name = '%s', require_name = '%s', source_require_name = '%s'\n", CSTRING(*mod_name), CSTRING(require_name), CSTRING(source_require_name));
*/
@


1.39
log
@[Bug #70018]
Add cast to call to live_in_gen
@
text
@d12 4
d650 6
a655 6
static inline mlval make_ancill(word saves,
				word spill,
				word leaf,
				int intercept, /* signed! */
				word stack_param,
				word code_no)
@


1.38
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d12 5
d401 1
a401 1
  if (live_in_gen(gen, code)) {
@


1.37
log
@[Bug #30089]
Remove include of mltime.h which is no longer needed
@
text
@d12 4
d364 1
d384 1
a384 1
  declare_root(&code);
d395 7
a401 2
  CCODE_SET_PROFILE(code,(mlval)NULL);
  return(code);
d421 1
a421 1
  declare_root(&load_external);
d700 1
a700 1
  declare_root(&objects);
d720 1
a720 1
    declare_root (&name);
d725 1
a725 1
    declare_root (&names);
d734 1
a734 1
    declare_root(&names_array);
d747 1
a747 1
    declare_root(&names);
d753 1
a753 1
  declare_root (&profiles);
d764 1
a764 1
      declare_root(&interfns);
d777 1
a777 1
  declare_root (&ancillary);
d781 1
a781 1
  declare_root(&vector);
d903 4
a906 4
  declare_root(&modules);
  declare_root(&objects);
  declare_root(&mo_time);
  declare_root(&require_name);
d1130 2
a1131 2
  declare_root(mod_name_ptr);
  declare_root(&time);
d1221 1
a1221 1
  declare_root(&wordset);
d1231 1
a1231 1
  declare_root (&names);
d1236 1
a1236 1
  declare_root (&profiles);
d1248 1
a1248 1
    declare_root(&interfns);
d1260 1
a1260 1
  declare_root (&ancillary);
d1265 1
a1265 1
  declare_root(&vector);
d1274 4
a1277 4
  declare_root(&list);
  declare_root(&leafs);
  declare_root(&intercepts);
  declare_root(&stack_params);
d1281 1
a1281 1
  declare_root(&result);
d1285 1
a1285 1
  declare_root(&code);
@


1.36
log
@[Bug #30089]
Timestamps changed to be pairs of integers representing
stamp div 10**6 and stamp mod 10**6
@
text
@d12 5
a355 1
#include "mltime.h"
@


1.36.1.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a11 5
 * Revision 1.36  1997/10/21  09:01:34  jont
 * [Bug #30089]
 * Timestamps changed to be pairs of integers representing
 * stamp div 10**6 and stamp mod 10**6
 *
@


1.35
log
@[Bug #20090]
Changed the module table to store the time stamps from the consistency
information, instead of the modification times of the files themselves.
@
text
@d12 5
d459 12
a599 8
static mlval read_unaligned_string(word string_size, FILE *stream)
{
  mlval ml_string = allocate_string(string_size);

  safe_read(CSTRING(ml_string), string_size, 1, stream);
  return(ml_string);
}

d856 1
a856 1
  mlval require_name = MLUNIT, mo_string = MLUNIT, source_require_name = MLUNIT;
a892 1
  declare_root(&mo_string);
a902 1
      retract_root(&mo_string);
d935 1
a935 2
  i = read_opt_int(stream); /* Time stamp size */
  *source_time = time_decode(read_unaligned_string(i, stream));
d946 1
a946 4
    i = read_opt_int(stream); /* Time stamp size */
    DIAGNOSTIC (4, "Reading mo_string of length %u\n", i,0);
    mo_string = read_unaligned_string(i, stream);
    mo_time = time_decode(mo_string);
d956 1
a956 1
      if (!ml_time_eq(mo_time,mt_time)) {
d966 14
a979 22
	    unsigned int *foo = (unsigned int *)(((int)mo_time)-1);
	    char * bar;
	    int len,i;
	    message_stderr("mo_time = 0x",0,0);
	    len = LENGTH(foo[-1]);
	    for(i=0;i<len;i++)
	      message_stderr(" %x",foo[i]);
	    
	    foo = (unsigned int *)((int)(mt_lookup_time(modules, require_name, *mod_name))-1);
	    message_stderr("\nrequire_time = 0x");
	    len = LENGTH(foo[-1]);
	    for(i=0;i<len;i++)
	      message_stderr(" %x",foo[i]);
	    bar = CSTRING(mo_string);
	    message_stderr("\nmo_string = ");
	    len = *((int *)(bar-4));
	    len >>= 6;
	    while (len-- > 0) {
	      message_stderr("0x%x ", *bar++);
	    }
	    message_stderr("\n");
	  }
a1090 1
  retract_root(&mo_string);
@


1.34
log
@[Bug #20069]
Check validity of stack_params to make_ancill
@
text
@d12 4
d842 1
a842 1
static mlval load_module(const char *filename, mlval *mod_name,
d846 1
a846 1
  mlval objects = MLUNIT, closure, source_time, mo_time = MLUNIT;
d929 1
a929 1
  source_time = time_decode(read_unaligned_string(i, stream));
a1122 7

  time = ml_stat(filename);
  if(time == MLERROR) {
    errno = ELOADOPEN;
    return MLERROR;
  }

d1125 2
a1126 2
  closure = load_module(filename, mod_name_ptr, DEREF(modules),
			verbose, dont_check_cons,delivery);
@


1.34.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 4
 * Revision 1.34  1997/07/22  11:57:24  jont
 * [Bug #20069]
 * Check validity of stack_params to make_ancill
 *
@


1.34.2.2
log
@[Bug #20090]
Merged from trunk:
Changed the module table to store the time stamps from the consistency
information, instead of the modification times of the files themselves.
@
text
@a11 3
 * Revision 1.34.2.1  1997/09/11  21:02:55  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d842 1
a842 1
static mlval load_module(const char *filename, mlval *mod_name, mlval *source_time,
d846 1
a846 1
  mlval objects = MLUNIT, closure, mo_time = MLUNIT;
d929 1
a929 1
  *source_time = time_decode(read_unaligned_string(i, stream));
d1123 7
d1132 2
a1133 2
  closure = load_module(filename, mod_name_ptr, &time, DEREF(modules),
			verbose, dont_check_cons, delivery);
@


1.34.2.3
log
@[Bug #30089]
Merged from trunk:
Timestamps changed to be pairs of integers representing
stamp div 10**6 and stamp mod 10**6
@
text
@a11 6
 * Revision 1.34.2.2  1997/10/29  12:06:18  daveb
 * [Bug #20090]
 * Merged from trunk:
 * Changed the module table to store the time stamps from the consistency
 * information, instead of the modification times of the files themselves.
 *
a456 12
static mlval read_pair(FILE *stream)
{
  word a = read_word(stream);
  word b = read_word(stream);
  return mlw_cons(MLINT(a), MLINT(b));
}

static int pairs_eq(mlval pair1, mlval pair2)
{
  return ((FIELD(pair1, 0) == FIELD(pair2, 0)) && (FIELD(pair1, 1) == FIELD(pair2, 1)));
}

d586 8
d850 1
a850 1
  mlval require_name = MLUNIT, source_require_name = MLUNIT;
d887 1
d898 1
d931 2
a932 1
  *source_time = read_pair(stream);
d943 4
a946 1
    mo_time = read_pair(stream);
d956 1
a956 1
      if (!pairs_eq(mo_time,mt_time)) {
d966 22
a987 14
	  unsigned int *foo = (unsigned int *)(((int)mo_time)-1);
	  int len,i;
	  message_stderr("mo_time = 0x",0,0);
	  len = LENGTH(foo[-1]);
	  for(i=0;i<len;i++)
	    message_stderr(" %x",foo[i]);
	  
	  foo = (unsigned int *)((int)(mt_lookup_time(modules, require_name, *mod_name))-1);
	  message_stderr("\nrequire_time = 0x");
	  len = LENGTH(foo[-1]);
	  for(i=0;i<len;i++)
	    message_stderr(" %x",foo[i]);
	}
	message_stderr("\n");
d1099 1
@


1.34.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 4
 * Revision 1.34  1997/07/22  11:57:24  jont
 * [Bug #20069]
 * Check validity of stack_params to make_ancill
 *
@


1.33
log
@[Bug #30076]
Modify to make NONGC spills be counted in words
@
text
@d12 4
d637 4
@


1.32
log
@[Bug #30076]
Modifications to allow stack based parameter passing on the I386
@
text
@d12 4
d617 5
@


1.31
log
@Reverse bytes in read_real
@
text
@d12 3
d610 1
d619 2
a620 2
  if (spill > CCODE_MAX_SPILL)
    error ("Trying to load object code with too many spill slots : %x",
d625 1
a625 1
  return CCODE_MAKE_ANCILL(saves, spill,leaf,intercept,code_no);
d748 1
a748 1
    word size, position, spill, saves, leaf;
d757 2
a758 1
    /* the leaf flag, and the intercept offset */
d764 2
a765 1
    
d778 1
a778 1
    next[1] = make_ancill(saves, spill,leaf,intercept,i);
d1148 2
a1149 1
    d_intercept:int list}
d1163 2
a1164 1
  mlval names, ancillary, profiles, interceptible, leafs, intercepts;
d1248 1
a1248 1
  /* only root now is vector; have to declare these next three as roots
d1255 1
d1273 1
a1273 1

d1278 1
a1278 1
    mlval quad = MLHEAD(list);		  /* (position,spills,saves,code) */
d1285 1
d1294 1
a1294 1
    next[1] = make_ancill(saves, spills,leaf,intercept,i);
d1308 1
d1328 1
@


1.31.1.1
log
@branched from 1.31
@
text
@a11 3
 * Revision 1.31  1997/02/10  14:05:01  matthew
 * Reverse bytes in read_real
 *
@


1.31.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 * Revision 1.31.1.1  1997/05/12  10:45:37  hope
 * branched from 1.31
 *
@


1.31.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 * Revision 1.31.1.1  1997/05/12  10:45:37  hope
 * branched from 1.31
 *
@


1.31.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 * Revision 1.31.1.1  1997/05/12  10:45:37  hope
 * branched from 1.31
 *
@


1.31.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 3
 * Revision 1.31.1.1.1.1  1997/07/28  18:26:57  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.30
log
@Fix #1439 - NT: Stack browswer frame hiding doesn't work properly.
Make read_delivered_name work for Win32 i.e. remove the assumption
that files use "/" as separators.
@
text
@d12 5
d463 17
@


1.30.8.1
log
@branched from 1.30
@
text
@a11 5
 * Revision 1.30  1996/06/26  11:40:44  stephenb
 * Fix #1439 - NT: Stack browswer frame hiding doesn't work properly.
 * Make read_delivered_name work for Win32 i.e. remove the assumption
 * that files use "/" as separators.
 *
@


1.30.7.1
log
@branched from 1.30
@
text
@a11 5
 * Revision 1.30  1996/06/26  11:40:44  stephenb
 * Fix #1439 - NT: Stack browswer frame hiding doesn't work properly.
 * Make read_delivered_name work for Win32 i.e. remove the assumption
 * that files use "/" as separators.
 *
@


1.30.7.1.1.1
log
@branched from 1.30.7.1
@
text
@a11 3
 * Revision 1.30.7.1  1996/12/17  17:57:16  hope
 * branched from 1.30
 *
@


1.30.6.1
log
@branched from 1.30
@
text
@a11 5
 * Revision 1.30  1996/06/26  11:40:44  stephenb
 * Fix #1439 - NT: Stack browswer frame hiding doesn't work properly.
 * Make read_delivered_name work for Win32 i.e. remove the assumption
 * that files use "/" as separators.
 *
@


1.30.5.1
log
@branched from 1.30
@
text
@a11 5
 * Revision 1.30  1996/06/26  11:40:44  stephenb
 * Fix #1439 - NT: Stack browswer frame hiding doesn't work properly.
 * Make read_delivered_name work for Win32 i.e. remove the assumption
 * that files use "/" as separators.
 *
@


1.30.4.1
log
@branched from 1.30
@
text
@a11 5
 * Revision 1.30  1996/06/26  11:40:44  stephenb
 * Fix #1439 - NT: Stack browswer frame hiding doesn't work properly.
 * Make read_delivered_name work for Win32 i.e. remove the assumption
 * that files use "/" as separators.
 *
@


1.30.4.1.1.1
log
@branched from 1.30.4.1
@
text
@a11 3
 * Revision 1.30.4.1  1996/11/14  13:01:07  hope
 * branched from 1.30
 *
@


1.30.3.1
log
@branched from 1.30
@
text
@a11 5
 * Revision 1.30  1996/06/26  11:40:44  stephenb
 * Fix #1439 - NT: Stack browswer frame hiding doesn't work properly.
 * Make read_delivered_name work for Win32 i.e. remove the assumption
 * that files use "/" as separators.
 *
@


1.30.2.1
log
@branched from 1.30
@
text
@a11 5
 * Revision 1.30  1996/06/26  11:40:44  stephenb
 * Fix #1439 - NT: Stack browswer frame hiding doesn't work properly.
 * Make read_delivered_name work for Win32 i.e. remove the assumption
 * that files use "/" as separators.
 *
@


1.30.1.1
log
@branched from 1.30
@
text
@a11 5
 * Revision 1.30  1996/06/26  11:40:44  stephenb
 * Fix #1439 - NT: Stack browswer frame hiding doesn't work properly.
 * Make read_delivered_name work for Win32 i.e. remove the assumption
 * that files use "/" as separators.
 *
@


1.29
log
@Delivered images still contain long empty loader_code tables.
@
text
@d12 3
d330 1
d470 2
d503 1
a503 1
    workptr = strstr(start_of_locn+1,"/src/");
d511 1
a511 1
      while (((workptr = strchr(workptr, '/')) != NULL) &&
d534 2
@


1.28
log
@Change to declare_global().
@
text
@d12 3
d381 1
a381 1
		 GLOBAL_DEFAULT, NULL, loader_code_fix, NULL);
@


1.27
log
@Changing ERROR to MLERROR
@
text
@d12 3
d358 1
a358 1
static void loader_code_fix(mlval *root, mlval value)
d377 2
a378 1
  declare_global("loaded code list", &loader_code, loader_code_fix);
@


1.26
log
@Runtime error message buffer problem.
@
text
@d12 3
d624 1
a624 1
    return(ERROR);
d799 1
a799 1
      return(ERROR);
d813 1
a813 1
    return(ERROR);
d835 1
a835 1
      return(ERROR);
d844 1
a844 1
    return(ERROR);
d882 1
a882 1
      if (mt_time == ERROR) {
d958 1
a958 1
	if (read_codeset(codeset_size, objects, stream, version, delivery) == ERROR)
d1003 1
a1003 1
	if(module == ERROR)
d1061 1
a1061 1
  if(time == ERROR) {
d1063 1
a1063 1
    return ERROR;
d1071 1
a1071 1
  if(closure == ERROR)
d1075 1
a1075 1
      return (ERROR);
d1126 1
a1126 1
    return(ERROR);
d1138 1
a1138 1
      return(ERROR);
d1149 1
a1149 1
    return(ERROR);
@


1.25
log
@Strange bug in delivery names.
@
text
@d12 3
d887 7
a893 3
	message("Warning: module '%s' references module '%s' "
		"with incompatible time stamp. Recompilation recommended.",
		CSTRING(*mod_name), CSTRING(require_name));
d927 7
a933 2
  if (verbose)
    message("Loading module `%s'", CSTRING(*mod_name));
@


1.24
log
@Change delivery names to make them recognisable to the debugger.
@
text
@d12 3
d457 1
a457 1
"initial_listener[/home/ml/sml/MLW/src/interpreter/_tty_listener.sml:320,7 to 320,54]" becomes "initial_listener[interpreter._tty_listener:320]"
d462 5
a466 1
"Builtin o of pad argument 1[/nfs/ml/home/ml/sml/MLW/src/sparc/_sparc_assembly.sml:465,23 to 467,25] and decode_load_and_store'[/nfs/ml/home/ml/sml/MLW/src/sparc/_sparc_assembly.sml:474,7 to 483, 38]"
d481 1
a481 1
    /* here's a location string */
d484 1
a484 1
    workptr = strstr(start_of_locn,"/src/");
d486 1
d488 1
a488 2
      start_of_locn[1] = ' ';
      end_of_locn -= (workptr+4-start_of_locn);
@


1.23
log
@Fix problems with C ordering of evaluation of function parameters
interaction with gc and C roots
@
text
@d12 4
d479 2
a480 1
      strcpy (start_of_locn+1,workptr+5);
@


1.22
log
@Postpone loader_code_add() until the code object is complete.
@
text
@d12 3
d946 4
a949 1
	MLUPDATE(objects, offset, read_real(stream));
d960 4
a963 1
	MLUPDATE(objects, offset, read_string(string_size,stream));
d1053 5
a1057 1
      MLUPDATE(modules, 0, mt_add(DEREF(modules), *mod_name_ptr, structure, time));
@


1.21
log
@Make load_module static, as it's only called internally.
@
text
@d12 3
d588 1
d601 1
a601 2
  if(word_align(file_length) != file_length)
  {
d682 2
d685 1
a685 2
  for(i=0; i<nr_procedures; ++i)
  {
d692 1
d728 7
d737 1
d1228 3
d1232 3
a1234 1
    loader_code_add(code); /* This can call gc */
@


1.20
log
@Remove superfluous error causing line
@
text
@d12 3
d744 2
a745 2
mlval load_module(const char *filename, mlval *mod_name,
		  mlval modules, int verbose, int dont_check_cons, int delivery)
@


1.19
log
@Handle unable to access mo files by returning an error which can be
translated into an exception
@
text
@d12 4
a1012 2

    error("The loader was unable to access the file `%s'.", filename);
@


1.18
log
@Use OBJECT_CODE_VERSION to check version of code
@
text
@d12 3
d1005 5
a1009 1
  if(time == ERROR)
@


1.17
log
@Adding ml_observer function
@
text
@d12 3
d805 2
a806 2
  /* This loader can only deal with version 12 and beyond. Versions 6-11 have
   * been rendered unreadable by the new ancillary layout. */
d808 1
a808 1
  if(version < 12)
@


1.16
log
@Change file opening to be rb
@
text
@d12 3
d304 2
a309 1
  retract_root(&code);
d312 3
@


1.15
log
@Change time.h to mltime.h
@
text
@d12 3
d735 1
a735 1
  stream = fopen(filename, "r");
d751 1
a751 1
    stream = fopen(name_with_suffix, "r");
@


1.14
log
@Add instruction cache flushing.
@
text
@d12 3
d279 1
a279 1
#include "time.h"
@


1.13
log
@Changed to be more vigilant about spotting non-aligned code vector total size
@
text
@d12 3
d279 1
d688 1
d1169 1
@


1.12
log
@Added routine read_raw_word which does not attempt to change endian
before returning its result. This is used to determine the endianness
of each mo file. Put this one down to the horrors of imperative programming!
@
text
@d12 5
d546 1
a546 1
static void read_codeset(unsigned int nr_procedures,
d554 1
a554 1
  size_t i, offset, length;
d566 8
a573 1
  length = read_word(stream)/sizeof(word) + 2*nr_procedures + 1;
d697 1
d884 2
a885 1
	read_codeset(codeset_size, objects, stream, version, delivery);
d1048 1
a1048 2
    size_t l = CSTRINGLENGTH(FIELD(quadruple,3));

a1053 1

@


1.11
log
@Control change_endian on the code by machine specific value
@
text
@d12 3
d352 8
d763 1
a763 1
  if(!find_endian(read_word(stream)))
@


1.10
log
@Make incompatible timestamp message a warning (not a diagnostic).
@
text
@d12 3
d267 1
d660 1
a660 1
    change_endian(&next[2], size);
@


1.9
log
@Fix load_wordset to handle object version 14.
@
text
@d12 3
d797 3
a799 3
	DIAGNOSTIC(1, "module '%s' references module '%s' ", CSTRING(*mod_name),
		   CSTRING(require_name));
	DIAGNOSTIC(1, "with incompatible time stamp. Recompilation recommended", 0, 0);
@


1.9.1.1
log
@branched from 1.9
@
text
@a11 3
 * Revision 1.9  1994/07/25  09:49:32  nickh
 * Fix load_wordset to handle object version 14.
 *
@


1.8
log
@Add callee saves to ancillary information
@
text
@d12 3
d977 11
a987 1
 *  From MachTypes:
a988 6
 *  > datatype wordset =
 *  >   WORD_SET of {a_names:string list,
 *  >                b:{a_clos:int, b_spills:int, c_saves:int, d_code:string} list,
 *  >                c_leafs:bool list,
 *  >                d_intercept:int list}
 *
d1015 2
a1016 2
    mlval triple = MLHEAD(list);
    size_t l = CSTRINGLENGTH(FIELD(triple, 2));
a1071 1

d1116 5
a1120 5
    mlval triple = MLHEAD(list);	  /* (position,spills,code) */
    mlval string = FIELD(triple, 3);	  /* the code itself */
    mlval position = FIELD(triple, 0);	  /* the position in the closure */
    word spills = CINT(FIELD(triple,1));  /* the number of non-GC spills */
    word saves = CINT(FIELD(triple,2));   /* the number of callee saves */
d1136 1
a1136 1
    DIAGNOSTIC(3, "         offset 0x%X  spills %u", offset, CINT(FIELD(triple, 1)));
@


1.7
log
@Change to code name delivery, and to printing of diagnostic messages.
@
text
@d12 3
d486 2
a487 1
static inline mlval make_ancill(word spill,
d496 2
a497 2
    error ("Trying to load object code with intercept offset too large : %x",
	   intercept);
d504 1
a504 1
  return CCODE_MAKE_ANCILL(spill,leaf,intercept,code_no);
d619 1
a619 1
    word size, position, spill, leaf;
d630 1
d646 1
a646 1
    next[1] = make_ancill(spill,leaf,intercept,i);
d977 4
a980 4
 *  >   WORD_SET of string list *		(* function names *)
 *  >               (int * int * string) list *	(* closure pos, spills, code *)
 *  >               bool list *			(* leaf flags *)
 *  >               int list			(* intercept offset *)
d1111 1
a1111 1
    mlval string = FIELD(triple, 2);	  /* the code itself */
d1114 1
d1125 1
a1125 1
    next[1] = make_ancill(spills,leaf,intercept,i);
@


1.6
log
@Increase version to 13
@
text
@d12 3
d381 13
d396 2
a397 1
  char *str = (char*)malloc(string_size), *workstr1=str, *workstr2;
d402 4
a405 10
  /* first try to remove most of the pathname:
     "myfun[/foo/bar/baz/boz/src/dir/file.sml:123,45 to 456,65]"
     becomes
     "myfun[dir/file.sml:123,45 to 456,65]"	*/
     
  if ((workstr1 = strchr(str,'[')) != NULL) { /* there's a location string */
    if ((workstr2 = strstr(workstr1,"/src/")) != NULL) {
      /* there's a pathname */
      strcpy (workstr1+1,workstr2+5);
      workstr2 = workstr1++;
d407 18
a424 2
      while ((workstr2 = strchr(workstr2, '/')) != NULL)
	*workstr2 = '.';	/* change remaining slashes to dots */
a425 3
      
    if ((workstr1 = strstr(str,".sml")) != NULL)
      strcpy(workstr1,workstr1+4);      /* remove the .sml */
d427 5
a431 3
    if ((workstr1 = strchr(str,',')) &&
	(workstr2 = strchr(workstr1,']')))
      strcpy(workstr1,workstr2); /* remove ",45 to 456,65]" */
d781 1
a781 1
	fprintf(stderr, "Time stamp failure, mod_name = '%s', require_name = '%s', source_require_name = '%s'\n", CSTRING(*mod_name), CSTRING(require_name), CSTRING(source_require_name));
d794 1
a794 1
	    fprintf(stderr, "mo_time = 0x");
d797 1
a797 1
	      fprintf(stderr, " %x",foo[i]);
d800 1
a800 1
	    fprintf(stderr, "\nrequire_time = 0x");
d803 1
a803 1
	      fprintf(stderr, " %x",foo[i]);
d805 1
a805 1
	    fprintf(stderr, "\nmo_string = ");
d809 1
a809 1
	      fprintf(stderr, "0x%x ", *bar++);
d811 1
a811 1
	    fprintf(stderr, "\n");
d887 1
a887 1
	  fprintf(stderr, "External reference failure, mod_name = '%s', require_name = '%s', source_require_name = '%s'\n", CSTRING(*mod_name), CSTRING(require_name), CSTRING(source_require_name));
@


1.5
log
@Fix interception treatment of loaded wordsets.
@
text
@d12 3
d719 1
a719 1
  /* This loader can only deal with version 12. Versions 6-11 have
d722 1
a722 1
  if(version != 12)
@


1.4
log
@New ancillary structure.
@
text
@d12 3
d1014 2
d1018 1
a1018 1
    interceptible |= CINT(MLHEAD(list));
@


1.3
log
@Bump version number.
@
text
@d12 3
d272 1
a272 1
  CCODEANCUPDATE(code, PROFILES, (mlval)NULL);
d372 1
a372 1
static mlval ignore_string(word string_size, FILE *stream)
d374 31
a404 6
  mlval ml_string = allocate_string(1);
  unsigned int size = word_align(string_size);
  while (size--)
    safe_read(CSTRING(ml_string), 1, 1, stream); /* Ignore the string */
  *(CSTRING(ml_string)) = '\0'; /* Finally set it to be null string */
  return(ml_string);
d449 21
d480 2
d491 1
a491 1
  mlval names, spills, profiles, intercepts, leafs, interfns;
d500 3
a502 1
  /* Create the ancillary */
d504 1
a504 9
  spills = allocate_array(nr_procedures);
  for (i=0; i<nr_procedures; ++i)
    MLUPDATE(spills, i, MLUNIT);
  declare_root(&spills);

  names = allocate_array(nr_procedures);
  for (i=0; i<nr_procedures; ++i)
    MLUPDATE(names, i, MLUNIT);
  declare_root(&names);
d506 2
a507 4
  profiles = allocate_array(nr_procedures);
  for (i=0; i < nr_procedures; i++)
    MLUPDATE(profiles, i, MLUNIT);
  declare_root(&profiles);
d509 32
a540 4
  intercepts = allocate_array(nr_procedures);
  for(i=0; i<nr_procedures; ++i)
    MLUPDATE(intercepts, i, MLINT(0));
  declare_root(&intercepts);
d542 4
a545 4
  leafs = allocate_array(nr_procedures);
  for(i=0; i<nr_procedures; ++i)
    MLUPDATE(leafs, i, MLFALSE);
  declare_root(&leafs);
d547 2
a548 4
  interfns = allocate_array(nr_procedures);
  for(i=0; i<nr_procedures; ++i)
    MLUPDATE(interfns, i, MLUNIT);
  declare_root(&interfns);
d550 13
a562 8
  ancillary = allocate_array(ANCILLARY_SIZE);
  MLUPDATE(ancillary, ANC_SPILLS, spills);
  MLUPDATE(ancillary, ANC_NAMES, names);
  MLUPDATE(ancillary, ANC_PROFILES, profiles);
  MLUPDATE(ancillary, ANC_LEAFS, leafs);
  MLUPDATE(ancillary, ANC_INTERCEPTS, intercepts);
  MLUPDATE(ancillary, ANC_INTERFNS, interfns);
  declare_root(&ancillary);
d564 2
a565 3
  /* Read and calculate the length of code vector required.  This is one */
  /* word for each instruction, plus two words per code item for the item */
  /* header, plus one words for the ancillary pointer. */
d567 3
a569 1
  length = read_word(stream)/sizeof(word) + 2*nr_procedures + 1;
d574 1
d583 3
a585 2
    word size, position;
    mlval code, name, spill, leaf, intercept;
d590 1
a590 1
    /* Read the ancillary information: the name, number of non-GC spills, */
d593 4
a596 11
    size = read_word(stream);
    name = (delivery) ? ignore_string(size, stream) : read_string(size, stream);
    MLUPDATE(names, i, name);

    spill = MLINT(read_word(stream));
    MLUPDATE(spills, i, spill);
    leaf = read_word(stream) ? MLTRUE : MLFALSE;
    MLUPDATE(leafs, i, leaf);
    intercept = MLINT(read_word(stream));
    MLUPDATE(intercepts, i, intercept);

d608 2
a609 2
    /* Insert the code vector number: CCODENUMBER(code) = i; */
    next[1] = i; 
a617 1
    DIAGNOSTIC(3, "       name `%s'", CSTRING(name), 0);
d619 2
a620 2
    DIAGNOSTIC(3, "       non-GC spills %u  %sleaf", CINT(spill), leaf == MLTRUE ? "" : "non-");
    DIAGNOSTIC(3, "       intercept offset %d", CINT(intercept), 0);
a625 7
  retract_root(&profiles);
  retract_root(&names);
  retract_root(&interfns);
  retract_root(&spills);
  retract_root(&intercepts);
  retract_root(&leafs);
  retract_root(&ancillary);
d639 1
d713 2
a714 8
  /* Versions 6, 7 & 8 & 9, 10 are the only versions that this loader can
   * cope with. 6, 7 & 8 & 9 differ only in the encapsulation of
   * type information, which doesn't affect the loader.
   * Version 10 has new consistency information, with records of the form
   * {mod_name, req_name, time}, stored in that order.
   * Version 11 differs from version 10 only in the encapsulation of
   * type information, which doesn't affect the loader.
   */
d716 1
a716 1
  if(version < 6 || version > 11)
d725 3
a727 4
  if (version > 9) {
    i = read_opt_int(stream); /* req_name size */
    source_require_name = ignore_unaligned_string(i, stream);
  };
d736 4
a739 4
    if (version > 9) {
      i = read_opt_int(stream); /* req_name size */
      source_require_name = ignore_unaligned_string(i, stream);
    };
d891 5
d953 1
a953 1
  size_t length = 0;
a954 1
  size_t offset;
d957 1
a957 1
  mlval names, spills, ancillary, profiles, intercepts, leafs, interfns;
d996 3
a998 9
  /* Create the ancillary of the code vector. */

  spills = allocate_array(nr_procedures);
  for(i=0, list=FIELD(wordset, 1); i<nr_procedures; ++i, list=MLTAIL(list))
    MLUPDATE(spills, i, FIELD(MLHEAD(list), 1));
  declare_root(&spills);

  names = allocate_array(nr_procedures);
  DIAGNOSTIC(3, "  function names array 0x%X:", names, 0);
d1001 1
a1001 1
    MLUPDATE(names, i, MLHEAD(list));
d1004 1
a1004 1
  declare_root(&names);
d1006 4
a1009 4
  profiles = allocate_array(nr_procedures);
  for (i=0; i<nr_procedures; ++i)
    MLUPDATE(profiles, i, MLUNIT);
  declare_root(&profiles);
d1011 22
a1032 4
  intercepts = allocate_array(nr_procedures);
  for(i=0; i<nr_procedures; ++i)
    MLUPDATE(intercepts, i, 0);
  declare_root(&intercepts);
d1034 2
a1035 5
  for(list=FIELD(wordset, 3), i=0; list!=MLNIL; list=MLTAIL(list), ++i)
  {
    DIAGNOSTIC(3, "    %3d: intercept offset 0x%X", i, MLHEAD(list));
    MLUPDATE(intercepts, i, MLHEAD(list));
  }
d1037 2
a1038 4
  leafs = allocate_array(nr_procedures);
  for(i=0; i<nr_procedures; ++i)
    MLUPDATE(leafs, i, MLFALSE);
  declare_root(&leafs);
d1040 1
a1040 5
  for(list=FIELD(wordset, 2), i=0; list!=MLNIL; list=MLTAIL(list), ++i)
  {
    DIAGNOSTIC(3, "    %3d: %sleaf", i, MLHEAD(list)==MLTRUE ? "" : "non-");
    MLUPDATE(leafs, i, MLHEAD(list));
  }
d1042 3
a1044 4
  interfns = allocate_array(nr_procedures);
  for(i=0; i<nr_procedures; ++i)
    MLUPDATE(interfns, i, MLFALSE);
  declare_root(&interfns);
d1046 3
a1048 1
  ancillary = allocate_array(ANCILLARY_SIZE);
d1050 1
a1050 11
  retract_root(&names);
  retract_root(&profiles);
  retract_root(&interfns);
  retract_root(&spills);
  MLUPDATE(ancillary, ANC_SPILLS, spills);
  MLUPDATE(ancillary, ANC_NAMES, names);
  MLUPDATE(ancillary, ANC_PROFILES, profiles);
  MLUPDATE(ancillary, ANC_LEAFS, leafs);
  MLUPDATE(ancillary, ANC_INTERCEPTS, intercepts);
  MLUPDATE(ancillary, ANC_INTERFNS, interfns);
  declare_root(&ancillary);
d1052 1
a1052 1
  /* Create the code vector and initialize the ancillary. */
d1054 1
a1054 3
  vector = allocate_code(length+1);
  CCVANCILLARY(vector) = ancillary;
  retract_root(&ancillary);
a1055 3
  declare_root(&vector);
  declare_root(&list);
  declare_root(&result);
d1060 2
d1063 7
a1069 1
  for(list=FIELD(wordset, 1), i=0; list!=MLNIL; list=MLTAIL(list), ++i)
d1071 9
a1079 4
    mlval triple = MLHEAD(list), string = FIELD(triple, 2), pair;
    size_t length = CSTRINGLENGTH(string);
    mlval position = FIELD(triple, 0);
    mlval *next = (mlval *)OBJECT(vector) + offset;
d1083 1
a1083 2
    if(offset > 0)
      next[0] = MAKEHEAD(BACKPTR, offset * sizeof(mlval));
d1085 1
a1085 1
    next[1] = i;
d1092 2
d1095 5
d1109 4
a1113 1
  retract_root(&list);
a1114 4
  retract_root(&vector);
  retract_root(&intercepts);
  retract_root(&leafs);
  retract_root(&wordset);
@


1.2
log
@new file
@
text
@d12 3
d655 2
d659 1
a659 1
  if(version < 6 || version > 10)
@


1.1
log
@new file
@
text
@d11 4
a14 1
 *  $Log: loader.c,v $
@
