head	1.62;
access;
symbols
	Final_version_of_old_runtime:1.62
	ML_revised_beta_release_25/05/94:1.62
	ML_final_beta_release_02/03/94:1.59
	mlworks-28-01-1994:1.58
	Release:1.53
	mlworks-beta-01-09-1993:1.53
	MLWorks-1-0-3-21/12/1992:1.38
	MLWorks-1-0-2-15/12/1992:1.38
	MLWorks-1-0-1-04/12/1992:1.38
	checkpoint_17_08_92:1.36;
locks; strict;
comment	@ *  @;


1.62
date	94.05.13.18.12.01;	author daveb;	state Exp;
branches;
next	1.61;

1.61
date	94.04.08.15.53.55;	author jont;	state Exp;
branches;
next	1.60;

1.60
date	94.03.14.16.17.09;	author jont;	state Exp;
branches;
next	1.59;

1.59
date	94.01.28.17.23.00;	author nickh;	state Exp;
branches;
next	1.58;

1.58
date	94.01.10.13.43.20;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	93.12.22.11.37.32;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	93.12.07.12.19.58;	author daveb;	state Exp;
branches;
next	1.55;

1.55
date	93.12.01.12.49.54;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	93.11.24.10.13.03;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	93.08.27.19.22.11;	author daveb;	state Exp;
branches
	1.53.1.1;
next	1.52;

1.52
date	93.08.26.17.36.58;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	93.08.12.11.24.32;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	93.08.06.17.13.02;	author richard;	state Exp;
branches;
next	1.49;

1.49
date	93.06.18.08.52.33;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	93.05.27.15.10.27;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	93.05.18.10.46.28;	author richard;	state Exp;
branches;
next	1.46;

1.46
date	93.05.10.15.43.37;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	93.04.15.13.37.46;	author richard;	state Exp;
branches;
next	1.44;

1.44
date	93.03.18.11.56.57;	author jont;	state Exp;
branches;
next	1.43;

1.43
date	93.03.11.18.17.58;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	93.02.12.16.36.07;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	93.02.01.14.47.24;	author richard;	state Exp;
branches;
next	1.40;

1.40
date	93.01.15.10.25.53;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	93.01.05.13.48.04;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	92.08.25.13.27.25;	author richard;	state Exp;
branches;
next	1.37;

1.37
date	92.08.18.11.19.17;	author richard;	state Exp;
branches;
next	1.36;

1.36
date	92.08.13.18.47.57;	author davidt;	state Exp;
branches;
next	1.35;

1.35
date	92.08.07.10.42.26;	author richard;	state Exp;
branches;
next	1.34;

1.34
date	92.08.07.08.46.13;	author richard;	state Exp;
branches;
next	1.33;

1.33
date	92.08.05.17.22.41;	author richard;	state Exp;
branches;
next	1.32;

1.32
date	92.08.04.15.01.27;	author richard;	state Exp;
branches;
next	1.31;

1.31
date	92.07.29.14.22.41;	author richard;	state Exp;
branches;
next	1.30;

1.30
date	92.07.27.13.00.27;	author richard;	state Exp;
branches;
next	1.29;

1.29
date	92.07.20.12.24.38;	author richard;	state Exp;
branches;
next	1.28;

1.28
date	92.07.15.17.24.28;	author richard;	state Exp;
branches;
next	1.27;

1.27
date	92.07.14.09.21.17;	author richard;	state Exp;
branches;
next	1.26;

1.26
date	92.07.02.09.12.42;	author richard;	state Exp;
branches;
next	1.25;

1.25
date	92.07.01.13.47.45;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	92.06.11.09.56.58;	author clive;	state Exp;
branches;
next	1.23;

1.23
date	92.05.12.19.45.54;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.05.05.09.54.01;	author clive;	state Exp;
branches;
next	1.21;

1.21
date	92.04.14.11.59.48;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.03.20.15.49.05;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	92.03.20.14.46.26;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	92.03.17.17.26.35;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	92.02.13.16.13.57;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.01.14.13.32.03;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.01.09.16.23.52;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	91.12.23.13.18.42;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	91.12.20.17.07.39;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	91.12.17.16.47.40;	author nickh;	state Exp;
branches;
next	1.11;

1.11
date	91.12.17.16.35.41;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	91.11.11.18.00.57;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.10.24.16.17.04;	author davidt;	state Exp;
branches;
next	1.8;

1.8
date	91.10.23.16.46.51;	author davidt;	state Exp;
branches;
next	1.7;

1.7
date	91.10.21.11.35.40;	author davidt;	state Exp;
branches;
next	1.6;

1.6
date	91.10.18.16.10.31;	author davidt;	state Exp;
branches;
next	1.5;

1.5
date	91.10.17.16.58.47;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	91.10.16.14.04.42;	author davidt;	state Exp;
branches;
next	1.3;

1.3
date	91.05.17.17.11.09;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.05.15.15.32.14;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.05.14.11.11.27;	author jont;	state Exp;
branches;
next	;

1.53.1.1
date	93.08.27.19.22.11;	author jont;	state Exp;
branches;
next	;


desc
@ The module loader
@


1.62
log
@Object file version has increased.
@
text
@/*  ==== MODULE LOADER ====
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  Needs documenting.
 *
 *  Revision Log
 *  ------------
 *  $Log: loader.c,v $
 *  Revision 1.61  1994/04/08  15:53:55  jont
 *  Add original require file names to consistency info.
 *
 *  Revision 1.60  1994/03/14  16:17:09  jont
 *  Fixed such that when timestamp tests find module missing, the same
 *  error is produced as if the time stamps weren't being done. In
 *  particular, errno is now set in this case.
 *
 *  Revision 1.59  1994/01/28  17:23:00  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.58  1994/01/10  13:43:20  matthew
 *  Added function internal_load_link for use by image builder and by the ml mo loader.
 *
 *  Revision 1.57  1993/12/22  11:37:32  jont
 *  Added delivery option which discards code vector names
 *
 *  Revision 1.56  1993/12/07  12:19:58  daveb
 *  Checked return value of mt_lookup_time.
 *
 *  Revision 1.55  1993/12/01  12:49:54  matthew
 *  Made it understand version 9 too.  There must be a better way of doing this!
 *
 *  Revision 1.54  1993/11/24  10:13:03  jont
 *  Changed to allow detection of inconsistent mo sets
 *
 *  Revision 1.53  1993/08/27  19:22:11  daveb
 *  Bug in read_opt_int (I wrote << instead of <<=).
 *
 *  Revision 1.52  1993/08/26  17:36:58  daveb
 *  load_module sets the module name from the consistency information in the
 *  file.
 *
 *  Revision 1.51  1993/08/12  11:24:32  daveb
 *  mt_lookup takes an extra argument.
 *
 *  Revision 1.50  1993/08/06  17:13:02  richard
 *  Increased the level of a diagnostic.
 *
 *  Revision 1.49  1993/06/18  08:52:33  daveb
 *  New object file format.  Runtime is compatible with old version.
 *
 *  Revision 1.48  1993/05/27  15:10:27  jont
 *  New version cos encapsulator has changed
 *
 *  Revision 1.47  1993/05/18  10:46:28  richard
 *  Changed the layout of code vectors in the encapsulator in order to
 *  reduce the amount of root juggling that would have been necessary
 *  to correct a bug calling the loader code observer.
 *
 *  Revision 1.46  1993/05/10  15:43:37  jont
 *  Fixed problem with superfluous mlupdate(spills, ...) outside scope
 *  of declare/retract. Removed superfluous reallocation of code vector.
 *  Added declare/retract round call to weak_add in loader_code_add
 *
 *  Revision 1.45  1993/04/15  13:37:46  richard
 *  All ancillary slots are now loaded.
 *
 *  Revision 1.44  1993/03/18  11:56:57  jont
 *  New version to account for code changes for leaf and intercept offset
 *
 *  Revision 1.43  1993/03/11  18:17:58  jont
 *  Moved ANCILLARY_SLOT_SIZE into values.h
 *
 *  Revision 1.42  1993/02/12  16:36:07  jont
 *  Changes for code vector reform
 *
 *  Revision 1.41  1993/02/01  14:47:24  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.40  1993/01/15  10:25:53  daveb
 *  Changed runtime_version to object_file_version.
 *
 *  Revision 1.39  1993/01/05  13:48:04  daveb
 *  Added version parameter to load_wordset.  Changed current version to 3,
 *  which has the new representation of lists.
 *
 *  Revision 1.38  1992/08/25  13:27:25  richard
 *  Changed the action when the loader finds a wrongly sized real
 *  number.  It now exits with an error code.
 *
 *  Revision 1.37  1992/08/18  11:19:17  richard
 *  Added missing root declarations.  (Oops)
 *
 *  Revision 1.36  1992/08/13  18:47:57  davidt
 *  Small change to the object file format.
 *
 *  Revision 1.35  1992/08/07  10:42:26  richard
 *  Implemented load_wordset.
 *
 *  Revision 1.34  1992/08/07  08:46:13  richard
 *  The loader keeps track of code vectors (again) but an observer
 *  function can be declared from any profiler.  This gives more
 *  flexibility for use by the memory auditer.
 *
 *  Revision 1.33  1992/08/05  17:22:41  richard
 *  Removed incorrect load_wordset() temporarily.
 *  Code vectors are now tagged differently to strings.
 *
 *  Revision 1.32  1992/08/04  15:01:27  richard
 *  Changed read_wordset to cope with a garbage collection caused by
 *  profile_new().
 *
 *  Revision 1.31  1992/07/29  14:22:41  richard
 *  The profiler, rather than the loader, maintains a list of code vectors.
 *
 *  Revision 1.30  1992/07/27  13:00:27  richard
 *  Changed delcare_code_vector() to declare_code(), exported it, and
 *  increased the size of the arrays it uses.
 *
 *  Revision 1.29  1992/07/20  12:24:38  richard
 *  Removed redundant include of "gc.h".
 *
 *  Revision 1.28  1992/07/15  17:24:28  richard
 *  Added load_wordset().
 *
 *  Revision 1.27  1992/07/14  09:21:17  richard
 *  Implemented load_code_vectors, and changed the way the loader
 *  interacts with the profiler.
 *
 *  Revision 1.26  1992/07/02  09:12:42  richard
 *  Returns ERROR to indicate error rather than IMPOSSIBLE.
 *
 *  Revision 1.25  1992/07/01  13:47:45  richard
 *  Changed module table types.  See modules.h.
 *
 *  Revision 1.24  1992/06/11  09:56:58  clive
 *  Fixes for the profiler
 *
 *  Revision 1.23  1992/05/12  19:45:54  jont
 *  Allowed comprehension of version 2, created when the magic number was
 *
 *  Revision 1.22  1992/05/05  09:54:01  clive
 *  Function called by value of ml_vector needs to declare it
 *
 *  Revision 1.21  1992/04/14  11:59:48  clive
 *  First version of the profiler
 *
 *  Revision 1.20  1992/03/20  15:49:05  richard
 *  Corrected calculatio of backpointers.
 *
 *  Revision 1.19  1992/03/20  14:46:26  richard
 *  New module format.  Added code to deal with different module versions.
 *
 *  Revision 1.18  1992/03/17  17:26:35  richard
 *  Changed error behaviour and parameterised the module table.
 *
 *  Revision 1.17  1992/02/13  16:13:57  clive
 *  Never closed any files - it does now
 *
 *  Revision 1.16  1992/01/14  13:32:03  richard
 *  Changed the call of callml to pass the closure rather than the ml_vector
 *
 *  Revision 1.15  1992/01/09  16:23:52  richard
 *  Fixed an error in the loading of codesets.
 *
 *  Revision 1.14  1991/12/23  13:18:42  richard
 *  Changed the name of the fatal runtime error handler to error().
 *
 *  Revision 1.13  91/12/20  17:07:39  richard
 *  Rewrote read_codeset so that it works.  Changed diagnostic output to be
 *  switchable.
 *  
 *  Revision 1.12  91/12/17  16:47:40  nickh
 *  add in_ML flag.
 *  
 *  Revision 1.11  91/12/17  16:35:41  richard
 *  Added code to add suffices to module names.  Restricted the sizes
 *  of reals to doubles only.
 *  
 *  Revision 1.10  91/11/11  18:00:57  jont
 *  Added read_real. Modified read_string to put the actual string length
 *  into the header word, as opposed to the padded length
 *  
 *  Revision 1.9  91/10/24  16:17:04  davidt
 *  Changed name of callml.h to interface.h
 *  
 *  Revision 1.8  91/10/23  16:46:51  davidt
 *  Fixed size put into backpointers in codesets to be in bytes as required.
 *  
 *  Revision 1.7  91/10/21  11:35:40  davidt
 *  Made some minor changes and finished implementation of read_codeset.
 *  read_codeset now reads each individual function in using one big
 *  read and also puts in the separating backpointers between functions
 *  in the same codeset.
 *  
 *  Revision 1.6  91/10/18  16:10:31  davidt
 *  Actually calls ML now! loader_error now takes three arguments.
 *  Strings now have a word_aligned size.
 *  
 *  Revision 1.5  91/10/17  16:58:47  davidt
 *  Big hacks all over the place which have nearly got the thing loading
 *  object files properly. Codesets are done properly yet.
 *  
 *  Revision 1.4  91/10/16  14:04:42  davidt
 *  Major revision after change to object file format (not quite
 *  finished yet).
 *  
 *  Revision 1.3  91/05/17  17:11:09  jont
 *  Reals allocated as strings
 *  
 *  Revision 1.2  91/05/15  15:32:14  jont
 *  Revised interface for second version of load format
 *  
 *  Revision 1.1  91/05/14  11:11:27  jont
 *  Initial revision
 */

#include "ansi.h"
#include "syscalls.h"
#include "mltypes.h"
#include "values.h"
#include "loader.h"
#include "objectfile.h"
#include "allocator.h"
#include "interface.h"
#include "endian.h"
#include "modules.h"
#include "diagnostic.h"
#include "utils.h"
#include "global.h"
#include "pervasives.h"
#include "options.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
#include <errno.h>
#include <memory.h>
#include <sys/stat.h>
#include <sys/types.h>

#include "pervasive/time.h"

/*  == Loaded code vector list ==  */

mlval loader_code;
void (*loader_code_observer)(mlval code) = NULL;

static void loader_code_add(mlval code)
{
  declare_root(&code);
  loader_code = weak_add(loader_code, code); /* This may call gc, hence declare */
  retract_root(&code);
  if(loader_code_observer != NULL)
    loader_code_observer(code);
}

static mlval disable(unsigned int index, mlval code)
{
  CCODEANCUPDATE(code, PROFILES, (mlval)NULL);
  return(code);
}

static void loader_code_fix(mlval *root, mlval value)
{
  weak_apply(value, disable);
  *root = value;
}



/*  === INITIALISE LOADER ===
 *
 *  This functions declares external ML values as roots.
 */

mlval load_external = MLUNIT;

void load_init(void)
{
  declare_root(&load_external);
  loader_code = weak_new(256);
  declare_global("loaded code list", &loader_code, loader_code_fix);
}



/*  == Bulletproof object file reading functions ==
 *
 *  These functions read data from a stream and cause a non-local jump to
 *  `problem' if an error occurs.
 *
 *  NOTE: I'm not sure that the endian changing code is necessary or
 *  correct.
 */

static jmp_buf problem;

static void safe_read(void *whither, size_t size, size_t number, FILE *stream)
{
  if(fread(whither, size, number, stream) != number)
    longjmp(problem, feof(stream) ? ELOADFORMAT : ELOADREAD);
}

int safe_read_byte(FILE *stream)
{
  int c;

  c = getc(stream);
  if (c == -1)
    longjmp(problem, feof(stream) ? ELOADFORMAT : ELOADREAD);
  return c;
}

static word read_word(FILE *stream)
{
  word w;

  fread(&w, sizeof(word), 1, stream);
  change_endian(&w, 1);
  return(w);
}

static word read_opt_int(FILE *stream)
{
  unsigned char c;
  word w;

  c = safe_read_byte(stream);
  if (c == 255)
    w = read_word(stream);
  else if (c == 254) {
    w = (word)safe_read_byte(stream);
    w <<= 8;
    w += (word)safe_read_byte(stream);
  }
  else
    w = (word)c;
  return w;
}

static mlval read_real(FILE *stream)
{
  double the_real;

  mlval ml_real = allocate_real();
  safe_read(&the_real, sizeof(double), 1, stream);
  (void)SETREAL(ml_real, the_real);
  return(ml_real);
}

static mlval read_string(word string_size, FILE *stream)
{
  mlval ml_string = allocate_string(string_size);

  safe_read(CSTRING(ml_string), word_align(string_size), 1, stream);
  return(ml_string);
}

static mlval ignore_string(word string_size, FILE *stream)
{
  mlval ml_string = allocate_string(1);
  unsigned int size = word_align(string_size);
  while (size--)
    safe_read(CSTRING(ml_string), 1, 1, stream); /* Ignore the string */
  *(CSTRING(ml_string)) = '\0'; /* Finally set it to be null string */
  return(ml_string);
}

static mlval ignore_unaligned_string(word string_size, FILE *stream)
{
  mlval ml_string = allocate_string(1);
  while (string_size--)
    safe_read(CSTRING(ml_string), 1, 1, stream); /* Ignore the string */
  *(CSTRING(ml_string)) = '\0'; /* Finally set it to be null string */
  return(ml_string);
}

static mlval read_unaligned_string(word string_size, FILE *stream)
{
  mlval ml_string = allocate_string(string_size);

  safe_read(CSTRING(ml_string), string_size, 1, stream);
  return(ml_string);
}

static int read_cons_size(FILE *stream)
{
  word list_size;

  fseek(stream, HEADER_SIZE, 0);
  list_size = read_opt_int(stream);
  DIAGNOSTIC(3, "             stream = 0x%X, cons_size = %u)", stream, list_size);
  return list_size;
}

static mlval read_name(FILE *stream)
{
  mlval name;
  word string_size;
  
/*
  fseek(stream, HEADER_SIZE+1, 0);
*/
  string_size = read_opt_int(stream);
  name = allocate_string(string_size + 1);
  safe_read(CSTRING(name), string_size, 1, stream);
  CSTRING(name)[string_size] = '\0';
  return name;
}


/*  == Load codeset ==
 *
 *  A codeset is a set of procedures which are allocated in the same
 *  code vector.  The procedures have back-pointers to the start of the
 *  string between them so that the garbage collector knows what to do
 *  with them.  The code sizes in the input file do not take account
 *  of the back pointers, and so these are inserted here.
 *
 *  The start address of each procedure is inserted into the array objects.
 */

static void read_codeset(word nr_procedures,
			 mlval objects,
			 FILE *stream,
			 int version,
			 int delivery)
{
  mlval vector, ancillary, *next;
  mlval names, spills, profiles, intercepts, leafs, interfns;
  size_t i, offset, length;

  DIAGNOSTIC(3, "read_codeset(nr_procedures = %u, objects = 0x%X",
	        nr_procedures, objects);
  DIAGNOSTIC(3, "             stream = 0x%X, version = %d)", stream, version);

  declare_root(&objects);

  /* Create the ancillary */

  spills = allocate_array(nr_procedures);
  for (i=0; i<nr_procedures; ++i)
    MLUPDATE(spills, i, MLUNIT);
  declare_root(&spills);

  names = allocate_array(nr_procedures);
  for (i=0; i<nr_procedures; ++i)
    MLUPDATE(names, i, MLUNIT);
  declare_root(&names);

  profiles = allocate_array(nr_procedures);
  for (i=0; i < nr_procedures; i++)
    MLUPDATE(profiles, i, MLUNIT);
  declare_root(&profiles);

  intercepts = allocate_array(nr_procedures);
  for(i=0; i<nr_procedures; ++i)
    MLUPDATE(intercepts, i, MLINT(0));
  declare_root(&intercepts);

  leafs = allocate_array(nr_procedures);
  for(i=0; i<nr_procedures; ++i)
    MLUPDATE(leafs, i, MLFALSE);
  declare_root(&leafs);

  interfns = allocate_array(nr_procedures);
  for(i=0; i<nr_procedures; ++i)
    MLUPDATE(interfns, i, MLUNIT);
  declare_root(&interfns);

  ancillary = allocate_array(ANCILLARY_SIZE);
  MLUPDATE(ancillary, ANC_SPILLS, spills);
  MLUPDATE(ancillary, ANC_NAMES, names);
  MLUPDATE(ancillary, ANC_PROFILES, profiles);
  MLUPDATE(ancillary, ANC_LEAFS, leafs);
  MLUPDATE(ancillary, ANC_INTERCEPTS, intercepts);
  MLUPDATE(ancillary, ANC_INTERFNS, interfns);
  declare_root(&ancillary);

  /* Read and calculate the length of code vector required.  This is one */
  /* word for each instruction, plus two words per code item for the item */
  /* header, plus one words for the ancillary pointer. */

  length = read_word(stream)/sizeof(word) + 2*nr_procedures + 1;

  vector = allocate_code(length);
  CCVANCILLARY(vector) = ancillary;
  declare_root(&vector);

  /* Read the code items */

  DIAGNOSTIC(3, "code vector 0x%X of %d items", vector, nr_procedures);

  offset = 2;
  for(i=0; i<nr_procedures; ++i)
  {
    word size, position;
    mlval code, name, spill, leaf, intercept;

    /* Read the position in the closure */
    position = read_word(stream);

    /* Read the ancillary information: the name, number of non-GC spills, */
    /* the leaf flag, and the intercept offset */

    size = read_word(stream);
    name = (delivery) ? ignore_string(size, stream) : read_string(size, stream);
    MLUPDATE(names, i, name);

    spill = MLINT(read_word(stream));
    MLUPDATE(spills, i, spill);
    leaf = read_word(stream) ? MLTRUE : MLFALSE;
    MLUPDATE(leafs, i, leaf);
    intercept = MLINT(read_word(stream));
    MLUPDATE(intercepts, i, intercept);

    /* Now insert the actual code into the vector */

    next = (mlval *)OBJECT(vector) + offset;
    code = MLPTR(POINTER, next);

    /* Insert a BACKPTR to the real header. */
    *next = MAKEHEAD(BACKPTR, offset * sizeof(mlval));

    /* Insert the code pointer into the closure */
    MLUPDATE(objects, position, code);

    /* Insert the code vector number: CCODENUMBER(code) = i; */
    next[1] = i; 

    size = read_word(stream);
    safe_read(&next[2], size, 1, stream);
    change_endian(&next[2], size);

    offset += double_align(size + 2*sizeof(mlval))/sizeof(mlval);

    DIAGNOSTIC(3, "  %3u: 0x%X", i, code);
    DIAGNOSTIC(3, "       name `%s'", CSTRING(name), 0);
    DIAGNOSTIC(3, "       position %u  length 0x%X bytes", position, size);
    DIAGNOSTIC(3, "       non-GC spills %u  %sleaf", CINT(spill), leaf == MLTRUE ? "" : "non-");
    DIAGNOSTIC(3, "       intercept offset %d", CINT(intercept), 0);

    loader_code_add(code);	/* this could cause a GC */
  }

  retract_root(&vector);
  retract_root(&profiles);
  retract_root(&names);
  retract_root(&interfns);
  retract_root(&spills);
  retract_root(&intercepts);
  retract_root(&leafs);
  retract_root(&ancillary);
  retract_root(&objects);
}



/*  === LOAD AN ML MODULE ===
 *
 *  Loading a module consists of reading ML objects from the module file and
 *  putting them in an ML record which record becomes the closure of the
 *  setup function for the module.
 *
 * This also checks the consistency of the loading if required.
 *
 */

mlval load_module(const char *filename, mlval *mod_name,
		  mlval modules, int verbose, int dont_check_cons, int delivery)
{
  word i, opcode, module_size, table_size, version, code_offset;
  mlval objects = MLUNIT, closure, source_time, mo_time = MLUNIT;
  mlval require_name = MLUNIT, mo_string = MLUNIT, source_require_name = MLUNIT;
  FILE *volatile stream;
  int length, cons_size;

  /* Attempt to open object file with the given name.  If that fails */
  /* and the name doesn't end in `.mo', try adding that. */
  stream = fopen(filename, "r");

  if(stream == NULL &&
     strcmp(filename + (length = strlen(filename)) - 3, ".mo"))
  {
    char *name_with_suffix = (char *)malloc(length + 3 + 1);

    if(name_with_suffix == NULL)
    {
      errno = ELOADALLOC;
      return(ERROR);
    }

    strcpy(name_with_suffix, filename);
    strcpy(name_with_suffix + length, ".mo");

    stream = fopen(name_with_suffix, "r");

    free(name_with_suffix);
  }

  if(stream == NULL)
  {
    errno = ELOADOPEN;
    return(ERROR);
  }

  declare_root(&modules);
  declare_root(&objects);
  declare_root(&mo_time);
  declare_root(&require_name);
  declare_root(&mo_string);

  /* Set up an error handler for the reading functions.  See read() above. */
  {
    int code = setjmp(problem);

    if(code != 0)
    {
      errno = code;
      retract_root(&modules);
      retract_root(&objects);
      retract_root(&mo_string);
      retract_root(&require_name);
      retract_root(&mo_time);
      fclose(stream);
      return(ERROR);
    }
  }

  /* Find endianess of object file, check the version number and code */
  /* size, and seek to the start of the code. */
  if(!find_endian(read_word(stream)))
  {
    errno = ELOADFORMAT;
    return(ERROR);
  }

  version = read_word(stream);

  /* Versions 6, 7 & 8 & 9, 10, 11 are the only versions that this loader can
   * cope with. 6, 7 & 8 & 9 differ only in the encapsulation of
   * type information, which doesn't affect the loader.
   * Version 10 has new consistency information, with records of the form
   * {mod_name, req_name, time}, stored in that order.
   * Version 11 differs from version 10 only in the encapsulation of
   * type information, which doesn't affect the loader.
   */

  if(version < 6 || version > 11)
    longjmp(problem, ELOADVERSION);

  /* Get code offset */

  code_offset = read_word(stream);
  cons_size = read_cons_size(stream);

  *mod_name = read_name(stream);
  if (version > 9) {
    i = read_opt_int(stream); /* req_name size */
    source_require_name = ignore_unaligned_string(i, stream);
  };
  i = read_opt_int(stream); /* Time stamp size */
  source_time = time_decode(read_unaligned_string(i, stream));
  /* This is the first item of the consistency information */
  /* We don't care about the time here */

  while (--cons_size > 0) {
    /* Check the other time stamps */
    require_name = read_name(stream);
    if (version > 9) {
      i = read_opt_int(stream); /* req_name size */
      source_require_name = ignore_unaligned_string(i, stream);
    };
    i = read_opt_int(stream); /* Time stamp size */
    DIAGNOSTIC (4, "Reading mo_string of length %u\n", i,0);
    mo_string = read_unaligned_string(i, stream);
    mo_time = time_decode(mo_string);
    if (!dont_check_cons) {
      mlval mt_time = mt_lookup_time(modules, require_name, *mod_name);
      if (mt_time == ERROR) {
	load_external = require_name;
/*
	fprintf(stderr, "Time stamp failure, mod_name = '%s', require_name = '%s', source_require_name = '%s'\n", CSTRING(*mod_name), CSTRING(require_name), CSTRING(source_require_name));
*/
	longjmp(problem, ELOADEXTERNAL);
      }
      if (memcmp(CPTR(mo_time), CPTR(mt_time), 4*sizeof(mlval)) != 0) {
	DIAGNOSTIC(1, "module '%s' references module '%s' ", CSTRING(*mod_name),
		   CSTRING(require_name));
	DIAGNOSTIC(1, "with incompatible time stamp. Recompilation recommended", 0, 0);
#ifdef DIAGNOSTICS
	if (4 <= diagnostic_level) {
	    unsigned int *foo = (unsigned int *)(((int)mo_time)-1);
	    char * bar;
	    int len;
	    fprintf(stderr, "mo_time = 0x%x %x %x %x\n", foo[0], foo[1], foo[2], foo[3]);
	    foo = (unsigned int *)((int)(mt_lookup_time(modules, require_name, *mod_name))-1);
	    fprintf(stderr, "require_time = 0x%x %x %x %x\n", foo[0], foo[1], foo[2], foo[3]);
	    bar = CSTRING(mo_string);
	    fprintf(stderr, "mo_string = ");
	    len = *((int *)(bar-4));
	    len >>= 6;
	    while (len-- > 0) {
	      fprintf(stderr, "0x%x ", *bar++);
	    }
	    fprintf(stderr, "\n");
	  }
#endif /* DIAGNOSTICS */
      }
    }
  }

  /* Seek to the code */

  fseek(stream, code_offset, 0);

  if (verbose)
    message("Loading module `%s'", CSTRING(*mod_name));

  module_size = read_word(stream);
  table_size = read_word(stream);

  DIAGNOSTIC(4, "  module size %d  table size %d", module_size, table_size);

  /* Get a vector if appropriate size */
  objects = allocate_array(table_size);
  for(i = 0; i < table_size; i++)
    MLUPDATE(objects, i, MLUNIT);

  /* Load objects into vector */
  for (i = 0; i < module_size; i++)
  {
    opcode = read_word(stream);

    switch (opcode)
    {
      case OPCODE_CODESET:
      {
	word codeset_size = read_word(stream);
	read_codeset(codeset_size, objects, stream, version, delivery);
      }
      break;

      case OPCODE_REAL:
      {
	word offset = read_word(stream);
	word real_size = read_word(stream);

	if(real_size != 2)
	  longjmp(problem, ELOADFORMAT);

        DIAGNOSTIC(4, "  real to position 0x%lX", offset, 0);

	MLUPDATE(objects, offset, read_real(stream));
      }
      break;

      case OPCODE_STRING:
      {
	word offset = read_word(stream);
	word string_size = read_word(stream);

        DIAGNOSTIC(4, "  string to position 0x%lX", offset, 0);

	MLUPDATE(objects, offset, read_string(string_size,stream));
      }
      break;

      case OPCODE_EXTERNAL:
      {
	/* Find out the name of the module referred to by the external */
	/* and look it up in the module table. */
	word offset = read_word(stream);
	word string_size = read_word(stream);
	mlval name = read_string(string_size, stream);
	mlval module = mt_lookup(modules, name, *mod_name);

	if(module == ERROR)
	{
	  load_external = name;
/*
	  fprintf(stderr, "External reference failure, mod_name = '%s', require_name = '%s', source_require_name = '%s'\n", CSTRING(*mod_name), CSTRING(require_name), CSTRING(source_require_name));
*/
	  longjmp(problem, ELOADEXTERNAL);
	}

        DIAGNOSTIC(4, "  external reference to module %s in "
		      "position 0x%lX", CSTRING(name), offset);

	MLUPDATE(objects, offset, module);
      }
      break;

      default:
      longjmp(problem, ELOADFORMAT);
    }
  }

  fclose(stream);


  closure = allocate_record(table_size);
  for(i=0; i<table_size; ++i)
    FIELD(closure, i) = MLSUB(objects, i);

  retract_root(&modules);
  retract_root(&mo_string);
  retract_root(&require_name);
  retract_root(&mo_time);
  retract_root(&objects);

/* The consistency information follows on immediately from the code */

  return(closure);
}


mlval internal_load_link(const char *filename, 
			 mlval *mod_name_ptr,
			 int verbose, 
			 int dont_check_cons,
			 int delivery)
{
  mlval closure;
  mlval structure;
  mlval time;

  struct stat stbuf;
  struct timeval tv;
  if(stat(filename,&stbuf) == -1) {
    error("The loader was unable to access the file `%s'.", filename);
  }
  tv.tv_sec = stbuf.st_mtime;
  tv.tv_usec = 0;
  time = ml_time(tv);
  declare_root(&time);
  declare_root(mod_name_ptr);

  closure = load_module(filename, mod_name_ptr, DEREF(modules),
			verbose, dont_check_cons,delivery);

  if(closure == ERROR)
    {
      retract_root(mod_name_ptr);
      retract_root(&time);
      return (ERROR);
    }
  else
    {
      structure = callml(closure, closure);
      MLUPDATE(modules, 0, mt_add(DEREF(modules), *mod_name_ptr, structure, time));
      retract_root(mod_name_ptr);
      retract_root(&time);

      return(structure);
    }
}


/*  === LOAD A COMPILED WORDSET ===
 *
 *  From MachTypes:
 *
 *  > datatype wordset =
 *  >   WORD_SET of string list *		(* function names *)
 *  >               (int * int * string) list *	(* closure pos, spills, code *)
 *  >               bool list *			(* leaf flags *)
 *  >               int list			(* intercept offset *)
 *
 *  The first argument to load_wordset is the runtime version required for
 *  this wordset.
 *
 *  See also: read_codeset() which loads the same object from a `.mo' file.
 */

mlval load_wordset(mlval argument)
{
  size_t length = 0;
  mlval result = MLNIL, vector, list = MLUNIT, code = MLUNIT;
  size_t offset;
  int version = CINT(FIELD(argument, 0)), i, nr_procedures = 0;
  mlval wordset = FIELD(argument, 1);
  mlval names, spills, ancillary, profiles, intercepts, leafs, interfns;

  DIAGNOSTIC(2, "load_wordset(version = %d, wordset = 0x%X)", version, wordset);

  if(version != OBJECT_FILE_VERSION)
  {
    errno = version > OBJECT_FILE_VERSION ? ELOADNEWER : ELOADOLDER;
    return(ERROR);
  }

  /* Calculate the length of the code vector and perform consistency checks. */

  for(list=FIELD(wordset, 1); list!=MLNIL; list=MLTAIL(list))
  {
    mlval triple = MLHEAD(list);
    size_t l = CSTRINGLENGTH(FIELD(triple, 2));

    if(word_align(l) != l)
    {
      errno = ELOADALIGN;
      return(ERROR);
    }

    /* One for back pointer, one for number within set */
    length += l/sizeof(word) + 2;

    ++nr_procedures;
  }

  if(length == 0)
  {
    errno = ELOADEMPTY;
    return(ERROR);
  }

  DIAGNOSTIC(3, "  nr_procedures=%u  length=%u", nr_procedures, length);

  declare_root(&wordset);

  /* Create the ancillary of the code vector. */

  spills = allocate_array(nr_procedures);
  for(i=0, list=FIELD(wordset, 1); i<nr_procedures; ++i, list=MLTAIL(list))
    MLUPDATE(spills, i, FIELD(MLHEAD(list), 1));
  declare_root(&spills);

  names = allocate_array(nr_procedures);
  DIAGNOSTIC(3, "  function names array 0x%X:", names, 0);
  for (i=0, list=FIELD(wordset, 0); i<nr_procedures; ++i, list=MLTAIL(list))
  {
    MLUPDATE(names, i, MLHEAD(list));
    DIAGNOSTIC(3, "    %3d: `%s'", i, CSTRING(MLHEAD(list)));
  }
  declare_root(&names);

  profiles = allocate_array(nr_procedures);
  for (i=0; i<nr_procedures; ++i)
    MLUPDATE(profiles, i, MLUNIT);
  declare_root(&profiles);

  intercepts = allocate_array(nr_procedures);
  for(i=0; i<nr_procedures; ++i)
    MLUPDATE(intercepts, i, 0);
  declare_root(&intercepts);

  for(list=FIELD(wordset, 3), i=0; list!=MLNIL; list=MLTAIL(list), ++i)
  {
    DIAGNOSTIC(3, "    %3d: intercept offset 0x%X", i, MLHEAD(list));
    MLUPDATE(intercepts, i, MLHEAD(list));
  }

  leafs = allocate_array(nr_procedures);
  for(i=0; i<nr_procedures; ++i)
    MLUPDATE(leafs, i, MLFALSE);
  declare_root(&leafs);

  for(list=FIELD(wordset, 2), i=0; list!=MLNIL; list=MLTAIL(list), ++i)
  {
    DIAGNOSTIC(3, "    %3d: %sleaf", i, MLHEAD(list)==MLTRUE ? "" : "non-");
    MLUPDATE(leafs, i, MLHEAD(list));
  }

  interfns = allocate_array(nr_procedures);
  for(i=0; i<nr_procedures; ++i)
    MLUPDATE(interfns, i, MLFALSE);
  declare_root(&interfns);

  ancillary = allocate_array(ANCILLARY_SIZE);

  retract_root(&names);
  retract_root(&profiles);
  retract_root(&interfns);
  retract_root(&spills);
  MLUPDATE(ancillary, ANC_SPILLS, spills);
  MLUPDATE(ancillary, ANC_NAMES, names);
  MLUPDATE(ancillary, ANC_PROFILES, profiles);
  MLUPDATE(ancillary, ANC_LEAFS, leafs);
  MLUPDATE(ancillary, ANC_INTERCEPTS, intercepts);
  MLUPDATE(ancillary, ANC_INTERFNS, interfns);
  declare_root(&ancillary);

  /* Create the code vector and initialize the ancillary. */

  vector = allocate_code(length+1);
  CCVANCILLARY(vector) = ancillary;
  retract_root(&ancillary);

  declare_root(&vector);
  declare_root(&list);
  declare_root(&result);
  declare_root(&code);

  DIAGNOSTIC(3, "  code vector 0x%X", vector, 0);

  offset = 2;
  for(list=FIELD(wordset, 1), i=0; list!=MLNIL; list=MLTAIL(list), ++i)
  {
    mlval triple = MLHEAD(list), string = FIELD(triple, 2), pair;
    size_t length = CSTRINGLENGTH(string);
    mlval position = FIELD(triple, 0);
    mlval *next = (mlval *)OBJECT(vector) + offset;

    code = MLPTR(POINTER, next);

    if(offset > 0)
      next[0] = MAKEHEAD(BACKPTR, offset * sizeof(mlval));

    next[1] = i;

    memcpy((char *)&next[2], CSTRING(string), length);

    DIAGNOSTIC(3, "    %3d: position %d", i, position);
    DIAGNOSTIC(3, "         offset 0x%X  spills %u", offset, CINT(FIELD(triple, 1)));

    offset += double_align(length + 2*sizeof(mlval))/sizeof(mlval);

    pair = allocate_record(2);
    FIELD(pair, 0) = position;
    FIELD(pair, 1) = code;
    result = cons(pair, result);

    loader_code_add(code); /* This can call gc */
  }

  retract_root(&code);
  retract_root(&list);
  retract_root(&result);
  retract_root(&vector);
  retract_root(&intercepts);
  retract_root(&leafs);
  retract_root(&wordset);

  return(result);
}
@


1.61
log
@Add original require file names to consistency info.
@
text
@d12 3
d644 1
a644 1
  /* Versions 6, 7 & 8 & 9, 10 are the only versions that this loader can
d649 2
d653 1
a653 1
  if(version < 6 || version > 10)
@


1.60
log
@Fixed such that when timestamp tests find module missing, the same
error is produced as if the time stamps weren't being done. In
particular, errno is now set in this case.
@
text
@d12 5
d370 9
d575 1
a575 1
  mlval require_name = MLUNIT, mo_string = MLUNIT;
d641 1
a641 1
  /* Versions 6, 7 & 8 & 9 are the only versions that this loader can
d643 4
a646 1
   * type information, which doesn't affect the loader */
d648 1
a648 1
  if(version < 6 || version > 9)
d657 4
d669 4
a680 1
	longjmp(problem, ELOADEXTERNAL);
d682 1
a682 3
	DIAGNOSTIC(1, "module '%s' references unknown module '%s' ",
		   CSTRING(*mod_name), CSTRING(require_name));
	return ERROR;
d684 1
d780 3
@


1.59
log
@Moved extern function declarations to header files.
@
text
@d12 3
d655 3
d661 1
@


1.58
log
@Added function internal_load_link for use by image builder and by the ml mo loader.
@
text
@d12 3
d209 2
a210 1

d291 1
a291 1
static void read(void *whither, size_t size, size_t number, FILE *stream)
d297 1
a297 1
int read_byte(FILE *stream)
d321 1
a321 1
  c = read_byte(stream);
d325 1
a325 1
    w = (word)read_byte(stream);
d327 1
a327 1
    w += (word)read_byte(stream);
d339 1
a339 1
  read(&the_real, sizeof(double), 1, stream);
d348 1
a348 1
  read(CSTRING(ml_string), word_align(string_size), 1, stream);
d357 1
a357 1
    read(CSTRING(ml_string), 1, 1, stream); /* Ignore the string */
d366 1
a366 1
  read(CSTRING(ml_string), string_size, 1, stream);
d390 1
a390 1
  read(CSTRING(name), string_size, 1, stream);
d516 1
a516 1
    read(&next[2], size, 1, stream);
d557 2
a558 1
  mlval objects = MLUNIT, closure, source_time, mo_time = MLUNIT, require_name = MLUNIT, mo_string = MLUNIT;
d593 3
d606 3
d624 9
a632 1
  /* Get code offset, and seek to it. */
d634 1
a634 1
  cons_size = (int)(read_cons_size(stream));
a641 3
  declare_root(&mo_time);
  declare_root(&require_name);
  declare_root(&mo_string);
d646 1
a646 3
/*
    fprintf(stderr, "Reading mo_string of length %u\n", i);
*/
d652 1
a652 1
	DIAGNOSTIC(0, "module '%s' references unknown module '%s' ",
d656 2
a657 5
      if (memcmp(mo_time, mt_time, 4*sizeof(mlval)) != 0) {
	unsigned int *foo = (unsigned int *)(((int)mo_time)-1);
	char * bar;
	int len;
	DIAGNOSTIC(0, "module '%s' references module '%s' ", CSTRING(*mod_name),
d659 25
a683 20
	DIAGNOSTIC(0, "with incompatible time stamp. Recompilation recommended", 0, 0);
/*
	fprintf(stderr, "mo_time = 0x%x %x %x %x\n", foo[0], foo[1], foo[2], foo[3]);
	foo = (unsigned int *)((int)(mt_lookup_time(modules, require_name, *mod_name))-1);
	fprintf(stderr, "require_time = 0x%x %x %x %x\n", foo[0], foo[1], foo[2], foo[3]);
	bar = CSTRING(mo_string);
	fprintf(stderr, "mo_string = ");
	len = *((int *)(bar-4));
	len >>= 6;
	while (len-- > 0) {
	  fprintf(stderr, "0x%x ", *bar++);
	};
	fprintf(stderr, "\n");
*/
      };
    };
  };
  retract_root(&mo_string);
  retract_root(&require_name);
  retract_root(&mo_time);
a688 7
  /* Versions 6, 7 & 8 & 9are the only versions that this loader can cope with. */
  /* 6, 7 & 8 & 9 differ only in the encapsulation of type information, */
  /* which doesn't affect the loader */

  if(version != 6 && version != 7 && version != 8 && version != 9)
    longjmp(problem, ELOADVERSION);

a766 1
  retract_root(&modules);
d772 4
@


1.57
log
@Added delivery option which discards code vector names
@
text
@d12 3
d218 2
d227 1
d771 41
@


1.56
log
@Checked return value of mt_lookup_time.
@
text
@d12 3
d342 10
d400 2
a401 1
			 int version)
d481 1
a481 1
    name = read_string(size, stream);
d544 1
a544 1
		  mlval modules, int verbose, int dont_check_cons)
d694 1
a694 1
	read_codeset(codeset_size, objects, stream, version);
@


1.55
log
@Made it understand version 9 too.  There must be a better way of doing this!
@
text
@d12 3
d616 7
a622 2
      if (memcmp(mo_time, mt_lookup_time(modules, require_name, *mod_name),
		 4*sizeof(mlval)) != 0) {
@


1.54
log
@Changed to allow detection of inconsistent mo sets
@
text
@d12 3
d645 2
a646 2
  /* Versions 6, 7 & 8 are the only versions that this loader can cope with. */
  /* 6, 7 & 8 differ only in the encapsulation of type information, */
d649 1
a649 1
  if(version != 6 && version != 7 && version != 8)
@


1.53
log
@Bug in read_opt_int (I wrote << instead of <<=).
@
text
@d12 3
d213 1
d215 1
d333 18
d356 1
d358 1
d518 3
d524 1
a524 1
		  mlval modules, int verbose)
d527 1
a527 1
  mlval objects = MLUNIT, closure;
d529 1
a529 1
  int length;
d589 2
d592 45
d734 2
@


1.53.1.1
log
@Fork for bug fixing
@
text
@a11 3
 *  Revision 1.53  1993/08/27  19:22:11  daveb
 *  Bug in read_opt_int (I wrote << instead of <<=).
 *
@


1.52
log
@load_module sets the module name from the consistency information in the
file.
@
text
@d12 4
d302 1
a302 1
    w << 8;
@


1.51
log
@mt_lookup takes an extra argument.
@
text
@d12 3
d269 10
d288 18
d324 13
d491 2
a492 1
mlval load_module(const char *filename, mlval modules)
d494 1
a494 1
  word i, opcode, module_size, table_size, version;
d554 1
d556 6
a561 1
  fseek(stream, read_word(stream), 0);
d626 1
a626 1
	mlval module = mt_lookup(modules, name, module_name (filename));
@


1.50
log
@Increased the level of a diagnostic.
@
text
@d12 3
d575 1
a575 1
	mlval module = mt_lookup(modules, name);
@


1.49
log
@New object file format.  Runtime is compatible with old version.
@
text
@d12 3
d311 1
a311 1
  DIAGNOSTIC(2, "read_codeset(nr_procedures = %u, objects = 0x%X",
d313 1
a313 1
  DIAGNOSTIC(2, "             stream = 0x%X, version = %d)", stream, version);
@


1.48
log
@New version cos encapsulator has changed
@
text
@d12 3
d506 2
a507 2
  /* Versions 6 & 7 are the only versions that this loader can cope with. */
  /* 6 & 7 differ only in the ecnapsulation of type information, */
d510 1
a510 1
  if(version != 6 && version != 7)
@


1.47
log
@Changed the layout of code vectors in the encapsulator in order to
reduce the amount of root juggling that would have been necessary
to correct a bug calling the loader code observer.
@
text
@d12 5
d503 5
a507 2
  /* Version 6 is the only versions that this loader can cope with. */
  if(version != 6)
@


1.46
log
@Fixed problem with superfluous mlupdate(spills, ...) outside scope
of declare/retract. Removed superfluous reallocation of code vector.
Added declare/retract round call to weak_add in loader_code_add
@
text
@d12 5
d288 1
a288 2
 *  The start address of each procedure is inserted into the record
 *  ml_vector.
d292 1
a292 1
			 mlval ml_vector,
a295 2
  word size_of_code;
  word length;
d298 1
a298 1
  size_t i, position, offset;
d300 2
a301 2
  DIAGNOSTIC(2, "read_codeset(nr_procedures = %u, ml_vector = 0x%X",
	        nr_procedures, ml_vector);
d304 1
a304 1
  declare_root(&ml_vector);
d306 1
a306 1
  /* Create the ancillary and read the names into the info part of it. */
a317 17
  DIAGNOSTIC(3, "  function names:", 0, 0);

  for(i=0; i<nr_procedures; ++i)
  {
    word size = read_word(stream);
    mlval name = read_string(size, stream);

    MLUPDATE(names, i, name);

    DIAGNOSTIC(3, "    %3d: `%s'", i, CSTRING(name));
  }

  /* Calculate the length of code vector required, adding an extra 2 words */
  /* for reformed code vector */
  size_of_code = read_word(stream);
  length = size_of_code/sizeof(word) + 2*(nr_procedures-1)+3;

a338 3
  retract_root(&profiles);
  retract_root(&names);
  retract_root(&interfns);
d347 6
a354 1
  retract_root(&ancillary);
d357 1
a357 2
  DIAGNOSTIC(3, "  code vector 0x%X  length 0x%X", vector, length);
  DIAGNOSTIC(3, "  reading code", 0, 0);
d359 2
d364 2
a365 2
    word size, spill;
    mlval code;
d367 19
d392 2
a393 2
    position = read_word(stream);
    FIELD(ml_vector, position) = code;
a398 1
    spill = read_word(stream);
d402 1
a402 2
    /* Put the number of spills into its array */
    MLUPDATE(spills, i, MLINT(spill));
d404 5
a408 2
    DIAGNOSTIC(3, "    %3d: position %d", i, position);
    DIAGNOSTIC(3, "         offset 0x%X  spills %u", offset, spill);
d410 1
a410 3
    offset += double_align(size + 2*sizeof(mlval))/sizeof(mlval);

    loader_code_add(code); /* This can call gc */
d413 4
a417 20

  /* Read in the leaf information and intercept offsets */

  if(version >= 5)
  {
    for(i=0; i<nr_procedures; ++i)
    {
      int leaf = read_word(stream);
      DIAGNOSTIC(3, "    %3d: %sleaf", i, leaf ? "" : "non-");
      MLUPDATE(leafs, i, leaf ? MLTRUE : MLFALSE);
    }

    for(i = 0; i < nr_procedures; ++i)
    {
      mlval offset = MLINT(read_word(stream));
      DIAGNOSTIC(3, "    %3d: intercept offset %d", i, CINT(offset));
      MLUPDATE(intercepts, i, offset);
    }
  }

d420 2
a421 2
  retract_root(&vector);
  retract_root(&ml_vector);
d435 2
a436 2
  word loop, opcode, module_size, table_size, version;
  mlval result = MLUNIT;
d470 1
a470 1
  declare_root(&result);
d480 1
a480 1
      retract_root(&result);
d498 3
a500 4
  switch(version)
  {
    case 0: case 1: case 2: case 3:
    error("Warning: %s is a version %d module.", filename, version);
d502 2
a503 5
    /* Versions 4 & 5 are the only versions that this loader can cope with. */
    case 4: case 5:
    module_size = read_word(stream);
    table_size = read_word(stream);
    break;
a504 4
    default:
    longjmp(problem, ELOADVERSION);
  }

d508 3
a510 3
  result = allocate_record(table_size);
  for(loop = 0; loop < table_size; loop++)
    FIELD(result, loop) = MLUNIT;
d513 1
a513 1
  for (loop = 0; loop < module_size; loop++)
d522 1
a522 2

	read_codeset(codeset_size, result, stream, version);
d536 1
a536 1
	FIELD(result, offset) = read_real(stream);
d547 1
a547 1
	FIELD(result, offset) = read_string(string_size,stream);
d569 1
a569 1
	FIELD(result, offset) = module;
a579 1
  retract_root(&result);
d582 7
a588 1
  return(result);
d681 6
d692 6
a763 13

  for(list=FIELD(wordset, 2), i=0; list!=MLNIL; list=MLTAIL(list), ++i)
  {
    DIAGNOSTIC(3, "    %3d: %sleaf", i, MLHEAD(list)==MLTRUE ? "" : "non-");
    MLUPDATE(leafs, i, MLHEAD(list));
  }

  for(list=FIELD(wordset, 3), i=0; list!=MLNIL; list=MLTAIL(list), ++i)
  {
    DIAGNOSTIC(3, "    %3d: intercept offset 0x%X", i, MLHEAD(list));
    MLUPDATE(intercepts, i, MLHEAD(list));
  }

@


1.45
log
@All ancillary slots are now loaded.
@
text
@d12 3
d193 3
a195 2
  loader_code = weak_add(loader_code, code); /* This may call gc */

d626 1
a626 1
  mlval result = MLNIL, vector, list, code = MLUNIT;
d706 1
a706 1
  retract_root(&spills);
d710 1
a724 2
  vector = allocate_code(length+1);
  CCVANCILLARY(vector) = ancillary;
d746 1
a746 1
    MLUPDATE(spills, i, FIELD(triple, 1));
@


1.44
log
@New version to account for code changes for leaf and intercept offset
@
text
@d12 3
d198 1
a198 1
  CCVPROFILE(code) = (unsigned int *)PROFILE_DISABLE;
d274 1
a274 1
 *  string.  The procedures have back-pointers to the start of the
d290 2
a291 1
  mlval vector, ancillary, *next, strings, spills, profiles;
d294 4
a297 1
  /* First read the name strings into the array */
d299 3
d303 1
a303 1
  for (i=0; i < nr_procedures; i++) {
a304 1
  }
d306 16
a321 3
  strings = allocate_array(nr_procedures);
  for (i=0; i < nr_procedures; i++) {
    MLUPDATE(strings, i, MLUNIT);
a322 6
  declare_root(&strings);
  for (i=0; i < nr_procedures; i++) {
    word size = read_word(stream); /* Length of the string */
    mlval string = read_string(size, stream);
    MLUPDATE(strings, i, string);
  };
d324 2
a327 1
  /* Extra 2 words for reformed code vector */
a328 3
  DIAGNOSTIC(2, "read_codeset(nr_procedures = %u, size = %u,", nr_procedures, size_of_code);
  DIAGNOSTIC(2, "             ml_vector = 0x%X, stream = 0x%X)", ml_vector, stream);

d330 2
a331 3
  for (i=0; i < nr_procedures; i++) {
    MLUPDATE(profiles, i, PROFILE_DISABLE);
  }
a332 7
  ancillary = allocate_array(ANCILLARY_SLOT_SIZE);
  for (i=3; i < ANCILLARY_SLOT_SIZE; i++) {
    MLUPDATE(ancillary, i, MLUNIT);
  };
  MLUPDATE(ancillary, 0, spills);
  MLUPDATE(ancillary, 1, strings);
  MLUPDATE(ancillary, 2, profiles);
d334 25
d360 1
d362 4
a365 1
  FIELD(vector, 0) = ancillary;
d367 1
a368 3
  DIAGNOSTIC(4, "  reading code", 0, 0);

  declare_root(&vector);
d370 1
a370 1
  for(i = 0; i < nr_procedures; ++i)
d378 2
a379 2
    /* If it isn't the first piece of code in the vector then insert a */
    /* BACKPTR to the real header. */
a380 3
    if(offset > 0)
      *next = MAKEHEAD(BACKPTR, offset * sizeof(mlval));

d384 3
a386 1
    next[1] = i; /* Write in the code vector number */
d389 4
a392 2
    read(next+2, size, 1, stream);
    change_endian(next+2, size);
a393 2
    /* Put the number of spills into its array */
    DIAGNOSTIC(4, "    0x%X: %s", code, CCVNAME1(code, i));
d395 3
a399 4
/* This really isn't necessary
    CCVPROFILE(code) = (unsigned int *)PROFILE_DISABLE;
*/

d403 13
a415 2
  if (version >= 5) {
    /* Now read in the leaf information (ignored at present) */
d417 5
a421 8
      {
	int leaf=read_word(stream);
      }
    /* Now read in the intercept offsets information (ignored at present) */
    for(i = 0; i < nr_procedures; ++i)
      {
	int offset=read_word(stream);
      }
d424 2
a425 3
  retract_root(&profiles);
  retract_root(&strings);
  retract_root(&spills);
a426 1
  retract_root(&ancillary);
d506 1
a506 5
    /* Version 0 had a buggy module size.  Add a bit just in case. */
    case 0:
    case 1:
    case 2:
    case 3:
a507 2
    /*NOTREACHED*/
    break;
d510 1
a510 2
    case 4:
    case 5:
d519 1
a519 1
  DIAGNOSTIC(2, "  module size %d  table size %d", module_size, table_size);
d533 1
a533 1
      case opcode_codeset:
d541 1
a541 1
      case opcode_real:
d549 1
a549 1
        DIAGNOSTIC(2, "  real to position 0x%lX", offset, 0);
d555 1
a555 1
      case opcode_string:
d560 1
a560 1
        DIAGNOSTIC(2, "  string to position 0x%lX", offset, 0);
d566 1
a566 1
      case opcode_external:
d581 1
a581 1
        DIAGNOSTIC(2, "  external reference to module %s in "
d607 5
a611 1
 *  > datatype wordset = WORD_SET of (int * int * string) list
a612 3
 *  where the first int is the closure position, the second is the non-gc
 *  spills, and the string is the code.
 *
d626 1
a626 2
  mlval codes = FIELD(wordset, 1);
  mlval strings, spills, ancillary, profiles;
d628 1
a628 5
  if (version > object_file_version)
    error("load_wordset() was passed code in a newer format than the run-time\n\
  system.  You probably need to re-compile the compiler.");
  else if (version < object_file_version)
    error("load_wordset() was passed code in an older format than the run-time system!");
d630 1
a630 1
  for(list = codes; list != MLNIL; list = MLTAIL(list))
d632 8
d644 4
a647 1
      error("load_wordset() was passed a string with unaligned length");
d649 4
a652 2
    length += l/sizeof(word) + 2; /* One for back pointer, one for number within set */
    nr_procedures++;
d656 4
a659 1
    error("load_wordset() was passed an empty wordset");
d661 2
d664 3
a666 9
  declare_root(&codes);
  ancillary = allocate_array(ANCILLARY_SLOT_SIZE);
  for (i=0; i < ANCILLARY_SLOT_SIZE; i++) {
    MLUPDATE(ancillary, i, MLUNIT);
  };
  declare_root(&ancillary);
  vector = allocate_code(length+1);
  FIELD(vector, 0) = ancillary;
  declare_root(&vector);
d668 2
a669 3
  for (i = 0; i < nr_procedures; i++) {
    MLUPDATE(spills, i, MLUNIT);
  }
d671 7
a677 3
  strings = allocate_array(nr_procedures);
  for (i=0; i < nr_procedures; i++) {
    MLUPDATE(strings, i, MLUNIT);
d679 2
a680 1
  declare_root(&strings);
d682 36
a717 3
  for (i = 0; i < nr_procedures; i++) {
    MLUPDATE(profiles, i, PROFILE_DISABLE);
  }
a718 6
  retract_root(&codes);
  retract_root(&wordset);
  retract_root(&strings);
  MLUPDATE(ancillary, 0, spills);
  MLUPDATE(ancillary, 1, strings);
  MLUPDATE(ancillary, 2, profiles);
d720 3
d727 1
a727 3
  for (list = FIELD(wordset, 0), i = 0; list != MLNIL; list = MLTAIL(list), i++) {
    MLUPDATE(strings, i, MLHEAD(list));
  }
d730 1
a730 1
  for(list = codes, i = 0; list != MLNIL; list = MLTAIL(list), i++)
d745 4
a750 4
/* This really isn't necessary
    CCVPROFILE(code) = (unsigned int *)PROFILE_DISABLE;
*/

d763 16
a778 1
  retract_root(&spills);
@


1.43
log
@Moved ANCILLARY_SLOT_SIZE into values.h
@
text
@d12 3
d282 2
a283 1
			 FILE *stream)
d372 13
d478 1
a478 1
    /* Version 4 is the only version that this loader can cope with. */
d480 1
d507 1
a507 1
	read_codeset(codeset_size, result, stream);
@


1.42
log
@Changes for code vector reform
@
text
@d12 3
a275 2

#define ANCILLARY_SLOT_SIZE 5
@


1.41
log
@Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
@
text
@d12 3
d16 1
a16 1
 *   Changed runtime_version to object_file_version.
d181 1
a181 1
  loader_code = weak_add(loader_code, code);
d274 2
a276 1
			 word size,
d280 3
a282 2
  word length = size/sizeof(word) + nr_procedures-1;
  mlval vector, *next;
d285 23
a307 1
  DIAGNOSTIC(2, "read_codeset(nr_procedures = %u, size = %u,", nr_procedures, size);
d310 12
a321 1
  declare_root(&ml_vector);
d323 1
d325 1
a325 2
  declare_root(&vector);

d330 2
a331 1
  offset = 0;
d334 1
d349 1
d351 6
a356 2
    read(next+1, size, 1, stream);
    change_endian(next+1, size);
d358 1
a358 1
    DIAGNOSTIC(4, "    0x%X: %s", code, CCVNAME(code));
d360 1
a360 2
    offset += double_align(size + sizeof(mlval))/sizeof(mlval);

d362 1
d364 1
a364 1
    loader_code_add(code);
d367 3
d371 1
d455 1
d460 2
a461 2
    /* Version 3 is the only version that this loader can cope with. */
    case 3:
a486 1
	word total_size = read_word(stream);
d488 1
a488 1
	read_codeset(codeset_size, total_size, result, stream);
d574 1
a574 1
  int version = CINT(FIELD(argument, 0));
d576 2
d585 1
a585 1
  for(list = wordset; list != MLNIL; list = MLTAIL(list))
d593 2
a594 1
    length += l/sizeof(word) + 2;
d601 25
a625 1
  vector = allocate_code(length-1);
d627 4
a632 1
  declare_root(&vector);
d636 6
a641 2
  offset = 0;
  for(list = wordset; list != MLNIL; list = MLTAIL(list))
d653 2
a654 1
    next[1] = CINT(FIELD(triple, 1));
a655 1

d658 1
d660 1
d667 1
a667 1
    loader_code_add(code);
d674 1
@


1.40
log
@ Changed runtime_version to object_file_version.
@
text
@d12 3
d168 1
d307 1
a307 1
    (void)SETFIELD(ml_vector, position, code);
d425 1
a425 1
    (void)SETFIELD(result, loop, MLUNIT);
d453 1
a453 1
	(void)SETFIELD(result, offset, read_real(stream));
d464 1
a464 1
	(void)SETFIELD(result,offset,read_string(string_size,stream));
d486 1
a486 1
	(void)SETFIELD(result, offset, module);
d525 2
a526 2
  int version = CINT(GETFIELD(argument, 0));
  mlval wordset = GETFIELD(argument, 1);
d537 1
a537 1
    size_t l = CSTRINGLENGTH(GETFIELD(triple, 2));
d560 1
a560 1
    mlval triple = MLHEAD(list), string = GETFIELD(triple, 2), pair;
d562 1
a562 1
    mlval position = GETFIELD(triple, 0);
d570 1
a570 1
    next[1] = CINT(GETFIELD(triple, 1));
d578 2
a579 2
    (void)SETFIELD(pair, 0, position);
    (void)SETFIELD(pair, 1, code);
@


1.39
log
@Added version parameter to load_wordset.  Changed current version to 3,
which has the new representation of lists.
@
text
@d12 4
d524 1
a524 1
  if (version > runtime_version)
d527 1
a527 1
  else if (version < runtime_version)
@


1.38
log
@Changed the action when the loader finds a wrongly sized real
number.  It now exits with an error code.
@
text
@d12 4
d396 4
a399 3
    message("Warning: %s is a version 0 module.", filename);
    module_size = read_word(stream);
    table_size = module_size + 100;
d402 2
a403 3
    /* Versions 1 & 2 are the highest versions this loader can cope with. */
    case 1:
    case 2:
d506 3
d512 1
a512 1
mlval load_wordset(mlval wordset)
d517 8
@


1.37
log
@Added missing root declarations.  (Oops)
@
text
@d12 3
d437 1
a437 2
	  error("loader: The runtime system can only cope with"
		"reals of size 2 (doubles).");
@


1.36
log
@Small change to the object file format.
@
text
@d12 3
d523 1
d525 1
d527 1
a529 1
  declare_root(&list);
@


1.35
log
@Implemented load_wordset.
@
text
@d12 3
d379 1
a379 1
  (void)read_word(stream);
@


1.34
log
@The loader keeps track of code vectors (again) but an observer
function can be declared from any profiler.  This gives more
flexibility for use by the memory auditer.
@
text
@d12 5
d494 1
a494 1
 *  See also: load_codeset()
d499 59
a557 1
  error("load_wordset() unimplemented");
@


1.33
log
@Removed incorrect load_wordset() temporarily.
Code vectors are now tagged differently to strings.
@
text
@d12 4
d136 1
a136 1
#include "profiler.h"
d145 27
d182 2
d187 1
d251 1
a251 1
  mlval vector, code, *next;
d254 3
d262 3
a264 1
  DIAGNOSTIC(2, "  codeset of %d procedures, length 0x%X", nr_procedures, length);
d269 2
d272 4
d281 1
a281 3
    (void)SETFIELD(ml_vector, position, MLPTR(POINTER, next));

    DIAGNOSTIC(2, "  procedure at 0x%X to position 0x%X", MLPTR(POINTER, next), position);
d287 2
d291 3
a293 2
    /* Introduce the new code vector to the profiler. */
    profile_new(MLPTR(POINTER, next));
@


1.32
log
@Changed read_wordset to cope with a garbage collection caused by
profile_new().
@
text
@d12 4
d216 1
a216 1
  word total_size = size + sizeof(word) * (nr_procedures - 1);
d222 1
a222 1
  vector = allocate_string(total_size);
d225 1
a225 2
  DIAGNOSTIC(2, "  codeset of %d procedures, size 0x%lX",
	     nr_procedures, total_size);
d448 1
a448 70
  size_t length;
  mlval list = MLNIL, vector, code, *next, *start, result, p = MLUNIT;

  declare_root(&wordset);
  declare_root(&list);

  /* Calculate the length of the code vector, taking into account the non-gc */
  /* spill parameter (4 bytes) and the header (4 bytes) */

  length = 0;
  for(list = wordset; !MLISNIL(list); list = MLTAIL(list))
    length += double_align(8 + CSTRINGLENGTH(GETFIELD(MLHEAD(list), 2)));

  vector = code = allocate_string(length - 4);
  start = next = (mlval *)CSTRING(vector);
  declare_root(&vector);
  declare_root(&code);

  result = MLNIL;
  declare_root(&result);
  declare_root(&p);

  for(list = wordset; !MLISNIL(list); list = MLTAIL(list))
  {
    /* If the procedure is not the first insert a backpointer to the start */
    /* of the code vector so that it is a legal ML value. */

    if(next != start)
    {
      *next = MAKEHEAD(BACKPTR, (next-start+1)*sizeof(mlval));
      code = MLPTR(POINTER, next);
      ++next;
    }

    /* Add the code pointer to the result list, paired with its position */
    /* from the original wordset. */

    p = allocate_record(2);
    (void)SETFIELD(p, 0, GETFIELD(MLHEAD(list), 0));
    (void)SETFIELD(p, 1, code);
    result = cons(p, result);

    /* Fixup `next' in case there was a collection. */

    next = (mlval *)CSTRING(code);

    /* Insert the non-gc spill count in front of the procedure, then copy */
    /* the code string into place. */

    *next++ = GETFIELD(MLHEAD(list), 1);
    p = GETFIELD(MLHEAD(list), 2);
    length = CSTRINGLENGTH(p);
    memcpy((char *)next, CSTRING(p), length);

    /* Introduce the new code vector to the profiler. */
    profile_new(code);

    /* Fix `start' and `next' in case there was a collection. */
    start = (mlval *)CSTRING(vector);
    next  = (mlval *)double_align(CSTRING(code) + length + 4);
  }

  retract_root(&p);
  retract_root(&code);
  retract_root(&result);
  retract_root(&vector);
  retract_root(&list);
  retract_root(&wordset);

  return(result);
@


1.31
log
@The profiler, rather than the loader, maintains a list of code vectors.
@
text
@d12 3
d213 2
a214 2
  mlval vector, code, *start, *next;
  size_t procedure, position;
d218 1
a218 2
  vector = code = allocate_string(total_size);
  start = next = (mlval *)CSTRING(vector);
a219 1
  declare_root(&code);
d224 2
a225 1
  for(procedure = 0; procedure < nr_procedures; ++procedure)
d227 4
a230 6
    if(next != start)
    {
      *next = MAKEHEAD(BACKPTR, (next-start+1)*sizeof(mlval));
      code = MLPTR(POINTER, next);
      ++next;
    }
d233 1
a233 1
    (void)SETFIELD(ml_vector, position, code);
d235 1
a235 1
    DIAGNOSTIC(2, "  procedure at 0x%X to position 0x%X", code, position);
d237 3
a239 1
    /* Find out how big this procedure is and read it in. */
d241 1
a241 3
    size = read_word(stream);
    read(next, size, 1, stream);
    change_endian(next, size);
d244 1
a244 7
    profile_new(code);

    /* There may have been a garbage collection in profile_new(), so */
    /* make sure these pointers are correct. */

    start = (mlval *)CSTRING(vector);
    next  = (mlval *)double_align(CSTRING(code) + size);
d247 1
a248 2
  retract_root(&code);
  retract_root(&vector);
@


1.30
log
@Changed delcare_code_vector() to declare_code(), exported it, and
increased the size of the arrays it uses.
@
text
@d12 4
a125 1
#include "global.h"
a139 1
mlval load_code_vectors = MLNIL;
a143 41
  declare_global("loaded code vectors", &load_code_vectors, NULL);
}


/*  === ADD CODE VECTOR TO LIST ===  */

#define ARRAY_SIZE	256

void declare_code(mlval code)
{
  mlval list = load_code_vectors;
  mlval array;
  size_t length, i;

  /* The profiler may also want to know about the code vector. */
  profile_new(code);

  while(list != MLNIL)
  {
    array = MLHEAD(list);
    length = LENGTH(ARRAYHEADER(array));

    for(i=0; i<length; ++i)
      if(MLSUB(array, i) == DEAD)
      {
	MLUPDATE(array, i, code);
	return;
      }

    list = MLTAIL(list);
  }

  array = allocate_weak_array(ARRAY_SIZE);
  declare_root(&array);
  load_code_vectors = cons(array, load_code_vectors);
  retract_root(&array);

  MLUPDATE(array, 0, code);

  for(i=1; i<ARRAY_SIZE; ++i)
    MLUPDATE(array, i, DEAD);
d243 2
a244 1
    declare_code(code);
d246 1
a246 1
    /* There may have been a garbage collection in declare_code(), so */
d506 2
a507 1
    declare_code(code);
@


1.29
log
@Removed redundant include of "gc.h".
@
text
@d12 3
d122 1
d142 1
a142 1
  declare_root(&load_code_vectors);
d148 1
a148 1
#define ARRAY_SIZE	16
d150 1
a150 1
static void declare_code_vector(mlval code)
d282 1
a282 1
    declare_code_vector(code);
d284 1
a284 1
    /* There may have been a garbage collection in declare_code_vector(), so */
d544 1
a544 1
    declare_code_vector(code);
@


1.28
log
@Added load_wordset().
@
text
@d12 3
a116 1
#include "gc.h"
@


1.27
log
@Implemented load_code_vectors, and changed the way the loader
interacts with the profiler.
@
text
@d12 4
a139 3
int in_ML = 0;


d243 2
a244 3
  mlval code;
  mlval *start, *next;
  word procedure, position;
d247 5
a251 3
  code = allocate_string(total_size);
  retract_root(&ml_vector);
  start = next = (mlval *)CSTRING(code);
d258 1
a258 9
    /* Find out where in the ml_vector the procedure belongs and */
    /* insert it there, inserting a back-pointer to the start of the */
    /* string if the procedure is not the first. */

    position = read_word(stream);

    DIAGNOSTIC(2, "  procedure at 0x%X to position 0x%X", code, position);

    if(procedure != 0)
d265 1
d268 2
d278 5
a282 1
    next = (mlval *)double_align((char *)next + size);
d284 4
d296 1
a296 4
 *  setup function for the module.  When all the objects have been read this
 *  function is called.  The module table is retracted as a root just before
 *  the setup function is called.  This allows its contents to be garbage
 *  collected.
d302 2
a303 2
  mlval ml_vector, result;
  FILE *stream;
a305 2
  declare_root(&modules);

d335 3
d345 3
d381 1
a381 2
    errno = ELOADVERSION;
    return(ERROR);
d387 1
a387 1
  ml_vector = allocate_record(table_size);
d389 1
a389 2
    (void)SETFIELD(ml_vector, loop, MLUNIT);
  declare_root(&ml_vector);
d403 1
a403 1
	read_codeset(codeset_size, total_size, ml_vector, stream);
d418 1
a418 1
	(void)SETFIELD(ml_vector, offset, read_real(stream));
d429 1
a429 1
	(void)SETFIELD(ml_vector,offset,read_string(string_size,stream));
d445 1
a445 2
	  errno = ELOADEXTERNAL;
	  return(ERROR);
d451 1
a451 1
	(void)SETFIELD(ml_vector, offset, module);
d456 1
a456 2
      errno = ELOADFORMAT;
      return(ERROR);
d462 1
a462 3
  /* The garbage collector doesn't need to have the vector declared to */
  /* it any more: it's about to be passed to ML. */
  retract_root(&ml_vector);
d465 86
a550 4
  /* Do the call to build the module */
  in_ML = 1;
  result = callml(ml_vector, ml_vector);
  in_ML = 0;
@


1.26
log
@Returns ERROR to indicate error rather than IMPOSSIBLE.
@
text
@d12 3
d123 1
a123 2
 *  The sole purpose of this function is to declare load_external as a root
 *  so it won't be accidentally garbage collected.
d127 1
d132 1
d136 42
d242 2
a243 3
  mlval string ;
  char *code ;
  char *start ;
d247 1
a247 3
  string = allocate_string(total_size);
  code = CSTRING(string);
  start = code;
d249 1
d264 1
a264 3
    if(procedure == 0)
      (void)SETFIELD(ml_vector, position, string);
    else
d266 4
a269 4
      word offset = code - start + sizeof(word);

      if(double_align((word)code) != (word)code)
	error("read_codeset: procedures have become non-aligned.");
d271 1
a271 4
      (void)SETFIELD(ml_vector, position, MLPTR(POINTER, code));
      *(word *)code = MAKEHEAD(BACKPTR, offset);
      code += sizeof(word);
    }
d276 4
a279 2
    read(code, size, 1, stream);
    change_endian((word *)code, size);
d281 1
a281 1
    code += size;
d297 1
a297 1
mlval load_module (const char *filename, mlval modules, int profile)
a465 11
  if(profile)
  {
    profiling_turned_on = 1;
    set_up_profiler_interrupt();
  }
  else
  {
    profiling_turned_on = 0;
    profile_frequency(0);
  }

@


1.25
log
@Changed module table types.  See modules.h.
@
text
@d12 3
d277 1
a277 1
      return(IMPOSSIBLE);
d291 1
a291 1
    return(IMPOSSIBLE);
d301 1
a301 1
      return(IMPOSSIBLE);
d310 1
a310 1
    return(IMPOSSIBLE);
d335 1
a335 1
    return(IMPOSSIBLE);
d397 1
a397 1
	if(module == IMPOSSIBLE)
d401 1
a401 1
	  return(IMPOSSIBLE);
d413 1
a413 1
      return(IMPOSSIBLE);
@


1.24
log
@Fixes for the profiler
@
text
@d12 3
d248 3
a250 3
 *  function is called.  If the discard flag is true the module table
 *  parameter is discarded just before the setup function is called.  This
 *  allows its contents to be garbage collected.
d253 1
a253 1
mlval load_module (const char *filename, ModuleTable modules, int discard,int profile)
d260 2
d419 1
a419 4

  /* Allow the modules to be garbage collected (if possible) */
  if(discard)
    mt_discard(modules);
d431 2
a432 1
  };	
@


1.23
log
@Allowed comprehension of version 2, created when the magic number was
@
text
@d12 3
d422 1
a423 1
    profiling_turned_on = 1;
@


1.22
log
@Function called by value of ml_vector needs to declare it
@
text
@d12 3
d315 1
a315 1
    /* Version 1 is the highest version this loader can cope with. */
d317 1
@


1.21
log
@First version of the profiler
@
text
@d12 3
d184 3
a186 3
  mlval string = allocate_string(total_size);
  char *code = CSTRING(string);
  char *start = code;
d188 6
@


1.20
log
@Corrected calculatio of backpointers.
@
text
@d12 3
d94 1
d235 1
a235 1
mlval load_module (const char *filename, ModuleTable modules, int discard)
d404 10
@


1.19
log
@New module format.  Added code to deal with different module versions.
@
text
@d12 3
d199 1
a199 1
      word offset = code - start;
@


1.18
log
@Changed error behaviour and parameterised the module table.
@
text
@d12 3
d179 1
a179 1
  DIAGNOSTIC(2, "Loading codeset of %d procedures, size 0x%lX",
d190 2
a211 2
    DIAGNOSTIC(3, "Loaded procedure to 0x%lX size 0x%lX", code, size);

d230 1
a230 1
  word loop, opcode, module_size;
d275 2
a276 3
  /* Find endianess of object file, skip past the version number and code */
  /* size, and seek to the start of the code.  NOTE: Some error checking is */
  /* required here, I think. */
d282 3
a284 1
  (void)read_word(stream); (void)read_word(stream);
d287 8
a294 1
  module_size = read_word(stream);
d296 13
d310 2
a311 2
  ml_vector = allocate_record(module_size);
  for(loop = 0; loop < module_size; loop++)
d340 1
a340 1
        DIAGNOSTIC(2, "loader: Loading real to position 0x%lX", offset, 0);
d351 1
a351 1
        DIAGNOSTIC(2, "loader: Loading string to position 0x%lX", offset, 0);
d373 1
a373 1
        DIAGNOSTIC(2, "loader: External reference to module %s in "
@


1.17
log
@Never closed any files - it does now
@
text
@d1 1
a1 6
/*
 * loader.c
 * Load an individual module into the system
 * $Log: loader.c,v $
 * Revision 1.16  1992/01/14  13:32:03  richard
 * Changed the call of callml to pass the closure rather than the ml_vector
d3 1
a3 2
 * Revision 1.15  1992/01/09  16:23:52  richard
 * Fixed an error in the loading of codesets.
d5 3
a7 2
 * Revision 1.14  1991/12/23  13:18:42  richard
 * Changed the name of the fatal runtime error handler to error().
d9 62
a70 49
 * Revision 1.13  91/12/20  17:07:39  richard
 * Rewrote read_codeset so that it works.  Changed diagnostic output to be
 * switchable.
 * 
 * Revision 1.12  91/12/17  16:47:40  nickh
 * add in_ML flag.
 * 
 * Revision 1.11  91/12/17  16:35:41  richard
 * Added code to add suffices to module names.  Restricted the sizes
 * of reals to doubles only.
 * 
 * Revision 1.10  91/11/11  18:00:57  jont
 * Added read_real. Modified read_string to put the actual string length
 * into the header word, as opposed to the padded length
 * 
 * Revision 1.9  91/10/24  16:17:04  davidt
 * Changed name of callml.h to interface.h
 * 
 * Revision 1.8  91/10/23  16:46:51  davidt
 * Fixed size put into backpointers in codesets to be in bytes as required.
 * 
 * Revision 1.7  91/10/21  11:35:40  davidt
 * Made some minor changes and finished implementation of read_codeset.
 * read_codeset now reads each individual function in using one big
 * read and also puts in the separating backpointers between functions
 * in the same codeset.
 * 
 * Revision 1.6  91/10/18  16:10:31  davidt
 * Actually calls ML now! loader_error now takes three arguments.
 * Strings now have a word_aligned size.
 * 
 * Revision 1.5  91/10/17  16:58:47  davidt
 * Big hacks all over the place which have nearly got the thing loading
 * object files properly. Codesets are done properly yet.
 * 
 * Revision 1.4  91/10/16  14:04:42  davidt
 * Major revision after change to object file format (not quite
 * finished yet).
 * 
 * Revision 1.3  91/05/17  17:11:09  jont
 * Reals allocated as strings
 * 
 * Revision 1.2  91/05/15  15:32:14  jont
 * Revised interface for second version of load format
 * 
 * Revision 1.1  91/05/14  11:11:27  jont
 * Initial revision
 * 
 * Copyright (c) 1991 Harlequin Ltd.
a72 3
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
d86 5
a90 2
/* in_ML is used by the garbage collector to tell whether the ML stack
   is active */
a91 1
int in_ML = 0;
d93 4
a96 4
/*
 * This version of fread automatically checks to see if it prematurely
 * reached eof or had a read error. If so it prints an error message
 * and terminates.
d99 3
a101 2
static void loader_fread
  (char *buffer, int size, int num, FILE *file, char *message)
d103 1
a103 3
  fread(buffer, size, num, file);
  if (ferror(file) != 0 || feof(file) != 0)
    loader_error("Error in reading object file (%s)", message, 0);
d106 9
a114 3
/*
 * This function reads a word from the input file and handles
 * any endian conversion required.
d117 3
a119 1
static word read_word (FILE *file)
d121 2
a122 4
  word temp;
  loader_fread((char *)&temp, sizeof(word), 1, file, "read_word");
  change_endian(&temp, 1);
  return temp;
d125 3
a127 3
/*
 * This function will read a real number from the input file eventually.
 */
d129 6
a134 1
static mlval read_real(FILE *file)
d137 1
d139 1
a139 1
  loader_fread((char *)&the_real, sizeof(double), 1, file, "read_real");
d141 1
a141 1
  return ml_real;
d144 1
a144 6
/*
 * This function reads a string of string_size bytes into a string
 * area allocated on the ML heap.
 */

static mlval read_string(word string_size, FILE *file)
d147 3
a149 3
  loader_fread(CSTRING(ml_string), word_align(string_size), 1, file,
	       "read_string");
  return ml_string;
d168 1
a168 1
			 FILE *file)
d185 1
a185 1
    position = read_word(file);
d203 2
a204 2
    size = read_word(file);
    loader_fread(code, size, 1, file, "read_codeset");
d213 13
a225 1
mlval load_module (char *module_name, int final)
d229 1
a229 1
  FILE *file;
d234 1
a234 1
  file = fopen(module_name,"r");
d236 2
a237 2
  if(file == NULL &&
     strcmp(module_name + (length = strlen(module_name)) - 3, ".mo"))
d239 1
a239 1
    char *name_with_suffix = malloc(length + 3 + 1);
d242 4
a245 1
      error("load_module: unable to allocate memory for file name");
d247 1
a247 1
    strcpy(name_with_suffix, module_name);
d250 1
a250 1
    file = fopen(name_with_suffix, "r");
d255 5
a259 1
  if (file == NULL) loader_error("Couldn't open object file %s",module_name,0);
d261 3
a263 2
  /* Find endianess of object file */
  find_endian(module_name, read_word(file));
d265 6
a270 2
  /* Ignore the version number and code size. */
  (void)read_word(file); (void)read_word(file);
d272 10
a281 2
  /* Seek to start of code */
  fseek(file, read_word(file), 0);
d283 1
a283 2
  /* The number of elements to go in the vector */
  module_size = read_word(file);
d287 2
a288 6

  /* Clear vector so that garbage collector can scan it ok */
  for (loop = 0; loop < module_size; loop++)
    (void)SETFIELD(ml_vector, loop, NULL);

  /* The vector must be a root during garbage collection */
d294 1
a294 2
    /* Read opcode */
    opcode = read_word(file);
a295 1
    /* Decode opcode */
d298 1
a298 1
    case opcode_codeset:
d300 4
a303 4
	word codeset_size = read_word(file);
	word total_size = read_word(file);
	read_codeset(codeset_size, total_size, ml_vector, file);
	break;
d305 3
a307 1
    case opcode_real:
d309 3
a311 2
	word offset = read_word(file);
	word real_size = read_word(file);
d315 1
d318 1
a318 3
	/* Put object in vector */
	(void)SETFIELD(ml_vector, offset, read_real(file));
	break;
d320 3
a322 1
    case opcode_string:
d324 3
a326 2
	word offset = read_word(file);
	word string_size = read_word(file);
d329 1
a329 3
	/* Put object in vector */
	(void)SETFIELD(ml_vector,offset,read_string(string_size,file));
	break;
d331 3
a333 1
    case opcode_external:
a334 3
	word offset = read_word(file);
	word string_size = read_word(file);

d337 4
a340 2
	mlval name = read_string(string_size, file);
	mlval module = lookup_module(module_name, name);
d342 7
a351 1
	/* Put object in vector */
a352 1
	break;
a353 2
    default:
      loader_error("Unknown opcode 0x%x", opcode, 0);
d355 4
d362 1
a362 2
/* And close it again */
  fclose(file);
d365 1
a365 1
  /* it any more: It's about to be passed to ML. */
d369 2
a370 1
  if (final == FINAL) discard_module_table();
d377 1
a377 1
  return result;
@


1.16
log
@Changed the call of callml to pass the closure rather than the ml_vector
@
text
@d5 3
d312 3
@


1.15
log
@Fixed an error in the loading of codesets.
@
text
@d5 3
d319 1
a319 1
  result = callml(GETFIELD(ml_vector, 0), ml_vector);
@


1.14
log
@Changed the name of the fatal runtime error handler to error().
@
text
@d4 4
a7 1
 * $Log:	loader.c,v $
d177 2
a178 2
      (void)SETFIELD(ml_vector, offset, MLPTR(POINTER, code));
      *(word *)code = MAKEHEAD(offset, BACKPTR);
@


1.13
log
@Rewrote read_codeset so that it works.  Changed diagnostic output to be
switchable.
@
text
@d5 4
d172 1
a172 1
	runtime_error(1, "read_codeset: procedures have become non-aligned.");
d208 1
a208 1
      runtime_error(1, "load_module: unable to allocate memory for file name");
d263 2
a264 2
	  runtime_error(1, "loader: The runtime system can only cope with"
			   "reals of size 2 (doubles).");
@


1.12
log
@add in_ML flag.
@
text
@d5 3
d54 1
d64 3
a66 1
#include "debug.h"
d109 1
a109 1
  SETREAL(ml_real, the_real);
d126 11
a136 5
/*
 * This function reads a complete codeset into a string total_size
 * bytes long. It inserts the appropriate back pointers between the
 * individual functions and puts each function's start address into
 * the vector ml_vector at the specified offset.
d139 4
a142 2
static void read_codeset
  (word codeset_size, word total_size, mlval ml_vector, FILE *file)
d144 5
a148 3
  word *code_start = (word *)CPTR(allocate_string(total_size));
  word offset, loop, index, code_size;
  word *code = code_start;
d150 2
a151 3
  for (index = 0; index < codeset_size; index++) {
    /* Get offset in global vector where this function belongs */
    offset = read_word(file);
d153 5
a157 2
    /* Put in the backpointer (if necessary) */
    if (index > 0) *code = MAKEHEAD((code-code_start)*sizeof(word),BACKPTR);
d159 1
a159 2
    /* Diagnostics */
    DEBUG("[Code (address 0x%lx, offset 0x%lx)]\n",MLPTR(POINTER,code),offset);
d161 5
a165 2
    /* Put the start address of the function's code in ml_vector */
    SETFIELD(ml_vector, offset, MLPTR(POINTER,(word)code++));
d167 2
a168 2
    /* Get the size of this code */
    code_size = read_word(file);
d170 14
a183 4
    DEBUG("[Read code length 0x%lx into 0x%lx]\n", code_size, code);
    loader_fread((char *)code, code_size, 1, file, "read_codeset");
    change_endian(code, code_size);
    code += code_size;
d204 1
a204 1
      runtime_error("load_module: unable to allocate memory for file name");
d210 2
d219 2
a220 4
  /*
   * Skip past version number, size of loadable code, size of environment code,
   * size of debugging information and size of consistency information.
   */
a221 3
  read_word(file); read_word(file); read_word(file);
  read_word(file); read_word(file);

a224 3
  /* Diagnostics */
  DEBUG("[Seek to position 0x%lx]\n", ftell(file), 0);

d232 2
a233 1
  for (loop = 0; loop < module_size; loop++) SETFIELD(ml_vector, loop, NULL);
d239 2
a240 2
  for (loop = 0; loop < module_size; loop++) {

d245 2
a246 1
    switch (opcode) {
a248 1
	/* Read codeset size */
a249 1
	/* Read total size */
a250 3
	/* Diagnostics */
        DEBUG("[Codeset (size 0x%lx, total 0x%lx)]\n",codeset_size,total_size);
	/* Read code */
a255 1
	/* Read offset for this object */
a256 1
	/* Get size of real */
d259 4
a262 4
	  runtime_error("loader: The runtime system can only cope with"
			"reals of size 2 (doubles).");
	/* Diagnostics */
        DEBUG("[Real (position 0x%lx)]\n", offset, 0);
d264 1
a264 1
	SETFIELD(ml_vector, offset, read_real(file));
a268 1
	/* Read offset for this object */
a269 1
	/* Get size of string */
d271 2
a272 2
	/* Diagnostics */
        DEBUG("[String (size 0x%lx, position 0x%lx)]\n",string_size,offset);
d274 1
a274 1
	SETFIELD(ml_vector,offset,read_string(string_size,file));
a278 1
	/* Read offset for this object */
a279 1
	/* Get size of string */
d281 3
a283 1
	/* Read string */
a284 1
	/* Get pointer to modules */
d286 4
a289 2
	/* Diagnostics */
        DEBUG("[External (name %s, offset 0x%lx)]\n",CSTRING(name),offset);
d291 1
a291 1
	SETFIELD(ml_vector, offset, module);
d298 1
a298 1
  };
d300 2
a301 1
  /* We don't need the vector any more */
d307 1
a308 2

  /* Do the call to build the module */
@


1.11
log
@Added code to add suffices to module names.  Restricted the sizes
of reals to doubles only.
@
text
@d5 4
d62 5
d160 1
a160 1
  mlval ml_vector;
d288 7
a294 2
  /* Do the call to build the module and return the result */
  return callml(GETFIELD(ml_vector, 0), ml_vector);
@


1.10
log
@Added read_real. Modified read_string to put the actual string length
into the header word, as opposed to the padded length
@
text
@d5 4
d46 1
d89 1
a89 1
static mlval read_real(word real_size, FILE *file)
d91 4
a94 2
  mlval ml_real = allocate_real(real_size+1);
  loader_fread((CSTRING(ml_real))+4, real_size*4, 1, file, "read_real");
d152 2
d155 18
a172 2
  /* Open object file */
  FILE *file = fopen(module_name,"r");
d230 3
d234 1
a234 1
        DEBUG("[Real (size 0x%lx, position 0x%lx)]\n",real_size,offset);
d236 1
a236 1
	SETFIELD(ml_vector, offset, read_real(real_size, file));
@


1.9
log
@Changed name of callml.h to interface.h
@
text
@d5 3
d86 3
a88 1
  loader_error("Reals not implemented yet", 0, 0);
d99 2
a100 1
  loader_fread(CSTRING(ml_string), string_size, 1, file, "read_string");
d220 1
a220 1
	SETFIELD(ml_vector,offset,read_string(word_align(string_size),file));
@


1.8
log
@Fixed size put into backpointers in codesets to be in bytes as required.
@
text
@d5 3
d45 1
a45 1
#include "callml.h"
@


1.7
log
@Made some minor changes and finished implementation of read_codeset.
read_codeset now reads each individual function in using one big
read and also puts in the separating backpointers between functions
in the same codeset.
@
text
@d5 6
d114 1
a114 1
    if (index > 0) *code = MAKEHEAD(code - code_start, BACKPTR);
@


1.6
log
@Actually calls ML now! loader_error now takes three arguments.
Strings now have a word_aligned size.
@
text
@d5 4
d64 2
a65 1
  return change_endian(temp);
d85 1
a85 1
  loader_fread(CSTRING(ml_string), 1, string_size, file, "read_string");
d96 1
a96 1
static void read_code
d99 1
a99 2
  mlval ml_code = allocate_string(total_size);
  word *code = (word *)CSTRING(ml_code);
d101 1
d107 2
a108 2
    /* Put the start address of the function's code in ml_vector */
    SETFIELD(ml_vector, offset, ml_code);
d111 1
a111 1
    DEBUG("[Code (address 0x%lx, offset 0x%lx)]\n", ml_code, offset);
d113 3
d118 5
a122 6
    DEBUG("[Code size 0x%lx]\n", code_size, 0);
    for (loop = 0; loop < code_size; loop += 4) {
      *code = read_word(file);
      DEBUG("[Read code word 0x%lx into 0x%lx]\n", *code, code);
      code++;
    }
d162 1
a162 1
  declare_root(ml_vector);
d181 1
a181 1
	read_code(codeset_size, total_size, ml_vector, file);
d231 1
a231 1
  retract_root(ml_vector);
@


1.5
log
@Big hacks all over the place which have nearly got the thing loading
object files properly. Codesets are done properly yet.
@
text
@d5 4
d48 1
a48 1
    loader_error("Error in reading object file (%s)", message);
d69 1
a69 1
  loader_error("Reals not implemented yet", 0);
d113 1
a113 1
      DEBUG("[Read code word 0x%lx into ox%lx]\n", *code, code);
d126 1
a126 1
  if (file == NULL) loader_error("Couldn't open object file %s", module_name);
d198 1
a198 1
	SETFIELD(ml_vector, offset, read_string(string_size, file));
d218 1
a218 1
      loader_error("Unknown opcode 0x%x", opcode);
d226 1
a226 2
  loader_error("Successful load but no call yet", 0);

d229 2
a230 3
  /* Do the call to build the module
  callml(NULL, NULL, NULL, CSTRING(GETFIELD(ml_vector, 0)), ml_vector);
  */
@


1.4
log
@Major revision after change to object file format (not quite
finished yet).
@
text
@d2 1
a2 1
 * loader .c
a3 1
 * Needs work on tagging types of heap block
d5 4
d23 2
a24 1
#include "types.h"
d26 1
a26 2
#include "program.h"
#include "opcodes.h"
d28 1
a28 1
#include "call_out.h"
d30 2
d34 3
a36 1
 * The current module we are loading (for error reporting).
d39 7
a45 1
static char *global_module_name;
d48 2
a49 1
 * Generate error message for when we run out of heap.
d52 1
a52 1
static void allocation_error()
d54 3
a56 3
  fprintf(stderr, "\n[Loader error : Not enough store for '%s']\n",
	  global_module_name);
  exit (-1);
d60 1
a60 1
 * Generate general loader error message.
d63 1
a63 1
static void loader_error (char *str)
d65 1
a65 3
  fprintf(stderr, "[Loader error : Corrupt object file '%s' (%s)]\n",
	  global_module_name, str);
  exit (-1);
d69 2
a70 3
 * This version of fread automatically checks to see if it prematurely
 * reached eof or had a read error. If so it prints an error message
 * and terminates.
d73 1
a73 2
static void loader_fread
  (char *buffer, int size, int num, FILE *file, char *msg)
d75 3
a77 2
  fread(buffer, size, num, file);
  if (ferror(file) != 0 || feof(file) != 0) loader_error(msg);
d81 4
a84 2
 * This functions reads a word from the input file and handles
 * any endian conversion required.
d87 2
a88 1
static u_int32 read_word (FILE *file)
d90 3
a92 4
  u_int32 temp;
  loader_fread((char *)&temp, sizeof(u_int32), 1, file, "read_word");
  return handle_endian(temp);
}
d94 3
a96 4
static tuple_pointer read_real(u_int32 real_size, FILE *file)
{
  loader_error("Reals not implemented yet");
}
d98 2
a99 7
static tuple_pointer read_string(u_int32 string_size, FILE *file)
{
  tuple_pointer real_string = allocate_string(string_size);
  char *string = extract_ptr(real_string);
  if (string == NULL) allocation_error();
  loader_fread(string, 1, string_size, file, "read_string");
}
d101 11
a111 10
static void read_code
  (u_int32 codeset_size, u_int32 total_size, tuple_pointer vector, FILE *file)
{
  /* Returns NULL if failed */
  tuple_pointer real_code = allocate_string(total_size * sizeof(u_int32));
  tuple_pointer code = extract_ptr(real_code);
  u_int32 loop;
  if (code == NULL) allocate_error();
  for (loop = 0; loop < codeset_size; loop++) {
    code[loop].integer = read_word(file);
d115 1
a115 1
tuple_pointer load_module (char *module_name, FILE *file)
d117 2
a118 2
  u_int32 loop, opcode, module_size;
  tuple_pointer vector, real_vector;
d120 3
a122 2
  /* For error reporting */
  global_module_name = module_name;
d124 17
d145 1
a145 2
  real_vector = allocate_record(module_size);
  vector = extract_ptr(real_vector);
d148 1
a148 1
  for (loop = 0; loop < module_size; loop++) vector[loop].integer = 0;
d151 1
a151 1
  declare_root(vector);
d164 1
a164 1
	u_int32 codeset_size = read_word(file);
d166 5
a170 3
	u_int32 total_size = read_word(file);
	/* Read words */
	read_code(codeset_size, total_size, vector, file);
d176 1
a176 1
	u_int32 offset = read_word(file);
d178 3
a180 1
	u_int32 real_size = read_word(file);
d182 1
a182 1
	vector[offset].tuple = read_real(real_size, file);
d188 1
a188 1
	u_int32 offset = read_word(file);
d190 3
a192 1
	u_int32 string_size = read_word(file);
d194 1
a194 1
	vector[offset].tuple = read_string(string_size, file);
d200 1
a200 1
	u_int32 offset = read_word(file);
d202 1
a202 1
	u_int32 string_size = read_word(file);
d204 1
a204 1
	tuple_pointer string = read_string(string_size, file);
d206 3
a208 6
	tuple_pointer module = lookup_module_name(string);
	if (module == NULL) {
	  fprintf(stderr, "Unknown module '%s' referred to in '%s'\n", string,
		  global_module_name);
	  exit (-1);
	}
d210 1
a210 1
	vector[offset].tuple = module;
d214 1
a214 2
      fprintf(stderr, "\n[Unknown opcode 0x%s]\n", opcode);
      loader_error("unknown opcode");
d219 2
a220 2
  /* Check that we read all of the object file */
  if (feof(file) == 0) loader_error("Not all code read from module");
d222 1
a222 2
  /* Record this module to our table */
  add_module(module_name, vector[module_size - 1].tuple);
d224 5
a228 2
  /* We don't need the vector any more */
  retract_root(vector);
@


1.3
log
@Reals allocated as strings
@
text
@d6 3
d15 1
d19 1
d23 1
a23 1
#include "codes.h"
d28 3
a30 3
extern void *malloc(u_int32);
extern void free(void *);
/* These should be in stdlib, but we don't have a proper stdlib */
d34 3
a36 1
static tuple_pointer global_vector;
d38 1
a38 1
static u_int32 read_word(FILE *file, int *error)
d40 3
a42 6
u_int32 a;
fread(&a, sizeof(u_int32), 1, file);
if ferror(file) {
  fprintf(stderr, "Corrupt object file '%s' (run out of code)\n",
    global_module_name);
  *error = 1;
a43 2
return handle_endian(a);
}
d45 5
a49 1
static int check_size(int32 *size_remaining, int32 size)
d51 3
a53 7
*size_remaining -= size;
if (*size_remaining < 0) {
  fprintf(stderr, "Corrupt object file '%s' (run out of code)\n",
    global_module_name);
  return 1;
};
return 0;
d56 8
a63 1
static void read_string(char *string, u_int32 length, FILE *file, int *error)
d65 2
a66 4
if (fread(string, 1, length, file) != length) {
  fprintf(stderr, "Corrupt object file '%s' (run out of code)\n",
    global_module_name);
  *error = 1;
a67 1
}
d69 6
a74 3
static tagged_value read_record_element(int32 *size_remaining,
  FILE *file,
  int *error)
d76 3
a78 82
/* Read a single record element */
tagged_value value;
u_int32 code = read_word(file, error); /* An opcode */
if (*error || check_size(size_remaining, sizeof(u_int32))) return value;
switch (code) {
  u_int32 c,
          i;
  tuple_pointer module;
  char *string;
  case opcode_word_seqn:
  fprintf(stderr, "Corrupt object file '%s' (unexpected word_seqn)\n",
    global_module_name);
  *error = 1;
  return value;
  break;
  case opcode_record:
  fprintf(stderr, "Corrupt object file '%s' (unexpected record)\n",
    global_module_name);
  *error = 1;
  return value;
  break;
  case opcode_fun_call:
  fprintf(stderr, "Corrupt object file '%s' (unexpected fun_call)\n",
    global_module_name);
  *error = 1;
  return value;
  break;
  case opcode_int:
  c = read_word(file, error);
  if (*error || check_size(size_remaining, sizeof(u_int32))) return value;
  value.integer = tag_int(c);
  break;
  case opcode_real:
  fprintf(stderr, "Reals not yet implemented\n");
  *error = 1;
  return value;
  break;
  case opcode_string:
  fprintf(stderr, "Corrupt object file '%s' (unexpected string)\n",
    global_module_name);
  *error = 1;
  return value;
  break;
  case opcode_loc_ref:
  c = read_word(file, error);
  if (*error || check_size(size_remaining, sizeof(u_int32))) return value;
  value.tuple = global_vector[c].tuple;
  break;
  case opcode_ext_ref:
  c = read_word(file, error); /* String length, including terminator */
  if (*error || check_size(size_remaining, sizeof(u_int32))) return value;
  string = malloc(c);
  if (string == NULL) {
    fprintf(stderr, "Not enough store for '%s'\n", global_module_name);
    *error = 1;
    return value;
  }
  read_string(string, c, file, error);
  if (error || check_size(size_remaining, c)) return value;
  module = lookup_module_name(string);
  if (module == NULL) {
    fprintf(stderr, "Unknown module '%s' referred to in '%s'\n", string,
      global_module_name);
    *error = 1;
    return value;
  }
  free(string);
  c = read_word(file, error); /* index_size */
  if (*error || check_size(size_remaining, sizeof(u_int32))) return value;
  for (i = 0; i < c; i++) {
    u_int32 j = read_word(file, error); /* Index value */
    if (*error || check_size(size_remaining, sizeof(u_int32))) return value;
    module = ((tuple_pointer)(extract_ptr(module)))[j].tuple;
  }
  value.tuple = module; /* Fill in the final answer */
  break;
  default:
  fprintf(stderr, "Corrupt object file '%s' (unexpected token 0x%x)\n",
    global_module_name, code);
  *error = 1;
  return value;
  break;
a79 2
return value;
}
d81 1
a81 3
static tuple_pointer read_record(int32 *size_remaining,
  u_int32 length,
  FILE *file)
d83 1
a83 8
/* Read in and generate a record */
tuple_pointer real_where = allocate_record(length),
              where = extract_ptr(real_where);
u_int32 i = 0;
int error = 0;
if (where == NULL) {
  fprintf(stderr, "Not enough store for '%s'\n", global_module_name);
  return NULL;
a84 6
while (i < length) {
  where[i++] = read_record_element(size_remaining, file, &error);
  if (error) return NULL;
}
return real_where;
}
d86 1
a86 2
static tuple_pointer read_words(u_int32 length, FILE *file)
/* Returns NULL if failed */
d88 4
a91 7
tuple_pointer real_where = allocate_string(length*sizeof(u_int32)),
              where = extract_ptr(real_where);
int error = 0;
u_int32 i = 0;
if (where == NULL) {
  fprintf(stderr, "Not enough store for '%s'\n", global_module_name);
  return NULL;
a92 6
while (i < length) {
  where[i++].integer = read_word(file, &error);
  if (error) return NULL;
}
return real_where;
}
d94 2
a95 2

int load_module(char *module_name, FILE *file, int32 size_remaining)
d97 7
a103 76
int error = 0;
tuple_pointer return_value;
u_int32 i = 0,
        size;
tuple_pointer real_global_vector;
global_module_name = module_name; /* For error reporting */
size = read_word(file, &error); /* The number of elements */
if (error || check_size(&size_remaining, sizeof(u_int32))) return 1;
real_global_vector = allocate_record(size);
/* This will be the vector of all items read from this module */
global_vector = extract_ptr(real_global_vector);
if (global_vector == NULL) {
  fprintf(stderr, "Not enough store for '%s'\n", global_module_name);
  return 1;
}
while (i < size) global_vector[i++].integer = 0;
declare_root(global_vector);
for (i = 0; i < size; i++) {
  u_int32 code = read_word(file, &error); /* An opcode */
  if (error || check_size(&size_remaining, sizeof(u_int32))) return 1;
  switch (code) {
    u_int32 c;
    char *string;
    tuple_pointer real_string,
                  where;
    tagged_value  arg;
    case opcode_word_seqn:
    c = read_word(file, &error); /* Code length */
    if (error || check_size(&size_remaining, sizeof(u_int32))) return 1;
    where = read_words(c, file);
    if (extract_ptr(where) == NULL ||
      check_size(&size_remaining, c*sizeof(u_int32)))
      return 1;
    global_vector[i].tuple = where;
    break;
    case opcode_record:
    c = read_word(file, &error); /* Record size */
    if (error || check_size(&size_remaining, sizeof(u_int32))) return 1;
    where = read_record(&size_remaining, c, file);
    if (extract_ptr(where) == NULL) return 1;
    global_vector[i].tuple = where;
    break;
    case opcode_fun_call:
    c = read_word(file, &error); /* Record function number */
    if (error || check_size(&size_remaining, sizeof(u_int32))) return 1;
    arg = read_record_element(&size_remaining, file, &error);
    if (error) return 1;
    global_vector[i].tuple = call_ml_function(global_vector[c].tuple, arg);
    break;
    case opcode_int:
    fprintf(stderr, "Corrupt object file '%s' (unexpected int)\n",
      global_module_name);
    return 1;
    break;
    case opcode_real:
    fprintf(stderr, "Reals not yet implemented\n");
    return 1;
    break;
    case opcode_string:
    c = read_word(file, &error); /* String length, including terminator */
    if (error || check_size(&size_remaining, sizeof(u_int32))) return 1;
    real_string = allocate_string(c);
    string = extract_ptr(real_string);
    if (string == NULL) {
      fprintf(stderr, "Not enough store for '%s'\n", global_module_name);
      return 1;
    }
    read_string(string, c, file, &error);
    if (error || check_size(&size_remaining, c)) return 1;
    global_vector[i].tuple = real_string;
    break;
    default:
    fprintf(stderr, "Corrupt object file '%s' (unexpected token 0x%x)\n",
      global_module_name, code);
    return 1;
    break;
a105 8
if (size_remaining != 0) {
  fprintf(stderr, "Not all code read from module '%s'\n", global_module_name);
  return 1;
}
add_module(module_name, global_vector[size-1].tuple);
retract_root(global_vector);
return 0;
}
d107 39
a145 10
#if 0 /* A full switch template on all the opcodes */
  switch (code) {
    case opcode_word_seqn:
    break;
    case opcode_record:
    break;
    case opcode_fun_call:
    break;
    case opcode_int:
    break;
d147 9
a155 3
    fprintf(stderr, "Reals not yet implemented\n");
    return NULL;
    break;
d157 28
a184 5
    break;
    case opcode_loc_ref:
    break;
    case opcode_ext_ref:
    break;
d186 15
a200 7
    fprintf(stderr, "Corrupt object file '%s' (unexpected token 0x%x)\n",
      global_module_name, code);
    return NULL;
    break;
  }
#endif
/* End loader.c */
@


1.2
log
@Revised interface for second version of load format
@
text
@d6 3
d176 1
a176 1
tuple_pointer real_where = allocate_code(length),
@


1.1
log
@Initial revision
@
text
@d5 4
a8 1
 * $Log$
d17 2
d20 3
a22 5
typedef struct fn_header {
  int execute_now;
  tagged_value *closure;
  u_int32 *code;
} fn_header;
a23 8
typedef struct component_list *component_list;

typedef struct component_list {
  component_list     next;
  tagged_value      *where; /* Where to write the answer */
  value_by_component name;  /* How the compiler specified */
};

d26 1
a26 1
static component_list comp = NULL; /* Empty so far */
d40 1
a40 2
static int read_words(u_int32 *where, u_int32 length, FILE *file, int *error)
/* Returns 0 for ok, 1 for failed */
d42 6
a47 4
while (length-- > 0) {
  *(where++) = read_word(file, error);
  if (*error) return 1;
}
d60 3
a62 1
static int check_size(int32 *size_remaining, int32 size)
d64 11
a74 3
*size_remaining -= size;
if (*size_remaining < 0) {
  fprintf(stderr, "Corrupt object file '%s' (run out of code)\n",
d76 70
a145 3
  return 1;
};
return 0;
d147 2
d150 3
a152 2
static int read_name_by_components(tagged_value *where, int32 *size_remaining, FILE *file)
/* Returns 0 for ok, 1 for failed */
d154 6
a159 8
int error;
u_int32 a = read_word(file, &error); /* String length, including terminator */
char   *string;
tuple_pointer module;
component_list name;
if (error || check_size(size_remaining, sizeof(u_int32))) return 1;
string = allocate(a);
if (string == NULL) {
d161 1
a161 1
  return 1;
d163 3
a165 7
read_string(string, a, file, &error); /* Read the module name */
if (error || check_size(size_remaining, a)) return 1;
module = lookup_module_name(string);
if (module == NULL) {
  fprintf(stderr, "Unexpected module name '%s' in module '%s'\n", string,
    global_module_name);
  return 1;
d167 1
a167 6
a = read_word(file, &error); /* Read the number of components */
if (error || check_size(size_remaining, sizeof(u_int32))) return 1;
if (a == 0) {
  fprintf(stderr, "Empty component name in module '%s'\n",
    global_module_name);
  return 1;
d169 11
a179 16
name = allocate(sizeof(*name) + sizeof(u_int32)*(a-1));
/* This could be done off a malloc heap */
name->next = NULL;
name->where = where;
name->name.module = tag_ptr(module);
name->name.size = a;
if (read_words(name->name.components, a, file, &error) ||
  error || check_size(size_remaining, a*sizeof(u_int32))) return 1;
name->next = comp;
comp = name; /* Link in */
a = read_word(file, &error);
if (error || check_size(size_remaining, a*sizeof(u_int32))) return 1;
if (a != opcode_end_comp) {
  fprintf(stderr, "Corrupt object file '%s' (missing end_comp)\n",
    global_module_name);
  return 1;
d181 3
a183 1
return 0;
d185 2
d188 2
a189 1
static tagged_value *read_closure(int32 *size_remaining, FILE *file)
d191 1
a191 3
int error;
u_int32 a = read_word(file, &error),
        i;
d193 10
a202 3
if (error || check_size(size_remaining, sizeof(u_int32))) return NULL;
return_value = allocate((a+1)*sizeof(u_int32));
if (return_value == NULL) {
d204 1
a204 1
  return NULL;
d206 6
a211 5
return_value->size = tag_int(a);
for (i = 1; i <= a; i++) {
  u_int32 b = read_word(file, &error);
  if (error || check_size(size_remaining, sizeof(u_int32))) return NULL;
  switch (b) {
d214 11
a224 4
    case opcode_start_struct:
    fprintf(stderr, "Corrupt object file '%s' (unexpected start_struct)\n",
      global_module_name);
    return NULL;
d226 6
a231 4
    case opcode_end_struct:
    fprintf(stderr, "Corrupt object file '%s' (unexpected end_struct)\n",
      global_module_name);
    return NULL;
d233 6
a238 4
    case opcode_start_comp:
    if (read_name_by_components(return_value->values+i-1, size_remaining,
      file))
      return NULL;
d240 2
a241 1
    fprintf(stderr, "Corrupt object file '%s' (unexpected start_comp)\n",
d243 1
a243 1
    return NULL;
a244 10
    case opcode_end_comp:
    fprintf(stderr, "Corrupt object file '%s' (unexpected end_comp)\n",
      global_module_name);
    return NULL;
    break;
    case opcode_int:
    c = read_word(file, &error);
    if (error || check_size(size_remaining, sizeof(u_int32))) return NULL;
    return_value->values[i-1].integer = tag_int(c);
    break;
d247 1
a247 1
    return NULL;
d251 3
a253 2
    if (error || check_size(size_remaining, sizeof(u_int32))) return NULL;
    string = allocate(c);
d256 1
a256 1
      return NULL;
a257 1
    return_value->values[i-1].pointer = tag_ptr(string);
d259 2
a260 1
    if (error || check_size(size_remaining, c)) return NULL;
a261 15
    case opcode_fun_def:
    fprintf(stderr, "Corrupt object file '%s' (unexpected fun_def)\n",
      global_module_name);
    return NULL;
    break;
    case opcode_fun_appl:
    fprintf(stderr, "Corrupt object file '%s' (unexpected fun_appl)\n",
      global_module_name);
    return NULL;
    break;
    case opcode_word_seqn:
    fprintf(stderr, "Corrupt object file '%s' (unexpected start_struct)\n",
      global_module_name);
    return NULL;
    break;
d264 2
a265 2
      global_module_name, b);
    return NULL;
d269 3
a271 1
return return_value;
d273 3
a275 44

static void *read_fun_body(int execute_now, int32 *size_remaining, FILE *file)
{
u_int32 a;
int error;
tagged_value *closure = read_closure(size_remaining, file),
     *result;
u_int32 *where;
fn_header *header;
if (closure == NULL) return NULL;
a = read_word(file, &error);
if (error || check_size(size_remaining, sizeof(u_int32))) return NULL;
where = allocate(a*sizeof(u_int32));
if (where == NULL || read_words(where, a, file, &error)) return NULL;
header = allocate(sizeof(*header));
if (header == NULL) return NULL;
header->execute_now = execute_now;
header->closure = closure;
header->code = where;
return header;
#if 0
switch () {
  case opcode_start_struct:
  break;
  case opcode_end_struct:
  break;
  case opcode_start_comp:
  break;
  case opcode_end_comp:
  break;
  case opcode_int:
  break;
  case opcode_real:
  break;
  case opcode_string:
  break;
  case opcode_fun_def:
  break;
  case opcode_fun_appl:
  break;
  case opcode_word_seqn:
  break;
  default:
  break;
a276 2
#endif
}
d278 3
a280 68
static int resolve_pointers(void)
{
/* Fill in all values in function closures */
component_list list = comp;
tagged_value where;
while (list != NULL) {
  u_int32 i = 1;
  tuple_pointer ptr = list->name.module;
  while (i <= list->name.size) {
    u_int32 j = list->name.components[i-1];
    /* We could check here for the internal error */
    /* Do this for early versions */
    if (j >= ptr->size) {
      u_int32 i = 1;
      fprintf(stderr, "Internal error, component value %d is out of range\n",
        j);
      fprintf(stderr, "Should be at most %d\nComponent set is:\n", ptr->size);
      while (i <= list->name.size) {
	fprintf(stderr, "%d: %d\n", i, list->name.components[i-1]);
	i++;
      }
    }
    where = ptr->values[j]; /* May be an actual value */
    if (i++ < list->name.size) ptr = extract_ptr(where.tuple);
    /* Follow the chain if necessary */
  }
  *list->where = where;
  /* If these structures off a malloc heap, then we should free them */
  /* If not, we should lose the reference in comp */
  list = list->next;
}
return 0; /* Success */
}

static tuple_pointer execute_module(tuple_pointer module)
{
/* Make all function calls within module */
/* Not yet implemented ***************** */
return module;
}

static tuple_pointer load_structure(FILE *file, int32 *size_remaining)
{
u_int32 a, i;
int error = 0;
tuple_pointer return_value;
void *ptr;
a = read_word(file, &error); /* Read structure size (#elements) */
if (error || check_size(size_remaining, sizeof(u_int32))) return NULL;
return_value = allocate((a+1)*sizeof(u_int32));
if (return_value == NULL) {
  fprintf(stderr, "Not enough store for '%s'\n", global_module_name);
  return NULL;
}
return_value->size = tag_int(a);
for (i = 1; i <= a; i++) {
  /* Read the components of the structure */
  tuple_pointer internal_pointer;
  void *fn_ptr;
  u_int32 b = read_word(file, &error),
          c;
  char *string;
  if (error || check_size(size_remaining, sizeof(u_int32))) return NULL;
  switch(b) {
    case opcode_start_struct:
    internal_pointer = load_structure(file, size_remaining);
    if (internal_pointer == NULL) return NULL;
    return_value->values[i-1].tuple = tag_ptr(internal_pointer);
d282 1
a282 4
    case opcode_end_struct:
    fprintf(stderr, "Corrupt object file '%s' (unexpected end_struct)\n",
      global_module_name);
    return NULL;
d284 1
a284 4
    case opcode_start_comp:
    fprintf(stderr, "Corrupt object file '%s' (unexpected start_comp)\n",
      global_module_name);
    return NULL;
a285 5
    case opcode_end_comp:
    fprintf(stderr, "Corrupt object file '%s' (unexpected end_comp)\n",
      global_module_name);
    return NULL;
    break;
a286 3
    c = read_word(file, &error);
    if (error || check_size(size_remaining, sizeof(u_int32))) return NULL;
    return_value->values[i-1].integer = tag_int(c);
a292 10
    c = read_word(file, &error); /* String length, including terminator */
    if (error || check_size(size_remaining, sizeof(u_int32))) return NULL;
    string = allocate(c);
    if (string == NULL) {
      fprintf(stderr, "Not enough store for '%s'\n", global_module_name);
      return NULL;
    }
    return_value->values[i-1].pointer = tag_ptr(string);
    read_string(string, c, file, &error);
    if (error || check_size(size_remaining, c)) return NULL;
d294 1
a294 10
    case opcode_fun_def:
    /* Request execution for this function */
    ptr = read_fun_body(1, size_remaining, file);
    if (ptr == NULL) return NULL;
    return_value->values[i-1].pointer = tag_ptr(ptr);
    case opcode_fun_appl:
    /* Mark as not to be executed directly */
    ptr = read_fun_body(0, size_remaining, file);
    if (ptr == NULL) return NULL;
    return_value->values[i-1].pointer = tag_ptr(ptr);
d296 1
a296 4
    case opcode_word_seqn:
    fprintf(stderr, "Corrupt object file '%s' (unexpected word_seqn)\n",
      global_module_name);
    return NULL;
d300 1
a300 1
      global_module_name, b);
d304 1
a304 31
}
if (return_value == NULL) return NULL;
a = read_word(file, &error);
if (error || check_size(size_remaining, sizeof(u_int32))) return NULL;
if (a != opcode_end_struct) {
  fprintf(stderr, "Corrupt object file '%s' (missing end_struct)\n",
    global_module_name);
  return NULL;
}
return return_value;
}

tuple_pointer load_module(char *module_name, FILE *file, int32 *size_remaining)
{
u_int32 a;
int error = 0;
tuple_pointer return_value;
global_module_name = module_name; /* For error reporting */
a = read_word(file, &error);
if (error || check_size(size_remaining, sizeof(u_int32))) return NULL;
if (a != opcode_start_struct) {
  fprintf(stderr, "Corrupt object file '%s' (missing start_struct)\n",
    global_module_name);
  return NULL;
}
return (return_value = load_structure(file, size_remaining),
/* Now resolve the function closures */
  return_value != NULL && resolve_pointers())
/* Now execute the module */
    ? execute_module(return_value) : NULL;
}
@
