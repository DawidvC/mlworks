head	1.35;
access;
symbols
	Final_version_of_old_runtime:1.35
	ML_revised_beta_release_25/05/94:1.35
	ML_final_beta_release_02/03/94:1.32
	mlworks-28-01-1994:1.31
	Release:1.31
	mlworks-beta-01-09-1993:1.31
	MLWorks-1-0-3-21/12/1992:1.24
	MLWorks-1-0-2-15/12/1992:1.23
	MLWorks-1-0-1-04/12/1992:1.23
	checkpoint_17_08_92:1.22;
locks; strict;
comment	@ *  @;


1.35
date	94.03.29.15.57.28;	author johnk;	state Exp;
branches;
next	1.34;

1.34
date	94.03.29.15.55.53;	author johnk;	state Exp;
branches;
next	1.33;

1.33
date	94.03.25.16.45.04;	author nickh;	state Exp;
branches;
next	1.32;

1.32
date	94.01.28.17.23.37;	author nickh;	state Exp;
branches;
next	1.31;

1.31
date	93.06.02.13.11.21;	author richard;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	93.05.13.11.14.33;	author richard;	state Exp;
branches;
next	1.29;

1.29
date	93.04.29.14.23.38;	author richard;	state Exp;
branches;
next	1.28;

1.28
date	93.04.06.15.27.40;	author richard;	state Exp;
branches;
next	1.27;

1.27
date	93.03.01.17.12.52;	author nosa;	state Exp;
branches;
next	1.26;

1.26
date	93.02.24.14.05.42;	author nosa;	state Exp;
branches;
next	1.25;

1.25
date	93.02.12.14.05.54;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	92.12.18.15.20.25;	author clive;	state Exp;
branches;
next	1.23;

1.23
date	92.10.01.15.42.49;	author richard;	state Exp;
branches;
next	1.22;

1.22
date	92.08.07.08.49.52;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	92.08.05.18.04.57;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	92.08.05.12.48.17;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	92.08.04.16.19.15;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	92.08.04.13.48.01;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	92.07.31.11.12.23;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	92.07.31.11.00.40;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.07.29.14.26.13;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	92.07.29.12.22.01;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	92.07.21.13.42.22;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	92.07.16.16.36.30;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	92.07.16.16.23.38;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	92.07.15.15.46.08;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.07.14.15.56.06;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	92.07.06.09.31.11;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.07.03.07.23.28;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	92.06.30.08.50.43;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	92.06.11.15.43.33;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	92.05.14.10.19.57;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.05.06.13.47.52;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.05.05.11.07.01;	author clive;	state Exp;
branches;
next	1.1;

1.1
date	92.04.14.16.14.18;	author clive;	state Exp;
branches;
next	;

1.31.1.1
date	93.06.02.13.11.21;	author jont;	state Exp;
branches;
next	;


desc
@First version of the profiler
@


1.35
log
@ Bumped a revision.
@
text
@/*  ==== PROFILER ====
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Revision Log
 *  ------------
 *  $Log: profiler.c,v $
 *  Revision 1.34  1994/03/29  15:55:53  johnk
 *  Manually bumped.
 *
 *  Revision 1.33  1994/03/25  16:45:04  nickh
 *  General bug fixing.
 *
 *  Revision 1.32  1994/01/28  17:23:37  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.31  1993/06/02  13:11:21  richard
 *  Added extra parentheses around conditionals as suggested by GCC 2.
 *  Added overriding definition of inline.
 *
 *  Revision 1.30  1993/05/13  11:14:33  richard
 *  Added suspend and resume, and also stuff for call counting.
 *
 *  Revision 1.29  1993/04/29  14:23:38  richard
 *  Corrected the use of the large list of profile structures
 *  from profile_begin().
 *  Reinstated the profiler output header with general information.
 *
 *  Revision 1.28  1993/04/06  15:27:40  richard
 *  Another complete rewrite based on Nosa's multi-level profiler.
 *
 *  Revision 1.27  1993/03/01  17:12:52  nosa
 *  A Bug Fix
 *
 *  Revision 1.26  1993/02/24  14:05:42  nosa
 *  Implemented a multi-level profiler
 *
 *  Revision 1.25  1993/02/12  14:05:54  jont
 *  Changes for code vector reform
 *
 *  Revision 1.24  1992/12/18  15:20:25  clive
 *  Made the profiler take the generalised streams
 *
 *  Revision 1.23  1992/10/01  15:42:49  richard
 *  Added ansi.h.
 *
 *  Revision 1.22  1992/08/07  08:49:52  richard
 *  The profiler no longer maintains its own list of all code vectors
 *  but uses the weak list kept by the loader.  The weak list functions
 *  have been improved to allow the profiler to use them on that list.
 *
 *  Revision 1.21  1992/08/05  18:04:57  richard
 *  Added missing test in profile initialisation.
 *
 *  Revision 1.20  1992/08/05  12:48:17  richard
 *  Forgot to initialise the `miscellaneous' entry in the tables.
 *
 *  Revision 1.19  1992/08/04  16:19:15  richard
 *  Added some diagnostics.
 *
 *  Revision 1.18  1992/08/04  13:48:01  richard
 *  Added some missing roots.
 *
 *  Revision 1.17  1992/07/31  11:12:23  richard
 *  Added missing return of success code.
 *
 *  Revision 1.16  1992/07/31  11:00:40  richard
 *  Unregistered code vectors (stubs) may arise and are allowed.
 *
 *  Revision 1.15  1992/07/29  14:26:13  richard
 *  Added better error recovery.
 *
 *  Revision 1.14  1992/07/29  12:22:01  richard
 *  Each profiler table list may now contain multiple profiler entry
 *  structures.  This allows profile_begin() to allocate one large chunk
 *  of memory rather than thousands of small ones.
 *
 *  Revision 1.13  1992/07/21  13:42:22  richard
 *  The signal stack is now allocated by initialise.c.  Corrected the
 *  time interval calculation in start_timer().
 *
 *  Revision 1.12  1992/07/16  16:36:30  richard
 *  Removed is_ml_frame().  (Now implemented in the storage manager.)
 *
 *  Revision 1.11  1992/07/16  16:23:38  richard
 *  Removed is_ml_frame().  (Now implemented in the storage manager.)
 *
 *  Revision 1.10  1992/07/15  15:46:08  clive
 *  Temprary export of is_ml_frame until a better home is found for it
 *
 *  Revision 1.9  1992/07/14  15:56:06  richard
 *  Complete reimplementation without placing assumptions on the
 *  storage manager.  The profiler may now be `wrapped around'
 *  a computation in order to profile it, and sends it output to
 *  a specified stream.
 *
 *  Revision 1.8  1992/07/06  09:31:11  clive
 *  offsetof not defined in the headers - temporary fix
 *
 *  Revision 1.7  1992/07/03  07:23:28  richard
 *  Tried to eliminate some dependencies on the type checker and also some
 *  very poor C.
 *
 *  Revision 1.6  1992/06/30  08:50:43  richard
 *  Tidying, and moved in_ML here since it isn't (going to be) used
 *  from the storage manager.
 *
 *  Revision 1.5  1992/06/11  15:43:33  clive
 *  Fixed the bug where the stack interrupt stack was not being set up
 *  correctly
 *
 *  Revision 1.4  1992/05/14  10:19:57  clive
 *  Added some code for memory profiling and corrected some bugs
 *
 *  Revision 1.3  1992/05/06  13:47:52  clive
 *  Not clearing the global table pointer, when the table has been cleared
 *
 *  Revision 1.2  1992/05/05  11:07:01  clive
 *  Sort on name as well as number of calls
 *
 *  Revision 1.1  1992/04/14  16:14:18  clive
 *  Initial revision
 */

#include "ansi.h"
#include "syscalls.h"
#include "profiler.h"
#include "tags.h"
#include "values.h"
#include "diagnostic.h"
#include "interface.h"
#include "extensions.h"
#include "utils.h"
#include "allocator.h"
#include "global.h"
#include "loader.h"
#include "intercept.h"

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <setjmp.h>
#include <stdarg.h>

#include <sys/signal.h>
#include <sys/time.h>

/*  == Debugging hooks ==  */

int profile_select_all(mlval code)
{
  return(1);
}

void profile_print_stdout(const char *string)
{
  fputs(string, stdout);
}

#define CALLEE_TABLE_SIZE	16
#define OUTPUT_BUFFER_SIZE      80


/*  == Globals ==
 *
 *  profile_suspended	see profiler.h
 *  profile_on          1 if profiling, 0 otherwise
 *  profile_options	the current profiler options
 *  scans, gc_scans	# of stack scans, # of scans skipped because in GC
 *  re_entered_scans    # of scans re-entered (non-zero means a *bug*)
 *  nr_code_vectors	number of code vectors profiled
 *  frames		number of frames scanned in total
 *  ml_frames		number of ML frames scanned in total
 *  maximum_ml_frames	maximum depth of ML frames found in a single scan
 *  start, stop		profiler clock start and stop times,
 *  gaps		the time spent suspended
 *  profile_data_size   how many bytes have we allocated
 *  profile_roots       how many roots have we declared
 *
 * frames and ml_frames are kept as doubles to provide extra bits
 * (when scanning a stack of depth 500, 100 times each second, a
 * profile of around a day will overflow a 32-bit int; IEEE doubles
 * have another 20 bits of precision).
 */

int profile_suspended;
int profile_on;
static struct profile_options *profile_options;
static unsigned int scans, gc_scans, re_entered_scans;
static unsigned int nr_code_vectors, maximum_ml_frames;
static double frames, ml_frames;
static struct timeval start, stop, gaps;
static unsigned int profile_data_size, profile_roots;

/* == Profiling Structures ==
 * 
 * 1. Call count profiling
 * 
 * The profiler works by keeping a 'struct profile' (see below) for
 * each profiled code vector. This is pointed to by the 'profiles'
 * slot of the ancillaries for that code object. If the code vector
 * was compiled for tracing and call-counting, it is intercepted (by
 * calling intercept.c:code_intercept(), in profile_code() below), and
 * the intercept code increments the call count in the 'struct
 * profile'. (see intercept.c:count_call()). Call counting slows code
 * down substantially (each function entry point calls into C - many
 * tens of instructions - to increment the call count).
 * 
 * 2. Statistical profiling
 * 
 * Several other slots in 'struct profile' are used for statistical
 * profiling. The user can specify a stack scanning interval (in
 * milliseconds). When the stack is scanned, profiling records of
 * frames found are updated. Information is gathered on frames found,
 * frames found at the top of the stack, depth of recursion, and depth
 * of self-calling recursion. Code does not have to be compiled for
 * tracing and call-counting to be statistically profiled; profiing in
 * this manner is much less intrusive.
 *
 * 3. Multi-level statistical profiling
 * 
 * When scanning the stack, the profiler can gather frequency
 * information on 'foo called bar called baz' patterns (to a depth
 * specified by the user). This is done by generating 'struct
 * profile_caller' (see below) structures, containing slots for
 * statistical profiling ('found' and 'top' slots, the other
 * statistical slots from 'struct profile' being meaningless). Tables
 * of these structures are managed in 'struct profile_callers'
 * structures.  'struct profile' has a 'struct profile_callers'
 * substructure, to keep track of callers, and 'struct profile_caller'
 * does likewise.
 * 
 * For more comments on how these structures are updated when scanning
 * the stack, see the comment for 'struct callers_arrays' below.
 *
 */

/* struct profile_callers is an extensible table of callers, extended
 * when a specific caller is not found during find_caller() q.v. See
 * the comment on multi-level statistical profiling above. */

struct profile_callers
{
  size_t number, size;
  struct profile_caller *table;
};

/* struct profile is a top-level profile structure. See the comment on
 * profiling structures above.
 * 
 * 'calls' is the number of calls recorded by interception
 * 'code' is an ML pointer to the code vector; this is declared as a root.
 * 'callers' is a table of callers; see above.
 * 
 * 'updated' is the scan number of the last scan which found this code vector
 * 'depth' is the number of times it has been found in this scan
 * 'stack_depth' is the maximum number of times found in a single scan
 * 'stack_found' is the total number of times found in all scans
 * 'stack_top' is the number of times found on the top of the stack
 * 'stack_self' is the maximum contiguous stack depth found in any scan
 *
 */

struct profile
{
  unsigned int calls;		/* nr calls (must be first, see intercept.c) */

  mlval code;			/* code vector profiled */

  struct profile_callers callers;

  unsigned int updated;		/* scan nr of last update of this profile */
  unsigned int depth;		/* stack depth found in current scan */
  unsigned int stack_depth;	/* maximum nesting depth on the stack */
  unsigned int stack_found;	/* nr times found on the stack */
  unsigned int stack_top;	/* nr times found on the top of the stack */
  unsigned int stack_self;	/* maximum contiguous stack depth */
};

/* 'struct profile_caller' is as for 'struct profile', but without
 * fields which are meaningless for callers. See the comment on
 * profiling structures above.
 * 
 * The 'code' slot is a little different: we want to avoid having too
 * many GC roots, so if a caller is being profiled (i.e. has a 'struct
 * profile'), the 'code' slot in its 'struct profile_caller' points to
 * the 'code' slot in its 'struct profile', and is not declared as a
 * root.  Callers which are not profiled in their own right have the
 * regular code pointer in their 'code' slots, and those slots are
 * declared as roots.  So to find the code object of a profile_caller:
 * if the 'code' slot has a tagged ML value, it is the code pointer;
 * otherwise it points to the code pointer. This is done by
 * 'find_code()' below (q.v.)
 * 
 * 'stack_found' is the number of times this caller-chain has been
 * 	found on the stack.
 * 'stack_top' is the number of times it's been found at the top of
 * 	the stack.
 */

struct profile_caller
{
  struct profile_callers callers;
  mlval code;			/* code vector profiled (see comment) */

  unsigned int stack_found;	/* nr times found on the stack */
  unsigned int stack_top;	/* nr times found on the top of the stack */
};

/* The profile list is a doubly-linked list of sets of profile
 * structures, each of which contains one or more profile structures.
 * The sentinel of the list is profile_list, which contains a dummy
 * profile structure. This is used by profile_end to scan all the
 * profile structures for printing.
 * 
 * In practice, entries on this list are either (a) a large set
 * containing all the profiler structures at the time when profiling
 * began, or (b) a single profiler structure for a code vector loaded
 * since profiling began. The entry of type (a) is created in
 * profile_begin(). Entries of type (b) are created in profile_new(),
 * q.v.
 */

struct profile_set
{
  struct profile_set *forward, *back;
  size_t nr_entries;
  struct profile profile[1];
} profile_list = {&profile_list, &profile_list, 0};

/* find_code(): see comment on struct profile_caller above */

static inline mlval find_code(mlval code)
{
  if (!ISPTR(code))
    code = *(mlval *)code;

  return(code);
}

/*  == Initialise a profile table entry ==
 *
 *  Given a pointer to a profiling structure and a code vector
 *  value, these functions fill the structure with initial values.
 */

static inline void init_profile(struct profile *profile, mlval code)
{
  profile->callers.number = 0;
  profile->callers.size = 0;
  profile->callers.table = NULL;
  profile->code = code;
  profile->updated = 0;
  profile->depth = 0;

  profile->calls = 0;
  profile->stack_found = 0;
  profile->stack_top = 0;
  profile->stack_depth = 0;
  profile->stack_self = 0;
}

static inline void init_profile_caller (struct profile_caller *profile,
					mlval code)
{
  profile->callers.number = 0;
  profile->callers.size = 0;
  profile->callers.table = NULL;
  profile->code = code;

  profile->stack_found = 0;
  profile->stack_top = 0;
}

/*  == Change code for profiling ==
 *
 *  This code inserts the interception code to the profiled code vectors.
 *  profile_code() performs whatever changes are necessary.
 *  unprofile_code() removes those changes.
 *
 *  IMPORTANT: Profiling must interact sensibly with tracing, which uses
 *  code vector interception.  If the code is not already intercepted then
 *  the profiler intercepts it.  If it is already intercepted (or replaced)
 *  then nothing need be done because the code in intercept.c increments the
 *  call count if the PROFILE ancillary is set.
 */

static inline void profile_code(mlval code, struct profile *profile)
{
  CCODEANCUPDATE(code, PROFILES, (mlval)profile);

  /* If the code is not being traced, intercept it.  N.B. */
  /* Non-interceptable code is ignored. */
  if(CCODEANCSUB(code, INTERFNS) == MLUNIT)
    code_intercept(code);
}

static inline void unprofile_code(mlval code)
{
  CCODEANCUPDATE(code, PROFILES, (mlval)NULL);
  if(CCODEANCSUB(code, INTERFNS) == MLUNIT)
    code_nop(code);
}

/* tests whether a function is intercepted or not; could call
intercept.c:code_status but that's very inefficient in comparison. */

static inline int intercepted_code(mlval code)
{
  return (CINT(CCODEANCSUB(code,INTERCEPTS)) != -1);
}

/*  == Add code vector to profiler tables ==
 * 
 * This function is installed in loader_code_observer when profiling is on,
 * so it gets applied to any new code vectors loaded during profiling.
 * The code vector is given a profile list entry, then the code is
 * intercepted.
 */

static void profile_new(mlval code)
{
  DIAGNOSTIC(2, "profiler_new(0x%X) `%s'", code, CSTRING(CCODENAME(code)));

  if((struct profile *)CCODEANCSUB(code, PROFILES) != NULL)
    error("The code vector 0x%X was introduced to the profiler twice.", code);

  if(profile_on && (*profile_options->select)(code))
  {
    /* add a new single-element profile set to the profile list */

    struct profile_set *new = alloc(sizeof(struct profile_set), "profile_new");
    profile_data_size += sizeof(struct profile_set);
    new->forward = profile_list.forward;
    new->back = &profile_list;
    new->forward->back = new;
    new->back->forward = new;
    new->nr_entries = 1;

    init_profile(&new->profile[0], code);
    declare_root(&new->profile[0].code);
    profile_roots++;

    profile_code(code, &new->profile[0]);

    ++nr_code_vectors;
  }
}

/*  == Find a caller ==
 * 
 * Searches a caller table for a particular code vector.  If it isn't
 * found, a new struct profile_caller is created and added to the table.
 */

static struct profile_caller *find_caller(struct profile_callers *callee,
					  mlval code)
{
  size_t i;
  struct profile *caller;

  DIAGNOSTIC(2, "find_caller(callee = 0x%X, code = 0x%X)", callee, code);
  DIAGNOSTIC(2, "  caller name `%s'", CSTRING(CCODENAME(code)), 0);

  for(i=0; i<callee->number; ++i)
    if(find_code(callee->table[i].code) == code)
    {
      DIAGNOSTIC(2, "  found at 0x%X", &callee->table[i], 0);
      return(&callee->table[i]);
    }

  DIAGNOSTIC(2, "  not found -- allocating slot %d", i, 0);

  if(callee->number >= callee->size)
  { /* table not big enough */
    int j;
    /* retract any roots in the old object */
    for (j=0; j < callee->number; j++)
      if (ISPTR(callee->table[j].code))
	retract_root(&callee->table[i].code);
    
    /* enlarge the table */
    profile_data_size +=
      (callee->size ? callee->size : CALLEE_TABLE_SIZE)
	* sizeof(struct profile_caller);

    callee->size = callee->size ? callee->size * 2 : CALLEE_TABLE_SIZE;
    callee->table =
      (struct profile_caller *)
	realloc(callee->table,
		sizeof(struct profile_caller) * callee->size);
    if(callee->table == NULL)
      error("profiler: Unable to expand caller tables");

    /* redeclare any roots that we've just retracted */
    for (j=0; j < callee->number; j++)
      if (ISPTR(callee->table[j].code))
	declare_root(&callee->table[i].code);
	  
    DIAGNOSTIC(2, "  expanded caller table to %u at 0x%X",
	          callee->size, callee->table);
  }
  callee->number++;

  DIAGNOSTIC(2, "  new at 0x%X", &callee->table[i], 0);

  /* Initialize the caller record; 
   * can we use indirection through some other GC root? */

  caller = (struct profile *)CCODEANCSUB(code, PROFILES);
  if(caller == NULL)
  {
    init_profile_caller(&callee->table[i], code);
    declare_root(&callee->table[i].code);
    profile_roots++;
  }
  else
  {
    DIAGNOSTIC(2, "  caller has profile at 0x%X", caller, 0);
    init_profile_caller(&callee->table[i], (mlval)&caller->code);
  }

  return(&callee->table[i]);
}


/*  == Free caller tables ==
 *
 *  Recursively frees the caller tables, retracting as roots any code
 * members which are actually pointers to code vectors.  */

static void free_callers(struct profile_callers *callers)
{
  if(callers->table != NULL)
  {
    size_t i;

    for(i=0; i<callers->number; ++i)
    {
      if(ISPTR(callers->table[i].code))
	retract_root(&callers->table[i].code);

      free_callers(&callers->table[i].callers);
    }

    free(callers->table);
  }
}

/* == Callers table for stack scanning ==
 * 
 * For multi-level statistical profiling (see the big comment on
 * 'profiling structures' above), we must record each ML stack frame
 * in several places: once in its own 'struct profile', and n times
 * (for depth n), as a caller of n outer (that is, more recent) stack
 * frames. We keep an array 'callers_array', of length n, to record
 * the n 'struct profile_callers' in which the code object of the
 * current frame should be looked up.
 * 
 * This array is set up in profile_begin(), freed in profile_end(),
 * and cleared before each stack scan. For each stack frame,
 * update_callers_array() is called, which scans through the array
 * acting on and updating each member of it:
 * 
 *   The current stack frame is looked up in each member, and the
 *   'struct profile_caller' found is updated. If the 'callers' slot
 *   is NULL, the top-level frame on this chain was not being
 *   profiled, so nothing needs to be recorded for this chain. If the
 *   'top' slot is non-zero, the top-level frame on this chain was on
 *   top of the stack. Then the oldest record in the array is updated
 *   with the top-level 'struct profile' corresponding to the current
 *   stack frame.
 * 
 */

static struct callers_array
{
  struct profile_callers *callers; /* NULL if this chain not profiled */
  int top;	                   /* 1 if this chain on top of stack */
} *callers_array;

static inline void create_callers_array(void)
{
  /* allocate an array of the necessary depth */
  if (profile_options->depth) {
    int array_size = sizeof(struct callers_array) * profile_options->depth;
    callers_array = (struct callers_array *)
      alloc(array_size, "create_callers_array");
    profile_data_size += array_size;
  } else
	callers_array = NULL;
}

static inline void free_callers_array(void)
{
  if (profile_options->depth)
    free(callers_array);
}

static inline void clear_callers_array(void)
{
  int i;
  for(i = 0; i<profile_options->depth; i++) {
    callers_array[i].callers = NULL;
  }
}

/* see the big comment above */

static inline void update_callers_array(int callers_index,
					mlval code,
					struct profile *profile,
					int top)
{
  int i;
  /* loop through each array member */
  for (i=0; i<profile_options->depth; i++) {
    if (callers_array[i].callers != NULL) {
      struct profile_caller *caller = find_caller(callers_array[i].callers,
						  code);
      caller->stack_found++;
      if (callers_array[i].top)
	caller->stack_top++;
      
      callers_array[i].callers = &caller->callers;
    }
  }
  /* overwrite the array member for this stack frame */
  callers_array[callers_index].callers =
    profile ? &profile->callers : NULL;
  callers_array[callers_index].top = top;
}

/*  === Periodic Stack Scanning ===
 * 
 * A virtual time alarm is set up by start_timer() which calls
 * alarm().  alarm() examines the stack and records information about
 * the code vectors it finds there.
 *
 *  NOTE: A signal stack is set up for the alarm handler in initialise.c.
 */

static struct itimerval timer;

static void alarm(int sig, int sig_code, struct sigcontext *scp, char *addr)
{
  static int entered = 0;
  unsigned int ml_frames_found, frames_found, self, top, callers_index;
  struct profile *profile = NULL;
  mlval code = MLUNIT, previous = MLUNIT;
  struct stack_frame *sp = (struct stack_frame *)scp->sc_sp;

  if(entered) {
    /* this is probably a bug, since we haven't set up the timer yet */
    re_entered_scans++;
    return;

  } else if (!in_GC) {
    /* can only scan the stack if we're not garbage-collecting */
    entered = 1; 
    scans++;
    
    top = 1;
    ml_frames_found = 0;
    frames_found = 0;
    self = 0;
    clear_callers_array();
    callers_index = 0;

    for(;;) { /* scan the stack */
      
      /* skip any C frames */
      
      while (sp != NULL && (code = is_ml_frame(sp)) == MLUNIT) {
	previous = MLUNIT;  /* 'foo calls C calls foo' is not a self-call */
	sp = sp->fp;
	++frames_found;
      }
      
      /* have we reached the bottom of the stack? */
      if (sp == NULL)
	break;
      
      ++ml_frames_found;
      
      profile = (struct profile *)CCODEANCSUB(code, PROFILES);
      
      if(profile != NULL) {
	/* do the profiling information */
	/* how many times found? */
	profile->stack_found++;
	
	/* how many times found on top?*/
	if (top)
	  profile->stack_top++;
	
	/* how many self-calls: 'maximum contiguous stack frames' */
	if(code == previous) {
	  ++self;
	  if (self > profile->stack_self)
	    profile->stack_self = self;
	} else
	  self = 0;
	
	/* how many recursions: 'maximum times found in a single scan' */
	if (profile->updated == scans) {
	  ++profile->depth;
	  if (profile->depth > profile->stack_depth)
	    profile->stack_depth = profile->depth;
	} else {
	  profile->depth = 0;
	  profile->updated = scans;
	}
      }
      
      /* do the multi-level profiling information */
      if (profile_options->depth) {
	update_callers_array(callers_index, code, profile, top);
	callers_index = ((callers_index+1) % profile_options->depth);
      }
      
      previous = code;
      top = 0;
      sp = sp->fp;
      ++frames_found;
    }
    /* finished the scan; update the globals */

    if (ml_frames_found > maximum_ml_frames)
      maximum_ml_frames = ml_frames_found;
    
    ml_frames += ml_frames_found;
    frames += frames_found;

  } else /* we're in the GC */
    gc_scans++;

  /* set up the timer to do the next scan */
  if(setitimer(ITIMER_VIRTUAL, &timer, NULL) == -1)
    message("Warning: Unable to set profile timer (setitimer set errno "
	    "to %d).  Frequency profiling will not occur.", errno);
  
  entered = 0;
}

/* start things off */

static void start_timer(unsigned int interval)
{
  struct sigvec vec = {alarm, SIGVTALRM, SV_ONSTACK};

  if(sigvec(SIGVTALRM, &vec, NULL) == -1)
    error("Unable to set up profiler signal handler.");

  timer.it_value.tv_sec = interval/1000;
  timer.it_value.tv_usec = (interval%1000)*1000;
  timer.it_interval.tv_sec = 0;
  timer.it_interval.tv_usec = 0; /* one shot timer */

  if(setitimer(ITIMER_VIRTUAL, &timer, NULL) == -1)
    message("Warning: Unable to set profile timer (setitimer set errno "
	    "to %d).  Stack scan profiling will not occur.", errno);
}

/* kill the timer */

static void stop_timer(void)
{
  struct sigvec vec = {SIG_DFL, SIGVTALRM, SV_ONSTACK};

  timer.it_value.tv_sec = timer.it_value.tv_usec = 0;
  timer.it_interval.tv_sec = timer.it_interval.tv_usec = 0;

  if(setitimer(ITIMER_VIRTUAL, &timer, NULL) == -1)
  {
    message("Warning: Unable to unset profile timer (setitimer set errno "
	    "to %d).  Future alarm signals will be ignored.", errno);
    vec.sv_handler = SIG_IGN;

    if(sigvec(SIGVTALRM, &vec, NULL) == -1)
      /* this is an error because we can't stop profiling */
      error("Unable to reset alarm signal handler (sigvec set errno to %d).",
	    errno);
  }
  if(sigvec(SIGVTALRM, &vec, NULL) == -1)
    /* this is not a serious error: we've turned off the clock anyway */
    message("Warning: Unable to reset alarm signal handler (sigvec set errno "
	    "to %d).", errno);
}

/*  === Initialise ===
 *
 *  Initialise the profiler global state.
 */

void profile_init(void)
{
  profile_options = NULL;
  profile_on = 0;
}


/*  === Output ===  */

/* Write output to output buffers before printing it, since it has to
 * go to C or ML depending on the profile options. */

struct output_buffer
{
  char *start;
  size_t size;
};

/* ensure our buffer is big enough */

static void buffer_size(struct output_buffer *buffer, size_t minimum)
{
  if(buffer->start && buffer->size >= minimum)
    return;

  if(buffer->start)
  {
    buffer->size *= 2;
    buffer->start = (char *)realloc(buffer->start, buffer->size);

    if(buffer->start == NULL)
      error("buffer_size: Unable to allocate memory for profiler output.");
  }
  else
  {
    buffer->size =
      minimum > OUTPUT_BUFFER_SIZE ?
	minimum : OUTPUT_BUFFER_SIZE;
    buffer->start = alloc(buffer->size, "buffer_size");
  }
}

/* print any string, to C or ML */

static inline void print(const char *string)
{
  if(profile_options->printer_type == PROFILE_OPT_C)
    (*profile_options->print.c)(string);
  else
    callml(ml_string (string), profile_options->print.ml);
}

/* function to print one line for a caller record. Arguments are:
 *
 * buffer: output buffer to use
 * top: profile struct for the top-level function
 * stack: array of pointers to profile_caller structs for the caller chain
 * depth: how far down the chain are we?
 */

static inline void print_nested(struct output_buffer *buffer,
				struct profile *top,
				struct profile_caller *stack[],
				size_t depth)
{
  struct profile_caller *p = stack[depth];
  int i;
  size_t offset, length;
  mlval code = top->code;
  char *name = CSTRING(CCODENAME(code));

  DIAGNOSTIC(4, "compose(buffer=0x%X, stack=0x%X", buffer, stack);
  DIAGNOSTIC(4, "        depth=%d) p=0x%X", depth, p);

  buffer_size(buffer, 80+strlen(name));
  (void) sprintf(buffer->start, 
		 "          %8u  %8u                       %s",
		 p->stack_found, p->stack_top, name);
  offset = strlen(buffer->start);

  for(i=0; i<= depth; ++i)
  {
    code = find_code(stack[i]->code);
    name = CSTRING(CCODENAME(code));
    length = strlen(name)+2;

    buffer_size(buffer, offset+length+1);
    (void) sprintf(buffer->start+offset, "; %s", name);
    offset+= length;
  }

  strcat(buffer->start, "\n");
  print(buffer->start);
}

/* Nested output for all lines below the top-level; calls itself
 * recursively. */

static void output_nested (struct output_buffer *buffer,
			   struct profile *top,
			   struct profile_caller *stack[],
			   size_t depth)
{
  size_t i;

  DIAGNOSTIC(4, "output(buffer=0x%X", buffer, 0);
  DIAGNOSTIC(4, "       stack=0x%X, depth=%u)", stack, depth);

  print_nested (buffer, top, stack, depth);

  for(i=0; i<stack[depth]->callers.number; ++i)
  {
    stack[depth+1] = & (stack[depth]->callers.table[i]);
    output_nested (buffer, top, stack, depth+1);
  }
}

/* Output all the lines for a top-level profile struct */

static void output_top_level (struct output_buffer *buffer,
			      struct profile *top,
			      struct profile_caller *stack[])
{
  mlval code = top->code;
  char *name = CSTRING(CCODENAME(code));
  int i;

  buffer_size(buffer,80+strlen(name));

  if (intercepted_code (code))
    sprintf(buffer->start,"%8u  %8u  %8u  %8u  %8u   %s\n",
	    top->calls, top->stack_found, top->stack_top,
	    top->stack_depth, top->stack_self, name);
  else
    sprintf(buffer->start,"       -  %8u  %8u  %8u  %8u   %s\n",
	    top->stack_found, top->stack_top,
	    top->stack_depth, top->stack_self, name);
    
    print(buffer->start);
  for (i=0; i<top->callers.number; i++) {
    stack[0] = & (top->callers.table[i]);
    output_nested (buffer, top, stack, 0);
  }
}

/*  === clock times using getrusage ===
 *
 * Could use clock(3), but that wraps around after 2147 seconds.
 *
 */

static inline void getuclock(struct timeval *pt)
{
  struct rusage rusage;

  if (getrusage(RUSAGE_SELF, &rusage))
    error ("getrusage failed in profiler's getuclock\n");

  *pt = rusage.ru_utime;
}
  
/*  === PROFILING CONTROL ===
 *
 *  A period of time is profiled by calling profile_begin() before it, and
 *  profile_end() after it.
 *
 *  The begin routine initialises the profiler tables, using the list of all
 *  current code vectors.  It then start the virtual time alarm, if
 *  required, to perform stack scanning.
 *
 *  The end code writes out the collected information in the profiler table
 *  and deallocates it.
 */

/* 'table' points to a profile_set containing all of the currently
 * profiled code vectors */

static struct profile_set *table;

/* add a code vector to the table, if it fits the selection criterion */

static mlval table_add(unsigned int index, mlval code)
{
  int i;

  if((*profile_options->select)(code))
  {
    DIAGNOSTIC(2, "  registering 0x%X `%s'", code, CSTRING(CCODENAME(code)));

    i = table->nr_entries++;
    init_profile(&table->profile[i], code);
    declare_root(&table->profile[i].code);
    profile_roots++;

    profile_code(code, &table->profile[i]);

    ++nr_code_vectors;
  }

  return(code);
}

/* start profiling */

int profile_begin(struct profile_options *options)
{
  struct profile_set *list;
  size_t length;

  DIAGNOSTIC(1, "profile(options = 0x%X)", options, 0);

  if(profile_on)
  {
    DIAGNOSTIC(1, "  already running!", 0, 0);
    errno = EPROFILENEST;
    return(-1);
  }

  profile_on = 1;

  loader_code_observer = profile_new;
  profile_options = options;

  /* Create a single large block of profile structures for the code vectors */
  /* already in existence. */

  length = weak_length(loader_code);
  DIAGNOSTIC(1, "  %u code vectors", length, 0);

  list = alloc(sizeof(struct profile_set) - sizeof(struct profile) +
	       sizeof(struct profile)*length, "profile_begin");

  list->nr_entries = 0;
  list->forward = profile_list.forward;
  list->back = &profile_list;
  list->forward->back = list;
  list->back->forward = list;

  scans = 0;
  frames = ml_frames = maximum_ml_frames = 0;

  /* Add the existing code vectors to the large table. */

  nr_code_vectors = 0;
  profile_roots = 0;
  table = list;
  weak_apply(loader_code, table_add);

  DIAGNOSTIC(1, "  %u code vectors selected", list->nr_entries, 0);

  /* Shrink the large table to reflect the number of code vectors actually */
  /* selected. */

  length =
    sizeof(struct profile_set) - sizeof(struct profile) +
      sizeof(struct profile)*list->nr_entries;

  table = (struct profile_set *) realloc(table, length);
  profile_data_size = length;

  /* set up timer and callers array */

  create_callers_array();
  getuclock (&start);
  gaps.tv_sec = gaps.tv_usec = 0;
  start_timer(profile_options->interval);

  return(0);
}

/* suspend and resume; not currently used but they're nice to have */

int profile_suspend(void)
{
  if(!profile_on)
  {
    errno = EPROFILENEST;
    return(-1);
  }

  if(profile_suspended++)
  {
    getuclock(&stop);
    stop_timer();
  }

  return(0);
}

int profile_resume(void)
{
  if(!profile_on)
  {
    errno = EPROFILENEST;
    return(-1);
  }

  if(!--profile_suspended)
  {
    struct timeval suspend;

    getuclock(&suspend);
    gaps.tv_sec += suspend.tv_sec-stop.tv_sec;
    gaps.tv_usec += suspend.tv_usec-stop.tv_usec;
    start_timer(profile_options->interval);
  }

  return(0);
}

/* finish profiling and print the profile report */

int profile_end(void)
{
  struct profile_caller *stack[PROFILE_DEPTH_MAX];
  struct output_buffer buffer = {NULL, 0};
  char print_buffer[1024];
  struct profile_set *list;
  long profile_time;

  if(!profile_on)
  {
    errno = EPROFILENEST;
    return(-1);
  }

  stop_timer();
  {
    long secs, usecs;
    getuclock(&stop);
    secs = stop.tv_sec - gaps.tv_sec - start.tv_sec;
    usecs = stop.tv_usec - gaps.tv_usec - start.tv_usec;
    profile_time = (secs * 1000) + (usecs / 1000);
  }
      
  free_callers_array();

  /* report header */

  sprintf(print_buffer,
	  "MLWorks profiler v4.0\n"
	  "%u bytes of data, %u roots\n"
	  "profile period: %u ms\n"
	  "functions profiled: %u\n",
	  profile_data_size, profile_roots,
	  profile_time, nr_code_vectors);
  print(print_buffer);

  if(scans)
  {
    sprintf(print_buffer,
	    "scans: %u\n"
	    "(%u in GC, %u re-entered)\n"
	    "frames scanned: %.0f\n"
	    "ML frames scanned: %.0f (%3.1f%%)\n"
	    "mean stack depth: %.2f\n"
	    "maximum ML stack depth: %u\n"
	    "mean ML stack depth: %.2f\n",
	    scans, gc_scans, re_entered_scans,
	    frames, ml_frames, (ml_frames/frames)*100.0,
	    frames/scans, maximum_ml_frames, ml_frames/scans);
    print(print_buffer);
  }

  print("---\n"
	"   calls     found       top     depth      self      name\n");


  /* print all the profile report lines */

  list = profile_list.forward;
  while(list != &profile_list)
  {
    struct profile_set *next = list->forward;
    size_t i;

    for(i=0; i<list->nr_entries; ++i)
      output_top_level(&buffer, &list->profile[i], stack);

    list = next;
  }

  /* uprofile everything, retract the roots, free the structures */

  list = profile_list.forward;
  while(list != &profile_list)
  {
    struct profile_set *next = list->forward;
    size_t i;

    for(i=0; i<list->nr_entries; ++i)
    {
      struct profile *profile = &list->profile[i];

      unprofile_code(profile->code);
      retract_root(&profile->code);

      free_callers(&profile->callers);
    }

    free(list);

    list = next;
  }

  /* Empty the profile table list */
  profile_list.forward = profile_list.back = &profile_list;

  loader_code_observer = NULL;
  profile_options = NULL;
  profile_on = 0;

  return(0);
}
@


1.34
log
@Manually bumped.
@
text
@d8 3
@


1.33
log
@General bug fixing.
@
text
@d8 3
@


1.32
log
@Moved extern function declarations to header files.
@
text
@d8 3
a153 2


d158 1
a158 1
/*  == Global parameters ==
d161 1
d163 2
a164 1
 *  scans		number of stack scans
d169 9
a177 1
 *  start, stop, gaps	profiler clock start and stop times, and the time spent suspended
d181 1
d183 73
a255 20
static unsigned int scans, frames;
static unsigned int ml_frames, maximum_ml_frames, nr_code_vectors;
static clock_t start, stop, gaps;


/*  == Code vector profile ==
 *
 *  The profiler collects information about code vectors into structures of
 *  this form. code is a pointer to a code vector address (allows the
 *  optimisation whereby only one declare and retract root call is
 *  sufficient for any such address); profile is a boolean indicating
 *  whether the code vector is selected to be profiled; caller is a pointer
 *  to a linked list of records of callers for the code vector; next is a
 *  pointer to a linked list of records of callers of callers for the code
 *  vector.
 *
 *  The code field is used strangely.  If it is tagged as a pointer then it
 *  refers directly to a code vector and is also declared as a garbage
 *  collector root.  If it is tagged as an integer then it is a C pointer to
 *  another such value and is not a root.
d262 4
a265 3
  size_t nr_callers, caller_table;
  struct profile *callers;
  mlval code;			/* code vector profiled (see above) */
d268 1
a268 1

a270 1
  unsigned int stack_depth;	/* maximum nesting depth on the stack */
d274 29
d304 12
a315 6
/*  == Profile list ==
 *
 *  The profile list is a doubly-linked list of profile structures, each of
 *  which contains one or more profile structure for a different code
 *  vector.  The sentinel of the list is profile_list, which contains a
 *  dummy profile structure.
d318 1
a318 1
struct list
d320 1
a320 1
  struct list *forward, *back;
d325 1
d327 1
a327 6
/*  == Follow a chain of code pointers ==
 *
 *  See comment next to struct profile declaration.
 */

static inline mlval follow(mlval code)
d329 1
a329 1
  while(!ISPTR(code))
a334 1

d337 2
a338 3
 *  Given a pointer to an entry structure and a pointer to a code vector
 *  value this function fills the profile with initial values and updates
 *  the profiler slot in the code vector to point at its call count.
d343 3
a345 3
  profile->nr_callers = 0;
  profile->caller_table = 0;
  profile->callers = NULL;
d357 11
d371 1
a371 1
 *  The code vector itself is `altered' for the purposes of profiling.
d399 2
d402 5
d408 5
a412 6
 *
 *  First, the code vector is added to the list of all code vectors.
 *  If the profile_stream is not NULL then the profiler is currently
 *  running, then the code vector is given a new profiler table entry.
 *  Otherwise, all code vectors are profiled using the default entry, which
 *  is kept in profile_list.
d422 1
a422 1
  if(profile_options && (*profile_options->select)(code))
d424 1
a424 1
    struct list *new = alloc(sizeof(struct list), "profile_new");
d426 2
d436 1
a443 1

d445 3
a447 3
 *
 *  Searches the caller list for the profile corresponding to a particular
 *  code vector.  If it isn't found, a new one is created.
d450 2
a451 1
static struct profile *find_caller(struct profile *callee, mlval code)
a456 1
  DIAGNOSTIC(2, "  callee name `%s'", CSTRING(CCODENAME(follow(callee->code))), 0);
d459 2
a460 2
  for(i=0; i<callee->nr_callers; ++i)
    if(follow(callee->callers[i].code) == code)
d462 2
a463 2
      DIAGNOSTIC(2, "  found at 0x%X", &callee->callers[i], 0);
      return(&callee->callers[i]);
d468 19
a486 12
  if(++callee->nr_callers > callee->caller_table)
  {
    callee->caller_table =
      callee->caller_table ?
	callee->caller_table * 2 :
	CALLEE_TABLE_SIZE;

    callee->callers =
      (struct profile *)realloc(callee->callers,
				sizeof(struct profile) * callee->caller_table);

    if(callee->callers == NULL)
d489 5
d495 1
a495 1
	          callee->caller_table, callee->callers);
d497 1
d499 1
a499 1
  DIAGNOSTIC(2, "  new at 0x%X", &callee->callers[i], 0);
d501 3
d507 3
a509 2
    init_profile(&callee->callers[i], code);
    declare_root(&callee->callers[i].code);
d514 1
a514 1
    init_profile(&callee->callers[i], (mlval)&caller->code);
d517 1
a517 1
  return(&callee->callers[i]);
d523 2
a524 3
 *  Recursively frees the caller tables, freeing any code members which are
 *  actually pointers to code vectors.
 */
d526 1
a526 1
static void free_callers(struct profile *profile)
d528 3
a530 1
  size_t i;
d532 1
a532 3
  if(profile->callers != NULL)
  {
    for(i=0; i<profile->nr_callers; ++i)
d534 2
a535 2
      if(ISPTR(profile->callers[i].code))
	retract_root(&profile->callers[i].code);
d537 1
a537 1
      free_callers(&profile->callers[i]);
d540 1
a540 1
    free(profile->callers);
d544 24
a567 9


/*  === PERIODIC STACK SCANNING ===
 *
 *  A virtual time alarm is set up by start_timer() which calls alarm() at
 *  regular intervals.  alarm() examines the stack and records information
 *  about the code vectors it finds there.
 *
 *  NOTE: A signal stack is set up for the alarm handler in initialise.c.
d570 5
a574 1
static struct itimerval timer;
d576 1
a576 3
static inline struct stack_frame *find_ml_frame(struct stack_frame *sp,
						mlval *code_pointer,
						unsigned int *frames_pointer)
d578 9
a586 1
  mlval code = MLUNIT;
d588 4
a591 10
  while(sp != NULL && (code = is_ml_frame(sp)) == MLUNIT)
  {
    sp = sp->fp;
    if(frames_pointer) ++*frames_pointer;
  }

  if(code_pointer)
    *code_pointer = code;

  return(sp);
d594 1
a594 2
static inline void examine(struct profile *profile, struct stack_frame *sp,
			   int scans, int self, int top)
d597 4
a600 1
  mlval code;
d602 1
a602 3
  DIAGNOSTIC(2, "examine(profile = 0x%X, sp = 0x%X", profile, sp);
  DIAGNOSTIC(2, "        scans = %d, self = %d,", scans, self);
  DIAGNOSTIC(2, "        top = %d)", top, 0);
d604 16
a619 16
  i = profile_options->depth;
  for(;;)
  {
    DIAGNOSTIC(2, "  depth %d: `%s'", i, CSTRING(CCODENAME(follow(profile->code))));

    ++profile->stack_found;

    if(top)
      ++profile->stack_top;

    if(profile->updated == scans)
      ++profile->depth;
    else
    {
      profile->depth = 0;
      profile->updated = scans;
d621 6
d628 8
a635 2
    if(profile->depth > profile->stack_depth)
      profile->stack_depth = profile->depth;
d637 1
a637 13
    if(self > profile->stack_self)
      profile->stack_self = self;

    if(i-- == 0)
      break;

    sp = find_ml_frame(sp->fp, &code, NULL);
    if(sp == NULL)
      break;

    profile = find_caller(profile, code);
  }
}
d642 3
a645 3
  unsigned int ml_frames_found, self = 0, top;
  struct profile *profile = NULL, *previous = NULL;
  mlval code;
d647 3
a649 1
  if(entered)
d652 2
a653 2
  if(!in_GC)		/* can't scan stack if GC is playing with it */
  {
d655 1
a655 1
    ++scans;
d659 21
a679 3

    while((sp = find_ml_frame(sp, &code, &frames)))
    {
d681 12
a692 6

      ++ml_frames_found;

      if(profile)
      {
	if(profile == previous)
d694 3
a696 1
	else
d698 16
a713 2

	examine(profile, sp, scans, self, top);
d715 2
a716 2

      previous = profile;
a717 1

d719 1
a719 1
      ++frames;
d721 1
d723 1
a723 1
    if(ml_frames_found > maximum_ml_frames)
d727 4
a730 1
  }
d732 1
d740 1
d759 2
d775 1
a778 1

d780 1
d785 1
a785 3


/*  === INITIALISE ===
d787 1
a787 2
 *  This is here for historical reasons, and because we may need to do
 *  something in future.
d793 1
d797 1
a797 1
/*  === OUTPUT ===  */
d799 3
d808 2
d832 3
a834 1
static mlval print(mlval out, const char *string)
d839 2
a840 2
  {
    mlval s, arg;
d842 7
a848 13
    declare_root(&out);
    s = ml_string(string);
    declare_root(&s);
    arg = allocate_record(2);
    FIELD(arg, 0) = out;
    FIELD(arg, 1) = s;
    retract_root(&s);
    retract_root(&out);
    out = callml(arg, profile_options->print.ml.fold);
  }

  return(out);
}
d850 4
a853 2
static void compose(struct output_buffer *buffer,
		    struct profile *stack[], size_t depth)
d855 1
a855 1
  struct profile *p = stack[depth-1];
d857 3
d864 15
a878 14
  buffer_size(buffer, 80);
  sprintf(buffer->start, "%8u  %8u  %8u  %8u  %8u   ",
	  p->calls, p->stack_found, p->stack_top,
	  p->stack_depth, p->stack_self);

  for(i=0; i<depth; ++i)
  {
    mlval code = follow(stack[i]->code);
    char *name = CSTRING(CCODENAME(code));
    size_t length = strlen(buffer->start);
    size_t more = strlen(name) + (i?2:0);

    buffer_size(buffer, length+more+1);
    sprintf(buffer->start+length, "%s%s", i?"; ":"", name);
d882 1
d884 3
a886 1
  
d888 4
a891 3
static mlval output(mlval out,
		    struct output_buffer *buffer,
		    struct profile *stack[], size_t depth)
d895 1
a895 1
  DIAGNOSTIC(4, "output(out=0x%X, buffer=0x%X", out, buffer);
d898 1
a898 3
  compose(buffer, stack, depth);

  out = print(out, buffer->start);
d900 1
a900 1
  for(i=0; i<stack[depth-1]->nr_callers; ++i)
d902 2
a903 2
    stack[depth] = &stack[depth-1]->callers[i];
    out = output(out, buffer, stack, depth+1);
d905 11
d917 16
a932 1
  return(out);
d935 15
d964 7
a970 1
static struct list *table;
d982 1
d992 1
d996 1
a996 1
  struct list *list;
d1001 1
a1001 1
  if(profile_options || loader_code_observer)
d1008 2
d1019 1
a1019 1
  list = alloc(sizeof(struct list) - sizeof(struct profile) +
d1034 1
d1043 12
a1054 7
  table = (struct list *)
    realloc(table,
	    sizeof(struct list) - sizeof(struct profile) +
	    sizeof(struct profile)*list->nr_entries);

  start = clock();
  gaps = 0;
d1060 2
d1064 1
a1064 1
  if(!profile_options)
d1072 1
a1072 1
    stop = clock();
d1079 1
a1079 1
int profile_resumt(void)
d1081 1
a1081 1
  if(!profile_options)
d1089 5
a1093 1
    gaps += clock() - stop;
d1100 2
d1104 1
a1104 1
  struct profile *stack[PROFILE_DEPTH_MAX];
d1107 2
a1108 2
  mlval out;
  struct list *list;
d1110 1
a1110 1
  if(!profile_options)
d1117 9
a1125 1
  stop = clock();
d1127 1
a1127 4
  if(profile_options->printer_type == PROFILE_OPT_ML)
    out = profile_options->print.ml.out;
  else
    out = MLUNIT;
d1130 7
a1136 4
	  "MLWorks profiler v3.0\n"
	  "profile period: %ums\nfunctions profiled: %u\n",
	  (stop-gaps-start)/(CLK_TCK/1000), nr_code_vectors);
  out = print(out, print_buffer);
d1141 5
a1145 2
	    "scans: %u\nframes scanned: %u\nML frames scanned: %u (%3.1f%%)\n"
	    "mean stack depth: %u\n"
d1147 3
a1149 3
	    "mean ML stack depth: %u\n",
	    scans, frames, ml_frames,
	    ((double)ml_frames/(double)frames)*100.0,
d1151 1
a1151 1
    out = print(out, print_buffer);
d1154 3
a1156 3
  out = print(out, 
	      "---\n"
	      "   calls     found       top     depth      self      name\n");
d1158 2
d1163 1
a1163 1
    struct list *next = list->forward;
d1167 1
a1167 6
    {
      struct profile *profile = &list->profile[i];

      stack[0] = profile;
      out = output(out, &buffer, stack, 1);
    }
d1172 2
d1177 1
a1177 1
    struct list *next = list->forward;
a1182 3
      mlval code = follow(profile->code);

      unprofile_code(code);
d1184 2
a1185 2
      if(ISPTR(profile->code))
	retract_root(&profile->code);
d1187 1
a1187 1
      free_callers(profile);
d1200 1
a1203 2


@


1.31
log
@Added extra parentheses around conditionals as suggested by GCC 2.
Added overriding definition of inline.
@
text
@d8 4
d117 1
a137 6
extern int setitimer(int which,
		     struct itimerval *value,
		     struct itimerval *ovalue);
extern int sigvec(int sig,struct sigvec *vec, struct sigvec *ovec);
extern long int clock(void);

@


1.31.1.1
log
@Fork for bug fixing
@
text
@a7 4
 *  Revision 1.31  1993/06/02  13:11:21  richard
 *  Added extra parentheses around conditionals as suggested by GCC 2.
 *  Added overriding definition of inline.
 *
@


1.30
log
@Added suspend and resume, and also stuff for call counting.
@
text
@d8 3
a138 4
#ifdef DEBUG
#define inline
#endif

d511 1
a511 1
    while(sp = find_ml_frame(sp, &code, &frames))
@


1.29
log
@Corrected the use of the large list of profile structures
from profile_begin().
Reinstated the profiler output header with general information.
@
text
@d8 5
d120 1
d161 1
d168 1
a168 1
 *  start, stop		profiler clock start and stop times
d171 1
d175 1
a175 1
static clock_t start, stop;
d197 2
a204 1
  unsigned int calls;		/* nr calls */
d266 31
a324 1
    CCODEANCUPDATE(code, PROFILES, (mlval)&new->profile[0]);
d326 2
d633 1
a633 1
static mlval print(mlval out, char *string)
a731 1
    CCODEANCUPDATE(code, PROFILES, (mlval)&table->profile[i]);
d733 2
d752 1
a752 1
    errno = EPROFILERUNNING;
d794 1
d800 34
d842 6
d859 1
a859 1
	  (stop-start)/(CLK_TCK/1000), nr_code_vectors);
d907 1
a907 1
      CCODEANCUPDATE(code, PROFILES, (mlval)NULL);
d928 2
@


1.28
log
@Another complete rewrite based on Nosa's multi-level profiler.
@
text
@d8 3
d268 1
a268 1
  DIAGNOSTIC(1, "profiler_new(0x%X) `%s'", code, CSTRING(CCODENAME(code)));
d390 2
a391 1
						mlval *code_pointer)
d396 1
d398 2
d444 1
a444 1
    sp = find_ml_frame(sp->fp, &code);
d471 1
a471 1
    while(sp = find_ml_frame(sp, &code))
d491 1
d620 3
d649 3
d682 2
d686 1
a686 1
    DIAGNOSTIC(1, "  registering 0x%X `%s'", code, CSTRING(CCODENAME(code)));
d688 4
a691 3
    init_profile(&table->profile[index], code);
    declare_root(&table->profile[index].code);
    CCODEANCUPDATE(code, PROFILES, (mlval)&table->profile[index]);
d717 3
d726 1
a726 1
  list->nr_entries = length;
d735 2
d741 10
d761 1
a767 18
/*
  print("MLWorks profiler v2.0\n"
	"profile period: %ums\nfunctions profiled: %u\n",
	(stop-start)/(CLK_TCK/1000), nr_code_vectors);

  if(frames != 0)
    print("scans: %u\nframes scanned: %u\nML frames scanned: %u (%3.1f%%)\n"
	  "mean stack depth: %u\n"
	  "maximum ML stack depth: %u\n"
	  "mean ML stack depth: %u\n",
	  scans, frames, ml_frames,
	  ((double)ml_frames/(double)frames)*100.0,
	  frames/scans, maximum_ml_frames, ml_frames/scans);

  print("---\n"
	"   calls     found       top     depth      self      name\n");
*/

d772 23
@


1.27
log
@A Bug Fix
@
text
@d8 3
d85 2
a86 1
 *  Fixed the bug where the stack interrupt stack was not being set up correctly
d121 3
a123 1
extern int setitimer(int which, struct itimerval *value, struct itimerval *ovalue);
d125 1
d127 3
a130 1
#define PARENT(type, field, pointer) ((type *)((char *)(pointer)-(char *)&(*(type *)0).field))
d132 1
d134 1
a134 13
/* some parameters global to profiling; these are input from the user; 
 * profile_all says whether to profile all the source code or selected bits of it;
 * profile_level is the level of profiling;
 * profile_list is the list of tags of selected bits of code to profile by
 *  (substrings of code vector names)
 */
static short profile_all;
static short profile_level;
static struct profile_list *to_profile;

/* the equivalent operators for lists in C for profile-list handling 
*/
struct profile_list *CONS(const char *string,struct profile_list *to_profile)
d136 1
a136 9
  struct profile_list *profile = to_profile;
  to_profile = (struct profile_list *)malloc(sizeof(struct profile_list));
  if(to_profile != NULL)
    {
      to_profile->string = string;
      to_profile->next = profile;
      return(to_profile);
    };
  error("Unable to allocate memory for profile list");
d138 2
a139 1
char *HEAD(struct profile_list *to_profile)
d141 1
a141 3
  if(to_profile == NULL)
    error("HEAD of empty profile list");
  return(to_profile->string);
a142 24
struct profile_list *TAIL(struct profile_list *to_profile)
{
  if(to_profile == NULL)
    error("TAIL of empty profile list");
  return(to_profile->next);
}
struct profile_list *CONVERT(mlval list)
{
  mlval ml_list;
  struct profile_list *to_profile = NULL, *last = NULL;
  for(ml_list = list; ml_list != MLNIL; ml_list = MLTAIL(ml_list))
    {
      to_profile = (struct profile_list *)malloc(sizeof(struct profile_list));
      if(to_profile != NULL)
	{
	  to_profile->string = CSTRING(MLHEAD(ml_list));
	  to_profile->next = last;
	  last = to_profile;
	}
      else
	error("Unable to allocate memory for profile list");
    }
  return(to_profile);
}
d144 23
d170 6
a175 5
 *  this form. code is a pointer to a code vector address(allows the optimisation
 *  whereby only one declare and retract root call is sufficient for any such address);
 *  profile is a boolean indicating whether the code vector is selected to be profiled;
 *  caller is a pointer to a linked list of records of callers for the code vector;
 *  next is a pointer to a linked list of records of callers of callers for the code 
d177 5
d186 11
a196 16
  struct profile_entry
    {
      mlval *code;			/* code vector profiled */
      short *profile;			/* profile this? */
      unsigned int calls;		/* number of calls */
      unsigned int stack_found;	/* number of times found on the stack */
      unsigned int stack_top;	/* number of times found on the top of the stack */
      unsigned int stack_depth;	/* maximum nesting depth on the stack */
      unsigned int stack_self;	/* maximum contiguous stack depth */
      struct profile_entry *caller, *next;
    } callee;
  
  unsigned int allocs;		/* number of allocations */
  size_t alloc_total;		/* total words allocated */
  size_t alloc_largest;		/* largest object allocated */
  size_t alloc_smallest;	/* smallest object allocated */
d202 1
a202 1
 *  The profile list is a doubly-linked list of entry structures, each of
d204 2
a205 2
 *  vector.  The sentinel of the list is profile_list, which also contains
 *  the default profile structure used for unknown or disabled functions.
d212 2
a213 7
  struct entry
  {
    struct profile profile;
    unsigned int updated;	/* the last time this entry was updated */
    unsigned int stack_depth;	/* stack depth found in current scan */
  } entry[1];
};
a214 5
static void (*profile)
  (struct entry *entry,struct entry *previous, struct profile_entry *profile, 
   struct profile_entry **next_profiles, struct stack_frame **sp, 
   struct profile_entry *next_profile, unsigned int top, unsigned int *self) = NULL;
static void (*print_entry) (struct entry *entry) = NULL;
d216 1
a216 6
struct list profile_list =
{&profile_list, &profile_list, 1,
   {{{{NULL, NULL, 0, 0, 0, 0, 0, NULL, NULL}, 0, 0, 0, 0}, 0, 0}}};


/*  == Global parameters ==
d218 1
a218 8
 *  scans		number of stack scans
 *  nr_code_vectors	number of code vectors profiled
 *  frames		number of frames scanned in total
 *  ml_frames		number of ML frames scanned in total
 *  maximum_ml_frames	maximum number of ML frames found in a single scan (depth)
 *  profile_stream	stream to which profiler results will be written
 *  profile_stream_type stream is a FILE * (otherwise a closure to be called )
 *  start, stop		profiler clock start and stop times
d221 4
a224 4
static unsigned int scans, frames, ml_frames, maximum_ml_frames, nr_code_vectors;
mlval profile_stream = MLUNIT;
int profile_stream_type = 0;
clock_t start, stop;
d226 2
d232 3
a234 3
 *  Given a pointer to an entry structure and a code vector this function
 *  fills the profile with initial values and updates the profiler slot in
 *  the code vector to point at its call count.
d237 1
a237 1
static void init_entry(struct entry *entry, mlval code)
d239 6
a244 16
  entry->updated = 0;
  entry->stack_depth = 0;
  entry->profile.callee.caller = NULL;
  entry->profile.callee.next = NULL;
  entry->profile.callee.code = (mlval *)malloc(sizeof(mlval));
  *entry->profile.callee.code = code;
  entry->profile.callee.profile = NULL;
  entry->profile.callee.calls = 0;
  entry->profile.callee.stack_found = 0;
  entry->profile.callee.stack_top = 0;
  entry->profile.callee.stack_depth = 0;
  entry->profile.callee.stack_self = 0;
  entry->profile.allocs = 0;
  entry->profile.alloc_total = 0;
  entry->profile.alloc_largest = 0;
  entry->profile.alloc_smallest = 0;
d246 5
a250 5
  if(code != MLUNIT)
  {
    CCVPROFILE(code) = (mlval)&entry->profile.callee.calls;
    declare_root(entry->profile.callee.code);
  }
d265 1
a265 2
  static int memory_warning = 0;
  struct list *new = NULL;
d267 1
a267 3
  DIAGNOSTIC(2, "profiler_new(0x%X) `%s'", code, CCVNAME(code));

  if(CCVPROFILE(code) != PROFILE_DISABLE)
d270 1
a270 1
  if(profile_stream == MLUNIT)
d272 1
a272 3
    CCVPROFILE(code) = (mlval)&profile_list.entry[0].profile.callee.calls;
    return;
  }
a273 4
  new = (struct list *)malloc(sizeof(struct list));

  if(new != NULL)
  {
d279 5
a283 1
    init_entry(&new->entry[0], code);
d286 53
d341 21
a361 1
    if(!memory_warning)
d363 4
a366 4
      message("Warning: Unable to allocate memory for further profiling "
	      "information.  Some functions requested may be profiled "
	      "under `miscellaneous'.");
      memory_warning = 1;
d369 1
a369 1
    CCVPROFILE(code) = (mlval)&profile_list.entry[0].profile.callee.calls;
d386 2
a387 4
/* fetch the required number of records for callers from the present callee 
 */
void fetch_callers(struct entry *entry,struct profile_entry **profiles,
		   struct profile_entry **callers)
d389 1
a389 66
  short n;
  struct profile_entry value = {NULL,NULL,0,0,0,0,0,NULL,NULL}, *prev_caller = NULL, *Caller,
  *caller = entry->profile.callee.caller;
  for(n = 0; n != profile_level-1; ++n)
    {
      if(profiles[n] == NULL)
	{
	  callers[n] = NULL;
	  return;
	}
      else
	{
	  for(Caller = caller; Caller != NULL; Caller = Caller->caller)
	    {
	      prev_caller = Caller;
	      if(Caller->code == profiles[n]->code)
		{
		  callers[n] = Caller;
		  break;
		}
	    };
	  if(prev_caller == NULL)
	    {
	      if(n == 0)
		{
		  entry->profile.callee.caller = 
		    (struct profile_entry *)malloc(sizeof(struct profile_entry));
		  caller = entry->profile.callee.caller;
		}
	      else
		{
		  callers[n-1]->next = 
		    (struct profile_entry *)malloc(sizeof(struct profile_entry));
		  caller = callers[n-1]->next;
		}
	      if(caller != NULL)
		{
		  *caller = value;
		  caller->code = profiles[n]->code;
		  callers[n] = caller;
		}
	      else
		error("Unable to allocate memory for further profiling information");
	    }
	  else 
	    {
	      if(Caller == NULL)
		{
		  prev_caller->caller = 
		    (struct profile_entry *)malloc(sizeof(struct profile_entry));
		  if(prev_caller->caller != NULL)
		    {
		      *prev_caller->caller = value;
		      prev_caller->caller->code = profiles[n]->code;
		      callers[n] = prev_caller->caller;
		    }
		  else
		    error("Unable to allocate memory for further profiling information");
		};
	    }
	  caller = callers[n]->next;
	  prev_caller = NULL;
	}
    };
  return;
}
d391 2
a392 7
/* determine if any strings in the profile-list are a substring of the name 
 * of the present code vector 
 */
int substring(char *name, char *string)
{
  char *prev_name;
  char *string_start = string;
d394 4
a397 18
  while(*name != '\0')
    {	    
      prev_name = name;
      while((*name == *string) || (*name == ' '))
	{
	  ++name;
	  if(*name != ' ')
	    ++string;
	  if(*string == '\0')
	      return(1);
	  if(*name == '\0')
	      return(0);  
	}
      name = prev_name;
      string = string_start;
      ++name;
    };
  return(0);
d400 2
a401 5
/* determine if this code vector is selected to be profiled;
 * update the profile component of the profile structure to prevent any further 
 * such tests
 */
int member(struct profile_entry *profile)
d403 2
a404 1
  struct profile_list *list;
d406 3
a408 3
  if(profile->profile == NULL)
    {
      char *name = CCVNAME(*profile->code);
d410 4
a413 17
      profile->profile = (short *)malloc(sizeof(short));
      for(list = to_profile; list != NULL; list = TAIL(list))
	{
	  char *head;
	  head = HEAD(list);
	  if(substring(name,head))
	    {
	      *profile->profile = 1;
	      return(1);
	    }
	}
      *profile->profile = 0;
      return(0);
    }
  else 
    return(*profile->profile);
}
d415 1
a415 5
/* determine if any of a collection of code vectors are selected to be profiled
 */
int members(struct profile_entry **profiles)
{
  short n;
d417 2
a418 9
  for(n = 0; n != profile_level-1; ++n)
    {
      if(profiles[n] == NULL)
	return(0);
      if(member(profiles[n]))
	return(1);
    };
  return(0);
}
d420 3
a422 7
/* fetch an ML-frame from the stack
 */
struct profile_entry *fetch_ml_frame(struct stack_frame **sp, short increment_frames)
{
  mlval code = MLUNIT;
  
  while((code == MLUNIT) && (*sp != NULL))
d424 2
a425 14
      if(increment_frames)
	++frames;
      code = is_ml_frame(*sp);
      *sp = (*sp)->fp;
    };
  if(code == MLUNIT)
      return(NULL);
  else
    {
      unsigned int *call_count = (unsigned int *)CCVPROFILE(code);
      if(call_count == NULL)
	  return(NULL);
      else
	  return(PARENT(struct profile_entry, calls, call_count));
a426 1
}
d428 2
a429 6
/* fetch the required number of profiles of code vectors from the stack
 */
void fetch_next_profiles(struct profile_entry **profiles, struct profile_entry *profile, 
			 struct stack_frame **sp)
{
  short n = 1;
d431 2
a432 1
  profiles[0] = profile;
d434 2
a435 19
  while(n != profile_level-1)
    {
      if((n == profile_level-2) || (profiles[n+1] == NULL))
	{
	  do
	    {
	      profiles[n] = fetch_ml_frame(sp,0);
	      if(profiles[n] == NULL)
		return;
	    }
	  while(profiles[n] == profile);
	}
      else 
	profiles[n] = profiles[n+1];
      profile = profiles[n++];
    };
  return;
}
		 
d437 3
a439 31
/* update record for callee
 */
void single_profile
  (struct entry *entry,struct entry *previous, struct profile_entry *profile, 
   struct profile_entry **next_profiles, struct stack_frame **sp, 
   struct profile_entry *next_profile, unsigned int top, unsigned int *self)
{
  ++entry->profile.callee.stack_found;
  if (top)
    ++entry->profile.callee.stack_top;
  
  if(entry->updated == scans)
    ++entry->stack_depth;
  else
    {
      entry->stack_depth = 1;
      entry->updated = scans;
    };
  
  if(entry->stack_depth > entry->profile.callee.stack_depth)
    entry->profile.callee.stack_depth = entry->stack_depth;
  
  if (entry == previous)
    {
      if(++*self > entry->profile.callee.stack_self)
	entry->profile.callee.stack_self = *self;
    }
  else 
    *self = 0;
  return;
}
d441 2
a442 31
/* update record for callee and records for callers of callee
 */
void multi_profile
  (struct entry *entry,struct entry *previous, struct profile_entry *profile, 
   struct profile_entry **next_profiles, struct stack_frame **sp, 
   struct profile_entry *next_profile, unsigned int top, unsigned int *self)
{
  short n = 0;
  struct profile_entry *caller;
  static struct profile_entry **callers = NULL;

  single_profile(entry,previous,profile,next_profiles,sp,next_profile,top,self);
  if(callers == NULL)
    callers = (struct profile_entry **)malloc(sizeof(struct profile_entry));
  fetch_callers(entry,next_profiles,callers);
  
  for(caller = callers[n]; ((caller != NULL) && (n != profile_level-1)); caller = callers[++n])
    {
      ++caller->stack_found;
      
      if(top)
	++caller->stack_top;
      
      if(entry->stack_depth > caller->stack_depth)
	caller->stack_depth = entry->stack_depth;
  
      if (entry == previous)
	if(*self > caller->stack_self)
	  caller->stack_self = *self;
    }
  return;
a444 16
/* determine which records to update
 */
void Profile(struct entry *entry, struct entry *previous, struct profile_entry *profile, 
	     struct profile_entry **next_profiles, struct stack_frame **sp, 
	     struct profile_entry *next_profile, unsigned int top, unsigned int *self)
{
  if((next_profile != profile) && (next_profile != NULL))
    {
      fetch_next_profiles(next_profiles,next_profile,sp);
      multi_profile(entry,previous,profile,next_profiles,sp,next_profile,top,self);
    }
  else
    single_profile(entry,previous,profile,next_profiles,sp,next_profile,top,self);
  return;
}

d448 4
a451 5
  struct stack_frame *sp = (struct stack_frame *)scp->sc_sp, *stack;
  struct profile_entry *prof, *next_prof; 
  static struct profile_entry **next_profiles = NULL;
  unsigned int ml_frames_found, self, top;
  struct entry *entry = NULL, *previous = NULL;
a452 2
  if(next_profiles == NULL)
    next_profiles = (struct profile_entry **)malloc(sizeof(struct profile_entry));
d455 10
a464 1
  else 
d466 9
a474 12
      if(!in_GC)		/* can't scan stack if GC is playing with it */
	{
	  entered = 1; 
	  {
	    short n;
 	    if(profile_level != 0)
	      for(n = 0; n != profile_level-1; ++n)
		next_profiles[n] = NULL;
	  }
	  ++scans;
	  
	  top = 1;
d476 8
a483 30
	  ml_frames_found = 0;
	  
	  next_prof = fetch_ml_frame(&sp,1);
	  if(sp != NULL)
	    stack = sp->fp;
	  while(next_prof != NULL)
	    {
	      prof = next_prof;
	      next_prof = fetch_ml_frame(&sp,1);
	      
	      if(prof != NULL)
		{
		  ++ml_frames_found;
		  
		  entry = PARENT(struct entry, profile.callee, prof);
		  
		  if(profile_all || (member(prof)) || (members(next_profiles)))
		    profile(entry,previous,prof,next_profiles,&stack,next_prof,top,&self);
		  
		  previous = entry;
		};
	      
	      top = 0;
	    }
	  
	  if(ml_frames_found > maximum_ml_frames)
	    maximum_ml_frames = ml_frames_found;
	  
	  ml_frames += ml_frames_found;
	}
d485 7
a491 1
      
d499 1
d550 1
a550 2
  DIAGNOSTIC(1,"Profiler_init called",0,0);
  declare_root(&profile_stream);
d554 1
d556 96
d668 1
a668 14
  DIAGNOSTIC(4, "  registering 0x%X `%s'", code, CCVNAME(code));
  init_entry(&table->entry[index], code);
  return(code);
}

static jmp_buf problem;

static char buffer[256];

static void print(const char *format, ...)
{
  va_list arg;

  if(profile_stream_type)
d670 1
a670 1
    int r;
d672 3
a674 3
    va_start(arg, format);
    r = vfprintf(profile_stream, format, arg);
    va_end(arg);
d676 1
a676 2
    if(r == EOF)
      longjmp(problem, EPROFILEWRITE);
a677 9
  else
  {
    va_start(arg, format);
    vsprintf(buffer, format, arg);
    va_end(arg);
    
    callml(ml_string(buffer),profile_stream);
  }
}
d679 1
a679 34
/* print all the callers of a callee
 */
void print_callers(struct profile_entry *profile,char *indentation)
{
  char *indent, *c;

  indent = (char *)malloc(sizeof(char));
  c = indent;
  while(*indentation != '\0')
    *c++ = *indentation++;
  *c = ' ';
  *++c = '\0';
  while(profile != NULL) 
    {
      print("%s%8u  %8u  %8u  %8u  %8u  %s\n", indent,
	    profile->calls, profile->stack_found,
	    profile->stack_top, profile->stack_depth,
	    profile->stack_self,
	    *profile->code == MLUNIT ?
	    "miscellaneous unprofiled" : CCVNAME(*profile->code));
      print_callers(profile->next,indent);
      profile = profile->caller;
    }
};

static void print_single_entry(struct entry *entry)
{
  if(profile_all || entry->profile.callee.stack_found)
    print("%8u  %8u  %8u  %8u  %8u   %s\n",
	  entry->profile.callee.calls, entry->profile.callee.stack_found,
	  entry->profile.callee.stack_top, entry->profile.callee.stack_depth,
	  entry->profile.callee.stack_self,
	  *entry->profile.callee.code == MLUNIT ?
	  "miscellaneous unprofiled" : CCVNAME(*entry->profile.callee.code));
a681 19
static void print_multiple_entry(struct entry *entry)
{
  if(profile_all || entry->profile.callee.stack_found)
    {
      print("\n%s  \n%s\n",
	    *entry->profile.callee.code == MLUNIT ?
	    "miscellaneous unprofiled" : CCVNAME(*entry->profile.callee.code),
	    "profiling by callee :");
      print("%8u  %8u  %8u  %8u  %8u\n",
	    entry->profile.callee.calls, entry->profile.callee.stack_found,
	    entry->profile.callee.stack_top, entry->profile.callee.stack_depth,
	    entry->profile.callee.stack_self);
      if(entry->profile.callee.caller != NULL)
	{
	  print("\n%s\n", "profiling by caller :");
	  print_callers(entry->profile.callee.caller,"");
	}
    }
}
d683 1
a683 2
int profile_begin(short profileLevel, short profileAll, struct profile_list *toProfile, 
		  mlval stream, unsigned int interval, int is_a_file)
d685 1
a685 1
  struct list *new;
d688 3
a690 1
  if(profile_stream != MLUNIT || loader_code_observer != NULL)
d692 1
d694 1
a694 1
    return(errno);
d698 1
a698 13
  to_profile = toProfile;
  profile_level = profileLevel;
  profile_all = profileAll;
  if(profile_level && (profile_level-1))
    {
      profile = Profile;
      print_entry = print_multiple_entry;
    }
  else 
    {
      profile = single_profile;
      print_entry = print_single_entry;
    }
a699 2
  DIAGNOSTIC(1, "profile_begin(stream = 0x%X, interval = %d", stream, interval);

d703 2
a704 7
  new = (struct list *)malloc(sizeof(struct list) - sizeof(struct entry) +
			      sizeof(struct entry)*length);
  if(new == NULL)
  {
    errno = EPROFILEALLOC;
    return(errno);
  }
d706 5
a710 5
  new->nr_entries = length;
  new->forward = profile_list.forward;
  new->back = &profile_list;
  new->forward->back = new;
  new->back->forward = new;
a711 2
  profile_stream = stream;
  profile_stream_type = is_a_file;
a713 1
  nr_code_vectors = length;
d715 2
a716 1
  table = new;
a718 2
  init_entry(&profile_list.entry[0], MLUNIT);

d720 1
a720 1
  start_timer(interval);
d727 4
a730 2
  struct list *list = profile_list.forward;
  int code = setjmp(problem);
a731 8
  if(code != 0)
  {
    errno = code;
    return(code);
  }

  DIAGNOSTIC(1, "profile_end()", 0, 0);

d735 1
d751 1
d753 6
d766 1
a766 1
      struct entry *entry = &list->entry[i];
d768 3
a770 1
      DIAGNOSTIC(4, "  unregistering 0x%X `%s'", *entry->profile.callee.code, CCVNAME(*entry->profile.callee.code));
d772 2
a773 4
      /* Make sure further call counting is harmless. */
      CCVPROFILE(*entry->profile.callee.code) = 
	(mlval)&profile_list.entry[0].profile.callee.calls;
      retract_root(entry->profile.callee.code);
d775 17
a791 1
      print_entry(entry);
a798 3
  /* Write out a final entry for miscellaneous unprofiled code */
  print_entry(&profile_list.entry[0]);

a801 1
  profile_stream = MLUNIT;
d803 1
@


1.26
log
@Implemented a multi-level profiler
@
text
@d8 3
d660 3
a662 2
	    for(n = 0; n != profile_level-1; ++n)
	      next_profiles[n] = NULL;
@


1.25
log
@Changes for code vector reform
@
text
@d8 3
d121 55
d179 6
a184 1
 *  this form.
d189 12
a200 8
  mlval code;			/* code vector profiled */

  unsigned int calls;		/* number of calls */
  unsigned int stack_found;	/* number of times found on the stack */
  unsigned int stack_top;	/* number of times found on the top of the stack */
  unsigned int stack_depth;	/* maximum nesting depth on the stack */
  unsigned int stack_self;	/* maximum contiguous stack depth */

d228 6
d235 2
a236 4
{
  &profile_list, &profile_list, 1,
  {{{MLUNIT, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0, 0}}
};
d269 10
a278 6
  entry->profile.code = code;
  entry->profile.calls = 0;
  entry->profile.stack_found = 0;
  entry->profile.stack_top = 0;
  entry->profile.stack_depth = 0;
  entry->profile.stack_self = 0;
d286 2
a287 2
    CCVPROFILE(code) = (mlval)&entry->profile.calls;
    declare_root(&entry->profile.code);
d313 1
a313 1
    CCVPROFILE(code) = (mlval)&profile_list.entry[0].profile.calls;
d339 1
a339 1
    CCVPROFILE(code) = (mlval)&profile_list.entry[0].profile.calls;
d356 281
d640 3
a642 2
  struct stack_frame *sp = (struct stack_frame *)scp->sc_sp;
  mlval code;
d646 2
d650 1
a650 10
  else if(!in_GC)		/* can't scan stack if GC is playing with it */
  {
    entered = 1;
    ++scans;

    top = 1;
    self = 0;
    ml_frames_found = 0;

    while(sp != NULL)
d652 1
a652 9
      ++frames;

      code = is_ml_frame(sp);

      if(code != MLUNIT)
      {
	unsigned int *call_count = (unsigned int *)CCVPROFILE(code);

	if(call_count != NULL)
d654 7
a660 3
	  ++ml_frames_found;
	  
	  entry = PARENT(struct entry, profile, PARENT(struct profile, calls, call_count));
d662 3
a664 1
	  ++entry->profile.stack_found;
d666 22
a687 10
	  if(top)
	    ++entry->profile.stack_top;
	  
	  if(entry->updated == scans)
	    ++entry->stack_depth;
	  else
	  {
	    entry->stack_depth = 1;
	    entry->updated = scans;
	  }
d689 2
a690 2
	  if(entry->stack_depth > entry->profile.stack_depth)
	    entry->profile.stack_depth = entry->stack_depth;
d692 1
a692 7
	  if(entry == previous)
	  {
	    if(++self > entry->profile.stack_self)
	      entry->profile.stack_self = self;
	  }
	  else
	    self = 0;
a693 9
      }
      else
	{
	entry = NULL;
      }
      previous = entry;

      sp = sp->fp;
      top = 0;
d695 1
a695 6
    if(ml_frames_found > maximum_ml_frames)
      maximum_ml_frames = ml_frames_found;

    ml_frames += ml_frames_found;
  }

d699 1
a699 1

d780 87
a866 1
int profile_begin(mlval stream, unsigned int interval,int is_a_file)
d878 13
a927 39
static jmp_buf problem;

static char buffer[256];

static void print(const char *format, ...)
{
  va_list arg;

  if(profile_stream_type)
  {
    int r;

    va_start(arg, format);
    r = vfprintf(profile_stream, format, arg);
    va_end(arg);

    if(r == EOF)
      longjmp(problem, EPROFILEWRITE);
  }
  else
  {
    va_start(arg, format);
    vsprintf(buffer, format, arg);
    va_end(arg);
    
    callml(ml_string(buffer),profile_stream);
  }
}

static void print_entry(struct entry *entry)
{
  print("%8u  %8u  %8u  %8u  %8u  %s\n",
	entry->profile.calls, entry->profile.stack_found,
	entry->profile.stack_top, entry->profile.stack_depth,
	entry->profile.stack_self,
	entry->profile.code == MLUNIT ?
	"miscellaneous unprofiled" : CCVNAME(entry->profile.code));
}

d958 1
a958 1
	"   calls     found       top     depth      self  name\n");
d969 1
a969 1
      DIAGNOSTIC(4, "  unregistering 0x%X `%s'", entry->profile.code, CCVNAME(entry->profile.code));
d972 3
a974 2
      CCVPROFILE(entry->profile.code) = (mlval)&profile_list.entry[0].profile.calls;
      retract_root(&entry->profile.code);
@


1.24
log
@Made the profiler take the generalised streams
@
text
@d8 3
d211 1
a211 1
    CCVPROFILE(code) = &entry->profile.calls;
d233 1
a233 1
  if(CCVPROFILE(code) != (unsigned int *)PROFILE_DISABLE)
d238 1
a238 1
    CCVPROFILE(code) = &profile_list.entry[0].profile.calls;
d264 1
a264 1
    CCVPROFILE(code) = &profile_list.entry[0].profile.calls;
d308 1
a308 1
	unsigned int *call_count = CCVPROFILE(code);
d342 1
d344 1
a344 1

a349 1

d572 1
a572 1
      CCVPROFILE(entry->profile.code) = &profile_list.entry[0].profile.calls;
@


1.23
log
@Added ansi.h.
@
text
@d8 3
d173 1
d178 2
a179 1
static FILE *profile_stream;
d233 1
a233 1
  if(profile_stream == NULL)
d410 2
d437 1
a437 1
int profile_begin(FILE *stream, unsigned int interval)
d442 1
a442 1
  if(profile_stream != NULL || loader_code_observer != NULL)
d470 1
d488 2
a492 1
  int r;
d494 3
a496 3
  va_start(arg, format);
  r = vfprintf(profile_stream, format, arg);
  va_end(arg);
d498 15
a512 2
  if(r == EOF)
    longjmp(problem, EPROFILEWRITE);
d586 1
a586 1
  profile_stream = NULL;
@


1.22
log
@The profiler no longer maintains its own list of all code vectors
but uses the weak list kept by the loader.  The weak list functions
have been improved to allow the profiler to use them on that list.
@
text
@d8 5
d85 1
@


1.21
log
@Added missing test in profile initialisation.
@
text
@d8 3
d89 1
a157 1
 *  code_vectors	list of all code vectors declared to the profiler
a166 1
mlval code_vectors;
a172 70
/*  == Add a code vector to the list ==
 *
 *  The profiler maintains a list of weak arrays of code vectors so that it
 *  can initiate profiling for all of them when requested.  This function
 *  adds a code vector to the list.
 */

#define ARRAY_SIZE	256

static void add_code_vector(mlval code)
{
  mlval list, array;
  size_t i;

  for(list = code_vectors; list != MLNIL; list = MLTAIL(list))
  {
    size_t length;

    array = MLHEAD(list);
    length = LENGTH(ARRAYHEADER(array));

    for(i=0; i<length; ++i)
      if(MLSUB(array, i) == DEAD)
      {
	MLUPDATE(array, i, code);
	return;
      }
  }

  declare_root(&code);
  array = allocate_weak_array(ARRAY_SIZE);
  retract_root(&code);
  MLUPDATE(array, 0, code);
  for(i=1; i<ARRAY_SIZE; ++i)
    MLUPDATE(array, i, DEAD);

  code_vectors = cons(array, code_vectors);
}


/*  == Fix code vectors on image load ==
 *
 *  When an image is loaded it will set the global root `profiler code
 *  vectors' and cause this function to be called.  It disables profiling
 *  for all code vectors on the list in case it was enabled when the image
 *  was saved.
 */

static void fix_code_vectors(mlval *root, mlval value)
{
  mlval list;
  *root = value;

  for(list = value; list != MLNIL; list = MLTAIL(list))
  {
    mlval array = MLHEAD(list);
    size_t length = LENGTH(ARRAYHEADER(array)), i;

    for(i=0; i<length; ++i)
    {
      mlval code = MLSUB(array, i);

      if(code != DEAD)
	CCVPROFILE(code) = &profile_list.entry[0].profile.calls;
    }
  }
}



d203 1
a203 2

/*  === ADD CODE VECTOR TO PROFILER TABLES ===
d212 1
a212 1
void profile_new(mlval code)
d219 1
a219 1
  if(CCVPROFILE(code) != NULL)
a221 4
  declare_root(&code);
  add_code_vector(code);
  retract_root(&code);

d393 2
a394 3
 *  The variable code_vectors must be declared as a global root so that it
 *  is preserved when an image is saved.  The code vectors it contains must
 *  also be fixed up when an image is loaded.
a398 2
  code_vectors = MLNIL;
  declare_global("profiler code vectors", &code_vectors, fix_code_vectors);
d416 8
a425 1
  mlval list;
d427 1
a427 1
  size_t count;
d429 1
a429 1
  if(profile_stream != NULL)
d435 2
d439 2
a440 12
  count = 0;
  for(list = code_vectors; list != MLNIL; list = MLTAIL(list))
  {
    mlval array = MLHEAD(list);
    size_t length = LENGTH(ARRAYHEADER(array)), i;

    for(i=0; i<length; ++i)
      if(MLSUB(array, i) != DEAD)
	++count;
  }

  DIAGNOSTIC(1, "  %u code vectors", count, 0);
d443 1
a443 2
			      sizeof(struct entry)*count);

d450 1
a450 1
  new->nr_entries = count;
d459 1
a459 7
  nr_code_vectors = count;

  count = 0;
  for(list = code_vectors; list != MLNIL; list = MLTAIL(list))
  {
    mlval array = MLHEAD(list);
    size_t length = LENGTH(ARRAYHEADER(array)), i;
d461 2
a462 11
    for(i=0; i<length; ++i)
    {
      mlval code = MLSUB(array, i);

      if(code != DEAD)
      {
	DIAGNOSTIC(4, "  registering 0x%X `%s'", code, CCVNAME(code));
	init_entry(&new->entry[count++], code);
      }
    }
  }
d559 1
@


1.20
log
@Forgot to initialise the `miscellaneous' entry in the tables.
@
text
@d8 3
d263 5
a267 2
  CCVPROFILE(code) = &entry->profile.calls;
  declare_root(&entry->profile.code);
@


1.19
log
@Added some diagnostics.
@
text
@d8 3
d550 2
@


1.18
log
@Added some missing roots.
@
text
@d8 3
d541 2
d544 1
d590 2
d620 2
d623 1
a623 2
      if(entry->profile.code != MLUNIT)
	CCVPROFILE(entry->profile.code) = &profile_list.entry[0].profile.calls;
@


1.17
log
@Added missing return of success code.
@
text
@d8 3
d191 1
d193 1
d279 1
d281 1
@


1.16
log
@Unregistered code vectors (stubs) may arise and are allowed.
@
text
@d8 3
d625 2
@


1.15
log
@Added better error recovery.
@
text
@d8 3
d347 1
a347 24
	++ml_frames_found;

	if(call_count == NULL)
	  error("Unregistered code vector at 0x%X", code);

	entry = PARENT(struct entry, profile, PARENT(struct profile, calls, call_count));

	++entry->profile.stack_found;

	if(top)
	  ++entry->profile.stack_top;

	if(entry->updated == scans)
	  ++entry->stack_depth;
	else
	{
	  entry->stack_depth = 1;
	  entry->updated = scans;
	}

	if(entry->stack_depth > entry->profile.stack_depth)
	  entry->profile.stack_depth = entry->stack_depth;

	if(entry == previous)
d349 27
a375 2
	  if(++self > entry->profile.stack_self)
	    entry->profile.stack_self = self;
a376 2
	else
	  self = 0;
@


1.14
log
@Each profiler table list may now contain multiple profiler entry
structures.  This allows profile_begin() to allocate one large chunk
of memory rather than thousands of small ones.
@
text
@d8 5
a64 1
#include "loader.h"
d66 2
d72 2
d136 1
d138 1
a138 1
 *  code_vectors	number of code vectors profiled
d146 2
a147 1
static unsigned int scans, frames, ml_frames, maximum_ml_frames, code_vectors;
d153 68
d242 1
a242 1
  
d251 1
d265 5
d286 1
a286 1
    ++code_vectors;
d297 1
a297 1
    
d439 15
d460 2
a461 3
 *  current code vectors supplied by the loader (see loader.h,
 *  load_code_vectors).  It then start the virtual time alarm, if required,
 *  to perform stack scanning.
d474 4
a477 1
    return(0);
d482 1
a482 1
  for(list = load_code_vectors; list != MLNIL; list = MLTAIL(list))
d498 4
a501 1
    return(0);
d512 1
a512 1
  code_vectors = count;
d515 1
a515 1
  for(list = load_code_vectors; list != MLNIL; list = MLTAIL(list))
d532 16
a547 1
  return(1);
d550 1
a550 1
static void entry_write(FILE *stream, struct entry *entry)
d552 6
a557 7
  fprintf(stream,
	  "%8u  %8u  %8u  %8u  %8u  %s\n",
	  entry->profile.calls, entry->profile.stack_found,
	  entry->profile.stack_top, entry->profile.stack_depth,
	  entry->profile.stack_self,
	  entry->profile.code == MLUNIT ?
	  "miscellaneous unprofiled" : CCVNAME(entry->profile.code));
d560 1
a560 1
void profile_end(void)
d563 1
d565 6
d574 3
a576 4
  fprintf(profile_stream,
	  "MLWorks profiler v2.0\n"
	  "profile period: %ums\nfunctions profiled: %u\n",
	  (stop-start)/(CLK_TCK/1000), code_vectors);
d579 10
a588 12
    fprintf(profile_stream,
	    "scans: %u\nframes scanned: %u\nML frames scanned: %u (%3.1f%%)\n"
	    "mean stack depth: %u\n"
	    "maximum ML stack depth: %u\n"
	    "mean ML stack depth: %u\n",
	    scans, frames, ml_frames,
	    ((double)ml_frames/(double)frames)*100.0,
	    frames/scans, maximum_ml_frames, ml_frames/scans);

  fprintf(profile_stream,
	  "---\n"
	  "   calls     found       top     depth      self  name\n");
d604 1
a604 1
      entry_write(profile_stream, entry);
d613 1
a613 1
  entry_write(profile_stream, &profile_list.entry[0]);
a617 1
  (void)fclose(profile_stream);
@


1.13
log
@The signal stack is now allocated by initialise.c.  Corrected the
time interval calculation in start_timer().
@
text
@d8 4
d102 3
a104 3
 *  which contains a profile structure for a different code vector.  The
 *  sentinel of the list is profile_list, which also contains the default
 *  profile structure used for unknown or disabled functions.
d107 1
a107 1
struct entry
d109 8
a116 4
  struct entry *forward, *back;
  struct profile profile;
  unsigned int updated;		/* the last time this entry was updated */
  unsigned int stack_depth;	/* stack depth found in current scan */
d119 5
a123 5
struct entry profile_list = {&profile_list, &profile_list,
			     {MLUNIT, /* see entry_write */
			      0, 0, 0, 0, 0,
			      0, 0, 0, 0},
			     0, 0};
d142 29
d174 3
a176 6
 *  running, and each new code vector is given a separate profiler table
 *  entry.  Otherwise, all code vectors are profiled using the default
 *  entry, which is kept in profile_list.
 *
 *  The profiler slot of the code vector is updated to point at the call
 *  counter for the profiler table entry.
d182 1
a182 1
  struct entry *new = NULL;
d188 1
a188 1
    CCVPROFILE(code) = &profile_list.profile.calls;
d192 1
a192 1
  new = (struct entry *)malloc(sizeof(struct entry));
d200 2
a201 16
    new->updated = 0;
    new->stack_depth = 0;
    new->profile.code = code;
    new->profile.calls = 0;
    new->profile.stack_found = 0;
    new->profile.stack_top = 0;
    new->profile.stack_depth = 0;
    new->profile.stack_self = 0;
    new->profile.allocs = 0;
    new->profile.alloc_total = 0;
    new->profile.alloc_largest = 0;
    new->profile.alloc_smallest = 0;

    CCVPROFILE(code) = &new->profile.calls;
    declare_root(&new->profile.code);

a202 2

    return;
d204 1
a204 2

  if(!memory_warning)
d206 9
a214 4
    message("Warning: Unable to allocate memory for further profiling "
	    "information.  Some functions requested may be profiled "
	    "under `miscellaneous'.");
    memory_warning = 1;
a215 2

  CCVPROFILE(code) = &profile_list.profile.calls;
d371 3
a373 1
  mlval list = load_code_vectors;
d380 25
d408 1
a408 1
  code_vectors = 0;
d410 2
a411 1
  while(list != MLNIL)
d421 1
a421 1
	profile_new(code);
a422 2

    list = MLTAIL(list);
d444 1
a444 1
  struct entry *entry = profile_list.forward;
d468 1
a468 1
  while(entry != &profile_list)
d470 2
a471 1
    struct entry *next = entry->forward;
d473 8
a480 4
    /* Make sure further call counting is harmless. */
    if(entry->profile.code != MLUNIT)
      CCVPROFILE(entry->profile.code) = &profile_list.profile.calls;
    retract_root(&entry->profile.code);
d482 2
a483 1
    entry_write(profile_stream, entry);
d485 1
a485 1
    free(entry);
d487 1
a487 1
    entry = next;
d490 4
a493 1
  entry_write(profile_stream, &profile_list);
@


1.12
log
@Removed is_ml_frame().  (Now implemented in the storage manager.)
@
text
@d8 3
a52 1
#include "gc.h"
a53 1
#include "mem.h"
d57 1
a65 1
extern int sigstack(struct sigstack *ss, struct sigstack *oss);
a68 2
#define SIGNAL_STACK_SIZE 8192

d205 2
d236 1
a236 1
      if(code)
a294 2
  long int usec;
  struct sigstack ss;
a295 10
  char *stack = malloc(SIGNAL_STACK_SIZE);

  if(stack == NULL)
    error("Unable to allocate signal stack.");

  ss.ss_sp = stack + SIGNAL_STACK_SIZE;
  ss.ss_onstack = 0;

  if(sigstack(&ss, NULL) == -1)
    error("Unable to set up signal stack (sigstack set errno to %d).", errno);
d300 2
a301 2
  timer.it_value.tv_sec = interval/1000000;
  timer.it_value.tv_usec = (interval/1000)%1000;
d356 1
a356 1
  DIAGNOSTIC(0, "profile_begin(stream = 0x%X, interval = %d", stream, interval);
@


1.11
log
@Removed is_ml_frame().  (Now implemented in the storage manager.)
@
text
@d8 3
a213 1
  void *pc = (void *)scp->sc_pc;
d233 1
a233 1
      code = is_ml_frame(sp, pc);
a274 1
      pc = (void *)sp->lr;
@


1.10
log
@Temprary export of is_ml_frame until a better home is found for it
@
text
@d8 3
a129 54


/*  == Is a stack frame an ML frame? ==
 *
 *  This function performs some conservative tests to guess whether a stack
 *  pointer and pc combination form a valid ML context.  It returns the code
 *  vector if it thinks it is, or zero if not.  If the pc passed is NULL
 *  then it is not used as a check criterion.
 */

mlval is_ml_frame(struct stack_frame *sp, void *pc)
{
  struct stack *stack;

  DIAGNOSTIC(3, "Checking context sp = %X, pc = %X", sp, pc);

  for(stack = GC_STACK; stack != NULL; stack = stack->parent)
  {
    /* If the stack pointer is in an ML stack area then it might be an ML */
    /* frame. */

    if((void *)sp >= (void *)stack && (void *)sp < stack->top)
    {
      mlval closure = sp->closure;

      /* If the closure register in that frame is a record then it's getting */
      /* really quite likely. */

      if((PRIMARY(closure) == POINTER || PRIMARY(closure) == PAIRPTR) &&
	 SECONDARY(GETHEADER(closure)) == RECORD)
      {
	mlval code = GETFIELD(closure, 0);

	/* If the first element of the closure is a string and the pc is in */
	/* that string then we can be pretty damn certain. */

	if(PRIMARY(code) == POINTER && SECONDARY(GETHEADER(code)) == STRING &&
	   (pc == NULL ||
	    ((char *)pc >= CSTRING(code) && (char *)pc < CSTRING(code)+CSTRINGLENGTH(code))))
	  return(code);

	DIAGNOSTIC(3, "  no code vector or pc outside code vector", 0, 0);
	return(0);
      }

      DIAGNOSTIC(3, "  closure is not a record", 0, 0);
      return(0);
    }
  }

  DIAGNOSTIC(3, "  stack pointer not in stack area", 0, 0);
  return(0);
}

@


1.9
log
@Complete reimplementation without placing assumptions on the
storage manager.  The profiler may now be `wrapped around'
a computation in order to profile it, and sends it output to
a specified stream.
@
text
@d8 6
d137 1
a137 1
static mlval is_ml_frame(struct stack_frame *sp, void *pc)
@


1.8
log
@offsetof not defined in the headers - temporary fix
@
text
@d8 3
d21 1
a21 1
 *  
d24 1
a24 1
 *  
d27 1
a27 1
 *  
d30 1
a30 1
 *  
d42 2
d47 1
a48 1
#define sparc             /************** blech *************/
d50 3
a52 1
extern int sigstack (struct sigstack *ss, struct sigstack *oss);
d54 1
a54 1
#include <sys/time.h>
d56 1
a56 38
/* 
   Profiling only occurs for specially compiled code, which uses the extra slot after 
  the raw spill count, which is initially set to zero. When the function is entered,
  the slot is checked - if it is zero, the function is registered by indirecting to the
  profiler routine via the implicit vector. This sets up an entry in a table maintained
  by the C, putting a one in the call count slot for the newly registered function, and
  storing the pointer in the extra slot. If the slot is non-zero, then the pointer to the
  table entry is used to add one to the call count, unless the pointer is not word aligned, 
  in which case we are running with the profiling turned off - in this case we do nothing.
   When an image is saved, the pointers to C table entries need to be set to zero (causing
  them to re-register themselves on the next run). This is implemented by having a 
  weak-pointer in each table entry pointing to the code that it call-counts for... if the
  pointer is destroyed then we record this by making the pointer in the table into the
  NULL pointer. Otherwise, when the routine finalise_profiler_table is called, the slot
  will be set to NULL.
    The time-sampling uses the same table entries - when a timer interrupt comes in, we check
  to find out if the PC is in the ML heap, the stackframe is tagged as a STACKBLK, and the
  closure is in the ML heap - if this is the case then the count in the table entry
  pointed to by the code is incremented by one, and the alarm signal is reinitialised. 
  Otherwise, nothing is done.
   Memory allocation profiling is also done for functions which are compiled specially.
  These put a stub around the function call to record the allocation before and after the
  call to the function. This information is then added to the profiler-table_entry for
  the given function.
*/

int profiling_turned_on = 0;
int scan_stack_profiling = 0;

int in_ML;

/* 
   The code in alarm handler relies on the fact that top_of_stack is an (int *)
   to number_of_calls plus one. Code_object must be the first thing, as we cast
   the root pointer given to the weak root kill function to a structure.
   Changing the slots here is dangerous as the offet is coded into the assembler
   frame wrapping code in interface.m4s
*/
d58 1
a58 11
struct profiler_table_entry
{
  mlval code_object;
  char *name ;
  unsigned int number_of_calls;
  unsigned int top_of_stack;
  unsigned int found_on_stack;

  unsigned int maximal_live_stack_count;
  unsigned int current_live_stack_count;
  unsigned int scan_number;
a59 1
  unsigned int allocation;
d61 5
a65 2
  int self_call_max;
};	
d67 1
a67 2
/* The profiler information is maintained as a linked list of smaller table */
struct profiler_table
d69 1
a69 9
  int profiler_table_size ;
  int next_entry;
  struct profiler_table *previous;
  struct profiler_table_entry *entries;
};

/*
  The structure used in the sorting process
*/
d71 10
a80 3
struct sort_table_entry
{
  struct profiler_table_entry *entry;
a82 1
struct profiler_table *current_table = NULL;
d84 7
a90 6
/*
  This function is called if the weak root pointing from the table entry
  back to the code vector dies. The pointer in the table is set to NULL
  to show that it is no longer valid
*/

d92 1
a92 1
void kill_profiler_entry(mlval *root)
d94 5
a98 4
  struct profiler_table_entry *entry = (struct profiler_table_entry *) root;
  DIAGNOSTIC(4,"Object killed %p",root,0);
  entry->code_object = NULL;
}
d100 5
a104 1
int warning_issued = 0;
a105 11
/*
  This function maintains the table of functions that are being profiled,
  setting up a weak root as a pointer from the entry back to the code vector.
*/
unsigned int *register_code(mlval packet,int initial_call_count, int initial_top_of_stack_count)
{
  word closure = packet;
  word code = GETFIELD(closure, 0);
  char *name = CCVNAME(code);
  char *copied_name = (char *)malloc(strlen(name)+1);
  struct profiler_table_entry *profiler_table;
d107 10
a116 85
  /* Set the profiling slot with an unaligned pointer to signify profiling turned off */
  if(!profiling_turned_on)
  {
    CCVPROFILE(code) = (unsigned int *)PROFILER_OFF;
    return(0);
  }

  if(copied_name == NULL)
  {
    if(!warning_issued)
      message("Warning: Profiler cannot get more memory - not profiling some functions");
    warning_issued = 1;
    return(NULL);
  }

  strcpy(copied_name,name);

  if(current_table == NULL || current_table->next_entry == current_table->profiler_table_size)
  {
    struct profiler_table *old_table = current_table;
    profiler_table = 
      (struct profiler_table_entry *)
	malloc(50 * sizeof(struct profiler_table_entry));
    current_table =
      (struct profiler_table *)
	malloc(sizeof(struct profiler_table));

    /* If memory has run out, forget about profiling this function 
       - speed will decrease, but the system should keep running */
    if(current_table == NULL || profiler_table == NULL)
    {
      if(!warning_issued)
	message("Warning: Profiler cannot get more memory - not profiling some functions.");
      warning_issued = 1;
      return(NULL);
    }

    current_table->profiler_table_size = 50;
    current_table->next_entry = 0;
    current_table->previous = old_table;
    current_table->entries = profiler_table;
  }
  else
    profiler_table = current_table->entries;

  profiler_table[current_table->next_entry].name = copied_name;
  profiler_table[current_table->next_entry].number_of_calls = (unsigned int) initial_call_count;
  profiler_table[current_table->next_entry].top_of_stack = (unsigned int) initial_top_of_stack_count;
  profiler_table[current_table->next_entry].found_on_stack = 0;
  profiler_table[current_table->next_entry].maximal_live_stack_count = 0;
  profiler_table[current_table->next_entry].current_live_stack_count = 0;
  profiler_table[current_table->next_entry].scan_number = 0;
  profiler_table[current_table->next_entry].allocation = 0;
  profiler_table[current_table->next_entry].self_call_max = 0;
  profiler_table[current_table->next_entry].code_object = code;
  CCVPROFILE(code) = &profiler_table[current_table->next_entry].number_of_calls;
  declare_weak(&profiler_table[current_table->next_entry].code_object,kill_profiler_entry);
  current_table->next_entry++;

  return(CCVPROFILE(code));
}

/*
  The ML will enter the C at this point
*/
  
unsigned int registered = 0;

void profiler(mlval packet)
{	
  registered ++;
  register_code(packet,1,0);
  return;
}

/*
  The structures for the timer code 
*/

struct itimerval timer =
  { { 0L, 0L} , {0L,PROFILE_TOS_EVERY} };

long *profile_every = & (timer.it_value).tv_usec;

extern int setitimer (int, struct itimerval *, struct itimerval *);
d118 3
a120 16
void set_profiler_timer_going(void)
{
  setitimer(ITIMER_VIRTUAL, & timer,NULL); 
}

/* 
  Set the profiling frequency at nums times per second
*/

void profile_frequency(int num)
{	
  if(num)
    *profile_every = (long) (1000000.0 / num) ;
  else
    *profile_every = (long) 0;
}
a121 1
unsigned int profiler_missed = 0;
d131 1
a131 1
mlval is_ml_frame(struct stack_frame *sp, void *pc)
d157 1
a157 1
	if(PRIMARY(code) == POINTER && GETHEADER(code) == STRING &&
d174 2
a175 1
 
d177 10
a186 9
/*
  This function handles the timer interrupts, and adds one to the appropriate
  top_of_stack count
*/

unsigned int number_of_stack_scans = 0;
unsigned int maximal_depth_of_stack = 0;
unsigned int total_number_of_stack_frames = 0;
int inside_alarm_handler = 0;
d188 1
a188 1
void alarm_handler(int sig, int alarm_code, struct sigcontext *scp, char *addr)
d190 4
a193 7
  struct stack_frame *sp = (struct stack_frame *)scp->sc_sp;
  void *pc = (void *)scp->sc_pc;
  mlval code;
  int count_of_ml_frames = 0;
  mlval self_call_closure = MLUNIT;
  struct profiler_table_entry *self_call_entry = NULL;
  int self_call_count = 0;
d195 3
a197 1
  if(inside_alarm_handler)
d199 22
d222 2
a223 1
  inside_alarm_handler = 1;
d225 1
a225 1
  number_of_stack_scans++;
d227 2
a228 1
  DIAGNOSTIC(4,"pc %x closure %x", pc, sp->closure);
d230 1
a230 1
  if(code = is_ml_frame(sp, pc))
d232 9
a240 1
    unsigned int *increment_address = CCVPROFILE(code);
a241 1
    self_call_closure = sp->closure;
d243 6
a248 1
    DIAGNOSTIC(4, "In top of stack view %s", CCVNAME(code), 0);
d250 1
a250 19
    /* If zero, this thing is not being profiled */
    if(increment_address != NULL)
    {
      if(increment_address != (unsigned int *)PROFILER_OFF)
      {
	DIAGNOSTIC(4, "Alarm handled",0,0);	
	DIAGNOSTIC(4, "  sp 0x%X  closure 0x%X", sp, sp->closure);
	DIAGNOSTIC(4, "  incrementing count at %p", increment_address, 0);
	++*increment_address;
      }
    }
    else
      register_code(sp->closure,0,1);
  }	
  else
  {
    self_call_closure = MLUNIT;
    ++profiler_missed;
  }
d252 8
a259 1
  /* Scan the entire ML stack to find the frames */	
d261 3
a263 1
  if(scan_stack_profiling)
d265 6
a270 1
    DIAGNOSTIC(3, "Walking the stack from 0x%X", sp, 0);
d274 5
a278 1
      if(code = is_ml_frame(sp, pc))
d280 8
a287 2
	mlval closure = sp->closure;
	unsigned int *call_counter = CCVPROFILE(code);
d289 1
a289 1
	++count_of_ml_frames;
d291 2
a292 1
	DIAGNOSTIC(3, "  ML frame 0x%X  code 0x%X", sp, code);
d294 3
a296 1
	if(call_counter != (unsigned int *)PROFILER_OFF)
d298 6
a303 2
	  if(call_counter == NULL)
	    call_counter = register_code(closure, 0, 0);
d305 4
a308 29
	  if(call_counter != NULL)
	  {
	    struct profiler_table_entry *entry =
	      (struct profiler_table_entry *)
		((char *)call_counter -
		 /* offsetof(struct profiler_table_entry, number_of_calls) */ 8);

	    if(entry->scan_number == number_of_stack_scans)
	      ++entry->current_live_stack_count;
	    else
	    {
	      if(entry->current_live_stack_count > entry->maximal_live_stack_count)
		entry->maximal_live_stack_count = entry->current_live_stack_count;
	      entry->current_live_stack_count = 1;
	      entry->scan_number = number_of_stack_scans;
	    }

	    if(self_call_closure == closure)
	      --self_call_count;
	    else
	    {
	      if(self_call_count < 0 && self_call_entry != NULL)
		self_call_entry->self_call_max -=
		  self_call_count;
	      self_call_count = entry->self_call_max - 1;
	      self_call_entry = entry;
	      self_call_closure = closure;
	    }
	  }
d310 2
d313 4
d320 1
d322 3
a324 3
    
    if(maximal_depth_of_stack < count_of_ml_frames)
      maximal_depth_of_stack = count_of_ml_frames ;
d326 1
a326 1
    total_number_of_stack_frames += count_of_ml_frames;
d329 3
a331 1
  set_profiler_timer_going();
d333 1
a333 1
  inside_alarm_handler = 0;
d336 15
a350 1
struct sigvec vec = {alarm_handler, SIGVTALRM, SV_ONSTACK};
d352 2
a353 1
struct sigstack new_stack = { NULL,0 };
d355 8
a362 12
void set_up_profiler_interrupt(void)
{	
  char * stack;	
  stack = malloc(SIGNAL_STACK_SIZE);
  if(stack == NULL)
    error("Can't get memory for new signal stack");
  else
    new_stack.ss_sp = stack + SIGNAL_STACK_SIZE;

  DIAGNOSTIC(4,"Setting the alarm signal handler at address %x",new_stack.ss_sp,0);
  sigstack(&new_stack,NULL);
  sigvec(SIGVTALRM,&vec,NULL); 
d365 17
a381 3
/*
  the sort function for the table entries
*/
d383 3
a385 10
int compare_entries(const void *a, const void *b)
{
  const struct sort_table_entry *arg1 = a;
  const struct sort_table_entry *arg2 = b;
  int result = (int) ((arg2->entry)->number_of_calls - (arg1->entry)->number_of_calls);

  if(result)
    return(result);
  else
    return(strcmp((arg1->entry)->name,(arg2->entry)->name));
d388 15
a402 4
/* 
   This routine prints the current counts, and sets the slots in the code vector that points
   to C tables back to zero
*/
d404 1
a404 1
void finalise_profiler_table(int print,int dont_sort)
d406 13
a418 14
  int i;
  unsigned int profiled_functions_count = 0,top_of_stack_functions_count = 0;
  int allocation_monitored = 0;
  struct profiler_table *current,*temp;
  struct profiler_table_entry *entries;
  float rough;
  int number_of_functions = 0;
  struct sort_table_entry *table = (struct sort_table_entry *) NULL;
  int slot_number = 0;
  
  if(print && registered)
    printf("Profiler statistics\n===================\n");	
  
  for(current = current_table; current != (struct profiler_table *) NULL ; )
d420 4
a423 2
    entries = current->entries;
    for(i=0 ; i<current->next_entry ; i++)	
d425 4
a428 13
      number_of_functions ++;
      if(entries[i].code_object != (mlval) NULL)
      {
	DIAGNOSTIC(4,"Clearing entry %d",i,0);
	CCVPROFILE(entries[i].code_object) = 0;
	entries[i].code_object = NULL;
      }
      profiled_functions_count += entries[i].number_of_calls;
      top_of_stack_functions_count += entries[i].top_of_stack;
      if(entries[i].allocation != 0)
	allocation_monitored = 1;
      if(entries[i].current_live_stack_count > entries[i].maximal_live_stack_count)
	entries[i].maximal_live_stack_count = entries[i].current_live_stack_count;
d430 2
a431 1
    current=current->previous;
d433 45
a477 2
  
  if(! dont_sort)
d479 12
a490 23
    table = 
      (struct sort_table_entry *)
	calloc(number_of_functions,sizeof(struct sort_table_entry));
    
    if(table == (struct sort_table_entry *) NULL)
    {
      dont_sort = 1;
      printf("Not enough memory to sort the entries\n");
    }
    else
    { 
      for(current = current_table; current != (struct profiler_table *) NULL; )
      {
	entries = current->entries;
	for(i=0 ; i<current->next_entry ; i++)	
	{
	  table[slot_number].entry = entries+i;
	  slot_number++;
	}
	current=current->previous;
      }
      qsort(table,slot_number,sizeof(struct sort_table_entry),compare_entries);
    }
d492 6
a497 130
  
  if(print && registered)
  {
    printf("Profiling information obtained for %d functions. \n",number_of_functions);
    if(profiler_missed ==0)
      profiler_missed++;
    if(*profile_every)
      printf("Top of stack survey based on a sample of %u ML functions \n"
	     "profiling every %ld usec with %4.1f%% of the time profiles \n"
	     "not finding ML functions using a total of %u stack scans.\n",
	     top_of_stack_functions_count,*profile_every,
	     100.0 * (float) profiler_missed / (profiler_missed + top_of_stack_functions_count),
	     number_of_stack_scans);
    if(maximal_depth_of_stack)
    {
      printf("Maximal depth of the stack while time profiling found to be %u\n",maximal_depth_of_stack);
      printf("Average depth of the stack while time profiling found to be %d\n",(int) (total_number_of_stack_frames / number_of_stack_scans) );
    }
    printf("\n");
    printf("The table entries have the following meaning\n");
    if(profiled_functions_count)
    {
      printf(" Using simple call counting\n");
      printf("  (.) Call count for the function\n");
      printf("  (.) Percentage of the total calls counted\n");
    }
    if(top_of_stack_functions_count || number_of_stack_scans)
      printf(" Using time-interval interrupt profiling\n");
    if(top_of_stack_functions_count)
      printf("  (.) Number of times that the function was found at the top of the stack (as a percentage)\n");
    if(number_of_stack_scans)
    {
      printf("  (.) Number of times the function was found on the stack\n");
      printf("  (.) Average number of times the function was found on the stack\n");
      printf("  (.) Maximum number of times the function was on the stack during one stack scan\n");
      printf("  (.) Maximum number of times the function was found to self-call without being optimised\n");
      printf("           (printed only if greater than one) \n");
    }
    if(allocation_monitored)	
    {
      printf(" Using memory profiling\n");
      if(allocation_might_be_wrong)
	printf("*** WARNING - the allocation counter (an int) wrapped so the figures coult be wrong\n");
      printf("  (.) Total allocation during the function\n");
      if(profiled_functions_count)
	printf("  (.) Average per call\n");
    }
    printf("\n\n");
  }
  
  slot_number = 0;
  
  for(current = current_table; current != (struct profiler_table *) NULL ; )
  {
    struct profiler_table_entry *entry;
    
    entries = current->entries;
    for(i=0 ; i<current->next_entry ; i++)	
    {
      if(! dont_sort)
	entry = table[slot_number].entry;
      else
	entry = entries+i;
      
      if(print)
      {
	/* Print out the call counts */
	if(profiled_functions_count) 
	{
	  rough = 100.0 * entry->number_of_calls / profiled_functions_count;
	  if(entry->number_of_calls)
	    printf("%10u %5.2f%% ",entry->number_of_calls,rough);
	  else
	    printf("                  ");
	}
	
	if(top_of_stack_functions_count)
	{
	  rough = 100.0 * entry->top_of_stack / top_of_stack_functions_count;
	  if(entry->top_of_stack)
	    printf("%5.2f%% ",rough);
	  else
	    printf("       ");
	}
	
	if(number_of_stack_scans)
	{
	  rough = (float) entry->found_on_stack / (float) number_of_stack_scans;
	  if(entry->found_on_stack)
	  {
	    printf("%10u %6.2f %4u ",entry->found_on_stack,rough,entry->maximal_live_stack_count);
	    if(entry->self_call_max > 1)
	      printf("%5d ",entry->self_call_max);
	    else
	      printf("      ");
	  }
	  else	
	    printf("                             ");
	}
	
	if(allocation_monitored)
	{
	  if(entry->allocation)
	    printf("%10u ",entry->allocation);
	  else
	    printf("           ");
	  if(profiled_functions_count)
	  {
	    if(entry->allocation && entry->number_of_calls)
	      printf("%10u ",entry->allocation / entry->number_of_calls);
	    else
	      printf("           ");
	  }
	}
	
	printf("%s\n",entry->name);
      }
      
      slot_number++;
    }
    temp=current->previous;
    free(current);
    current=temp;
  }
  if(table != (struct sort_table_entry *) NULL)
    free(table);
  
  registered=0;
  profiler_missed = 0;
  current_table = NULL;
@


1.7
log
@Tried to eliminate some dependencies on the type checker and also some
very poor C.
@
text
@d8 4
d395 1
a395 1
		 offsetof(struct profiler_table_entry, number_of_calls));
@


1.6
log
@Tidying, and moved in_ML here since it isn't (going to be) used
from the storage manager.
@
text
@d8 4
d29 1
d39 1
a39 1
#define sparc 
d41 2
d62 1
a62 1
  constants are in the ML heap - if this is the case then the count in the table entry
d98 2
a99 2
  int unoptimised_self_call_max;
  };	
d141 1
a141 1
mlval register_code(mlval packet,int initial_call_count,int initial_top_of_stack_count)     
d143 4
a146 5
  word closure = packet ;
  word code = P(closure-1);
  word offset = P(code + 7);
  char *name = (char *) (code + offset);
  char *copied_name = (char *) calloc(strlen(name)+1, sizeof(char));
d149 6
a154 7
  /* Set the profiling slot with an unaligned pointer
     to signify profiling turned off */
  if(! profiling_turned_on)
  {
    P(code+3) = (word) 1;
    return((mlval) 0);
  };
d156 1
a156 1
  if(copied_name == (char *) NULL)
d158 2
a159 2
    if(! warning_issued)
      fprintf(stderr,"\n*** WARNING - Profiler cannot get more memory - not profiling some functions\n\n");
d161 2
a162 2
    return((mlval) 0);
  };
d171 1
a171 1
	calloc(50,sizeof(struct profiler_table_entry));
d174 1
a174 1
	calloc(1,sizeof(struct profiler_table));
d179 6
a184 6
      {
	if(! warning_issued)
	  fprintf(stderr,"\n*** WARNING - Profiler cannot get more memory - not profiling some functions\n\n");
	warning_issued = 1;
	return((mlval) 0);
      };
a191 1
  {
a192 1
  };
d202 1
a202 1
  profiler_table[current_table->next_entry].unoptimised_self_call_max = 0;
d204 2
a205 2
  P(code+3) = (word) & profiler_table[current_table->next_entry].number_of_calls;
  declare_weak(& profiler_table[current_table->next_entry].code_object,kill_profiler_entry);
d208 1
a208 1
  return(P(code+3));
a246 1
  {
a247 1
  }	
a248 1
  {
a249 1
  }
d254 53
d317 1
a317 1
void alarm_handler(int sig,int code,struct sigcontext *scp,char *addr)
d319 3
a321 3
  word address = (word) scp->sc_sp;
  word constants = (word) P((word) scp->sc_sp + 36);
  word pc = (word) scp->sc_pc;
d323 3
d327 2
a328 3
  int unoptimised_self_call_constants = constants;
  int *unoptimised_self_call_entry = NULL;
  int unoptimised_self_call_count = 0;
d330 7
a336 1
  if(inside_alarm_handler ==0)
d338 1
a338 1
    inside_alarm_handler = 1;
d340 1
a340 1
    number_of_stack_scans ++;
d342 1
a342 2
    DIAGNOSTIC(4,"pc %x constants %x",pc,constants);
    DIAGNOSTIC(4," %x  %x",typemap[BLKNO(pc)],typemap[BLKNO(constants)]);
d344 2
a345 7
    if(in_ML
       && address < MEMLIMIT
       && constants < MEMLIMIT
       && pc < MEMLIMIT
       && typemap[BLKNO(address)] == STACKBLK 
       && typemap[BLKNO(constants)]==HEAPBLK
       && (typemap[BLKNO(pc)] == HEAPBLK || (PC_FOR_ML_RAISE(pc))))
d347 1
a347 7
      word code = P(constants-1);
      unsigned int *increment_address;
      
      DIAGNOSTIC(4,"In top of stack view %s",(char *) (code + P(code+7)),0);
      
      /* If zero, this thing is not being profiled */
      if((int) P(code+3))
d349 4
a352 8
	if((((int) P(code+3)) & 3) == 0)
	{
	  increment_address = ((unsigned int *) P(code+3)) + 1;
	  DIAGNOSTIC(4,"Alarm handled",0,0);	
	  DIAGNOSTIC(4,"Address 0x%x Constants 0x%x ",address,constants);
	  DIAGNOSTIC(4,"Changing the address %p",increment_address,0);
	  (*increment_address) ++;
	};
d354 1
a354 3
      else
	register_code(constants,0,1);
    }	
d356 26
a381 23
      profiler_missed++;
    
    /* Scan the entire ML stack to find the frames */	
    DIAGNOSTIC(4,"Entering stack walk %p",address,0);
    
    pc = (word) scp->sc_pc;
    while(scan_stack_profiling && in_ML && 
	  address && address < MEMLIMIT && (count_of_ml_frames==0 || typemap[BLKNO(address)]==STACKBLK))
    {
      DIAGNOSTIC(4,"Inside the stack walk",0,0);
      constants = P(address+36);
      if(constants < MEMLIMIT
	 && pc < MEMLIMIT
	 && typemap[BLKNO(address)] == STACKBLK 
	 && typemap[BLKNO(constants)]==HEAPBLK
	 && (typemap[BLKNO(pc)] == HEAPBLK || (PC_FOR_ML_RAISE(pc))))
      {	
	word code = P(constants-1);
	unsigned int *increment_address;
	count_of_ml_frames ++;
	DIAGNOSTIC(4,"Inside stack walk %s %x",(char *) (code + P(code+7)),P(code+3));	
	
	if(((int) P(code+3) & 3) == 0)
d383 4
a386 1
	  if((int) P(code+3))
d388 26
a413 3
	    DIAGNOSTIC(4,"Incrementing",0,0);
	    increment_address = ((unsigned int *) P(code+3)) + 2;
	    (*increment_address) ++;	
d415 6
a420 29
	  else
	    increment_address = ((unsigned int *) register_code(constants,0,0)) + 2;
	  
	  if(increment_address[3]==number_of_stack_scans)
	    (increment_address[2]) ++;
	  else
	  {
	    if(increment_address[2] > increment_address[1])
	      increment_address[1] = increment_address[2];
	    increment_address[2] = 1;
	    increment_address[3] = number_of_stack_scans;
	  };
	  
	  if(unoptimised_self_call_constants == constants)
	    unoptimised_self_call_count --;
	  else
	  {
	    if(unoptimised_self_call_count < 0 && unoptimised_self_call_entry != NULL)
	      *unoptimised_self_call_entry -= unoptimised_self_call_count;
	    unoptimised_self_call_count = increment_address[5]-1;
	    unoptimised_self_call_entry = (int *) (increment_address + 5);
	    unoptimised_self_call_constants = constants;
	  };
	};	
      };	
      pc = P(address+60);	
      address = P(address + 56);
    };
    DIAGNOSTIC(4,"Exiting %p",address,0);
d426 3
a428 2
    
    set_profiler_timer_going();
d430 1
a430 2
    inside_alarm_handler = 0;
  };
d433 1
a433 4
struct sigvec vec =
{alarm_handler,
    SIGVTALRM,
   SV_ONSTACK};
a436 3
extern int sigstack (struct sigstack *ss, struct sigstack *oss);
extern int sigvec(int sig,struct sigvec *vec, struct sigvec *ovec);

d440 1
a440 1
  stack = calloc(SIGNAL_STACK_SIZE,sizeof(char));
d483 1
a483 1
    
d496 1
a496 1
	P((word) entries[i].code_object + 3) = 0;
d498 1
a498 1
      };
d505 1
a505 1
    };
d507 1
a507 1
  };
d509 1
a509 1
if(! dont_sort)
d514 1
a514 1

d529 1
a529 1
	};
d531 1
a531 1
      };
d533 3
a535 3
    };
  };

d552 1
a552 1
    };
d556 5
a560 5
      {
	printf(" Using simple call counting\n");
	printf("  (.) Call count for the function\n");
	printf("  (.) Percentage of the total calls counted\n");
      };
d572 1
a572 1
    };
d581 1
a581 1
    };
d583 2
a584 2
  };

d586 1
a586 1

d590 1
a590 1
  
d598 1
a598 1

d603 8
a610 8
	  {
	    rough = 100.0 * entry->number_of_calls / profiled_functions_count;
	    if(entry->number_of_calls)
	      printf("%10u %5.2f%% ",entry->number_of_calls,rough);
	    else
	      printf("                  ");
	  };

d612 12
d625 3
a627 3
	    rough = 100.0 * entry->top_of_stack / top_of_stack_functions_count;
	    if(entry->top_of_stack)
	      printf("%5.2f%% ",rough);
d629 6
a634 18
	      printf("       ");
	  };

	if(number_of_stack_scans)
	  {
	    rough = (float) entry->found_on_stack / (float) number_of_stack_scans;
	    if(entry->found_on_stack)
	      {
		printf("%10u %6.2f %4u ",entry->found_on_stack,rough,entry->maximal_live_stack_count);
		if(entry->unoptimised_self_call_max > 1)
		  printf("%5d ",entry->unoptimised_self_call_max);
		else
		  printf("      ");
	      }
	    else	
	      printf("                             ");
	  };

d636 6
d643 2
a644 2
	    if(entry->allocation)
	      printf("%10u ",entry->allocation);
d647 3
a649 9
	    if(profiled_functions_count)
	      {
		if(entry->allocation && entry->number_of_calls)
		  printf("%10u ",entry->allocation / entry->number_of_calls);
		else
		  printf("           ");
	      };
	  };

d651 2
a652 2
      };

d654 1
a654 1
    };
d658 1
a658 1
  };
d661 1
a661 1

@


1.5
log
@Fixed the bug where the stack interrupt stack was not being set up correctly
@
text
@d8 15
a22 2
Revision 1.4  1992/05/14  10:19:57  clive
Added some code for memory profiling and corrected some bugs
a23 11
Revision 1.3  1992/05/06  13:47:52  clive
Not clearing the global table pointer, when the table has been cleared

Revision 1.2  1992/05/05  11:07:01  clive
Sort on name as well as number of calls

Revision 1.1  1992/04/14  16:14:18  clive
Initial revision

*/

d66 2
@


1.4
log
@Added some code for memory profiling and corrected some bugs
@
text
@d8 3
d27 1
d228 1
a228 1
void set_timer(void)
d258 2
d272 1
a272 12
  number_of_stack_scans ++;

  DIAGNOSTIC(4,"pc %x constants %x",pc,constants);
  DIAGNOSTIC(4," %x  %x",typemap[BLKNO(pc)],typemap[BLKNO(constants)]);

  if(in_ML
     && address < MEMLIMIT
     && constants < MEMLIMIT
     && pc < MEMLIMIT
     && typemap[BLKNO(address)] == STACKBLK 
     && typemap[BLKNO(constants)]==HEAPBLK
     && typemap[BLKNO(pc)] == HEAPBLK)
d274 1
a274 2
    word code = P(constants-1);
    unsigned int *increment_address;
d276 1
a276 1
    DIAGNOSTIC(4,"%s",(char *) (code + P(code+7)),0);
d278 2
a279 14
    /* If zero, this thing is not being profiled */
    if((int) P(code+3))
    {
      increment_address = ((unsigned int *) P(code+3)) + 1;
      DIAGNOSTIC(4,"Alarm handled",0,0);	
      DIAGNOSTIC(4,"Address 0x%x Constants 0x%x ",address,constants);
      DIAGNOSTIC(4,"Changing the address %p",increment_address,0);
      (*increment_address) ++;
    }
    else
      register_code(constants,0,1);
  }	
  else
    profiler_missed++;
d281 3
a283 8
/* Scan the entire ML stack to find the frames */	
  DIAGNOSTIC(4,"Entering stack walk %p",address,0);
  pc = (word) scp->sc_pc;
  while(scan_stack_profiling && in_ML && 
	address && address < MEMLIMIT && (count_of_ml_frames==0 || typemap[BLKNO(address)]==STACKBLK))
  {
    constants = P(address+36);
    if(constants < MEMLIMIT
d287 2
a288 2
       && typemap[BLKNO(pc)] == HEAPBLK)
    {	
d291 3
a293 2
      count_of_ml_frames ++;
      DIAGNOSTIC(4,"%s",(char *) (code + P(code+7)),0);	
d297 8
a304 2
	increment_address = ((unsigned int *) P(code+3)) + 2;
	(*increment_address) ++;	
d307 26
a332 6
	increment_address = ((unsigned int *) register_code(constants,0,0)) + 2;

	/* Do a count of the maximal times on the stack */
	if(increment_address[3]==number_of_stack_scans)
	  (increment_address[2]) ++;
	else
d334 38
a371 5
	  if(increment_address[2] > increment_address[1])
	    increment_address[1] = increment_address[2];
	  increment_address[2] = 1;
	  increment_address[3] = number_of_stack_scans;
	};
d373 3
a375 15
      if(unoptimised_self_call_constants == constants)
	unoptimised_self_call_count --;
      else
      {
	if(unoptimised_self_call_count < 0 && unoptimised_self_call_entry != NULL)
	  *unoptimised_self_call_entry -= unoptimised_self_call_count;
	unoptimised_self_call_count = increment_address[5]-1;
	unoptimised_self_call_entry = (int *) (increment_address + 5);
	unoptimised_self_call_constants = constants;
      };
    };	
    pc = P(address+60);	
    address = P(address + 56);
};
  DIAGNOSTIC(4,"Exiting %p",address,0);
d377 2
a378 4
  if(maximal_depth_of_stack < count_of_ml_frames)
    maximal_depth_of_stack = count_of_ml_frames ;

  set_timer();
d393 3
a395 2
  new_stack.ss_sp = calloc(8000,sizeof(char));
  if(new_stack.ss_sp == NULL)
d397 2
d400 1
a400 1
  DIAGNOSTIC(4,"Setting the alarm signal",0,0);
a402 1
  set_timer();
d449 1
d498 1
a498 1
	     "not finding ML functions. \n",
d500 2
a501 1
	     100.0 * (float) profiler_missed / (profiler_missed + top_of_stack_functions_count));
d503 4
a506 1
      printf("Maximal depth of the stack found while time profiling found to be %u\n",maximal_depth_of_stack);
@


1.3
log
@Not clearing the global table pointer, when the table has been cleared
@
text
@d8 3
a32 5
  There are two types of the profiling which are provided in the following code.
  (i)  on entry profiling which counts the calls of the function
  (ii) time-sampling of the image, which samples the image every *profile_every 
  microseconds of virtual time, and records which ML function we are in
  
d51 5
a55 2
  Othwise, nothing is done.

d59 1
d64 3
a66 1
   the root pointer given to the weak root kill function to a structure
d75 9
d126 1
a126 1
void register_code(mlval packet,int initial_call_count)     
d140 1
a140 1
    return;
d148 1
a148 1
    return;
d170 1
a170 1
	return;
d185 7
a191 1
  profiler_table[current_table->next_entry].top_of_stack = 0;
d196 2
d209 2
a210 1
  register_code(packet,1);
d252 3
d260 1
d262 6
d282 3
d292 3
a294 1
    };	
d299 56
d405 1
d408 1
a408 1
  float percentage1,percentage2;
a412 1

d429 4
d436 2
a437 2

  if(! dont_sort)
d475 2
d478 29
a506 5
    printf("  Total             %% of\n");
    printf("  Number     %% of   Times\n");
    printf(" Of Times    Total  Found                          Function Name \n");
    printf("  Called            Top of\n");
    printf("                    Stack\n");
d522 1
a522 6
      if(profiled_functions_count) 
	percentage1 = 100.0 * entry->number_of_calls / profiled_functions_count;
      else percentage1 = 0.0 ;
      if(top_of_stack_functions_count)
	percentage2 = 100.0 * entry->top_of_stack / top_of_stack_functions_count;
      else percentage2 = 0.0;
d524 53
a576 2
	printf("%10u %5.2f%% (%5.2f%%) %s\n",entry->number_of_calls,percentage1,
	       percentage2,entry->name);
@


1.2
log
@Sort on name as well as number of calls
@
text
@d8 3
d183 2
d187 1
d320 2
a321 2
  if(print)
    printf("Profiler statistics\n");	
d367 1
a367 1
  if(print)
d369 1
a369 1
    printf("Profiling information obtained for %d functions \n",number_of_functions);
d374 2
a375 2
	     " profiling every %ld usec with %4.1f%% of the time profiles \n"
	     " not finding ML functions \n",
d416 2
a417 1
  current=NULL;
d419 1
@


1.1
log
@Initial revision
@
text
@d8 3
a84 1
  int value;
d289 6
a294 1
  return((int) (arg2->value - arg1->value));
a351 1
	  table[slot_number].value = entries[i].number_of_calls;
@
