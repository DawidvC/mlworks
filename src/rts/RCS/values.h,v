head	1.45;
access;
symbols
	Final_version_of_old_runtime:1.45
	ML_revised_beta_release_25/05/94:1.45
	ML_final_beta_release_02/03/94:1.45
	mlworks-28-01-1994:1.45
	Release:1.45
	mlworks-beta-01-09-1993:1.45
	MLWorks-1-0-3-21/12/1992:1.37
	MLWorks-1-0-2-15/12/1992:1.37
	MLWorks-1-0-1-04/12/1992:1.37
	checkpoint_17_08_92:1.33;
locks; strict;
comment	@ *  @;


1.45
date	93.06.02.13.15.36;	author richard;	state Exp;
branches
	1.45.1.1;
next	1.44;

1.44
date	93.04.19.13.08.09;	author richard;	state Exp;
branches;
next	1.43;

1.43
date	93.03.23.15.16.50;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	93.03.11.18.17.43;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	93.02.10.15.09.07;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	93.02.02.17.21.23;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	93.02.01.16.07.38;	author richard;	state Exp;
branches;
next	1.38;

1.38
date	93.01.14.14.55.07;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	92.10.26.13.03.22;	author richard;	state Exp;
branches;
next	1.36;

1.36
date	92.08.24.15.47.02;	author richard;	state Exp;
branches;
next	1.35;

1.35
date	92.08.19.15.50.31;	author richard;	state Exp;
branches;
next	1.34;

1.34
date	92.08.18.12.32.59;	author richard;	state Exp;
branches;
next	1.33;

1.33
date	92.08.11.11.24.32;	author richard;	state Exp;
branches;
next	1.32;

1.32
date	92.08.07.13.48.57;	author clive;	state Exp;
branches;
next	1.31;

1.31
date	92.08.05.16.52.17;	author richard;	state Exp;
branches;
next	1.30;

1.30
date	92.07.27.17.26.10;	author richard;	state Exp;
branches;
next	1.29;

1.29
date	92.07.15.15.35.35;	author richard;	state Exp;
branches;
next	1.28;

1.28
date	92.07.14.10.05.57;	author richard;	state Exp;
branches;
next	1.27;

1.27
date	92.07.03.07.21.03;	author richard;	state Exp;
branches;
next	1.26;

1.26
date	92.07.01.13.20.49;	author richard;	state Exp;
branches;
next	1.25;

1.25
date	92.06.24.12.28.01;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	92.04.06.08.53.45;	author richard;	state Exp;
branches;
next	1.23;

1.23
date	92.04.01.09.59.29;	author richard;	state Exp;
branches;
next	1.22;

1.22
date	92.03.23.12.27.33;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	92.03.18.13.31.21;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	92.03.11.12.31.04;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	92.03.06.14.32.09;	author clive;	state Exp;
branches;
next	1.18;

1.18
date	92.02.25.15.46.09;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.02.14.17.08.24;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	92.01.16.14.11.14;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.01.15.09.29.25;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	92.01.14.16.22.21;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	91.12.17.16.36.16;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	91.12.17.16.26.31;	author nickh;	state Exp;
branches;
next	1.11;

1.11
date	91.12.17.14.25.49;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	91.12.16.12.53.41;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	91.12.13.15.52.34;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	91.12.05.16.57.59;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	91.11.28.14.48.11;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.10.22.11.48.06;	author davidt;	state Exp;
branches;
next	1.5;

1.5
date	91.10.18.18.02.12;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	91.10.17.15.19.54;	author davidt;	state Exp;
branches;
next	1.3;

1.3
date	91.10.16.15.33.42;	author davidt;	state Exp;
branches;
next	1.2;

1.2
date	91.05.15.15.32.05;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.05.14.11.10.32;	author jont;	state Exp;
branches;
next	;

1.45.1.1
date	93.06.02.13.15.36;	author jont;	state Exp;
branches;
next	;


desc
@A description of the tuple system
@


1.45
log
@Added parentheses suggested by GCC 2.
@
text
@/*  ==== ML VALUE TOOLS ====
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Revision Log
 *  ------------
 *  $Log: values.h,v $
 *  Revision 1.44  1993/04/19  13:08:09  richard
 *  Changed val_print() for new value printer.
 *  Removed rusty polymorphic equality.
 *
 *  Revision 1.43  1993/03/23  15:16:50  jont
 *  Modified defn of CBYTEARRAY to account for using ref tags
 *
 *  Revision 1.42  1993/03/11  18:17:43  jont
 *  Moved ANCILLARY_SLOT_SIZE into here from loader.c
 *
 *  Revision 1.41  1993/02/10  15:09:07  jont
 *  Changes for code vector reform.
 *
 *  Revision 1.40  1993/02/02  17:21:23  jont
 *  Added ISORDPTR and ISREFPTR to distinguish these types
 *
 *  Revision 1.39  1993/02/01  16:07:38  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.38  1993/01/14  14:55:07  daveb
 *  Changed definitions of MLHEAD and MLTAIL to use new list representation.
 *
 *  Revision 1.37  1992/10/26  13:03:22  richard
 *  Removed gross CCVNAME hack.
 *
 *  Revision 1.36  1992/08/24  15:47:02  richard
 *  Corrected bytearray and real number macros.
 *
 *  Revision 1.35  1992/08/19  15:50:31  richard
 *  Corrected the definition of CCVSTART and CCVEND.
 *
 *  Revision 1.34  1992/08/18  12:32:59  richard
 *  Added CCVEND().
 *
 *  Revision 1.33  1992/08/11  11:24:32  richard
 *  Added alignment predicates.
 *
 *  Revision 1.32  1992/08/07  13:48:57  clive
 *  Changed the functionality of some of the debugger functions - added support
 *  for tracing
 *
 *  Revision 1.31  1992/08/05  16:52:17  richard
 *  Code vectors are now tagged differently to strings.
 *
 *  Revision 1.30  1992/07/27  17:26:10  richard
 *  Added stuff to deal with exceptions.
 *
 *  Revision 1.29  1992/07/15  15:35:35  richard
 *  Changed MLSUB to use the new ml_array_header structure.
 *
 *  Revision 1.28  1992/07/14  10:05:57  richard
 *  Changed definition of FIXABLE to include WEAKARRAY objects.
 *  Reimplemented CCV macros to use code_vector_header structure.
 *  Corrected definition of MLSUB to use a type cast.
 *
 *  Revision 1.27  1992/07/03  07:21:03  richard
 *  Moved tags to tags.h so that they can be used from assembler.
 *
 *  Revision 1.26  1992/07/01  13:20:49  richard
 *  Added array handling macros.
 *
 *  Revision 1.25  1992/06/24  12:28:01  richard
 *  Added some extra macros to keep the new version of fixup() tidy.
 *
 *  Revision 1.24  1992/04/06  08:53:45  richard
 *  Changed evacuation to a uniform marker, freeing one header tag.
 *
 *  Revision 1.23  1992/04/01  09:59:29  richard
 *  Changed `CAR' and `CDR' to `HEAD' and `TAIL' on request from
 *  Jon who doesn't like using the names of ``registers on ancient
 *  machines''.
 *
 *  Revision 1.22  1992/03/23  12:27:33  richard
 *  Added `FIXABLE' predicate.
 *
 *  Revision 1.21  1992/03/18  13:31:21  richard
 *  Generalised parameter mechanism to val_print().
 *
 *  Revision 1.20  1992/03/11  12:31:04  richard
 *  The length of a C string is one less than the length in the header, which
 *  includes the terminating '\0'.
 *
 *  Revision 1.19  1992/03/06  14:32:09  clive
 *  Added string length
 *
 *  Revision 1.18  1992/02/25  15:46:09  clive
 *  Added val_print in the System structure in ML
 *
 *  Revision 1.17  1992/02/14  17:08:24  richard
 *  Added extra debugging information to val_print.  This is switched on with the
 *  `-i' option.  (See main.c)
 *
 *  Revision 1.16  1992/01/16  14:11:14  richard
 *  Added ARRAYHEADER and changed CARRAY as the primary tag for arrays is now
 *  REFPTR.  Changed some explicit uses of `5' to POINTER.
 *
 *  Revision 1.15  1992/01/15  09:29:25  richard
 *  Removed definition of NULL.  (Who put it there?)
 *
 *  Revision 1.14  1992/01/14  16:22:21  richard
 *  Added FOLLOWBACK.
 *
 *  Revision 1.13  1991/12/17  16:36:16  richard
 *  Fixed SETREAL..
 *
 *  Revision 1.12  91/12/17  16:26:31  nickh
 *  added P(x) to dereference a pointer value (used extensively in gc).
 *  
 *  Revision 1.11  91/12/17  14:25:49  richard
 *  Added macros for dealing with reals.
 *  
 *  Revision 1.10  91/12/16  12:53:41  richard
 *  Added SETCAR and SETCDR, polymorhpic equality, and list cons.
 *  
 *  Revision 1.9  91/12/13  15:52:34  richard
 *   Tidied up and added macros for dealing with some predefined ML types
 *  such as list.
 *  
 *  Revision 1.8  91/12/05  16:57:59  richard
 *  Added MLTRUE and MLFALSE.
 * 
 *  Revision 1.7  91/11/28  14:48:11  richard
 *  Added MLUNIT.
 * 
 *  Revision 1.6  91/10/22  11:48:06  davidt
 *  Put in various casts so that macros work correctly when
 *  passed values of pointer type.
 * 
 *  Revision 1.5  91/10/18  18:02:12  davidt
 *  Put in word_align and NFIELDS.
 * 
 *  Revision 1.4  91/10/17  15:19:54  davidt
 *  Major changes. This file now includes lots of utilities for
 *  creating and untagging ML values.
 * 
 *  Revision 1.3  91/10/16  15:33:42  davidt
 *  Putin double_align macro. I intend this file have general value
 *  manipulation utilities eventually.
 * 
 *  Revision 1.2  91/05/15  15:32:05  jont
 *  Revised interface for second version of load format
 * 
 *  Revision 1.1  91/05/14  11:10:32  jont
 *  Initial revision
 */


#ifndef values_h
#define values_h

#include "mltypes.h"
#include "implicit.h"
#include "tags.h"

#include <stddef.h>
#include <stdio.h>


#define word_align(x)		(((word)(x) + 3) & ~3)
#define double_align(x) 	(((word)(x) + 7) & ~7)
#define is_word_aligned(x)	(!((word)(x) & 3))
#define is_double_aligned(x)	(!((word)(x) & 7))


/*  == Primary tag manipulation ==
 *
 *  PRIMARY(x)    extracts the primary tag (see above) from value x
 *  OBJECT(x)     a pointer to the header of the object pointed to by x
 *  ISPTR(x)      true iff x is a pointer
 *  ISORDPTR	  true iff x is a PAIRPTR or RECORDPTR
 *  ISREFPTR	  true iff x is a reference type pointer
 *  MLINT(x)      makes a tagged integer value from an integer
 *  MLPTR(t,p)    makes a pointer to p with tag t
 *  CINT(x)       extracts the integer from an integer value
 *  CPTR(x)       extracts the pointer from a pointer value
 *  DEREF(x)      extracts the value referenced by a reference pointer
 *  FOLLOWBACK(x) follows a BACKPTR to the main object (see secondaries)
 */

#define PRIMARY(x)	((mlval)(x) & 7)
#define OBJECT(x)	((mlval *)((x) & ~7))
#define ISPTR(x)	((mlval)(x) & 1)
#define ISORDPTR(x)	(((mlval)(x) & 3) == 1)
#define ISREFPTR(x)	(((mlval)(x) & 3) == 3)
#define MLINT(i)	((mlval)(i) << 2)
#define MLPTR(t,p)      ((mlval)(t) + (mlval)(p))
#define CINT(i)		((int)(i) >> 2)
#define CPTR(p)         ((mlval *)(p-1))
#define DEREF(x)        ((mlval)(*(mlval *)((x)+9)))
#define FOLLOWBACK(p)	((mlval)((word)(p)-LENGTH(*(word *)((word)(p)-POINTER))))


/*  == Secondary tag manipulation ==
 *
 *  Note: EQUALITY and POINTERS are only defined for normal objects.
 *
 *  SECONDARY(x)  extracts the secondary tag from header word x
 *  ISNORMAL(x)   true iff x is a header from an ordinary record (see above)
 *  EQUALITY(x)   true iff the record has simple equality
 *  POINTERS(x)   true iff the record contains pointers
 *  MAKEHEAD(t,l) make a header word for a record of length l with tag t
 *  LENGTH(x)     returns the length of the record
 *  WLENGTH(l)    converts a string length into a length in words
 *  FIXABLE(x)    false iff x is a STRING, BYTEARRAY, WEAKARRAY, or CODE
 */

#define SECONDARY(x)	((x) & 63)
#define ISNORMAL(x)	(!((x) & 32))
#define EQUALITY(x)	(!((x) & 16))
#define POINTERS(x)	(!((x) & 8))
#define MAKEHEAD(t,l)	(((l) << 6) + (t))
#define LENGTH(x)	((x) >> 6)
#define WLENGTH(l)      (((l)+3) >> 2)
#define FIXABLE(x)	(((x) & 0xF) ^ 0xA)


/*  === ML OBJECTS ===  */

/*  == Strings ==
 *
 *  Strings are records with header tag STRING and length equal to the
 *  number of characters in the string.
 *
 *  CSTRING(x)  returns a char * pointing to the string from string value x
 */

#define CSTRING(p) ((char *)(p) - 1)
#define CSTRINGLENGTH(x) (LENGTH(GETHEADER(x))-1)

/*  == Code vectors ==
 *
 *  Code vectors have a GC field at the beginning which points to an array
 *  containing extra information about the code.  This is called the code
 *  ancillary.  See also the ANC_ macros in tags.h.
 *
 *  CCVANCILLARY(p)	fetches the ancillary array from a (whole) code vector
 *  CCODEANCILLARY(p)	as above but p is a code item within the vector
 *  CCODENUMBER(p)	the number (index) of the code item within the vector
 *
 *  For convenience:
 *  CCODEANCSUB(p, f)	fetches value from ancillary slot f
 *                      corresponding to the code vector number of p
 *  CCODEANCUPDATE(p, f, v)
 *              	updates value in ancillary slot f
 *                      corresponding to the code vector number of p
 *  CCODESPILLS(p)	the number of spills for a code item within a vector
 *  CCODENAME(p)	the name string of a code item
 */

#define CCVANCILLARY(p)		(((struct code_vector_header *)OBJECT(p))->ancillary)
#define CCODEANCILLARY(p)	CCVANCILLARY(FOLLOWBACK(p))
#define CCODENUMBER(p)		(((struct code_item_header *)OBJECT(p))->number)
#define CCODESTART(p)		(((struct code_item_header *)OBJECT(p))->instruction)

#define CCODEANCSUB(p, f) \
  MLSUB(MLSUB(CCODEANCILLARY(p), ANC_ ## f), CCODENUMBER(p))
#define CCODEANCUPDATE(p, f, v)	\
  MLUPDATE(MLSUB(CCODEANCILLARY(p), ANC_ ## f), CCODENUMBER(p), (v))
#define CCODESPILLS(p)  	CCODEANCSUB(p, SPILLS)
#define CCODENAME(p)		CCODEANCSUB(p, NAMES)

/*  == Arrays and bytearrays ==
 *
 *  CARRAY(r)      returns a pointer to the word array
 *  CBYTEARRAY(r)  returns a pointer to a byte array
 */

#define ARRAYHEADER(r)	(*(mlval *)((r)-REFPTR))
#define CARRAY(r)     	((word *)((r)-REFPTR+12))
#define CBYTEARRAY(r) 	((byte *)((r)+1))

/*  == Records and tuples ==
 *
 *  Note: These are only defined for values with tag POINTER or
 *        PAIRPTR.
 *
 *  NFIELDS(r)       return the number of fields in a record
 *  GETHEADER(r)     fetches the header word from a record, or makes one
 *                   of length 2 for pairs
 *  FIELD(r,i)	     the value at position i within a record (an lvalue)
 *  GETFIELD(r,i)    fetches the value at position i within a record
 *  SETFIELD(r,i,v)  sets position i to value v, returns r
 */

#define NFIELDS(r) ((PRIMARY(r) == PAIRPTR) ? 2 : LENGTH(*(mlval *)((r)-POINTER)))
#define GETHEADER(r) (PRIMARY(r) == PAIRPTR ? MAKEHEAD(RECORD, 2) : *(mlval *)((r)-POINTER))
#define FIELD(r,i)	(((mlval *)((r) - 1))[i])

/*  == Booleans ==
 *
 *  False is represented by the integer 0, true by 1.
 */

#define MLFALSE MLINT(0)
#define MLTRUE  MLINT(1)

/*  == Unit ==
 *
 *  Unit is represented by the integer 0.
 */

#define MLUNIT MLINT(0)

/*  == Lists ==
 *
 *  nil is represented by the integer 1, and x::y is represented by a
 *  record {x, y} (was {0, {x, y}} )
 *
 *  MLNIL        the value representing nil
 *  MLISNIL(x)   true iff the list x is nil
 *  MLHEAD(x)    the head of the list x, defined iff x is not nil
 *  MLTAIL(x)    the tail of the list x, defined iff x is not nil
 *
 *  See also `cons'.
 */

#define MLNIL        MLINT(1)
#define MLISNIL(x)   ((x) == MLNIL)
#define MLHEAD(x)    FIELD(x, 0)
#define MLTAIL(x)    FIELD(x, 1)

/*  == Arrays ==
 *
 *  MLSUB(a,x)       extract element x of array a
 *  MLUPDATE(a,x,y)  update element x of array a with y
 */

extern void mlupdate(mlval array, mlval subscript, mlval x);
#define MLSUB(a,x)      (((union ml_array_header *)((a)-REFPTR))->the.element[x])
#define MLUPDATE(a,x,y) mlupdate(a,x,y)

/*  == Refs ==
 *
 *  MLDEREF(r)	     extract the value in ref cell r
 *  ref(x)	     create a ref cell containing x
 */

#define MLDEREF(r)	MLSUB(r, 0)
extern mlval ref(mlval value);

/*  == Reals ==
 *
 *  At the moment only one size (double) is supported.  A real is
 *  written into a string, and it indistinguishable from some strings.
 *  The macro MLISREAL tests whether it is _possible_ that it's a
 *  real, it might be a random bytearray.
 *    MLISREAL(s)   could bytearray s contain a real?
 *    SETREAL(s,r)  stores the double r in the bytearray s, returns s
 *    GETREAL(s)    retrieves a double from a bytearray
 */

#define MLISREAL(s)  (LENGTH(GETHEADER(s)) == 12)
#define SETREAL(s,r) (*(double *)(CSTRING(s)+4) = (r), s)
#define GETREAL(s)   (*(double *)(CSTRING(s)+4))

/*  == Exceptions ==
 *
 *  MLEXNNAME(p)    extracts the exception name from the packet p
 *  MLEXNARG(p)     extracts the exception argument from the packet p
 *  exn_name(n)     creates an exception name from a C string
 *  exn(n, a)       creates an exception packet from a name and an argument
 */

#define MLEXNNAME(p)	FIELD(p, 0)
#define MLEXNARG(p)	FIELD(p, 1)

extern mlval exn_name(const char *name);
extern mlval exn(mlval exn_name, mlval argument);


/*  === LIST CONSTRUCTOR ===
 *
 *  Given two ML values x and y this function constructs the list
 *  x::y.
 */

mlval cons(mlval head, mlval tail);


#endif
@


1.45.1.1
log
@Fork for bug fixing
@
text
@a7 3
 *  Revision 1.45  1993/06/02  13:15:36  richard
 *  Added parentheses suggested by GCC 2.
 *
@


1.44
log
@Changed val_print() for new value printer.
Removed rusty polymorphic equality.
@
text
@d8 4
d221 1
a221 1
#define FIXABLE(x)	((x) & 0xF ^ 0xA)
@


1.43
log
@Modified defn of CBYTEARRAY to account for using ref tags
@
text
@d8 3
d235 3
a237 1
 *  Code vectors are strings with some extra information stored in them.
d239 12
a250 5
 *  CCVSPILLS(p)	the number of non-gc spills required by the code
 *  CCVPROFILE(p)	profiler information slot (see profiler.c)
 *  CCVNAME(p)		the name string of the code
 *  CCVSTART(p)		the start address of the machine code
 *  CCVEND(p)		the end address of the machine code
d253 4
a256 13
#define ANCILLARY(p) (*(mlval *)(FOLLOWBACK(p)-POINTER+sizeof(mlval)))
#define SPILLS(p) MLSUB(ANCILLARY(p),0)
#define NAMES(p) MLSUB(ANCILLARY(p),1)
#define PROFILES(p) MLSUB(ANCILLARY(p),2)
/*
#define CCVSPILLS(p)  (((struct code_vector_header *)OBJECT(p))->non_gc_area)
*/
#define CCVSPILLS1(p,i) MLSUB(SPILLS(p),i)
#define CCVPROFILE(p) MLSUB(PROFILES(p),FIELD(p,0))
#define CCVNAME(p) CSTRING(MLSUB(NAMES(p),FIELD(p,0)))
#define CCVNAME1(p,i)    MLSUB(NAMES(p),i) 
#define CCVSTART(p)   (&((struct code_vector_header *)OBJECT(p))->instruction[0])
#define CCVEND(p)     ((word *)(OBJECT(p) + LENGTH(GETHEADER(p))))
d258 7
a290 2
/* #define GETFIELD(r,i)	FIELD(r, i) */
/* #define SETFIELD(r,i,v)	((((mlval *)((r) - 1))[i] = (v)), r) */
d356 2
a357 2
#define SETREAL(s,r) (*(double *)(CBYTEARRAY(s)+4) = (r), s)
#define GETREAL(s)   (*(double *)(CBYTEARRAY(s)+4))
a369 5
/*
 * Code vector ancillary stuff
 */
#define ANCILLARY_SLOT_SIZE 5

a373 36
/*  === PRINT A VALUE ===
 *
 *  Prints a value to a stream in a fairly crude form for debugging
 *  purposes.  Integers are printed as themselves, strings are
 *  surrounded by quote characters and non-printable characters are
 *  escaped.  Records are displayed as `{x1,x2,...}', arrays as
 *  `[x1,x2,...]', byte arrays as `byte[c1,c2,...]byte', refs as `ref x',
 *  and strings are escaped properly so that they can be input back to
 *  ML.
 *
 *  The parameters parameter controls the way in which values are printed.
 *  If it is NULL the values specified in `val_print_defaults' are used.
 *
 *  The `depth' parameter controls the depth to which record and array
 *  contents are displayed.  Values which are more deeply nested are
 *  printed as `#' a la SML/NJ.  A negative depth is equivalent to an
 *  infinite depth.
 *
 *  If `internals' is non-zero then additional information such as generation
 *  numbers and addresses will be displayed.
 *
 *  The `string_length' parameter controls the maximum length of strings.
 *  Longer strings are truncated and `...' appended.
 */

extern struct val_print_parameters
{
  int internals;
  int string_length;
  int depth;
} val_print_defaults;

void val_print(FILE *stream, mlval value,
	       struct val_print_parameters *parameters);


a380 8


/*  === POLYMORPHIC EQUALITY ===
 *
 *  Given two ML values this function returns true iff they are equal.
 */

int equal(mlval, mlval);
@


1.42
log
@Moved ANCILLARY_SLOT_SIZE into here from loader.c
@
text
@d8 3
d263 1
a263 1
#define CBYTEARRAY(r) 	((byte *)((r)-1))
@


1.41
log
@Changes for code vector reform.
@
text
@d8 3
d358 6
@


1.40
log
@Added ISORDPTR and ISREFPTR to distinguish these types
@
text
@d8 3
d235 5
d241 5
a245 2
#define CCVPROFILE(p) (((struct code_vector_header *)OBJECT(p))->call_count)
#define CCVNAME(p)    ((char *)(p) + ((struct code_vector_header *)OBJECT(p))->name_offset)
d256 1
a256 1
#define CARRAY(r)     	((word *)((r)-REFPTR+4))
@


1.39
log
@Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
@
text
@d8 3
d161 2
d174 2
@


1.38
log
@Changed definitions of MLHEAD and MLTAIL to use new list representation.
@
text
@d8 3
d249 1
d256 3
a258 2
#define GETFIELD(r,i)	(((mlval *)((r) - 1))[i])
#define SETFIELD(r,i,v)	((((mlval *)((r) - 1))[i] = (v)), r)
d290 2
a291 2
#define MLHEAD(x)    GETFIELD(x, 0)
#define MLTAIL(x)    GETFIELD(x, 1)
d335 2
a336 2
#define MLEXNNAME(p)	GETFIELD(p, 0)
#define MLEXNARG(p)	GETFIELD(p, 1)
@


1.37
log
@Removed gross CCVNAME hack.
@
text
@d8 3
d273 1
a273 1
 *  record {0, {x, y}}
d285 2
a286 2
#define MLHEAD(x)    GETFIELD(GETFIELD(x, 1), 0)
#define MLTAIL(x)    GETFIELD(GETFIELD(x, 1), 1)
@


1.36
log
@Corrected bytearray and real number macros.
@
text
@d8 3
d221 1
a221 1
#define CCVNAME(p)    ((char *)(p) + (1 | ((struct code_vector_header *)OBJECT(p))->name_offset))
@


1.35
log
@Corrected the definition of CCVSTART and CCVEND.
@
text
@d8 3
d225 1
a225 1
 *  CBYTEARRAY(r)  returns a pointer to a char array
d230 1
a230 1
#define CBYTEARRAY(r) 	((char *)((r)-1))
d306 4
a309 4
 *  real, it might be a string.
 *    MLISREAL(s)   could string s contain a real?
 *    SETREAL(s,r)  stores the double r in the string s, returns s
 *    GETREAL(s)    retrieves a double from a string
d313 2
a314 2
#define SETREAL(s,r) (*(double *)(CSTRING(s)+4) = (r), s)
#define GETREAL(s)   (*(double *)(CSTRING(s)+4))
@


1.34
log
@Added CCVEND().
@
text
@d8 3
d213 4
a216 4
#define CCVSPILLS(p)  (((struct code_vector_header *)CSTRING(p))->non_gc_area)
#define CCVPROFILE(p) (((struct code_vector_header *)CSTRING(p))->call_count)
#define CCVNAME(p)    ((char *)(p) + (1 | ((struct code_vector_header *)CSTRING(p))->name_offset))
#define CCVSTART(p)   ((word *)(((struct code_vector_header *)CSTRING(p))+1))
@


1.33
log
@Added alignment predicates.
@
text
@d8 3
d206 2
a207 1
 *  CCVSTART(p)		the address of the first instruction
d213 2
a214 1
#define CCVSTART(p)   ((void *)(((struct code_vector_header *)CSTRING(p))+1))
@


1.32
log
@Changed the functionality of some of the debugger functions - added support
for tracing
@
text
@d8 4
d129 4
a132 2
#define word_align(x)	(((word)(x) + 3) & ~3)
#define double_align(x) (((word)(x) + 7) & ~7)
@


1.31
log
@Code vectors are now tagged differently to strings.
@
text
@d8 3
d202 1
a202 1
#define CCVNAME(p)    ((char *)(p) + ((struct code_vector_header *)CSTRING(p))->name_offset)
@


1.30
log
@Added stuff to deal with exceptions.
@
text
@d8 3
d161 1
a161 1
 *  FIXABLE(x)    false iff x is a STRING, BYTEARRAY, WEAKARRAY, (or BACKPTR)
@


1.29
log
@Changed MLSUB to use the new ml_array_header structure.
@
text
@d8 3
d269 9
d292 13
@


1.28
log
@Changed definition of FIXABLE to include WEAKARRAY objects.
Reimplemented CCV macros to use code_vector_header structure.
Corrected definition of MLSUB to use a type cast.
@
text
@d8 5
d263 1
a263 1
#define MLSUB(a,x)      (((mlval *)((union ml_array_header *)OBJECT(a)+1))[x])
@


1.27
log
@Moved tags to tags.h so that they can be used from assembler.
@
text
@d8 3
d150 1
a150 1
 *  FIXABLE(x)    false iff x is the header of a STRING or BYTEARRAY
d160 1
a160 1
#define FIXABLE(x)	((x) & 0x2F ^ 0xA)
d186 4
a189 4
#define CCVSPILLS(p)  (*(size_t *)((p)-1))
#define CCVPROFILE(p) (*(unsigned int **)((p)+3))
#define CCVNAME(p)    ((char *)((p) + *(word *)((p)+7)))
#define CCVSTART(p)   ((void *)((p)+11))
d258 1
a258 1
#define MLSUB(a,x)      (((mlval *)((a)-REFPTR+12))[x])
@


1.26
log
@Added array handling macros.
@
text
@d8 3
d102 1
a107 2
#define IMPOSSIBLE 1	/* Impossible value (pointer to zero)	*/

a111 20
/*  === PRIMARY TAGS ===
 *
 *  Every mlval is tagged in the bottom 3 bits as below.  Odd tags are
 *  always pointers, even tags are always immediates.  Possible uses
 *  for PRIMARY6 and PRIMARY7 include weak pointers,  floating-point,
 *  foreign pointers. Note that PAIRPTR and POINTER are such that
 *  (mlval - 1) is always the address of the first data word of the
 *  object (pairs being unheaded).
 */

#define INTEGER0 0		/* 000 : even integer		*/
#define PAIRPTR  1		/* 001 : pair pointer		*/
#define HEADER   2		/* 010 : header word		*/
#define REFPTR   3		/* 011 : reference pointer	*/
#define INTEGER1 4		/* 100 : odd integer		*/
#define POINTER  5		/* 101 : any other pointer	*/
#define PRIMARY6 6		/* 110 : unused : not a pointer	*/
#define PRIMARY7 7		/* 111 : unused : a pointer	*/


a135 25
/* de-pointer: 'a -> word. Used extensively in the gc. Note that P(x)
can be an lvalue or an rvalue. */

#define P(x)  *((word*)(x))


/*  === SECONDARY TAGS ===
 *
 *  These all live in header words.  Ordinary objects have bit 5 unset.
 *  For ordinary objects: objects with `normal' equality have bit 4
 *  unset, and objects containing pointers have bit 3 unset.  For back
 *  pointers the length field is the distance back to the start of the
 *  object.
 */

#define RECORD		 2	/* 000010 pointers, simple equality	*/
#define STRING		10	/* 001010 no pointers, simple equality	*/
#define ARRAY		18	/* 010010 pointers, ref equality 	*/
#define BYTEARRAY	26	/* 011010 no pointers, ref equality	*/
#define HEADER34	34	/* 100010 unused: abnormal object	*/
#define BACKPTR		42	/* 101010 back pointer (see above)	*/
#define HEADER50	50	/* 110010 unused: abnormal object	*/
#define HEADER58        58      /* 111010 unused: abnormal object	*/


a147 2
 *  EVACUATED	  a special value used to replace the header of evacuated
 *  		  objects so the GC can forward them
a157 1
#define EVACUATED	IMPOSSIBLE
d173 15
d212 2
a213 2
#define GETFIELD(r,i)	((mlval)(((mlval *)((r) - 1))[i]))
#define SETFIELD(r,i,v)	((mlval)(((mlval *)((r) - 1))[i] = (v)), r)
d248 1
a248 2

/*  === ARRAYS ===
d258 1
a258 2

/*  === REALS ===
@


1.25
log
@Added some extra macros to keep the new version of fixup() tidy.
@
text
@d8 3
d278 11
@


1.24
log
@Changed evacuation to a uniform marker, freeing one header tag.
@
text
@d8 3
d130 1
d141 1
d186 1
d198 1
@


1.23
log
@Changed `CAR' and `CDR' to `HEAD' and `TAIL' on request from
Jon who doesn't like using the names of ``registers on ancient
machines''.
@
text
@d8 5
d158 1
a158 2
 *  object.  Possibilities for HEADER50 and HEADER58 include weak
 *  pointers.
d165 1
a165 1
#define EVACUATED	34	/* 100010 only found when forwarding	*/
a180 1
 *  EVAC(x)       true iff the record has been evacuated (gc)
d182 2
a191 1
#define EVAC(x)		(SECONDARY(x) == EVACUATED)
d193 1
@


1.22
log
@Added `FIXABLE' predicate.
@
text
@d8 3
d251 4
a254 6
 *  MLNIL       the value representing nil
 *  MLISNIL(x)  true iff the list x is nil
 *  MLCAR(x)    the head of the list x, defined iff x is not nil
 *  MLCDR(x)    the tail of the list x, defined iff x is not nil
 *  SETCAR(l,x) overwrites the head of the list l with x
 *  SETCDR(l,x) overwrites the tail of the list l with x
d259 4
a262 6
#define MLNIL       MLINT(1)
#define MLISNIL(x)  ((x) == MLNIL)
#define MLCAR(x)    GETFIELD(GETFIELD(x, 1), 0)
#define MLCDR(x)    GETFIELD(GETFIELD(x, 1), 1)
#define SETCAR(l,x) (void)SETFIELD(GETFIELD(x, 1), 0, x)
#define SETCDR(l,x) (void)SETFIELD(GETFIELD(x, 1), 1, x)
@


1.21
log
@Generalised parameter mechanism to val_print().
@
text
@d8 3
d175 1
d185 1
@


1.20
log
@The length of a C string is one less than the length in the header, which
includes the terminating '\0'.
@
text
@d8 4
d287 4
a290 1
 *  The depth parameter controls the depth to which record and array
d295 5
a299 3
 *  The global `val_print_internals', if non-zero, will display additional
 *  information with each value such as address, generation number, entry
 *  list links, etc.
d302 9
a310 2
extern int val_print_internals ;
void val_print(FILE *stream, mlval value, int depth, int val_print_internals);
@


1.19
log
@Added string length
@
text
@d8 3
a75 1

d77 1
d190 1
a190 1
#define CSTRINGLENGTH(x) (LENGTH(GETHEADER(x)))
@


1.18
log
@Added val_print in the System structure in ML
@
text
@d8 3
d124 1
a124 1
#define DEREF(x)        ((mlval)(*(mlval *)((x)+1)))
d187 1
@


1.17
log
@Added extra debugging information to val_print.  This is switched on with the
`-i' option.  (See main.c)
@
text
@d8 4
d286 2
a287 2
extern int val_print_internals;
void val_print(FILE *stream, mlval value, int depth);
@


1.16
log
@Added ARRAYHEADER and changed CARRAY as the primary tag for arrays is now
REFPTR.  Changed some explicit uses of `5' to POINTER.
@
text
@d8 4
d276 4
d282 1
@


1.15
log
@Removed definition of NULL.  (Who put it there?)
@
text
@d8 3
d183 3
a185 2
#define CARRAY(r)     ((word *)((r)-1))
#define CBYTEARRAY(r) ((char *)((r)-1))
d199 2
a200 2
#define NFIELDS(r) ((PRIMARY(r) == PAIRPTR) ? 2 : LENGTH(*(mlval *)((r)-5)))
#define GETHEADER(r) (PRIMARY(r) == PAIRPTR ? MAKEHEAD(RECORD, 2) : *(mlval *)((r)-5))
@


1.14
log
@Added FOLLOWBACK.
@
text
@d8 3
a55 3
#include <stdio.h>

/* Avoid multiple inclusion */
d59 1
a59 2
/* For efficiency */
#ifndef mltypes_h
a60 1
#endif
d62 2
d65 1
a65 1
#define NULL	0	/* The null pointer 			*/
@


1.13
log
@Fixed SETREAL..
@
text
@d7 4
a10 1
 *  $Log:	values.h,v $
d101 1
d111 1
d113 1
d118 1
@


1.12
log
@added P(x) to dereference a pointer value (used extensively in gc).
@
text
@d8 3
d243 1
a243 1
#define SETREAL(s,r) ((void)(double *)(CSTRING(s)+4) = (r), s)
@


1.11
log
@Added macros for dealing with reals.
@
text
@d8 3
d105 4
@


1.10
log
@Added SETCAR and SETCDR, polymorhpic equality, and list cons.
@
text
@d8 3
d175 1
a175 1
 *  SETFIELD(r,i,v)  sets position i to value v
d181 1
a181 1
#define SETFIELD(r,i,v)	((mlval)(((mlval *)((r) - 1))[i] = (v)))
d217 18
a234 2
#define SETCAR(l,x) SETFIELD(GETFIELD(x, 1), 0, x)
#define SETCDR(l,x) SETFIELD(GETFIELD(x, 1), 1, x)
@


1.9
log
@ Tidied up and added macros for dealing with some predefined ML types
such as list.
@
text
@d8 4
d204 4
d210 6
a215 4
#define MLNIL      MLINT(1)
#define MLISNIL(x) ((x) == MLNIL)
#define MLCAR(x)   GETFIELD(GETFIELD(x, 1), 0)
#define MLCDR(x)   GETFIELD(GETFIELD(x, 1), 1)
d223 4
a226 1
 *  escaped.  Records are displayed as {x1,x2,...}.
d228 4
a231 3
 *  The depth parameter controls the depth to which record contents are
 *  displayed.  Values which are more deeply nested are printed as `#'
 *  a la SML/NJ.  A negative depth is equivalent to an infinite depth.
d235 17
@


1.8
log
@Added MLTRUE and MLFALSE.
@
text
@d1 9
a9 5
/*
 * values.h
 * $Log:	values.h,v $
 * Revision 1.7  91/11/28  14:48:11  richard
 * Added MLUNIT.
d11 2
a12 3
 * Revision 1.6  91/10/22  11:48:06  davidt
 * Put in various casts so that macros work correctly when
 * passed values of pointer type.
d14 3
a16 2
 * Revision 1.5  91/10/18  18:02:12  davidt
 * Put in word_align and NFIELDS.
d18 2
a19 3
 * Revision 1.4  91/10/17  15:19:54  davidt
 * Major changes. This file now includes lots of utilities for
 * creating and untagging ML values.
d21 3
a23 3
 * Revision 1.3  91/10/16  15:33:42  davidt
 * Putin double_align macro. I intend this file have general value
 * manipulation utilities eventually.
d25 3
a27 2
 * Revision 1.2  91/05/15  15:32:05  jont
 * Revised interface for second version of load format
d29 2
a30 2
 * Revision 1.1  91/05/14  11:10:32  jont
 * Initial revision
d32 2
a33 1
 * Copyright (c) 1991 Harlequin Ltd.
d36 3
a47 3
/*
 * Null pointer.
 */
d49 2
a50 1
#define NULL	0	
a51 10
/*
 * Impossible heap value (pointer to zero).
 */

#define IMPOSSIBLE 1

/*
 * Word and double word align an integer.
 */

d55 9
a63 7
/*
 * The primary tags. Every mlval is tagged in the bottom 3 bits as below.
 * Odd tags are always pointers, even tags are always immediates.
 * Possible uses for PRIMARY6 and PRIMARY7 include weak pointers,
 * floating-point, foreign pointers. Note that PAIRPTR and POINTER are
 * such that (mlval - 1) is always the address of the first data word of
 * the object (pairs being unheaded).
a74 3
/*
 * Utilities for dealing with primary tags.
 */
d76 9
a84 7
#define ISPTR(x)	((word)(x) & 1)		/* Is x a pointer	     */
#define MLINT(i)	((word)(i) << 2)	/* Make an ML integer value  */
#define CINT(i)		((word)(i) >> 2)	/* Make a C integer value    */
#define PRIMARY(x)	((word)(x) & 7)		/* The primary tag of x	     */

/*
 * Make word of value x, tag t.
d87 7
a93 1
#define MAKEWORD(t,x)	(((word)(x) << 3) + (word)(t))
a94 3
/*
 * Make pointer of value p, tag t.
 */
d96 8
a103 4
#define MLPTR(t,p)	((word)(t) + (word)(p))

/*
 * Get C pointer value. Don't use this if at all possible.
a105 10
#define CPTR(x)		((word)(x) & ~7)

/*
 * The secondary tags. These all live in header words. Ordinary objects have
 * bit 5 unset. For ordinary objects : objects with `normal' equality have
 * bit 4 unset, and objects containing pointers have bit 3 unset. For back
 * pointers the length field is the distance back to the start of the object.
 * Possibilities for HEADER50 and HEADER58 include weak pointers.
 */

d115 2
a116 2
/*
 * Utilities for dealing with secondary tags.
d118 9
a126 1
 * Note that EQUALITY and POINTERS are only defined for normal objects.
d129 7
a135 6
#define ISNORMAL(x)	(!((x) & 32)) 	   /* ordinary object		     */
#define EQUALITY(x)	(!((x) & 16))	   /* normal equality		     */
#define POINTERS(x)	(!((x) & 8))	   /* contains pointers		     */
#define HEADERTAG(x)	((x) & 63)	   /* the header tag		     */
#define MAKEHEAD(t,l)	(((l) << 6) + (t)) /* Header word of tag t, length l */
#define LENGTH(x)	((x) >> 6)	   /* length from a header	     */
a136 1
#define EVAC(x)		((HEADERTAG(x) == EVACUATED)	 /* is x evacuated ? */
d138 1
a138 3
/*
* Utilities for dealing with other ML objects
*/
d140 8
a147 1
/* Make a C string pointer */
d150 5
a154 2
/* Get the number of fields in a record */
#define NFIELDS(r) ((PRIMARY(r) == PAIRPTR) ? 2 : LENGTH(*(word *)((r)-5)))
d156 17
a172 1
/* Get a record field (works for any record pointer) */
a173 2

/* Set a record field (works for any record pointer) */
d176 45
a220 4
/* The value of unit, (); true and false */
#define MLUNIT 0
#define MLTRUE 4
#define MLFALSE 0
@


1.7
log
@Added MLUNIT.
@
text
@d4 3
d152 1
a152 1
/* The value of unit, () */
d154 3
@


1.6
log
@Put in various casts so that macros work correctly when
passed values of pointer type.
@
text
@d4 4
d148 3
@


1.5
log
@Put in word_align and NFIELDS.
@
text
@d4 3
d74 4
a77 4
#define ISPTR(x)	((x) & 1)	/* Is x a pointer		*/
#define MLINT(i)	((i) << 2)	/* Make an ML integer value	*/
#define CINT(i)		((i) >> 2)	/* Make a C integer value	*/
#define PRIMARY(x)	((x) & 7)	/* The primary tag of x		*/
d79 3
a81 2
#define MAKEWORD(t,x)	(((x) << 3) + (t)) 	/* Word of value x, tag t    */
#define MLPTR(t,p)	((t)+(p))		/* Pointer of value p, tag t */
d83 2
d86 6
d95 1
a95 1
#define CPTR(x)		((x) & ~7)
d134 1
a134 1
#define CSTRING(p) ((char *)((p) - 1))
@


1.4
log
@Major changes. This file now includes lots of utilities for
creating and untagging ML values.
@
text
@d4 4
d43 1
a43 1
 * Double align a C pointer.
d46 2
a47 1
#define double_align(x) ((void *)(((word)(x) + 7) & ~7))
d122 4
a125 1
#define CSTRING(p)	((char *)CPTR(p))
@


1.3
log
@Putin double_align macro. I intend this file have general value
manipulation utilities eventually.
@
text
@a2 3
 * The values in a program or module, represented as tuples.
 * These allow any value to be found by a series of
 * component numbers.
d4 4
d22 2
a23 2
#ifndef types_h
#include "types.h"
d26 3
a28 1
typedef union tag_value *tuple_pointer;
d30 2
a31 3
typedef union tag_value {
  u_int32       integer; /* Simple value */
  tuple_pointer tuple;   /* Substructure */
d33 1
a33 3
 * Both the above will be tagged to allow
 * the garbage collector to understand them.
 * The exact nature of the tagging is not important here.
a34 1
} tagged_value;
d36 1
a36 1
typedef char *module_names[]; /* The names associated with the modules */
d38 86
a123 1
#define double_align(x) ((char *)((((u_int32)(x) + 8) & ~7)))
@


1.2
log
@Revised interface for second version of load format
@
text
@d7 3
d13 1
d16 2
a17 1
#ifndef values_h /* Avoid multiple inclusion */
d20 2
a21 1
#ifndef types_h /* For efficiency */
a36 8
#if 0
typedef struct component_name {
  tuple_pointer module;        /* The module containing the value */
  u_int32       size;          /* Number of elements in the array */
  u_int32       components[1]; /* Actually open array */
} value_by_component;
#endif

d39 1
a39 2
#if 0 /* Old revision 1.1 */
typedef struct value *tuple_pointer;
a40 30
typedef union tag_value {
  u_int32        integer; /* Simple value */
  tuple_pointer *tuple;   /* Substructure */
  void          *pointer; /* Something else */
/*
 * Both the above will be tagged to allow
 * the garbage collector to understand them.
 * The exact nature of the tagging is not important here.
 */
} tagged_value;

typedef struct value {
  u_int32      size;      /* The number of values */
  tagged_value values[1]; /* Actually an open array of size size */
} tuple;

typedef struct component_name {
  tuple_pointer module;        /* The module containing the value */
  u_int32       size;          /* Number of elements in the array */
  u_int32       components[1]; /* Actually open array */
} value_by_component;

/*
 * The structures for representing unresolved closures
 * and unevaluated function references are as yet undetermined.
 * More work required here.
 * ******************
 */

typedef char *module_names[]; /* The names associated with the modules */
a41 3

#endif
/* End values.h */
@


1.1
log
@Initial revision
@
text
@d6 4
a9 1
 * $Log$
d19 23
d74 1
@
