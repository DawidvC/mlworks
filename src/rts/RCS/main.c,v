head	1.76;
access;
symbols
	Final_version_of_old_runtime:1.76
	ML_revised_beta_release_25/05/94:1.75
	ML_final_beta_release_02/03/94:1.75
	mlworks-28-01-1994:1.74
	Release:1.69
	mlworks-beta-01-09-1993:1.69
	MLWorks-1-0-3-21/12/1992:1.55
	MLWorks-1-0-2-15/12/1992:1.53
	MLWorks-1-0-1-04/12/1992:1.53
	checkpoint_17_08_92:1.45;
locks; strict;
comment	@ *  @;


1.76
date	94.05.26.15.58.51;	author jont;	state Exp;
branches;
next	1.75;

1.75
date	94.01.28.17.23.11;	author nickh;	state Exp;
branches;
next	1.74;

1.74
date	94.01.10.13.42.41;	author matthew;	state Exp;
branches;
next	1.73;

1.73
date	93.12.22.11.41.21;	author jont;	state Exp;
branches;
next	1.72;

1.72
date	93.11.23.12.06.27;	author jont;	state Exp;
branches;
next	1.71;

1.71
date	93.10.12.16.06.39;	author matthew;	state Exp;
branches;
next	1.70;

1.70
date	93.09.02.15.23.54;	author daveb;	state Exp;
branches;
next	1.69;

1.69
date	93.08.26.18.44.26;	author daveb;	state Exp;
branches
	1.69.1.1;
next	1.68;

1.68
date	93.08.19.16.40.50;	author daveb;	state Exp;
branches;
next	1.67;

1.67
date	93.08.12.14.18.10;	author daveb;	state Exp;
branches;
next	1.66;

1.66
date	93.06.22.15.05.18;	author daveb;	state Exp;
branches;
next	1.65;

1.65
date	93.06.02.13.05.15;	author richard;	state Exp;
branches;
next	1.64;

1.64
date	93.06.01.15.36.17;	author richard;	state Exp;
branches;
next	1.63;

1.63
date	93.05.13.11.15.58;	author richard;	state Exp;
branches;
next	1.62;

1.62
date	93.04.30.12.49.28;	author richard;	state Exp;
branches;
next	1.61;

1.61
date	93.04.19.11.16.44;	author richard;	state Exp;
branches;
next	1.60;

1.60
date	93.03.12.10.08.43;	author richard;	state Exp;
branches;
next	1.59;

1.59
date	93.02.24.14.10.06;	author nosa;	state Exp;
branches;
next	1.58;

1.58
date	93.02.03.16.37.21;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	93.02.01.14.47.19;	author richard;	state Exp;
branches;
next	1.56;

1.56
date	93.01.06.13.22.47;	author richard;	state Exp;
branches;
next	1.55;

1.55
date	92.12.21.15.24.40;	author richard;	state Exp;
branches;
next	1.54;

1.54
date	92.12.18.15.20.40;	author clive;	state Exp;
branches;
next	1.53;

1.53
date	92.11.02.13.06.58;	author richard;	state Exp;
branches;
next	1.52;

1.52
date	92.10.02.09.40.46;	author richard;	state Exp;
branches;
next	1.51;

1.51
date	92.10.01.15.36.45;	author richard;	state Exp;
branches;
next	1.50;

1.50
date	92.09.01.11.25.44;	author richard;	state Exp;
branches;
next	1.49;

1.49
date	92.08.27.10.57.55;	author richard;	state Exp;
branches;
next	1.48;

1.48
date	92.08.26.15.46.18;	author richard;	state Exp;
branches;
next	1.47;

1.47
date	92.08.25.13.27.20;	author richard;	state Exp;
branches;
next	1.46;

1.46
date	92.08.19.07.06.12;	author richard;	state Exp;
branches;
next	1.45;

1.45
date	92.07.31.07.44.01;	author richard;	state Exp;
branches;
next	1.44;

1.44
date	92.07.29.14.26.14;	author richard;	state Exp;
branches;
next	1.43;

1.43
date	92.07.27.12.48.11;	author richard;	state Exp;
branches;
next	1.42;

1.42
date	92.07.23.15.52.05;	author richard;	state Exp;
branches;
next	1.41;

1.41
date	92.07.21.14.14.30;	author richard;	state Exp;
branches;
next	1.40;

1.40
date	92.07.15.17.53.30;	author richard;	state Exp;
branches;
next	1.39;

1.39
date	92.07.15.14.47.25;	author richard;	state Exp;
branches;
next	1.38;

1.38
date	92.07.14.15.37.02;	author richard;	state Exp;
branches;
next	1.37;

1.37
date	92.07.02.09.12.40;	author richard;	state Exp;
branches;
next	1.36;

1.36
date	92.07.01.14.14.54;	author richard;	state Exp;
branches;
next	1.35;

1.35
date	92.06.25.09.16.50;	author richard;	state Exp;
branches;
next	1.34;

1.34
date	92.06.22.14.54.25;	author clive;	state Exp;
branches;
next	1.33;

1.33
date	92.06.11.15.43.57;	author clive;	state Exp;
branches;
next	1.32;

1.32
date	92.05.18.08.30.31;	author clive;	state Exp;
branches;
next	1.31;

1.31
date	92.05.13.13.08.40;	author clive;	state Exp;
branches;
next	1.30;

1.30
date	92.05.06.13.00.09;	author clive;	state Exp;
branches;
next	1.29;

1.29
date	92.05.05.13.07.24;	author clive;	state Exp;
branches;
next	1.28;

1.28
date	92.04.14.13.31.19;	author clive;	state Exp;
branches;
next	1.27;

1.27
date	92.04.03.08.43.58;	author richard;	state Exp;
branches;
next	1.26;

1.26
date	92.03.26.15.29.28;	author richard;	state Exp;
branches;
next	1.25;

1.25
date	92.03.24.15.57.22;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	92.03.20.14.47.53;	author richard;	state Exp;
branches;
next	1.23;

1.23
date	92.03.20.10.49.33;	author richard;	state Exp;
branches;
next	1.22;

1.22
date	92.03.19.17.15.59;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	92.03.18.15.05.36;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	92.03.18.14.39.53;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	92.03.18.13.35.51;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	92.03.12.12.41.58;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	92.03.10.12.28.29;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.02.25.15.46.28;	author clive;	state Exp;
branches;
next	1.15;

1.15
date	92.02.24.16.20.40;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.02.14.17.16.10;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	92.02.12.11.24.11;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	92.01.24.11.35.20;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	91.12.23.14.36.57;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	91.12.20.16.51.16;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	91.12.13.12.30.00;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	91.12.06.16.48.58;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.10.28.17.29.57;	author davidt;	state Exp;
branches;
next	1.6;

1.6
date	91.10.23.15.30.14;	author davidt;	state Exp;
branches;
next	1.5;

1.5
date	91.10.22.13.48.34;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	91.10.21.10.47.35;	author davidt;	state Exp;
branches;
next	1.3;

1.3
date	91.10.18.18.27.19;	author davidt;	state Exp;
branches;
next	1.2;

1.2
date	91.10.17.15.48.08;	author davidt;	state Exp;
branches;
next	1.1;

1.1
date	91.10.16.15.26.34;	author davidt;	state Exp;
branches;
next	;

1.69.1.1
date	93.08.26.18.44.26;	author jont;	state Exp;
branches;
next	1.69.1.2;

1.69.1.2
date	93.09.07.10.53.21;	author daveb;	state Exp;
branches;
next	1.69.1.3;

1.69.1.3
date	93.10.12.14.26.46;	author matthew;	state Exp;
branches;
next	;


desc
@A main program for testing the run-time system.
@


1.76
log
@Fix speeling errs
@
text
@/*  === TOP LEVEL OF RUNTIME SYSTEM ===
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This file contains the main() function, which parses the command
 *  line, loads and invokes the modules, and displays the results of
 *  running the last module.
 *
 *  Revision Log
 *  ------------
 *  $Log: main.c,v $
 *  Revision 1.75  1994/01/28  17:23:11  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.74  1994/01/10  13:42:41  matthew
 *  Changed load_link to call internal_load_link in loader.c
 *
 *  Revision 1.73  1993/12/22  11:41:21  jont
 *  Added delivery option which discards code vector names
 *
 *  Revision 1.72  1993/11/23  12:06:27  jont
 *  Added extra option to turn off mo consistency checking
 *
 *  Revision 1.71  1993/10/12  16:06:39  matthew
 *  Merging bug fixes
 *
 *  Revision 1.70  1993/09/02  15:23:54  daveb
 *  Added -mono option.
 *
 *  Revision 1.69.1.3  1993/10/12  14:26:46  matthew
 *  Added the -stack option to control the stack overflow limit
 *
 *  Revision 1.69.1.2  1993/09/07  10:53:21  daveb
 *  Added -mono option.
 *
 *  Revision 1.69.1.1  1993/08/26  18:44:26  jont
 *  Fork for bug fixing
 *
 *  Revision 1.69  1993/08/26  18:44:26  daveb
 *  module names are now read from the files' consistency information.
 *  The -path option isn't needed.
 *
 *  Revision 1.68  1993/08/19  16:40:50  daveb
 *  Changed name of program in error message.
 *
 *  Revision 1.67  1993/08/12  14:18:10  daveb
 *  Added -path parameter.
 *
 *  Revision 1.66  1993/06/22  15:05:18  daveb
 *  Minor improvement to error message.
 *
 *  Revision 1.65  1993/06/02  13:05:15  richard
 *  Improved the use of const on the argv parameter type.
 *  Added missing include of stdio.h.
 *
 *  Revision 1.64  1993/06/01  15:36:17  richard
 *  Added missing #include of stdio.h.
 *
 *  Revision 1.63  1993/05/13  11:15:58  richard
 *  Added documentation of the `--' option to the help string.
 *
 *  Revision 1.62  1993/04/30  12:49:28  richard
 *  Multiple arguments can now be passed to the storage manager in a general
 *  way.
 *
 *  Revision 1.61  1993/04/19  11:16:44  richard
 *  New profiler and value printer.
 *
 *  Revision 1.60  1993/03/12  10:08:43  richard
 *  Made the call to the license server conditional so that it
 *  can be debugged without disturbing other developers.
 *
 *  Revision 1.59  1993/02/24  14:10:06  nosa
 *  Implemented a multi-level profiler
 *
 *  Revision 1.58  1993/02/03  16:37:21  jont
 *  Changes for code vector reform
 *
 *  Revision 1.57  1993/02/01  14:47:19  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.56  1993/01/06  13:22:47  richard
 *  Moved the call to the license enforcer so that it notices the
 *  diagnostic level.
 *
 *  Revision 1.55  1992/12/21  15:24:40  richard
 *  Added call to license enforcer.
 *
 *  Revision 1.54  1992/12/18  15:20:40  clive
 *  Made the profiler take the generalised streams
 *
 *  Revision 1.53  1992/11/02  13:06:58  richard
 *  Changed the way the image load and save operations are done.
 *
 *  Revision 1.52  1992/10/02  09:40:46  richard
 *  Added missing consts.
 *
 *  Revision 1.51  1992/10/01  15:36:45  richard
 *  Added ansi.h.
 *
 *  Revision 1.50  1992/09/01  11:25:44  richard
 *  Implemented argument passing to the modules.
 *
 *  Revision 1.49  1992/08/27  10:57:55  richard
 *  The module table is now a reference cell.
 *
 *  Revision 1.48  1992/08/26  15:46:18  richard
 *  The module table is now a pervasive value.
 *
 *  Revision 1.47  1992/08/25  13:27:20  richard
 *  Changed or corrected some messages.
 *
 *  Revision 1.46  1992/08/19  07:06:12  richard
 *  Corrected the documentation string.
 *
 *  Revision 1.45  1992/07/31  07:44:01  richard
 *  Moved initialisation of diagnostic level to beginning of main().
 *
 *  Revision 1.44  1992/07/29  14:26:14  richard
 *  Added error checking on profile start and end.
 *
 *  Revision 1.43  1992/07/27  12:48:11  richard
 *  Removed references to redundant external_invocation_count.
 *  Corrected spelling of privilege.
 *
 *  Revision 1.42  1992/07/23  15:52:05  richard
 *  Changed image saving and loading to use the global root manager.
 *
 *  Revision 1.41  1992/07/21  14:14:30  richard
 *  Removed redundant `-generations' option, and changed `-preallocate'
 *  to `-size' to make it more general.  Imported the help string for
 *  `-size' from the memory manager.  Added an extra field to images which
 *  is called if set.  (See ml_image_save() in pervasives.c.)
 *
 *  Revision 1.40  1992/07/15  17:53:30  richard
 *  The loader no longer calls the code it loads, so load_link() now does it.
 *
 *  Revision 1.38  1992/07/14  15:37:02  richard
 *  Changed the way profiling is done, and simplified control structure
 *  now that we can assume the module table won't disappear.
 *
 *  Revision 1.37  1992/07/02  09:12:40  richard
 *  returns ERROR to indicate error rather than IMPOSSIBLE.
 *
 *  Revision 1.36  1992/07/01  14:14:54  richard
 *  The module table is now a single global root.
 *
 *  Revision 1.35  1992/06/25  09:16:50  richard
 *  Added -plock option.
 *
 *  Revision 1.34  1992/06/22  14:54:25  clive
 *  Error in profiler timer code - used to start timer before initialising
 *  the signal handler
 *
 *  Revision 1.33  1992/06/11  15:43:57  clive
 *  Fixes to the profiler
 *
 *  Revision 1.32  1992/05/18  08:30:31  clive
 *  Added timers and code for compiling the make system
 *
 *  Revision 1.31  1992/05/13  13:08:40  clive
 *  Added some code for memory profiling and corrected some bugs
 *
 *  Revision 1.30  1992/05/06  13:00:09  clive
 *  In the -save case, profiling information was not being taken
 *
 *  Revision 1.29  1992/05/05  13:07:24  clive
 *  Added stack backtrace depth
 *
 *  Revision 1.28  1992/04/14  13:31:19  clive
 *  First version of the profiler
 *
 *  Revision 1.27  1992/04/03  08:43:58  richard
 *  Corrected timing code.
 *
 *  Revision 1.26  1992/03/26  15:29:28  richard
 *  Removed `nothing to do' error (does nothing instead).  Added new
 *  statistics from callc_codes.h.
 *
 *  Revision 1.25  1992/03/24  15:57:22  richard
 *  Added `-statistics' option to display internal statistics.
 *
 *  Revision 1.24  1992/03/20  14:47:53  richard
 *  Added code to deal with ELOADVERSION error.
 *
 *  Revision 1.23  1992/03/20  10:49:33  richard
 *  Added `-show' option.
 *
 *  Revision 1.22  1992/03/19  17:15:59  richard
 *  Added more robust error checking of parameters and input.  Removed
 *  extraneous includes.
 *
 *  Revision 1.21  1992/03/18  15:02:19  richard
 *  Added -verbose option.
 *
 *  Revision 1.20  1992/03/18  14:39:53  richard
 *  Added -from option.
 *
 *  Revision 1.17  1992/03/10  12:28:29  clive
 *  Added call to initialise the new Io system
 *
 *  Revision 1.16  1992/02/25  15:46:28  clive
 *  Added val_print in the System structure in ML
 *
 *  Revision 1.15  1992/02/24  16:20:40  clive
 *  Needed to add the module_name as a root during the loading process, else
 *  the string it pointed too went walkabout
 *
 *  Revision 1.14  1992/02/14  17:16:10  richard
 *  Added `-i' option.
 *
 *  Revision 1.13  1992/02/12  11:24:11  richard
 *  Removed the assumption that the result of an execution is a record.
 *
 *  Revision 1.12  1992/01/24  11:35:20  richard
 *  Added -c option to control collection messages.
 *
 *  Revision 1.11  1991/12/23  14:36:57  richard
 *  Changed the name of the fatal runtime error handler to error().
 *  Moved the code to extract base file names to utils.
 *
 *  Revision 1.10  91/12/20  16:51:16  richard
 *  Rewrote to produce more diagnostic output and accept a diagnostic output
 *  level on the command line as an option.
 *  
 *  Revision 1.9  91/12/13  12:30:00  richard
 *  Changed result printing to use the val_print so that the structure
 *  of the results can be seen.
 *  
 *  Revision 1.8  91/12/06  16:48:58  jont
 *  Added pathname stripping for module names
 *  
 *  Revision 1.7  91/10/28  17:29:57  davidt
 *  Put in timer function.
 *  
 *  Revision 1.6  91/10/23  15:30:14  davidt
 *  Took out some initialisation code and moved into into the
 *  file initialise.c which is especially for that purpose.
 *  
 *  Revision 1.5  91/10/22  13:48:34  davidt
 *  Increased size of initial stack and heap. Now calculates the ml_stack
 *  pointer correctly (used to assign the stack pointer a non-aligned
 *  address, this didn't show up immediately because of another bug).
 *  
 *  Revision 1.4  91/10/21  10:47:35  davidt
 *  Improved the printing function to show the type of pointer which
 *  was returned instead of just an address.
 *  
 *  Revision 1.3  91/10/18  18:27:19  davidt
 *  Moved all the allocation stuff into allocate.c
 *  Moved all the C and ML state preserving stuff into state.c
 *  Did general tidy up and printing of result values.
 *  
 *  Revision 1.2  91/10/17  15:48:08  davidt
 *  Put in various hacks to get a testable version of the run-time system.
 */


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <time.h>
#include <sys/time.h>
#ifdef PLOCK
#include <sys/lock.h>
#include <pwd.h>
#endif
#include "ansi.h"
#include "syscalls.h"
#include "loader.h"
#include "modules.h"
#include "utils.h"
#include "values.h"
#include "diagnostic.h"
#include "initialise.h"
#include "global.h"
#include "options.h"
#include "profiler.h"
#include "handler.h"
#include "state.h"
#include "allocator.h"
#include "interface.h"
#include "storeman.h"
#include "pervasives.h"
#include "license.h"
#include "print.h"
#include "pervasive/time.h"

static const char *usage_message =
/* 0         1         2         3         4         5         6         7        | */
  "Usage:   mlrun [options...] module...\n"
  "Options:\n"
  "  --      This option does nothing, but nothing after it on the command line\n"
  "          will be treated as an option.\n"
  "  -mono   Use the X resources for a monochrome screen.\n"
  "  -d n    Set diagnostic level to n.\n"
  "  -c n    Set collection message level to n.\n"
  "  -stack n
             Set initial maximum number of stack blocks to n.\n"
  "  -gc-statistics filename\n"
  "          Write garbage collection statistics to file.\n"
  "  -show   Display the result of the final module.\n"
  "  -profile filename\n"
  "          Profile the entire run, writing the results to filename.  This\n"
  "          option overrides previous profiling options with the defaults.\n"
  "  -profile-scan n\n"
  "          When profiling, scan the stack every n virtual milliseconds to\n"
  "          gather information.  An interval of zero disables scanning.\n"
  "          Scanning is not enabled by default.\n"
  "  -profile-depth n\n"
  "          When profiling with scanning, record patterns of caller functions\n"
  "          to a depth of n callers.  The default is zero.\n"
  "  -profile-select string\n"
  "          When profiling, only record information about functions which\n"
  "          include this string in their names.  By default, all functions are\n"
  "          profiled.\n"
  "  -backtrace-depth depth\n"
  "          Maximum depth of the backtrace if an exception occurs.\n"
  "  -print depth length indent tags\n"
  "          Control the way values are output by default.  Depth is the maximum\n"
  "          nesting of structures (zero for no limit and by default), length is\n"
  "          the maximum length of strings (also zero for no limit and by\n"
  "          default), indent, if non-zero, causes values to be printed on\n"
  "          separate lines using indentation to show structure, tags,\n"
  "          if non-zero, causes internal value information to be displayed.\n"
  "  -load filename\n"
  "          Load an image from the file before loading any modules.\n"
  "  -save filename\n"
  "          Load modules specified then save the image in a file.\n"
  "  -from filename\n"
  "          Read module file names from this file before reading them from the\n"
  "          command line.\n"
  "  -delivery\n"
  "          Discard code vector names on loading.\n"
  "  -verbose\n"
  "          Display information about the activities of the runtime system.\n"
  "  -statistics\n"
  "          Display various internal statistics at the end of the run.\n"
#ifdef PLOCK
  "  -plock\n"
  "          Attempt to lock process in real memory, then set effective uid of\n"
  "          the process to real uid.  This option requires root privilege.\n"
#endif
  "  -pass s arg... s\n"
  "          Propagate arguments between the delimiter strings to the modules.\n"
  "          The delimiter may be any string.\n"
  "  -storeman s arg... s\n"
  "          Pass arguments between the delimiter strings to the storage manager.\n"
  "%s"
  "  -help   Display this message.\n";


static struct option
  option_diagnostic      = {"d", 1, 0, NULL},
  option_messages        = {"c", 1, 0, NULL},
  option_stacksize       = {"stack", 1, 0, NULL},
  option_print           = {"print", 4, 0, NULL},
  option_storeman        = {"storeman", -1, 0, NULL},
  option_gc_stats        = {"gc-statistics", 1, 0, NULL},
  option_modules         = {"from", 1, 0, NULL},
  option_load            = {"load", 1, 0, NULL},
  option_save            = {"save", 1, 0, NULL},
  option_help            = {"help", 0, 0, NULL},
  option_verbose         = {"verbose", 0, 0, NULL},
  option_show	         = {"show", 0, 0, NULL},
  option_profile         = {"profile", 1, 0, NULL},
  option_profile_scan    = {"profile-scan", 1, 0, NULL},
  option_profile_depth   = {"profile-depth", 1, 0, NULL},
  option_profile_select  = {"profile-select", 1, 0, NULL},
  option_backtrace_depth = {"backtrace-depth", 1, 0, NULL},
  option_statistics      = {"statistics", 0, 0, NULL},
  option_mono	         = {"mono", 0, 0, NULL},
#ifdef PLOCK
  option_plock           = {"plock", 0, 0, NULL},
#endif
  option_pass	         = {"pass", -1, 0, NULL},
  option_dont_check      = {"relaxed", 0, 0, NULL}, 
  option_delivery        = {"delivery", 0, 0, NULL},
  option_end	         = {NULL, 0, 0, NULL};

static struct option *options[] =
{
  &option_diagnostic, &option_messages, &option_stacksize, &option_print, &option_storeman,
  &option_modules, &option_load, &option_save, &option_help, &option_verbose,
  &option_show, &option_profile, &option_profile_scan, &option_profile_depth,
  &option_profile_select, &option_backtrace_depth, &option_mono,
  &option_gc_stats, &option_statistics, &option_pass,
#ifdef PLOCK
  &option_plock,
#endif
  &option_dont_check, &option_delivery,
  &option_end
};



mlval image_continuation = MLUNIT;
int module_argc = 0;
const char *const *module_argv = NULL;
int mono = 0;



/*  == Load and link a module and add it to the module table ==
 *
 *  The module is loaded onto the heap by load_module() and linked by
 *  calling the resulting top-level function.
 */

static mlval load_link(const char *filename)
{
  mlval mod_name = MLUNIT;
  mlval result = internal_load_link (filename,&mod_name,option_verbose.specified, 
				     option_dont_check.specified,
				     option_delivery.specified);
  if(result == ERROR)
    switch(errno)
    {
      case ELOADREAD:
      error("The loader was unable to read from the file `%s' "
	    "despite being able to open it.", filename);

      case ELOADOPEN:
      error("The loader was unable to open the file `%s'.", filename);

      case ELOADALLOC:
      error("The loader was unable to allocate enough memory while "
	    "loading the file `%s'.", filename);

      case ELOADVERSION:
      error("The file `%s' contains a module of a version the loader does "
	    "not understand.", filename);

      case ELOADFORMAT:
      error("The file `%s' is not in the correct loader format.", filename);

      case ELOADEXTERNAL:
      error("The module in the file `%s' references an unloaded external "
	    "module called `%s'.", filename, CSTRING(load_external));

      default:
      error("The loader returned %d, which is not a valid error code.", errno);
    }
  else
    return(result);
}

static FILE *profile_stream;
static const char *profile_selector = NULL;

static void profile_print(const char *s)
{
  fputs(s, profile_stream);
}

static int profile_select(mlval code)
{
  return(profile_selector == NULL ||
	 strstr(CSTRING(CCODENAME(code)), profile_selector) != NULL);
}


int main(int argc, const char *const *argv)
{
  int loop;
  mlval result = MLUNIT;
  clock_t start, stop;
  struct profile_options profile_options;

  --argc; ++argv;	/* Skip the command name argument */

  if(!option_parse(&argc, &argv, options))
    switch(errno)
    {
      case EOPTIONARGS:
      error("The wrong number of arguments were specified for the "
	    "option `%s'.  Use `-help' for help.", argv[0]);

      case EOPTIONUNKNOWN:
      error("An unknown option `%s' was specified.  Use `-help' for help.", argv[0]);

      case EOPTIONDELIM:
      error("Missing closing delimiter for option `%s'.  Use `-help' for help.", argv[0]);

      default:
      error("The option parser returned an unknown error code %d.", errno);
    }

  if(option_diagnostic.specified)
    diagnostic_level = to_unsigned(option_diagnostic.arguments[0]);

  if(option_backtrace_depth.specified)
    max_backtrace_depth = to_int(option_backtrace_depth.arguments[0]);

#ifdef LICENSE
  license();
#endif

#ifdef PLOCK
  if(option_plock.specified)
  {
    int uid = getuid();

    if(plock(PROCLOCK))
      switch(errno)
      {
	case EAGAIN:
	message("Warning: Insufficient memory to lock process.");
	break;

	case EPERM:
	error("Insufficient privilege to lock process.");

	default:
	message("Warning: plock() returned an unknown error.");
      }
    else
      message("Process locked in real memory.");

    if(seteuid(getuid()))
       switch(errno)
       {
	 case EINVAL:
	 error("Invalid numeric uid specified (%d).", uid);
	 
	 case EPERM:
	 error("Not enough privilege to set effective uid.");
	 
	 default:
	 message("Warning: seteuid() returned an unknown error code.");
       }
  }
#endif

  if(option_mono.specified)
    mono = 1;

  if(option_storeman.specified)
    initialise(option_storeman.nr_arguments, option_storeman.arguments);
  else
    initialise(0, NULL);

  if (option_stacksize.specified)
    sm_interface (50,MLINT(to_int(option_stacksize.arguments[0])));
    
  if(option_help.specified)
  {
    printf(usage_message, sm_help);
    exit(EXIT_SUCCESS);
  }

  if(option_pass.specified)
  {
    if(option_verbose.specified)
      message("Passing arguments to modules.");

    module_argc = option_pass.nr_arguments;
    module_argv = option_pass.arguments;
  }

  if(option_gc_stats.specified)
  {
    gc_stat_stream = fopen(option_gc_stats.arguments[0], "w");

    if(gc_stat_stream == NULL)
      error("Unable to open `%s' for writing.", option_gc_stats.arguments[0]);

    if(option_verbose.specified)
      message("Writing garbage collection statistics to file `%s'.",
	      option_gc_stats.arguments[0]);
  }

  if(option_print.specified)
  {
    print_defaults.depth_max = to_int(option_print.arguments[0]);
    print_defaults.string_length_max = to_unsigned(option_print.arguments[1]);
    print_defaults.indent = to_int(option_print.arguments[2]);
    print_defaults.tags = to_int(option_print.arguments[3]);
  }

  /* Load an initial image if specified. */
  if(option_load.specified)
  {
    mlval root;

    if(option_verbose.specified)
      message("Loading image from file `%s'.", option_load.arguments[0]);

    root = sm_interface(SM_IMAGE_LOAD, ml_string(option_load.arguments[0]));

    if(root == ERROR)
      switch(errno)
      {
	case EIMPL:
	error("Image loading is not implemented by this storage manager.");

	case EIMAGEFORMAT:
	error("The file `%s' is not in the correct image format.",
	      option_load.arguments[0]);

	case EIMAGEOPEN:
	error("The image loader was unable to open the file `%s'.",
	      option_load.arguments[0]);

	case EIMAGEREAD:
	error("The image loader was unable to read from the file `%s' "
	      "despite being able to open it.", option_load.arguments[0]);

	case EIMAGEALLOC:
	error("The image loader was unable to allocate enough memory while "
	      "loading the file `%s'.", option_load.arguments[0]);

	case EIMAGEVERSION:
	error("The image file `%s' is incompatable with the current version "
	      "of the image loader.", option_load.arguments[0]);

	default:
	error("The image loader returned %d, "
	      "which is not a valid error code.", errno);
      }

    if(!global_unpack(root))
      error("The global state in the image file `%s' does not correspond to "
	    "that of this runtime system.", option_load.arguments[0]);
  }

  if(option_messages.specified)
    MLUPDATE(gc_message_level, 0, MLINT(to_int(option_messages.arguments[0])));

  if(option_profile.specified)
  {
    const char *filename = option_profile.arguments[0];

    profile_stream = fopen(filename, "w");

    if(profile_stream == NULL)
      error("Unable to open `%s' for writing.", filename);

    profile_options.interval =
      option_profile_scan.specified ?
	to_unsigned(option_profile_scan.arguments[0]) : 0;

    profile_options.depth =
      option_profile_depth.specified ?
	to_unsigned(option_profile_depth.arguments[0]) : 0;

    profile_options.select = profile_select;
    profile_selector =
      option_profile_select.specified ?
	option_profile_select.arguments[0] : NULL;

    profile_options.printer_type = PROFILE_OPT_C;
    profile_options.print.c = profile_print;

    if(option_verbose.specified)
      message("Profiling to `%s' with scanning interval %u and depth %u.",
	      filename, profile_options.interval, profile_options.depth);


    if(profile_begin(&profile_options))
      switch(errno)
      {
	case EPROFILEDEPTH:
	error("The profiler cannot profile to depth %d.", profile_options.depth);

	default:
	error("The profile returned an unexpected error code %d.", errno);
      }
  }

  start = clock();

  /* If an image with a continuation was loaded, execute it first. */
  if(image_continuation != MLUNIT)
      result = callml(MLUNIT, image_continuation);

  /* If there is a module list file, load modules from there first. */
  if(option_modules.specified)
  {
    char filename[FILENAME_MAX+1];
    char format[10];
    FILE *f;

    if(option_verbose.specified)
      message("Reading module filenames from file `%s'",
	      option_modules.arguments[0]);

    f = fopen(option_modules.arguments[0], "r");

    if(f == NULL)
      error("Unable to open module list file `%s'.",
	    option_modules.arguments[0]);

    (void)sprintf(format, " %%%us", FILENAME_MAX);

    while(fscanf(f, format, filename) == 1)
    {
      int c = fgetc(f);

      (void)load_link(filename);

      if(c == EOF)
	break;
      else if(!isspace(c))
	error("Overlong filename in module list file `%s'.",
	      option_modules.arguments[0]);
    }

    (void)fclose(f);
  }

  /* Load any modules specified on the command line. */
  for(loop=0; loop<argc; ++loop)
    result = load_link(argv[loop]);

  stop = clock();

  if(option_profile.specified)
  {
    profile_end();
    if(fclose(profile_stream) == EOF)
      error("Unable to close profiler output file.");
  }

  if(option_show.specified)
  {
    print(NULL, stdout, result);
    putchar('\n');
  }

  if(option_save.specified)
  {
    mlval global, filename, argument;

    if(option_verbose.specified)
      message("Saving image to file `%s'", option_save.arguments[0]);

    global = global_pack();
    declare_root(&global);
    filename = ml_string(option_save.arguments[0]);
    declare_root(&filename);
    argument = allocate_record(2);
    FIELD(argument, 0) = filename;
    FIELD(argument, 1) = global;
    retract_root(&filename);
    retract_root(&global);

    if(sm_interface(SM_IMAGE_SAVE, argument) == ERROR)
      switch(errno)
      {
	case EIMPL:
	error("Image saving is not implemented by this storage manager.");

	case EIMAGEOPEN:
	error("The image saver was unable to open the file `%s'.",
	      option_save.arguments[0]);

	case EIMAGEWRITE:
	error("The image saver was unable to write to the file `%s'.",
	      option_save.arguments[0]);

	default:
	error("The image saver returned %d, "
	      "which is not a valid error code.", errno);
      }
  }

  if(gc_stat_stream != NULL)
    if(fclose(gc_stat_stream) == EOF)
      error("Unable to close statistics file.");

  if(option_verbose.specified)
    message("Total loading time %lums.", (stop - start)/(CLK_TCK/1000));

  if(option_statistics.specified)
    printf("Runtime system statistics:\n"
	   "  Raise count: %u\n"
	   "  Stack extension count: %u\n",
	   raise_count, stack_extension_count);
  
  return(EXIT_SUCCESS);
}
@


1.75
log
@Moved extern function declarations to header files.
@
text
@d14 3
d350 2
a351 2
  "          Propagate arguments between the delimeter strings to the modules.\n"
  "          The delimeter may be any string.\n"
d353 1
a353 1
  "          Pass arguments between the delimeter strings to the storage manager.\n"
@


1.74
log
@Changed load_link to call internal_load_link in loader.c
@
text
@d14 3
a268 3
extern int plock(int);
extern int seteuid(int);
extern int getuid(void);
a269 1

d271 1
@


1.73
log
@Added delivery option which discards code vector names
@
text
@d14 3
a261 1
#include <sys/stat.h>
d415 4
a418 20
  mlval closure;
  mlval structure;
  mlval time;

  struct stat stbuf;
  struct timeval tv;
  if(stat(filename,&stbuf) == -1) {
    error("The loader was unable to access the file `%s'.", filename);
  }
  tv.tv_sec = stbuf.st_mtime;
  tv.tv_usec = 0;
  time = ml_time(tv);
  declare_root(&time);
  declare_root(&mod_name);

  closure = load_module(filename, &mod_name, DEREF(modules),
			option_verbose.specified, option_dont_check.specified,
			option_delivery.specified);

  if(closure == ERROR)
d446 2
a447 7

  structure = callml(closure, closure);
  MLUPDATE(modules, 0, mt_add(DEREF(modules), mod_name, structure, time));
  retract_root(&mod_name);
  retract_root(&time);

  return(structure);
a448 1

@


1.72
log
@Added extra option to turn off mo consistency checking
@
text
@d14 3
d333 2
d378 1
d391 1
a391 1
  &option_dont_check,
d429 2
a430 1
			option_verbose.specified, option_dont_check.specified);
@


1.71
log
@Merging bug fixes
@
text
@d14 3
d256 2
d284 1
a285 1

d372 1
d385 1
d409 1
d411 9
d423 1
a423 1
			option_verbose.specified);
d455 1
a455 1
  MLUPDATE(modules, 0, mt_add(DEREF(modules), mod_name, structure));
d457 1
@


1.70
log
@Added -mono option.
@
text
@d14 12
d290 2
d346 1
d371 1
a371 1
  &option_diagnostic, &option_messages, &option_print, &option_storeman,
d540 3
@


1.69
log
@module names are now read from the files' consistency information.
The -path option isn't needed.
@
text
@d14 4
d275 1
d347 1
d359 1
a359 1
  &option_profile_select, &option_backtrace_depth,
d372 1
d516 3
@


1.69.1.1
log
@Fork for bug fixing
@
text
@a13 4
 *  Revision 1.69  1993/08/26  18:44:26  daveb
 *  module names are now read from the files' consistency information.
 *  The -path option isn't needed.
 *
@


1.69.1.2
log
@Added -mono option.
@
text
@a13 3
 *  Revision 1.69.1.1  1993/08/26  18:44:26  jont
 *  Fork for bug fixing
 *
a274 1
  "  -mono   Use the X resources for a monochrome screen.\n"
a345 1
  option_mono	         = {"mono", 0, 0, NULL},
d357 1
a357 1
  &option_profile_select, &option_backtrace_depth, &option_mono,
a369 1
int mono = 0;
a512 3

  if(option_mono.specified)
    mono = 1;
@


1.69.1.3
log
@Added the -stack option to control the stack overflow limit
@
text
@a13 3
 *  Revision 1.69.1.2  1993/09/07  10:53:21  daveb
 *  Added -mono option.
 *
a280 2
  "  -stack n
             Set initial maximum number of stack blocks to n.\n"
a334 1
  option_stacksize       = {"stack", 1, 0, NULL},
d359 1
a359 1
  &option_diagnostic, &option_messages, &option_stacksize, &option_print, &option_storeman,
a527 3
  if (option_stacksize.specified)
    sm_interface (50,MLINT(to_int(option_stacksize.arguments[0])));
    
@


1.68
log
@Changed name of program in error message.
@
text
@d14 3
a302 3
  "  -path dirname\n"
  "          Remove this directory name from the name of each file when\n"
  "          converting a filename to a module name.\n"
a332 1
  option_path            = {"path", 1, 0, NULL},
d353 1
a353 1
  &option_profile_select, &option_backtrace_depth, &option_path,
d377 1
a377 1
  mlval mod_name = module_name (filename);
a380 3
  if(option_verbose.specified)
    message("Loading module `%s'", CSTRING(mod_name));

d383 2
a384 1
  closure = load_module(filename, DEREF(modules));
a518 6
  }

  if(option_path.specified)
  {
    mod_path = option_path.arguments[0];
    message("Module path set to `%s'.", mod_path);
@


1.67
log
@Added -path parameter.
@
text
@d14 3
d264 1
a264 1
  "Usage:   runtime [options...] module...\n"
@


1.66
log
@Minor improvement to error message.
@
text
@d14 3
d297 3
d330 1
d351 1
a351 1
  &option_profile_select, &option_backtrace_depth,
d369 2
a370 3
 *  The module name is taken to be the basename of the filename.  The module
 *  is loaded onto the heap by load_module() and linked by calling the
 *  resulting top-level function.
d375 1
a375 1
  mlval module_name = basename(filename);
d380 1
a380 1
    message("Loading module `%s'", CSTRING(module_name));
d382 1
a382 1
  declare_root(&module_name);
d416 2
a417 2
  MLUPDATE(modules, 0, mt_add(DEREF(modules), module_name, structure));
  retract_root(&module_name);
d519 6
@


1.65
log
@Improved the use of const on the argv parameter type.
Added missing include of stdio.h.
@
text
@d14 4
d452 1
a452 1
      error("Missing delimiter after option `%s'.  Use `-help' for help.", argv[0]);
@


1.64
log
@Added missing #include of stdio.h.
@
text
@d14 3
d218 1
d428 1
a428 1
int main(int argc, char *argv[])
d437 1
a437 1
  if(!option_parse(&argc, (const char ***)&argv, options))
@


1.63
log
@Added documentation of the `--' option to the help string.
@
text
@d14 3
d218 1
@


1.62
log
@Multiple arguments can now be passed to the storage manager in a general
way.
@
text
@d14 4
d248 2
@


1.61
log
@New profiler and value printer.
@
text
@d14 3
d241 1
a241 1
/* 0         1         2         3         4         5         6         7  */
d268 4
a271 5
  "          the maximum length of strings (also zero for no limit and by default),\n"
  "          indent, if non-zero, causes values to be printed on separate lines\n"
  "          using indentation to show structure, tags, if non-zero, causes internal\n"
  "          value information to be displayed.\n"
  "  -size n\n%s"	/* filled by storage manager */
d291 3
d300 2
a301 2
  option_print       = {"print", 4, 0, NULL},
  option_size 	         = {"size", 1, 0, NULL},
d323 1
a323 1
  &option_diagnostic, &option_messages, &option_print, &option_size,
a398 24
static int to_int(const char *s)
{
  int n;
  char dummy;

  if(sscanf(s, " %d%c", &n, &dummy) != 1)
    error("`%s' is not a number.", s);

  return(n);
}


static unsigned int to_unsigned(const char *s)
{
  unsigned int n;
  char dummy;

  if(sscanf(s, " %u%c", &n, &dummy) != 1)
    error("`%s' is not an unsigned number.", s);

  return(n);
}


d421 2
d486 2
a487 9
  if(option_size.specified)
  {
    unsigned int top = to_unsigned(option_size.arguments[0]);

    if(option_verbose.specified)
      message("Initializing heap with size %u.", top);

    initialise(top);
  }
d489 1
a489 1
    initialise(0);
d493 1
a493 1
    printf(usage_message, sm_size_help);
@


1.60
log
@Made the call to the license server conditional so that it
can be debugged without disturbing other developers.
@
text
@d14 4
d97 2
a98 1
 *  Error in profiler timer code - used to start timer before initialising the signal handler
d234 1
d246 14
a259 4
  "  -profile s -level l -profile s profile_list s -filename f -interval n s\n"
  "          Profile the entire run, recording profiling information in the\n"
  "          specified file.  If n is not zero the stack is scanned at intervals\n"
  "          of n virtual milliseconds to provide additional information.\n"
d262 1
a262 1
  "  -print depth length internals\n"
d264 5
a268 3
  "          nesting of structures, length is the maximum length of strings, and\n"
  "          internals, if non-zero, causes internal value information to be\n"
  "          displayed.\n"
a291 1
extern struct profile_list *profile;
d293 15
a307 12
  option_diagnostic  = {"d", 1, 0, NULL},
  option_messages    = {"c", 1, 0, NULL},
  option_internals   = {"print", 3, 0, NULL},
  option_size 	     = {"size", 1, 0, NULL},
  option_gc_stats    = {"gc-statistics", 1, 0, NULL},
  option_modules     = {"from", 1, 0, NULL},
  option_load        = {"load", 1, 0, NULL},
  option_save        = {"save", 1, 0, NULL},
  option_help        = {"help", 0, 0, NULL},
  option_verbose     = {"verbose", 0, 0, NULL},
  option_show	     = {"show", 0, 0, NULL},
  option_profile     = {"profile", -1, 0, NULL},
d309 1
a309 1
  option_statistics  = {"statistics", 0, 0, NULL},
d311 1
a311 1
  option_plock       = {"plock", 0, 0, NULL},
d313 2
a314 2
  option_pass	     = {"pass", -1, 0, NULL},
  option_end	     = {NULL, 0, 0, NULL};
d318 1
a318 1
  &option_diagnostic, &option_messages, &option_internals, &option_size,
d320 2
a321 1
  &option_show, &option_profile, &option_backtrace_depth,
d418 15
d438 1
a438 1
  FILE *profile_stream = NULL;
d542 1
a542 1
  if(option_internals.specified)
d544 4
a547 3
    val_print_defaults.depth = to_int(option_internals.arguments[0]);
    val_print_defaults.string_length = to_unsigned(option_internals.arguments[1]);
    val_print_defaults.internals = to_unsigned(option_internals.arguments[2]);
d601 1
a601 6
    struct profile_list *to_profile = NULL;
    short profile_all = 1, profile_level = 0;
    unsigned int time_interval = 0;
    const char *filename;
    int file_specified = 0;
    int i;
a602 35
    for(i = 0; i != option_profile.nr_arguments; ++i)
      {
	if(!strcmp(option_profile.arguments[i], "-level"))
	    profile_level = to_unsigned(option_profile.arguments[++i]);
	else
	  if(!strcmp(option_profile.arguments[i], "-profile"))
	    {
	      const char *delimiter;
	      delimiter = option_profile.arguments[++i];
	      while(strcmp(option_profile.arguments[++i], delimiter))
		{
		  if(i >= option_profile.nr_arguments)
		    error("The wrong number of arguments were specified for the option `%s' in "
			  "option `%s'.  Use `-help' for help.", "profile", "profile");
		    to_profile = CONS(option_profile.arguments[i],to_profile);
		}
	      profile_all = 0;
	    }
	  else 
	    if(!strcmp(option_profile.arguments[i], "-filename"))
	      {
		filename = option_profile.arguments[++i];
		file_specified = 1;
	      }
	    else 
	      if(!strcmp(option_profile.arguments[i], "-interval"))
		time_interval = to_unsigned(option_profile.arguments[++i]);
	      else 
		error("illegal option specified for the "
		      "option `%s'.  Use `-help' for help.", "profile");
      }
    if(!file_specified)
      error("file not specified for the "
	    "option `%s'.  Use `-help' for help.", "profile");

d605 19
d625 2
a626 1
      message("Profiling results to file `%s'", filename);
a627 2
    if(profile_stream == NULL)
      error("Unable to open profiling output file `%s'.",filename);
d629 2
a630 1
    if(profile_begin(profile_level, profile_all, to_profile, profile_stream, time_interval, 1))
d632 2
a633 2
	fclose(profile_stream);
	profile_stream = NULL;
d635 2
a636 10
	switch(errno)
	  {
	  case EPROFILEALLOC:
	    message("Warning: The profiler was unable to allocate memory for its "
		    "tables.  Profiling will not take place.");
	    break;
	    
	  default:
	    error("The profiler returned an unexpected error code %d.", errno);
	  }
d644 1
a644 1
    result = callml(MLUNIT, image_continuation);
d687 1
a687 1
  if(profile_stream != NULL)
d689 3
a691 13
    if(profile_end())
      switch(errno)
      {
	case EPROFILEWRITE:
	message("Warning: The profiler had difficulty writing to the profile "
		"output file.");
	break;

	default:
	error("The profiler returned an unexpected error code %d.", errno);
      }

    fclose(profile_stream);
d696 1
a696 1
    val_print(stdout, result, NULL);
@


1.59
log
@Implemented a multi-level profiler
@
text
@d14 3
d427 1
d429 1
@


1.58
log
@Changes for code vector reform
@
text
@d14 3
d237 1
a237 1
  "  -profile filename n\n"
d271 1
d284 1
a284 1
  option_profile     = {"profile", 2, 0, NULL},
d559 43
a601 1
    profile_stream = fopen(option_profile.arguments[0], "w");
d604 1
a604 1
      message("Profiling results to file `%s'", option_profile.arguments[0]);
d607 1
a607 7
      error("Unable to open profiling output file `%s'.",
	    option_profile.arguments[0]);

    if(profile_begin(profile_stream, to_unsigned(option_profile.arguments[1]), 1))
    {
      fclose(profile_stream);
      profile_stream = NULL;
d609 1
a609 1
      switch(errno)
d611 2
a612 4
	case EPROFILEALLOC:
	message("Warning: The profiler was unable to allocate memory for its "
		"tables.  Profiling will not take place.");
	break;
d614 10
a623 2
	default:
	error("The profiler returned an unexpected error code %d.", errno);
a624 1
    }
@


1.57
log
@Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
@
text
@d14 3
d344 1
a344 1
      error("The file `%s' contains a module of a version the loader does"
@


1.56
log
@Moved the call to the license enforcer so that it notices the
diagnostic level.
@
text
@d14 4
d661 2
a662 2
    (void)SETFIELD(argument, 0, filename);
    (void)SETFIELD(argument, 1, global);
@


1.55
log
@Added call to license enforcer.
@
text
@d14 3
d383 1
a383 1
int main(int argc, const char *const *argv)
a389 2
  license();

d412 2
@


1.54
log
@Made the profiler take the generalised streams
@
text
@d14 3
d212 1
d386 2
@


1.53
log
@Changed the way the image load and save operations are done.
@
text
@d14 3
d548 1
a548 1
    if(profile_begin(profile_stream, to_unsigned(option_profile.arguments[1])))
@


1.52
log
@Added missing consts.
@
text
@d14 3
d493 1
a493 1
    root = image_load(option_load.arguments[0]);
d498 4
a501 1
	case EIMAGE:
a504 3
	case EIMAGEIMPL:
	error("Image loading is not implemented by this storage manager.");

d635 2
d640 11
a650 1
    if(!image_save(option_save.arguments[0], global_pack()))
d653 3
a662 3

	case EIMAGEIMPL:
	error("Image saving is not implemented by this storage manager.");
@


1.51
log
@Added ansi.h.
@
text
@d14 3
d205 1
a205 1
static char *usage_message =
d285 1
a285 1
const char **module_argv = NULL;
d370 1
a370 1
int main(int argc, char **argv)
@


1.50
log
@Implemented argument passing to the modules.
@
text
@d14 3
d184 1
@


1.49
log
@The module table is now a reference cell.
@
text
@d14 3
d235 3
d259 1
d267 1
a267 1
  &option_gc_stats, &option_statistics,
a275 2
/*  == The global module table ==  */

d277 2
d378 1
a378 2
      error("An unknown option `%s' was specified.  Use `-help' for help.",
	    argv[0]);
d380 3
d445 9
@


1.48
log
@The module table is now a pervasive value.
@
text
@d14 3
a169 1

d325 1
a325 1
  MLUPDATE(modules, 0, mt_add(modules, module_name, structure));
@


1.47
log
@Changed or corrected some messages.
@
text
@d14 3
d190 1
a268 1
mlval modules;
d291 1
a291 1
  closure = load_module(filename, modules);
d323 1
a323 1
  modules = mt_add(modules, module_name, structure);
@


1.46
log
@Corrected the documentation string.
@
text
@d14 3
d392 1
a392 1
	error("Insufficient privelidge to lock process.");
d407 1
a407 1
	 error("Not enough privelidge to set effective uid.");
d458 1
a458 1
      message("Loading image from file `%s'", option_load.arguments[0]);
d629 2
a630 1
  message("Total loading time %lums.", (stop - start)/(CLK_TCK/1000));
@


1.45
log
@Moved initialisation of diagnostic level to beginning of main().
@
text
@d14 3
d210 1
a210 2
  "          Load all modules as intermediate and then save the image in the\n"
  "          specified file.\n"
@


1.44
log
@Added error checking on profile start and end.
@
text
@d14 3
d368 3
a445 3

  if(option_diagnostic.specified)
    diagnostic_level = to_unsigned(option_diagnostic.arguments[0]);
@


1.43
log
@Removed references to redundant external_invocation_count.
Corrected spelling of privilege.
@
text
@d14 4
d348 1
d495 1
a495 1
    FILE *stream = fopen(option_profile.arguments[0], "w");
d500 1
a500 1
    if(stream == NULL)
d504 16
a519 1
    profile_begin(stream, to_unsigned(option_profile.arguments[1]));
d569 16
a584 2
  if(option_profile.specified)
    profile_end();
a623 4
  {
    size_t i;
    mlval list;

a627 16

    printf("  Loaded code vectors:\n");
    for(list = load_code_vectors; list != MLNIL; list = MLTAIL(list))
    {
      mlval array = MLHEAD(list);
      size_t length = LENGTH(ARRAYHEADER(array));

      for(i=0; i<length; ++i)
      {
	mlval code = MLSUB(array, i);

	if(code != DEAD)
	  printf("    0x%X: %s\n", code, CCVNAME(code));
      }
    }
  }
@


1.42
log
@Changed image saving and loading to use the global root manager.
@
text
@d14 3
a167 1
#include "callc_codes.h"
d212 1
a212 1
  "          the process to real uid.  This option requires root privelidge.\n"
a559 2
    mlval root;

d596 1
a596 2
	   "  Stack extension count: %u\n"
	   "  External C routine invocation counts:\n",
a597 7
    for(i=0; i<40; ++i)
    {
      unsigned int c = external_invocation_count[i];

      if(c > 0)
	printf("    %2u: %u\n", i, c);
    }
@


1.41
log
@Removed redundant `-generations' option, and changed `-preallocate'
to `-size' to make it more general.  Imported the help string for
`-size' from the memory manager.  Added an extra field to images which
is called if set.  (See ml_image_save() in pervasives.c.)
@
text
@d14 6
d163 1
d180 1
a180 1
  "  -gcstatfile filename\n"
d220 1
a220 1
  option_gc_stats    = {"gcstatfile", 1, 0, NULL},
d248 8
a262 2
int in_ML = 0;

a304 1
  in_ML = 1;
a305 1
  in_ML = 0;
d340 1
a340 1
  mlval result = MLUNIT, image_continuation = MLUNIT;
d447 1
a447 1
    if(root == MLUNIT)
d454 3
d478 3
a480 4
    modules = GETFIELD(root, 0);
    load_code_vectors = GETFIELD(root, 1);
    gc_message_level = GETFIELD(root, 2);
    image_continuation = GETFIELD(root, 3);
d563 1
a563 7
    root = allocate_record(4);
    (void)SETFIELD(root, 0, modules);
    (void)SETFIELD(root, 1, load_code_vectors);
    (void)SETFIELD(root, 2, gc_message_level);
    (void)SETFIELD(root, 3, MLUNIT);

    if(!image_save(option_save.arguments[0], root))
d573 3
@


1.40
log
@The loader no longer calls the code it loads, so load_link() now does it.
@
text
@d14 3
a150 1
#include "mem.h"
a156 2
#include "gc.h"
#include "image.h"
d164 1
d168 1
d171 5
a175 5
  "  -d n  Set diagnostic level to n.\n"
  "  -c n  Show collection messages for generation n and higher.\n"
  "  -gcstatfile f\n"
  "        Write garbage collection statistics to file f.\n"
  "  -show Display the result of the final module.\n"
d177 5
a181 5
  "        Record profiling information, outputting it to the specified\n"
  "        file.  If n is not zero the stack is scanned at intervals of\n"
  "        n virtual milliseconds to provide additional information.\n"
  "  -backtrace-depth depth (default 25) \n"
  "        Maximum depth of the backtrace if an exception occurs"
d183 5
a187 8
  "        Control the way values are output by default.  Depth is the\n"
  "        maximum nesting of structures, length is the maximum length\n"
  "        of strings, and internals, if non-zero, causes internal value\n"
  "        information to be displayed.\n"
  "  -preallocate n\n"
  "        Pre-allocate generations up to n.\n"
  "  -generations spec [unimplemented]\n"
  "        Specify sizes and number of spaces in each generation.\n"
d189 1
a189 1
  "        Load an image from the file before loading any further modules.\n"
d191 2
a192 2
  "        Load all modules as intermediate and then save the image in the\n"
  "        specified file.\n"
d194 2
a195 2
  "        Read module file names from this file before reading them from\n"
  "        the command line.\n"
d197 1
a197 1
  "        Display information about the activities of the runtime system.\n"
d199 1
a199 1
  "	   Display various internal statistics at the end of the run.\n"
d202 2
a203 2
  "        Attempt to lock process in real memory, then set effective uid\n"
  "        of process to real uid.  This option requires root privelidge.\n"
d205 1
a205 1
  "  -help Display this message.\n";
d212 1
a212 2
  option_preallocate = {"preallocate", 1, 0, NULL},
  option_generations = {"generations", 1, 0, NULL},
d230 1
a230 1
  &option_diagnostic, &option_messages, &option_internals, &option_preallocate,
d232 1
a232 1
  &option_generations, &option_show, &option_profile, &option_backtrace_depth,
d329 1
a329 1
  mlval result = MLUNIT;
d386 1
a386 4
  if(option_generations.specified)
    message("Warning: -generations not implemented.");

  if(option_preallocate.specified)
d388 1
a388 1
    unsigned int top = to_unsigned(option_preallocate.arguments[0]);
d391 1
a391 1
      message("Preallocating generations up to %u.", top);
d400 1
a400 1
    fputs(usage_message, stderr);
d467 1
d489 4
d550 1
a550 1
    root = allocate_record(3);
d554 1
@


1.39
log
@The gc_message_level is now a ref cell on the heap, and is saved
and loaded with the image.
@
text
@d163 1
d243 1
a243 1
/*  == Load a module and add it to the module table ==
d245 3
a247 1
 *  The module name is taken to be the basename of the filename.
d250 3
a252 1
static mlval load(const char *filename)
d255 1
d263 1
a263 1
  structure = load_module(filename, modules);
d265 1
a265 1
  if(structure == ERROR)
d294 3
d475 1
a475 1
    MLUPDATE(gc_message_level, 0, CINT(to_int(option_messages.arguments[0])));
d516 1
a516 1
      (void)load(filename);
d530 1
a530 1
    result = load(argv[loop]);
@


1.38
log
@Changed the way profiling is done, and simplified control structure
now that we can assume the module table won't disappear.
@
text
@d14 4
a421 3
  if(option_messages.specified)
    gc_message_level = to_int(option_messages.arguments[0]);

d462 1
a463 5
  else
  {
    modules = mt_empty();
    load_code_vectors = MLNIL;
  }
d465 3
d541 1
a541 1
    root = allocate_record(2);
d544 1
@


1.37
log
@returns ERROR to indicate error rather than IMPOSSIBLE.
@
text
@d14 3
d158 2
d169 4
a172 8
  "  -profile \n"
  "        Display profile information at end of the run.\n"
  "  -profile-frequency number_of_times_per_second \n"
  "        Profile this many times per second (default 10000). \n"
  "  -profile-dont-scan-stack \n"
  "        Don't scan the whole stack when profiling \n"
  "  -profile-dont-sort  \n"
  "        Don't sort the results of the profiler. \n"
d217 1
a217 4
  option_profile     = {"profile", 0, 0, NULL},
  option_profile_dont_scan_stack = {"profile-dont-scan-stack", 0, 0, NULL},
  option_profile_frequency = {"profile-frequency", 1, 0, NULL},
  option_profile_dont_sort = {"profile-dont-sort", 0, 0, NULL},
d229 2
a230 3
  &option_generations, &option_show, &option_profile, &option_profile_frequency,
  &option_profile_dont_sort, &option_backtrace_depth, &option_gc_stats, &option_statistics,
  &option_profile_dont_scan_stack,
d243 1
a243 1
static mlval load(const char *filename, int profile)
d253 1
a253 1
  structure = load_module(filename, modules, profile);
d318 1
a318 1
  mlval result;
a338 2
  scan_stack_profiling = !option_profile_dont_scan_stack.specified;

a389 8
  if(option_profile_frequency.specified)
  {
    profile_frequency(to_int(option_profile_frequency.arguments[0]));
    set_profiler_timer_going();
  }
  else
    profile_frequency(0);

d424 2
d429 1
a429 1
    modules = image_load(option_load.arguments[0]);
d431 1
a431 1
    if(modules == NULL)
d458 3
d463 1
d465 2
d468 14
d507 1
a507 1
      (void)load(filename, option_profile.specified);
d519 15
d536 1
a536 5
    /* Load any modules specified on the command line. */
    for(loop=0; loop<argc; ++loop)
      (void)load(argv[loop], option_profile.specified);

    stop = clock();
d541 3
a543 1
    finalise_profiler_table(option_profile.specified,option_profile_dont_sort.specified);
d545 1
a545 1
    if(!image_save(option_save.arguments[0], modules))
a560 19
  else if(argc >= 1)
  {
    /* Load any remaining intermediate modules from the command line. */
    for(loop=0; loop<argc-1; ++loop)
      (void)load(argv[loop], option_profile.specified);

    /* Load the final module and execute it. */
    result = load(argv[loop], option_profile.specified);

    stop = clock();

    if(option_show.specified)
    {
      val_print(stdout, result, NULL);
      putchar('\n');
    }
  }
  else
    stop = clock();
a561 2
  finalise_profiler_table(option_profile.specified,option_profile_dont_sort.specified);

d566 1
a566 7
  finalise_store_used((unsigned int) ml_state.heap_limit);

  if(allocation_might_be_wrong)
    message("Total loading time %lums gc_time %lums ", (stop - start)/(CLK_TCK/1000),total_gc_time/(CLK_TCK/1000));
  else
    message("Total loading time %lums, allocation %u bytes,gc time %lums ", (stop - start)/(CLK_TCK/1000),
	    allocation_so_far,total_gc_time/(CLK_TCK/1000));
d571 1
d584 15
@


1.36
log
@The module table is now a single global root.
@
text
@d14 3
d258 1
a258 1
  if(structure == IMPOSSIBLE)
@


1.35
log
@Added -plock option.
@
text
@d14 3
a237 3
static ModuleTable modules;


d240 1
a240 4
 *  The module name is taken to be the basename of the filename.  The
 *  discard parameter determines whether the module table `modules' is
 *  discarded as the module is loaded or whether the module is added to the
 *  table.
d243 1
a243 1
static mlval load(const char *filename, int discard,int profile)
d251 1
a251 2
  if(!discard)
    declare_root(&module_name);
d253 1
a253 1
  structure = load_module(filename, modules, discard,profile);
d284 2
a285 5
  if(!discard)
  {
    mt_add(modules, module_name, structure);
    retract_root(&module_name);
  }
d495 1
a495 1
      (void)load(filename, 0,option_profile.specified);
d511 1
a511 1
      (void)load(argv[loop], 0,option_profile.specified);
d540 1
a540 1
      (void)load(argv[loop], 0,option_profile.specified);
d543 1
a543 1
    result = load(argv[loop], 1,option_profile.specified);
a588 5
}

ModuleTable read_module_table(void)
{
  return modules;
@


1.34
log
@Error in profiler timer code - used to start timer before initialising the signal handler
@
text
@d14 3
d127 8
d189 5
d216 3
d227 5
a231 1
  &option_profile_dont_scan_stack,  &option_end
d301 1
d303 1
a303 1
  if(sscanf(s, " %d%c", &n) != 1)
d313 1
d315 1
a315 1
  if(sscanf(s, " %u%c", &n) != 1)
d346 37
a382 3
  if(option_profile_dont_scan_stack.specified)
    scan_stack_profiling = 0;
  else scan_stack_profiling = 1;
d403 1
a403 1
    }
@


1.33
log
@Fixes to the profiler
@
text
@d14 3
a320 8
  if(option_profile_frequency.specified)
  {
    profile_frequency(to_int(option_profile_frequency.arguments[0]));
    set_profiler_timer_going();
    }
  else
    profile_frequency(0);

d340 8
d537 5
@


1.32
log
@Added timers and code for compiling the make system
@
text
@d14 3
d321 1
@


1.31
log
@Added some code for memory profiling and corrected some bugs
@
text
@d14 3
d506 1
a506 1
    message("Total loading time %lums ", (stop - start)/(CLK_TCK/1000));
d508 2
a509 1
    message("Total loading time %lums, allocation %u words ", (stop - start)/(CLK_TCK/1000),allocation_so_far);
@


1.30
log
@In the -save case, profiling information was not being taken
@
text
@d14 3
d128 1
d142 2
d186 1
d199 1
a199 1
  &option_end
d319 4
d500 6
a505 1
  message("Total loading time %lums", (stop - start)/(CLK_TCK/1000));
@


1.29
log
@Added stack backtrace depth
@
text
@d14 3
d438 1
a438 1
      (void)load(argv[loop], 0,0);
@


1.28
log
@First version of the profiler
@
text
@d14 3
d121 1
d131 8
a138 3
  "  -profile  Display profile information at end of the run.\n"
  "  -profile-frequency Profile this many times per second (default 10000). \n"
  "  -profile-dont-sort  Don't sort the results of the profiler. \n"
d179 1
d188 1
a188 1
  &option_profile_dont_sort, &option_gc_stats, &option_statistics,
d298 3
@


1.27
log
@Corrected timing code.
@
text
@d14 3
d117 1
a118 1

d127 3
d167 3
d177 2
a178 1
  &option_generations, &option_show, &option_gc_stats, &option_statistics,
d194 1
a194 1
static mlval load(const char *filename, int discard)
d205 1
a205 1
  structure = load_module(filename, modules, discard);
d289 7
d406 1
a406 1
      (void)load(filename, 0);
d422 1
a422 1
      (void)load(argv[loop], 0);
d429 2
d451 1
a451 1
      (void)load(argv[loop], 0);
d454 1
a454 1
    result = load(argv[loop], 1);
d466 2
@


1.26
log
@Removed `nothing to do' error (does nothing instead).  Added new
statistics from callc_codes.h.
@
text
@d14 4
d262 1
a324 2
  clock();

d364 2
d407 2
d437 2
d445 2
d452 1
a452 1
  DIAGNOSTIC(0, "main: Total time taken %.1fs", (float)clock() / 1000000, 0);
@


1.25
log
@Added `-statistics' option to display internal statistics.
@
text
@d14 3
d109 1
a109 1
#include "callc.h"
d113 1
a113 1
  "Usage:   runtime [options...] module... [final-module]\n"
d421 1
a421 1
  else
a422 3
    if(argc < 1)
      error("Nothing to do.  Use `-help' for help.");

d448 4
a451 1
	   "  External C routine invocation counts:\n");
@


1.24
log
@Added code to deal with ELOADVERSION error.
@
text
@d14 3
d106 1
d114 2
d136 2
d147 1
d154 1
d161 1
a161 1
  &option_generations, &option_show,
d292 12
d437 4
d442 15
@


1.23
log
@Added `-show' option.
@
text
@d14 3
d194 4
d246 1
a246 1
  if(!option_parse(&argc, &argv, options))
@


1.22
log
@Added more robust error checking of parameters and input.  Removed
extraneous includes.
@
text
@d14 4
d107 1
d141 1
d148 1
a148 1
  &option_generations,
d401 5
a405 2
    val_print(stdout, result, NULL);
    putchar('\n');
@


1.21
log
@Added -verbose option.
@
text
@d82 1
d84 1
a87 1
#include "mltypes.h"
a93 1
#include "allocator.h"
a97 3
extern long clock(void);
extern void initialise_pervasive_io(void);

d108 1
a108 1
  "  -generations n\n"
d110 2
d129 1
d140 1
a140 1
  &option_diagnostic, &option_messages, &option_internals, &option_generations,
d142 1
d206 22
a232 7
  /* Initialise run-time system. */

  if(option_generations.specified)
    initialise(atoi(option_generations.arguments[0]));
  else
    initialise(0);

d248 15
d271 3
a273 3
    val_print_defaults.depth = atoi(option_internals.arguments[0]);
    val_print_defaults.string_length = atoi(option_internals.arguments[1]);
    val_print_defaults.internals = atoi(option_internals.arguments[2]);
d277 1
a277 1
    diagnostic_level = atoi(option_diagnostic.arguments[0]);
d280 1
a280 1
    gc_message_level = atoi(option_messages.arguments[0]);
d327 1
d340 6
a345 1
    while(fscanf(f, " %s", filename) == 1)
d347 7
@


1.20
log
@Added -from option.
@
text
@d14 6
d121 2
d135 1
d141 2
a142 1
  &option_modules, &option_load, &option_save, &option_help, &option_end
d162 3
d256 3
d298 4
d319 3
@


1.19
log
@Added image load and save.  Generalised the options mechanism.
@
text
@d112 1
a112 1
  "  -module_file filename\n"
d115 1
a115 1
  "  -help Display this message.";
d123 1
a123 1
  option_modules     = {"module_file", 1, 0, NULL},
d277 1
a277 2
#ifdef NEVER
  if(list_file != NULL)
d282 1
a282 2
    DIAGNOSTIC(0, "opening `%s'", list_file, 0);
    f = fopen(list_file, "r");
d285 2
a286 1
      error("Unable to open module list file `%s'.", list_file);
d288 1
a288 3
    while(fscanf(f, " %1s", filename) == 1)
    {
      DIAGNOSTIC(0, "name: %s", filename, 0);
a289 1
    }
a292 1
#endif
d318 3
@


1.18
log
@Added `-g' option to specify number of generations initially.
@
text
@d76 1
d88 2
d96 20
a115 1
  "Usage: runtime [-d level] [-c level] [-i level] [-g top-gen] module ...";
d117 13
a129 1
int main(int argc, char *argv[])
d131 3
a133 3
  int loop;
  mlval result;
  size_t top_generation = 0;
a134 1
  /* Parse and check the command line arguments. */
d136 1
a136 3
  --argc; ++argv;
  if(argc < 1)
    error(usage_message);
a137 4
  while(argv[0][0] == '-')
  {
    if(argc < 2)
      error(usage_message);
d139 20
a158 1
    switch(argv[0][1])
d160 3
a162 3
      case 'd':
      diagnostic_level = atoi(argv[1]);
      break;
d164 2
a165 3
      case 'c':
      gc_message_level = atoi(argv[1]);
      break;
d167 3
a169 3
      case 'i':
      val_print_internals = atoi(argv[1]);
      break;
d171 2
a172 3
      case 'g':
      top_generation = atoi(argv[1]);
      break;
d174 4
d179 1
a179 1
      error("Unknown option `%c'", argv[0][1]);
d182 4
a185 2
    argc -= 2;
    argv += 2;
d188 2
a189 2
  if(argc < 1)
    error(usage_message);
a190 1
  /* Initialise run-time system and create a global module table. */
d192 4
a195 3
  initialise(top_generation);
  initialise_pervasive_io();	
  init_module_table(argc-1);
d197 41
d240 4
a243 2
  /* Load all the intermediate modules, if any, entering them into the */
  /* module table. */
d245 34
a278 1
  for (loop = 0; loop < argc-1; loop++)
d280 2
a281 1
    mlval module_name;
d283 2
a284 1
    /* Extract the bare module name from the module file name. */
d286 2
a287 1
    module_name = basename(argv[loop]);
d289 5
a293 1
    /* Load the module and add it to the table. */
d295 1
a295 6
    DIAGNOSTIC(2, "main: Loading intermediate module %s from file %s",
	          CSTRING(module_name), argv[loop]);
    
    declare_root(& module_name);
    add_module(module_name, load_module(argv[loop], INTERMEDIATE));
    retract_root(& module_name);
d297 1
d299 5
a303 2
  /* Load the final module, discarding the module table before calling */
  /* the ML code. */
d305 6
a310 1
  DIAGNOSTIC(2, "main: Loading final module from file %s", argv[loop], 0);
d312 3
a314 1
  result = load_module(argv[loop], FINAL);
d316 18
a335 6
  /* Output the contents of the result record. */

  printf("Result:\n");
  val_print(stdout, result, 40, val_print_internals);
  putchar('\n');

@


1.17
log
@Added call to initialise the new Io system
@
text
@d14 3
d77 1
d92 2
a93 1
static char *usage_message = "Usage: runtime [-d level] [-c level] [-i level] module ...";
d99 1
d126 4
d143 1
a143 1
  initialise();
@


1.16
log
@Added val_print in the System structure in ML
@
text
@d14 3
d86 1
d134 1
@


1.15
log
@Needed to add the module_name as a root during the loading process, else
the string it pointed too went walkabout
@
text
@d14 4
d167 1
a167 1
  val_print(stdout, result, 40);
@


1.14
log
@Added `-i' option.
@
text
@d14 3
d145 2
a146 1

d148 1
@


1.13
log
@Removed the assumption that the result of an execution is a record.
@
text
@d14 3
d77 1
a77 1
static char *usage_message = "Usage: runtime [-d level] [-c level] module ...";
d103 4
@


1.12
log
@Added -c option to control collection messages.
@
text
@d14 3
d150 3
a152 8
  printf("Result record:\n");
  for (loop = 0; loop < NFIELDS(result); loop++)
  {
    mlval value = GETFIELD(result, loop);
    printf("  field %i is 0x%lx: ", loop, value);
    val_print(stdout, value, 40);
    putc('\n', stdout);
  }
@


1.11
log
@Changed the name of the fatal runtime error handler to error().
Moved the code to extract base file names to utils.
@
text
@d13 5
a17 1
 *  $Log:	main.c,v $
d65 1
d71 1
a71 1
static char *usage_message = "Usage: runtime [-d level] module ...";
d84 1
a84 1
  if(strcmp(argv[0], "-d") == 0)
d87 1
a87 1
      error("Missing diagnostic level after -d option.");
d89 5
a93 1
    diagnostic_level = atoi(argv[1]);
d95 10
a104 2
    argc -=2;
    argv +=2;
@


1.10
log
@Rewrote to produce more diagnostic output and accept a diagnostic output
level on the command line as an option.
@
text
@d14 4
d77 1
a77 1
    runtime_error(1, usage_message);
d82 1
a82 1
      runtime_error(1, "Missing diagnostic level after -d option.");
d91 1
a91 1
    runtime_error(1, usage_message);
a104 1
    char *s;
d107 1
a107 2
    /* Strip away any directory names so we're left with the bare */
    /* module name for the module table. */
d109 1
a109 5
    s = strrchr(argv[loop], '/');
    if(s == NULL)
      module_name = ml_string(argv[loop]);
    else
      module_name = ml_string(s + 1);
d130 1
a130 1
  printf("Result record:");
d139 1
a139 1
  return(0);
@


1.9
log
@Changed result printing to use the val_print so that the structure
of the results can be seen.
@
text
@d1 43
a43 32
/*
 * main.c
 * Top level for run-time system (checks command line etc).
 * $Log:	main.c,v $
 * Revision 1.8  91/12/06  16:48:58  jont
 * Added pathname stripping for module names
 * 
 * Revision 1.7  91/10/28  17:29:57  davidt
 * Put in timer function.
 * 
 * Revision 1.6  91/10/23  15:30:14  davidt
 * Took out some initialisation code and moved into into the
 * file initialise.c which is especially for that purpose.
 * 
 * Revision 1.5  91/10/22  13:48:34  davidt
 * Increased size of initial stack and heap. Now calculates the ml_stack
 * pointer correctly (used to assign the stack pointer a non-aligned
 * address, this didn't show up immediately because of another bug).
 * 
 * Revision 1.4  91/10/21  10:47:35  davidt
 * Improved the printing function to show the type of pointer which
 * was returned instead of just an address.
 * 
 * Revision 1.3  91/10/18  18:27:19  davidt
 * Moved all the allocation stuff into allocate.c
 * Moved all the C and ML state preserving stuff into state.c
 * Did general tidy up and printing of result values.
 * 
 * Revision 1.2  91/10/17  15:48:08  davidt
 * Put in various hacks to get a testable version of the run-time system.
 * 
 * Copyright (c) 1991 harlequin Ltd.
d48 1
d55 3
d59 6
a64 1
void main(int argc, char *argv[])
d66 2
a67 2
  int loop, tag;
  mlval result, item;
d69 1
a69 3
  if (--argc < 1) {
    runtime_error("Usage : runtime objectfile ...");
  };
d71 20
a90 1
  /* Initialise run-time system */
d92 1
a93 4
  /* Setup module table with enough slots for all modules */
  init_module_table(argc);

  /* Start timer */
d96 2
a97 15
  /* Load all the intermediate modules */
  for (loop = 1; loop < argc; loop++) {
    char *module_name = argv[loop];
    char *temp;
    int i = -1,
        j = 0;
    while (module_name[++i]) {if (module_name[i] == '/') j = i+1;};
    /* Search for last pathname separator */
    module_name += j;
    i = strlen(module_name);
    temp = malloc(i+1);
    strcpy(temp, module_name);
    add_module(ml_string(temp), load_module(argv[loop], INTERMEDIATE));
    free(temp);
  };
d99 4
a102 2
  /* Load the final module */
  result = load_module(argv[argc], FINAL);
d104 25
a128 2
  /* Print time taken */
  printf("[Total time taken %.1fs]\n",(float)clock() / 1000000);
d130 3
a132 1
  /* Print results */
d136 1
a136 1
    printf("Result slot %i at 0x%lx: ", loop, value);
d140 2
@


1.8
log
@Added pathname stripping for module names
@
text
@d5 3
d35 3
d84 8
a91 31
  /* Print result */
  for (loop = 0; loop < NFIELDS(result); loop++) {
    item = GETFIELD(result, loop);
    tag = PRIMARY(item);
    switch (tag) {
    case INTEGER0:
    case INTEGER1:
      printf("[Result slot %i INTEGER %i]\n", loop, CINT(item));
      break;
    case PAIRPTR:
      printf("[Result slot %i PAIR 0x%lx]\n", loop, item);
      break;
    case POINTER:
      {
	switch (HEADERTAG(*(word *)CPTR(item))) {
	case RECORD:
	  printf("[Result slot %i RECORD 0x%lx]\n", loop, item);
	  break;
	case STRING:
	  printf("[Result slot %i STRING %s]\n", loop, CSTRING(item));
	  break;
	default:
	  printf("[Result slot %i is UNEXPECTED POINTER 0x%lx]\n", loop, item);
	  break;
	};
	break;
      }
    default:
      printf("[Result slot %i is UNEXPECTED 0x%lx]\n", loop, item);
    }
  };
@


1.7
log
@Put in timer function.
@
text
@d5 3
d58 12
a69 1
    add_module(ml_string(argv[loop]), load_module(argv[loop], INTERMEDIATE));
@


1.6
log
@Took out some initialisation code and moved into into the
file initialise.c which is especially for that purpose.
@
text
@d5 4
d50 3
d61 3
@


1.5
log
@Increased size of initial stack and heap. Now calculates the ml_stack
pointer correctly (used to assign the stack pointer a non-aligned
address, this didn't show up immediately because of another bug).
@
text
@d5 5
a24 5
#include <malloc.h>
#include <setjmp.h>

#include "allocator.h"
#include "debug.h"
d26 2
a27 1
#include "state.h"
d31 1
a31 3
#define BLOCK_SIZE 100000

main(int argc, char *argv[])
d40 2
a41 3
  /* Get a stack and a heap */
  ml_stack = double_align(malloc(BLOCK_SIZE));
  ml_heap  = double_align(malloc(BLOCK_SIZE));
a42 10
  if (ml_stack == NULL || ml_heap == NULL) {
    runtime_error("Couldn't allocate space for ML");
  };

  /* Setup heap limit (-7 in case we lost memory doing alignment) */
  ml_heap_limit = ml_heap + BLOCK_SIZE - 8;

  /* Setup stack (-7 in case we lost memory doing alignment) */
  ml_stack = ml_stack + BLOCK_SIZE - 8;

d48 1
a48 1
    add_module(argv[loop], load_module(argv[loop], INTERMEDIATE));
@


1.4
log
@Improved the printing function to show the type of pointer which
was returned instead of just an address.
@
text
@d5 4
d30 1
a30 1
#define BLOCK_SIZE 50000
d50 1
a50 1
  ml_heap_limit = ml_heap + BLOCK_SIZE - 7;
d53 1
a53 1
  ml_stack = ml_stack + BLOCK_SIZE - 7;
@


1.3
log
@Moved all the allocation stuff into allocate.c
Moved all the C and ML state preserving stuff into state.c
Did general tidy up and printing of result values.
@
text
@d5 5
d11 1
a11 1
 * Put in various hack to get a testable version of the run-time system.
a12 1
 *
a61 4
  /* Diagnostics */
  DEBUG("[Stack pointer: 0x%lx]\n", ml_stack, 0);
  DEBUG("[Heap Pointer: 0x%lx]\n", ml_heap, 0);

d66 3
a68 1
    if (tag == INTEGER0 || tag == INTEGER1) {
d70 21
a90 2
    } else {
      printf("[Result slot %i is.... %s]\n", loop, CSTRING(item));
a92 9

#if 0
  if ((result = setjmp(state)) == 0) {
  } else {
    /* ML calls back */
    message("ML requests service");
    exit (0);
  }
#endif
@


1.2
log
@Put in various hack to get a testable version of the run-time system.
@
text
@d4 4
a7 1
 * $Log$
d12 1
a12 1
#include <stdio.h>
a13 1
#include <malloc.h>
d15 5
a19 1
#include "mltypes.h"
a20 3
#include "callml.h"
#include "loader.h"
#include "debug.h"
a21 21
runtime_message(str)
char *str;
{
  fprintf(stderr, "[ML runtime : %s]\n", str);
}

runtime_error(str)
char *str;
{
  runtime_message(str);
  exit (-1);
}

/* The C state is stored here */

jmp_buf state;

/* ML state is stored here */

word ml_stack_pointer, ml_c_arguments;

a22 3
void *ml_stack;
void *ml_heap;
void *ml_code;
d26 2
a27 1
  int result, loop;
d29 5
a35 1
  ml_code  = double_align(malloc(BLOCK_SIZE));
d37 2
a38 2
  if (argc < 2) {
    runtime_error("Usage : runtime objectfile ...");
d41 12
a52 2
  if (ml_stack == NULL || ml_heap == NULL || ml_code == NULL) {
    runtime_error("Couldn't allocate space for ML");
d55 2
a56 1
  for (loop = 1; loop < argc; loop++) load_module(argv[loop], INTERMEDIATE);
d58 3
a60 1
  load_module(argv[argc], FINAL);
d62 11
a80 43
}

/*
 * Generate error message for when we run out of heap.
 */

static void allocation_error()
{
  runtime_error("Ran out of memory");
}

/*
 * Temporary allocate function for records (automatically checks for errors).
 */

mlval allocate_record (word size_in_words)
{
  /* Diagnostics */
  DEBUG("[Allocate record (size_in_words 0x%lx, address 0x%lx)]\n",
	size_in_words, ml_heap);
  return MLPTR((word)ml_heap, POINTER);
}

/*
 * Temporary allocate function for strings (automatically checks for errors).
 */

mlval allocate_string (word size_in_bytes)
{
  /* Diagnostics */
  DEBUG("[Allocate string (size_in_bytes 0x%lx, address 0x%lx)]\n",
	size_in_bytes, ml_heap);
  return MLPTR((word)ml_heap, POINTER);
}

void declare_root (mlval root)
{
  DEBUG("[Declare root 0x%lx]\n", root, 0);
}

void retract_root (mlval root)
{
  DEBUG("[Retract root 0x%lx]\n", root, 0);
@


1.1
log
@Initial revision
@
text
@d1 7
a8 2
/* Library includes */

d13 2
a14 4
/* Run-time system includes */

#include "types.h"
#include "utils.h"
d16 2
d19 13
a35 2
typedef unsigned int mlval;

d38 1
a38 1
u_int32 ml_stack_pointer, ml_c_arguments;
d41 3
d45 1
a45 1
main()
d47 1
a47 4
  int result;
  char *ml_stack;
  char *ml_heap;
  char *ml_code;
d50 2
a51 2
  ml_heap = double_align(malloc(BLOCK_SIZE));
  ml_code = double_align(malloc(BLOCK_SIZE));
d53 4
d58 2
a59 12
    error("Couldn't allocate space for ML");
  } else {
    int code_size;
    FILE *code_file = fopen("codefile","r");
    if (code_file == NULL)
      error("Couldn't open code file");
    code_size = getw(code_file);
    if (ferror(code_file) != 0 || feof(code_file) != 0)
      error("Error reading code length");
    if (fread(ml_code, 1, code_size, code_file) != code_size)
      error("Error reading sparc code");
  }
d61 5
a66 2
    /* Call ML */
    callml(ml_stack + BLOCK_SIZE, ml_heap, ml_heap + BLOCK_SIZE, ml_code);
d72 1
d75 5
a79 2
message(str)
char *str;
d81 1
a81 1
  printf("\n[ML runtime : %s]\n", str);
d84 5
a88 2
error(str)
char *str;
d90 26
a115 2
  message(str);
  exit (-1);
@
