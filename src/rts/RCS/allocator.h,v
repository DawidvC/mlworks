head	1.17;
access;
symbols
	Final_version_of_old_runtime:1.17
	ML_revised_beta_release_25/05/94:1.17
	ML_final_beta_release_02/03/94:1.17
	mlworks-28-01-1994:1.17
	Release:1.17
	mlworks-beta-01-09-1993:1.17
	MLWorks-1-0-3-21/12/1992:1.17
	MLWorks-1-0-2-15/12/1992:1.17
	MLWorks-1-0-1-04/12/1992:1.17
	checkpoint_17_08_92:1.15;
locks; strict;
comment	@ *  @;


1.17
date	92.09.08.13.47.46;	author richard;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	92.08.24.08.05.17;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.08.05.17.10.02;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	92.07.30.11.13.29;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	92.07.23.11.22.48;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	92.07.14.08.17.07;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	92.06.30.09.55.52;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	92.03.11.14.22.05;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	91.12.17.16.01.42;	author nickh;	state Exp;
branches;
next	1.8;

1.8
date	91.12.17.14.51.23;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	91.11.11.17.12.33;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.10.21.09.19.26;	author davidt;	state Exp;
branches;
next	1.5;

1.5
date	91.10.18.15.52.52;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	91.10.17.15.12.44;	author davidt;	state Exp;
branches;
next	1.3;

1.3
date	91.05.22.12.11.56;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.05.15.15.27.52;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.05.14.11.06.01;	author jont;	state Exp;
branches;
next	;

1.17.1.1
date	92.09.08.13.47.46;	author jont;	state Exp;
branches;
next	;


desc
@The interface of the run time system to the heap allocator/garbage collector
@


1.17
log
@Added `allocate_multiple'.
@
text
@/*  ==== ML VALUE HEAP ALLOCATOR ====
 *
 *  Copyright (C) 1992 Harelquint Ltd.
 *
 *  Description
 *  -----------
 *  This library contains functions which allocate ML objects on the ML
 *  heap.  A garbage collection may be caused by any of the functions, so
 *  any ML pointer values which need to be preserved must be declared as
 *  roots before calling them.  The objects returned are uninitialized; they
 *  must be filled with valid ML values (where applicable) before the next
 *  garbage collection.
 *
 *  Revision Log
 *  ------------
 *  $Log: allocator.h,v $
 *  Revision 1.16  1992/08/24  08:05:17  richard
 *  Added allocate_bytearray.
 *
 *  Revision 1.15  1992/08/05  17:10:02  richard
 *  Added allocate_code().
 *
 *  Revision 1.14  1992/07/30  11:13:29  richard
 *  Added static_string().
 *
 *  Revision 1.13  1992/07/23  11:22:48  richard
 *  `ml_string' now takes a const char *.
 *
 *  Revision 1.12  1992/07/14  08:17:07  richard
 *  Added allocate_array() and allocate_weak_array().
 *
 *  Revision 1.11  1992/06/30  09:55:52  richard
 *  Added storeman.h to headers.
 *
 *  Revision 1.10  1992/03/11  14:22:05  richard
 *  Tidied up and improved type abstration.
 *
 *  Revision 1.9  1991/12/17  16:01:42  nickh
 *  removed declare_root and retract_root (these are now in gc.c)
 *
 *  Revision 1.8  91/12/17  14:51:23  richard
 *  Removed argument from allocate_real.
 *  
 *  Revision 1.7  91/11/11  17:12:33  jont
 *  Added allocate_real
 *  
 *  Revision 1.6  91/10/21  09:19:26  davidt
 *  Changed the types of declare_root and retract_root so that the
 *  garbage collector is free to move the root objects (updating
 *  their new values using the address provided).
 *  
 *  Revision 1.5  91/10/18  15:52:52  davidt
 *  Allocation routines for various ML objects.
 *  
 *  Revision 1.4  91/10/17  15:12:44  davidt
 *  Took out all sorts of junk which had gone out of date.
 *  
 *  Revision 1.3  91/05/22  12:11:56  jont
 *  *** empty log message ***
 *  
 *  Revision 1.2  91/05/15  15:27:52  jont
 *  Updated for second revision of load structure
 *  
 *  Revision 1.1  91/05/14  11:06:01  jont
 *  Initial revision
 */

#ifndef allocator_h
#define allocator_h

#include "values.h"
#include "storeman.h"

#include <stddef.h>


/*  === ALLOCATE UNINITIALIZED OBJECT ===
 *
 *  The objects allocated by these functions are uninitialized, and so must
 *  be filled in with valid ML values before the next garbage collection or
 *  allocation.
 *
 *  Note:  The size passed to allocate_string() is the entire size,
 *  including the terminating '\0' character, if any.
 *
 *  The static versions of these function allocate ML values on the C heap.
 *  Care must be taken to preserve these values across image save and
 *  reload.
 */

extern mlval allocate_record(size_t number_of_fields);
extern mlval allocate_string(size_t size_in_bytes);
extern mlval allocate_bytearray(size_t size_in_bytes);
extern mlval allocate_code(size_t size_in_words);
extern mlval allocate_real(void);
extern mlval allocate_array(size_t length);
extern mlval allocate_weak_array(size_t length);

extern mlval static_string(size_t size_in_bytes);


/*  === MAKE ML STRING FROM C STRING ===
 *
 *  Creates an ML string object corresponding to a C string.
 */

extern mlval ml_string(const char *cstring);


/*  === ALLOCATE MULTIPLE OBJECTS ===
 *
 *  This function allocates a block of contiguous memory in one go.  It
 *  attempts to allocate space for `number' objects, each of size `size'
 *  values.  It returns the number of objects available and sets *start to
 *  point at the beginning of the memory.  Guaranteed not to enter the
 *  garbage collector.
 */

extern size_t allocate_multiple(size_t size, size_t number, mlval **start);

#endif
@


1.17.1.1
log
@Fork for bug fixing
@
text
@a16 3
 *  Revision 1.17  1992/09/08  13:47:46  richard
 *  Added `allocate_multiple'.
 *
@


1.16
log
@Added allocate_bytearray.
@
text
@d17 3
d108 12
@


1.15
log
@Added allocate_code().
@
text
@d17 3
d90 1
@


1.14
log
@Added static_string().
@
text
@d17 3
d87 1
@


1.13
log
@`ml_string' now takes a const char *.
@
text
@d17 3
d76 4
d87 2
@


1.12
log
@Added allocate_array() and allocate_weak_array().
@
text
@d17 3
d87 1
a87 1
extern mlval ml_string(char *cstring);
@


1.11
log
@Added storeman.h to headers.
@
text
@d17 3
d75 2
@


1.10
log
@Tidied up and improved type abstration.
@
text
@d17 3
d54 2
@


1.9
log
@removed declare_root and retract_root (these are now in gc.c)
@
text
@d1 44
a44 31
/*
 * allocator.h
 * Allocation, deallocation and tag stripping.
 * $Log:	allocator.h,v $
 * Revision 1.8  91/12/17  14:51:23  richard
 * Removed argument from allocate_real.
 * 
 * Revision 1.7  91/11/11  17:12:33  jont
 * Added allocate_real
 * 
 * Revision 1.6  91/10/21  09:19:26  davidt
 * Changed the types of declare_root and retract_root so that the
 * garbage collector is free to move the root objects (updating
 * their new values using the address provided).
 * 
 * Revision 1.5  91/10/18  15:52:52  davidt
 * Allocation routines for various ML objects.
 * 
 * Revision 1.4  91/10/17  15:12:44  davidt
 * Took out all sorts of junk which had gone out of date.
 * 
 * Revision 1.3  91/05/22  12:11:56  jont
 * *** empty log message ***
 * 
 * Revision 1.2  91/05/15  15:27:52  jont
 * Updated for second revision of load structure
 * 
 * Revision 1.1  91/05/14  11:06:01  jont
 * Initial revision
 * 
 * Copyright (c) 1991 Harlequin Ltd.
a46 1
/* Avoid multiple inclusion */
d50 2
a51 4
/* For efficiency */
#ifndef mltypes_h
#include "mltypes.h"
#endif
a52 3
/*
 * The current ML stack, heap and heap limit pointers.
 */
d54 8
a61 6
extern word ml_stack;
extern word ml_heap;
extern word ml_heap_limit;

/*
 * Allocate a record on the ML heap.
d64 3
a66 1
extern mlval allocate_record(word number_of_fields);
a67 3
/*
 * Allocate a string on the ML heap.
 */
d69 3
a71 10
extern mlval allocate_string(word size_in_bytes);

/*
 * Allocate a real on the ML heap.
 */

extern mlval allocate_real (void);

/*
 * Copy a C string into the ML heap.
@


1.8
log
@Removed argument from allocate_real.
@
text
@d5 3
a73 12

/*
 * Declare places where the garbage collector must look for roots.
 * C variables declared as roots must be declared as volatile to
 * the C compiler because they may be updated whenever a garbage
 * collection occurs. Hence, these variables must be used taking
 * care that we don't hold onto intermediate calculations
 * using them across garbage collections.
 */

extern void declare_root(mlval *root);
extern void retract_root(mlval *root);
@


1.7
log
@Added allocate_real
@
text
@d5 3
d64 1
a64 1
extern mlval allocate_real (word length);
@


1.6
log
@Changed the types of declare_root and retract_root so that the
garbage collector is free to move the root objects (updating
their new values using the address provided).
@
text
@d5 5
d56 6
@


1.5
log
@Allocation routines for various ML objects.
@
text
@d5 3
d59 6
a64 2
 * Declare places where the garbage collector must look,
 * but which must not be moved.
d67 2
a68 2
extern void declare_root(mlval root);
extern void retract_root(mlval root);
@


1.4
log
@Took out all sorts of junk which had gone out of date.
@
text
@d5 3
d29 18
a46 1
extern mlval allocate_record(word size_in_words);
d50 6
d60 2
a61 2
extern void declare_root(mlval root); /* This is a root		  */
extern void retract_root(mlval root); /* This is no longer a root */
@


1.3
log
@*** empty log message ***
@
text
@d5 3
d14 1
d17 2
a18 1
#ifndef allocator_h /* Avoid multiple inclusion */
d21 3
a23 2
#ifndef types_h /* For efficiency */
#include "types.h"
d26 2
a27 4
#define INTEGER 0		/* 00 : integer tag */
#define VANILLA 1		/* 01 : vanilla tag */
#define HEADER  2		/* 10 : header word */
#define PAIRPTR 3		/* 11 : pair pointer */
a28 23
/* Value extraction */
#define extract_int(x) ((u_int32)((x) >> 2))
#define extract_ptr(x) ((void *)((u_int32)(x) & ~3))

/* Pointer production */
#define tag_int(x) ((u_int32)x)
#define tag_vanilla(x) ((void *)(((u_int32)(x)) | (VANILLA)))
#define tag_pair(x) ((void *)(((u_int32)(x)) | (PAIR_PTR)))

/* Interface to the heap manager */
#ifdef __sparc
register void *heap_lo asm("%g6");
register void *heap_hi asm("%g7");
#endif
/* Allocation */
extern void *allocate_record(u_int32);
/* Size in words */

extern void *allocate_string(u_int32);
/* Length in bytes */

extern void *allocate_pair(void);

d30 2
a31 3
 * Roots
 * places wherein the garbage collector must look,
 * but which must not be moved
d34 2
a35 2
extern void declare_root(void *); /* This is a root */
extern void retract_root(void *); /* This is no longer a root */
a37 1
/* End allocator.h */
@


1.2
log
@Updated for second revision of load structure
@
text
@d5 3
d35 4
a44 3

extern void *allocate_code(u_int32);
/* Length in words */
@


1.1
log
@Initial revision
@
text
@d4 4
a7 1
 * $Log$
d17 7
a23 1
#define extract_int(x) ((u_int32)((x) & ~3))
d26 4
a29 4
extern u_int32 tag_int(u_int32);
extern void *tag_ptr(void *);
extern void *allocate(u_int32);
extern void deallocate(void *);
d32 20
@
