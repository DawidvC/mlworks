head	1.16;
access;
symbols
	Final_version_of_old_runtime:1.16
	ML_revised_beta_release_25/05/94:1.16
	ML_final_beta_release_02/03/94:1.16
	mlworks-28-01-1994:1.16
	Release:1.16
	mlworks-beta-01-09-1993:1.16
	MLWorks-1-0-3-21/12/1992:1.10
	MLWorks-1-0-2-15/12/1992:1.10
	MLWorks-1-0-1-04/12/1992:1.10
	checkpoint_17_08_92:1.10;
locks; strict;
comment	@ *  @;


1.16
date	93.06.22.11.15.28;	author richard;	state Exp;
branches
	1.16.1.1;
next	1.15;

1.15
date	93.06.02.14.16.20;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	93.05.05.09.34.16;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.04.30.14.28.22;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	93.04.14.13.24.01;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	93.02.10.14.12.19;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.08.07.08.25.18;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	92.08.05.16.50.31;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	92.07.24.14.06.44;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	92.07.23.08.27.08;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	92.07.17.14.23.27;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	92.07.16.16.14.09;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	92.07.14.10.31.36;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	92.07.02.15.15.21;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.10.16.17.06.25;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	91.10.16.14.14.31;	author nickh;	state Exp;
branches;
next	;

1.16.1.1
date	93.06.22.11.15.28;	author jont;	state Exp;
branches;
next	;


desc
@#defines for all (primary and secondary) tags used on the heap,
and macros for accessing them.
@


1.16
log
@Added stack marker for interception frames.  See also
sparc/interface.m4s.
@
text
@/*  ==== ML OBJECT TAGS ====
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This header is used by both C and assembler files and defines the tags
 *  used for ML values and other garbage collector markers, as well as
 *  macros for manipulating them.
 *
 *  IMPORTANT
 *  ---------
 *  This file is scanned by tags.awk and __tags.awk to produce SML sources.
 *  Any #define which defines an upper case integer will be included.
 *
 *  $Id: tags.h,v 1.15 1993/06/02 14:16:20 richard Exp richard $
 */


#ifndef tags_h
#define tags_h


/*  === PRIMARY TAGS ===
 *
 *  Every mlval is tagged in the bottom 3 bits as below.  Odd tags are
 *  always pointers, even tags are always immediates.  Possible uses
 *  for PRIMARY6 and PRIMARY7 include weak pointers,  floating-point,
 *  foreign pointers. Note that PAIRPTR and POINTER are such that
 *  (mlval - 1) is always the address of the first data word of the
 *  object (pairs being unheaded).
 */

#define INTEGER0 0		/* 000 : even integer		*/
#define PAIRPTR  1		/* 001 : pair pointer		*/
#define HEADER   2		/* 010 : header word		*/
#define REFPTR   3		/* 011 : reference pointer	*/
#define INTEGER1 4		/* 100 : odd integer		*/
#define POINTER  5		/* 101 : any other pointer	*/
#define PRIMARY6 6		/* 110 : unused : not a pointer	*/
#define PRIMARY7 7		/* 111 : unused : a pointer	*/


/*  === SECONDARY TAGS ===
 *
 *  These all live in header words.  Ordinary objects have bit 5 unset.
 *  For ordinary objects: objects with `normal' equality have bit 4
 *  unset, and objects containing pointers have bit 3 unset.  For back
 *  pointers the length field is the distance back to the start of the
 *  object.
 */

#define RECORD		 2	/* 000010 pointers, simple equality	*/
#define STRING		10	/* 001010 no pointers, simple equality	*/
#define ARRAY		18	/* 010010 pointers, ref equality 	*/
#define BYTEARRAY	26	/* 011010 no pointers, ref equality	*/
#define BACKPTR		34	/* 100010 back pointer (see above)	*/
#define CODE		42	/* 101010 no pointers, ref equality	*/
#define HEADER50	50	/* 110010 unused			*/
#define WEAKARRAY       58      /* 111010 special pointers, ref equality*/


/*  === SPECIAL VALUES AND MARKERS ===
 *
 *  These values are used as markers.  An `impossible' value is one which
 *  can not be generated by ML.
 *
 *  ERROR            impossible value used to flag errors
 *  EVACUATED        impossible value used to mark evacuated objects in the
 *                   garabge collector
 *  DEAD	     impossible value used to annul weak array entries
 *
 *  The values beginning with STACK are placed in the closure register in
 *  special stack frames so that they can be recognised by various parts of
 *  the runtime system.
 */

#define ERROR			5
#define EVACUATED		1
#define DEAD			6    /* NOTE: not a pointer */
#define STACK_START		4    /* start of ML stack (see callml) */
#define STACK_START_INTERCEPT	44   /* start of ML stack (see callml_intercept) */
#define STACK_END		8    /* marks end of ML stack */
#define STACK_EXTENSION		12   /* link back to old stack area */
#define STACK_LEAF_RAISE	16   /* wrapper frame for leaf case raise */
#define STACK_RAISE             20   /* raise frame */
#define STACK_RESUME		24   /* resumable raise frame */
#define STACK_PROFILE		28   /* profiler code frames */
#define STACK_EVENT		32   /* event handler frames */
#define STACK_C_RAISE		36   /* raise from C */
#define STACK_C_CALL		40   /* call to C */
#define STACK_INTERCEPT		44   /* code vector interception frame */


/*  === CODE VECTOR ANCILLARY ===
 *
 *  The macros beginning with ANC_ define the index within the ancillary
 *  (the array attached to a code vector) of various bits of information.
 *  See also values.h.
 *
 *  SPILLS	number of non-GC spills
 *  NAMES	the name strings
 *  PROFILES	profiling handle (see the profiler)
 *  INTERCEPTS	offset of the intercept/replace code fragment
 *  INTERFNS	the functions to call on interception/replacement
 *  LEAFS	whether a code vector is a leaf procedure
 */

#define ANCILLARY_SIZE		6
#define ANC_SPILLS		0
#define ANC_NAMES		1
#define ANC_LEAFS		2
#define ANC_PROFILES		3
#define ANC_INTERCEPTS		4
#define ANC_INTERFNS		5


/*  === OTHER RUNTIME PARAMETERS ===
 *
 *  STACK_BUFFER is the number of `unused' bytes that must be maintained
 *  between an ML stack frame and the stack limit register %g6.
 *  CODE_OFFSET is the number to be added to an mlval code vector to address
 *  its first instruction.
 *  INTERCEPT_LENGTH is the length in words of the code in a code vector
 *  which is altered to implement interception.  (See intercept.h and
 *  interface.m4s.)
 */

#define STACK_BUFFER		2048
#define DEFAULT_STACK_SIZE	64
#define CODE_OFFSET		3
#define INTERCEPT_LENGTH	3


#endif /* tags_h */
@


1.16.1.1
log
@Fork for bug fixing
@
text
@d16 1
a16 1
 *  $Id: tags.h,v 1.16 1993/06/22 11:15:28 richard Exp jont $
@


1.15
log
@Removed the RCS log since this file is distributed to users.
@
text
@d16 1
a16 1
 *  $Id$
d92 1
@


1.14
log
@Changed hex DEFAULT_STACK_SIZE to decimal
@
text
@d16 1
a16 46
 *  Revision Log
 *  ------------
 *  $Log: tags.h,v $
 *  Revision 1.13  1993/04/30  14:28:22  jont
 *  Changed to distinguish the real base of the stack from the stack limit pointer
 *
 *  Revision 1.12  1993/04/14  13:24:01  richard
 *  Ripped out old tracing mechanism and installed a new one.
 *
 *  Revision 1.11  1993/02/10  14:12:19  jont
 *  Changes for code vector reform
 *
 *  Revision 1.10  1992/08/07  08:25:18  richard
 *  Added PROFILE_DISABLE.
 *
 *  Revision 1.9  1992/08/05  16:50:31  richard
 *  Code vectors are now tagged differently to strings.
 *
 *  Revision 1.8  1992/07/24  14:06:44  richard
 *  Added STACK_C_RAISE and _CALL.
 *
 *  Revision 1.7  1992/07/23  08:27:08  richard
 *  Changed DEAD to 6 so that it isn't a pointer and doesn't have to be
 *  checked for explicitly in many places.
 *
 *  Revision 1.6  1992/07/17  14:23:27  richard
 *  Oops.  BUFFER has only two `F's.
 *
 *  Revision 1.5  1992/07/16  16:14:09  richard
 *  Added STACK_INTERRUPT and STACK_BUFFER.
 *
 *  Revision 1.4  1992/07/14  10:31:36  richard
 *  Implemented WEAKARRAY objects using HEADER50.
 *  Removed obsolete PROFILER_OFF, and added DEAD value.
 *
 *  Revision 1.3  1992/07/02  15:15:21  richard
 *  Revived this file with the new tags so that they can be used from assembler.
 *
 *  Revision 1.2  1991/10/16  17:06:25  nickh
 *  #ifndef token
 *
 *  Revision 1.2  91/10/16  15:59:43  nickh
 *  changed #ifndef token
 *
 *  Revision 1.1  91/10/16  14:14:31  nickh
 *  Initial revision
@


1.13
log
@Changed to distinguish the real base of the stack from the stack limit pointer
@
text
@d19 3
d174 1
a174 1
#define DEFAULT_STACK_SIZE	0x40
@


1.12
log
@Ripped out old tracing mechanism and installed a new one.
@
text
@d19 3
d171 1
@


1.11
log
@Changes for code vector reform
@
text
@d19 3
a110 3
 *  PROFILE_UNINIT   First call to profiling stuff not yet made
 *  PROFILE_DISABLE  written into the profiler slot of a code vector to
 *  		     prevent it from taking any profiling action
a118 2
#define PROFILE_UNINIT		0
#define PROFILE_DISABLE		4
d120 3
a122 2
#define STACK_START		4    /* start of ML stack (unimplemented) */
#define STACK_END		8    /* marks end of ML stack (unimplemented) */
d128 1
a128 1
#define STACK_INTERRUPT		32   /* interrupt handler frames */
d133 23
d162 3
d168 2
a170 1
#define CODE_OFFSET		3
@


1.10
log
@Added PROFILE_DISABLE.
@
text
@d19 3
d108 1
d119 2
a120 1
#define PROFILE_DISABLE		1
d138 2
d144 1
@


1.9
log
@Code vectors are now tagged differently to strings.
@
text
@d19 3
d105 2
d115 1
a126 1
#define STACK_ASM		44   /* assembler subroutine of ML */
@


1.8
log
@Added STACK_C_RAISE and _CALL.
@
text
@d19 3
d87 2
a88 2
#define HEADER34	34	/* 100010 unused			*/
#define BACKPTR		42	/* 101010 back pointer (see above)	*/
d121 1
@


1.7
log
@Changed DEAD to 6 so that it isn't a pointer and doesn't have to be
checked for explicitly in many places.
@
text
@d19 4
d116 2
@


1.6
log
@Oops.  BUFFER has only two `F's.
@
text
@d19 3
d103 1
a103 1
#define DEAD			9
@


1.5
log
@Added STACK_INTERRUPT and STACK_BUFFER.
@
text
@d19 3
d117 1
a117 1
#define STACK_BUFFFER		2048
@


1.4
log
@Implemented WEAKARRAY objects using HEADER50.
Removed obsolete PROFILER_OFF, and added DEAD value.
@
text
@d19 4
d105 10
@


1.3
log
@Revived this file with the new tags so that they can be used from assembler.
@
text
@d11 5
d19 3
d70 1
a70 1
#define HEADER34	34	/* 100010 unused: abnormal object	*/
d72 2
a73 2
#define HEADER50	50	/* 110010 unused: abnormal object	*/
#define HEADER58        58      /* 111010 unused: abnormal object	*/
d84 5
a88 6
 *  PROFILER_OFF     stored in the profiler slot of a code vector to disable
 *                   profiling of that code
 *  STACK_TOP        a non-pointer used in the closure at the top of the ML
 *                   stack
 *  STACK_EXTENSION  a non-pointer value used as the closure of a stack
 *                   extension frame
d93 8
a100 7
#define PROFILER_OFF		9
#define STACK_START		4
#define STACK_END		8
#define STACK_EXTENSION		12
#define STACK_LEAF_RAISE	16
#define STACK_RAISE             20
#define STACK_RESUME		24
@


1.2
log
@#ifndef token
@
text
@d1 1
a1 1
/* tags.h
d3 1
a3 2
 * defines all the tags used in the garbage collector, and macros for
 * accessing them.
d5 5
a9 8
 * $Log:	tags.h,v $
 * Revision 1.2  91/10/16  15:59:43  nickh
 * changed #ifndef token
 * 
 *
 * Revision 1.1  91/10/16  14:14:31  nickh
 * Initial revision
 * Copyright (c) 1991 Harlequin Ltd.
d11 11
a23 2
#ifndef tags.h
#define tags.h
d25 2
a26 2
/* first the primary tags. Every gc-able word is tagged in the bottom
   3 bits as follows: */
a27 8
#define INTEGER0 0		/* 000 : even integer */
#define PAIRPTR  1		/* 001 : pair pointer */
#define HEADER   2		/* 010 : header word */
#define REFPTR   3		/* 011 : reference pointer */
#define INTEGER1 4		/* 100 : odd integer */
#define POINTER  5		/* 101 : any other pointer */
#define PRIMARY6 6		/* 110 : unused : not a pointer */
#define PRIMARY7 7		/* 111 : unused : a pointer (real values?) */
d29 9
a37 1
/* odd tags are always pointers, even tags are always immediates */
d39 8
a46 2
/* possibilities for PRIMARY6 and PRIMARY7 include weak pointers,
   floating-point, foreign pointers */
a47 2
/* note that PAIRPTR and POINTER are such that (ptr-1) is always the
   address of the first data word of the object (pairs being unheaded) */
d49 8
a56 1
/* now some macros for dealing with primary tags */
d58 8
a65 3
#define ISPTR(x)      ((x) & 1)	/* is x a pointer */
#define MAKEINT(i)    ((i) << 2) /* makes an ML integer value */
#define PRIMARY(x)    ((x) & 7)	/* the primary tag of x */
a66 1
/* the others are not used much : */
d68 15
a82 29
#define MAKEWORD(t,x) (((x) << 3) + (t)) /* a word with value x and tag t */
#define GETPTR(x)	((x) & ~3) /* the pointer value */
#define MAKEPTR(t,p)	((t)+(p)) /* make word value p of type t */

/* now the secondary tags. These all live in header words */

#define RECORD		 2	/* 000010 pointers, straightforward equality */
#define STRING		10	/* 001010 no pointers, "         , " */
#define ARRAY		18	/* 010010 pointers, ref equality */
#define BYTEARRAY	26	/* 011010 no pointers, ref equality */
#define EVACUATED	34	/* 100010 only found when forwarding */
#define BACKPTR		42	/* 101010 `length' is distance back to start of object */
#define HEADER50	50	/* 110010 unused: abnormal object */
#define HEADER58        58      /* 111010 unused: abnormal object */

/* ordinary objects have bit 5 unset. */
/* ordinary objects with `normal' equality have bit 4 unset */
/* ordinary objects containing pointers have bit 3 unset */

/* possibilities for HEADER50 and HEADER58 include weak pointers and
   all sorts of other junk */

#define ISNORMAL(x)	(!((x) & 32)) 	/* ordinary object */
#define EQUALITY(x)	(!((x) & 16))	/* normal equality (if ISNORMAL(x) also) */
#define POINTERS(x)	(!((x) & 8))	/* contains pointers (if ISNORMAL(x) also) */
#define HEADERTAG(x)	((x) & 63)      /* the header tag */
#define MAKEHEAD(t,l)	(((l) << 6) + (t)) /* a header word with tag t and length l */
#define EVAC(x)		((HEADERTAG(x) == EVACUATED) /* true if x is evacuated */
#define LENGTH(x)	((x) >> 6)	/* length from a header */
d84 9
a93 2
#define NULL       0		/* null pointer */
#define IMPOSSIBLE 1		/* impossible heap value : pointer to zero */
d95 1
a95 1
#endif tags.h
@


1.1
log
@Initial revision
@
text
@d2 14
d17 2
a18 2
   defines all the tags used in the garbage collector, and macros for
   accessing them.
a19 9
   Copyright (c) 1991 Harlequin Ltd.

   $Log:

*/

#ifndef TAGS
#define TAGS

d82 1
a82 2
#endif TAGS

@
