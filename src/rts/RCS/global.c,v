head	1.8;
access;
symbols
	Final_version_of_old_runtime:1.8
	ML_revised_beta_release_25/05/94:1.8
	ML_final_beta_release_02/03/94:1.8
	mlworks-28-01-1994:1.8
	Release:1.7
	mlworks-beta-01-09-1993:1.7
	MLWorks-1-0-3-21/12/1992:1.4
	MLWorks-1-0-2-15/12/1992:1.4
	MLWorks-1-0-1-04/12/1992:1.4
	checkpoint_17_08_92:1.4;
locks; strict;
comment	@ *  @;


1.8
date	93.11.16.17.14.20;	author nickh;	state Exp;
branches;
next	1.7;

1.7
date	93.04.30.14.19.47;	author richard;	state Exp;
branches
	1.7.1.1;
next	1.6;

1.6
date	93.04.29.12.23.02;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	93.02.01.14.38.27;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	92.08.07.08.46.11;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	92.08.05.09.53.08;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.07.24.14.06.46;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.07.23.12.03.06;	author richard;	state Exp;
branches;
next	;

1.7.1.1
date	93.04.30.14.19.47;	author jont;	state Exp;
branches;
next	;


desc
@Global root manager
@


1.8
log
@Added root declaration and retraction in weak_add().
(bug fix).
@
text
@/*  ==== GLOBAL C ROOTS ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Implementation
 *  --------------
 *  The global roots are maintained as a simple extensible table.  The
 *  global root package is an ML record containing the global root names and
 *  their values.
 *
 *  Revision Log
 *  ------------
 *  $Log: global.c,v $
 *  Revision 1.7  1993/04/30  14:19:47  richard
 *  Added some diagnostics to help with image inconsistency problems.
 *
 *  Revision 1.6  1993/04/29  12:23:02  richard
 *  Corrected a stylistically bad use of a macro which could trip
 *  us up later.
 *
 *  Revision 1.5  1993/02/01  14:38:27  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.4  1992/08/07  08:46:11  richard
 *  Added weak_length and changed the type of weak_apply.
 *
 *  Revision 1.3  1992/08/05  09:53:08  richard
 *  Added weak list utilities.
 *
 *  Revision 1.2  1992/07/24  14:06:46  richard
 *  Added a duplication test to declare_global().
 *  Added a hook to global roots so that other functions are called when they
 *  are unpacked.
 *
 *  Revision 1.1  1992/07/23  12:03:06  richard
 *  Initial revision
 *
 */

#include "global.h"
#include "storeman.h"
#include "values.h"
#include "allocator.h"
#include "diagnostic.h"

#include <string.h>
#include <stdlib.h>


struct entry
{
  const char *name;
  mlval *root;
  void (*f)(mlval *root, mlval value);
} *table = NULL;
size_t table_size = 16, table_used = 0;
  

void declare_global(const char *name, mlval *root, void (*f)(mlval *root, mlval value))
{
  size_t i;

  for(i=0; i<table_used; ++i)
    if(strcmp(table[i].name, name) == 0)
      error("Duplicate global root definition for name `%s'.", name);

  if(table == NULL || table_used >= table_size)
  {
    table_size *= 2;
    table = (struct entry *)realloc(table, sizeof(struct entry) * table_size);
    if(table == NULL)
      error("Unable to expand global root table.");
  }

  table[table_used].name = name;
  table[table_used].root = root;
  table[table_used].f = f;
  ++table_used;

  declare_root(root);
}


mlval global_pack(void)
{
  mlval package = allocate_record(table_used * 2);
  size_t i;

  declare_root(&package);

  for(i=0; i<table_used; ++i)
  {
    FIELD(package, i*2)   = ml_string(table[i].name);
    FIELD(package, i*2+1) = *table[i].root;
  }

  retract_root(&package);

  return(package);
}


int global_unpack(mlval package)
{
  size_t i, j, length;

  DIAGNOSTIC(2, "global_unpack(0x%X)", package, 0);

  declare_root(&package);

  length = LENGTH(GETHEADER(package))/2;

#ifndef DEBUG			/* don't short cut */
  if(length != table_used)
    return(0);
#endif

  for(i=0; i<table_used; ++i)
  {
    const char *name = table[i].name;

    for(j=0; j<length; ++j)
      if(strcmp(CSTRING(FIELD(package, j*2)), name) == 0)
	goto found;

    DIAGNOSTIC(2, "  failed to match `%s'", name, 0);
    retract_root(&package);
    return(0);

    found:
    DIAGNOSTIC(2, "  %s: 0x%X", name, FIELD(package, j*2+1));
    if(table[i].f != NULL)
    {
      DIAGNOSTIC(2, "  invoking fix function 0x%X", table[i].f, 0);
      (*table[i].f)(table[i].root, FIELD(package, j*2+1));
    }
    else
      *table[i].root = FIELD(package, j*2+1);
  }

  retract_root(&package);
  return(1);
}


mlval weak_new(size_t granularity)
{
  mlval new = allocate_array(2);

  MLUPDATE(new, 0, MLINT(granularity));
  MLUPDATE(new, 1, MLNIL);

  return(new);
}

mlval weak_add(mlval list, mlval value)
{
  size_t granularity = MLSUB(list, 0), i;
  mlval l, array;

  for(l = MLSUB(list, 1); l != MLNIL; l = MLTAIL(l))
  {
    mlval array = MLHEAD(l);
    size_t length = LENGTH(ARRAYHEADER(array)), i;

    for(i=0; i<length; ++i)
      if(MLSUB(array, i) == DEAD)
      {
	MLUPDATE(array, i, value);
	return(list);
      }
  }

  declare_root(&list);
  declare_root(&value);
  array = allocate_weak_array(granularity);
  retract_root(&value);

  MLUPDATE(array, 0, value);
  for(i=1; i<granularity; ++i)
    MLUPDATE(array, i, DEAD);
  declare_root(&array);
  MLUPDATE(list, 1, cons(array, MLSUB(list, 1)));
  retract_root(&array);
  retract_root(&list);

  return(list);
}

size_t weak_length(mlval list)
{
  size_t total = 0;
  mlval l;

  for(l = MLSUB(list, 1); l != MLNIL; l = MLTAIL(l))
  {
    mlval array = MLHEAD(l);
    size_t length = LENGTH(ARRAYHEADER(array)), i;

    for(i=0; i<length; ++i)
      if(MLSUB(array, i) != DEAD)
	++total;
  }

  return(total);
}

void weak_apply(mlval list, mlval (*f)(unsigned int, mlval))
{
  mlval l = MLUNIT, array = MLUNIT;
  unsigned int index = 0;

  declare_root(&list);
  declare_root(&l);
  declare_root(&array);

  for(l=MLSUB(list, 1); l!=MLNIL; l=MLTAIL(l))
  {
    size_t length, i;

    array = MLHEAD(l);
    length = LENGTH(ARRAYHEADER(array));

    for(i=0; i<length; ++i)
    {
      mlval value = MLSUB(array, i);

      if(value != DEAD)
      {
	value = (*f)(index++, value);
	MLUPDATE(array, i, value);
      }
    }
  }

  retract_root(&array);
  retract_root(&l);
  retract_root(&list);
}
@


1.7
log
@Added some diagnostics to help with image inconsistency problems.
@
text
@d14 3
d182 1
a182 1

d184 1
@


1.7.1.1
log
@Fork for bug fixing
@
text
@a13 3
 *  Revision 1.7  1993/04/30  14:19:47  richard
 *  Added some diagnostics to help with image inconsistency problems.
 *
@


1.6
log
@Corrected a stylistically bad use of a macro which could trip
us up later.
@
text
@d14 4
d41 1
d102 3
a104 1
  size_t i, j;
d108 4
a111 1
  if(LENGTH(GETHEADER(package)) != table_used*2)
d113 1
d117 4
a120 2
    for(j=0; j<table_used; ++j)
      if(strcmp(CSTRING(FIELD(package, j*2)), table[i].name) == 0)
d123 1
d128 1
d130 4
a133 1
      table[i].f(table[i].root, FIELD(package, j*2+1));
@


1.5
log
@Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
@
text
@d14 3
d195 1
a195 1
  for(l = MLSUB(list, 1); l !=MLNIL; l = MLTAIL(l))
d207 4
a210 1
	MLUPDATE(array, i, f(index++, value));
@


1.4
log
@Added weak_length and changed the type of weak_apply.
@
text
@d14 3
d36 1
d82 2
a83 2
    (void)SETFIELD(package, i*2,   ml_string(table[i].name));
    (void)SETFIELD(package, i*2+1, *table[i].root);
d104 1
a104 1
      if(strcmp(CSTRING(GETFIELD(package, j*2)), table[i].name) == 0)
d112 1
a112 1
      table[i].f(table[i].root, GETFIELD(package, j*2+1));
d114 1
a114 1
      *table[i].root = GETFIELD(package, j*2+1);
@


1.3
log
@Added weak list utilities.
@
text
@d14 3
d161 19
a179 1
mlval weak_apply(mlval list, mlval (*f)(mlval))
d182 1
d200 1
a200 1
	MLUPDATE(array, i, f(value));
a206 2

  return(list);
@


1.2
log
@Added a duplication test to declare_global().
Added a hook to global roots so that other functions are called when they
are unpacked.
@
text
@d14 5
d112 75
@


1.1
log
@Initial revision
@
text
@d13 4
a16 1
 *  $Log$
d31 1
d36 1
a36 1
void declare_global(const char *name, mlval *root)
d38 6
d54 1
d84 2
d95 1
d99 4
a102 1
    *table[i].root = GETFIELD(package, j*2+1);
d105 1
@
