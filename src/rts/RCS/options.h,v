head	1.4;
access;
symbols
	Final_version_of_old_runtime:1.4
	ML_revised_beta_release_25/05/94:1.4
	ML_final_beta_release_02/03/94:1.4
	mlworks-28-01-1994:1.4
	Release:1.4
	mlworks-beta-01-09-1993:1.4
	MLWorks-1-0-3-21/12/1992:1.2
	MLWorks-1-0-2-15/12/1992:1.2
	MLWorks-1-0-1-04/12/1992:1.2
	checkpoint_17_08_92:1.1;
locks; strict;
comment	@ *  @;


1.4
date	93.06.02.13.06.46;	author richard;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	93.04.30.12.36.39;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.09.01.10.48.23;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.03.18.14.06.00;	author richard;	state Exp;
branches;
next	;

1.4.1.1
date	93.06.02.13.06.46;	author jont;	state Exp;
branches;
next	;


desc
@Command line option parser.
@


1.4
log
@Improved the use of const on the argv parameter type.
@
text
@/*  ==== COMMAND LINE OPTIONS PARSER ====
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This module provides a generalised parsing mechanism for the command
 *  line parameters passed to main().  A command line of the form:
 *
 *    command [options] parm...
 *
 *  where options are keywords beginning with OPTION_CHAR which can take
 *  zero or more arguments.  Options must come before any other parameters.
 *  The option OPTION_CHAR OPTION_CHAR (e.g. "--" on UNIX) is special: it
 *  terminates option processing.  All parameters after it are ignored.
 *
 *  Revision Log
 *  ------------
 *  $Log: options.h,v $
 *  Revision 1.3  1993/04/30  12:36:39  richard
 *  Multiple arguments can now be passed to the storage manager in a general
 *  way.
 *
 *  Revision 1.2  1992/09/01  10:48:23  richard
 *  Implemented delimited options.
 *
 *  Revision 1.1  1992/03/18  14:06:00  richard
 *  Initial revision
 *
 */

#ifndef options_h
#define options_h

#include <stddef.h>


/*  == Option switch character ==
 *
 *  This character is used to distinguish options from other parameters.
 */

#define OPTION_CHAR	'-'


/*  == Option desciptor ==
 *
 *  An option descriptor specifies the keyword for an option and the number
 *  of arguments it requires.  An array of these desciptors is passed to
 *  option_parse() below and updated to contains the parameters.
 */

struct option
{
  const char *name;
  int nr_arguments;
  int specified;
  const char *const *arguments;
};



/*  === PARSE COMMAND LINE OPTIONS ===
 *
 *  The option_parse() function is passed pointers to a list of arguments
 *  such as those passed to main().  (Actually, it is passed argc-1 and
 *  argv+1.) It also takes an array of option descriptors (see
 *  above) terminated with a descriptor whose `name' field is NULL.  The
 *  parameters in the argv array are matched against the option names and
 *  the option desciptors are updated to inidicate that they were specified.
 *
 *  For example, if OPTION_CHAR is '-' and the desciptor array is
 *  initialised to
 *   {{"x", 0, 0, NULL}, {"y", 2, 0, NULL}, {"z", 1, 0, NULL},
 *    {NULL, 0, 0, NULL}}
 *  and the command line was
 *   foo -y A B -x -- -z loofah
 *  i.e. it is the array
 *   {"foo", "-y", "A", "B", "-x", "--", "-z", "loofah"}
 *  the desciptors will be updated to
 *   {{"x", 0, 1, ?}, {"y", 2, 1, {"A", "B"}}, {"z", 1, 0, NULL},
 *    {NULL, 0, 0, NULL}}
 *  and the command array will be
 *   {"-z", "loofah"}
 *
 *  A non-zero value is returned iff successful, otherwise `errno' is set to
 *  one of the enumerated values below and argv is left pointing to the
 *  problematical parameter.
 *
 *  NOTE: option_parse does not make use of the fact that argv[argc] is
 *  NULL, so it is safe to use on other arrays of strings.
 */

enum
{
  EOPTIONUNKNOWN=1,	/* An option not in the desciptors was specified. */
  EOPTIONARGS,		/* The wrong number of arguments were specified. */
  EOPTIONDELIM		/* Missing delimiter from delimited option. */
};

typedef const char *const *argv_t;

int option_parse(int *argcp,
		 argv_t *argvp,
		 struct option *options[]);


/*  === UTILITIES ===
 *
 *  These cause fatal errors if the string is of the wrong form.
 */

int to_int(const char *s);
unsigned int to_unsigned(const char *s);

#endif
@


1.4.1.1
log
@Fork for bug fixing
@
text
@a19 3
 *  Revision 1.4  1993/06/02  13:06:46  richard
 *  Improved the use of const on the argv parameter type.
 *
@


1.3
log
@Multiple arguments can now be passed to the storage manager in a general
way.
@
text
@d20 4
d101 2
d104 1
a104 1
		 const char ***argvp,
@


1.2
log
@Implemented delimited options.
@
text
@d20 3
d61 3
a63 3
 *  The option_parse() function is passed a pointer to the argument
 *  variables (usually called `argv' and `argc') passed to main() when the
 *  program starts.  It also takes an array of option descriptors (see
d85 3
d100 9
@


1.1
log
@Initial revision
@
text
@d19 4
a22 1
 *  $Log$
d87 2
a88 1
  EOPTIONARGS		/* The wrong number of arguments were specified. */
@
