head	1.46;
access;
symbols
	MLW_daveb_inline_1_4_99:1.46.4
	MLWorks_21c0_1999_03_25:1.46
	MLWorks_20c1_1998_08_20:1.46
	MLWorks_20c0_1998_08_04:1.46
	MLWorks_20b2c2_1998_06_19:1.46
	MLWorks_20b2_Windows_1998_06_12:1.46
	MLWorks_20b1c1_1998_05_07:1.46
	MLWorks_20b0_1998_04_07:1.46
	MLWorks_20b0_1998_03_20:1.46
	MLWorks_20m2_1998_02_16:1.46
	MLWorks_20m1_1997_10_23:1.46
	MLWorks_11r1:1.46.1.1.1.1.1
	MLWorks_workspace_97:1.46.3
	MLWorks_dt_wizard:1.46.2
	MLWorks_11c0_1997_09_09:1.46.1.1.1.1
	MLWorks_10r3:1.46.1.1.3
	MLWorks_10r2_551:1.46.1.1.2
	MLWorks_11:1.46.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.46.1.1
	MLWorks_20m0_1997_06_20:1.46
	MLWorks_1_0_r2c2_1997_06_14:1.46.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.46.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.46.1
	MLWorks_BugFix_1997_04_24:1.46
	MLWorks_1_0_r2_Win32_1997_04_11:1.46
	MLWorks_1_0_r2_Unix_1997_04_04:1.46
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.44.3.1.1
	MLWorks_gui_1996_12_18:1.44.4
	MLWorks_1_0_Win32_1996_12_17:1.44.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.44.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.44.1.1
	MLWorks_1_0_Irix_1996_11_28:1.44.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.44.2
	MLWorks_1_0_Unix_1996_11_14:1.44.1
	MLWorks_Open_Beta2_1996_10_11:1.43.3
	MLWorks_License_dev:1.43.2
	MLWorks_1_open_beta_1996_09_13:1.43.1
	MLWorks_Open_Beta_1996_08_22:1.43
	MLWorks_Beta_1996_07_02:1.43
	MLWorks_Beta_1996_06_07:1.43
	MLWorks_Beta_1996_06_06:1.43
	MLWorks_Beta_1996_06_05:1.43
	MLWorks_Beta_1996_06_03:1.43
	MLWorks_Beta_1996_05_31:1.43
	MLWorks_Beta_1996_05_30:1.43
	ML_beta_release_12/08/94:1.34
	ML_beta_release_03/08/94:1.34
	ML_revised_beta_release_25/05/94:1.34
	ML_final_beta_release_02/03/94:1.32
	mlworks-28-01-1994:1.31
	Release:1.29
	mlworks-beta-01-09-1993:1.29
	MLWorks-1-0-4-29/01/1993:1.23
	MLWorks-1-0-3-21/12/1992:1.22
	MLWorks-1-0-2-15/12/1992:1.22
	MLWorks-1-0-1-04/12/1992:1.22
	checkpoint_17_08_92:1.19;
locks; strict;
comment	@ * @;


1.46
date	97.01.15.13.00.26;	author matthew;	state Exp;
branches
	1.46.1.1
	1.46.2.1
	1.46.3.1
	1.46.4.1;
next	1.45;

1.45
date	96.11.22.12.13.00;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	96.11.06.11.08.27;	author matthew;	state Exp;
branches
	1.44.1.1
	1.44.2.1
	1.44.3.1
	1.44.4.1;
next	1.43;

1.43
date	96.05.02.14.59.40;	author jont;	state Exp;
branches
	1.43.1.1
	1.43.2.1
	1.43.3.1;
next	1.42;

1.42
date	96.05.02.12.37.42;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	96.04.29.14.47.49;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	95.12.20.13.24.13;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	95.05.31.11.10.43;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	94.10.13.11.15.44;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	94.09.30.12.50.34;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	94.09.13.14.51.52;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	94.08.25.13.49.42;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	94.05.12.12.47.33;	author richard;	state Exp;
branches;
next	1.33;

1.33
date	94.03.09.15.09.08;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	94.02.11.15.57.20;	author nickh;	state Exp;
branches;
next	1.31;

1.31
date	94.01.17.18.33.52;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	93.11.01.16.32.06;	author nickh;	state Exp;
branches;
next	1.29;

1.29
date	93.08.17.11.55.31;	author richard;	state Exp;
branches
	1.29.1.1;
next	1.28;

1.28
date	93.08.06.13.51.36;	author richard;	state Exp;
branches;
next	1.27;

1.27
date	93.06.01.15.01.31;	author nosa;	state Exp;
branches;
next	1.26;

1.26
date	93.05.18.14.33.53;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	93.04.27.13.44.02;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	93.03.10.18.12.47;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.01.21.15.34.06;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.11.03.14.30.09;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.08.28.14.43.01;	author davidt;	state Exp;
branches;
next	1.20;

1.20
date	92.08.26.15.16.49;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.08.04.18.26.46;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.07.14.13.57.59;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	92.06.18.16.21.12;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	92.06.17.10.09.09;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.06.09.14.30.59;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	92.06.04.09.07.04;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	92.06.01.10.18.16;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	92.05.12.10.45.45;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	92.05.05.13.57.46;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	92.05.05.09.50.44;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	92.04.27.12.46.40;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	92.04.21.11.08.44;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.04.14.09.25.27;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.04.09.15.15.47;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	92.03.05.15.52.05;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	92.03.04.14.28.00;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	92.03.03.13.58.30;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.02.28.14.08.09;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.02.20.16.29.24;	author richard;	state Exp;
branches;
next	;

1.29.1.1
date	93.08.17.11.55.31;	author jont;	state Exp;
branches;
next	1.29.1.2;

1.29.1.2
date	93.11.01.16.25.58;	author nickh;	state Exp;
branches;
next	;

1.43.1.1
date	96.09.13.11.14.45;	author hope;	state Exp;
branches;
next	;

1.43.2.1
date	96.10.07.16.05.08;	author hope;	state Exp;
branches;
next	;

1.43.3.1
date	96.10.17.11.23.24;	author hope;	state Exp;
branches;
next	;

1.44.1.1
date	96.11.14.12.47.43;	author hope;	state Exp;
branches
	1.44.1.1.1.1;
next	;

1.44.1.1.1.1
date	96.11.28.14.59.15;	author hope;	state Exp;
branches;
next	;

1.44.2.1
date	96.11.22.18.07.46;	author hope;	state Exp;
branches;
next	;

1.44.3.1
date	96.12.17.17.46.28;	author hope;	state Exp;
branches
	1.44.3.1.1.1;
next	;

1.44.3.1.1.1
date	97.02.24.11.36.06;	author hope;	state Exp;
branches;
next	;

1.44.4.1
date	96.12.18.09.40.28;	author hope;	state Exp;
branches;
next	;

1.46.1.1
date	97.05.12.10.32.48;	author hope;	state Exp;
branches
	1.46.1.1.1.1
	1.46.1.1.2.1
	1.46.1.1.3.1;
next	;

1.46.1.1.1.1
date	97.07.28.18.17.44;	author daveb;	state Exp;
branches
	1.46.1.1.1.1.1.1;
next	;

1.46.1.1.1.1.1.1
date	97.10.07.11.42.38;	author jkbrook;	state Exp;
branches;
next	;

1.46.1.1.2.1
date	97.09.08.17.11.16;	author daveb;	state Exp;
branches;
next	;

1.46.1.1.3.1
date	97.09.09.14.06.53;	author daveb;	state Exp;
branches;
next	;

1.46.2.1
date	97.09.10.19.21.28;	author brucem;	state Exp;
branches;
next	;

1.46.3.1
date	97.09.11.20.52.41;	author daveb;	state Exp;
branches;
next	;

1.46.4.1
date	99.04.01.17.55.47;	author daveb;	state Exp;
branches;
next	;


desc
@Annotated MIR procedure type
functor
@


1.46
log
@Have tag list in tagged operations
@
text
@(*  ==== MIR ANNOTATED PROCEDURE TYPE ====
 *               SIGNATURE
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Revision Log
 *  ------------
 *  $Log: _mirprocedure.sml,v $
 * Revision 1.45  1996/11/22  12:13:00  matthew
 * Removing references to MLWorks.Option
 *
 * Revision 1.44  1996/11/06  11:08:27  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.43  1996/05/02  14:59:40  jont
 * floor doesn't need to be in raises table
 * as it contains the handler reference in the instruction
 *
 * Revision 1.42  1996/05/02  12:37:42  jont
 * raises function didn't know call_c could raise
 * also didn't know floor could raise. Both added.
 *
 * Revision 1.41  1996/04/29  14:47:49  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.40  1995/12/20  13:24:13  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
 *  Revision 1.39  1995/05/31  11:10:43  matthew
 *  Removing call to xtime
 *
 *  Revision 1.38  1994/10/13  11:15:44  matthew
 *  Use pervasive Option.option for return values in NewMap
 *
 *  Revision 1.37  1994/09/30  12:50:34  jont
 *  Remove handler register concept
 *
 *  Revision 1.36  1994/09/13  14:51:52  matthew
 *  Abstraction of debug information
 *
 *  Revision 1.35  1994/08/25  13:49:42  matthew
 *  Removed various unnecessary annotations
 *
 *  Revision 1.34  1994/05/12  12:47:33  richard
 *  Add field to MirTypes.PROC_PARAMS.
 *
 *  Revision 1.33  1994/03/09  15:09:08  jont
 *  Adding load offset instruction
 *
 *  Revision 1.32  1994/02/11  15:57:20  nickh
 *  checkout -com MLWharp _mirprocedure.sml -and -com MLWsparc _pervasives.sml
 *  Fix handling of trapping operations.
 *
 *  Revision 1.31  1994/01/17  18:33:52  daveb
 *  Removed unnecessary exceptions from closures.
 *
 *  Revision 1.30  1993/11/01  16:32:06  nickh
 *  Merging in structure simplification.
 *
 *  Revision 1.29.1.2  1993/11/01  16:25:58  nickh
 *  Removed unused substructures of MirTables
 *
 *  Revision 1.29.1.1  1993/08/17  11:55:31  jont
 *  Fork for bug fixing
 *
 *  Revision 1.29  1993/08/17  11:55:31  richard
 *  Changed the annotation of raise instructions to model the fact that
 *  the raise might reach _any_ of the nexted continuation blocks.
 *
 *  Revision 1.28  1993/08/06  13:51:36  richard
 *  Added a hack to remove LEA instructions which reference nonexistent
 *  blocks.
 *
 *  Revision 1.27  1993/06/01  15:01:31  nosa
 *  Debugger Environments for local and closure variable inspection
 *  in the debugger;
 *  changed Option.T to Option.opt.
 *
 *  Revision 1.26  1993/05/18  14:33:53  jont
 *  Removed Integer parameter
 *
 *  Revision 1.25  1993/04/27  13:44:02  richard
 *  The PROFILER instruction has been removed.  It's replacement,
 *  INTERCEPT, does not force a function to be non-leaf.
 *
 *  Revision 1.24  1993/03/10  18:12:47  matthew
 *  changed Map substructure now MirTypes.Map
 *  Signature revisions
 *
 *  Revision 1.23  1993/01/21  15:34:06  jont
 *  Changed handle Map.Undefined constructs for case statements thus
 *  allowing tail recursion to work proprely
 *
 *  Revision 1.22  1992/11/03  14:30:09  jont
 *  Efficiency changes to use mononewmap for registers and tags
 *
 *  Revision 1.21  1992/08/28  14:43:01  davidt
 *  Removed some unncesessary intermediate lists which
 *  were being built.
 *
 *  Revision 1.20  1992/08/26  15:16:49  jont
 *  Removed some redundant structures and sharing
 *
 *  Revision 1.19  1992/08/04  18:26:46  jont
 *  Removed various uses of NewMap.to_list in favour of fold and union
 *
 *  Revision 1.18  1992/07/14  13:57:59  richard
 *  Temporary fix to prevent exception continuation blocks disappearing.
 *
 *  Revision 1.17  1992/06/18  16:21:12  richard
 *  Added parameter to RAISE once again.
 *
 *  Revision 1.16  1992/06/17  10:09:09  richard
 *  Added show_timings.
 *
 *  Revision 1.15  1992/06/09  14:30:59  richard
 *  Added total registers used as an annotation on procedures.
 *
 *  Revision 1.14  1992/06/04  09:07:04  richard
 *  Added copy' and changed is_empty to take advantage of new
 *  functions in MONOSET signature.
 *
 *  Revision 1.13  1992/06/01  10:18:16  richard
 *  Changed virtual register Sets to Packs.
 *  Added mutating union, intersection, etc.
 *  Added RegisterPack invocation.
 *  Utilized mutable set operations to provide block-wise packs of
 *  defined and referenced registers.
 *
 *  Revision 1.12  1992/05/12  10:45:45  richard
 *  Moved set operations on triples of register sets to here.
 *  Corrected print routine slightly.
 *
 *  Revision 1.11  1992/05/05  13:57:46  richard
 *  Added calculation of leaf procedure flag.
 *
 *  Revision 1.9  1992/04/27  12:46:40  richard
 *  Added register annotations to blocks and `first definition' annotation to
 *  instructions.
 *
 *  Revision 1.8  1992/04/21  11:08:44  jont
 *  Added require "text"
 *
 *  Revision 1.7  1992/04/14  09:25:27  clive
 *  First version of the profiler
 *
 *  Revision 1.6  1992/04/09  15:15:47  richard
 *  Added uses_stack annotation.
 *
 *  Revision 1.5  1992/03/05  15:52:05  richard
 *  Added side_effects annotation to instructions.
 *
 *  Revision 1.4  1992/03/04  14:28:00  richard
 *  Annotation no longer traces TAIL_CALLs even when the tag is explicit
 *  since they may leave the procedure.
 *
 *  Revision 1.3  1992/03/03  13:58:30  richard
 *  Added missing branch case for FLOOR instructions.
 *
 *  Revision 1.2  1992/02/28  14:08:09  richard
 *  Changed the way virtual registers are handled.  See MirTypes.
 *
 *  Revision 1.1  1992/02/20  16:29:24  richard
 *  Initial revision
 *
 *)

require "../basis/__int";

require "../utils/lists";
require "../utils/crash";
require "../utils/diagnostic";
require "registerpack";
require "mirprint";
require "mirtables";
require "mirprocedure";


functor MirProcedure (
  structure Lists	 : LISTS
  structure Crash	 : CRASH                      
  structure MirTables	 : MIRTABLES
  structure MirPrint	 : MIRPRINT
  structure RegisterPack : REGISTERPACK
  structure Diagnostic	 : DIAGNOSTIC

  sharing MirTables.MirTypes = MirPrint.MirTypes = RegisterPack.MirTypes
) : MIRPROCEDURE =

  struct
    structure MirTypes = MirTables.MirTypes
    structure Map = MirTypes.Map
    structure Set = MirTypes.Set
    structure Diagnostic = Diagnostic
    structure Text = MirTypes.GC.Set.Text
    structure RuntimeEnv = MirTypes.Debugger_Types.RuntimeEnv

    fun crash message =
      Crash.impossible ("MirProcedure: " ^ message)

    fun union ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Pack.union (gc, gc'),
       non_gc = MirTypes.NonGC.Pack.union (non_gc, non_gc'),
       fp     = MirTypes.FP.Pack.union (fp, fp')}

    fun union' ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Pack.union' (gc, gc'),
       non_gc = MirTypes.NonGC.Pack.union' (non_gc, non_gc'),
       fp     = MirTypes.FP.Pack.union' (fp, fp')}

    fun intersection ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Pack.intersection (gc, gc'),
       non_gc = MirTypes.NonGC.Pack.intersection (non_gc, non_gc'),
       fp     = MirTypes.FP.Pack.intersection (fp, fp')}

    fun intersection' ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Pack.intersection' (gc, gc'),
       non_gc = MirTypes.NonGC.Pack.intersection' (non_gc, non_gc'),
       fp     = MirTypes.FP.Pack.intersection' (fp, fp')}

    fun difference ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Pack.difference (gc, gc'),
       non_gc = MirTypes.NonGC.Pack.difference (non_gc, non_gc'),
       fp     = MirTypes.FP.Pack.difference (fp, fp')}

    fun difference' ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Pack.difference' (gc, gc'),
       non_gc = MirTypes.NonGC.Pack.difference' (non_gc, non_gc'),
       fp     = MirTypes.FP.Pack.difference' (fp, fp')}

    fun equal ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      MirTypes.GC.Pack.equal (gc, gc') andalso
      MirTypes.NonGC.Pack.equal (non_gc, non_gc') andalso
      MirTypes.FP.Pack.equal (fp, fp')

    fun pack {gc, non_gc, fp} =
      {gc     = MirTypes.GC.pack_set gc,
       non_gc = MirTypes.NonGC.pack_set non_gc,
       fp     = MirTypes.FP.pack_set fp}

    fun unpack {gc, non_gc, fp} =
      {gc     = MirTypes.GC.unpack_set gc,
       non_gc = MirTypes.NonGC.unpack_set non_gc,
       fp     = MirTypes.FP.unpack_set fp}

    fun copy' {gc, non_gc, fp} =
      {gc     = MirTypes.GC.Pack.copy' gc,
       non_gc = MirTypes.NonGC.Pack.copy' non_gc,
       fp     = MirTypes.FP.Pack.copy' fp}

    val empty = {gc = MirTypes.GC.Pack.empty,
                 non_gc = MirTypes.NonGC.Pack.empty,
                 fp = MirTypes.FP.Pack.empty}

    val empty_set = {gc = MirTypes.GC.Set.empty,
                     non_gc = MirTypes.NonGC.Set.empty,
                     fp = MirTypes.FP.Set.empty}

    fun is_empty {gc, non_gc, fp} =
      MirTypes.GC.Pack.is_empty gc andalso
      MirTypes.NonGC.Pack.is_empty non_gc andalso
      MirTypes.FP.Pack.is_empty fp


    fun pack_set_union'  ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Set.reduce MirTypes.GC.Pack.add' (gc,gc'),
       non_gc = MirTypes.NonGC.Set.reduce MirTypes.NonGC.Pack.add' (non_gc,non_gc'),
       fp     = MirTypes.FP.Set.reduce MirTypes.FP.Pack.add' (fp,fp')}

    (* Remove the elements of a set from the elements of a packed set *)
    fun pack_set_difference'  ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Set.reduce MirTypes.GC.Pack.remove' (gc,gc'),
       non_gc = MirTypes.NonGC.Set.reduce MirTypes.NonGC.Pack.remove' (non_gc,non_gc'),
       fp     = MirTypes.FP.Set.reduce MirTypes.FP.Pack.remove' (fp,fp')}

    fun gcforall f set = MirTypes.GC.Set.reduce (fn (t,i) => t andalso f i) (true,set)
    fun nongcforall f set = MirTypes.NonGC.Set.reduce (fn (t,i) => t andalso f i) (true,set)
    fun fpforall f set = MirTypes.FP.Set.reduce (fn (t,i) => t andalso f i) (true,set)

    fun set_pack_disjoint  ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      (gcforall (fn r => not (MirTypes.GC.Pack.member (gc',r))) gc) andalso
      (nongcforall (fn r => not (MirTypes.NonGC.Pack.member (non_gc',r))) non_gc) andalso
      (fpforall (fn r => not (MirTypes.FP.Pack.member (fp',r))) fp)

    val substitute = RegisterPack.substitute

    datatype instruction =
      I of {defined	: {gc     : MirTypes.GC.Pack.T,
                           non_gc : MirTypes.NonGC.Pack.T,
                           fp     : MirTypes.FP.Pack.T},
            referenced	: {gc     : MirTypes.GC.Pack.T,
                           non_gc : MirTypes.NonGC.Pack.T,
                           fp     : MirTypes.FP.Pack.T},
            branches	: MirTypes.tag Set.Set,
            excepts	: MirTypes.tag list,
            opcode      : MirTypes.opcode}

    datatype block =
      B of {reached	: MirTypes.tag Set.Set,
            excepts	: MirTypes.tag list,
            length	: int} *
           instruction list

    datatype procedure =
      P of {uses_stack	 : bool,
            nr_registers : {gc : int, non_gc : int, fp : int},
            parameters   : MirTypes.procedure_parameters} *
           string * MirTypes.tag * (block) Map.T



    (*  == Extract Branches from Opcode ==
     *
     *  `branches' takes an opcode to a list of the tags to which it
     *  might branch, a boolean indicating whether the next instruction
     *  is reached, and a possibly optimised opcode.
     *
     *  `raises' is a predicate indicating whether an instruction can raise
     *  an exception.
     *)

    local
      open MirTypes
    in
      fun branches (opcode as TBINARY (_, tags, _, _, _)) =
          {next = true, branches = tags, opcode = opcode}
        | branches (opcode as TBINARYFP (_, tags, _, _, _)) =
          {next = true, branches = tags, opcode = opcode}
        | branches (opcode as TUNARYFP (_, tags, _, _)) =
          {next = true, branches = tags, opcode = opcode}
        | branches (opcode as BRANCH (_, TAG tag)) =
          {next = false, branches = [tag], opcode = opcode}
        | branches (opcode as BRANCH (_, REG _)) =
          {next = false, branches = [], opcode = opcode}
        | branches (opcode as TEST (_, tag, _, _)) =
          {next = true, branches = [tag], opcode = opcode}
        | branches (opcode as FTEST (_, tag, _, _)) =
          {next = true, branches = [tag], opcode = opcode}
        | branches (opcode as TAIL_CALL _) =
          {next = false, branches = [], opcode = opcode}
        | branches (opcode as SWITCH (_, _, tags as [tag])) =
          {next = false, branches = tags, opcode = BRANCH(BRA, TAG tag)}
        | branches (opcode as SWITCH (_, _, tags)) =
          {next = false, branches = tags, opcode = opcode}
        | branches (opcode as RTS) =
          {next = false, branches = [], opcode = opcode}
        | branches (opcode as RAISE _) =
          {next = false, branches = [], opcode = opcode}
        | branches (opcode as FLOOR(_, tag, _, _)) =
          {next = true, branches = [tag], opcode = opcode}
        | branches opcode =
          {next = true, branches = [], opcode = opcode}

      fun raises (RAISE _) = true
        | raises (BRANCH_AND_LINK _) = true	(* A subroutine may raise an exception *)
	| raises (TBINARY (_, [],_,_,_)) = true
	| raises (TBINARYFP (_, [],_,_,_)) = true
	| raises (TUNARYFP (_, [],_,_)) = true
	| raises CALL_C = true
        | raises _ = false

    end



    (*  === ANNOTATE A PROCEDURE ===
     *
     *  The annotation algorithm analyses the flow of control using two
     *  mutually recursive functions and builds a Map.T of tags to annotated
     *  blocks.  `next' takes the map so far and a list of blocks to be
     *  processed with the exception handlers active on entry.  If the first
     *  block on the list *)


    fun annotate (procedure as MirTypes.PROC (name,start_tag, parameters, block_list,_)) =
      let
        val {nr_registers, substitute} = RegisterPack.f procedure

        (* Build a function mapping tags to blocks in the original *)
        (* procedure. *)

	val old_block_map =
	  (Lists.reducel (fn (res, MirTypes.BLOCK(x,y)) =>
			  Map.define(res, x, y))
	   (Map.empty, block_list))
        fun old_block x = Map.tryApply'(old_block_map, x)

        (*  == Annotate a list of opcodes ==
         *
         *  Given a list of unannotated opcodes and a stack (list) of active
         *  exception blocks, this function constructs an annotated block
         *  and returns a list of other blocks reached with the exception
         *  block stack active at the time of branching.  It also returns 
         *  booleans indicating whether there were any non-leaf instructions, and whether
         *  the block uses stack.
         *)

        fun block (excepts, opcodes) =
          let
            fun block' (done, defined, length, reached, stack, _, []) =
                (rev done, defined, length, reached, stack)
              | block' (done, defined, length, reached, stack, excepts, opcode::opcodes) =
                let

                  val opcode' = substitute opcode

                  (* add or remove exceptions from the exception stack. *)
                  val excepts' =
                    case opcode'
                      of MirTypes.NEW_HANDLER(_, tag) => tag::excepts
                       | MirTypes.OLD_HANDLER =>
                         (case excepts
                            of _::rest => rest
                             | [] =>
                               crash ("Too many OLD_HANDLERs in procedure " ^ MirTypes.print_tag start_tag ^ "."))
                       | _ => excepts

                  (* Check whether the opcode uses any stack at all. *)
                  val stack' =
                    case opcode'
                      of MirTypes.STACKOP _ => true
                       | MirTypes.ALLOCATE_STACK _ => true
                       | MirTypes.DEALLOCATE_STACK _ => true
                       | _ => stack

                  (* Find out where the opcode might possible go to. *)
                  val {next, branches, opcode = opcode''} = branches opcode'
                  val reached' = (map (fn tag => (excepts', tag)) branches) @@ reached

                  (* Find out if the opcode might raise an exception.  If it *)
                  (* does, then it might reach any exception continuation in *)
                  (* the current stack. *)
                  val (excepts, reached'') =
                    if raises opcode'' then
                      let
                        fun reach (reached, []) = reached
                          | reach (reached, excepts as cont::conts) =
                            reach ((excepts, cont)::reached, conts)

                        val reached'' = reach (reached',excepts)
                      in
                        (excepts, reached'')
                      end
                    else
                      ([], reached')

                  (* Build an annotated instruction with the information. *)
                  val defined_here = pack (MirTables.defined_by opcode'')
                  val referenced_here = pack (MirTables.referenced_by opcode'')
                  val instruction =
                    I {defined      = defined_here,
                        referenced   = referenced_here,
                        branches     = Set.list_to_set branches,
                        excepts       = excepts,
                        opcode = opcode''}
                in
                  block' (instruction::done,
                          union' (defined, defined_here),
                          case opcode'' of MirTypes.COMMENT _ => length | _ => length+1,
                          reached'',
                          stack',
                          excepts',
                          if next then opcodes else [])
                end

            val (instructions, defined, length, reached, stack) =
              block' ([], empty, 0, [], false, excepts, opcodes)
          in
            (B ({reached = Set.list_to_set (map #2 reached),
                 length = length,
                 excepts = excepts}, 
                instructions),
             defined,
             reached,
             stack)
          end

        (*  == Iteratively Annotate Blocks Until Done ==
         *
         *  This function runs through a list of (exception stack, block
         *  tag) pairs and, if the block has not already been processed,
         *  builds an annotated block for each, adding it to a Map.T of
         *  processed blocks.  The blocks reached by annotating the
         *  procedure are added to the list for the next iteration.
         *)

        fun next (map, stack, []) = (map,stack)
          | next (map, stack, (excepts, tag)::rest) =
	    (case Map.tryApply'(map, tag) of
	       SOME (B ({excepts = excepts', ...}, _)) =>
		 if excepts = excepts' then
		   next (map, stack, rest)
		 else
		   crash ("Block " ^ MirTypes.print_tag tag ^ " has been reached with inconsistent exception blocks.  " ^
			  "The first time round they were " ^ Lists.to_string MirTypes.print_tag excepts' ^
			  " but this time they were " ^ Lists.to_string MirTypes.print_tag excepts ^ ".")
	     | _ =>
		 (case old_block tag of
		    SOME opcodes =>
		      let
			val (new_block, defined, reached, stack') = block (excepts, opcodes)
			val map' = Map.define (map, tag, new_block)
		      in
			next (map',
                              stack orelse stack',
                              reached @@ rest)
		      end
		  | _ =>
		      crash ("Block " ^ MirTypes.print_tag tag ^
			     " has been reached but cannot be found in the original " ^
			     "procedure.")))

        (* Cause all reachable blocks to be processed by starting with the *)
        (* initial block reachable. *)

        val (map, stack) =
          next (Map.empty, false, [([], start_tag)])

      in

        P ({nr_registers = nr_registers,
            uses_stack = stack,
            parameters = parameters},
           name,start_tag, map)

      end



    (*  === UNANNOTATE ===
     *
     *  This is far simple than annotation.  It simply strips off the extra
     *  information.
     *
     *  NOTE: There is an extra hack here which looks for LEA instructions
     *  to nonexistent blocks and replaces them with safe MOVEs.  This is
     *  because the optimizer can throw away exception continuations but not
     *  the LEA which references them.  This should be fixed when a HANDLE
     *  directive is introduced - richard.
     *)

    fun unannotate (P({parameters, ...}, name, start_tag, block_map)) =
      let
        fun unannotate_block (tag, B(_, instructions)) =
          let
            local
              open MirTypes
            in
              fun unannotate_instruction (I {opcode = opcode as ADR (_, reg, tag),...}) =
                  (case Map.tryApply' (block_map, tag) of
                     SOME _ => opcode
                   | _ => UNARY (MOVE, reg, GP_IMM_ANY 0))
                | unannotate_instruction (I {opcode,...}) = opcode
            end
          in
            MirTypes.BLOCK(tag, map unannotate_instruction instructions)
          end
      in
        MirTypes.PROC(name,start_tag, parameters, map unannotate_block
		      (Map.to_list block_map),RuntimeEnv.EMPTY)
      end


    (*  === CONVERT ANNOTATED PROCEDURE TO PRINTABLE TEXT ===  *)

    fun to_text (P(annotation, name, start_tag, block_map)) =
      let
        nonfix ^^
        val ^^ = Text.concatenate
        val $ = Text.from_string
        infix ^^

        fun list printer (leader, []) = $""
          | list printer (leader, [t]) = leader ^^ $(printer t) ^^ $"\n"
          | list printer (leader, t::ts) =
            leader ^^
            Lists.reducel (fn (text, t) => $(printer t) ^^ $", " ^^ text) 
            ($(printer t), ts) ^^
            $"\n"

        val tags = list MirTypes.print_tag

        fun registers (leader, {gc, non_gc, fp}) =
          leader ^^ MirTypes.GC.Pack.to_text gc ^^
          $" " ^^ MirTypes.NonGC.Pack.to_text non_gc ^^
          $" " ^^ MirTypes.FP.Pack.to_text fp ^^
          $"\n"

        val header =
          $"Procedure " ^^ $(MirTypes.print_tag start_tag) ^^ $": " ^^ $name ^^ $"\n"

        fun block (text, tag, B(annotation, instructions)) =
          let
            val header =
              $"    Block " ^^ $(MirTypes.print_tag tag) ^^ $"\n" ^^
              tags      ($"      reached: ", Set.set_to_list (#reached annotation)) ^^
              tags      ($"      exceptions: ", #excepts annotation) ^^
                         $"      length: " ^^ $(Int.toString (#length annotation)) ^^ $"\n"

            fun opcode (text, I {defined,referenced,branches,excepts,opcode}) =
              let
                val trailer =
                  registers ($"          defined: ", defined) ^^
                  registers ($"          referenced: ", referenced) ^^
                  tags      ($"          branches: ", Set.set_to_list branches) ^^
                  tags	    ($"          exceptions: ", excepts) 
              in
                text ^^
                $"        " ^^ $(MirPrint.opcode opcode) ^^ $"\n" ^^
                trailer
              end
          in
            text ^^ Lists.reducel opcode (header, instructions)
          end
      in
        Map.fold block (header, block_map)
      end

  end
@


1.46.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a8 3
 * Revision 1.46  1997/01/15  13:00:26  matthew
 * Have tag list in tagged operations
 *
@


1.46.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a8 3
 * Revision 1.46  1997/01/15  13:00:26  matthew
 * Have tag list in tagged operations
 *
@


1.46.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a8 3
 * Revision 1.46  1997/01/15  13:00:26  matthew
 * Have tag list in tagged operations
 *
@


1.46.1.1
log
@branched from 1.46
@
text
@a8 3
 * Revision 1.46  1997/01/15  13:00:26  matthew
 * Have tag list in tagged operations
 *
@


1.46.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a8 3
 * Revision 1.46.1.1  1997/05/12  10:32:48  hope
 * branched from 1.46
 *
@


1.46.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a8 3
 * Revision 1.46.1.1  1997/05/12  10:32:48  hope
 * branched from 1.46
 *
@


1.46.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a8 3
 * Revision 1.46.1.1  1997/05/12  10:32:48  hope
 * branched from 1.46
 *
@


1.46.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a8 3
 * Revision 1.46.1.1.1.1  1997/07/28  18:17:44  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.45
log
@Removing references to MLWorks.Option
@
text
@d9 3
d327 6
a332 6
      fun branches (opcode as TBINARY (_, SOME tag, _, _, _)) =
          {next = true, branches = [tag], opcode = opcode}
        | branches (opcode as TBINARYFP (_, SOME tag, _, _, _)) =
          {next = true, branches = [tag], opcode = opcode}
        | branches (opcode as TUNARYFP (_, SOME tag, _, _)) =
          {next = true, branches = [tag], opcode = opcode}
d358 3
a360 3
	| raises (TBINARY (_, NONE,_,_,_)) = true
	| raises (TBINARYFP (_, NONE,_,_,_)) = true
	| raises (TUNARYFP (_, NONE,_,_)) = true
@


1.44
log
@[Bug #1728]
__integer becomes __int
@
text
@d9 4
d324 1
a324 1
      fun branches (opcode as TBINARY (_, MLWorks.Option.SOME tag, _, _, _)) =
d326 1
a326 1
        | branches (opcode as TBINARYFP (_, MLWorks.Option.SOME tag, _, _, _)) =
d328 1
a328 1
        | branches (opcode as TUNARYFP (_, MLWorks.Option.SOME tag, _, _)) =
d355 3
a357 3
	| raises (TBINARY (_, MLWorks.Option.NONE,_,_,_)) = true
	| raises (TBINARYFP (_, MLWorks.Option.NONE,_,_,_)) = true
	| raises (TUNARYFP (_, MLWorks.Option.NONE,_,_)) = true
d489 1
a489 1
	       MLWorks.Option.SOME (B ({excepts = excepts', ...}, _)) =>
d498 1
a498 1
		    MLWorks.Option.SOME opcodes =>
d550 1
a550 1
                     MLWorks.Option.SOME _ => opcode
@


1.44.4.1
log
@branched from 1.44
@
text
@a8 4
 * Revision 1.44  1996/11/06  11:08:27  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.3.1
log
@branched from 1.44
@
text
@a8 4
 * Revision 1.44  1996/11/06  11:08:27  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.3.1.1.1
log
@branched from 1.44.3.1
@
text
@a8 3
 * Revision 1.44.3.1  1996/12/17  17:46:28  hope
 * branched from 1.44
 *
@


1.44.2.1
log
@branched from 1.44
@
text
@a8 4
 * Revision 1.44  1996/11/06  11:08:27  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.1.1
log
@branched from 1.44
@
text
@a8 4
 * Revision 1.44  1996/11/06  11:08:27  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.1.1.1.1
log
@branched from 1.44.1.1
@
text
@a8 3
 * Revision 1.44.1.1  1996/11/14  12:47:43  hope
 * branched from 1.44
 *
@


1.43
log
@floor doesn't need to be in raises table
as it contains the handler reference in the instruction
@
text
@d9 4
d163 1
a163 1
require "../basis/__integer";
@


1.43.3.1
log
@branched from 1.43
@
text
@a8 4
 * Revision 1.43  1996/05/02  14:59:40  jont
 * floor doesn't need to be in raises table
 * as it contains the handler reference in the instruction
 *
@


1.43.2.1
log
@branched from 1.43
@
text
@a8 4
 * Revision 1.43  1996/05/02  14:59:40  jont
 * floor doesn't need to be in raises table
 * as it contains the handler reference in the instruction
 *
@


1.43.1.1
log
@branched from 1.43
@
text
@a8 4
 * Revision 1.43  1996/05/02  14:59:40  jont
 * floor doesn't need to be in raises table
 * as it contains the handler reference in the instruction
 *
@


1.42
log
@raises function didn't know call_c could raise
also didn't know floor could raise. Both added.
@
text
@d9 4
a350 1
	| raises (FLOOR _) = true
@


1.41
log
@Removing MLWorks.Integer
@
text
@d9 3
d346 2
@


1.40
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d9 4
d152 2
d581 1
a581 1
                         $"      length: " ^^ $(MLWorks.Integer.makestring (#length annotation)) ^^ $"\n"
@


1.39
log
@Removing call to xtime
@
text
@d9 3
a171 1
    structure Option = MirTypes.Option
d303 1
a303 1
      fun branches (opcode as TBINARY (_, Option.PRESENT tag, _, _, _)) =
d305 1
a305 1
        | branches (opcode as TBINARYFP (_, Option.PRESENT tag, _, _, _)) =
d307 1
a307 1
        | branches (opcode as TUNARYFP (_, Option.PRESENT tag, _, _)) =
d334 3
a336 3
	| raises (TBINARY (_, Option.ABSENT,_,_,_)) = true
	| raises (TBINARYFP (_, Option.ABSENT,_,_,_)) = true
	| raises (TUNARYFP (_, Option.ABSENT,_,_)) = true
@


1.38
log
@Use pervasive Option.option for return values in NewMap
@
text
@d9 3
a147 1
require "../utils/timer";
a160 1
  structure Timer	 : TIMER
a173 10
    val show_timings = ref false

    val ^^ = Diagnostic.Text.concatenate
    infix ^^
    val $ = Diagnostic.Text.from_string

    fun diagnostic (level, output_function) =
      Diagnostic.output_text level
      (fn verbosity => $"MirProcedure: " ^^ output_function verbosity)

a176 1
      
a262 1

d271 2
a272 3
            except	: MirTypes.tag list,
            side_effects: bool} *
           MirTypes.opcode
d352 1
a352 2
        val {nr_registers, substitute} =
          Timer.xtime ("register packing", !show_timings, fn () => RegisterPack.f procedure)
a381 10
                  (* No longer used -- MLA *)
(*
                  val leaf' =
                    case opcode'
                      of MirTypes.BRANCH_AND_LINK _ => false
                       | MirTypes.TAIL_CALL _ => false
                       | MirTypes.CALL_C => false
                       | MirTypes.RAISE _ => false
                       | _ => leaf
*)
d408 1
a408 1
                  val (except, reached'') =
d426 1
a426 1
                    I ({defined      = defined_here,
d429 2
a430 3
                        side_effects = MirTables.has_side_effects opcode'',
                        except       = except},
                       opcode'')
d524 1
a524 1
              fun unannotate_instruction (I(_, opcode as ADR (_, reg, tag))) =
d528 1
a528 1
                | unannotate_instruction (I(_, opcode)) = opcode
d575 1
a575 1
            fun opcode (text, I(annotation, opcode)) =
d578 4
a581 4
                  registers ($"          defined: ", #defined annotation) ^^
                  registers ($"          referenced: ", #referenced annotation) ^^
                  tags      ($"          branches: ", Set.set_to_list (#branches annotation)) ^^
                  tags	    ($"          exceptions: ", #except annotation) 
@


1.37
log
@Remove handler register concept
@
text
@d9 3
d489 1
a489 1
	       Map.YES(B ({excepts = excepts', ...}, _)) =>
d498 1
a498 1
		    Map.YES opcodes =>
d550 2
a551 2
                     Map.YES _ => opcode
                   | Map.NO => UNARY (MOVE, reg, GP_IMM_ANY 0))
@


1.36
log
@Abstraction of debug information
@
text
@d9 3
d405 1
a405 1
                      of MirTypes.NEW_HANDLER tag => tag::excepts
@


1.35
log
@Removed various unnecessary annotations
@
text
@d9 3
d165 1
a165 1
    structure RuntimeEnv = MirTypes.RuntimeEnv
@


1.34
log
@Add field to MirTypes.PROC_PARAMS.
@
text
@d9 3
d232 4
d242 20
a273 1
            exits	: bool,
d280 1
a280 8
            exits	: bool,
            length	: int,
            defined	: {gc     : MirTypes.GC.Pack.T,
                           non_gc : MirTypes.NonGC.Pack.T,
                           fp     : MirTypes.FP.Pack.T},
            referenced	: {gc     : MirTypes.GC.Pack.T,
                           non_gc : MirTypes.NonGC.Pack.T,
                           fp     : MirTypes.FP.Pack.T}} *
d284 1
a284 2
      P of {exits	 : MirTypes.tag Set.Set,
            uses_stack	 : bool,
a285 3
            registers    : {gc     : MirTypes.GC.Pack.T,
                            non_gc : MirTypes.NonGC.Pack.T,
                            fp     : MirTypes.FP.Pack.T},
d295 1
a295 2
     *  is reached, another indicating whether the instruction _definitely_
     *  exits the procedure, and a possibly optimised opcode.
a296 4
     *  Note: TAIL calls to a tag are treated as procedure exits because the
     *  tag may be to another procedure in a recursive set.  It may be
     *  better to detect this case and treat it specially.
     *
d305 1
a305 1
          {next = true, exits = false, branches = [tag], opcode = opcode}
d307 1
a307 1
          {next = true, exits = false, branches = [tag], opcode = opcode}
d309 1
a309 1
          {next = true, exits = false, branches = [tag], opcode = opcode}
d311 1
a311 1
          {next = false, exits = false, branches = [tag], opcode = opcode}
d313 1
a313 1
          {next = false, exits = true, branches = [], opcode = opcode}
d315 1
a315 1
          {next = true, exits = false, branches = [tag], opcode = opcode}
d317 1
a317 1
          {next = true, exits = false, branches = [tag], opcode = opcode}
d319 1
a319 1
          {next = false, exits = true, branches = [], opcode = opcode}
d321 1
a321 1
          {next = false, exits = false, branches = tags, opcode = BRANCH(BRA, TAG tag)}
d323 1
a323 1
          {next = false, exits = false, branches = tags, opcode = opcode}
d325 1
a325 1
          {next = false, exits = true, branches = [], opcode = opcode}
d327 1
a327 1
          {next = false, exits = false, branches = [], opcode = opcode}
d329 1
a329 1
          {next = true, exits = false, branches = [tag], opcode = opcode}
d331 1
a331 1
          {next = true, exits = false, branches = [], opcode = opcode}
d373 1
a373 2
         *  booleans indicating whether the procedure could be exited in this
         *  block, whether there were any non-leaf instructions, and whether
d379 3
a381 3
            fun block' (done, defined, referenced, length, reached, exit, stack, leaf, _, []) =
                (rev done, defined, referenced, length, reached, exit, stack, leaf)
              | block' (done, defined, referenced, length, reached, exit, stack, leaf, excepts, opcode::opcodes) =
d386 2
d395 1
a395 1

d416 1
a416 1
                  val {next, exits, branches, opcode = opcode''} = branches opcode'
a417 1
                  val exit' = exit orelse exits
d422 1
a422 1
                  val (except, reached'', exit'') =
d425 3
a427 3
                        fun reach (reached, exit, []) = (reached, exit)
                          | reach (reached, exit, excepts as cont::conts) =
                            reach ((excepts, cont)::reached, exit', conts)
d429 1
a429 1
                        val (reached'', exit'') = reach (reached', true, excepts)
d431 1
a431 1
                        (excepts, reached'', exit'')
d434 1
a434 1
                      ([], reached', exit')
a442 1
                        exits	     = exits,
a448 1
                          union' (referenced, referenced_here),
a450 1
                          exit'',
a451 1
                          leaf',
d456 2
a457 2
            val (instructions, defined, referenced, length, reached, exits, stack, leaf) =
              block' ([], empty, empty, 0, [], false, false, true, excepts, opcodes)
a459 1
                 exits = exits,
d461 2
a462 3
                 excepts = excepts,
                 defined = defined,
                 referenced = referenced}, instructions),
d465 1
a465 3
             exits,
             stack,
             leaf)
d477 2
a478 2
        fun next (map, registers, exit_blocks, stack, leaf, []) = (map, registers, exit_blocks, stack, leaf)
          | next (map, registers, exit_blocks, stack, leaf, (excepts, tag)::rest) =
d482 1
a482 1
		   next (map, registers, exit_blocks, stack, leaf, rest)
d491 1
a491 1
			val (new_block, defined, reached, exits, stack', leaf') = block (excepts, opcodes)
d495 2
a496 5
			      union' (registers, defined),
			      if exits then tag::exit_blocks else exit_blocks,
				stack orelse stack',
				leaf andalso leaf',
				reached @@ rest)
d506 2
a507 14
        val (map, registers, exit_blocks, stack, leaf) =
          next (Map.empty, empty, [], false, true, [([], start_tag)])

        val parameters' =
          let
            val MirTypes.PROC_PARAMS {registers_used, spill_sizes,
                                      stack_allocated, loop_entry, ...} = parameters
          in
            MirTypes.PROC_PARAMS {leaf = leaf,
                                  registers_used = registers_used,
                                  spill_sizes = spill_sizes,
                                  stack_allocated = stack_allocated,
                                  loop_entry = loop_entry}
          end
d511 1
a511 3
        P ({exits = Set.list_to_set(exit_blocks),
            nr_registers = nr_registers,
            registers = registers,
d513 1
a513 1
            parameters = parameters'},
a553 1

d556 1
a556 1
    fun to_text (P(annotation, name,start_tag, block_map)) =
d580 1
a580 2
          $"Procedure " ^^ $(MirTypes.print_tag start_tag) ^^ $": " ^^ $name ^^ $"\n" ^^
          tags ($"  exits: ", Set.set_to_list (#exits annotation))
d588 1
a588 5
                         $"      length: " ^^ $(MLWorks.Integer.makestring (#length annotation)) ^^ $"\n" ^^
              (if #exits annotation then
                 $"      exits\n"
               else
                 $"")
d596 1
a596 5
                  tags	    ($"          exceptions: ", #except annotation) ^^
                  (if #exits annotation then
                     $"          exits\n"
                   else
                     $"")
@


1.33
log
@Adding load offset instruction
@
text
@d9 3
d512 2
a513 1
            val MirTypes.PROC_PARAMS {registers_used, spill_sizes, stack_allocated, ...} = parameters
d518 2
a519 1
                                  stack_allocated = stack_allocated}
@


1.32
log
@checkout -com MLWharp _mirprocedure.sml -and -com MLWsparc _pervasives.sml
Fix handling of trapping operations.
@
text
@d9 4
d549 1
a549 1
              fun unannotate_instruction (I(_, opcode as ADR (LEA, reg, tag))) =
@


1.31
log
@Removed unnecessary exceptions from closures.
@
text
@d9 3
d318 3
@


1.30
log
@Merging in structure simplification.
@
text
@d9 3
d284 1
a284 1
      fun branches (opcode as TBINARY (_, tag, _, _, _)) =
d286 1
a286 1
        | branches (opcode as TBINARYFP (_, tag, _, _, _)) =
d288 1
a288 1
        | branches (opcode as TUNARYFP (_, tag, _, _)) =
@


1.29
log
@Changed the annotation of raise instructions to model the fact that
the raise might reach _any_ of the nexted continuation blocks.
@
text
@d9 10
d143 1
a143 1
    structure Option = MirTables.Option
@


1.29.1.1
log
@Fork for bug fixing
@
text
@a8 4
 *  Revision 1.29  1993/08/17  11:55:31  richard
 *  Changed the annotation of raise instructions to model the fact that
 *  the raise might reach _any_ of the nexted continuation blocks.
 *
@


1.29.1.2
log
@Removed unused substructures of MirTables
@
text
@a8 3
 *  Revision 1.29.1.1  1993/08/17  11:55:31  jont
 *  Fork for bug fixing
 *
d137 1
a137 1
    structure Option = MirTypes.Option
@


1.28
log
@Added a hack to remove LEA instructions which reference nonexistent
blocks.
@
text
@d9 4
d223 1
a223 1
            except	: MirTypes.tag Option.opt,
d383 3
a385 1
                  (* Find out if the opcode might raise an exception. *)
d388 9
a396 3
                      case excepts
                        of top::_ => (Option.PRESENT top, (excepts', top)::reached', exit')
                         | []     => (Option.ABSENT, reached', true)
d398 1
a398 1
                      (Option.ABSENT, reached', exit')
a584 4
                val excepts =
                  case #except annotation
                    of Option.PRESENT e => [e]
                     | Option.ABSENT => []
d589 1
a589 1
                  tags	    ($"          exceptions: ", excepts ) ^^
@


1.27
log
@Debugger Environments for local and closure variable inspection
in the debugger;
changed Option.T to Option.opt.
@
text
@d9 5
a297 1
        | raises (ADR _) = true			(* *** SEE BELOW *** *)
a299 4
      (* ADR is currently marked as raising an exception in order to prevent *)
      (* the loss of exception continuation blocks under any circumstances. *)
      (* This should be fixed when the HANDLE directive is introduced, when *)
      (* the optimiser should throw away HANDLE/continuation pairs. *)
d499 6
d511 9
a519 1
            fun unannotate_instruction (I(_, opcode)) = opcode
@


1.26
log
@Removed Integer parameter
@
text
@d9 3
d127 1
d214 1
a214 1
            except	: MirTypes.tag Option.T,
d313 1
a313 1
    fun annotate (procedure as MirTypes.PROC (name,start_tag, parameters, block_list)) =
d511 1
a511 1
		      (Map.to_list block_map))
@


1.25
log
@The PROFILER instruction has been removed.  It's replacement,
INTERCEPT, does not force a function to be non-leaf.
@
text
@d9 4
a97 1
require "../utils/integer";
a111 1
  structure Integer	 : INTEGER
d547 1
a547 1
                         $"      length: " ^^ $(Integer.makestring (#length annotation)) ^^ $"\n" ^^
@


1.24
log
@changed Map substructure now MirTypes.Map
Signature revisions
@
text
@d9 4
a345 1
                       | MirTypes.PROFILER _ => false
@


1.23
log
@Changed handle Map.Undefined constructs for case statements thus
allowing tail recursion to work proprely
@
text
@d9 4
d113 1
a113 1
    structure Map = MirTypes.Debugger_Types.Datatypes.NewMap
d230 1
a230 1
           string * MirTypes.tag * (block) MirTypes.Map.T
d313 3
a315 3
			  MirTypes.Map.define(res, x, y))
	   (MirTypes.Map.empty, block_list))
        fun old_block x = MirTypes.Map.tryApply'(old_block_map, x)
d430 2
a431 2
	    (case MirTypes.Map.tryApply'(map, tag) of
	       MirTypes.Map.YES(B ({excepts = excepts', ...}, _)) =>
d440 1
a440 1
		    MirTypes.Map.YES opcodes =>
d443 1
a443 1
			val map' = MirTypes.Map.define (map, tag, new_block)
d461 1
a461 1
          next (MirTypes.Map.empty, empty, [], false, true, [([], start_tag)])
d502 1
a502 1
		      (MirTypes.Map.to_list block_map))
d572 1
a572 1
        MirTypes.Map.fold block (header, block_map)
@


1.22
log
@Efficiency changes to use mononewmap for registers and tags
@
text
@d9 3
d307 1
a307 2
        val old_block =
          MirTypes.Map.apply
d311 1
d426 26
a451 26
            let
              val B ({excepts = excepts', ...}, _) = MirTypes.Map.apply map tag
            in
              if excepts = excepts' then
                next (map, registers, exit_blocks, stack, leaf, rest)
              else
                crash ("Block " ^ MirTypes.print_tag tag ^ " has been reached with inconsistent exception blocks.  " ^
                       "The first time round they were " ^ Lists.to_string MirTypes.print_tag excepts' ^
                       " but this time they were " ^ Lists.to_string MirTypes.print_tag excepts ^ ".")
            end
            handle MirTypes.Map.Undefined =>
              let
                val opcodes = old_block tag
                val (new_block, defined, reached, exits, stack', leaf') = block (excepts, opcodes)
                val map' = MirTypes.Map.define (map, tag, new_block)
              in
                next (map',
                      union' (registers, defined),
                      if exits then tag::exit_blocks else exit_blocks,
                      stack orelse stack',
                      leaf andalso leaf',
                      reached @@ rest)
              end
              handle MirTypes.Map.Undefined =>
                crash ("Block " ^ MirTypes.print_tag tag ^ " has been reached but cannot be found in the original " ^
                       "procedure.")
@


1.21
log
@Removed some unncesessary intermediate lists which
were being built.
@
text
@d9 4
d223 1
a223 1
           string * MirTypes.tag * (MirTypes.tag, block) Map.T
d305 4
a308 3
          Map.apply
	  (Lists.reducel (fn (res, MirTypes.BLOCK(x,y)) => Map.define(res, x, y))
	   (Map.empty' MirTypes.order_tag, block_list))
d424 1
a424 1
              val B ({excepts = excepts', ...}, _) = Map.apply map tag
d433 1
a433 1
            handle Map.Undefined =>
d437 1
a437 1
                val map' = Map.define (map, tag, new_block)
d446 1
a446 1
              handle Map.Undefined =>
d454 1
a454 1
          next (Map.empty' MirTypes.order_tag, empty, [], false, true, [([], start_tag)])
d494 2
a495 1
        MirTypes.PROC(name,start_tag, parameters, map unannotate_block (Map.to_list block_map))
a527 3
(*
        val blocks = Map.to_list block_map
*)
d565 1
a565 1
        Map.fold block (header, block_map)
@


1.20
log
@Removed some redundant structures and sharing
@
text
@d9 3
d299 1
d301 3
a303 1
          Map.apply (Map.from_list' MirTypes.order_tag (map (fn MirTypes.BLOCK p => p) block_list))
@


1.19
log
@Removed various uses of NewMap.to_list in favour of fold and union
@
text
@d9 3
a72 3

require "../utils/newmap";
require "../utils/set";
a74 1
require "../utils/option";
a75 1
require "../utils/text";
a80 1
require "mirtypes";
a84 3

  structure Map		 : NEWMAP
  structure Set		 : SET
a86 2
  structure Option	 : OPTION
  structure MirTypes	 : MIRTYPES
a90 1
  structure Text	 : TEXT		(* Not necessarily Diagnostic.Text *)
d94 1
a94 4
  sharing MirTypes = MirTables.MirTypes = MirPrint.MirTypes = RegisterPack.MirTypes
  sharing Set = MirTables.Set = MirTypes.Set
  sharing Text = MirTypes.Text

d98 4
a101 5

    structure MirTypes = MirTypes
    structure Map = Map
    structure Set = Set
    structure Option = Option
d103 1
a103 1
    structure Text = Text
@


1.18
log
@Temporary fix to prevent exception continuation blocks disappearing.
@
text
@d9 3
d529 1
d531 1
d533 1
a533 1
        fun block (text, (tag, B(annotation, instructions))) =
d569 1
a569 1
        Lists.reducel block (header, blocks)
@


1.17
log
@Added parameter to RAISE once again.
@
text
@d9 3
d279 1
d281 5
@


1.16
log
@Added show_timings.
@
text
@d9 3
d267 1
a267 1
        | branches (opcode as RAISE) =
d274 1
a274 1
      fun raises RAISE = true
d326 1
a326 1
                       | MirTypes.RAISE => false
@


1.15
log
@Added total registers used as an annotation on procedures.
@
text
@d9 3
d70 1
d92 1
d109 1
d289 2
a290 1
        val {nr_registers, substitute} = RegisterPack.f procedure
@


1.14
log
@Added copy' and changed is_empty to take advantage of new
functions in MONOSET signature.
@
text
@d9 4
d177 3
d207 2
a208 2
      P of {exits	: MirTypes.tag Set.Set,
            uses_stack	: bool,
d210 4
a213 1
            parameters  : MirTypes.procedure_parameters} *
d385 1
d401 2
a402 2
        fun next (map, exit_blocks, stack, leaf, []) = (map, exit_blocks, stack, leaf)
          | next (map, exit_blocks, stack, leaf, (excepts, tag)::rest) =
d407 1
a407 1
                next (map, exit_blocks, stack, leaf, rest)
d416 1
a416 1
                val (new_block, reached, exits, stack', leaf') = block (excepts, opcodes)
d420 1
d433 2
a434 2
        val (map, exit_blocks, stack, leaf) =
          next (Map.empty' MirTypes.order_tag, [], false, true, [([], start_tag)])
d450 1
@


1.13
log
@Changed virtual register Sets to Packs.
Added mutating union, intersection, etc.
Added RegisterPack invocation.
Utilized mutable set operations to provide block-wise packs of
defined and referenced registers.
@
text
@d9 7
d158 5
d168 3
a170 3
      MirTypes.GC.Pack.equal (gc, MirTypes.GC.Pack.empty) andalso
      MirTypes.NonGC.Pack.equal (non_gc, MirTypes.NonGC.Pack.empty) andalso
      MirTypes.FP.Pack.equal (fp, MirTypes.FP.Pack.empty)
@


1.12
log
@Moved set operations on triples of register sets to here.
Corrected print routine slightly.
@
text
@d9 4
d56 1
d65 12
a76 11
  structure Map		: NEWMAP
  structure Set		: SET
  structure Lists	: LISTS
  structure Crash	: CRASH                      
  structure Option	: OPTION
  structure MirTypes	: MIRTYPES
  structure MirTables	: MIRTABLES
  structure MirPrint	: MIRPRINT
  structure Diagnostic	: DIAGNOSTIC
  structure Text	: TEXT		(* Not necessarily Diagnostic.Text *)
  structure Integer	: INTEGER
d78 1
a78 1
  sharing MirTypes = MirTables.MirTypes = MirPrint.MirTypes
d93 12
d107 8
a114 3
      {gc     = MirTypes.GC.Set.union (gc, gc'),
       non_gc = MirTypes.NonGC.Set.union (non_gc, non_gc'),
       fp     = MirTypes.FP.Set.union (fp, fp')}
d117 8
a124 3
      {gc     = MirTypes.GC.Set.intersection (gc, gc'),
       non_gc = MirTypes.NonGC.Set.intersection (non_gc, non_gc'),
       fp     = MirTypes.FP.Set.intersection (fp, fp')}
d127 8
a134 3
      {gc     = MirTypes.GC.Set.difference (gc, gc'),
       non_gc = MirTypes.NonGC.Set.difference (non_gc, non_gc'),
       fp     = MirTypes.FP.Set.difference (fp, fp')}
d137 17
a153 7
      MirTypes.GC.Set.equal (gc, gc') andalso
      MirTypes.NonGC.Set.equal (non_gc, non_gc') andalso
      MirTypes.FP.Set.equal (fp, fp')

    val empty = {gc = MirTypes.GC.Set.empty,
                 non_gc = MirTypes.NonGC.Set.empty,
                 fp = MirTypes.FP.Set.empty}
d156 3
a158 3
      MirTypes.GC.Set.equal (gc, MirTypes.GC.Set.empty) andalso
      MirTypes.NonGC.Set.equal (non_gc, MirTypes.NonGC.Set.empty) andalso
      MirTypes.FP.Set.equal (fp, MirTypes.FP.Set.empty)
d162 6
a167 6
      I of {defined	: {gc     : MirTypes.GC.Set.T,
                           non_gc : MirTypes.NonGC.Set.T,
                           fp     : MirTypes.FP.Set.T},
            referenced	: {gc     : MirTypes.GC.Set.T,
                           non_gc : MirTypes.NonGC.Set.T,
                           fp     : MirTypes.FP.Set.T},
d178 7
a184 1
            length	: int} *
d190 1
a194 31
    val ^^ = Diagnostic.Text.concatenate
    infix ^^
    val $ = Diagnostic.Text.from_string

    fun diagnostic (level, output_function) =
      Diagnostic.output_text level
      (fn verbosity => $"MirProcedure: " ^^ output_function verbosity)

    fun crash message =
      Crash.impossible ("MirProcedure: " ^ message)


    fun order (op<) (x,y) =
      if x=y then Map.EQUAL
      else if x<y then Map.LESS
           else Map.GREATER

    fun partition set =
      let
        open MirTypes
        fun part ({gc, non_gc, fp}, GC reg) =
            {gc = GC.Set.add (gc, reg), non_gc = non_gc, fp = fp}
          | part ({gc, non_gc, fp}, NON_GC reg) =
            {gc = gc, non_gc = NonGC.Set.add (non_gc, reg), fp = fp}
          | part ({gc, non_gc, fp}, FLOAT reg) =
            {gc = gc, non_gc = non_gc, fp = FP.Set.add (fp, reg)}
      in
        Lists.reducel part ({gc = GC.Set.empty, non_gc = NonGC.Set.empty, fp = FP.Set.empty}, Set.set_to_list set)
      end


a248 16
    fun union ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Set.union (gc, gc'),
       non_gc = MirTypes.NonGC.Set.union (non_gc, non_gc'),
       fp     = MirTypes.FP.Set.union (fp, fp')}

    fun difference ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Set.difference (gc, gc'),
       non_gc = MirTypes.NonGC.Set.difference (non_gc, non_gc'),
       fp     = MirTypes.FP.Set.difference (fp, fp')}

    val empty_sets = {gc = MirTypes.GC.Set.empty,
                      non_gc = MirTypes.NonGC.Set.empty,
                      fp = MirTypes.FP.Set.empty}



d259 1
a259 1
    fun annotate (MirTypes.PROC (name,start_tag, parameters, block_list)) =
d261 2
d266 1
a266 1
          Map.apply (Map.from_list (order MirTypes.order_tag) (map (fn MirTypes.BLOCK p => p) block_list))
d281 3
a283 3
            fun block' (done, length, reached, exit, stack, leaf, _, []) =
                (rev done, length, reached, exit, stack, leaf)
              | block' (done, length, reached, exit, stack, leaf, excepts, opcode::opcodes) =
d286 2
d289 1
a289 1
                    case opcode
d299 1
a299 1
                    case opcode
d310 1
a310 1
                    case opcode
d317 1
a317 1
                  val {next, exits, branches, opcode = opcode'} = branches opcode
d323 1
a323 1
                    if raises opcode' then
d331 2
a332 2
                  val defined_here = partition (MirTables.defined_by opcode')
                  val referenced_here = partition (MirTables.referenced_by opcode')
d338 1
a338 1
                        side_effects = MirTables.has_side_effects opcode',
d340 1
a340 1
                       opcode')
d343 3
a345 1
                          case opcode' of MirTypes.COMMENT _ => length | _ => length+1,
d354 2
a355 2
            val (instructions, length, reached, exits, stack, leaf) =
              block' ([], 0, [], false, false, true, excepts, opcodes)
d360 3
a362 1
                 excepts = excepts}, instructions),
d410 1
a410 1
          next (Map.empty (order MirTypes.order_tag), [], false, true, [([], start_tag)])
d425 1
d474 3
a476 4
          leader ^^
          $"GCs: "     ^^ MirTypes.GC.Set.to_text gc ^^
          $" NonGCs: " ^^ MirTypes.NonGC.Set.to_text non_gc ^^
          $" FPs: "    ^^ MirTypes.FP.Set.to_text fp ^^
@


1.11
log
@Added calculation of leaf procedure flag.
@
text
@d9 3
d88 30
d469 1
a469 1
          $"Procedure " ^^ $ name ^^ $(MirTypes.print_tag start_tag) ^^ $"\n" ^^
d479 1
a479 1
                         $"      length: " ^^ $(Integer.makestring (#length annotation)) ^^
@


1.10
log
@Removed block-wise defined and referenced annotations as they were
taking far too long to calculate.  This also removes the `first'
annotation from instructions, but it wasn't used anyway.
@
text
@d237 2
a238 1
         *  block and whether the block uses stack.
d243 3
a245 3
            fun block' (done, length, reached, exit, stack, _, []) =
                (rev done, length, reached, exit, stack)
              | block' (done, length, reached, exit, stack, excepts, opcode::opcodes) =
d248 10
a257 1
                  (* Add or remove exceptions from the exception stack. *)
d307 1
d312 2
a313 2
            val (instructions, length, reached, exits, stack) =
              block' ([], 0, [], false, false, excepts, opcodes)
d321 2
a322 1
             stack)
d334 2
a335 2
        fun next (map, exit_blocks, stack, []) = (map, exit_blocks, stack)
          | next (map, exit_blocks, stack, (excepts, tag)::rest) =
d340 1
a340 1
                next (map, exit_blocks, stack, rest)
d349 1
a349 1
                val (new_block, reached, exits, stack') = block (excepts, opcodes)
d352 5
a356 1
                next (map', if exits then tag::exit_blocks else exit_blocks, stack orelse stack', reached @@ rest)
d365 12
a376 1
        val (map, exit_blocks, stack) = next (Map.empty (order MirTypes.order_tag), [], false, [([], start_tag)])
d382 1
a382 1
            parameters = parameters},
@


1.9
log
@Added register annotations to blocks and `first definition' annotation to
instructions.
@
text
@d9 4
a91 3
            first	: {gc     : MirTypes.GC.Set.T,
                           non_gc : MirTypes.NonGC.Set.T,
                           fp     : MirTypes.FP.Set.T},
d102 1
a102 7
            length	: int,
	    defined	: {gc     : MirTypes.GC.Set.T,
                           non_gc : MirTypes.NonGC.Set.T,
                           fp     : MirTypes.FP.Set.T},
            referenced	: {gc     : MirTypes.GC.Set.T,
                           non_gc : MirTypes.NonGC.Set.T,
                           fp     : MirTypes.FP.Set.T}} *
d242 3
a244 3
            fun block' (done, length, defined, referenced, reached, exit, stack, _, []) =
                (rev done, length, defined, referenced, reached, exit, stack)
              | block' (done, length, defined, referenced, reached, exit, stack, excepts, opcode::opcodes) =
a285 1
                        first        = difference (defined_here, defined),
a293 2
                          union (defined, defined_here),
                          union (referenced, referenced_here),
d301 2
a302 2
            val (instructions, length, defined, referenced, reached, exits, stack) =
              block' ([], 0, empty_sets, empty_sets, [], false, false, excepts, opcodes)
a304 2
                 defined = defined,
                 referenced = referenced,
a416 2
              registers ($"      defined: ", #defined annotation) ^^
              registers ($"      referenced: ", #referenced annotation) ^^
a433 1
                  registers ($"          first: ", #first annotation) ^^
@


1.8
log
@Added require "text"
@
text
@d9 3
d44 1
d63 1
d88 3
d100 8
a107 1
            exits	: bool} *
d202 16
d247 3
a249 2
            fun block' (done, reached, exit, stack, _, []) = (rev done, reached, exit, stack)
              | block' (done, reached, exit, stack, excepts, opcode::opcodes) =
d286 2
d289 3
a291 2
                    I ({referenced   = partition (MirTables.referenced_by opcode'),
                        defined      = partition (MirTables.defined_by opcode'),
d299 3
d309 2
a310 1
            val (instructions, reached, exits, stack) = block' ([], [], false, false, excepts, opcodes)
d312 6
a317 1
            (B ({reached = Set.list_to_set (map #2 reached), exits = exits, excepts = excepts}, instructions),
d427 5
a431 2
              tags ($"      reached: ", Set.set_to_list (#reached annotation)) ^^
              tags ($"      exceptions: ", #excepts annotation) ^^
d446 1
@


1.7
log
@First version of the profiler
@
text
@d9 3
d40 1
@


1.6
log
@Added uses_stack annotation.
@
text
@d9 3
d95 1
a95 1
           MirTypes.tag * (MirTypes.tag, block) Map.T
d193 1
a193 1
    fun annotate (MirTypes.PROC (start_tag, parameters, block_list)) =
d318 1
a318 1
           start_tag, map)
d330 1
a330 1
    fun unannotate (P({parameters, ...}, start_tag, block_map)) =
d339 1
a339 1
        MirTypes.PROC(start_tag, parameters, map unannotate_block (Map.to_list block_map))
d346 1
a346 1
    fun to_text (P(annotation, start_tag, block_map)) =
d371 1
a371 1
          $"Procedure " ^^ $(MirTypes.print_tag start_tag) ^^ $"\n" ^^
@


1.5
log
@Added side_effects annotation to instructions.
@
text
@d9 3
d90 1
d202 3
a204 3
         *  block stack active at the time of branching.  It also returns a
         *  boolean indicating whether the procedure could be exited in this
         *  block.
d209 2
a210 2
            fun block' (done, reached, exit, _, []) = (rev done, reached, exit)
              | block' (done, reached, exit, excepts, opcode::opcodes) =
d224 8
d259 1
d264 1
a264 1
            val (instructions, reached, exits) = block' ([], [], false, excepts, opcodes)
d268 2
a269 1
             exits)
d281 2
a282 2
        fun next (map, exit_blocks, []) = (map, exit_blocks)
          | next (map, exit_blocks, (excepts, tag)::rest) =
d287 1
a287 1
                next (map, exit_blocks, rest)
d296 1
a296 1
                val (new_block, reached, exits) = block (excepts, opcodes)
d299 1
a299 1
                next (map', if exits then tag::exit_blocks else exit_blocks, reached @@ rest)
d308 1
a308 1
        val (map, exit_blocks) = next (Map.empty (order MirTypes.order_tag), [], [([], start_tag)])
d313 1
@


1.4
log
@Annotation no longer traces TAIL_CALLs even when the tag is explicit
since they may leave the procedure.
@
text
@d9 4
d75 2
a76 1
            exits	: bool} *
d236 6
a241 5
                    I ({referenced = partition (MirTables.referenced_by opcode'),
                        defined    = partition (MirTables.defined_by opcode'),
                        branches   = Set.list_to_set branches,
                        exits	   = exits,
                        except     = except},
@


1.3
log
@Added missing branch case for FLOOR instructions.
@
text
@d9 3
d125 4
d150 1
a150 3
        | branches (opcode as TAIL_CALL (_, TAG tag)) =
          {next = false, exits = false, branches = [tag], opcode = BRANCH(BRA, TAG tag)}
        | branches (opcode as TAIL_CALL (_, REG _)) =
d296 20
@


1.2
log
@Changed the way virtual registers are handled.  See MirTypes.
@
text
@d9 3
d155 2
@


1.1
log
@Initial revision
@
text
@d8 4
a11 1
 *  $Log$
d41 2
a42 1
  sharing Set = MirTables.Set
d57 6
a62 2
      I of {defined	: MirTypes.any_register Set.Set,
            referenced	: MirTypes.any_register Set.Set,
d75 2
a76 1
      P of {exits	: MirTypes.tag Set.Set} *
d97 12
d110 2
d221 2
a222 2
                    I ({referenced = MirTables.referenced_by opcode',
                        defined    = MirTables.defined_by opcode',
d282 2
a283 1
        P ({exits = Set.list_to_set(exit_blocks)},
a307 1
        val registers = list MirPrint.any_reg
d309 7
d339 2
a340 2
                  registers ($"          defined: ", Set.set_to_list (#defined annotation)) ^^
                  registers ($"          referenced: ", Set.set_to_list (#referenced annotation)) ^^
@
