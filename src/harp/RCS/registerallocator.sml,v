head	1.22;
access;
symbols
	MLW_daveb_inline_1_4_99:1.22.11
	MLWorks_21c0_1999_03_25:1.22
	MLWorks_20c1_1998_08_20:1.22
	MLWorks_20c0_1998_08_04:1.22
	MLWorks_20b2c2_1998_06_19:1.22
	MLWorks_20b2_Windows_1998_06_12:1.22
	MLWorks_20b1c1_1998_05_07:1.22
	MLWorks_20b0_1998_04_07:1.22
	MLWorks_20b0_1998_03_20:1.22
	MLWorks_20m2_1998_02_16:1.22
	MLWorks_20m1_1997_10_23:1.22
	MLWorks_11r1:1.22.8.1.1.1.1
	MLWorks_workspace_97:1.22.10
	MLWorks_dt_wizard:1.22.9
	MLWorks_11c0_1997_09_09:1.22.8.1.1.1
	MLWorks_10r3:1.22.8.1.3
	MLWorks_10r2_551:1.22.8.1.2
	MLWorks_11:1.22.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.22.8.1
	MLWorks_20m0_1997_06_20:1.22
	MLWorks_1_0_r2c2_1997_06_14:1.22.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.22.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.22.8
	MLWorks_BugFix_1997_04_24:1.22
	MLWorks_1_0_r2_Win32_1997_04_11:1.22
	MLWorks_1_0_r2_Unix_1997_04_04:1.22
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.22.6.1.1
	MLWorks_gui_1996_12_18:1.22.7
	MLWorks_1_0_Win32_1996_12_17:1.22.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.22.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.22.4.1
	MLWorks_1_0_Irix_1996_11_28:1.22.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.22.5
	MLWorks_1_0_Unix_1996_11_14:1.22.4
	MLWorks_Open_Beta2_1996_10_11:1.22.3
	MLWorks_License_dev:1.22.2
	MLWorks_1_open_beta_1996_09_13:1.22.1
	MLWorks_Open_Beta_1996_08_22:1.22
	MLWorks_Beta_1996_07_02:1.22
	MLWorks_Beta_1996_06_07:1.22
	MLWorks_Beta_1996_06_06:1.22
	MLWorks_Beta_1996_06_05:1.22
	MLWorks_Beta_1996_06_03:1.22
	MLWorks_Beta_1996_05_31:1.22
	MLWorks_Beta_1996_05_30:1.22
	ML_beta_release_12/08/94:1.21
	ML_beta_release_03/08/94:1.21
	ML_revised_beta_release_25/05/94:1.21
	ML_final_beta_release_02/03/94:1.21
	mlworks-28-01-1994:1.21
	Release:1.21
	mlworks-beta-01-09-1993:1.21
	MLWorks-1-0-4-29/01/1993:1.20
	MLWorks-1-0-3-21/12/1992:1.20
	MLWorks-1-0-2-15/12/1992:1.20
	MLWorks-1-0-1-04/12/1992:1.19
	checkpoint_17_08_92:1.19;
locks; strict;
comment	@ * @;


1.22
date	95.05.30.11.41.04;	author matthew;	state Exp;
branches
	1.22.1.1
	1.22.2.1
	1.22.3.1
	1.22.4.1
	1.22.5.1
	1.22.6.1
	1.22.7.1
	1.22.8.1
	1.22.9.1
	1.22.10.1
	1.22.11.1;
next	1.21;

1.21
date	93.02.22.16.27.32;	author nosa;	state Exp;
branches
	1.21.1.1;
next	1.20;

1.20
date	92.12.08.19.47.54;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.06.17.10.08.54;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	92.06.11.10.33.31;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	92.06.03.16.40.47;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	92.05.27.13.36.59;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.04.29.13.38.23;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	92.04.16.13.08.59;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	92.04.09.16.01.12;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	92.03.05.11.39.52;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	92.02.27.17.13.01;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	92.02.13.11.00.49;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	92.02.07.14.29.38;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	91.11.25.11.11.01;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	91.11.19.15.37.31;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.10.17.12.37.50;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	91.10.15.13.28.32;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	91.10.07.11.53.41;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.10.04.11.24.40;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.10.03.15.28.01;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	91.09.27.15.01.26;	author richard;	state Exp;
branches;
next	;

1.21.1.1
date	93.02.22.16.27.32;	author jont;	state Exp;
branches;
next	;

1.22.1.1
date	96.09.13.11.14.09;	author hope;	state Exp;
branches;
next	;

1.22.2.1
date	96.10.07.16.04.38;	author hope;	state Exp;
branches;
next	;

1.22.3.1
date	96.10.17.11.22.52;	author hope;	state Exp;
branches;
next	;

1.22.4.1
date	96.11.14.12.47.06;	author hope;	state Exp;
branches
	1.22.4.1.1.1;
next	;

1.22.4.1.1.1
date	96.11.28.14.58.43;	author hope;	state Exp;
branches;
next	;

1.22.5.1
date	96.11.22.18.07.13;	author hope;	state Exp;
branches;
next	;

1.22.6.1
date	96.12.17.17.45.57;	author hope;	state Exp;
branches
	1.22.6.1.1.1;
next	;

1.22.6.1.1.1
date	97.02.24.11.35.30;	author hope;	state Exp;
branches;
next	;

1.22.7.1
date	96.12.18.09.39.56;	author hope;	state Exp;
branches;
next	;

1.22.8.1
date	97.05.12.10.32.16;	author hope;	state Exp;
branches
	1.22.8.1.1.1
	1.22.8.1.2.1
	1.22.8.1.3.1;
next	;

1.22.8.1.1.1
date	97.07.28.18.18.02;	author daveb;	state Exp;
branches
	1.22.8.1.1.1.1.1;
next	;

1.22.8.1.1.1.1.1
date	97.10.07.11.42.59;	author jkbrook;	state Exp;
branches;
next	;

1.22.8.1.2.1
date	97.09.08.17.11.35;	author daveb;	state Exp;
branches;
next	;

1.22.8.1.3.1
date	97.09.09.14.07.11;	author daveb;	state Exp;
branches;
next	;

1.22.9.1
date	97.09.10.19.21.55;	author brucem;	state Exp;
branches;
next	;

1.22.10.1
date	97.09.11.20.53.11;	author daveb;	state Exp;
branches;
next	;

1.22.11.1
date	99.04.01.17.55.58;	author daveb;	state Exp;
branches;
next	;


desc
@Allocation of virtual to real registers and resulting code modification.
@


1.22
log
@Adding debug flag to analyse
@
text
@(*  ==== REGISTER ALLOCATOR ====
 *           SIGNATURE
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  The register allocator modifies a procedure from using registers drawn
 *  from an infinite set of `virtual' registers to a finite set of `real
 *  register aliases' which correspond to registers on the actual target
 *  processor.  (A mapping from real register aliases to machine registers
 *  is supplied in the MirRegisters module.)  Extra instructions may be
 *  added to the procedure to read and write values in `spill slots' in
 *  order to reduce the number of registers in use at any one time.  The
 *  number of spill slots required is entered in to the procedure parameters
 *  record (see MirTypes).
 *
 *  Diagnostic output levels
 *  ------------------------
 *   0  none
 *   1  procedure tags
 *   2  messages about activities
 *   3  register assignments
 *   4  graphs
 *
 *  Revision Log
 *  ------------
 *  $Log: registerallocator.sml,v $
 *  Revision 1.21  1993/02/22  16:27:32  nosa
 *  Extra stack spills for local and closure variable inspection
 *  in the debugger.
 *
 *  Revision 1.20  1992/12/08  19:47:54  jont
 *  Removed a number of duplicated signatures and structures
 *
 *  Revision 1.19  1992/06/17  10:08:54  richard
 *  Hints are no longer passed to the graphs.
 *
 *  Revision 1.18  1992/06/11  10:33:31  richard
 *  Added `referenced' parameter to clasher.
 *
 *  Revision 1.17  1992/06/03  16:40:47  richard
 *  The register allocator now exports a mutable graph type which is
 *  acted on directly by the variable analyser.
 *
 *  Revision 1.16  1992/05/27  13:36:59  richard
 *  Changed register Sets to Packs.
 *
 *  Revision 1.15  1992/04/29  13:38:23  richard
 *  Added register merge hints to parameters to register allocator.
 *
 *  Revision 1.14  1992/04/16  13:08:59  richard
 *  Added show_timings.
 *
 *  Revision 1.13  1992/04/09  16:01:12  richard
 *  Removed obsolete Switches structure.
 *
 *  Revision 1.12  1992/03/05  11:39:52  richard
 *  Now returns an annotated procedure rather than a plain one.  This is
 *  to make it easy to feed the results to the stack allocator.
 *
 *  Revision 1.11  1992/02/27  17:13:01  richard
 *  Changed the way virtual registers are handled.  See MirTypes.
 *
 *  Revision 1.10  1992/02/13  11:00:49  richard
 *  Added missing require of mirtypes.
 *
 *  Revision 1.9  1992/02/07  14:29:38  richard
 *  Changed the type of `analyse' to return an unannotated procedure.
 *  See new version (2.1) of functor.
 *
 *  Revision 1.8  1991/11/25  11:11:01  richard
 *  Tidied up.
 *
 *  Revision 1.7  91/11/19  15:37:31  richard
 *  Changed debugging output to use the Diagnostic module, which
 *  prevents the debugging output strings being constructed even
 *  if they aren't printed.
 *  
 *  Revision 1.6  91/10/17  12:37:50  richard
 *  Added Switches structure.
 *  
 *  Revision 1.5  91/10/15  13:28:32  richard
 *  Moved register assignment tables to MirRegisters.
 *  
 *  Revision 1.4  91/10/07  11:53:41  richard
 *  Changed dependency on MachRegisters to MachSpec.
 *  
 *  Revision 1.3  91/10/04  11:24:40  richard
 *  Mappings from virtual to real registers are now exported.
 *  
 *  Revision 1.2  91/10/03  15:28:01  richard
 *  The analyse function now returns four tables which map virtual to
 *  real registers along with the modified code. These should be used to
 *  generate the target machine code.
 *  
 *  Revision 1.1  91/09/27  15:01:26  richard
 *  Initial revision
 *)


require "../utils/diagnostic";
require "mirprocedure";


signature REGISTERALLOCATOR =

  sig

    structure MirProcedure	: MIRPROCEDURE
    structure Diagnostic	: DIAGNOSTIC

    type Graph

    val empty : {gc : int, non_gc : int, fp : int} * bool -> Graph

    val clash :
      Graph ->
      {gc     : MirProcedure.MirTypes.GC.Pack.T,
       non_gc : MirProcedure.MirTypes.NonGC.Pack.T,
       fp     : MirProcedure.MirTypes.FP.Pack.T} *
      {gc     : MirProcedure.MirTypes.GC.Pack.T,
       non_gc : MirProcedure.MirTypes.NonGC.Pack.T,
       fp     : MirProcedure.MirTypes.FP.Pack.T} *
      {gc     : MirProcedure.MirTypes.GC.Pack.T,
       non_gc : MirProcedure.MirTypes.NonGC.Pack.T,
       fp     : MirProcedure.MirTypes.FP.Pack.T} ->
      unit



    (*  === ALLOCATE REGISTERS ===
     *
     *  This module takes a procedure, lists of live register clashes (see
     *  MirVariable signature), and hints as to which registers may be
     *  coloured the same, and returns a procedure which uses virtual
     *  registers which are mapped to real registers by the maps in
     *  MirRegisters.machine_register_assignments.
     *
     *  NOTE: The register annotations in the returned procedure will be
     *  incorrect, but the control flow annotations are preserved.
     *)

    val analyse : 
      MirProcedure.procedure * Graph * {fp:int,gc:int,non_gc:int} * bool ->
      MirProcedure.procedure

  end
@


1.22.11.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a28 3
 * Revision 1.22  1995/05/30  11:41:04  matthew
 * Adding debug flag to analyse
 *
@


1.22.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a28 3
 * Revision 1.22  1995/05/30  11:41:04  matthew
 * Adding debug flag to analyse
 *
@


1.22.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a28 3
 * Revision 1.22  1995/05/30  11:41:04  matthew
 * Adding debug flag to analyse
 *
@


1.22.8.1
log
@branched from 1.22
@
text
@a28 3
 * Revision 1.22  1995/05/30  11:41:04  matthew
 * Adding debug flag to analyse
 *
@


1.22.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a28 3
 * Revision 1.22.8.1  1997/05/12  10:32:16  hope
 * branched from 1.22
 *
@


1.22.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a28 3
 * Revision 1.22.8.1  1997/05/12  10:32:16  hope
 * branched from 1.22
 *
@


1.22.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a28 3
 * Revision 1.22.8.1  1997/05/12  10:32:16  hope
 * branched from 1.22
 *
@


1.22.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a28 3
 * Revision 1.22.8.1.1.1  1997/07/28  18:18:02  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.22.7.1
log
@branched from 1.22
@
text
@a28 3
 * Revision 1.22  1995/05/30  11:41:04  matthew
 * Adding debug flag to analyse
 *
@


1.22.6.1
log
@branched from 1.22
@
text
@a28 3
 * Revision 1.22  1995/05/30  11:41:04  matthew
 * Adding debug flag to analyse
 *
@


1.22.6.1.1.1
log
@branched from 1.22.6.1
@
text
@a28 3
 * Revision 1.22.6.1  1996/12/17  17:45:57  hope
 * branched from 1.22
 *
@


1.22.5.1
log
@branched from 1.22
@
text
@a28 3
 * Revision 1.22  1995/05/30  11:41:04  matthew
 * Adding debug flag to analyse
 *
@


1.22.4.1
log
@branched from 1.22
@
text
@a28 3
 * Revision 1.22  1995/05/30  11:41:04  matthew
 * Adding debug flag to analyse
 *
@


1.22.4.1.1.1
log
@branched from 1.22.4.1
@
text
@a28 3
 * Revision 1.22.4.1  1996/11/14  12:47:06  hope
 * branched from 1.22
 *
@


1.22.3.1
log
@branched from 1.22
@
text
@a28 3
 * Revision 1.22  1995/05/30  11:41:04  matthew
 * Adding debug flag to analyse
 *
@


1.22.2.1
log
@branched from 1.22
@
text
@a28 3
 * Revision 1.22  1995/05/30  11:41:04  matthew
 * Adding debug flag to analyse
 *
@


1.22.1.1
log
@branched from 1.22
@
text
@a28 3
 * Revision 1.22  1995/05/30  11:41:04  matthew
 * Adding debug flag to analyse
 *
@


1.21
log
@Extra stack spills for local and closure variable inspection
in the debugger.
@
text
@d29 4
a112 2
    val show_timings : bool ref

d115 1
a115 1
    val empty : {gc : int, non_gc : int, fp : int} -> Graph
d144 3
a146 2
    val analyse : MirProcedure.procedure * Graph * {fp:int,gc:int,non_gc:int} 
      -> MirProcedure.procedure
@


1.21.1.1
log
@Fork for bug fixing
@
text
@a28 4
 *  Revision 1.21  1993/02/22  16:27:32  nosa
 *  Extra stack spills for local and closure variable inspection
 *  in the debugger.
 *
@


1.20
log
@Removed a number of duplicated signatures and structures
@
text
@d29 3
d142 2
a143 1
    val analyse : MirProcedure.procedure * Graph -> MirProcedure.procedure
@


1.19
log
@Hints are no longer passed to the graphs.
@
text
@d29 3
a95 1
require "mirtypes";
a102 1
    structure MirTypes		: MIRTYPES
a103 1
    sharing MirTypes = MirProcedure.MirTypes
d114 9
a122 9
      {gc     : MirTypes.GC.Pack.T,
       non_gc : MirTypes.NonGC.Pack.T,
       fp     : MirTypes.FP.Pack.T} *
      {gc     : MirTypes.GC.Pack.T,
       non_gc : MirTypes.NonGC.Pack.T,
       fp     : MirTypes.FP.Pack.T} *
      {gc     : MirTypes.GC.Pack.T,
       non_gc : MirTypes.NonGC.Pack.T,
       fp     : MirTypes.FP.Pack.T} ->
@


1.18
log
@Added `referenced' parameter to clasher.
@
text
@d29 3
d110 1
a110 6
    val empty :
      {gc : int, non_gc : int, fp : int} *
      {gc     : (MirTypes.GC.T * MirTypes.GC.T) list,
       non_gc : (MirTypes.NonGC.T * MirTypes.NonGC.T) list,
       fp     : (MirTypes.FP.T * MirTypes.FP.T) list} ->
      Graph
@


1.17
log
@The register allocator now exports a mutable graph type which is
acted on directly by the variable analyser.
@
text
@d29 4
d116 3
@


1.16
log
@Changed register Sets to Packs.
@
text
@d29 3
d101 18
d120 2
d134 1
a134 9
    val analyse :
      MirProcedure.procedure *
      {gc     : (MirTypes.GC.Pack.T    * MirTypes.GC.Pack.T)    list,
       non_gc : (MirTypes.NonGC.Pack.T * MirTypes.NonGC.Pack.T) list,
       fp     : (MirTypes.FP.Pack.T    * MirTypes.FP.Pack.T)    list} *
      {gc     : (MirTypes.GC.T * MirTypes.GC.T) list,
       non_gc : (MirTypes.NonGC.T * MirTypes.NonGC.T) list,
       fp     : (MirTypes.FP.T * MirTypes.FP.T) list} ->
      MirProcedure.procedure
@


1.15
log
@Added register merge hints to parameters to register allocator.
@
text
@d29 3
d113 3
a115 3
      {gc     : (MirTypes.GC.Set.T    * MirTypes.GC.Set.T)    list,
       non_gc : (MirTypes.NonGC.Set.T * MirTypes.NonGC.Set.T) list,
       fp     : (MirTypes.FP.Set.T    * MirTypes.FP.Set.T)    list} *
@


1.14
log
@Added show_timings.
@
text
@d29 3
d98 4
a101 3
     *  This module takes a procedure and lists of live register clashes
     *  (see MirVariable signature) and returns a procedure which uses
     *  virtual registers which are mapped to real registers by the maps in
d112 4
a115 1
       fp     : (MirTypes.FP.Set.T    * MirTypes.FP.Set.T)    list} ->
@


1.13
log
@Removed obsolete Switches structure.
@
text
@d29 3
d89 2
@


1.12
log
@Now returns an annotated procedure rather than a plain one.  This is
to make it easy to feed the results to the stack allocator.
@
text
@d29 4
a73 1
require "switches";
a84 1
    structure Switches		: SWITCHES
@


1.11
log
@Changed the way virtual registers are handled.  See MirTypes.
@
text
@d29 3
d92 3
d102 1
a102 1
      MirTypes.procedure
@


1.10
log
@Added missing require of mirtypes.
@
text
@d29 3
d69 1
a69 1
require "miropttypes";
d77 2
a78 2
    structure MirOptTypes	: MIROPTTYPES
    sharing MirTypes = MirOptTypes.MirTypes
d85 3
a87 3
     *  This module takes a procedure which has live variable
     *  annotations and returns a procedure which uses virtual registers
     *  which are mapped to real registers by the maps in
d91 6
a96 1
    val analyse : MirOptTypes.procedure -> MirTypes.procedure
@


1.9
log
@Changed the type of `analyse' to return an unannotated procedure.
See new version (2.1) of functor.
@
text
@d29 4
d65 1
@


1.8
log
@Tidied up.
@
text
@d28 4
a31 1
 *  $Log:	registerallocator.sml,v $
d68 1
d70 1
d78 3
a80 2
     *  annotations and reduces the number of virtual registers used
     *  to not more than the number available on the target processor.
d83 1
a83 1
    val analyse : MirOptTypes.procedure -> MirOptTypes.procedure
@


1.7
log
@Changed debugging output to use the Diagnostic module, which
prevents the debugging output strings being constructed even
if they aren't printed.
@
text
@d1 53
a53 1
(* registerallocator.sml the signature *)
a54 3
(* $Log:	registerallocator.sml,v $
Revision 1.6  91/10/17  12:37:50  richard
Added Switches structure.
a55 20
Revision 1.5  91/10/15  13:28:32  richard
Moved register assignment tables to MirRegisters.

Revision 1.4  91/10/07  11:53:41  richard
Changed dependency on MachRegisters to MachSpec.

Revision 1.3  91/10/04  11:24:40  richard
Mappings from virtual to real registers are now exported.

Revision 1.2  91/10/03  15:28:01  richard
The analyse function now returns four tables which map virtual to
real registers along with the modified code. These should be used to
generate the target machine code.

Revision 1.1  91/09/27  15:01:26  richard
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

a66 9

    (* Diagnostic output levels:
     *   0  none
     *   1  procedure tags
     *   2  messages about activities
     *   3  register assignments
     *   4  graphs
     *)

@


1.6
log
@Added Switches structure.
@
text
@d4 3
d27 1
d38 10
@


1.5
log
@Moved register assignment tables to MirRegisters.
@
text
@d4 3
d24 1
d33 1
@


1.4
log
@Changed dependency on MachRegisters to MachSpec.
@
text
@d4 3
a20 3
require "../utils/table";
require "../machine/machspec";
require "mirtypes";
a28 25
    structure MirTypes		: MIRTYPES
    structure MachSpec		: MACHSPEC
    structure Table		: TABLE



    (*  === REGISTER ASSIGNMENTS ===
     *
     *  The virtual registers in the code returned by the analyse
     *  function can be mapped on to real machine registers using the
     *  following tables.
     *)

    val gc_assign :
      (MirTypes.gc_register, MachSpec.register) Table.table

    val non_gc_assign :
      (MirTypes.non_gc_register, MachSpec.register) Table.table

    val fp_assign :
      (MirTypes.fp_register, MachSpec.register) Table.table

    val fp_double_assign :
      (MirTypes.fp_double_register, MachSpec.register) Table.table

@


1.3
log
@Mappings from virtual to real registers are now exported.
@
text
@d4 3
d19 1
a19 1
require "../machine/machregisters";
d30 1
a30 1
    structure MachRegisters	: MACHREGISTERS
d34 1
d43 1
a43 1
      (MirTypes.gc_register, MachRegisters.T) Table.table
d46 1
a46 1
      (MirTypes.non_gc_register, MachRegisters.T) Table.table
d49 1
a49 1
      (MirTypes.fp_register, MachRegisters.T) Table.table
d52 2
a53 1
      (MirTypes.fp_double_register, MachRegisters.T) Table.table
@


1.2
log
@The analyse function now returns four tables which map virtual to
real registers along with the modified code. These should be used to
generate the target machine code.
@
text
@d4 5
d16 1
d27 1
d31 6
a36 1
    type ''virtual_register assignment
d38 2
d41 10
a55 2
     *  It also returns a tables mapping the virtual registers in the
     *  code to the real machine registers.
d58 1
a58 7
    val analyse :
      MirOptTypes.procedure ->
      MirOptTypes.procedure *
       (MirTypes.gc_register assignment *
	MirTypes.non_gc_register assignment *
	MirTypes.fp_register assignment *
	MirTypes.fp_double_register assignment)
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
(* $Log$
d10 2
d20 2
d24 3
d30 4
a33 6
     *  annotations and assigns each virtual register to a real
     *  register. Where this is not possible it generates the code to
     *  save and restore values on the stack. It will also attempt to
     *  unify registers which are copies of each other.
     *
     *  It returns the modified procedure.
d36 7
a42 2
    val analyse : MirOptTypes.procedure -> MirOptTypes.procedure

@
