head	1.67;
access;
symbols
	MLW_daveb_inline_1_4_99:1.67.1
	MLWorks_21c0_1999_03_25:1.67
	MLWorks_20c1_1998_08_20:1.66
	MLWorks_20c0_1998_08_04:1.66
	MLWorks_20b2c2_1998_06_19:1.66
	MLWorks_20b2_Windows_1998_06_12:1.66
	MLWorks_20b1c1_1998_05_07:1.66
	MLWorks_20b0_1998_04_07:1.66
	MLWorks_20b0_1998_03_20:1.66
	MLWorks_20m2_1998_02_16:1.66
	MLWorks_20m1_1997_10_23:1.66
	MLWorks_11r1:1.66.1.1.1.1.1
	MLWorks_workspace_97:1.66.3
	MLWorks_dt_wizard:1.66.2
	MLWorks_11c0_1997_09_09:1.66.1.1.1.1
	MLWorks_10r3:1.66.1.1.3
	MLWorks_10r2_551:1.66.1.1.2
	MLWorks_11:1.66.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.66.1.1
	MLWorks_20m0_1997_06_20:1.66
	MLWorks_1_0_r2c2_1997_06_14:1.66.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.66.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.66.1
	MLWorks_BugFix_1997_04_24:1.66
	MLWorks_1_0_r2_Win32_1997_04_11:1.66
	MLWorks_1_0_r2_Unix_1997_04_04:1.66
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.63.3.1.1
	MLWorks_gui_1996_12_18:1.63.4
	MLWorks_1_0_Win32_1996_12_17:1.63.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.63.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.63.1.1
	MLWorks_1_0_Irix_1996_11_28:1.63.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.63.2
	MLWorks_1_0_Unix_1996_11_14:1.63.1
	MLWorks_Open_Beta2_1996_10_11:1.60.3
	MLWorks_License_dev:1.60.2
	MLWorks_1_open_beta_1996_09_13:1.60.1
	MLWorks_Open_Beta_1996_08_22:1.60
	MLWorks_Beta_1996_07_02:1.60
	MLWorks_Beta_1996_06_07:1.60
	MLWorks_Beta_1996_06_06:1.60
	MLWorks_Beta_1996_06_05:1.60
	MLWorks_Beta_1996_06_03:1.60
	MLWorks_Beta_1996_05_31:1.60
	MLWorks_Beta_1996_05_30:1.60
	ML_beta_release_12/08/94:1.37
	ML_beta_release_03/08/94:1.36
	ML_revised_beta_release_25/05/94:1.34
	ML_final_beta_release_02/03/94:1.33
	mlworks-28-01-1994:1.33
	Release:1.31
	mlworks-beta-01-09-1993:1.31
	MLWorks-1-0-4-29/01/1993:1.22
	MLWorks-1-0-3-21/12/1992:1.21
	MLWorks-1-0-2-15/12/1992:1.21
	MLWorks-1-0-1-04/12/1992:1.21
	checkpoint_17_08_92:1.14;
locks; strict;
comment	@ * @;


1.67
date	98.08.26.13.43.21;	author jont;	state Exp;
branches
	1.67.1.1;
next	1.66;

1.66
date	97.03.06.16.03.34;	author jont;	state Exp;
branches
	1.66.1.1
	1.66.2.1
	1.66.3.1;
next	1.65;

1.65
date	97.01.16.11.53.58;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	97.01.03.13.55.00;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	96.11.06.11.08.09;	author matthew;	state Exp;
branches
	1.63.1.1
	1.63.2.1
	1.63.3.1
	1.63.4.1;
next	1.62;

1.62
date	96.11.04.15.07.15;	author jont;	state Exp;
branches;
next	1.61;

1.61
date	96.10.30.21.23.21;	author io;	state Exp;
branches;
next	1.60;

1.60
date	96.05.21.15.37.19;	author matthew;	state Exp;
branches
	1.60.1.1
	1.60.2.1
	1.60.3.1;
next	1.59;

1.59
date	96.04.30.16.51.39;	author jont;	state Exp;
branches;
next	1.58;

1.58
date	96.04.30.16.51.39;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	96.04.29.14.47.05;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	96.04.19.14.14.31;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	96.01.31.16.18.52;	author jont;	state Exp;
branches;
next	1.54;

1.54
date	95.12.20.13.05.34;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	95.09.15.16.17.51;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	95.09.12.18.05.54;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	95.07.27.12.17.06;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	95.07.25.13.40.00;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	95.07.18.11.16.43;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	95.07.17.14.43.46;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	95.05.23.10.12.52;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	95.03.17.19.50.56;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	95.02.15.14.55.05;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	95.02.07.17.07.24;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	95.01.05.11.18.31;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	94.11.04.17.59.05;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	94.10.14.14.55.05;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	94.10.10.10.12.33;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	94.09.19.13.53.05;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	94.08.25.11.12.30;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	94.08.09.15.30.07;	author nickh;	state Exp;
branches;
next	1.36;

1.36
date	94.07.25.11.41.04;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	94.06.03.12.51.38;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	94.03.04.13.07.33;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	94.01.19.10.43.23;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	93.09.06.09.15.52;	author nosa;	state Exp;
branches;
next	1.31;

1.31
date	93.08.19.14.50.47;	author jont;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	93.08.18.16.28.04;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	93.07.30.14.50.25;	author nosa;	state Exp;
branches;
next	1.28;

1.28
date	93.07.26.16.57.57;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	93.07.20.12.08.55;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	93.05.18.14.14.58;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	93.04.27.10.46.10;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	93.03.10.17.15.40;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.03.01.15.01.13;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.01.21.18.30.33;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.12.01.11.48.55;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	92.11.30.10.36.22;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.11.25.14.37.55;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	92.10.07.12.51.45;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.09.01.11.28.51;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.08.26.14.44.10;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.08.19.18.06.33;	author davidt;	state Exp;
branches;
next	1.14;

1.14
date	92.08.14.13.48.08;	author davidt;	state Exp;
branches;
next	1.13;

1.13
date	92.08.07.17.59.46;	author davidt;	state Exp;
branches;
next	1.12;

1.12
date	92.08.07.11.36.02;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.07.27.15.12.05;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.07.21.11.41.13;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.07.01.14.27.00;	author davida;	state Exp;
branches;
next	1.8;

1.8
date	92.06.29.09.20.54;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.06.11.09.22.45;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.05.13.09.30.41;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.05.06.13.50.55;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.04.24.16.28.00;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.04.14.09.04.19;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.04.10.17.31.10;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	92.04.07.19.56.36;	author jont;	state Exp;
branches;
next	;

1.31.1.1
date	93.08.19.14.50.47;	author jont;	state Exp;
branches;
next	;

1.60.1.1
date	96.09.13.11.14.26;	author hope;	state Exp;
branches;
next	;

1.60.2.1
date	96.10.07.16.04.53;	author hope;	state Exp;
branches;
next	;

1.60.3.1
date	96.10.17.11.23.07;	author hope;	state Exp;
branches;
next	;

1.63.1.1
date	96.11.14.12.47.26;	author hope;	state Exp;
branches
	1.63.1.1.1.1;
next	;

1.63.1.1.1.1
date	96.11.28.14.58.58;	author hope;	state Exp;
branches;
next	;

1.63.2.1
date	96.11.22.18.07.29;	author hope;	state Exp;
branches;
next	;

1.63.3.1
date	96.12.17.17.46.13;	author hope;	state Exp;
branches
	1.63.3.1.1.1;
next	;

1.63.3.1.1.1
date	97.02.24.11.35.49;	author hope;	state Exp;
branches;
next	;

1.63.4.1
date	96.12.18.09.40.11;	author hope;	state Exp;
branches;
next	;

1.66.1.1
date	97.05.12.10.32.32;	author hope;	state Exp;
branches
	1.66.1.1.1.1
	1.66.1.1.2.1
	1.66.1.1.3.1;
next	;

1.66.1.1.1.1
date	97.07.28.18.18.16;	author daveb;	state Exp;
branches
	1.66.1.1.1.1.1.1;
next	;

1.66.1.1.1.1.1.1
date	97.10.07.11.43.16;	author jkbrook;	state Exp;
branches;
next	;

1.66.1.1.2.1
date	97.09.08.17.11.50;	author daveb;	state Exp;
branches;
next	;

1.66.1.1.3.1
date	97.09.09.14.07.26;	author daveb;	state Exp;
branches;
next	;

1.66.2.1
date	97.09.10.19.22.15;	author brucem;	state Exp;
branches;
next	;

1.66.3.1
date	97.09.11.20.53.33;	author daveb;	state Exp;
branches;
next	;

1.67.1.1
date	99.04.01.17.56.08;	author daveb;	state Exp;
branches;
next	;


desc
@Utilities for _mir_cg
@


1.67
log
@[Bug #20119]
Stop combine creating empty blocks
@
text
@(* _mir_utils.sml the functor *)
(*
$Log: _mir_utils.sml,v $
 * Revision 1.66  1997/03/06  16:03:34  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
 * Revision 1.65  1997/01/16  11:53:58  matthew
 * Rationalizing MIR arithmetic.
 *
 * Revision 1.64  1997/01/03  13:55:00  matthew
 * Simplifications and rationalizations
 *
 * Revision 1.63  1996/11/06  11:08:09  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.62  1996/11/04  15:07:15  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
 * Revision 1.61  1996/10/30  21:23:21  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.60  1996/05/21  15:37:19  matthew
 * WORD32LSHIFT takes a word second argument now.
 *
 * Revision 1.59  1996/04/30  16:51:39  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.57  1996/04/29  14:47:05  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.56  1996/04/19  14:14:31  matthew
 * Exception changes
 *
 * Revision 1.55  1996/01/31  16:18:52  jont
 * Add functions for saving raw 32 bit values as boxed values
 *
Revision 1.54  1995/12/20  13:05:34  jont
Removing Option in favour of MLWorks.Option

Revision 1.53  1995/09/15  16:17:51  daveb
The routines for converting long integers were failing to handle minint.

Revision 1.52  1995/09/12  18:05:54  daveb
Added new types for different sizes of ints, words, and reals.

Revision 1.51  1995/07/27  12:17:06  jont
Get use of sign correct in convert_word

Revision 1.50  1995/07/25  13:40:00  jont
Add word conversion functions

Revision 1.49  1995/07/18  11:16:43  jont
convert_hex_to_bignum moved into bignum module

Revision 1.48  1995/07/17  14:43:46  jont
Allow conversion of hex integers
including outsize integers

Revision 1.47  1995/05/23  10:12:52  matthew
Removed check on GCness of function
This caused a compiler fault with eg. (cast 0) 0

Revision 1.46  1995/03/17  19:50:56  daveb
Removed ununsed parameter Print.

Revision 1.45  1995/02/15  14:55:05  matthew
Removed NewMap from Debugger_Types

Revision 1.44  1995/02/07  17:07:24  matthew
Removing unused LambdaSub

Revision 1.43  1995/01/05  11:18:31  matthew
Rationalizing debugger

Revision 1.42  1994/11/04  17:59:05  jont
Remove superfluous adds when calculating self closure

Revision 1.41  1994/10/14  14:55:05  matthew
Make lookup_in_closure return an Option value
Some efficiency improvements -- reduce number of lookups of variables
and diddled about with appending lists of lists.

Revision 1.40  1994/10/10  10:12:33  matthew
Changes to lambda calculus

Revision 1.39  1994/09/19  13:53:05  matthew
Changes to lambdatypes

Revision 1.38  1994/08/25  11:12:30  matthew
Adding stuff for multiple argument passing

Revision 1.37  1994/08/09  15:30:07  nickh
Mistake in lift_externals.

Revision 1.36  1994/07/25  11:41:04  matthew
Added support for multiple arguments to functions.
Not complete yet, but should be OK for single argument case.

Revision 1.35  1994/06/03  12:51:38  jont
Fix register undefined following self tail call problem

Revision 1.34  1994/03/04  13:07:33  jont
Log: Changes for automatic_callee mechanism removal
and moving machspec from machine to main

Revision 1.33  1994/01/19  10:43:23  matthew
Added ConvertInt exception to MirUtils

Revision 1.33  1994/01/19  10:43:23  matthew
Convert_int raises ConvertInt exception

Revision 1.32  1993/09/06  09:15:52  nosa
FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.

Revision 1.31  1993/08/19  14:50:47  jont
Fixed bug in needs_transform to look inside the arguments to builtins

Revision 1.30  1993/08/18  16:28:04  jont
Moved some more functions here from _mir_cg.sml

Revision 1.29  1993/07/30  14:50:25  nosa
Changed type of new_do_app for local and closure variable
inspection in the debugger;
structure Option.

Revision 1.28  1993/07/26  16:57:57  jont
Fixed bug where host longest int might be unrepresentable in target

Revision 1.27  1993/07/20  12:08:55  jont
Added support for code generation of long ints by transforming the lambda
calculus to expressions involving shifts and adds

Revision 1.26  1993/05/18  14:14:58  jont
Removed Integer parameter

Revision 1.25  1993/04/27  10:46:10  richard
Removed unused option refs.

Revision 1.24  1993/03/10  17:15:40  matthew
Signature revisions

Revision 1.23  1993/03/01  15:01:13  matthew
Added MLVALUE lambda exp

Revision 1.22  1993/01/21  18:30:33  jont
Made copy_n tail recursive

Revision 1.21  1992/12/01  11:48:55  daveb
Changes to propagate compiler options as parameters instead of references.

Revision 1.20  1992/11/30  10:36:22  jont
Removed a large number of unnecessary map operations

Revision 1.19  1992/11/25  14:37:55  daveb
Fixed bug in tail optimisation code.
Also removed redefinition of append.

Revision 1.18  1992/10/07  12:51:45  clive
Convert on most negative integer failed

Revision 1.17  1992/09/01  11:28:51  clive
Added switches for self call optimisation

Revision 1.16  1992/08/26  14:44:10  jont
Removed some redundant structures and sharing

Revision 1.15  1992/08/19  18:06:33  davidt
Mir_Env now uses Map instead of Map.

Revision 1.14  1992/08/14  13:48:08  davidt
Changed ord(substring ...) to ordof.

Revision 1.13  1992/08/07  17:59:46  davidt
String structure is now pervasive.

Revision 1.12  1992/08/07  11:36:02  clive
Added a flag to turn off tail-call optimisation

Revision 1.11  1992/07/27  15:12:05  jont
Shortened various exit blocks (should be done by expression analyser)

Revision 1.10  1992/07/21  11:41:13  jont
Rewrote cg_lvar to use exceptions instead of is_in...

Revision 1.9  1992/07/01  14:27:00  davida
Added LET constructor and new slot to APP.

Revision 1.8  1992/06/29  09:20:54  clive
Added type annotation information at application points

Revision 1.7  1992/06/11  09:22:45  clive
Added slot for slot in FNexp

Revision 1.6  1992/05/13  09:30:41  jont
Changed to use augmented lambda calculus, and sexpressions to avoid
duplicated append operations.

Revision 1.5  1992/05/06  13:50:55  jont
Removed some no longer used functions. Tidied up in places, using
reducer for appends instead of reducel. Accidentally fixed a problem
in build_args_for_tail caused by the int_reg_list being in reverse order
(real fix is in _interproc)

Revision 1.4  1992/04/24  16:28:00  jont
Changed reducel op @@ to reducer op @@ to avoid quadratic behaviour

Revision 1.3  1992/04/14  09:04:19  clive
First version of the profiler

Revision 1.2  1992/04/10  17:31:10  jont
Fixed minor potential problem with tupling real values

Revision 1.1  1992/04/07  19:56:36  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "^.basis.__int";
require "^.basis.__string";
require "^.basis.__char";

require "../utils/sexpr";
require "../utils/diagnostic";
require "../utils/lists";
require "../utils/crash";
require "../utils/bignum";
require "../main/pervasives";
require "../main/library";
require "../typechecker/types";
require "mirregisters";
require "mir_env";
require "mir_utils";


functor Mir_Utils(
  structure Sexpr : SEXPR
  structure Diagnostic : DIAGNOSTIC
  structure Lists : LISTS
  structure Crash : CRASH
  structure BigNum : BIGNUM
  structure BigNum32 : BIGNUM
  structure Pervasives : PERVASIVES
  structure Library : LIBRARY
  structure Types : TYPES
  structure MirRegisters : MIRREGISTERS
  structure Mir_Env : MIR_ENV

  sharing Mir_Env.LambdaTypes = Library.AugLambda.LambdaTypes
  sharing Mir_Env.LambdaTypes.Ident = Types.Datatypes.Ident
  sharing Mir_Env.MirTypes = MirRegisters.MirTypes
  sharing type Pervasives.pervasive = Mir_Env.LambdaTypes.Primitive
  sharing type Types.Datatypes.Type = Mir_Env.LambdaTypes.Type
) : MIR_UTILS =
struct
  structure Sexpr = Sexpr
  structure Diagnostic = Diagnostic
  structure AugLambda = Library.AugLambda
  structure LambdaTypes = Mir_Env.LambdaTypes
  structure Debugger_Types = AugLambda.Debugger_Types
  structure Pervasives = Pervasives
  structure Mir_Env = Mir_Env
  structure MirTypes = Mir_Env.MirTypes
  structure Set = LambdaTypes.Set
  structure Ident = LambdaTypes.Ident
  structure Symbol = Ident.Symbol
  structure Datatypes = Types.Datatypes
  structure Map = Datatypes.NewMap

  type bignum = BigNum.bignum
  (* This functor exports biggest_num. *)

  exception Unrepresentable = BigNum.Unrepresentable

  fun appendl [] = []
    | appendl [l] = l
    | appendl [l1,l2] = l1 @@ l2
    | appendl ll =
      let
        fun rev' ([],acc) = acc
          | rev' (a::l,acc) = rev' (l,a::acc)
        fun aux ([],acc) = rev' (acc,[])
          | aux ([l],acc) = rev' (acc,l)
          | aux (l::ll,acc) = aux (ll,rev' (l,acc))
      in
        aux (ll,[])
      end

  val real_offset = 3

  val caller_arg = MirRegisters.caller_arg
  (* The argument register for all functions *)

  val callee_arg = MirRegisters.callee_arg
  (* The local copy of the argument register *)

  val caller_closure = MirRegisters.caller_closure
  (* The closure pointer for all function calls *)

  val callee_closure = MirRegisters.callee_closure
  (* The local copy of the closure pointer *)

  fun find_largest_power(n, i) =
    (find_largest_power(n+1, i*2)) handle Overflow => n

  val longest_string_length = find_largest_power(0, 1)
  (* How much to chop strings up into *)

  fun gp_from_reg(MirTypes.GC_REG x) = MirTypes.GP_GC_REG x
    | gp_from_reg(MirTypes.NON_GC_REG x) = MirTypes.GP_NON_GC_REG x

  fun reg_from_gp(MirTypes.GP_GC_REG x) = MirTypes.GC_REG x
    | reg_from_gp(MirTypes.GP_NON_GC_REG x) = MirTypes.NON_GC_REG x
    | reg_from_gp _ = Crash.impossible"reg_from_gp(IMM)"

  datatype reg_result =
    INT of MirTypes.gp_operand |
    REAL of MirTypes.fp_operand

  fun get_real(REAL fp_op) = (fp_op, [])
    | get_real(INT(MirTypes.GP_GC_REG reg_op)) =
      let
        val fp_op = MirTypes.FP_REG(MirTypes.FP.new())
      in
        (fp_op,
         [MirTypes.STOREFPOP(MirTypes.FLD, fp_op, MirTypes.GC_REG reg_op,
                             MirTypes.GP_IMM_ANY real_offset)])
      end
    | get_real _ = Crash.impossible"get_real bad value"

  fun get_word32(INT(MirTypes.GP_GC_REG reg_op)) =
      let
        val res = MirTypes.GC.new()
        val res1 = MirTypes.GC_REG res
        val res2 = MirTypes.GP_GC_REG res
      in
        (res2,
         [MirTypes.STOREOP(MirTypes.LD, res1, MirTypes.GC_REG reg_op,
                             MirTypes.GP_IMM_ANY ~1)],
	 [MirTypes.NULLARY(MirTypes.CLEAN, res1)])
      end
  |   get_word32(INT(MirTypes.GP_NON_GC_REG _)) =
  	Crash.impossible "get_word32 GP_NON_GC_REG"
  |   get_word32(INT(MirTypes.GP_IMM_INT i)) =
  	Crash.impossible ("get_word32 GP_IMM_INT " ^ Int.toString i)
  |   get_word32(INT(MirTypes.GP_IMM_ANY _)) =
  	Crash.impossible "get_word32 GP_IMM_ANY"
  |   get_word32(INT(MirTypes.GP_IMM_SYMB _)) =
  	Crash.impossible "get_word32 GP_IMM_SYMB"
  |   get_word32 _ = Crash.impossible "get_word32 bad value"

  fun save_real_to_reg(fp_op, reg) =
    (* Store as to a pointer (tag 1) *)
    [MirTypes.ALLOCATE(MirTypes.ALLOC_REAL, reg, MirTypes.GP_IMM_INT 0),
     MirTypes.STOREFPOP(MirTypes.FST, fp_op, reg,
			MirTypes.GP_IMM_ANY real_offset)]

  fun save_real(fp_op) =
    let
      val new_reg = MirTypes.GC.new()
      val new_r = MirTypes.GC_REG new_reg
    in
      (new_reg, save_real_to_reg(fp_op, new_r))
    end

  fun tuple_up_in_reg(reg_list, new_reg) =
  let
    val len = length reg_list
    (* Get the offset right for the pointer type used *)
    val alloc_op =
      MirTypes.ALLOCATE(MirTypes.ALLOC, MirTypes.GC_REG new_reg, MirTypes.GP_IMM_INT len)
    val reg_code_list =
      map
      (fn (REAL fp_op) =>
       let
	 val (reg, code) = save_real(fp_op)
       in
	 (INT(MirTypes.GP_GC_REG reg), code)
       end
       | reg => (reg, []))
      reg_list
    val reg_list = map #1 reg_code_list
    val start_code =
      appendl (map #2 reg_code_list)
(*
      Lists.reducer
      (fn ((y, z), x) => z @@ x)
      (reg_code_list, [])
*)
    val (number_list, _) =
      Lists.number_from(reg_list, ~1, 4, MirTypes.GP_IMM_ANY)
  in
    (new_reg, 
     appendl
     ((start_code @@ [alloc_op]) ::
        map (fn (INT(MirTypes.GP_GC_REG reg), imm) =>
	     [MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG reg,
			  MirTypes.GC_REG new_reg, imm)]
	     | (INT(MirTypes.GP_NON_GC_REG reg), imm) =>
	       [MirTypes.STOREOP(MirTypes.ST, MirTypes.NON_GC_REG reg,
		 MirTypes.GC_REG new_reg, imm)]
	     | (INT(i as MirTypes.GP_IMM_INT _), imm) =>
	       let
		 val new_reg' = MirTypes.GC.new()
	       in
		 [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg', i),
		   MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg',
		   MirTypes.GC_REG new_reg, imm)]
	       end
	     | (INT(i as MirTypes.GP_IMM_SYMB _), imm) =>
	       let
		 val new_reg' = MirTypes.GC.new()
	       in
		 [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg', i),
		   MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg',
		   MirTypes.GC_REG new_reg, imm)]
	       end
	     | (REAL _, _) =>
		 Crash.impossible"tuple_up_in_reg of unhandled REAL"
	     | _ => Crash.impossible"Tuple_up_in_reg untagged value")
      number_list))
  end

  fun stack_tuple_up_in_reg(reg_list, new_reg) =
  let
    val len = length reg_list
    val alloc_op =
      MirTypes.ALLOCATE_STACK(MirTypes.ALLOC, MirTypes.GC_REG new_reg, len,
			      NONE)
    val (number_list, _) =
      Lists.number_from(reg_list, ~1, 4, MirTypes.GP_IMM_ANY)
  in
    (new_reg, 
     appendl
     ([alloc_op] ::
        map (fn (INT(MirTypes.GP_GC_REG reg), imm) =>
	     [MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG reg,
			  MirTypes.GC_REG new_reg, imm)]
	     | (INT(MirTypes.GP_NON_GC_REG reg), imm) =>
	       [MirTypes.STOREOP(MirTypes.ST, MirTypes.NON_GC_REG reg,
		 MirTypes.GC_REG new_reg, imm)]
	     | (INT(i as MirTypes.GP_IMM_INT _), imm) =>
	       let
		 val new_reg' = MirTypes.GC.new()
	       in
		 [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg', i),
		   MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg',
		   MirTypes.GC_REG new_reg, imm)]
	       end
	     | (INT(i as MirTypes.GP_IMM_SYMB _), imm) =>
	       let
		 val new_reg' = MirTypes.GC.new()
	       in
		 [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg', i),
		   MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg',
		   MirTypes.GC_REG new_reg, imm)]
	       end
	     | (REAL fp_op, imm) =>
	       let
		 val (new_reg', code) = save_real(fp_op)
	       in
		 code @@
		 [MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg',
				   MirTypes.GC_REG new_reg,
				   imm)]
	       end
	     | _ => Crash.impossible"Tuple_up untagged value")
      number_list))
  end

  fun tuple_up reg_list =
    tuple_up_in_reg(reg_list, MirTypes.GC.new())

  exception ConvertInt

  fun convert chars =
    let
      val char_size = size chars
      fun convert' (sign, ptr, value) =
	if ptr >= char_size then value
	else
	  let
	    val new_digit = (MLWorks.String.ordof (chars, ptr)) - ord #"0"
	  in
	    convert' (sign,ptr+1, 10 * value + (if sign then new_digit else ~new_digit))
	  end
    in
      convert' 
    end

  fun convert_hex chars =
    let
      val char_size = size chars
      fun convert_hex_int(sign, ptr, value) =
	if ptr >= char_size then value
	else
	  let
	    val digit = chr (MLWorks.String.ordof (chars, ptr))
	    val new_digit =
	      if Char.isDigit digit then 
		ord digit - ord #"0"
	      else if digit >= #"a" andalso digit <= #"f" then
		ord digit - ord #"a" + 10
		   else
		     if digit >= #"A" andalso digit <= #"F" then
		       ord digit - ord #"A" + 10
		     else
		       Crash.impossible("convert_hex:bad digit: " ^ (str digit))
	  in
	    convert_hex_int(sign,ptr+1, 16 * value + (if sign then new_digit else ~new_digit))
	  end
    in
      convert_hex_int
    end

  fun power(n, x, a:int) =
    if n <= 0 then a else power(n-1, x, a*x)

  fun convert_int (chars, max_size_opt) = 
    let
      val (sign, ptr) = if MLWorks.String.ordof (chars, 0) = ord #"~" then (false, 1) else (true, 0)
      val is_short = size chars - ptr < 2
      
      val number =
	if is_short then
	  convert chars (sign, ptr, 0)
        else
	  (if MLWorks.String.ordof (chars, ptr) = ord #"0" andalso MLWorks.String.ordof (chars, ptr+1) = ord #"x" then
	     convert_hex chars (sign, ptr + 2, 0)
	   else
	     convert chars (sign, ptr, 0))
    in
      case max_size_opt of
	NONE =>
	  number
      |  SOME max_size => 
	  let
	    val max_int = power (max_size - 1, 2, 1)
	    val min_int = ~max_int
	  in
	    if number >= max_int orelse number < min_int then
	      raise Unrepresentable
	    else
	      number
	  end
        handle	(* if power raises Overflow, then the number must fit *)
	Overflow => number
    end
  handle Overflow => raise ConvertInt

  fun convert_word (chars, max_size_opt) =
    let
      val is_short = size chars < 3
      val sign = true

      val number =
        if is_short then
	  convert chars (sign, 2, 0)
        else
	  if String.isPrefix "0wx" chars then
	    convert_hex chars (sign, 3, 0)
	  else
	    convert chars (sign, 2, 0)
    in
      case max_size_opt
      of NONE => number
      |  SOME max_size => 
	let
	  val max_int = power (max_size, 2, 1)
	in
	  if number >= max_int then
	    raise Unrepresentable
	  else
	    number
        end
        handle	(* if power raises Overflow, then the number must fit *)
	  Overflow => number
    end
  handle Overflow => raise ConvertInt

  fun string_is_zero (s:string):bool = 
    let
      val sz = size s
      fun scan i = 
	if i < sz then
	  if (String.sub(s, i) = #"0") then
	    scan (i+1)
	  else
	    false
	else
	  true
    in
      scan 0
    end

  fun to_lab string = Ident.LAB(Symbol.find_symbol string)

  val binary_int_function_type =
    Datatypes.FUNTYPE(Types.add_to_rectype
		      (to_lab"1", Types.int_type,
		       Types.add_to_rectype(to_lab"2", Types.int_type,
					    Types.empty_rectype)), Types.int_type)

  fun longest_representable_int longest_string_length =
    let
      val longest_int = power(longest_string_length, 2, 1)
      val biggest_num = BigNum.string_to_bignum(Int.toString longest_int)
    in
      (longest_string_length, longest_int, biggest_num)
    end handle BigNum.Unrepresentable =>
      longest_representable_int(longest_string_length-1)

  val (longest_string_length, longest_int, biggest_num) =
    longest_representable_int longest_string_length

  val bignum_zero = BigNum.int_to_bignum 0

  fun add_sign(arg as (chars, location), sign) =
    if sign then
      ("~" ^ chars, location)
    else
      arg

  (* This function returns an expression that calculates the desired value,
     without overflowing on the compiling machine. *)
  fun convert_long(bignum, arg as (_, location)) =
    if BigNum.<=(bignum, biggest_num) andalso
       BigNum.>=(bignum, BigNum.~ biggest_num) then
      (* Terminate the recursion *)
      AugLambda.SCON
	(LambdaTypes.Ident.INT (BigNum.bignum_to_string bignum, location),
	 NONE)
	 (* I think the maximum size is irrelevant now, hence the NONE. *)
    else
      let
	val head = BigNum.quot(bignum, biggest_num)
	val tail = BigNum.rem(bignum, biggest_num)
      in
	if BigNum.eq(head, bignum_zero) then
	  AugLambda.SCON
	    (LambdaTypes.Ident.INT (BigNum.bignum_to_string tail, location),
	     NONE)
	 (* I think the maximum size is irrelevant now, hence the NONE. *)
	else
	  AugLambda.APP
	  ({size=0,
	    lexp=AugLambda.BUILTIN
	    (Pervasives.UNSAFEINTPLUS, binary_int_function_type)},
	   ([{size=0,
	     lexp=
	     AugLambda.STRUCT
	     [{size=0,
	       (* head * 2 ** longest_string_length *)
	       lexp=AugLambda.APP
	       ({size=0,
		 lexp=AugLambda.BUILTIN
		 (Pervasives.LSHIFT, binary_int_function_type)},
		([{size=0,
		  lexp=
		  AugLambda.STRUCT
		  [{size=0, lexp=convert_long(head, arg)},
		   {size=0, lexp=AugLambda.INT longest_string_length}]
		  }],[]),
		Debugger_Types.SELECT
		(0, Debugger_Types.NOP))
	       },
	     {size=0, lexp=convert_long(tail, arg)}]
	     }],[]),
	   Debugger_Types.SELECT
	   (0, Debugger_Types.NOP))
      end

  fun convert_long_int (arg as (chars, _)) =
    let
      val ptr = if MLWorks.String.ordof (chars, 0) = ord #"~" then 1 else 0

      val is_short = size chars < 2 + ptr
      (* This is very unlikely ever to hold, because this function is only
	 called if the integer can't be held in an int value. *)

      val bignum =
	if is_short then
	  BigNum.string_to_bignum chars
	else if MLWorks.String.ordof (chars, ptr) = ord #"0" andalso
	  MLWorks.String.ordof (chars, ptr+1) = ord #"x" then
	  BigNum.hex_string_to_bignum chars
	else
	  BigNum.string_to_bignum chars
    in
      convert_long(bignum, arg)
    end

  fun convert_long_word (arg as (chars, _)) =
    let
      val is_short = size chars < 3
      (* This is very unlikely ever to hold, because this function is only
	 called if the word can't be held in an int value. *)
      val bignum =
	if is_short then
	  BigNum.word_string_to_bignum chars
	else
	  if String.isPrefix "0wx" chars then
	    BigNum.hex_word_string_to_bignum chars
	  else
	    BigNum.word_string_to_bignum chars
    in
      convert_long(bignum, arg)
    end


  (* 32-bit conversions *)

  val binary_word32_function_type =
    Datatypes.FUNTYPE
      (Types.add_to_rectype
         (to_lab"1", Types.word32_type,
	  Types.add_to_rectype
 	    (to_lab"2", Types.word32_type,
	     Types.empty_rectype)),
       Types.word32_type)

  fun longest_representable_int32 num_bits =
    let
      val longest_int = power(num_bits, 2, 1)
      val biggest_num =
        BigNum32.string_to_bignum(Int.toString longest_int)
    in
      biggest_num
    end
    handle
       BigNum32.Unrepresentable =>
      longest_representable_int32 (num_bits - 1)
    |  Overflow =>
      longest_representable_int32 (num_bits - 1)

  val biggest_num32 =
    longest_representable_int32 28

  val bignum32_zero = BigNum32.int_to_bignum 0

  val longest_string_length_str =
    Int.toString longest_string_length

  (* N.B. This is supposed to handle both Int32 and Word32.  It requires that
     mir_cg is able to handle Int32 literals, as it creates them here.
     It uses Word32 operations because that's all I've implemented so far;
     it may be a good idea to keep these because they don't check for Overflow
     (which should be impossible). *)
  fun convert_long32 (bignum, arg as (_, location)) =
    if BigNum32.<=(bignum, biggest_num32) andalso
       BigNum32.>=(bignum, BigNum32.~ biggest_num32) then
      (* Terminate the recursion *)
      AugLambda.SCON
	(LambdaTypes.Ident.INT (BigNum32.bignum_to_string bignum, location),
	 SOME 32)
    else
      let
	val head = BigNum32.quot (bignum, biggest_num32)
	val tail = BigNum32.rem(bignum, biggest_num32)
      in
	if BigNum32.eq(head, bignum32_zero) then
	  AugLambda.SCON
	    (LambdaTypes.Ident.INT (BigNum32.bignum_to_string tail, location),
	     SOME 32)
	else
	  AugLambda.APP
	  ({size=0,
	    lexp=AugLambda.BUILTIN
	    (Pervasives.WORD32PLUS, binary_word32_function_type)},
	   ([{size=0,
	     lexp=
	     AugLambda.STRUCT
	     [{size=0,
	       (* head * 2 ** longest_string_length *)
	       lexp=AugLambda.APP
	       ({size=0,
		 lexp=AugLambda.BUILTIN
		        (Pervasives.WORD32LSHIFT, binary_word32_function_type)},
		([{size=0,
		  lexp=
		  AugLambda.STRUCT
		  [{size=0, lexp=convert_long32(head, arg)},
		   {size=0,
		    lexp=
		      AugLambda.SCON
			(LambdaTypes.Ident.INT
			   (longest_string_length_str, location),
			 NONE)
		   }]
		 }],[]),
		Debugger_Types.SELECT
		(0, Debugger_Types.NOP))
	       },
	     {size=0, lexp= convert_long32(tail, arg)}]
	     }],[]),
	   Debugger_Types.SELECT
	   (0, Debugger_Types.NOP))
      end

  fun convert_long_int32 (arg as (chars, _)) =
    let
      val ptr = if MLWorks.String.ordof (chars, 0) = ord #"~" then 1 else 0

      val is_short = size chars < 2 + ptr
      (* This is very unlikely ever to hold, because this function is only
	 called if the integer can't be held in an int value. *)

      val bignum =
	if is_short then
	  BigNum32.string_to_bignum chars
	else
	  case substring (* could raise Substring *)(chars, ptr, 2) of
	    "0x" => BigNum32.hex_string_to_bignum chars
	  | _ => BigNum32.string_to_bignum chars
    in
      convert_long32(bignum, arg)
    end
    handle
      BigNum32.Unrepresentable =>
	raise Unrepresentable

  fun convert_long_word32 (arg as (chars, _)) =
    let
      val is_short = size chars < 3
      (* This is very unlikely ever to hold, because this function is only
	 called if the word can't be held in an int value. *)
      val bignum =
	if is_short then
	  BigNum32.word_string_to_bignum chars
	else
	  if String.isPrefix "0wx" chars then
	    BigNum32.hex_word_string_to_bignum chars
	  else
	    BigNum32.word_string_to_bignum chars
    in
      convert_long32(bignum, arg)
    end
    handle
      BigNum32.Unrepresentable =>
	raise Unrepresentable

  val convert_long_int =
    fn (Ident.INT arg, SOME 32) => convert_long_int32 arg
    |  (Ident.INT arg, max_size) => convert_long_int arg
    |  _ => Crash.impossible "Convert_long_int of non-int"

  val convert_long_word =
    fn (Ident.WORD arg, SOME 32) => convert_long_word32 arg
    |  (Ident.WORD arg, max_size) => convert_long_word arg
    |  _ => Crash.impossible "Convert_long_word of non-word"

  datatype cg_result =
    ONE of reg_result |
    LIST of reg_result list

  fun get_any_register (INT(MirTypes.GP_GC_REG reg)) = MirTypes.GC reg
    | get_any_register (INT(MirTypes.GP_NON_GC_REG reg)) = MirTypes.NON_GC reg
    | get_any_register (REAL(MirTypes.FP_REG reg)) = MirTypes.FLOAT reg
    | get_any_register _ = Crash.impossible"Bad value to get_any_register"

  fun cg_lvar(lvar, env, closure, funs_in_closure) =
    (* first look up in the lambda environment *)
    (case Mir_Env.lookup_lambda(lvar, env) of
       SOME (MirTypes.GC reg) => 
         (((INT(MirTypes.GP_GC_REG reg)),[]), 0,false)
     | SOME (MirTypes.NON_GC reg) => 
         (((INT(MirTypes.GP_NON_GC_REG reg)),[]),0,false)
     | SOME (MirTypes.FLOAT reg) => 
         (((REAL(MirTypes.FP_REG reg)),[]),0,false)
     | NONE =>
         (* else look up in the closure *)
         (* This loads in an object from the closure *)
         (case Mir_Env.lookup_in_closure(lvar, closure) of
            SOME offset =>
              let
                val is_same_set = offset < funs_in_closure * 2 - 1
                val new_reg = MirTypes.GC.new()
              in
                (* Because the function pointers in a closure are interspersed *)
                (* with zeroes, we must halve offset_in_closure above *)
                ((INT(MirTypes.GP_GC_REG new_reg),
                  [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
                                    MirTypes.GC_REG callee_closure,
                                    MirTypes.GP_IMM_ANY(~1 + 4*offset))]),
                offset div 2, is_same_set)
              end
          | NONE => 
              Crash.impossible("cg_lvar: Lambda variable " ^
                               LambdaTypes.printLVar lvar ^
                               " is neither in the closure nor the local bindings")))

  (* If its a function value we want, just add offset onto current closure *)
  fun cg_lvar_fn(lvar, env, closure, funs_in_closure) =
    let
      val ((reg, code), pos, is_same_set) =
	cg_lvar(lvar, env, closure, funs_in_closure)
    in
      if is_same_set then
	let
	  val new_reg = MirTypes.GC.new()
	in
	  (INT(MirTypes.GP_GC_REG new_reg),
	    [MirTypes.BINARY(MirTypes.ADDU, MirTypes.GC_REG new_reg,
			     MirTypes.GP_GC_REG callee_closure,
			     MirTypes.GP_IMM_INT (pos*2))])
	(* Note use of recursive call info for dynamic access *)
	end
      else
	(reg, code)
    end

  fun list_of(i, v) =
    let
      fun list_sub(i, done) =
	if i <= 0 then done
	else list_sub(i-1, v :: done)
    in
      list_sub(i, [])
    end

  fun list_of_tags n =
    let
      fun list_sub(n, done) =
	if n <= 0 then done
	else list_sub(n-1, MirTypes.new_tag() :: done)
    in
      list_sub(n, [])
    end

  fun destruct_2_tuple(MirTypes.GP_GC_REG gc_reg) =
    let
      val reg1 = MirTypes.GC.new()
      val reg2 = MirTypes.GC.new() (* reasonable assumption *)
    in
      (MirTypes.GP_GC_REG reg1,
       MirTypes.GP_GC_REG reg2,
       [MirTypes.STOREOP(MirTypes.LD,
			 MirTypes.GC_REG reg1, MirTypes.GC_REG gc_reg,
			 MirTypes.GP_IMM_ANY ~1),
	MirTypes.STOREOP(MirTypes.LD,
			 MirTypes.GC_REG reg2, MirTypes.GC_REG gc_reg,
			 MirTypes.GP_IMM_ANY 3)])
    end
  | destruct_2_tuple _ = Crash.impossible"destruct_2_tuple"

  fun contract_sexpr(Sexpr.NIL, [], acc) = appendl (rev acc) (* Lists.reducel (fn (x, y) => y @@ x) ([], acc) *)
  | contract_sexpr(Sexpr.NIL, x :: xs, acc) = contract_sexpr(x, xs, acc)
  | contract_sexpr(Sexpr.ATOM x, to_do, acc) =
    contract_sexpr(Sexpr.NIL, to_do, x :: acc)
  | contract_sexpr(Sexpr.CONS(x, y), to_do, acc) =
    contract_sexpr(x, y :: to_do, acc)

  val contract_sexpr =
    fn x => contract_sexpr(x, [], [])

  fun empty_sexpr Sexpr.NIL = true
    | empty_sexpr(Sexpr.ATOM []) = true
    | empty_sexpr(Sexpr.CONS(x, y)) = empty_sexpr x andalso empty_sexpr y
    | empty_sexpr _ = false

  fun combine(((first, blocks, tag, last), values, set),
	      ((first', blocks', tag', last'), values', set')) =
    let
      val code =
        case tag of
          NONE =>
            if empty_sexpr last then
              (Sexpr.CONS (first, first'), blocks @@ blocks', tag', last')
            else
              Crash.impossible"non-empty last with no tag"
        | SOME tag_val =>
            (case tag' of
               NONE =>
                 if empty_sexpr last' then
                   (first, blocks @@ blocks', tag, Sexpr.CONS(last, first'))
                 else
                   Crash.impossible"non-empty last' with no tag"
             | SOME tag_val' =>
                 (first,
		  let
		    val list = contract_sexpr(Sexpr.CONS(last,first'))
		    val tail = blocks @@ blocks'
		  in
		    case list of
		      [] => tail
		    | _ => MirTypes.BLOCK(tag_val,list) :: tail
		  end,
		  tag', last'))
    in
      (code,values @@ values',set @@ set')
    end

  fun send_to_given_reg_with_allocate(tuple_fn, (cg_res, gc_reg)) =
    case cg_res of
      ONE reg =>
	(case reg of
	  INT(arg as MirTypes.GP_IMM_INT _) =>
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG gc_reg, arg)]
	| INT(arg as MirTypes.GP_IMM_SYMB _) =>
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG gc_reg, arg)]
	| INT(MirTypes.GP_IMM_ANY _) =>
	  Crash.impossible"GP_IMM_ANY"
	| INT(arg as MirTypes.GP_GC_REG gc_reg') =>
	    if (gc_reg' = gc_reg) then []
	    else [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG gc_reg, arg)]
	| INT(arg as MirTypes.GP_NON_GC_REG non_gc_reg) =>
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG gc_reg, arg)]
	| REAL fp_op =>
	    save_real_to_reg(fp_op, MirTypes.GC_REG gc_reg))
    | LIST many =>
	let
	  val (_, code) = tuple_fn(many, gc_reg)
	in
	  code
	end

  fun send_to_given_reg arg =
    send_to_given_reg_with_allocate(tuple_up_in_reg, arg)

  fun stack_send_to_given_reg arg =
    send_to_given_reg_with_allocate(stack_tuple_up_in_reg, arg)

  fun send_to_new_reg x =
    let
      val new_reg = MirTypes.GC.new()
    in
      (MirTypes.GP_GC_REG new_reg,send_to_given_reg(x, new_reg))
    end

  fun send_to_reg(ONE reg) =
    (case reg of
       INT(arg as MirTypes.GP_IMM_INT _) =>
	 let val new_reg = MirTypes.GC.new()
	 in
	   (MirTypes.GP_GC_REG new_reg,
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg, arg)])
	 end
     | INT(arg as MirTypes.GP_IMM_SYMB _) =>
	 let val new_reg = MirTypes.GC.new()
	 in
	   (MirTypes.GP_GC_REG new_reg,
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg, arg)])
	 end
     | INT(MirTypes.GP_IMM_ANY _) =>
	 Crash.impossible"GP_IMM_ANY"
     | INT x => (x, [])
     | REAL fp_op =>
	 let
	   val (reg, code) = save_real(fp_op)
	 in
	   (MirTypes.GP_GC_REG reg, code)
	 end)
  | send_to_reg(LIST many) =
    let val (gc_reg, code) = tuple_up(many)
    in
      (MirTypes.GP_GC_REG gc_reg, code)
    end

  fun save_word32_in_reg(source, target) =
    let
      val source1 = MirTypes.GC_REG source
      val target1 = MirTypes.GC_REG target
    in
      [MirTypes.ALLOCATE
       (MirTypes.ALLOC_STRING, target1, MirTypes.GP_IMM_INT 4),
       MirTypes.STOREOP
       (MirTypes.ST, source1, target1, MirTypes.GP_IMM_ANY ~1)]
    end

  fun save_word32 source =
    let
      val target = MirTypes.GC.new()
    in
      (target, save_word32_in_reg(source, target))
    end

  val ident_fn = fn x => x

  fun make_closure(tags, free, statics, offset, env, closure,
		   funs_in_closure) =
    (* tags, the function tags this closure is for
     free, the list of free variables.
     statics, how many static gc objects to allow for in this closure.
     offset, where these live in the surrounding closure.
     env, the old env.
     closure, the old closure. *)
    let
      (* This is being changed to interlace code pointers in the closure *)
      (* with zeroes, in order to preserve the double word alignment *)
      val funs = 2 * length tags - 1
      (* Changed above n => 2*n-1 *)
      val free_size = length free
      val (tags, _) =
	Lists.number_from(tags, 0, 2, ident_fn)
      (* Changed above (1 for 2) *)
      val lambda_offset_list_list =
	map
	(fn (_, n) => #1 (Lists.number_from_by_one(free, 
                                                   statics+funs-n,
                                                   ident_fn)))
	tags
      (* This produces numberings of the free variables assuming the pointer
       (caller_closure) is some distance before the first free variable, as required
       for common closures for mutually recursive functions and functions
       containing static gc objects within them *)
      (* Pointer to newly created closure *)
      val reg_operand = MirTypes.GC_REG(MirTypes.GC.new())
      val cl_code_list =
	map
	(fn lv => cg_lvar_fn(lv, env, closure, funs_in_closure))
	free
      val (num_cl_code, _) =
	Lists.number_from_by_one(cl_code_list, funs + statics, ident_fn)
      val closure_size = funs + statics + free_size
      val start = ~1
      val clean_dynamics =
	map
	(fn arg as ((reg, code), i) =>
	 (case reg of
	    INT reg => ((reg, code), i)
	  | REAL _ =>
	      let
		val (reg', code') = send_to_reg(ONE reg)
	      in
		((reg', code @@ code'), i)
	      end
	    ))
	num_cl_code
      val copy_dynamics =
        appendl
	([MirTypes.COMMENT"Dynamic closure elements"] ::
	  map (fn ((reg, _), i) =>
	       [MirTypes.STOREOP(MirTypes.ST, reg_from_gp reg, reg_operand,
				 MirTypes.GP_IMM_ANY(start + 4*i))])
	  clean_dynamics)
      val setup_dynamics = appendl (map (#2 o #1) clean_dynamics)
(*
	Lists.reducer
	(fn (((_, code), _), l) => code @@ l)
	(clean_dynamics, [])
*)
      val copy_statics =
	let
	  val new_reg = MirTypes.GC.new()
	  fun copy_n(acc, how_many, from, to) =
	    if how_many <= 0 then acc
	    else
	      copy_n
	      (MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
				MirTypes.GC_REG callee_closure,
				MirTypes.GP_IMM_ANY(start + 4*from)) ::
	       MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg,
				reg_operand,
				MirTypes.GP_IMM_ANY(start + 4*to)) :: acc,
	       how_many-1, from+1, to+1)
	in
	  MirTypes.COMMENT"Static closure elements" ::
	  copy_n([], statics, offset, funs)
	end
      val closure_env_list (* as Mir_Env.CLOSURE_ENV map_map :: _ *) =
	map
	(fn x =>
	 Lists.reducel
	 (fn (x, y) => Mir_Env.add_closure_env(y, x))
	 (Mir_Env.empty_closure_env, x))
	lambda_offset_list_list
    in
      (reg_operand,
       Sexpr.CONS(Sexpr.ATOM setup_dynamics,
		  Sexpr.CONS
		  (Sexpr.ATOM(MirTypes.ALLOCATE
			      (MirTypes.ALLOC, reg_operand,
			       MirTypes.GP_IMM_INT closure_size) ::
			      copy_dynamics),
		   Sexpr.ATOM copy_statics)),
	closure_env_list)
    end

  (* Map function parameters onto a fixed set of registers *)
  local
    val caller_arg_regs = MirRegisters.caller_arg_regs
    val tail_arg_regs = MirRegisters.tail_arg_regs

    fun assign_regs regs args =
      let
        fun assign ([],regs,acc) = rev acc
          | assign (arg::rest,[reg],acc) = rev (reg::acc)
          | assign (arg::rest,reg::restregs,acc) = assign (rest,restregs,reg::acc)
          | assign (_,[],acc) = Crash.impossible "Not enough arg regs"
      in
        assign (args,regs,[])
      end
  in
    val assign_caller_regs = assign_regs caller_arg_regs
    val assign_tail_regs = assign_regs tail_arg_regs
    val assign_fp_regs = assign_regs MirRegisters.fp_arg_regs
  end

  fun do_app(debugger_information,
             regs, the_code as ((first, blocks, opt, last), values, procs),
	     regs', the_code' as ((first', blocks', opt', last'), values', procs')) =
    let
      (* First code generate to evaluate which function should be called, *)
      (* then evaluate the argument, then call the function *)

      val (fn_reg, fn_code) =
	case (regs, the_code) of
	  (ONE(INT reg), ((first, blocks, opt, last), values, procs)) =>
	    (reg,
	      ((Sexpr.CONS
		(Sexpr.ATOM[MirTypes.COMMENT"Evaluate function to be called"],
		 first),
	        blocks, opt, last), values, procs))
	| _ => Crash.impossible"STRUCT or NON_GC as FN"
      val arg_code =
	((Sexpr.CONS
	  (Sexpr.ATOM[MirTypes.COMMENT"Evaluate function argument"],
	   first'),
	  blocks', opt', last'), values', procs')
      val extra_code = send_to_given_reg(regs', caller_arg)
      val fn_reg_op = reg_from_gp fn_reg
      val res_reg = MirTypes.GC.new()
      val call_code =
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG caller_closure,
			  fn_reg),
	   MirTypes.COMMENT("Set up new closure pointer"),
	   MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG MirRegisters.global,
			    MirTypes.GC_REG caller_closure,
			    MirTypes.GP_IMM_ANY ~1),
	   MirTypes.COMMENT("Get address of code"),
	   let
	     val dest = MirTypes.REG(MirTypes.GC_REG MirRegisters.global)
	   in
	     MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information,[MirTypes.GC caller_arg])
	   end,
	   MirTypes.COMMENT("Call the function"),
	   MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
			   MirTypes.GP_GC_REG caller_arg),
	   MirTypes.COMMENT("And acquire result")]
    in
      (ONE(INT(MirTypes.GP_GC_REG res_reg)),
        combine(fn_code,
	  combine(arg_code,
	    ((Sexpr.CONS(Sexpr.ATOM extra_code, Sexpr.ATOM call_code), [],
	      NONE, Sexpr.NIL), [], []))))
    end

  datatype CallType = 
    LOCAL of Mir_Env.MirTypes.tag * Mir_Env.MirTypes.GC.T list * Mir_Env.MirTypes.FP.T list
  | SAMESET of int (* position in closure *)
  | EXTERNAL

  fun do_multi_app(debugger_information,
                   regs, ((first, blocks, opt, last), values, procs),
                   regs', ((first', blocks', opt', last'), values', procs'),
                   regs'', ((first'', blocks'', opt'', last''), values'', procs''),
                   calltype,
                   funs_in_closure, tag_list,
                   do_tail) =
    let
      (* Annotate the fn and arg code with some comments *)
      val fn_code =
        ((Sexpr.CONS
          (Sexpr.ATOM[MirTypes.COMMENT "Evaluate function to be called"],
           first),
          blocks, opt, last), values, procs)

      val arg_code =
	((Sexpr.CONS
	  (Sexpr.ATOM [MirTypes.COMMENT "Evaluate function argument"],
	   first'),
	  blocks', opt', last'), values', procs')

      val fp_arg_code =
	((Sexpr.CONS
	  (Sexpr.ATOM [MirTypes.COMMENT "Evaluate function argument"],
	   first''),
	  blocks'', opt'', last''), values'', procs'')

      (* Get the function and argument registers *)
      val fn_reg =
        case regs of
	  (ONE (INT reg)) => reg
	| _ => Crash.impossible"STRUCT or NON_GC as FN"

      val arg_register_list =
	case regs' of
          LIST many => many
        | ONE (INT(MirTypes.GP_IMM_INT 0)) => []
        | _ => Crash.impossible "Bad structure for multi arg call"

      val fp_arg_register_list =
        case regs'' of
          LIST many => many
        | ONE (INT(MirTypes.GP_IMM_INT 0)) => []
        | _ => Crash.impossible "Bad fp structure for multi arg call"

      (* Now put the argument into the right form for the function call *)
      val (real_arg_regs, real_fp_regs, real_closure_reg) =
        case calltype of
          LOCAL (_,regs,fp_regs) =>
            (regs, fp_regs,MirRegisters.tail_closure)
	| _ =>
            if do_tail 
              then (assign_tail_regs arg_register_list, 
                    assign_fp_regs fp_arg_register_list, 
                    MirRegisters.tail_closure)
            else (assign_caller_regs arg_register_list, 
                  assign_fp_regs fp_arg_register_list, 
                  caller_closure)

      val gp_arg_regs = map MirTypes.GC real_arg_regs @@ map MirTypes.FLOAT real_fp_regs

      val cleaned_regs_and_code =
        map
        (fn reg =>
         let
           val new_reg = MirTypes.GC.new()
           val code = send_to_given_reg(ONE reg, new_reg)
         in
           (INT(MirTypes.GP_GC_REG new_reg), code)
         end)
        arg_register_list
      val gc_regs = map #1 cleaned_regs_and_code
      val clean_code = appendl (map #2 cleaned_regs_and_code)

      val real_offset = 3

      fun send_to_given_fp_reg (REAL fp_reg,to_reg) =
        [MirTypes.UNARYFP(MirTypes.FMOVE, 
                          MirTypes.FP_REG to_reg,
                          fp_reg)]
        | send_to_given_fp_reg (INT (MirTypes.GP_GC_REG gc_reg),to_reg) =
        [MirTypes.STOREFPOP(MirTypes.FLD, MirTypes.FP_REG to_reg,
                            MirTypes.GC_REG gc_reg,
                            MirTypes.GP_IMM_ANY real_offset)]
        | send_to_given_fp_reg _ = Crash.impossible ("send_to_given_fp_reg")

      val fp_cleaned_regs_and_code =
        map
        (fn reg =>
         let
           val new_reg = MirTypes.FP.new()
           val code = send_to_given_fp_reg(reg, new_reg)
         in
           (REAL(MirTypes.FP_REG new_reg), code)
         end)
        fp_arg_register_list
      val fp_regs = map #1 fp_cleaned_regs_and_code
      val fp_clean_code = appendl (map #2 fp_cleaned_regs_and_code)
        
      (* The first clause deals with the situation where we have run out of *)
      (* real registers to pass arguments in, so we need to stack allocate *)
      val (setup_code,deallocate_size) =
        let
          fun make_setup_code (regs as (_::_::_),[r],acc) =
            let
              val (tuple_code,deallocate_size) =
                if do_tail 
                  (* If its a tail then alas we must heap allocate it *)
                  then (send_to_given_reg (LIST regs,r),0)
                else (stack_send_to_given_reg (LIST regs,r),Lists.length regs)
            in
              (rev (tuple_code::acc),deallocate_size)
            end
            | make_setup_code (reg::restreg,r::restr,acc) =
              make_setup_code (restreg,restr,send_to_given_reg(ONE reg, r)::acc)
            | make_setup_code ([],[],acc) = (rev acc,0)
            | make_setup_code _ = Crash.impossible "make_setup_code: formal & actual parameter mismatch"
        in
          make_setup_code (gc_regs,real_arg_regs,[])
        end

      val fp_setup_code =
        let
          fun make_setup_code (reg::restreg,r::restr,acc) =
              make_setup_code (restreg,restr,send_to_given_fp_reg(reg, r)::acc)
            | make_setup_code ([],[],acc) = rev acc
            | make_setup_code _ = Crash.impossible "make_setup_code: formal & actual parameter mismatch"
        in
          make_setup_code (fp_regs,real_fp_regs,[])
        end

      fun deallocate_code () =
	if deallocate_size > 0  then
	  [MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, deallocate_size)]
	else
	  []

      (* arg_code computes the function arguments, this code actual moves the args *)
      (* into the expected places *)
      val full_arg_code =
	combine(arg_code,
                combine (fp_arg_code,
                         ((Sexpr.ATOM (clean_code @@ fp_clean_code @@ 
                                       appendl setup_code @@ appendl fp_setup_code),
                           [], NONE, Sexpr.NIL),
                          [], [])))

      val res_reg = MirTypes.GC.new ()

      (* Code for a local function call *)
      fun local_tail_code (loop_tag) =
	[MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG real_closure_reg,
			MirTypes.GP_GC_REG callee_closure),
	 MirTypes.COMMENT("Set up new closure pointer"),
	 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag),
         (* The following code is required to keep the register allocator happy *)
	 (* It serves no other purpose, and will be discarded by the optimiser *)
	 (* as it is unreachable *)
         (* Unless it is here, RegisterPack can fail because res_reg is undefined *)
	 MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
			MirTypes.GP_GC_REG caller_arg),
	 MirTypes.COMMENT"And acquire result"]

      fun relative_code (pos) =
        (if pos = 0 then
           MirTypes.UNARY(MirTypes.MOVE, 
                          MirTypes.GC_REG real_closure_reg,
                           MirTypes.GP_GC_REG callee_closure)
         else
           MirTypes.BINARY(MirTypes.ADDU, MirTypes.GC_REG real_closure_reg,
                           MirTypes.GP_GC_REG callee_closure,
                           MirTypes.GP_IMM_INT(pos*2))) ::
        MirTypes.COMMENT("Set up new closure pointer") ::
        let
          val dest = MirTypes.TAG(Lists.nth(Lists.length tag_list + pos -
                                            funs_in_closure, tag_list))
                     handle Lists.Nth => Crash.impossible "nth in relative_code"
        in
          if do_tail then
            MirTypes.TAIL_CALL(MirTypes.TAIL, dest,gp_arg_regs)
          else
            MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information,gp_arg_regs)
        end ::
      MirTypes.COMMENT(if do_tail then
                         "Tail to the function"
                       else "Call the function") ::
      MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
                     MirTypes.GP_GC_REG caller_arg) ::
      MirTypes.COMMENT"And acquire result" ::
      deallocate_code ()

      fun indirect_code () =
	MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG real_closure_reg,
		       fn_reg) ::
	MirTypes.COMMENT("Set up new closure pointer") ::
	MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG MirRegisters.global,
			 MirTypes.GC_REG real_closure_reg,
			 MirTypes.GP_IMM_ANY ~1) ::
	MirTypes.COMMENT("Get address of code") ::
	let
	  val dest = MirTypes.REG(MirTypes.GC_REG MirRegisters.global)
	in
	  if do_tail then
	    MirTypes.TAIL_CALL(MirTypes.TAIL, dest, gp_arg_regs)
	  else
	    MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information,gp_arg_regs)
	end ::
        MirTypes.COMMENT(if do_tail then
			   "Tail to the function"
			 else "Call the function") ::
	MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
		       MirTypes.GP_GC_REG caller_arg) ::
	MirTypes.COMMENT("And acquire result")::
        deallocate_code ()

      val call_code =
        case calltype of
          LOCAL (tag, regs, fp_regs) =>
            local_tail_code (tag)
        | SAMESET (pos) => 
            relative_code pos 
        | EXTERNAL => 
            indirect_code()
    in
      (ONE(INT(MirTypes.GP_GC_REG res_reg)), fn_code, full_arg_code, 
       ((Sexpr.ATOM (call_code), [], NONE,
         Sexpr.NIL), [], []))
    end (* of do_multi_app *)

    val empty_string_tree = Map.empty (String.<,op= : string * string -> bool)

    fun find_var(trees as (var_tree, exn_tree, str_tree, fun_tree, string_tree), string) =
      case Map.tryApply'(var_tree, string) of
	SOME lv => (trees, lv)
      | _ =>
	  let
	    val lv = LambdaTypes.new_LVar()
	  in
	    ((Map.define(var_tree, string, lv), exn_tree, str_tree, fun_tree, string_tree),
	     lv)
	  end

    fun find_exn(trees as (var_tree, exn_tree, str_tree, fun_tree, string_tree), string) =
      case Map.tryApply'(exn_tree, string) of
	SOME lv => (trees, lv)
      | _ =>
	  let
	    val lv = LambdaTypes.new_LVar()
	  in
	    ((var_tree, Map.define(exn_tree, string, lv), str_tree, fun_tree, string_tree),
	     lv)
	  end

    fun find_str(trees as (var_tree, exn_tree, str_tree, fun_tree, string_tree), string) =
      case Map.tryApply'(str_tree, string) of
	SOME lv => (trees, lv)
      | _ =>
	  let
	    val lv = LambdaTypes.new_LVar()
	  in
	    ((var_tree, exn_tree, Map.define(str_tree, string, lv), fun_tree, string_tree),
	     lv)
	  end

    fun find_fun(trees as (var_tree, exn_tree, str_tree, fun_tree, string_tree), string) =
      case Map.tryApply'(fun_tree, string) of
	SOME lv => (trees, lv)
      | _ =>
	  let
	    val lv = LambdaTypes.new_LVar()
	  in
	    ((var_tree, exn_tree, str_tree, Map.define(fun_tree, string, lv), string_tree),
	     lv)
	  end

    fun find_ext(trees as (var_tree, exn_tree, str_tree, fun_tree, string_tree), string) =
      case Map.tryApply'(string_tree, string) of
	SOME lv => (trees, lv)
      | _ =>
	  let
	    val lv = LambdaTypes.new_LVar()
	  in
	    ((var_tree, exn_tree, str_tree, fun_tree, Map.define(string_tree, string, lv)),
	     lv)
	  end

    fun lift_externals(arg as (trees, {lexp=AugLambda.APP
				       ({lexp=AugLambda.BUILTIN(prim,_), ...},
					([{lexp=AugLambda.SCON(Ident.STRING chars, NONE),
                                           ...}],[]),
                                        _),
                                       ...})) =
      (case prim of
	 Pervasives.LOAD_VAR =>
	   let
	     val (trees, lv) = find_var(trees, chars)
	   in
	     (trees, {lexp=AugLambda.VAR lv, size=0})
	   end
       | Pervasives.LOAD_EXN =>
	   let
	     val (trees, lv) = find_exn(trees, chars)
	   in
	     (trees, {lexp=AugLambda.VAR lv, size=0})
	   end
       | Pervasives.LOAD_STRUCT =>
	   let
	     val (trees, lv) = find_str(trees, chars)
	   in
	     (trees, {lexp=AugLambda.VAR lv, size=0})
	   end
       | Pervasives.LOAD_FUNCT =>
	   let
	     val (trees, lv) = find_fun(trees, chars)
	   in
	     (trees, {lexp=AugLambda.VAR lv, size=0})
	   end
       | Pervasives.LOAD_STRING =>
	   let
	     val (trees, lv) = find_ext(trees, chars)
	   in
	     (trees, {lexp=AugLambda.VAR lv, size=0})
	   end
       | _ => arg)
      | lift_externals(trees, {lexp=AugLambda.APP(le, (lel,fpel),debug), size=size}) =
	let
	  val (trees, le) = lift_externals(trees, le)
	  val (trees, lel) = lift_externals_list (trees, [], lel)
	  val (trees, fpel) = lift_externals_list (trees, [], fpel)
	in
	  (trees, {lexp=AugLambda.APP(le, (lel,fpel),debug), size=size})
	end
      | lift_externals(trees, {lexp=AugLambda.LET((lv, info,lb), le), size=size}) =
	let
	  val (trees, lb) = lift_externals(trees, lb)
	  val (trees, le) = lift_externals(trees, le)
	in
	  (trees, {lexp=AugLambda.LET((lv,info,lb),le), size=size})
	end
      | lift_externals(trees, {lexp=AugLambda.FN(lv, le, name, instances), size=size}) =
	let
	  val (trees, le) = lift_externals(trees, le)
	in
	  (trees, {lexp=AugLambda.FN(lv, le, name, instances), size=size})
	end
      | lift_externals(trees, {lexp=AugLambda.STRUCT le_list, size=size}) =
	let
	  val (trees, le_list) = lift_externals_list(trees, [], le_list)
	in
	  (trees, {lexp=AugLambda.STRUCT le_list, size=size})
	end
      | lift_externals(trees, {lexp=AugLambda.SELECT(field, le), size=size}) =
	let
	  val (trees, le) = lift_externals(trees, le)
	in
	  (trees, {lexp=AugLambda.SELECT(field, le), size=size})
	end
      | lift_externals(trees, {lexp=AugLambda.SWITCH(le, info, tag_le_list, opt),
			       size=size}) =
	let
	  val (trees, opt) = case opt of
	    SOME le =>
	      let
		val (trees, le) = lift_externals(trees, le)
	      in
		(trees, SOME le)
	      end
	  | _ => (trees, opt)
	  val (trees, le) = lift_externals(trees, le)
	  val (trees, tag_le_list) =
	    lift_externals_tag_le_list(trees, [], tag_le_list)
	in
	  (trees, {lexp=AugLambda.SWITCH(le, info, tag_le_list, opt),
		   size=size})
	end
      | lift_externals(arg as (_, {lexp=AugLambda.VAR _, ...})) =
	arg
      | lift_externals(trees, {lexp=AugLambda.LETREC(lv_list, le_list, le),
			       size=size}) =
	let
	  val (trees, le) = lift_externals(trees, le)
	  val (trees, le_list) = lift_externals_list(trees, [], le_list)
	in
	  (trees, {lexp=AugLambda.LETREC(lv_list, le_list, le), size=size})
	end
      | lift_externals(arg as (_, {lexp=AugLambda.INT _, ...})) = arg
      | lift_externals(arg as (_, {lexp=AugLambda.SCON _, ...})) = arg
      | lift_externals(arg as (_, {lexp=AugLambda.MLVALUE _, ...})) = arg
      | lift_externals(trees, {lexp=AugLambda.HANDLE(le, le'), size=size}) =
	let
	  val (trees, le) = lift_externals(trees, le)
	  val (trees, le') = lift_externals(trees, le')
	in
	  (trees, {lexp=AugLambda.HANDLE(le, le'), size=size})
	end
      | lift_externals(trees, {lexp=AugLambda.RAISE (le), size=size}) =
	let
	  val (trees, le) = lift_externals(trees, le)
	in
	  (trees, {lexp=AugLambda.RAISE (le), size=size})
	end
      | lift_externals(arg as (_, {lexp=AugLambda.BUILTIN _, ...})) = arg

    and lift_externals_list(trees, acc, []) = (trees, rev acc)
      | lift_externals_list(trees, acc, x :: xs) =
	let
	  val (trees, x) = lift_externals(trees, x)
	in
	  lift_externals_list(trees, x :: acc, xs)
	end

    and lift_externals_tag_le_list(trees, acc, []) = (trees, rev acc)
      | lift_externals_tag_le_list(trees, acc, (tag, le) :: rest) =
	let
	  val (trees, tag) = case tag of
	    AugLambda.EXP_TAG le =>
	      let
		val (trees, le) = lift_externals(trees, le)
	      in
		(trees, AugLambda.EXP_TAG le)
	      end
	  | _ => (trees, tag)
	  val (trees, le) = lift_externals(trees, le)
	in
	  lift_externals_tag_le_list(trees, (tag, le) :: acc, rest)
	end

    fun get_string{lexp=AugLambda.APP
		   ({lexp=AugLambda.BUILTIN(prim,_), ...},
		    ([{lexp=AugLambda.SCON(Ident.STRING chars, NONE), ...}],[]),_), ...} =
      if prim = Pervasives.LOAD_STRING then Set.singleton chars
      else Set.empty_set
      | get_string{lexp=AugLambda.APP(le, (lel,fpel),_), ...} =
	Lists.reducel
	(fn (set, le) => Set.union(set, get_string le))
	(get_string le, lel @@ fpel)
      | get_string{lexp=AugLambda.LET((_,_,lb),le),...} = 
      Set.union(get_string lb, get_string le)
      | get_string{lexp=AugLambda.FN(_, le,_,_), ...} = get_string le
      | get_string{lexp=AugLambda.STRUCT le_list, ...} =
	Lists.reducel
	(fn (set, le) => Set.union(set, get_string le))
	(Set.empty_set, le_list)
      | get_string{lexp=AugLambda.SELECT(_, le), ...} = get_string le
      | get_string{lexp=AugLambda.SWITCH _, ...} = Set.empty_set
      | get_string{lexp=AugLambda.VAR _, ...} = Set.empty_set
      | get_string{lexp=AugLambda.LETREC _, ...} = Set.empty_set
      | get_string{lexp=AugLambda.INT _, ...} = Set.empty_set
      | get_string{lexp=AugLambda.SCON _, ...} = Set.empty_set
      | get_string{lexp=AugLambda.MLVALUE _, ...} = Set.empty_set
      | get_string{lexp=AugLambda.HANDLE _, ...} = Set.empty_set
      | get_string{lexp=AugLambda.RAISE _, ...} = Set.empty_set
      | get_string{lexp=AugLambda.BUILTIN _, ...} = Set.empty_set

    (* See if we must lift out any references in the tree *)
    fun transform_needed(bad, {lexp=AugLambda.APP
			 ({lexp=AugLambda.BUILTIN(prim,_), ...}, (lel,fpel), _), ...}) =
      (case prim of
	 Pervasives.LOAD_STRING => bad
       | Pervasives.LOAD_VAR => true
       | Pervasives.LOAD_EXN => true
       | Pervasives.LOAD_FUNCT => true
       | Pervasives.LOAD_STRUCT => true
       | _ => Lists.exists (fn le => transform_needed(bad, le)) (fpel @@ lel))
      | transform_needed(bad, {lexp=AugLambda.APP(le, (lel,fpel),_), ...}) =
	transform_needed(bad, le) orelse  Lists.exists (fn le => transform_needed (bad, le)) (fpel @@ lel)
      | transform_needed(bad, {lexp=AugLambda.LET((_,_,lb),le),...}) = 
	transform_needed(bad, lb) orelse transform_needed(bad, le)
      | transform_needed(_, {lexp=AugLambda.FN(_, le,_,_), ...}) = transform_needed(true, le)
      | transform_needed(bad, {lexp=AugLambda.STRUCT le_list, ...}) =
	Lists.exists
	(fn le => transform_needed(bad, le))
	le_list
      | transform_needed(bad, {lexp=AugLambda.SELECT(_, le), ...}) = transform_needed(bad, le)
      | transform_needed(_, {lexp=AugLambda.SWITCH(le, _, tag_le_list, le_opt),
			     ...}) =
	transform_needed(true, le) orelse
	Lists.exists
	(fn (tag, le) =>
	 transform_needed(true, le) orelse
	 (case tag of
	    AugLambda.EXP_TAG le => transform_needed(true, le)
	  | _ => false))
	tag_le_list orelse
	(case le_opt of
	   SOME le => transform_needed(true, le)
	 | _ => false)
      | transform_needed(_, {lexp=AugLambda.VAR _, ...}) = false
      | transform_needed(_, {lexp=AugLambda.LETREC(_, le_list, le), ...}) =
	Lists.exists
	(fn le => transform_needed(true, le))
	(le :: le_list)
      | transform_needed(_, {lexp=AugLambda.INT _, ...}) = false
      | transform_needed(_, {lexp=AugLambda.SCON _, ...}) = false
      | transform_needed(_, {lexp=AugLambda.MLVALUE _, ...}) = false
      | transform_needed(_, {lexp=AugLambda.HANDLE(le, le'), ...}) =
	transform_needed(true, le) orelse transform_needed(true, le')
      | transform_needed(_, {lexp=AugLambda.RAISE le, ...}) =
	transform_needed(true, le)
      | transform_needed(_, {lexp=AugLambda.BUILTIN _, ...}) = false

    fun needs_prim_stringeq(AugLambda.VAR _) = false
      | needs_prim_stringeq(AugLambda.FN(_, {lexp=lexp, ...}, _,_)) =
	needs_prim_stringeq lexp
      | needs_prim_stringeq(AugLambda.LET((_,_, {lexp=bind,...}), {lexp=expr,...})) =
	needs_prim_stringeq bind orelse needs_prim_stringeq expr
      | needs_prim_stringeq(AugLambda.LETREC(_, le_list, {lexp=le, ...})) =
	needs_prim_stringeq le orelse
	Lists.exists
	(fn {lexp=lexp, size=_} => needs_prim_stringeq lexp)
	le_list
      | needs_prim_stringeq(AugLambda.APP({lexp=le, ...}, (el,fpel),_)) =
	needs_prim_stringeq le orelse 
	Lists.exists
	(fn {lexp=lexp, size=_} => needs_prim_stringeq lexp)
	(fpel @@ el)
      | needs_prim_stringeq(AugLambda.SCON _) = false
      | needs_prim_stringeq(AugLambda.MLVALUE _) = false
      | needs_prim_stringeq(AugLambda.INT _) = false
      | needs_prim_stringeq(AugLambda.SWITCH({lexp=le, ...}, _, tag_le_list, opt)) =
	needs_prim_stringeq le orelse
	needs_prim_stringeq_opt opt orelse
	Lists.exists needs_prim_stringeq_tag tag_le_list
      | needs_prim_stringeq(AugLambda.STRUCT le_list) =
	Lists.exists
	(fn {lexp=lexp, size=_} => needs_prim_stringeq lexp)
	le_list
      | needs_prim_stringeq(AugLambda.SELECT(_, {lexp=lexp, ...})) =
	needs_prim_stringeq lexp
      | needs_prim_stringeq(AugLambda.RAISE({lexp=lexp, ...})) =
	needs_prim_stringeq lexp
      | needs_prim_stringeq(AugLambda.HANDLE({lexp=le, ...}, {lexp=le', ...})) =
	needs_prim_stringeq le orelse
	needs_prim_stringeq le'
      | needs_prim_stringeq(AugLambda.BUILTIN _) = false

    and needs_prim_stringeq_opt(SOME {lexp=lexp, size=_}) =
      needs_prim_stringeq lexp
      | needs_prim_stringeq_opt NONE = false

    and needs_prim_stringeq_tag(tag, {lexp=lexp, size=_}) =
      case tag of
	AugLambda.SCON_TAG(Ident.STRING _, _) => true
      | _ => needs_prim_stringeq lexp

end
@


1.67.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.67  1998/08/26  13:43:21  jont
 * [Bug #20119]
 * Stop combine creating empty blocks
 *
@


1.66
log
@[Bug #1938]
Remove __pre_basis from require list
@
text
@d4 4
d987 10
a996 3
                 (first, 
                  MirTypes.BLOCK(tag_val,contract_sexpr(Sexpr.CONS(last,first'))) :: blocks @@ blocks',
                  tag', last'))
@


1.66.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.66  1997/03/06  16:03:34  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.66.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.66  1997/03/06  16:03:34  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.66.1.1
log
@branched from 1.66
@
text
@a3 4
 * Revision 1.66  1997/03/06  16:03:34  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.66.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.66.1.1  1997/05/12  10:32:32  hope
 * branched from 1.66
 *
@


1.66.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.66.1.1  1997/05/12  10:32:32  hope
 * branched from 1.66
 *
@


1.66.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.66.1.1  1997/05/12  10:32:32  hope
 * branched from 1.66
 *
@


1.66.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.66.1.1.1.1  1997/07/28  18:18:16  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.65
log
@Rationalizing MIR arithmetic.
@
text
@d4 3
a225 1
require "^.basis.__pre_basis";
@


1.64
log
@Simplifications and rationalizations
@
text
@d4 3
d905 1
a905 1
	    [MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG new_reg,
d1417 1
a1417 1
           MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG real_closure_reg,
@


1.63
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d166 1
a166 1
Mir_Env now uses NewMap instead of Map.
d267 1
a267 1
  structure NewMap = Datatypes.NewMap
a273 2
  open MLWorks.Option

d648 1
a648 1
	   [{size=0,
d657 1
a657 1
		[{size=0,
d662 1
a662 1
		  }],
d667 1
a667 1
	     }],
d769 1
a769 1
	   [{size=0,
d778 1
a778 1
		[{size=0,
d789 1
a789 1
		 }],
d794 1
a794 1
	     }],
d871 1
d891 1
a1068 9
  fun gc_list_positions(_, _, [], done) = rev done
    | gc_list_positions(prev_total:int, size_fn, le :: rest, done) =
      let
	val this_size = size_fn le
      in
	gc_list_positions(prev_total + this_size, size_fn, rest,
			  prev_total :: done)
      end

d1090 3
a1092 2
	(fn (_, n) => #1 (Lists.number_from_by_one(free, statics+funs-n,
						ident_fn)))
d1171 20
d1240 4
a1243 70
    fun build_args_for_tail(int_reg_list, regs) =
      (* Build up a tupled arg for a tail recursion *)
      (* Note that this assumes that int_reg_list is in order *)
      let
	val (gc_regs, code) = case regs of
	  LIST regs =>
	    let
	      val cleaned_regs_and_code =
		map
		(fn reg =>
		 let
		   val new_reg = MirTypes.GC.new()
		   val code = send_to_given_reg(ONE reg, new_reg)
		 in
		   (INT(MirTypes.GP_GC_REG new_reg), code)
		 end)
		regs
	      val code = appendl (map #2 cleaned_regs_and_code)
(*
		Lists.reducer
		(fn ((_, y), x) => y @@ x)
		(cleaned_regs_and_code, [])
*)
	    in
	      (map #1 cleaned_regs_and_code, code)
	    end
	| ONE reg =>
	    (case int_reg_list of
	      [] => ([reg], [])
	    | _ =>
		(* Need to detuple here before we can use the value *)
		let
		  val (ok_reg, ok_code) = send_to_reg regs
		  val ok_reg = reg_from_gp ok_reg
		  val new_regs_and_code =
		    map
		    (fn (i, _) =>
		     let
		       val new_reg = MirTypes.GC.new()
		       val code =
			 MirTypes.STOREOP(MirTypes.LD,
					  MirTypes.GC_REG new_reg, ok_reg,
					  MirTypes.GP_IMM_ANY(i * 4 - 1))
		     in
		       (INT(MirTypes.GP_GC_REG new_reg), code)
		     end)
		    int_reg_list
		  val (regs, code) = Lists.unzip new_regs_and_code
		  val code = ok_code @@ code
		in
		  (regs, code)
		end)
      in
	case int_reg_list of
	  [] => send_to_given_reg(regs, caller_arg)
	| _ =>
            appendl
	    (code ::
	     map
	     (fn (i, MirTypes.GC r) =>
	      (send_to_given_reg(ONE(Lists.nth(i, gc_regs)), r)
	       handle Lists.Nth =>
		 Crash.impossible("Lists.Nth in build_args_for_tail\nn = " ^
				  Int.toString i ^
				  " but list length = " ^
				  Int.toString(length gc_regs) ^
				  "\n"))
	     | _ => Crash.impossible"build_args_for_tail gets non-gc reg")
	     int_reg_list)
      end
d1245 14
a1258 49
  fun new_do_app(debugger_information,
                 regs, the_code as ((first, blocks, opt, last), values, procs),
		 regs', the_code' as ((first', blocks', opt', last'), values', procs'),
                 loop_tag, tuple_bindings,
		 args_escape, 
		 is_same_set, pos, funs_in_closure, tag_list,
		 tail_position, opt_tail_calls, opt_self_calls) =
    let
      (* The arguments are exactly as code generated by cg_sub *)
      (* args_escape relate to the callee *)
      (* and means that the argument may be returned outside *)
      (* the function itself by some means (eg ref, return, raise) *)
      (* tuple_bindings is an (int, reg) list giving the positions in the *)
      (* argument tuple of each register selected off it *)
      (* For a multi-argument function where the argument escapes *)
      (* or is referenced internally tuple_bindings contains a single *)
      (* binding to the place to which the argument is moved on function *)
      (* entry, as if the function took a single argument *)
      (* is_same_set says the function being called is in the same recursive *)
      (* set as the caller. *)
      (* loop_tag is a re_entry point for self tail recursive functions *)
      (* pos is the position within the caller closure of the callee *)
      (* is_same_set andalso pos = 0 => we are calling ourselves *)
      (* funs_in_closure is the number of functions, including the caller, *)
      (* within the caller closure with non-negative offset *)
      (* tag_list is the set of all tags for procedures in the current *)
      (* mutually recursive set *)
      (* tail_position indicates that we are in the tail position *)

      val is_same_fn = is_same_set andalso pos = 0

      (* This means that the function in which we are takes a tuple argument *)
      (* Moved here from _mir_cg *)
      val has_tupled_arg = length tuple_bindings > 1

      (* Used to have this.  Replaced with false *)
      (* val args_reused = length tuple_bindings = 1 andalso has_tupled_arg *)

      val _ = Diagnostic.output 5 (fn _ => ["pos = " ^ Int.toString pos])
      val _ = Diagnostic.output 5 (fn _ => [if is_same_fn then "Same fn" else "Not same fn"])

      val do_tail = tail_position andalso 
        (* This might be the same as:
         (is_same_fn and opt_self_calls) or (not is_same_fn and opt_tail_calls) 
        *)
        (is_same_fn orelse opt_tail_calls) andalso
        (not is_same_fn orelse opt_self_calls)

      (* Get the function to a register *)
a1259 11
      val (fn_reg, fn_code) =
	case regs of
	  (ONE(INT reg)) =>
	    (reg,
             ((Sexpr.CONS
               (Sexpr.ATOM[MirTypes.COMMENT "Evaluate function to be called"],
                first),
               blocks, opt, last), values, procs))
	| _ => Crash.impossible"STRUCT or NON_GC as FN"

      (* Code for the parameters.  This might be detupled *)
d1266 5
a1270 142
      val (args_are_tuple, tuple_size) =
	case regs' of
	  ONE _ => (false, 0)
	| LIST many => (true, length many)

      (* Now put the argument into the right form for the function call *)

      val (real_arg_reg, real_closure_reg) =
	if do_tail 
          then (MirRegisters.tail_arg, MirRegisters.tail_closure)
	else (caller_arg, caller_closure)
          
      val (has_tail_arg, single_tail_arg, tuple_bindings') =
	case tuple_bindings of
	  (_, MirTypes.GC reg) :: rest => (true, reg, rest)
	| _ => (false, MirTypes.GC.new(), [])

      (* Regretfully, we can't do self call stuff when args escape, which *)
      (* includes when we are compiling for interception *)
      val do_self_call = is_same_set andalso is_same_fn andalso do_tail andalso not args_escape

      val (do_deallocate, deallocate_size, extra_arg_code) =
        if has_tupled_arg (* ie. the current function accepts detupled args *)
          then
            if is_same_fn andalso do_tail andalso not args_escape 
              then (false, 0, build_args_for_tail(tuple_bindings', regs'))
            else if args_escape orelse do_tail 
              then (false, 0, send_to_given_reg(regs', real_arg_reg))
            else (args_are_tuple, tuple_size, stack_send_to_given_reg (regs', real_arg_reg))
        else
          if do_self_call then
            if has_tail_arg then
              (false, 0,
               let val tmp_reg = MirTypes.GC.new()
               in
                 send_to_given_reg(regs', tmp_reg) @@
                 [MirTypes.UNARY (MirTypes.MOVE,
                                  MirTypes.GC_REG single_tail_arg,
                                  MirTypes.GP_GC_REG tmp_reg)]
               end)
            else
              Crash.impossible "Request for tail arg when none given"
          else if args_escape orelse do_tail 
            then (false, 0, send_to_given_reg(regs', real_arg_reg))
          else
	    (args_are_tuple, tuple_size,stack_send_to_given_reg(regs', real_arg_reg))

      val arg_code =
	combine(arg_code,
		((Sexpr.ATOM extra_arg_code, [], NONE, Sexpr.NIL),
		 [], []))

      val res_reg = MirTypes.GC.new ()

      fun deallocate_code () =
	if do_deallocate then
	  [MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, deallocate_size)]
	else
	  []

      fun self_tail_code () =
	[MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG real_closure_reg,
			MirTypes.GP_GC_REG callee_closure),
	 MirTypes.COMMENT("Set up new closure pointer"),
	 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag),
	 (* The following code is required to keep the register allocator happy *)
	 (* It serves no other purpose, and will be discarded by the optimiser *)
	 (* as it is unreachable *)
	 MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
			MirTypes.GP_GC_REG caller_arg),
	 MirTypes.COMMENT"And acquire result"]

      fun relative_code () =
	if is_same_set then
	  (if pos = 0 then
	     MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG real_closure_reg,
			    MirTypes.GP_GC_REG callee_closure)
	   else
	     MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG real_closure_reg,
			     MirTypes.GP_GC_REG callee_closure,
			     MirTypes.GP_IMM_INT(pos*2))) ::
	  MirTypes.COMMENT("Set up new closure pointer") ::
	  let
	    val dest = MirTypes.TAG(Lists.nth(length tag_list + pos -
					      funs_in_closure, tag_list))
	      handle Lists.Nth =>
		Crash.impossible("Lists.Nth in new_do_app\nn = " ^
				 Int.toString(length tag_list +
						    pos -
						    funs_in_closure) ^
				 " but list length = " ^
				 Int.toString(length tag_list) ^
				 "\n")
	  in
	    if do_tail then
	      MirTypes.TAIL_CALL(MirTypes.TAIL, dest,[MirTypes.GC MirRegisters.tail_arg])
	    else
	      MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information,[MirTypes.GC caller_arg])
	  end ::
	  MirTypes.COMMENT(if do_tail then
			     "Tail to the function"
			   else "Call the function") ::
	  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
			 MirTypes.GP_GC_REG caller_arg) ::
	  MirTypes.COMMENT"And acquire result" :: deallocate_code ()
	else
	  Crash.impossible "Relative code when not same set"

      fun indirect_code () =
	MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG real_closure_reg,
		       fn_reg) ::
	MirTypes.COMMENT("Set up new closure pointer") ::
	MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG MirRegisters.global,
			 MirTypes.GC_REG real_closure_reg,
			 MirTypes.GP_IMM_ANY ~1) ::
	MirTypes.COMMENT("Get address of code") ::
	let
	  val dest = MirTypes.REG(MirTypes.GC_REG MirRegisters.global)
	in
	  if do_tail then
	    MirTypes.TAIL_CALL(MirTypes.TAIL, dest,[MirTypes.GC MirRegisters.tail_arg])
	  else
	    MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information,[MirTypes.GC caller_arg])
	end ::
        MirTypes.COMMENT(if do_tail then
			   "Tail to the function"
			 else "Call the function") ::
	MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
		       MirTypes.GP_GC_REG caller_arg) ::
	MirTypes.COMMENT("And acquire result") :: deallocate_code ()

      val call_code =
        if do_self_call
          then self_tail_code()
        else if is_same_set 
          then relative_code()
        else indirect_code()
    in
      (ONE(INT(MirTypes.GP_GC_REG res_reg)), fn_code, arg_code, 
       ((Sexpr.ATOM (call_code), [], NONE,
                      Sexpr.NIL), [], []))
    end (* of new_do_app *)
d1272 4
a1275 45
  (* Map function parameters onto a fixed set of registers *)
  local
    val caller_arg_regs = MirRegisters.caller_arg_regs
    val tail_arg_regs = MirRegisters.tail_arg_regs

    fun assign_regs regs args =
      let
        fun assign ([],regs,acc) = rev acc
          | assign (arg::rest,[reg],acc) = rev (reg::acc)
          | assign (arg::rest,reg::restregs,acc) = assign (rest,restregs,reg::acc)
          | assign (_,[],acc) = Crash.impossible "Not enough arg regs"
      in
        assign (args,regs,[])
      end
  in
    val assign_caller_regs = assign_regs caller_arg_regs
    val assign_tail_regs = assign_regs tail_arg_regs
  end

  fun do_multi_app(debugger_information,
                   regs, the_code as ((first, blocks, opt, last), values, procs),
                   regs', the_code' as ((first', blocks', opt', last'), values', procs'),
                   loop_tag, tuple_bindings,
                   is_same_set, pos, funs_in_closure, tag_list,
                   tail_position, opt_tail_calls,opt_self_calls) =
    let
      val do_self_tail = tail_position andalso opt_self_calls andalso is_same_set andalso pos = 0
      val do_tail = tail_position andalso opt_tail_calls

      val _ = 
        Diagnostic.output 2
        (fn _ =>
         if do_self_tail then ["Doing self tail multi call"]
         else if do_tail then ["Doing tail multi call"]
         else ["Doing multi call"])

      (* Get the function to a register *)
      val (fn_reg, fn_code) =
	case regs of
	  (ONE(INT reg)) =>
	    (reg,
             ((Sexpr.CONS
               (Sexpr.ATOM[MirTypes.COMMENT "Evaluate function to be called"],
                first),
               blocks, opt, last), values, procs))
a1277 7
      val arg_code =
	((Sexpr.CONS
	  (Sexpr.ATOM [MirTypes.COMMENT "Evaluate function argument"],
	   first'),
	  blocks', opt', last'), values', procs')

      (* Get the registers with the arguments in *)
d1284 5
a1288 5
      fun assign_self_regs reglist =
        map 
        (fn (_,MirTypes.GC r) => r
      | _ => Crash.impossible "Bad reg in tuple binding")
        tuple_bindings
d1291 12
d1304 1
a1304 8
      val (real_arg_regs, real_closure_reg) =
        if do_self_tail
          then (assign_self_regs arg_register_list, MirRegisters.tail_closure)
	else if do_tail 
          then (assign_tail_regs arg_register_list, MirRegisters.tail_closure)
	else (assign_caller_regs arg_register_list, caller_closure)

      val used_arg_regs = map MirTypes.GC real_arg_regs
d1316 14
a1329 7
      val code = appendl (map #2 cleaned_regs_and_code)
(*
        Lists.reducer
        (fn ((_, y), x) => y @@ x)
        (cleaned_regs_and_code, [])
*)
      val (gc_regs, code) = (map #1 cleaned_regs_and_code, code)
d1331 16
a1346 1
      fun make_setup_code (regs as (_::_::_),[r],acc) =
d1348 14
a1361 6
          (* val _ = output (std_out,"Doing tupled app\n") *)
          val (tuple_code,do_deallocate,deallocate_size) =
            if do_self_tail then Crash.impossible "self_tail in make_setup_code"
            else if do_tail then 
              (send_to_given_reg (LIST regs,r),false,0)
                 else (stack_send_to_given_reg (LIST regs,r),true,length regs)
d1363 1
a1363 1
          (rev (tuple_code::acc),do_deallocate,deallocate_size)
a1364 4
        | make_setup_code (reg::restreg,r::restr,acc) =
          make_setup_code (restreg,restr,send_to_given_reg(ONE reg, r)::acc)
        | make_setup_code ([],[],acc) = (rev acc,false,0)
        | make_setup_code _ = Crash.impossible "make_setup_code"
d1366 9
a1374 4
      val (setup_code,do_deallocate,deallocate_size) =
        make_setup_code (gc_regs,real_arg_regs,[])

      val extra_arg_code = code @@ (appendl setup_code)
d1377 1
a1377 1
	if do_deallocate then
d1382 3
a1384 1
      val arg_code =
d1386 5
a1390 2
		((Sexpr.ATOM extra_arg_code, [], NONE, Sexpr.NIL),
		 [], []))
d1394 2
a1395 1
      fun self_tail_code () =
d1400 1
a1400 1
	 (* The following code is required to keep the register allocator happy *)
d1403 1
d1408 27
a1434 32
      fun relative_code () =
	if is_same_set then
	  MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG real_closure_reg,
			  MirTypes.GP_GC_REG callee_closure,
			  MirTypes.GP_IMM_INT(pos*2)) ::
	  MirTypes.COMMENT("Set up new closure pointer") ::
	  let
	    val dest = MirTypes.TAG(Lists.nth(length tag_list + pos -
					      funs_in_closure, tag_list))
	      handle Lists.Nth =>
		Crash.impossible("Lists.Nth in do_multi_app\nn = " ^
				 Int.toString(length tag_list +
						    pos -
						    funs_in_closure) ^
				 " but list length = " ^
				 Int.toString(length tag_list) ^
				 "\n")
	  in
	    if do_tail then
	      MirTypes.TAIL_CALL(MirTypes.TAIL, dest,used_arg_regs)
	    else
	      MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information,used_arg_regs)
	  end ::
	  MirTypes.COMMENT(if do_tail then
			     "Tail to the function"
			   else "Call the function") ::
	  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
			 MirTypes.GP_GC_REG caller_arg) ::
	  MirTypes.COMMENT"And acquire result" ::
          deallocate_code ()
	else
	  Crash.impossible "Relative code when not same set"
d1448 1
a1448 1
	    MirTypes.TAIL_CALL(MirTypes.TAIL, dest,used_arg_regs)
d1450 1
a1450 1
	    MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information,used_arg_regs)
d1461 7
a1467 5
        if do_self_tail
          then self_tail_code ()
        else if is_same_set 
          then relative_code()
	else indirect_code()
d1469 1
a1469 1
      (ONE(INT(MirTypes.GP_GC_REG res_reg)), fn_code, arg_code, 
d1471 1
a1471 1
                      Sexpr.NIL), [], []))
d1474 1
a1474 107
    fun exit_block [] = NONE
    | exit_block((block as MirTypes.BLOCK(tag, opcode_list)) :: rest) =
      if Lists.exists
	(fn MirTypes.RTS => true | _ => false)
	opcode_list
	then SOME block
      else exit_block rest

    fun small_exit_block(MirTypes.BLOCK(_, opcode_list)) =
      Lists.filter_length
      (fn (MirTypes.COMMENT _) => false | _ => true)
      opcode_list
      <= 3

    fun do_shrink(_, _, []) = (false, [])
      | do_shrink(first, last, [MirTypes.RTS]) =
	(true, [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG last, first),
		MirTypes.RTS])
      | do_shrink(first, last,
		  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG to,
				 MirTypes.GP_GC_REG from) :: rest) =
	if from = last then
	  do_shrink(first, to, rest)
	else
	  (false, [])
      | do_shrink(first, last, (comm as MirTypes.COMMENT _) :: rest) =
	let
	  val (ok, list) = do_shrink(first, last, rest)
	in
	  if ok then
	    (ok, comm :: list)
	  else
	    (false, [])
	end
      | do_shrink _ = (false, [])

    fun real_length opc_list =
      Lists.filter_length
      (fn (MirTypes.COMMENT _) => false
       | _ => true)
      opc_list

    fun shrink_exit_block(block as MirTypes.BLOCK(tag, opcode_list)) =
      (* Attempt to remove useless register copying *)
      if real_length opcode_list > 4 then
	block
      else
	let
	  fun shrink_list [] = []
	    | shrink_list((comm as MirTypes.COMMENT _) :: rest) =
	      comm :: shrink_list rest
	    | shrink_list(list as (MirTypes.UNARY(MirTypes.MOVE,
						  MirTypes.GC_REG last,
						  first) :: rest)) =
	      let
		val (ok, new_list) = do_shrink(first, last, rest)
	      in
		if ok then
		  new_list
		else
		  list
	      end
	    | shrink_list list = list
	in
	  MirTypes.BLOCK(tag, shrink_list opcode_list)
	end

    fun append_small_exit(MirTypes.BLOCK(tag, opcode_list), block_list) =
      let
	fun do_block(block as MirTypes.BLOCK(tag', opc_list)) =
	  if Lists.exists
	    (fn (MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG t)) => tag = t
	    | _ => false)
	    opc_list then
	    (* Difficult case. Append the exit block onto the block *)
	    (* branching to it, and remove the branch and tag *)
	    let
	      val opc' = rev opc_list

	      fun get_new_opc_list((comm as MirTypes.COMMENT _) :: rest) =
		comm :: get_new_opc_list rest
	      | get_new_opc_list(MirTypes.BRANCH(MirTypes.BRA,
						 MirTypes.TAG t) ::
				 rest) =
		if t = tag then rest
		else
		  Crash.impossible
		    "harp get_new_opc (1) fails to find proper branch"
	      | get_new_opc_list _ =
		Crash.impossible
		  "harp get_new_opc (2) fails to find proper branch"

	      val new_opc = get_new_opc_list opc'
	      fun rev_app([], x) = x
	      | rev_app(y, []) = y
	      | rev_app(y :: ys, x) = rev_app(ys, y :: x)
	    in
	      shrink_exit_block
	      (MirTypes.BLOCK(tag', rev_app(new_opc, opcode_list)))
	    end
	  else
	    shrink_exit_block block
      in
	map do_block block_list
      end

    val empty_string_tree = NewMap.empty ((op<):string*string->bool,op= : string * string -> bool)
d1477 1
a1477 1
      case NewMap.tryApply'(var_tree, string) of
d1483 1
a1483 1
	    ((NewMap.define(var_tree, string, lv), exn_tree, str_tree, fun_tree, string_tree),
d1488 1
a1488 1
      case NewMap.tryApply'(exn_tree, string) of
d1494 1
a1494 1
	    ((var_tree, NewMap.define(exn_tree, string, lv), str_tree, fun_tree, string_tree),
d1499 1
a1499 1
      case NewMap.tryApply'(str_tree, string) of
d1505 1
a1505 1
	    ((var_tree, exn_tree, NewMap.define(str_tree, string, lv), fun_tree, string_tree),
d1510 1
a1510 1
      case NewMap.tryApply'(fun_tree, string) of
d1516 1
a1516 1
	    ((var_tree, exn_tree, str_tree, NewMap.define(fun_tree, string, lv), string_tree),
d1521 1
a1521 1
      case NewMap.tryApply'(string_tree, string) of
d1527 1
a1527 1
	    ((var_tree, exn_tree, str_tree, fun_tree, NewMap.define(string_tree, string, lv)),
d1533 2
a1534 2
					[{lexp=AugLambda.SCON(Ident.STRING chars, NONE),
                                          ...}],
d1569 1
a1569 1
      | lift_externals(trees, {lexp=AugLambda.APP(le, lel,debug), size=size}) =
d1573 1
d1575 1
a1575 1
	  (trees, {lexp=AugLambda.APP(le, lel,debug), size=size})
d1674 1
a1674 1
		    [{lexp=AugLambda.SCON(Ident.STRING chars, NONE), ...}],_), ...} =
d1677 1
a1677 1
      | get_string{lexp=AugLambda.APP(le, lel,_), ...} =
d1680 1
a1680 1
	(get_string le, lel)
d1701 1
a1701 1
			 ({lexp=AugLambda.BUILTIN(prim,_), ...}, lel, _), ...}) =
d1708 3
a1710 3
       | _ => Lists.exists (fn le => transform_needed(bad, le)) lel)
      | transform_needed(bad, {lexp=AugLambda.APP(le, lel,_), ...}) =
	transform_needed(bad, le) orelse  Lists.exists (fn le => transform_needed (bad, le)) lel
d1756 1
a1756 1
      | needs_prim_stringeq(AugLambda.APP({lexp=le, ...}, le_list,_)) =
d1760 1
a1760 1
	le_list
a1788 3

    fun lneeds_prim_stringeq le_list =
      Lists.exists (fn {lexp=lexp, size=_} => needs_prim_stringeq lexp) le_list
@


1.63.4.1
log
@branched from 1.63
@
text
@a3 4
 * Revision 1.63  1996/11/06  11:08:09  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.63.3.1
log
@branched from 1.63
@
text
@a3 4
 * Revision 1.63  1996/11/06  11:08:09  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.63.3.1.1.1
log
@branched from 1.63.3.1
@
text
@a3 3
 * Revision 1.63.3.1  1996/12/17  17:46:13  hope
 * branched from 1.63
 *
@


1.63.2.1
log
@branched from 1.63
@
text
@a3 4
 * Revision 1.63  1996/11/06  11:08:09  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.63.1.1
log
@branched from 1.63
@
text
@a3 4
 * Revision 1.63  1996/11/06  11:08:09  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.63.1.1.1.1
log
@branched from 1.63.1.1
@
text
@a3 3
 * Revision 1.63.1.1  1996/11/14  12:47:26  hope
 * branched from 1.63
 *
@


1.62
log
@[Bug #1725]
Remove unsafe string operations introduced when String structure removed
@
text
@d4 4
d213 1
a213 1
require "^.basis.__integer";
@


1.61
log
@[Bug #1614]
basifying String
@
text
@d4 4
d579 1
a579 1
	  if (MLWorks.Internal.Value.unsafe_string_sub (s, i) = ord #"0") then
@


1.60
log
@WORD32LSHIFT takes a word second argument now.
@
text
@d4 3
d205 4
a208 1
require "../basis/__integer";
d222 1
d357 1
a357 1
    val len = Lists.length reg_list
d415 1
a415 1
    val len = Lists.length reg_list
d418 1
a418 1
			      MLWorks.Option.NONE)
d472 1
a472 1
	    val new_digit = (String.ordof(chars, ptr) - String.ord"0")
d487 1
a487 1
	    val ord_digit = String.ordof(chars, ptr)
d489 9
a497 10
	      if ord_digit >= String.ord"0" andalso ord_digit <= String.ord"9" then
		ord_digit - String.ord"0"
	      else
		if ord_digit >= String.ord"a" andalso ord_digit <= String.ord"f" then
		  ord_digit - String.ord"a" + 10
		else
		  if ord_digit >= String.ord"A" andalso ord_digit <= String.ord"F" then
		    ord_digit - String.ord"A" + 10
		  else
		    Crash.impossible("convert_hex:bad digit:" ^ String.chr ord_digit)
d508 1
a508 1
  fun convert_int (chars, max_size_opt) =
d510 1
a510 4
      val (sign, ptr) = case String.substring(chars, 0, 1) of
	"~" => (false, 1)
	| _ => (true, 0)

d517 4
a520 3
	  case String.substring(chars, ptr, 2) of
	    "0x" => convert_hex chars (sign, ptr + 2, 0)
	  | _ => convert chars (sign, ptr, 0)
d522 13
a534 13
      case max_size_opt
      of MLWorks.Option.NONE =>
	number
      |  MLWorks.Option.SOME max_size => 
	let
	  val max_int = power (max_size - 1, 2, 1)
	  val min_int = ~max_int
	in
	  if number >= max_int orelse number < min_int then
	    raise Unrepresentable
	  else
	    number
        end
d536 1
a536 1
	  Overflow => number
d549 4
a552 3
	  case String.substring(chars, 0, 3) of
	    "0wx" => convert_hex chars (sign, 3, 0)
	  | _ => convert chars (sign, 2, 0)
d555 2
a556 2
      of MLWorks.Option.NONE => number
      |  MLWorks.Option.SOME max_size => 
d570 1
a570 1
  fun string_is_zero string =
d572 9
a580 1
      val exploded_string = String.explode string
d582 1
a582 3
      Lists.forall
      (fn "0" => true | _ => false)
      exploded_string
d621 1
a621 1
	 MLWorks.Option.NONE)
d631 1
a631 1
	     MLWorks.Option.NONE)
d664 1
a664 1
      val ptr = if String.ordof(chars, 0) = String.ord"~" then 1 else 0
d673 3
d677 1
a677 3
	  case String.substring(chars, ptr, 2) of
	    "0x" => BigNum.hex_string_to_bignum chars
	  | _ => BigNum.string_to_bignum chars
d691 4
a694 3
	  case String.substring(chars, 0, 3) of
	    "0wx" => BigNum.hex_word_string_to_bignum chars
	  | _ => BigNum.word_string_to_bignum chars
d744 1
a744 1
	 MLWorks.Option.SOME 32)
d753 1
a753 1
	     MLWorks.Option.SOME 32)
d777 1
a777 1
			 MLWorks.Option.NONE)
d791 1
a791 1
      val ptr = if String.ordof(chars, 0) = String.ord"~" then 1 else 0
d801 1
a801 1
	  case String.substring(chars, ptr, 2) of
d820 4
a823 3
	  case String.substring(chars, 0, 3) of
	    "0wx" => BigNum32.hex_word_string_to_bignum chars
	  | _ => BigNum32.word_string_to_bignum chars
d875 1
a875 1
          | MLWorks.Option.NONE => 
d953 1
a953 1
          MLWorks.Option.NONE =>
d958 1
a958 1
        | MLWorks.Option.SOME tag_val =>
d960 1
a960 1
               MLWorks.Option.NONE =>
d965 1
a965 1
             | MLWorks.Option.SOME tag_val' =>
d1079 1
a1079 1
      val funs = 2 * Lists.length tags - 1
d1081 1
a1081 1
      val free_size = Lists.length free
d1213 1
a1213 1
	      MLWorks.Option.NONE, Sexpr.NIL), [], []))))
d1281 1
a1281 1
				  Int.toString(Lists.length gc_regs) ^
d1320 1
a1320 1
      val has_tupled_arg = Lists.length tuple_bindings > 1
d1323 1
a1323 1
      (* val args_reused = Lists.length tuple_bindings = 1 andalso has_tupled_arg *)
d1357 1
a1357 1
	| LIST many => (true, Lists.length many)
d1403 1
a1403 1
		((Sexpr.ATOM extra_arg_code, [], MLWorks.Option.NONE, Sexpr.NIL),
d1437 1
a1437 1
	    val dest = MirTypes.TAG(Lists.nth(Lists.length tag_list + pos -
d1441 1
a1441 1
				 Int.toString(Lists.length tag_list +
d1445 1
a1445 1
				 Int.toString(Lists.length tag_list) ^
d1493 1
a1493 1
       ((Sexpr.ATOM (call_code), [], MLWorks.Option.NONE,
d1599 1
a1599 1
                 else (stack_send_to_given_reg (LIST regs,r),true,Lists.length regs)
d1621 1
a1621 1
		((Sexpr.ATOM extra_arg_code, [], MLWorks.Option.NONE, Sexpr.NIL),
d1645 1
a1645 1
	    val dest = MirTypes.TAG(Lists.nth(Lists.length tag_list + pos -
d1649 1
a1649 1
				 Int.toString(Lists.length tag_list +
d1653 1
a1653 1
				 Int.toString(Lists.length tag_list) ^
d1703 1
a1703 1
       ((Sexpr.ATOM (call_code), [], MLWorks.Option.NONE,
d1707 1
a1707 1
    fun exit_block [] = MLWorks.Option.NONE
d1712 1
a1712 1
	then MLWorks.Option.SOME block
d1813 1
a1813 1
    val empty_string_tree = NewMap.empty (String.<,op= : string * string -> bool)
@


1.60.3.1
log
@branched from 1.60
@
text
@a3 3
 * Revision 1.60  1996/05/21  15:37:19  matthew
 * WORD32LSHIFT takes a word second argument now.
 *
@


1.60.2.1
log
@branched from 1.60
@
text
@a3 3
 * Revision 1.60  1996/05/21  15:37:19  matthew
 * WORD32LSHIFT takes a word second argument now.
 *
@


1.60.1.1
log
@branched from 1.60
@
text
@a3 3
 * Revision 1.60  1996/05/21  15:37:19  matthew
 * WORD32LSHIFT takes a word second argument now.
 *
@


1.59
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d764 1
a764 1
			 MLWorks.Option.SOME 32)
@


1.58
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@@


1.57
log
@Removing MLWorks.Integer
@
text
@d4 3
d459 1
a459 1
	    val new_digit = (String.ordof(chars, ptr) - ord"0")
d476 2
a477 2
	      if ord_digit >= ord"0" andalso ord_digit <= ord"9" then
		ord_digit - ord"0"
d479 2
a480 2
		if ord_digit >= ord"a" andalso ord_digit <= ord"f" then
		  ord_digit - ord"a" + 10
d482 2
a483 2
		  if ord_digit >= ord"A" andalso ord_digit <= ord"F" then
		    ord_digit - ord"A" + 10
d485 1
a485 1
		    Crash.impossible("convert_hex:bad digit:" ^ chr ord_digit)
d561 1
a561 1
      val exploded_string = explode string
d647 1
a647 1
      val ptr = if String.ordof(chars, 0) = ord"~" then 1 else 0
d772 1
a772 1
      val ptr = if String.ordof(chars, 0) = ord"~" then 1 else 0
@


1.56
log
@Exception changes
@
text
@d4 3
d193 2
d318 1
a318 1
  	Crash.impossible ("get_word32 GP_IMM_INT " ^ MLWorks.Integer.makestring i)
d576 1
a576 1
      val biggest_num = BigNum.string_to_bignum(MLWorks.Integer.makestring longest_int)
d693 1
a693 1
        BigNum32.string_to_bignum(MLWorks.Integer.makestring longest_int)
d709 1
a709 1
    MLWorks.Integer.makestring longest_string_length
d1256 1
a1256 1
				  MLWorks.Integer.makestring i ^
d1258 1
a1258 1
				  MLWorks.Integer.makestring(Lists.length gc_regs) ^
d1302 1
a1302 1
      val _ = Diagnostic.output 5 (fn _ => ["pos = " ^ MLWorks.Integer.makestring pos])
d1418 1
a1418 1
				 MLWorks.Integer.makestring(Lists.length tag_list +
d1422 1
a1422 1
				 MLWorks.Integer.makestring(Lists.length tag_list) ^
d1626 1
a1626 1
				 MLWorks.Integer.makestring(Lists.length tag_list +
d1630 1
a1630 1
				 MLWorks.Integer.makestring(Lists.length tag_list) ^
@


1.55
log
@Add functions for saving raw 32 bit values as boxed values
@
text
@d4 3
d272 1
a272 1
    (find_largest_power(n+1, i*2)) handle Prod => n
d517 2
a518 3
        handle	(* if power raises Prod or Sum, then the number must fit *)
	  Prod => number
        | Sum => number
d520 1
a520 2
  handle Prod => raise ConvertInt
       | Sum => raise ConvertInt
d546 2
a547 3
        handle	(* if power raises Prod or Sum, then the number must fit *)
	  Prod => number
        | Sum => number
d549 1
a549 2
  handle Prod => raise ConvertInt
       | Sum => raise ConvertInt
d695 1
a695 1
    |  Prod =>
@


1.54
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d1010 18
@


1.53
log
@The routines for converting long integers were failing to handle minint.
@
text
@d4 3
d391 1
a391 1
			      MirTypes.Option.ABSENT)
d923 1
a923 1
          MirTypes.Option.ABSENT =>
d928 1
a928 1
        | MirTypes.Option.PRESENT tag_val =>
d930 1
a930 1
               MirTypes.Option.ABSENT =>
d935 1
a935 1
             | MirTypes.Option.PRESENT tag_val' =>
d1165 1
a1165 1
	      MirTypes.Option.ABSENT, Sexpr.NIL), [], []))))
d1355 1
a1355 1
		((Sexpr.ATOM extra_arg_code, [], MirTypes.Option.ABSENT, Sexpr.NIL),
d1445 1
a1445 1
       ((Sexpr.ATOM (call_code), [], MirTypes.Option.ABSENT,
d1573 1
a1573 1
		((Sexpr.ATOM extra_arg_code, [], MirTypes.Option.ABSENT, Sexpr.NIL),
d1655 1
a1655 1
       ((Sexpr.ATOM (call_code), [], MirTypes.Option.ABSENT,
d1659 1
a1659 1
    fun exit_block [] = MirTypes.Option.ABSENT
d1664 1
a1664 1
	then MirTypes.Option.PRESENT block
@


1.52
log
@Added new types for different sizes of ints, words, and reals.
@
text
@d4 3
d585 3
a587 2
  fun convert_long(bignum, arg as ((_, location), sign), max_size) =
    if BigNum.<=(bignum, biggest_num) then
d590 1
a590 2
	(LambdaTypes.Ident.INT
	   (add_sign((BigNum.bignum_to_string bignum, location), sign)),
d595 2
a596 2
	val head = BigNum.div(bignum, biggest_num)
	val tail = BigNum.mod(bignum, biggest_num)
d600 2
a601 3
	    (LambdaTypes.Ident.INT
	       (add_sign((BigNum.bignum_to_string tail, location), sign)),
	        MLWorks.Option.NONE)
d620 1
a620 1
		  [{size=0, lexp=convert_long(head, arg, max_size)},
d626 1
a626 1
	     {size=0, lexp=convert_long(tail, arg, max_size)}]
d632 1
a632 1
  fun convert_long_int (arg as ((chars, _), _), max_size) =
d634 3
a636 1
      val is_short = size chars < 2
d639 1
d644 1
a644 1
	  case String.substring(chars, 0, 2) of
d648 1
a648 1
      convert_long(bignum, arg, max_size)
d651 1
a651 1
  fun convert_long_word (arg as ((chars, _), _), max_size) =
d664 1
a664 1
      convert_long(bignum, arg, max_size)
d706 3
a708 2
  fun convert_long32(bignum, arg as ((_, location), sign)) =
    if BigNum32.<=(bignum, biggest_num32) then
d711 1
a711 2
	(LambdaTypes.Ident.INT
	   (add_sign((BigNum32.bignum_to_string bignum, location), sign)),
d715 2
a716 2
	val head = BigNum32.div(bignum, biggest_num32)
	val tail = BigNum32.mod(bignum, biggest_num32)
d720 2
a721 3
	    (LambdaTypes.Ident.INT
	       (add_sign((BigNum32.bignum_to_string tail, location), sign)),
	        MLWorks.Option.SOME 32)
d757 1
a757 2
  fun convert_long_int32 (arg as ((chars, _), _)) =
  (* Unsigned conversion *)
d759 3
a761 1
      val is_short = size chars < 2
d764 1
d769 1
a769 1
	  case String.substring(chars, 0, 2) of
d779 1
a779 1
  fun convert_long_word32 (arg as ((chars, _), _)) =
d799 2
a800 18
    fn (Ident.INT(chars, location), SOME 32) =>
    let
      val (unsigned_chars, sign) =
	if String.ordof(chars, 0) = ord"~" then
	  (String.substring(chars, 1, size chars - 1), true)
	else (chars, false)
    in
      convert_long_int32 ((unsigned_chars, location), sign)
    end
    |  (Ident.INT(chars, location), max_size) =>
    let
      val (unsigned_chars, sign) =
	if String.ordof(chars, 0) = ord"~" then
	  (String.substring(chars, 1, size chars - 1), true)
	else (chars, false)
    in
      convert_long_int (((unsigned_chars, location), sign), max_size)
    end
d804 2
a805 2
    fn (Ident.WORD arg, SOME 32) => convert_long_word32 (arg, false)
    |  (Ident.WORD arg, max_size) => convert_long_word ((arg, false), max_size)
a806 1

@


1.51
log
@Get use of sign correct in convert_word
@
text
@d4 3
d196 1
d224 7
d287 21
d435 1
a435 1
      fun convert_int(sign, ptr, value) =
d441 1
a441 1
	    convert_int(sign,ptr+1, 10 * value + (if sign then new_digit else ~new_digit))
d444 1
a444 1
      convert_int
d473 4
a476 1
  fun convert_int chars =
d481 1
d483 25
a507 7
    in
      if is_short then
	convert chars (sign, ptr, 0)
      else
	case String.substring(chars, ptr, 2) of
	  "0x" => convert_hex chars (sign, ptr + 2, 0)
	| _ => convert chars (sign, ptr, 0)
d512 1
a512 1
  fun convert_word chars =
d516 8
d525 14
a538 6
      if is_short then
	convert chars (sign, 2, 0)
      else
	case String.substring(chars, 0, 3) of
	  "0wx" => convert_hex chars (sign, 3, 0)
	| _ => convert chars (sign, 2, 0)
a559 3
  fun power(n, x, a:int) =
    if n <= 0 then a else power(n-1, x, a*x)

d580 3
a582 1
  fun convert_long(bignum, arg as ((_, location), sign)) =
d584 6
a589 1
      AugLambda.SCON(LambdaTypes.Ident.INT(add_sign((BigNum.bignum_to_string bignum, location), sign)))
d597 4
a600 2
	  (LambdaTypes.Ident.INT
	   (add_sign((BigNum.bignum_to_string tail, location), sign)))
d618 1
a618 1
		  [{size=0, lexp=convert_long(head, arg)},
d624 1
a624 1
	     {size=0, lexp=convert_long(tail, arg)}]
d630 1
a630 2
  fun convert_long_int(arg as ((chars, _), _)) =
  (* Unsigned conversion *)
d633 2
d643 1
a643 1
      convert_long(bignum, arg)
d646 1
a646 1
  fun convert_long_word(arg as ((chars, _), _)) =
d649 2
d659 109
a767 1
      convert_long(bignum, arg)
d769 22
d793 1
a793 1
    fn (Ident.INT(chars, location)) =>
d800 1
a800 1
      convert_long_int((unsigned_chars, location), sign)
d802 10
a811 1
     | _ => Crash.impossible"Convert_long_int of non-int"
d814 4
a817 2
    fn (Ident.WORD arg) => convert_long_word(arg, false)
     | _ => Crash.impossible"Convert_long_word of non-word"
d831 1
a831 1
       MLWorks.Option.SOME (MirTypes.GC reg) => 
d833 1
a833 1
     | MLWorks.Option.SOME (MirTypes.NON_GC reg) => 
d835 1
a835 1
     | MLWorks.Option.SOME (MirTypes.FLOAT reg) => 
d837 1
a837 1
     | MLWorks.Option.NONE =>
d840 1
a840 1
            MLWorks.Option.SOME offset =>
d1745 1
d1753 2
a1754 1
		  Crash.impossible"get_new_opc fails to find proper branch"
d1756 3
a1758 1
		Crash.impossible"get_new_opc fails to find proper branch"
d1777 1
a1777 1
	MLWorks.Option.SOME lv => (trees, lv)
d1788 1
a1788 1
	MLWorks.Option.SOME lv => (trees, lv)
d1799 1
a1799 1
	MLWorks.Option.SOME lv => (trees, lv)
d1810 1
a1810 1
	MLWorks.Option.SOME lv => (trees, lv)
d1821 1
a1821 1
	MLWorks.Option.SOME lv => (trees, lv)
d1832 1
a1832 1
					[{lexp=AugLambda.SCON(Ident.STRING chars),
d1904 1
a1904 1
	    LambdaTypes.Option.PRESENT le =>
d1908 1
a1908 1
		(trees, LambdaTypes.Option.PRESENT le)
d1972 1
a1972 1
		    [{lexp=AugLambda.SCON(Ident.STRING chars), ...}],_), ...} =
d2028 1
a2028 1
	   LambdaTypes.Option.PRESENT le => transform_needed(true, le)
d2079 1
a2079 1
    and needs_prim_stringeq_opt(LambdaTypes.Option.PRESENT{lexp=lexp, size=_}) =
d2081 1
a2081 1
      | needs_prim_stringeq_opt LambdaTypes.Option.ABSENT = false
d2085 1
a2085 1
	AugLambda.SCON_TAG(Ident.STRING _) => true
@


1.50
log
@Add word conversion functions
@
text
@d4 3
a250 5
(*
  fun find_largest_power(n, i) =
    if i * 2 < 0 then n else (find_largest_power(n+1, i*2))
*)

d461 1
a461 1
      val sign = false
d466 1
a466 1
	case String.substring(chars, 3, 0) of
d515 1
a515 1
      AugLambda.SCON(LambdaTypes.Ident.INT(add_sign arg))
@


1.49
log
@convert_hex_to_bignum moved into bignum module
@
text
@d4 3
d62 1
a62 1
> convert_int raises ConvertInt exception
d401 2
a402 1
  fun convert_int chars =
d405 1
a405 1
      fun convert(sign, ptr, value) =
d411 1
a411 1
	    convert(sign,ptr+1, 10 * value + (if sign then new_digit else ~new_digit))
d413 3
d417 4
a420 1
      fun convert_hex(sign, ptr, value) =
d437 1
a437 1
	    convert_hex(sign,ptr+1, 16 * value + (if sign then new_digit else ~new_digit))
d439 6
d451 1
a451 1
	convert(sign, ptr, 0)
d454 17
a470 2
	  "0x" => convert_hex(sign, ptr + 2, 0)
	| _ => convert(sign, ptr, 0)
a491 5
(*
  val _ = output(std_out, "first longest_string_length = " ^
		 MLWorks.Integer.makestring longest_string_length ^ "\n")
*)

a506 5
(*
  val _ = output(std_out, "longest_string_length = " ^
		 MLWorks.Integer.makestring longest_string_length ^ "\n")
*)

d515 42
a556 1
  fun convert_long_int(arg as ((chars, location), sign)) =
d568 15
a582 43
      if BigNum.<=(bignum, biggest_num) then
	AugLambda.SCON(LambdaTypes.Ident.INT(add_sign arg))
      else
	let
	  val head = BigNum.div(bignum, biggest_num)
	  val tail = BigNum.mod(bignum, biggest_num)
	in
	  if BigNum.eq(head, bignum_zero) then
	    AugLambda.SCON
	    (LambdaTypes.Ident.INT
	     (add_sign((BigNum.bignum_to_string tail, location), sign)))
	  else
	    AugLambda.APP
	    ({size=0,
	      lexp=AugLambda.BUILTIN
	      (Pervasives.UNSAFEINTPLUS, binary_int_function_type)},
	     [{size=0,
	      lexp=
	      AugLambda.STRUCT
	      [{size=0,
		(* head * 2 ** longest_string_length *)
		lexp=AugLambda.APP
		({size=0,
		  lexp=AugLambda.BUILTIN
		  (Pervasives.LSHIFT, binary_int_function_type)},
		 [{size=0,
                   lexp=
                   AugLambda.STRUCT
                   [{size=0, lexp=convert_long_int
                     ((BigNum.bignum_to_string head, location), sign)},
		    {size=0, lexp=AugLambda.INT longest_string_length}
                    ]
                   }],
		 Debugger_Types.SELECT
		 (0, Debugger_Types.NOP))
		 },
	      {size=0, lexp=convert_long_int
	       ((BigNum.bignum_to_string tail, location), sign)}
	      ]
	      }],
	     Debugger_Types.SELECT
	     (0, Debugger_Types.NOP))
	end
d588 4
a591 3
      val (unsigned_chars, sign) = case String.substring(chars, 0, 1) of
	"~" => (String.substring(chars, 1, size chars - 1), true)
      | _ => (chars, false)
d596 4
@


1.48
log
@Allow conversion of hex integers
including outsize integers
@
text
@d4 4
a487 2
  val bignum_sixteen = BigNum.int_to_bignum 16

a493 28
  fun hex_digit_to_bignum digit =
    if digit >= ord"0" andalso digit <= ord"9" then
      digit - ord"0"
    else
      if digit >= ord"a" andalso digit <= ord"f" then
	digit - ord"a" + 10
      else
	if digit >= ord"A" andalso digit <= ord"F" then
	  digit - ord"A" + 10
	else
	  Crash.impossible("hex_digit_to_bignum:bad digit:" ^ chr digit)

  fun convert_hex_to_bignum chars =
    let
      val size = size chars
      fun do_hex_digit(ptr', acc) =
	if ptr' >= size then acc
	else
	  let
	    val digit = hex_digit_to_bignum(MLWorks.String.ordof(chars, ptr'))
	  in
	    do_hex_digit(ptr'+1, BigNum.+(BigNum.*(bignum_sixteen, acc),
					  BigNum.int_to_bignum digit))
	  end
    in
      do_hex_digit(2, bignum_zero)
    end

d503 1
a503 1
	    "0x" => convert_hex_to_bignum chars
@


1.47
log
@Removed check on GCness of function
This caused a compiler fault with eg. (cast 0) 0
@
text
@d4 4
d399 1
a399 1
	else 
d403 21
a423 1
	    convert(sign,ptr+1, 10 * value + (if sign = 1 then new_digit else ~new_digit))
d425 4
d430 6
a435 3
      case String.substring(chars, 0, 1) of
	"~" => convert(~1,1, 0)
      | _ => convert(1,0, 0)
d482 1
a482 1
  val bignum_zero = BigNum.string_to_bignum"0"
d484 2
d492 28
d523 8
a530 1
      val bignum = BigNum.string_to_bignum chars
@


1.46
log
@Removed ununsed parameter Print.
@
text
@d4 3
d837 1
a837 2
	  (ONE(INT(reg as MirTypes.GP_GC_REG _)),
	    ((first, blocks, opt, last), values, procs)) =>
d1000 1
a1000 1
	  (ONE(INT(reg as MirTypes.GP_GC_REG _))) =>
d1197 1
a1197 1
	  (ONE(INT(reg as MirTypes.GP_GC_REG _))) =>
@


1.45
log
@Removed NewMap from Debugger_Types
@
text
@d4 3
a161 1
require "../utils/print";
a174 1
  structure Print : PRINT
@


1.44
log
@Removing unused LambdaSub
@
text
@d4 3
a192 1
  structure NewMap = Debugger_Types.NewMap
d200 1
d1029 4
d1042 15
a1056 16
	  if args_escape orelse do_tail then
	    if is_same_fn andalso do_tail then
	      if has_tail_arg then
	        (false, 0,
		 let val tmp_reg = MirTypes.GC.new()
		 in
		   send_to_given_reg(regs', tmp_reg) @@
		     [MirTypes.UNARY (MirTypes.MOVE,
				      MirTypes.GC_REG single_tail_arg,
				      MirTypes.GP_GC_REG tmp_reg)]
		 end)
	      else
		Crash.impossible "Request for tail arg when none given"
	    else
	      (false, 0, send_to_given_reg(regs', real_arg_reg))
	  else
d1144 5
a1148 6
	if is_same_set then
	  if is_same_fn andalso do_tail
	    andalso not (has_tupled_arg andalso args_escape)
	    then self_tail_code()
	  else relative_code()
	else indirect_code()
@


1.43
log
@Rationalizing debugger
@
text
@d4 3
a157 1
require "../lambda/lambdasub";
a174 1
  structure LambdaSub : LAMBDASUB
d178 1
a178 1
  sharing Mir_Env.LambdaTypes = LambdaSub.LT = Library.AugLambda.LambdaTypes
@


1.42
log
@Remove superfluous adds when calculating self closure
@
text
@d4 3
d489 2
a490 2
		 AugLambda.Debugger_Types.Select
		 (0, AugLambda.Debugger_Types.Nop))
d496 2
a497 2
	     AugLambda.Debugger_Types.Select
	     (0, AugLambda.Debugger_Types.Nop))
@


1.41
log
@Make lookup_in_closure return an Option value
Some efficiency improvements -- reduce number of lookups of variables
and diddled about with appending lists of lists.
@
text
@d4 5
d1076 7
a1082 3
	  MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG real_closure_reg,
			  MirTypes.GP_GC_REG callee_closure,
			  MirTypes.GP_IMM_INT(pos*2)) ::
@


1.40
log
@Changes to lambda calculus
@
text
@d4 3
d190 13
a202 7
  fun reducel f = 
    let
      fun red (acc, []) = acc
        | red (acc, x::xs) = red (f(acc,x), xs)
    in 
      red
    end
d283 2
d288 1
d292 2
a293 1
    (new_reg, Lists.reducer op @@
d320 1
a320 1
      number_list, []))
d332 3
a334 2
    (new_reg, Lists.reducer op @@
      ([alloc_op] ::
d367 1
a367 1
      number_list, []))
d514 28
a541 32
    let
      val (offset, is_same_set, found) =
	let
	  val offset_in_closure = Mir_Env.lookup_in_closure(lvar, closure)
	in
	  (offset_in_closure, offset_in_closure < funs_in_closure * 2 - 1,
	   true)
	end handle Mir_Env.Lookup => (0, false, false)
    in
      (((case Mir_Env.lookup_lambda(lvar, env) of
	   MirTypes.GC reg => INT(MirTypes.GP_GC_REG reg)
	 | MirTypes.NON_GC reg =>
	     INT(MirTypes.GP_NON_GC_REG reg)
	 | MirTypes.FLOAT reg => REAL(MirTypes.FP_REG reg)),
	   []), offset, is_same_set) handle Mir_Env.Lookup =>
	   if found then
	     let
	       val new_reg = MirTypes.GC.new()
	     in
	       ((INT(MirTypes.GP_GC_REG new_reg),
		 [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
				   MirTypes.GC_REG callee_closure,
				   MirTypes.GP_IMM_ANY(~1 + 4*offset))]),
		offset div 2, is_same_set)
	     (* Because the function pointers in a closure are interspersed *)
	     (* with zeroes, we must halve offset_in_closure above *)
	     end
	   else
	     Crash.impossible("cg_lvar: Lambda variable " ^
			   LambdaTypes.printLVar lvar ^
			      " is neither in the closure nor the local bindings")
    end
d596 1
a596 2
  fun contract_sexpr(Sexpr.NIL, [], acc) =
    reducel (fn (x, y) => y @@ x) ([], acc)
d613 22
a634 18
    ((case tag of
      MirTypes.Option.ABSENT =>
	if empty_sexpr last then
	  (Sexpr.CONS(first, first'), blocks @@ blocks', tag', last')
	else
	  Crash.impossible"non-empty last with no tag"
    | MirTypes.Option.PRESENT tag_val =>
	(case tag' of
	   MirTypes.Option.ABSENT =>
	     if empty_sexpr last' then
	       (first, blocks @@ blocks', tag, Sexpr.CONS(last, first'))
	     else
	       Crash.impossible"non-empty last' with no tag"
	 | MirTypes.Option.PRESENT tag_val' =>
	     (first, MirTypes.BLOCK(tag_val,
				    contract_sexpr(Sexpr.CONS(last,first'))) ::
	      blocks @@ blocks',
	      tag', last'))), values @@ values', set @@ set')
d763 1
a763 1
 	Lists.reducer op @@
d767 4
a770 4
				 MirTypes.GP_IMM_ANY(start + 4*i))]
	       )
	  clean_dynamics, [])
      val setup_dynamics =
d774 1
d796 1
a796 1
	 reducel
d879 2
a880 1
	      val code =
d884 1
d918 1
a918 1
	    Lists.reducer op @@
d930 1
a930 1
	     int_reg_list, [])
d1224 2
a1225 1
      val code =
d1229 1
d1251 1
a1251 5
      val extra_arg_code =
        code @@
        (Lists.reducer op @@
         (setup_code,
          []))
d1453 1
a1453 1
	NewMap.YES lv => (trees, lv)
d1464 1
a1464 1
	NewMap.YES lv => (trees, lv)
d1475 1
a1475 1
	NewMap.YES lv => (trees, lv)
d1486 1
a1486 1
	NewMap.YES lv => (trees, lv)
d1497 1
a1497 1
	NewMap.YES lv => (trees, lv)
d1652 1
a1652 1
	reducel
d1659 1
a1659 1
	reducel
@


1.39
log
@Changes to lambdatypes
@
text
@d4 3
d187 8
d587 1
a587 1
    Lists.reducel (fn (x, y) => y @@ x) ([], acc)
d782 1
a782 1
	 Lists.reducel
d1129 3
a1131 2
          | assign (arg::rest,reg::restregs,acc) = assign (rest,restregs,(arg,reg)::acc)
          | assign _ = Crash.impossible "Not enough arg regs"
d1182 4
a1185 9
        let
          val toregs =
            map 
            (fn (_,MirTypes.GC r) => r
          | _ => Crash.impossible "Bad reg in tuple binding")
            tuple_bindings
        in
          Lists.zip (reglist,toregs)
        end
d1196 1
a1196 1
      val used_arg_regs = map (fn (_,reg) => MirTypes.GC reg) real_arg_regs
d1198 17
a1214 1
      val extra_arg_code =
d1216 6
a1221 15
          val cleaned_regs_and_code =
            map
            (fn reg =>
             let
               val new_reg = MirTypes.GC.new()
               val code = send_to_given_reg(ONE reg, new_reg)
             in
               (INT(MirTypes.GP_GC_REG new_reg), code)
             end)
            arg_register_list
          val code =
            Lists.reducer
            (fn ((_, y), x) => y @@ x)
            (cleaned_regs_and_code, [])
          val (gc_regs, code) = (map #1 cleaned_regs_and_code, code)
d1223 1
a1223 6
          code @@
          (Lists.reducer op @@
           (map
            (fn (reg, (_,r)) => send_to_given_reg(ONE reg, r))
            (Lists.zip (gc_regs,real_arg_regs)),
            []))
d1225 19
d1292 2
a1293 1
	  [MirTypes.COMMENT"And acquire result"]
d1318 2
a1319 1
	[MirTypes.COMMENT("And acquire result")]
d1435 1
a1435 1
    val empty_string_tree = NewMap.empty' String.<
d1537 1
a1537 1
      | lift_externals(trees, {lexp=AugLambda.LET(lv, info,lb, le), size=size}) =
d1542 1
a1542 1
	  (trees, {lexp=AugLambda.LET(lv,info,lb,le), size=size})
d1638 1
a1638 1
	Lists.reducel
d1641 1
a1641 1
      | get_string{lexp=AugLambda.LET(_,_,lb,le),...} = 
d1645 1
a1645 1
	Lists.reducel
d1671 1
a1671 1
      | transform_needed(bad, {lexp=AugLambda.LET(_,_,lb,le),...}) = 
d1709 1
a1709 1
      | needs_prim_stringeq(AugLambda.LET(_,_, {lexp=bind,...}, {lexp=expr,...})) =
@


1.38
log
@Adding stuff for multiple argument passing
@
text
@d4 3
d1507 1
a1507 1
      | lift_externals(trees, {lexp=AugLambda.LET(lv, lb, le), size=size}) =
d1512 1
a1512 1
	  (trees, {lexp=AugLambda.LET(lv,lb,le), size=size})
d1611 1
a1611 1
      | get_string{lexp=AugLambda.LET(_,lb,le),...} = 
d1641 1
a1641 1
      | transform_needed(bad, {lexp=AugLambda.LET(_,lb,le),...}) = 
d1679 1
a1679 1
      | needs_prim_stringeq(AugLambda.LET(_, {lexp=bind,...}, {lexp=expr,...})) =
@


1.37
log
@Mistake in lift_externals.
@
text
@d4 3
d198 5
d207 1
a207 1
  | gp_from_reg(MirTypes.NON_GC_REG x) = MirTypes.GP_NON_GC_REG x
d210 2
a211 2
  | reg_from_gp(MirTypes.GP_NON_GC_REG x) = MirTypes.NON_GC_REG x
  | reg_from_gp _ = Crash.impossible"reg_from_gp(IMM)"
d218 9
a226 9
  | get_real(INT(MirTypes.GP_GC_REG reg_op)) =
    let
      val fp_op = MirTypes.FP_REG(MirTypes.FP.new())
    in
      (fp_op,
        [MirTypes.STOREFPOP(MirTypes.FLD, fp_op, MirTypes.GC_REG reg_op,
			    MirTypes.GP_IMM_ANY real_offset)])
    end
  | get_real _ = Crash.impossible"get_real bad value"
d480 4
a483 5
  fun get_any_register(INT(MirTypes.GP_GC_REG reg)) = MirTypes.GC reg
  | get_any_register(INT(MirTypes.GP_NON_GC_REG reg)) = MirTypes.NON_GC reg
  | get_any_register(REAL(MirTypes.FP_REG reg)) = MirTypes.FLOAT reg
  | get_any_register _ =
    Crash.impossible"Bad value to get_any_register"
d786 1
a786 3
	     regs', the_code' as ((first', blocks', opt', last'), values',
				  procs'),
	     loop_tag, pos, funs_in_closure, tag_list) =
a790 3
      val _ = Diagnostic.output 5
        (fn _ => ["pos = " ^ MLWorks.Integer.makestring pos])

d820 1
a820 1
	     MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information,[])
d906 4
a909 3
		 args_escape, has_tupled_arg, tuple_bindings,
		 is_same_set, loop_tag, pos, funs_in_closure, tag_list,
		 do_tail, opt_tail_calls, opt_self_calls) =
d912 2
a913 2
      (* args_escape and has_tupled_arg relate to the callee *)
      (* and mean respectively that the argument may be returned outside *)
a914 3
      (* and that the function takes a record argument (of some sort) *)
      (* eg {1=a, ..} or even a constructed value where all constructors *)
      (* carry values. *)
d930 1
a930 1
      (* do_tail indicates that we are in the tail position *)
a932 1
      val args_reused = Lists.length tuple_bindings = 1 andalso has_tupled_arg
d934 7
d944 1
a944 1
      val do_tail' = do_tail andalso 
d978 1
a978 1
	if do_tail' 
d981 2
a982 2
 
     val (has_tail_arg, single_tail_arg, tuple_bindings') =
d988 1
a988 1
	if has_tupled_arg 
d990 1
a990 1
            if is_same_fn andalso do_tail' andalso not args_escape andalso not args_reused 
d992 1
a992 1
            else if args_escape orelse args_reused orelse do_tail' 
d995 3
a997 3
	else
	  if args_escape orelse do_tail' then
	    if is_same_fn andalso do_tail' then
d1012 2
a1013 2
	    (args_are_tuple, tuple_size,
	     stack_send_to_given_reg(regs', real_arg_reg))
d1018 4
a1021 3
      val fn_reg_op = reg_from_gp fn_reg
      val res_reg = MirTypes.GC.new()
      val deallocate_code =
d1057 2
a1058 2
	    if do_tail' then
	      MirTypes.TAIL_CALL(MirTypes.TAIL, dest,[])
d1060 1
a1060 1
	      MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information,[])
d1062 1
a1062 1
	  MirTypes.COMMENT(if do_tail' then
d1067 1
a1067 1
	  MirTypes.COMMENT"And acquire result" :: deallocate_code
d1069 1
a1069 1
	  []
d1082 2
a1083 2
	  if do_tail' then
	    MirTypes.TAIL_CALL(MirTypes.TAIL, dest,[])
d1085 1
a1085 1
	    MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information,[])
d1087 1
a1087 1
        MirTypes.COMMENT(if do_tail' then
d1092 1
a1092 1
	MirTypes.COMMENT("And acquire result") :: deallocate_code
d1096 2
a1097 3
	  if is_same_fn andalso do_tail'
	    andalso not (has_tupled_arg andalso
			 (args_escape orelse args_reused))
d1106 193
@


1.36
log
@Added support for multiple arguments to functions.
Not complete yet, but should be OK for single argument case.
@
text
@d4 4
d1301 1
a1301 1
	  val (trees, lel') = lift_externals_list (trees, [], lel)
@


1.35
log
@Fix register undefined following self tail call problem
@
text
@d4 3
d424 1
a424 1
	     {size=0,
d433 5
a437 5
		 {size=0,
		  lexp=
		  AugLambda.STRUCT
		  [{size=0, lexp=convert_long_int
		    ((BigNum.bignum_to_string head, location), sign)},
d439 2
a440 2
		   ]
		  },
d447 1
a447 1
	      },
d814 1
a814 1
	     MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information)
d899 1
a899 2
		 regs', the_code' as ((first', blocks', opt', last'), values',
				      procs'),
d927 1
d930 10
a939 4
      val _ = Diagnostic.output 5
        (fn _ => ["pos = " ^ MLWorks.Integer.makestring pos])
      val _ = Diagnostic.output 5
        (fn _ => [if is_same_fn then "Same fn" else "Not same fn"])
d941 1
a941 3
      val do_tail' = do_tail 
        andalso (is_same_fn orelse opt_tail_calls)
        andalso (not is_same_fn orelse opt_self_calls)
d944 2
a945 3
	case (regs, the_code) of
	  (ONE(INT(reg as MirTypes.GP_GC_REG _)),
	    ((first, blocks, opt, last), values, procs)) =>
d947 4
a950 4
	      ((Sexpr.CONS
		(Sexpr.ATOM[MirTypes.COMMENT"Evaluate function to be called"],
		 first),
	        blocks, opt, last), values, procs))
d952 2
d956 1
a956 1
	  (Sexpr.ATOM[MirTypes.COMMENT"Evaluate function argument"],
d959 1
d968 2
a969 1
	if do_tail' then (MirRegisters.tail_arg, MirRegisters.tail_closure)
d971 2
a972 1
      val (has_tail_arg, single_tail_arg, tuple_bindings') =
d976 1
d978 7
a984 10
	if has_tupled_arg then
	  if is_same_fn andalso do_tail' andalso not args_escape andalso
	    not args_reused then
	    (false, 0, build_args_for_tail(tuple_bindings', regs'))
	  else
             if args_escape orelse args_reused orelse do_tail' then
               (false, 0, send_to_given_reg(regs', real_arg_reg))
             else
               (args_are_tuple, tuple_size,
                stack_send_to_given_reg(regs', real_arg_reg))
d995 1
a995 2
				      MirTypes.GP_GC_REG tmp_reg) 
		     ]
d1015 2
a1016 1
      fun self_tail_code() =
d1028 1
a1028 1
      fun relative_code() =
d1047 1
a1047 1
	      MirTypes.TAIL_CALL(MirTypes.TAIL, dest)
d1049 1
a1049 1
	      MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information)
d1060 1
a1060 1
      fun indirect_code() =
d1072 1
a1072 1
	    MirTypes.TAIL_CALL(MirTypes.TAIL, dest)
d1074 1
a1074 1
	    MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information)
d1088 3
a1090 6
	    then
	    self_tail_code()
	  else
	    relative_code()
	else
	  indirect_code()
d1095 1
a1095 1
    end
d1258 4
a1261 2
					{lexp=AugLambda.SCON(Ident.STRING chars),
					 ...},_), ...})) =
d1294 1
a1294 1
      | lift_externals(trees, {lexp=AugLambda.APP(le, le',debug), size=size}) =
d1297 1
a1297 1
	  val (trees, le') = lift_externals(trees, le')
d1299 1
a1299 1
	  (trees, {lexp=AugLambda.APP(le, le',debug), size=size})
d1398 1
a1398 1
		    {lexp=AugLambda.SCON(Ident.STRING chars), ...},_), ...} =
d1401 4
a1404 2
      | get_string{lexp=AugLambda.APP(le, le',_), ...} =
	Set.union(get_string le, get_string le')
d1425 1
a1425 1
			 ({lexp=AugLambda.BUILTIN(prim,_), ...}, le, _), ...}) =
d1432 3
a1434 3
       | _ => transform_needed(bad, le))
      | transform_needed(bad, {lexp=AugLambda.APP(le, le',_), ...}) =
	transform_needed(bad, le) orelse transform_needed(bad, le')
d1480 5
a1484 2
      | needs_prim_stringeq(AugLambda.APP({lexp=le, ...}, {lexp=le', ...},_)) =
	needs_prim_stringeq le orelse needs_prim_stringeq le'
@


1.34
log
@Log: Changes for automatic_callee mechanism removal
and moving machspec from machine to main
@
text
@d4 4
d1011 7
a1017 1
	 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)]
@


1.33
log
@Added ConvertInt exception to MirUtils
@
text
@d5 3
d953 1
a953 2
      val use_callee_registers =
	MirRegisters.automatic_callee andalso do_tail'
d955 1
a955 1
	if use_callee_registers then (callee_arg, callee_closure)
@


1.32
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.
@
text
@d4 7
d323 1
d340 2
@


1.31
log
@Fixed bug in needs_transform to look inside the arguments to builtins
@
text
@d4 3
d1278 1
a1278 1
      | lift_externals(trees, {lexp=AugLambda.FN(lv, le, name), size=size}) =
d1282 1
a1282 1
	  (trees, {lexp=AugLambda.FN(lv, le, name), size=size})
d1375 1
a1375 1
      | get_string{lexp=AugLambda.FN(_, le,_), ...} = get_string le
d1405 1
a1405 1
      | transform_needed(_, {lexp=AugLambda.FN(_, le,_), ...}) = transform_needed(true, le)
d1439 1
a1439 1
      | needs_prim_stringeq(AugLambda.FN(_, {lexp=lexp, ...}, _)) =
@


1.31.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.31  1993/08/19  14:50:47  jont
Fixed bug in needs_transform to look inside the arguments to builtins

@


1.30
log
@Moved some more functions here from _mir_cg.sml
@
text
@d4 3
d1390 1
a1390 1
			 ({lexp=AugLambda.BUILTIN(prim,_), ...}, _, _), ...}) =
d1397 1
a1397 1
       | _ => false)
@


1.29
log
@Changed type of new_do_app for local and closure variable
inspection in the debugger;
structure Option.
@
text
@d4 5
d141 2
d1165 198
a1362 2
    fun get_string(LambdaTypes.APP(LambdaTypes.BUILTIN prim,
				   LambdaTypes.SCON(Ident.STRING chars),_)) =
d1365 3
a1367 3
    | get_string(LambdaTypes.APP(le, le',_)) =
      Set.union(get_string le, get_string le')
    | get_string(LambdaTypes.LET(_, lb, le)) = 
d1369 106
a1474 15
    | get_string(LambdaTypes.FN(_, le,_,_)) = get_string le
    | get_string(LambdaTypes.STRUCT le_list) =
      Lists.reducel
      (fn (set, le) => Set.union(set, get_string le))
      (Set.empty_set, le_list)
    | get_string(LambdaTypes.SELECT(_, le)) = get_string le
    | get_string(LambdaTypes.SWITCH _) = Set.empty_set
    | get_string(LambdaTypes.VAR _) = Set.empty_set
    | get_string(LambdaTypes.LETREC _) = Set.empty_set
    | get_string(LambdaTypes.INT _) = Set.empty_set
    | get_string(LambdaTypes.SCON _) = Set.empty_set
    | get_string(LambdaTypes.MLVALUE _) = Set.empty_set
    | get_string(LambdaTypes.HANDLE _) = Set.empty_set
    | get_string(LambdaTypes.RAISE _) = Set.empty_set
    | get_string(LambdaTypes.BUILTIN _) = Set.empty_set
@


1.28
log
@Fixed bug where host longest int might be unrepresentable in target
@
text
@d4 3
d259 1
a259 1
			      MirTypes.ABSENT)
d409 2
a410 2
		 (0, AugLambda.Debugger_Types.Nop)
		 )},
d484 1
a484 1
	  ((INT(MirTypes.GP_GC_REG new_reg),
d487 1
a487 1
			     MirTypes.GP_IMM_INT (pos*2))]))
d547 1
a547 1
      MirTypes.ABSENT =>
d552 1
a552 1
    | MirTypes.PRESENT tag_val =>
d554 1
a554 1
	   MirTypes.ABSENT =>
d559 1
a559 1
	 | MirTypes.PRESENT tag_val' =>
d792 1
a792 1
	      MirTypes.ABSENT, Sexpr.NIL), [], []))))
d942 5
a946 5
	    if args_escape orelse args_reused orelse do_tail' then
	      (false, 0, send_to_given_reg(regs', real_arg_reg))
	    else
	      (args_are_tuple, tuple_size,
	       stack_send_to_given_reg(regs', real_arg_reg))
d969 1
a969 1
		((Sexpr.ATOM extra_arg_code, [], MirTypes.ABSENT, Sexpr.NIL),
d1051 3
a1053 6
      (ONE(INT(MirTypes.GP_GC_REG res_reg)),
       combine
       (fn_code,
	combine
	(arg_code, ((Sexpr.ATOM call_code, [], MirTypes.ABSENT,
		     Sexpr.NIL), [], []))))
d1056 1
a1056 1
    fun exit_block [] = MirTypes.ABSENT
d1061 1
a1061 1
	then MirTypes.PRESENT block
@


1.27
log
@Added support for code generation of long ints by transforming the lambda
calculus to expressions involving shifts and adds
@
text
@d4 4
d334 4
a337 1
  val longest_string_length = longest_string_length(* div 2*)
d342 16
a357 3
  val longest_int = power(longest_string_length, 2, 1)

  val biggest_num = BigNum.string_to_bignum(MLWorks.Integer.makestring longest_int)
@


1.26
log
@Removed Integer parameter
@
text
@d4 3
d95 1
d99 1
d110 1
d113 1
d119 1
d122 1
d127 1
d134 2
d151 6
d297 110
a406 15
  let
    val char_size = size chars
    fun convert(sign, ptr, value) =
      if ptr >= char_size then value
      else 
        let
          val new_digit = (String.ordof(chars, ptr) - ord"0")
        in
          convert(sign,ptr+1, 10 * value + (if sign = 1 then new_digit else ~new_digit))
        end
  in
    case String.substring(chars, 0, 1) of
      "~" => convert(~1,1, 0)
    | _ => convert(1,0, 0)
  end
@


1.25
log
@Removed unused option refs.
@
text
@d4 3
a89 1
require "../utils/integer";
a104 1
  structure Integer : INTEGER
d614 1
a614 1
        (fn _ => ["pos = " ^ Integer.makestring pos])
d720 1
a720 1
				  Integer.makestring i ^
d722 1
a722 1
				  Integer.makestring(Lists.length gc_regs) ^
d762 1
a762 1
        (fn _ => ["pos = " ^ Integer.makestring pos])
d859 1
a859 1
				 Integer.makestring(Lists.length tag_list +
d863 1
a863 1
				 Integer.makestring(Lists.length tag_list) ^
@


1.24
log
@Signature revisions
@
text
@d4 3
a122 3

  val do_tail_optimisation = ref(true)
  val do_self_call_optimisation = ref(true)
@


1.23
log
@Added MLVALUE lambda exp
@
text
@d4 3
d119 1
a119 1
  structure Ident = LambdaTypes.Datatypes.Ident
@


1.22
log
@Made copy_n tail recursive
@
text
@d4 3
d1040 1
@


1.21
log
@Changes to propagate compiler options as parameters instead of references.
@
text
@d4 3
d563 11
a573 10
	  fun copy_n(how_many, from, to) =
	  if how_many <= 0 then []
	  else
	    MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
	      MirTypes.GC_REG callee_closure,
			      MirTypes.GP_IMM_ANY(start + 4*from)) ::
	      MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg,
			       reg_operand,
			       MirTypes.GP_IMM_ANY(start + 4*to)) ::
	    copy_n(how_many-1, from+1, to+1)
d576 1
a576 1
	  copy_n(statics, offset, funs)
@


1.20
log
@Removed a large number of unnecessary map operations
@
text
@d4 3
d597 1
a597 2
	     is_same_set, loop_tag, pos, funs_in_closure, tag_list, do_tail,
	     args_dont_escape) =
a601 2
      val do_tail' = do_tail andalso !do_tail_optimisation
      val is_same_fn = pos = 0
a603 2
      val _ = Diagnostic.output 5
        (fn _ => [if is_same_fn then "Same fn" else "Not same fn"])
d620 1
a620 6
      val use_callee_registers =
	MirRegisters.automatic_callee andalso do_tail
      val (real_arg_reg, real_closure_reg) =
	if use_callee_registers then (callee_arg, callee_closure)
	else (caller_arg, caller_closure)
      val extra_code = send_to_given_reg(regs', real_arg_reg)
d624 1
a624 38
	if is_same_set then
	  if is_same_fn andalso do_tail' andalso args_dont_escape then
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG real_closure_reg,
			    MirTypes.GP_GC_REG callee_closure),
	     MirTypes.COMMENT("Set up new closure pointer"),
	     MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)]
	  else
	    [MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG real_closure_reg,
			     MirTypes.GP_GC_REG callee_closure,
			     MirTypes.GP_IMM_INT(pos*2)),
	     MirTypes.COMMENT("Set up new closure pointer"),
	     let
	       val dest = MirTypes.TAG(Lists.nth(Lists.length tag_list + pos -
						 funs_in_closure, tag_list))
		 handle Lists.Nth =>
		   Crash.impossible("Lists.Nth in do_app\nn = " ^
				    Integer.makestring(Lists.length tag_list +
						       pos -
						       funs_in_closure) ^
				    " but list length = " ^
				    Integer.makestring(Lists.length tag_list) ^
				    "\n")
	     in
	       if do_tail' 
                 then
                   MirTypes.TAIL_CALL(MirTypes.TAIL, dest)
	       else
		 MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information)
	     end,
	     MirTypes.COMMENT(if do_tail'
                                then
				"Tail to the function"
			      else "Call the function"),
	     MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
			    MirTypes.GP_GC_REG caller_arg),
	     MirTypes.COMMENT"And acquire result"]
	else
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG real_closure_reg,
d628 1
a628 1
			    MirTypes.GC_REG real_closure_reg,
d634 1
a634 4
	     if do_tail' then
	       MirTypes.TAIL_CALL(MirTypes.TAIL, dest)
	     else
	       MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest,debugger_information)
d636 1
a636 3
	   MirTypes.COMMENT(if do_tail' then
			      "Tail to the function"
			    else "Call the function"),
d723 1
a723 1
		 do_tail) =
d756 2
a757 2
        andalso (is_same_fn orelse ! do_tail_optimisation)
        andalso (not is_same_fn orelse ! do_self_call_optimisation)
@


1.19
log
@Fixed bug in tail optimisation code.
Also removed redefinition of append.
@
text
@d4 4
a96 4
(*
  sharing MirTypes.Ident = Mir_Env.LambdaTypes.Ident
  sharing LambdaSub.Set = Library.Set
*)
d742 2
a743 1
		  val code = ok_code @@ (map #2 new_regs_and_code)
d745 1
a745 1
		  (map #1 new_regs_and_code, code)
d1074 2
a1075 2
      Set.union
      (Set.empty_set, map get_string le_list)
@


1.18
log
@Convert on most negative integer failed
@
text
@d4 3
a111 11
  fun rev_app([], x) = x
    | rev_app(x :: xs, y) = rev_app(xs, x :: y)

  fun rev x = rev_app(x, [])

  fun app(x, []) = x
    | app([], x) = x
    | app(x, y) = rev_app(rev x, y)

  val op@@ = app

d850 15
a864 9
	    (false, 0,
	     send_to_given_reg(regs',
			       if is_same_fn andalso do_tail' then
				 if has_tail_arg then single_tail_arg
				 else
				   Crash.impossible
				   "Request for tail arg when none given"
			       else
				 real_arg_reg))
@


1.17
log
@Added switches for self call optimisation
@
text
@d4 3
d276 1
a276 1
    fun convert(ptr, value) =
d278 6
a283 1
      else convert(ptr+1, 10 * value + (String.ordof(chars, ptr) - ord"0"))
d286 2
a287 2
      "~" => 0 - convert(1, 0)
    | _ => convert(0, 0)
@


1.16
log
@Removed some redundant structures and sharing
@
text
@d4 3
d104 1
d803 3
a805 1
      val do_tail' = do_tail andalso ! do_tail_optimisation
d873 1
a873 1
      val self_tail_code =
d878 2
a879 1
      val relative_code =
d910 2
a911 1
      val indirect_code =
d940 1
a940 1
	    self_tail_code
d942 1
a942 1
	    relative_code
d944 1
a944 1
	  indirect_code
@


1.15
log
@Mir_Env now uses NewMap instead of Map.
@
text
@d4 3
a64 1
require "mirtypes";
a78 1
  structure MirTypes : MIRTYPES
d82 3
a84 2
  sharing Mir_Env.LambdaTypes = LambdaSub.LT = Library.LambdaTypes
  sharing Mir_Env.MirTypes = MirTypes = MirRegisters.MirTypes
d87 1
d96 3
a98 3
  structure MirTypes = MirTypes
  structure Set = Library.Set
  structure Ident = MirTypes.Ident
@


1.14
log
@Changed ord(substring ...) to ordof.
@
text
@d4 3
a54 2
require "../utils/set";
require "../utils/map";
a58 2
require "../basics/ident";
require "../lambda/lambdatypes";
a69 2
  structure Set : SET
  structure Map : MAP
a73 1
  structure Ident : IDENT
a75 1
  structure LambdaTypes : LAMBDATYPES
d81 1
a81 2
  sharing LambdaTypes = Mir_Env.LambdaTypes =
    LambdaSub.LT = Library.LambdaTypes
d83 3
a85 4
  sharing MirTypes.Ident = LambdaTypes.Ident = Ident
  sharing Set = LambdaSub.Set = Library.Set
  sharing Map = Mir_Env.Map = Library.Map
  sharing type Pervasives.pervasive = LambdaTypes.Primitive
d90 1
a90 1
  structure LambdaTypes = LambdaTypes
d94 2
d293 1
a293 1
	end handle Map.Lookup => (0, false, false)
d300 1
a300 1
	   []), offset, is_same_set) handle Map.Lookup =>
@


1.13
log
@String structure is now pervasive.
@
text
@d4 3
d273 1
a273 3
      else
	convert(ptr+1, 10 * value + (ord(String.substring(chars, ptr, 1)) -
				     ord"0"))
@


1.12
log
@Added a flag to turn off tail-call optimisation
@
text
@d4 3
a54 1
require "../utils/string";
a72 1
  structure String : STRING
@


1.11
log
@Shortened various exit blocks (should be done by expression analyser)
@
text
@d4 3
d98 2
d596 1
d628 1
a628 1
	  if is_same_fn andalso do_tail andalso args_dont_escape then
d650 3
a652 2
	       if do_tail then
		 MirTypes.TAIL_CALL(MirTypes.TAIL, dest)
d656 2
a657 1
	     MirTypes.COMMENT(if do_tail then
d674 1
a674 1
	     if do_tail then
d679 1
a679 1
	   MirTypes.COMMENT(if do_tail then
d799 2
d823 1
a823 1
	MirRegisters.automatic_callee andalso do_tail
d833 1
a833 1
	  if is_same_fn andalso do_tail andalso not args_escape andalso
d837 1
a837 1
	    if args_escape orelse args_reused orelse do_tail then
d843 1
a843 1
	  if args_escape orelse do_tail then
d846 1
a846 1
			       if is_same_fn andalso do_tail then
d890 1
a890 1
	    if do_tail then
d895 1
a895 1
	  MirTypes.COMMENT(if do_tail then
d914 1
a914 1
	  if do_tail then
d919 1
a919 1
        MirTypes.COMMENT(if do_tail then
d928 1
a928 1
	  if is_same_fn andalso do_tail
@


1.10
log
@Rewrote cg_lvar to use exceptions instead of is_in...
@
text
@d4 3
d950 53
d1029 2
a1030 1
	      MirTypes.BLOCK(tag', rev_app(new_opc, opcode_list))
d1033 1
a1033 1
	    block
@


1.9
log
@Added LET constructor and new slot to APP.
@
text
@d4 3
d283 6
a288 8
	if Mir_Env.is_in_closure(lvar, closure) then
	  let
	    val offset_in_closure = Mir_Env.lookup_in_closure(lvar, closure)
	  in
	    (offset_in_closure, offset_in_closure < funs_in_closure * 2 - 1,
	     true)
	  end
	else (0, false, false)
d290 20
a309 22
      if Mir_Env.is_in_lambda_env(lvar, env) then
	(((case Mir_Env.lookup_lambda(lvar, env) of
	     MirTypes.GC reg => INT(MirTypes.GP_GC_REG reg)
	   | MirTypes.NON_GC reg =>
	       INT(MirTypes.GP_NON_GC_REG reg)
	   | MirTypes.FLOAT reg => REAL(MirTypes.FP_REG reg)),
	     []), offset, is_same_set)
      else
	if found then
	  let
	    val new_reg = MirTypes.GC.new()
	  in
	    ((INT(MirTypes.GP_GC_REG new_reg),
	      [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
				MirTypes.GC_REG callee_closure,
				MirTypes.GP_IMM_ANY(~1 + 4*offset))]),
	     offset div 2, is_same_set)
	  (* Because the function pointers in a closure are interspersed *)
	  (* with zeroes, we must halve offset_in_closure above *)
	  end
	else
	  Crash.impossible("cg_lvar: Lambda variable " ^
d311 1
a311 1
			   " is neither in the closure nor the local bindings")
@


1.8
log
@Added type annotation information at application points
@
text
@d4 3
d983 1
a983 1
				   LambdaTypes.SCON(Ident.STRING chars))) =
d986 1
a986 1
    | get_string(LambdaTypes.APP(le, le')) =
d988 2
@


1.7
log
@Added slot for slot in FNexp
@
text
@d4 3
d576 2
a577 1
  fun do_app(regs, the_code as ((first, blocks, opt, last), values, procs),
d642 1
a642 1
		 MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest)
d664 1
a664 1
	       MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest)
d748 2
a749 1
  fun new_do_app(regs, the_code as ((first, blocks, opt, last), values, procs),
d878 1
a878 1
	      MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest)
d902 1
a902 1
	    MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest)
@


1.6
log
@Changed to use augmented lambda calculus, and sexpressions to avoid
duplicated append operations.
@
text
@d4 4
d980 1
a980 1
    | get_string(LambdaTypes.FN(_, le,_)) = get_string le
@


1.5
log
@Removed some no longer used functions. Tidied up in places, using
reducer for appends instead of reducel. Accidentally fixed a problem
in build_args_for_tail caused by the int_reg_list being in reverse order
(real fix is in _interproc)
@
text
@d4 6
d25 1
d45 1
d72 1
a103 105
  fun needs_prim(prim, le) =
    Crash.impossible"Mir_Utils.needs_prim no longer supported"

  fun lneeds_prim(prim, le_list) =
    let
      fun lneeds [] = false
      | lneeds(le :: rest) = needs_prim(prim, le) orelse lneeds rest
    in
      lneeds le_list
    end

(*
  fun makes_calls(LambdaTypes.VAR _) = false
    | makes_calls(LambdaTypes.APP(LambdaTypes.FN(lv, le,_), le')) =
      makes_calls le orelse makes_calls le'
    | makes_calls(LambdaTypes.APP(LambdaTypes.BUILTIN _,
				  LambdaTypes.STRUCT le_list)) =
      makes_calls_list le_list
    | makes_calls(LambdaTypes.APP(LambdaTypes.BUILTIN _, le)) =
      makes_calls le
    | makes_calls(LambdaTypes.APP(le, le')) = true
    | makes_calls(LambdaTypes.FN(lv, lexp,_)) = true
    | makes_calls(LambdaTypes.LETREC(lv_list, le_list, lexp)) = true
    | makes_calls(LambdaTypes.SWITCH(le, tag_le_list, le1_opt, le2_opt)) =
      let fun count_tag_list [] = false
	| count_tag_list((tag, le) :: rest) =
	  (case tag of
	    LambdaTypes.EXP_TAG lexp => makes_calls lexp
	  | _ => false) orelse makes_calls le orelse count_tag_list rest
	fun count_le_opt LambdaTypes.ABSENT = false
	| count_le_opt(LambdaTypes.PRESENT le) = makes_calls le
      in
	makes_calls le orelse count_tag_list tag_le_list orelse
	count_le_opt le1_opt orelse count_le_opt le2_opt
      end
    | makes_calls(LambdaTypes.STRUCT le_list) = true
    | makes_calls(LambdaTypes.SELECT(_, le)) = makes_calls le
    | makes_calls(LambdaTypes.RAISE le) = true
    | makes_calls(LambdaTypes.HANDLE(le, le')) = true
    | makes_calls(LambdaTypes.SCON _) = false
    | makes_calls(LambdaTypes.INT _) = false
    | makes_calls(LambdaTypes.BUILTIN _) = false

  and makes_calls_list [] = false
    | makes_calls_list (x :: xs) = makes_calls x orelse makes_calls_list xs
*)

  fun makes_calls _ =
    Crash.impossible"Mir_Utils.makes_calls no longer supported"

(*
  fun count_gc_objects(LambdaTypes.VAR _) = 0
    | count_gc_objects(LambdaTypes.APP(LambdaTypes.FN(lv, le,_), le')) =
      count_gc_objects le + count_gc_objects le'
    | count_gc_objects(LambdaTypes.APP(LambdaTypes.BUILTIN prim, le')) =
      if prim = Pervasives.LOAD_STRING then 0 else count_gc_objects le'
    | count_gc_objects(LambdaTypes.APP(le, le')) =
      count_gc_objects le + count_gc_objects le'
    | count_gc_objects(LambdaTypes.FN(lv, lexp,_)) = 1 + count_gc_objects lexp
    | count_gc_objects(LambdaTypes.LETREC(lv_list, le_list, lexp)) =
      Lists.reducel op +
      (count_gc_objects lexp,
       map (count_gc_objects o (fn x => LambdaSub.eta_abstract(x,""))) le_list)
    | count_gc_objects(LambdaTypes.SCON scon) =
	(case scon of
	  Ident.INT _ => 0
	| _ => 1)
    | count_gc_objects(LambdaTypes.INT _) = 0
    | count_gc_objects(LambdaTypes.SWITCH(le, tag_le_list, le1_opt, le2_opt)) =
      let fun count_tag_list [] = 0
	| count_tag_list((tag, le) :: rest) =
	  (case tag of
	    LambdaTypes.EXP_TAG lexp =>
	      if count_gc_objects lexp <> 0 then
		Crash.impossible"EXP_TAG contains static gc"
	      else 0
	  | LambdaTypes.SCON_TAG(Ident.REAL _) => 1
	  | LambdaTypes.SCON_TAG(Ident.STRING _) => 1
	  | _ => 0) + count_gc_objects le + count_tag_list rest
	fun count_le_opt LambdaTypes.ABSENT = 0
	| count_le_opt(LambdaTypes.PRESENT le) = count_gc_objects le
      in
	count_gc_objects le + count_tag_list tag_le_list +
	count_le_opt le1_opt + count_le_opt le2_opt
      end
    | count_gc_objects(LambdaTypes.STRUCT le_list) =
      Lists.reducel op + (0, map count_gc_objects le_list)
    | count_gc_objects(LambdaTypes.SELECT(_, le)) = count_gc_objects le
    | count_gc_objects(LambdaTypes.RAISE le) = count_gc_objects le
    | count_gc_objects(LambdaTypes.HANDLE(le, le' as LambdaTypes.FN _)) =
      count_gc_objects le + count_gc_objects le'
    | count_gc_objects(LambdaTypes.HANDLE(le, le')) =
      count_gc_objects le + count_gc_objects(LambdaSub.eta_abstract (le',""))
    | count_gc_objects(LambdaTypes.BUILTIN _) = 0

  fun count_gc_tags(LambdaTypes.SCON_TAG(Ident.REAL _)) = 1
    | count_gc_tags(LambdaTypes.SCON_TAG(Ident.STRING _)) = 1
    | count_gc_tags _ = 0
*)
  fun count_gc_objects _ =
    Crash.impossible"Mir_Utils.count_gc_objects no longer supported"

  fun count_gc_tags _ =
    Crash.impossible"Mir_Utils.count_gc_tags no longer supported"

d358 16
d377 17
a393 10
      MirTypes.ABSENT => (case last of
	[] => (first @@ first', blocks @@ blocks', tag', last')
      | _ => Crash.impossible"non-empty last with no tag")
    | MirTypes.PRESENT tag_val => (case tag' of
        MirTypes.ABSENT => (case last' of
	  [] => (first, blocks @@ blocks', tag, last @@ first')
	| _ => Crash.impossible"non-empty last' with no tag")
      | MirTypes.PRESENT tag_val' =>
	(first, MirTypes.BLOCK(tag_val, last @@ first') :: blocks @@ blocks',
	 tag', last'))), values @@ values', set @@ set')
d475 1
a475 1
     free, the set of free variables.
d485 1
a485 2
      val free_list = Set.set_to_list free
      val free_size = Lists.length free_list
d491 1
a491 1
	(fn (_, n) => #1 (Lists.number_from_by_one(free_list, statics+funs-n,
d503 1
a503 1
	free_list
d559 7
a565 4
       setup_dynamics @@
       (MirTypes.ALLOCATE(MirTypes.ALLOC, reg_operand,
			  MirTypes.GP_IMM_INT closure_size) ::
	copy_dynamics @@ copy_statics),
d589 3
a591 1
	      ((MirTypes.COMMENT("Evaluate function to be called") :: first,
d595 3
a597 1
	((MirTypes.COMMENT("Evaluate function argument") :: first',
d668 2
a669 1
	    ((extra_code @@ call_code, [], MirTypes.ABSENT, []), [], []))))
d782 3
a784 1
	      ((MirTypes.COMMENT("Evaluate function to be called") :: first,
d788 3
a790 1
	((MirTypes.COMMENT("Evaluate function argument") :: first',
d833 3
a835 1
	combine(arg_code, ((extra_arg_code, [], MirTypes.ABSENT, []), [], []))
d918 2
a919 1
	(arg_code, ((call_code, [], MirTypes.ABSENT, []), [], []))))
@


1.4
log
@Changed reducel op @@ to reducer op @@ to avoid quadratic behaviour
@
text
@d4 3
d96 1
a96 2
    Set.is_member(prim, Library.external_references le)
  (* Used for spotting implicit requirements such as STRINGEQ for SWITCH *)
d106 1
d140 1
d142 4
d193 3
d197 3
d689 8
d739 2
a740 1
    (* Build up a tupled arg for a tail recursion *)
d795 7
a801 1
	      send_to_given_reg(ONE(Lists.nth(i, gc_regs)), r)
d917 8
@


1.3
log
@First version of the profiler
@
text
@d4 3
d66 12
d240 3
a242 3
      Lists.reducel
      (fn (x, (y, z)) => x @@ z)
      ([], reg_code_list)
d246 2
a247 2
    (new_reg, Lists.reducel op @@
      (start_code @@ [alloc_op],
d273 1
a273 1
      number_list))
d285 2
a286 2
    (new_reg, Lists.reducel op @@
      ([alloc_op],
d319 1
a319 1
      number_list))
d582 2
a583 2
 	Lists.reducel op @@
	([MirTypes.COMMENT"Dynamic closure elements"],
d588 1
a588 1
	  clean_dynamics)
d590 3
a592 3
	Lists.reducel
	(fn (l, ((_, code), _)) => l @@ code)
	([], clean_dynamics)
d733 3
a735 3
		Lists.reducel
		(fn (x, (_, y)) => x @@ y)
		([], cleaned_regs_and_code)
d768 2
a769 3
	    Lists.reducel
	    op @@
	    (code,
d774 1
a774 1
	     int_reg_list)
@


1.2
log
@Fixed minor potential problem with tupling real values
@
text
@d4 3
d90 1
a90 1
    | makes_calls(LambdaTypes.APP(LambdaTypes.FN(lv, le), le')) =
d98 1
a98 1
    | makes_calls(LambdaTypes.FN(lv, lexp)) = true
d124 1
a124 1
    | count_gc_objects(LambdaTypes.APP(LambdaTypes.FN(lv, le), le')) =
d130 1
a130 1
    | count_gc_objects(LambdaTypes.FN(lv, lexp)) = 1 + count_gc_objects lexp
d134 1
a134 1
       map (count_gc_objects o LambdaSub.eta_abstract) le_list)
d164 1
a164 1
      count_gc_objects le + count_gc_objects(LambdaSub.eta_abstract le')
d984 1
a984 1
    | get_string(LambdaTypes.FN(_, le)) = get_string le
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d550 13
d566 9
a574 13
	  map (fn ((reg, code), i) => code @@
	  (case reg of INT reg =>
	    [MirTypes.STOREOP(MirTypes.ST, reg_from_gp reg,
			      reg_operand, MirTypes.GP_IMM_ANY(start + 4*i))]
	  | REAL _ =>
	      let
		val (reg', code) = send_to_reg(ONE reg)
	      in
		code @@ [MirTypes.STOREOP(MirTypes.ST, reg_from_gp reg',
					 reg_operand,
					 MirTypes.GP_IMM_ANY(start + 4*i))]
	      end))
	  num_cl_code)
d601 2
a602 1
        MirTypes.ALLOCATE(MirTypes.ALLOC, reg_operand,
d604 1
a604 1
	copy_dynamics @@ copy_statics,
@
