head	1.48;
access;
symbols
	MLW_daveb_inline_1_4_99:1.48.4
	MLWorks_21c0_1999_03_25:1.48
	MLWorks_20c1_1998_08_20:1.48
	MLWorks_20c0_1998_08_04:1.48
	MLWorks_20b2c2_1998_06_19:1.48
	MLWorks_20b2_Windows_1998_06_12:1.48
	MLWorks_20b1c1_1998_05_07:1.48
	MLWorks_20b0_1998_04_07:1.48
	MLWorks_20b0_1998_03_20:1.48
	MLWorks_20m2_1998_02_16:1.48
	MLWorks_20m1_1997_10_23:1.48
	MLWorks_11r1:1.48.1.1.1.1.1
	MLWorks_workspace_97:1.48.3
	MLWorks_dt_wizard:1.48.2
	MLWorks_11c0_1997_09_09:1.48.1.1.1.1
	MLWorks_10r3:1.48.1.1.3
	MLWorks_10r2_551:1.48.1.1.2
	MLWorks_11:1.48.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.48.1.1
	MLWorks_20m0_1997_06_20:1.48
	MLWorks_1_0_r2c2_1997_06_14:1.48.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.48.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.48.1
	MLWorks_BugFix_1997_04_24:1.48
	MLWorks_1_0_r2_Win32_1997_04_11:1.48
	MLWorks_1_0_r2_Unix_1997_04_04:1.48
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.47.6.1.1
	MLWorks_gui_1996_12_18:1.47.7
	MLWorks_1_0_Win32_1996_12_17:1.47.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.47.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.47.4.1
	MLWorks_1_0_Irix_1996_11_28:1.47.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.47.5
	MLWorks_1_0_Unix_1996_11_14:1.47.4
	MLWorks_Open_Beta2_1996_10_11:1.47.3
	MLWorks_License_dev:1.47.2
	MLWorks_1_open_beta_1996_09_13:1.47.1
	MLWorks_Open_Beta_1996_08_22:1.47
	MLWorks_Beta_1996_07_02:1.47
	MLWorks_Beta_1996_06_07:1.47
	MLWorks_Beta_1996_06_06:1.47
	MLWorks_Beta_1996_06_05:1.47
	MLWorks_Beta_1996_06_03:1.47
	MLWorks_Beta_1996_05_31:1.47
	MLWorks_Beta_1996_05_30:1.47
	ML_beta_release_12/08/94:1.43
	ML_beta_release_03/08/94:1.43
	ML_revised_beta_release_25/05/94:1.43
	ML_final_beta_release_02/03/94:1.42
	mlworks-28-01-1994:1.42
	Release:1.42
	mlworks-beta-01-09-1993:1.42
	MLWorks-1-0-4-29/01/1993:1.41
	MLWorks-1-0-3-21/12/1992:1.41
	MLWorks-1-0-2-15/12/1992:1.41
	MLWorks-1-0-1-04/12/1992:1.40
	checkpoint_17_08_92:1.38;
locks; strict;
comment	@ * @;


1.48
date	96.12.16.15.05.05;	author matthew;	state Exp;
branches
	1.48.1.1
	1.48.2.1
	1.48.3.1
	1.48.4.1;
next	1.47;

1.47
date	95.12.22.12.52.54;	author jont;	state Exp;
branches
	1.47.1.1
	1.47.2.1
	1.47.3.1
	1.47.4.1
	1.47.5.1
	1.47.6.1
	1.47.7.1;
next	1.46;

1.46
date	95.05.30.11.37.08;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	94.09.19.16.06.51;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	94.08.26.13.59.26;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	94.04.12.11.05.47;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	93.07.30.14.45.30;	author nosa;	state Exp;
branches
	1.42.1.1;
next	1.41;

1.41
date	92.12.08.20.03.01;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	92.11.02.18.04.39;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	92.08.26.15.42.57;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	92.06.17.10.51.17;	author richard;	state Exp;
branches;
next	1.37;

1.37
date	92.06.04.14.23.15;	author richard;	state Exp;
branches;
next	1.36;

1.36
date	92.05.21.11.51.06;	author richard;	state Exp;
branches;
next	1.35;

1.35
date	92.04.28.14.23.02;	author richard;	state Exp;
branches;
next	1.34;

1.34
date	92.04.23.11.12.45;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	92.04.13.15.29.55;	author richard;	state Exp;
branches;
next	1.32;

1.32
date	92.03.05.15.46.15;	author richard;	state Exp;
branches;
next	1.31;

1.31
date	92.03.02.12.13.55;	author richard;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	92.02.17.17.26.56;	author richard;	state Exp;
branches;
next	1.29;

1.29
date	92.02.10.13.06.23;	author richard;	state Exp;
branches;
next	1.28;

1.28
date	92.01.28.12.18.19;	author richard;	state Exp;
branches;
next	1.27;

1.27
date	91.11.18.16.47.59;	author richard;	state Exp;
branches;
next	1.26;

1.26
date	91.11.08.11.26.48;	author richard;	state Exp;
branches;
next	1.25;

1.25
date	91.11.07.11.38.20;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	91.10.29.09.45.00;	author richard;	state Exp;
branches;
next	1.23;

1.23
date	91.10.28.14.13.43;	author richard;	state Exp;
branches;
next	1.22;

1.22
date	91.10.25.14.46.54;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	91.10.21.14.14.09;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	91.10.17.11.32.35;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	91.10.16.14.37.23;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	91.10.15.13.50.34;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	91.10.11.09.56.14;	author richard;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	91.10.10.14.56.03;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	91.10.10.13.04.41;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	91.10.07.11.55.33;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	91.10.04.14.08.05;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	91.10.04.13.26.39;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	91.10.03.15.37.35;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	91.09.30.10.16.10;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	91.09.24.11.31.50;	author richard;	state Exp;
branches
	1.9.1.1;
next	1.8;

1.8
date	91.09.18.18.39.31;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	91.09.17.15.37.01;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.09.16.12.43.10;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	91.09.10.10.22.04;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	91.09.09.10.42.55;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.09.05.16.46.46;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.09.04.15.28.19;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	91.09.02.12.05.16;	author richard;	state Exp;
branches;
next	;

1.9.1.1
date	91.09.26.14.58.10;	author richard;	state Exp;
branches;
next	;

1.17.1.1
date	91.10.14.16.22.24;	author richard;	state Exp;
branches;
next	;

1.31.1.1
date	92.03.04.15.14.14;	author richard;	state Exp;
branches;
next	;

1.42.1.1
date	93.07.30.14.45.30;	author jont;	state Exp;
branches;
next	;

1.47.1.1
date	96.09.13.11.14.04;	author hope;	state Exp;
branches;
next	;

1.47.2.1
date	96.10.07.16.04.34;	author hope;	state Exp;
branches;
next	;

1.47.3.1
date	96.10.17.11.22.48;	author hope;	state Exp;
branches;
next	;

1.47.4.1
date	96.11.14.12.47.02;	author hope;	state Exp;
branches
	1.47.4.1.1.1;
next	;

1.47.4.1.1.1
date	96.11.28.14.58.38;	author hope;	state Exp;
branches;
next	;

1.47.5.1
date	96.11.22.18.07.09;	author hope;	state Exp;
branches;
next	;

1.47.6.1
date	96.12.17.17.45.53;	author hope;	state Exp;
branches
	1.47.6.1.1.1;
next	;

1.47.6.1.1.1
date	97.02.24.11.35.25;	author hope;	state Exp;
branches;
next	;

1.47.7.1
date	96.12.18.09.39.52;	author hope;	state Exp;
branches;
next	;

1.48.1.1
date	97.05.12.10.32.13;	author hope;	state Exp;
branches
	1.48.1.1.1.1
	1.48.1.1.2.1
	1.48.1.1.3.1;
next	;

1.48.1.1.1.1
date	97.07.28.18.17.56;	author daveb;	state Exp;
branches
	1.48.1.1.1.1.1.1;
next	;

1.48.1.1.1.1.1.1
date	97.10.07.11.42.54;	author jkbrook;	state Exp;
branches;
next	;

1.48.1.1.2.1
date	97.09.08.17.11.30;	author daveb;	state Exp;
branches;
next	;

1.48.1.1.3.1
date	97.09.09.14.07.06;	author daveb;	state Exp;
branches;
next	;

1.48.2.1
date	97.09.10.19.21.49;	author brucem;	state Exp;
branches;
next	;

1.48.3.1
date	97.09.11.20.53.04;	author daveb;	state Exp;
branches;
next	;

1.48.4.1
date	99.04.01.17.55.56;	author daveb;	state Exp;
branches;
next	;


desc
@Functor for HARP optimiser
@


1.48
log
@Removing references to MLWorks.Option
@
text
@(*  ==== MIR OPTIMISER ====
 *          FUNCTOR
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  This functor doesn't do any optimisation itself, it just invokes other
 *  optimisation phases and generates diagnostic output.
 *
 *  Revision Log
 *  ------------
 *  $Log: _miroptimiser.sml,v $
 * Revision 1.47  1995/12/22  12:52:54  jont
 * Removing Option in favour of MLWorks.Option
 *
 *  Revision 1.46  1995/05/30  11:37:08  matthew
 *  Adding debug flag to RegisterAllocator.analyse
 *
 *  Revision 1.45  1994/09/19  16:06:51  matthew
 *  Reinstated call to MirExpr.simple_transform before colouring
 *
 *  Revision 1.44  1994/08/26  13:59:26  matthew
 *  Added and commented out call to MirExpr.simple_transform
 *  Experiment is needed for this.
 *
 *  Revision 1.43  1994/04/12  11:05:47  jont
 *  Adding expression analysis
 *
 *  Revision 1.42  1993/07/30  14:45:30  nosa
 *  Debugger Environments and extra stack spills for local and closure
 *  variable inspection in the debugger.
 *
 *  Revision 1.41  1992/12/08  20:03:01  jont
 *  Removed a number of duplicated signatures and structures
 *
 *  Revision 1.40  1992/11/02  18:04:39  jont
 *  Reworked in terms of mononewmap
 *
 *  Revision 1.39  1992/08/26  15:42:57  jont
 *  Removed some redundant structures and sharing
 *
 *  Revision 1.38  1992/06/17  10:51:17  richard
 *  Removed the redundant preallocator.  The work of the preallocator
 *  is now done by the annotator (RegisterPack, in fact).  There is no
 *  longer any need to pass hints to the graph.
 *
 *  Revision 1.37  1992/06/04  14:23:15  richard
 *  Changed order of stages.  The Preallocator stage is now done before
 *  variable analysis, as it produces information used in building the
 *  register clash graph.  The graph is now updated directly by the
 *  MirVariable analyser, greatly reducing garbage and increasing
 *  efficiency.
 *
 *  Revision 1.36  1992/05/21  11:51:06  richard
 *  Added diagnostic to print names of procedures.
 *
 *  Revision 1.35  1992/04/28  14:23:02  richard
 *  Added register preallocator.
 *
 *  Revision 1.34  1992/04/23  11:12:45  jont
 *  Changed all instances of timer_ to timer
 *
 *  Revision 1.33  1992/04/13  15:29:55  richard
 *  Removed available expression analysis.  Temporarily, I hope.
 *
 *  Revision 1.32  1992/03/05  15:46:15  richard
 *  MirExpression now uses MirProcedure annotated procedures so the
 *  MirOptTypes and MirFlow modules can finally be abolished.
 *
 *  Revision 1.31  1992/03/02  12:13:55  richard
 *  Changes to reflect version 2.1 of MirVariable and new procedure annotation
 *  method.  Added timings.
 *
 *  Revision 1.30  1992/02/17  17:26:56  richard
 *  Moved register assignments to the top level of this structure.
 *
 *  Revision 1.29  1992/02/10  13:06:23  richard
 *  Abolished the second pass of optimization.  It wasn't acheiving much.
 *  
 *  Revision 1.28  1992/01/28  12:18:19  richard
 *  Changed diagnostic output to reflect changes in MirOptTypes.
 *  
 *  Revision 1.27  1991/11/18  16:47:59  richard
 *  Changed debugging output to use the Diagnostic module.
 *  
 *  Revision 1.26  91/11/08  11:26:48  richard
 *  Added a debugging function.
 *  
 *  Revision 1.25  91/11/07  11:38:20  richard
 *  Added a second pass of optimisation to clean up after register
 *  substitution and spill instruction insertion.
 *  
 *  Revision 1.24  91/10/29  09:45:00  richard
 *  Added StackAllocator to optimisations.
 *  
 *  Revision 1.23  91/10/28  14:13:43  richard
 *  Removed redundant requires which I left in by mistake after a
 *  debugging session.
 *  
 *  Revision 1.22  91/10/25  14:46:54  richard
 *  Removed explicit dependency on the representation of MirOptTypes.procedure.
 *  
 *  Revision 1.21  91/10/21  14:14:09  richard
 *  Added Print to dependencies.
 *  
 *  Revision 1.20  91/10/17  11:32:35  richard
 *  Added Switches structure. Removed redundant MirDataFlow module.
 *  
 *  Revision 1.19  91/10/16  14:37:23  richard
 *  Removed procedure parameters to reflect changes in MirTypes.
 *  
 *  Revision 1.18  91/10/15  13:50:34  richard
 *  Deleted register assignments. These can now be found in the
 *  MirRegisters structure.
 *  
 *  Revision 1.17  91/10/11  09:56:14  richard
 *  Slight alterations to cope with new MirTypes.
 *  
 *  Revision 1.16  91/10/10  14:56:03  richard
 *  The loader block is now allocated.
 *  
 *  Revision 1.14  91/10/07  11:55:33  richard
 *  Changed dependency on MachRegisters to MachSpec.
 *  
 *  Revision 1.13  91/10/04  14:08:05  richard
 *  Optimisation and register allocation of the loader setup block.
 *  
 *  Revision 1.12  91/10/04  13:26:39  richard
 *  Rewrote the optimiser top level to use the new MirTypes code structure,
 *  with significant benefits for code size and speed! Also, the functor
 *  now exports the register assignment tables for the target machine.
 *  
 *  Revision 1.11  91/10/03  15:37:35  richard
 *  Added a quick fix to allow register allocation to return some extra
 *  stuff. The extra stuff is ignored at the moment.
 *  
 *  Revision 1.10  91/09/30  10:16:10  richard
 *  Added register allocator to optimiser module.
 *  
 *  Revision 1.9  91/09/24  11:31:50  richard
 *  Modified to use a table of blocks rather than a simple list. This allows
 *  procedure blocks to be in _any_ order, they will all be caught by
 *  control flow analysis. See also MirOptTypes.
 *  
 *  Revision 1.8  91/09/18  18:39:31  richard
 *  Fixed the squish function, which didn't cope with single-block
 *  procedures.
 *  
 *  Revision 1.7  91/09/17  15:37:01  richard
 *  Code to annotate and deannotate blocks moved here from MirDataflow
 *  module. Also minor changes related to the break-up of MirDataflow
 *  (see log for that file).
 *  
 *  Revision 1.6  91/09/16  12:43:10  richard
 *  Rewrote separate function to cope with nested procedures produced
 *  by the code generator.
 *  
 *  Revision 1.5  91/09/10  10:22:04  richard
 *  Minor changes to invocation of dataflow analyser to prevent
 *  inexhaustive binding.
 *  
 *  Revision 1.4  91/09/09  10:42:55  richard
 *  Changed filename of mirpeep to mirpeepholer.
 *  Removed some redundant debugging code.
 *  
 *  Revision 1.3  91/09/05  16:46:46  richard
 *  Removed redundant dataflow data structure (to MirDataFlow module),
 *  otherwise just test modifications to do with data flow.
 *  
 *  Revision 1.2  91/09/04  15:28:19  richard
 *  Early version of code to split up MIR code ready for
 *  dataflow analysis.
 *  
 *  Revision 1.1  91/09/02  12:05:16  richard
 *  Initial revision
 *)


require "../utils/diagnostic";
require "mirvariable";
require "mirregisters";
require "mirexpr";
require "stackallocator";
require "miroptimiser";


functor MirOptimiser(
  structure MirVariable		: MIRVARIABLE
  structure StackAllocator	: STACKALLOCATOR
  structure MirRegisters	: MIRREGISTERS
  structure MirExpr		: MIREXPR
  structure Diagnostic		: DIAGNOSTIC

  sharing
    MirRegisters.MirTypes =
    MirVariable.RegisterAllocator.MirProcedure.MirTypes =
    MirExpr.MirTypes

  sharing Diagnostic.Text = MirVariable.RegisterAllocator.MirProcedure.Text

  sharing MirVariable.RegisterAllocator.MirProcedure =
    StackAllocator.MirProcedure

) : MIROPTIMISER =

  struct
    structure RegisterAllocator = MirVariable.RegisterAllocator
    structure MirProcedure = RegisterAllocator.MirProcedure
    structure MirTypes = MirProcedure.MirTypes
    structure Diagnostic = Diagnostic
    structure MachSpec = MirRegisters.MachSpec


    (*  == Diagnostic output functions ==  *)

    infix ^^
    val (op^^) = Diagnostic.Text.concatenate
    val $ = Diagnostic.Text.from_string

    fun listing (level, message, procedure) =
      Diagnostic.output_text level
      (fn _ =>
       $"MirOptimiser: " ^^ $message ^^ $"\n" ^^
       MirProcedure.to_text procedure)

    val machine_register_assignments = MirRegisters.machine_register_assignments



    (*  === OPTIMISE MIR CODE ===
     *
     *  A simple application of each of the optimisation passes.
     *)

    fun optimise (MirTypes.CODE(refs, values, proc_sets),make_debugging_code) =
      let
        fun optimise' (procedure as MirTypes.PROC (name, tag,proc as MirTypes.PROC_PARAMS{spill_sizes=spill_sizes', ...},blocks,runtime_env)) =
          let
            (* This may or may not be a good thing to do *)
            (* This stuff is done by the preferencer and unless we can eliminate unused registers ... *)
            (* Though code size does decrease with this *)
            (* Need to investigate the tradeoffs *)

            val procedure =
              MirTypes.PROC (name,tag,proc, MirExpr.simple_transform blocks,runtime_env)

            val _ =
              Diagnostic.output 1 (fn _ => ["MirOptimiser: procedure ", MirTypes.print_tag tag, ": ", name])

            val annotated as MirProcedure.P (annotation, _, _, _) =
              MirProcedure.annotate procedure

            val _ = listing (2, "after annotation", annotated)

            val graph =
              RegisterAllocator.empty (#nr_registers annotation,make_debugging_code)

            val varied = MirVariable.analyse (annotated, graph)

            val _ = listing (2, "after variable analysis", varied)

            val spill_sizes = 
              case #spill_sizes((fn MirTypes.PROC_PARAMS params=>params)
                                (#parameters(annotation))) of
                NONE => {gc = 0, non_gc = 0, fp = 0}
              | SOME(spill_sizes) => spill_sizes

            val registered =
              RegisterAllocator.analyse (varied, graph,spill_sizes,make_debugging_code)

            val _ = listing (2, "after register allocation", registered)

            val stacked = StackAllocator.allocate registered

            val _ = listing (2, "after stack allocation", stacked)

            val MirTypes.PROC (name, tag, proc, block,_) = MirProcedure.unannotate stacked
	    val block = MirExpr.transform block
	    val proc = case proc of
	      MirTypes.PROC_PARAMS{spill_sizes, stack_allocated, ...} =>
		MirTypes.PROC_PARAMS
		{spill_sizes = spill_sizes,
		 old_spill_sizes = spill_sizes',
		 stack_allocated = stack_allocated}
          in
            MirTypes.PROC (name, tag, proc, block,runtime_env)
          end
      in
        MirTypes.CODE(refs, values, map (map optimise') proc_sets)
      end


  end
@


1.48.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a13 3
 * Revision 1.48  1996/12/16  15:05:05  matthew
 * Removing references to MLWorks.Option
 *
@


1.48.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a13 3
 * Revision 1.48  1996/12/16  15:05:05  matthew
 * Removing references to MLWorks.Option
 *
@


1.48.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a13 3
 * Revision 1.48  1996/12/16  15:05:05  matthew
 * Removing references to MLWorks.Option
 *
@


1.48.1.1
log
@branched from 1.48
@
text
@a13 3
 * Revision 1.48  1996/12/16  15:05:05  matthew
 * Removing references to MLWorks.Option
 *
@


1.48.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a13 3
 * Revision 1.48.1.1  1997/05/12  10:32:13  hope
 * branched from 1.48
 *
@


1.48.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a13 3
 * Revision 1.48.1.1  1997/05/12  10:32:13  hope
 * branched from 1.48
 *
@


1.48.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a13 3
 * Revision 1.48.1.1  1997/05/12  10:32:13  hope
 * branched from 1.48
 *
@


1.48.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a13 3
 * Revision 1.48.1.1.1.1  1997/07/28  18:17:56  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.47
log
@Removing Option in favour of MLWorks.Option
@
text
@d14 3
d254 1
a254 1
            val _ = listing (3, "after annotation", annotated)
d266 2
a267 2
                MLWorks.Option.NONE => {gc = 0, non_gc = 0, fp = 0}
              | MLWorks.Option.SOME(spill_sizes) => spill_sizes
@


1.47.7.1
log
@branched from 1.47
@
text
@a13 3
 * Revision 1.47  1995/12/22  12:52:54  jont
 * Removing Option in favour of MLWorks.Option
 *
@


1.47.6.1
log
@branched from 1.47
@
text
@a13 3
 * Revision 1.47  1995/12/22  12:52:54  jont
 * Removing Option in favour of MLWorks.Option
 *
@


1.47.6.1.1.1
log
@branched from 1.47.6.1
@
text
@a13 3
 * Revision 1.47.6.1  1996/12/17  17:45:53  hope
 * branched from 1.47
 *
@


1.47.5.1
log
@branched from 1.47
@
text
@a13 3
 * Revision 1.47  1995/12/22  12:52:54  jont
 * Removing Option in favour of MLWorks.Option
 *
@


1.47.4.1
log
@branched from 1.47
@
text
@a13 3
 * Revision 1.47  1995/12/22  12:52:54  jont
 * Removing Option in favour of MLWorks.Option
 *
@


1.47.4.1.1.1
log
@branched from 1.47.4.1
@
text
@a13 3
 * Revision 1.47.4.1  1996/11/14  12:47:02  hope
 * branched from 1.47
 *
@


1.47.3.1
log
@branched from 1.47
@
text
@a13 3
 * Revision 1.47  1995/12/22  12:52:54  jont
 * Removing Option in favour of MLWorks.Option
 *
@


1.47.2.1
log
@branched from 1.47
@
text
@a13 3
 * Revision 1.47  1995/12/22  12:52:54  jont
 * Removing Option in favour of MLWorks.Option
 *
@


1.47.1.1
log
@branched from 1.47
@
text
@a13 3
 * Revision 1.47  1995/12/22  12:52:54  jont
 * Removing Option in favour of MLWorks.Option
 *
@


1.46
log
@Adding debug flag to RegisterAllocator.analyse
@
text
@d14 3
d235 1
a235 1
        fun optimise' (procedure as MirTypes.PROC (name, tag,proc,blocks,runtime_env)) =
d263 2
a264 2
                MirTypes.Option.ABSENT => {gc = 0, non_gc = 0, fp = 0}
              | MirTypes.Option.PRESENT(spill_sizes) => spill_sizes
d277 6
@


1.45
log
@Reinstated call to MirExpr.simple_transform before colouring
@
text
@d14 3
a174 1
require "../utils/timer";
a187 1
  structure Timer		: TIMER
a220 2
    val show_timings = ref false

d230 1
a230 1
    fun optimise (MirTypes.CODE(refs, values, proc_sets)) =
d239 2
a240 3
            val procedure = Timer.xtime ("Preoptimization", 
                                         !show_timings, 
                                         fn () => (MirTypes.PROC (name,tag,proc, MirExpr.simple_transform blocks,runtime_env)))
d246 1
a246 1
              Timer.xtime ("Annotation", !show_timings, fn () => MirProcedure.annotate procedure)
d251 1
a251 1
              Timer.xtime ("Building graph", !show_timings, fn () => RegisterAllocator.empty (#nr_registers annotation))
d253 1
a253 1
            val varied = Timer.xtime ("Variable", !show_timings, fn () => MirVariable.analyse (annotated, graph))
d262 1
d264 1
a264 1
              Timer.xtime ("RegAlloc", !show_timings, fn () => RegisterAllocator.analyse (varied, graph,spill_sizes))
d268 1
a268 1
            val stacked = Timer.xtime ("StackAlloc", !show_timings, fn () => StackAllocator.allocate registered)
@


1.44
log
@Added and commented out call to MirExpr.simple_transform
Experiment is needed for this.
@
text
@d14 4
d240 3
a242 1
            val procedure = procedure (* Timer.xtime ("Preoptimization", !show_timings, fn () => (MirTypes.PROC (name,tag,proc, MirExpr.simple_transform blocks,runtime_env))) *)
@


1.43
log
@Adding expression analysis
@
text
@d14 3
d224 1
a224 2
     *  A beautifully simple application of each of the optimisation
     *  passes.
d229 1
a229 1
        fun optimise' (procedure as MirTypes.PROC (name, tag, _, _,runtime_env)) =
d231 7
@


1.42
log
@Debugger Environments and extra stack spills for local and closure
variable inspection in the debugger.
@
text
@d14 4
d168 1
d177 1
d183 2
a184 1
    MirVariable.RegisterAllocator.MirProcedure.MirTypes
d259 1
@


1.42.1.1
log
@Fork for bug fixing
@
text
@a13 4
 *  Revision 1.42  1993/07/30  14:45:30  nosa
 *  Debugger Environments and extra stack spills for local and closure
 *  variable inspection in the debugger.
 *
@


1.41
log
@Removed a number of duplicated signatures and structures
@
text
@d14 3
d220 1
a220 1
        fun optimise' (procedure as MirTypes.PROC (name, tag, _, _)) =
d237 5
d243 1
a243 1
              Timer.xtime ("RegAlloc", !show_timings, fn () => RegisterAllocator.analyse (varied, graph))
d251 1
a251 1
            val unannotated = MirProcedure.unannotate stacked
d253 1
a253 1
            unannotated
@


1.40
log
@Reworked in terms of mononewmap
@
text
@d14 3
a157 2
require "../utils/crash";
require "../utils/print";
a158 1
require "mirprocedure";
d160 1
a160 1
require "registerallocator";
a161 2
require "mirprint";
require "mirregisters";
a165 1
  structure MirProcedure	: MIRPROCEDURE
a166 1
  structure RegisterAllocator	: REGISTERALLOCATOR
d174 1
a174 2
    MirProcedure.MirTypes =
    RegisterAllocator.MirTypes
d176 1
a176 1
  sharing Diagnostic.Text = MirProcedure.Text
d178 1
a178 3
  sharing MirProcedure =
    MirVariable.MirProcedure =
    RegisterAllocator.MirProcedure =
a180 2
  sharing RegisterAllocator = MirVariable.RegisterAllocator

d184 2
@


1.39
log
@Removed some redundant structures and sharing
@
text
@d14 3
a194 1
    structure Map = MirTypes.Debugger_Types.Datatypes.NewMap
@


1.38
log
@Removed the redundant preallocator.  The work of the preallocator
is now done by the annotator (RegisterPack, in fact).  There is no
longer any need to pass hints to the graph.
@
text
@d14 5
a154 1
require "mirtypes";
a164 2

  structure MirTypes		: MIRTYPES
d173 1
a173 1
  sharing MirTypes =
d190 1
a190 2

    structure MirTypes = MirTypes
d192 1
a192 1
    structure Map = MirRegisters.Map
@


1.37
log
@Changed order of stages.  The Preallocator stage is now done before
variable analysis, as it produces information used in building the
register clash graph.  The graph is now updated directly by the
MirVariable analyser, greatly reducing garbage and increasing
efficiency.
@
text
@d14 7
a151 1
require "mirexpression";
a152 1
require "preallocator";
a163 1
  structure MirExpression	: MIREXPRESSION
a164 1
  structure Preallocator 	: PREALLOCATOR
d181 1
a181 3
    StackAllocator.MirProcedure =
    MirExpression.MirProcedure =
    Preallocator.MirProcedure
a230 2
            val hints = Timer.xtime ("Prealloc", !show_timings, fn () => Preallocator.analyse annotated)

d232 1
a232 1
              Timer.xtime ("Building graph", !show_timings, fn () => RegisterAllocator.empty (#nr_registers annotation, hints))
@


1.36
log
@Added diagnostic to print names of procedures.
@
text
@d14 3
d182 2
d220 1
a220 1
        fun optimise' procedure =
d223 4
a226 7
              Diagnostic.output 1
              (fn _ =>
               let
                 val MirTypes.PROC (name, tag, _, _) = procedure
               in 
                 ["MirOptimiser: procedure ", MirTypes.print_tag tag, ": ", name]
               end)
a227 1
            val annotated = Timer.xtime ("Annotation", !show_timings, fn () => MirProcedure.annotate procedure)
d229 8
a236 1
            val (varied, clashes) = Timer.xtime ("Variable",   !show_timings, fn () => MirVariable.analyse annotated)
d238 4
a241 2
            val hints = Timer.xtime ("Prealloc",   !show_timings, fn () => Preallocator.analyse varied)
            val registered = Timer.xtime ("RegAlloc",   !show_timings, fn () => RegisterAllocator.analyse (varied, clashes, hints))
d243 1
d245 1
d247 1
@


1.35
log
@Added register preallocator.
@
text
@d14 3
d217 9
@


1.34
log
@Changed all instances of timer_ to timer
@
text
@d14 3
d141 1
d155 1
d173 2
a174 1
    MirExpression.MirProcedure
d214 1
a214 1
            val annotated   = Timer.xtime ("Annotation", !show_timings, fn () => MirProcedure.annotate procedure)
d216 4
a219 3
            val varied      = Timer.xtime ("Variable",   !show_timings, fn () => MirVariable.analyse annotated)
            val _ = listing (2, "after variable analysis", #1 varied)
            val registered  = Timer.xtime ("RegAlloc",   !show_timings, fn () => RegisterAllocator.analyse varied)
d221 1
a221 1
            val stacked     = Timer.xtime ("StackAlloc", !show_timings, fn () => StackAllocator.allocate registered)
@


1.33
log
@Removed available expression analysis.  Temporarily, I hope.
@
text
@d14 3
d208 1
a208 1
            val annotated   = Timer_.xtime ("Annotation", !show_timings, fn () => MirProcedure.annotate procedure)
d210 1
a210 1
            val varied      = Timer_.xtime ("Variable",   !show_timings, fn () => MirVariable.analyse annotated)
d212 1
a212 1
            val registered  = Timer_.xtime ("RegAlloc",   !show_timings, fn () => RegisterAllocator.analyse varied)
d214 1
a214 1
            val stacked     = Timer_.xtime ("StackAlloc", !show_timings, fn () => StackAllocator.allocate registered)
@


1.32
log
@MirExpression now uses MirProcedure annotated procedures so the
MirOptTypes and MirFlow modules can finally be abolished.
@
text
@d14 4
d207 1
a207 4
            val expressed   = Timer_.xtime ("Expression", !show_timings, fn () => MirExpression.analyse annotated)
            val annotated'  = Timer_.xtime ("Reannotation",!show_timings, fn () => MirProcedure.annotate expressed)
            val _ = listing (2, "after expression analysis and reannotation", annotated')
            val varied      = Timer_.xtime ("Variable",   !show_timings, fn () => MirVariable.analyse annotated')
@


1.31
log
@Changes to reflect version 2.1 of MirVariable and new procedure annotation
method.  Added timings.
@
text
@d14 4
d128 2
a130 2
require "mirexpression";
require "mirflow";
d132 1
a132 2
require "miropttypes";
require "switches";
d134 1
a134 3
require "mirtables";
require "stackallocator";
require "mirprocedure";
a139 1
  structure MirOptTypes		: MIROPTTYPES
d141 2
a143 4
  structure MirExpression	: MIREXPRESSION
  structure MirFlow		: MIRFLOW
  structure MirRegisters	: MIRREGISTERS
  structure MirProcedure	: MIRPROCEDURE
d146 1
a150 2
    MirOptTypes.MirTypes =
    StackAllocator.MirTypes =
a154 4
  sharing MirOptTypes =
    MirExpression.MirOptTypes =
    MirFlow.MirOptTypes

d157 5
a161 1
  sharing MirProcedure = MirVariable.MirProcedure = RegisterAllocator.MirProcedure
a174 5
    fun listing (level, message, procedure) =
      Diagnostic.output level
      (fn _ => ["MirOptimiser: ", message, "\n"] @@
       (MirOptTypes.print_procedure procedure));

d179 1
a179 1
    fun listing' (level, message, procedure) =
d201 5
a205 9
            val annotated   = Timer_.xtime ("Annotation", !show_timings, fn () => MirOptTypes.annotate procedure)
            val _ = listing (2, "after annotation", annotated)
            val flow_traced = Timer_.xtime ("Flow",       !show_timings, fn () => MirFlow.trace annotated)
            val _ = listing (2, "after flow analysis", flow_traced)
            val expressed   = Timer_.xtime ("Expression", !show_timings, fn () => MirExpression.analyse flow_traced)
            val _ = listing (2, "after expression analysis", expressed)
            val annotated'  = Timer_.xtime ("Annotation'",!show_timings, fn () =>
                                            MirProcedure.annotate (MirOptTypes.unannotate expressed))
            val _ = listing' (2, "after reannotation", annotated')
d207 1
a207 1
            val _ = listing' (2, "after variable analysis", #1 varied)
d209 1
d211 2
d214 1
a214 1
            stacked
@


1.31.1.1
log
@Experimental version with StackAllocator using MirProcedure
annotated procedures.
@
text
@a13 4
 *  Revision 1.31  1992/03/02  12:13:55  richard
 *  Changes to reflect version 2.1 of MirVariable and new procedure annotation
 *  method.  Added timings.
 *
a157 5
  sharing MirProcedure =
    StackAllocator.MirProcedure =
    MirVariable.MirProcedure =
    RegisterAllocator.MirProcedure

d164 2
d210 1
a210 1
            val _ = listing (3, "after annotation", annotated)
d212 1
a212 1
            val _ = listing (3, "after flow analysis", flow_traced)
d217 1
a217 1
            val _ = listing' (3, "after reannotation", annotated')
d221 1
a221 4
            val annotated'' = Timer_.xtime ("Annotation''", !show_timings, fn () => MirProcedure.annotate registered)
            val _ = listing' (2, "after register allocation and annotation''", annotated'')
            val stacked     = Timer_.xtime ("StackAlloc", !show_timings, fn () => StackAllocator.allocate annotated'')
            val _ = listing' (2, "after stack allocation", stacked)
d223 1
a223 1
            MirProcedure.unannotate stacked
@


1.30
log
@Moved register assignments to the top level of this structure.
@
text
@d1 2
a2 5
(* _miroptimiser.sml the functor *)
(*
$Log: _miroptimiser.sml,v $
 *  Revision 1.30  1992/02/14  16:10:04  richard
 *  No time no time! The bus is coming!
d4 113
a116 2
Revision 1.29  1992/02/10  13:06:23  richard
Abolished the second pass of optimization.  It wasn't acheiving much.
a117 2
Revision 1.28  1992/01/28  12:18:19  richard
Changed diagnostic output to reflect changes in MirOptTypes.
a118 97
Revision 1.27  1991/11/18  16:47:59  richard
Changed debugging output to use the Diagnostic module.

Revision 1.26  91/11/08  11:26:48  richard
Added a debugging function.

Revision 1.25  91/11/07  11:38:20  richard
Added a second pass of optimisation to clean up after register
substitution and spill instruction insertion.

Revision 1.24  91/10/29  09:45:00  richard
Added StackAllocator to optimisations.

Revision 1.23  91/10/28  14:13:43  richard
Removed redundant requires which I left in by mistake after a
debugging session.

Revision 1.22  91/10/25  14:46:54  richard
Removed explicit dependency on the representation of MirOptTypes.procedure.

Revision 1.21  91/10/21  14:14:09  richard
Added Print to dependencies.

Revision 1.20  91/10/17  11:32:35  richard
Added Switches structure. Removed redundant MirDataFlow module.

Revision 1.19  91/10/16  14:37:23  richard
Removed procedure parameters to reflect changes in MirTypes.

Revision 1.18  91/10/15  13:50:34  richard
Deleted register assignments. These can now be found in the
MirRegisters structure.

Revision 1.17  91/10/11  09:56:14  richard
Slight alterations to cope with new MirTypes.

Revision 1.16  91/10/10  14:56:03  richard
The loader block is now allocated.

Revision 1.14  91/10/07  11:55:33  richard
Changed dependency on MachRegisters to MachSpec.

Revision 1.13  91/10/04  14:08:05  richard
Optimisation and register allocation of the loader setup block.

Revision 1.12  91/10/04  13:26:39  richard
Rewrote the optimiser top level to use the new MirTypes code structure,
with significant benefits for code size and speed! Also, the functor
now exports the register assignment tables for the target machine.

Revision 1.11  91/10/03  15:37:35  richard
Added a quick fix to allow register allocation to return some extra
stuff. The extra stuff is ignored at the moment.

Revision 1.10  91/09/30  10:16:10  richard
Added register allocator to optimiser module.

Revision 1.9  91/09/24  11:31:50  richard
Modified to use a table of blocks rather than a simple list. This allows
procedure blocks to be in _any_ order, they will all be caught by
control flow analysis. See also MirOptTypes.

Revision 1.8  91/09/18  18:39:31  richard
Fixed the squish function, which didn't cope with single-block
procedures.

Revision 1.7  91/09/17  15:37:01  richard
Code to annotate and deannotate blocks moved here from MirDataflow
module. Also minor changes related to the break-up of MirDataflow
(see log for that file).

Revision 1.6  91/09/16  12:43:10  richard
Rewrote separate function to cope with nested procedures produced
by the code generator.

Revision 1.5  91/09/10  10:22:04  richard
Minor changes to invocation of dataflow analyser to prevent
inexhaustive binding.

Revision 1.4  91/09/09  10:42:55  richard
Changed filename of mirpeep to mirpeepholer.
Removed some redundant debugging code.

Revision 1.3  91/09/05  16:46:46  richard
Removed redundant dataflow data structure (to MirDataFlow module),
otherwise just test modifications to do with data flow.

Revision 1.2  91/09/04  15:28:19  richard
Early version of code to split up MIR code ready for
dataflow analysis.

Revision 1.1  91/09/02  12:05:16  richard
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

d133 1
d145 1
d154 3
a156 1
    MirRegisters.MirTypes
a158 1
    MirVariable.MirOptTypes =
d160 1
a160 2
    MirFlow.MirOptTypes =
    RegisterAllocator.MirOptTypes
d162 4
d168 1
a168 1
struct
d170 4
a173 4
  structure MirTypes = MirTypes
  structure Diagnostic = Diagnostic
  structure Map = MirRegisters.Map
  structure MachSpec = MirRegisters.MachSpec
d176 1
a176 1
  (*  == Diagnostic output functions ==  *)
d178 4
a181 5
  fun listing (level, message) procedure =
    (Diagnostic.output level
     (fn _ => ["MirOptimiser: ", message, "\n"] @@
              (MirOptTypes.print_procedure procedure));
     procedure)
d183 3
a185 5
  fun display level (procedure as MirTypes.PROC(tag, _, _)) =
    (Diagnostic.output level
     (fn _ => ["MirOptimiser: processing procedure ",
	       MirTypes.print_tag tag]);
     procedure)
d187 5
a191 1
  val show_timings = ref false
d193 1
d195 1
a196 1
  val machine_register_assignments = MirRegisters.machine_register_assignments
d199 5
d205 23
a227 5
  (*  === OPTIMISE MIR CODE ===
   *
   *  A beautifully simple application of each of the optimisation
   *  passes.
   *)
a228 16
  fun optimise (MirTypes.CODE(refs, values, proc_sets)) =
    let
      fun optimise' procedure =
        let
          val annotated   = Timer_.xtime ("Annotation", !show_timings, fn () => MirOptTypes.annotate procedure)
          val flow_traced = Timer_.xtime ("Flow",       !show_timings, fn () => MirFlow.trace annotated)
          val expressed   = Timer_.xtime ("Expression", !show_timings, fn () => MirExpression.analyse flow_traced)
          val varied      = Timer_.xtime ("Variable",   !show_timings, fn () => MirVariable.analyse expressed)
          val registered  = Timer_.xtime ("RegAlloc",   !show_timings, fn () => RegisterAllocator.analyse varied)
          val stacked     = Timer_.xtime ("StackAlloc", !show_timings, fn () => StackAllocator.allocate registered)
        in
          stacked
        end
    in
      MirTypes.CODE(refs, values, map (map optimise') proc_sets)
    end
d230 1
a230 2

end
@


1.29
log
@Abolished the second pass of optimization.  It wasn't acheiving much.
@
text
@d4 6
d113 1
a113 1
require "../utils/balancedtree";
a136 5
  structure Crash		: CRASH
  structure Switches		: SWITCHES
  structure MirPrint		: MIRPRINT
  structure MirTables		: MIRTABLES
  structure BalancedTree	: BALANCEDTREE
d138 1
d142 2
a143 3
    MirTables.MirTypes =
    MirPrint.MirTypes =
    StackAllocator.MirTypes
a150 6
  sharing Switches =
    MirFlow.Switches =
    MirExpression.Switches =
    MirVariable.Switches =
    RegisterAllocator.Switches

a155 2
  structure MirRegisters = MirRegisters
  structure Switches = Switches
d157 2
d175 1
d178 5
d190 15
a204 1
  let
a205 1
    (* Optimise the procedures *)
d207 1
a207 43
(*    val first_pass =
      map (map (RegisterAllocator.analyse o
		(listing (3, "after first variable analysis")) o
		MirVariable.analyse o
		(listing (3, "after first expression analysis")) o
		MirExpression.analyse o
		(listing (3, "after first control flow trace")) o
		MirFlow.trace o
		(listing (3, "after first annotatation")) o
		MirOptTypes.annotate o
		(display 1))) proc_sets

  val second_pass =
      map (map (StackAllocator.allocate o
		MirOptTypes.unannotate o
		(listing (3, "after second variable analysis")) o
		MirVariable.analyse o
		(listing (3, "after second expression analysis")) o
		MirExpression.analyse o
		(listing (3, "after second control flow trace")) o
		MirFlow.trace o
		(listing (3, "after second annotation")) o
		MirOptTypes.annotate)) first_pass
*)
  in

    MirTypes.CODE(refs, values,
                  map (map (StackAllocator.allocate o
                            RegisterAllocator.analyse o
                            (listing (3, "after variable analysis")) o
                            MirVariable.analyse o
                            (listing (3, "after expression analysis")) o
                            MirExpression.analyse o
                            (listing (3, "after control flow trace")) o
                            MirFlow.trace o
                            (listing (3, "after annotatation")) o
                            MirOptTypes.annotate o
                            (display 1))) proc_sets)

  end


end; (* of functor *)
@


1.28
log
@Changed diagnostic output to reflect changes in MirOptTypes.
@
text
@d4 3
d193 2
a194 4
    val first_pass =
      map (map (MirOptTypes.unannotate o
		(listing (2, "after register allocation")) o
		RegisterAllocator.analyse o
d205 1
a205 1
    val second_pass =
d216 1
a216 1

d219 12
a230 1
    MirTypes.CODE(refs, values, second_pass)
@


1.27
log
@Changed debugging output to use the Diagnostic module.
@
text
@d3 4
a6 1
$Log:	_miroptimiser.sml,v $
d167 2
a168 2
     (fn _ => ["MirOptimiser: ", message, "\n",
	       MirOptTypes.print_procedure procedure]);
@


1.26
log
@Added a debugging function.
@
text
@d4 3
d98 1
a126 1
  structure Print		: PRINT
d130 1
d157 1
d160 1
d162 5
a166 1
  (*  == Debugging information output ==  *)
d168 5
a172 4
  fun info message =
    if !Switches.listings then
      Print.print ("MirOptimiser: " ^ message ^ "\n")
    else ()
a184 6
    (* I sometimes slip this between stages for debugging. It shouldn't *)
    (* normally be part of the optimisation process. *)
    fun display procedure =
      (print (MirOptTypes.print_procedure procedure);
       procedure)

d189 1
d191 1
d193 1
d195 1
d197 3
a199 1
		MirOptTypes.annotate)) proc_sets
a200 2
    val _ = map (map (info o MirPrint.procedure)) first_pass

d204 1
d206 1
d208 1
d210 1
@


1.25
log
@Added a second pass of optimisation to clean up after register
substitution and spill instruction insertion.
@
text
@d4 4
d173 6
@


1.24
log
@Added StackAllocator to optimisations.
@
text
@d4 3
a150 7
  (*  === CONVERT UNANNOTATED CODE BLOCKS TO ANNOTATED ===
   *
   *  This function takes blocks of type MirTypes.block and converts
   *  them into MirOptTypes.blocks. The live variable and successor
   *  information is set to unknown. The first block of each list must
   *  be the block starting with a procedure entry.
   *)
d152 1
a152 1
  local
d154 4
a157 10
    fun annotate_block (MirTypes.BLOCK(tag,opcodes)) =
    let
      fun f [] = []
	| f (opcode::opcodes) =
	  (opcode,
	   MirOptTypes.REGS_UNKNOWN,
	   MirOptTypes.SUCCS_UNKNOWN) :: (f opcodes)
    in
      MirOptTypes.BLOCK(tag,f opcodes)
    end
a158 1
  in
a159 2
    fun annotate_proc (MirTypes.PROC(start_tag, params, blocks)) =
      MirOptTypes.make_proc (start_tag, params, map annotate_block blocks)
a160 35
  end


  (*  === CONVERT ANNOTATED CODE BLOCKS TO UNANNOTATED ===
   *
   *  This is the reverse of the above function.
   *
   *  NOTE: It needs rewriting to produce the blocks in some sort of
   *  coherent order.
   *)

  local

    fun unannotate_block (MirOptTypes.BLOCK(tag,opcodes)) =
    let
      fun f [] = []
	| f ((opcode,_,_)::opcodes) =
	  opcode :: (f opcodes)
    in
      MirTypes.BLOCK(tag, f opcodes)
    end

  in

    fun unannotate_proc (procedure as MirOptTypes.PROC(start_tag, params, _)) =
    let
      val alist = MirOptTypes.alist_of_proc procedure
      val blocks = map (fn (_,block) => block) alist
    in
      MirTypes.PROC(start_tag, params, map unannotate_block blocks)
    end

  end;


d172 2
a173 3
    val optimised_proc_sets =
      map (map (StackAllocator.apply o
		unannotate_proc o
d178 1
a178 1
		annotate_proc)) proc_sets
d180 10
d192 1
a192 1
    MirTypes.CODE(refs, values, optimised_proc_sets)
@


1.23
log
@Removed redundant requires which I left in by mistake after a
debugging session.
@
text
@d4 4
d100 1
d113 1
d124 2
a125 1
    MirPrint.MirTypes
d221 2
a222 1
      map (map (unannotate_proc o
@


1.22
log
@Removed explicit dependency on the representation of MirOptTypes.procedure.
@
text
@d4 3
a95 2
require "procedure";
require "_procedure";
@


1.21
log
@Added Print to dependencies.
@
text
@d4 3
d83 1
d91 4
d110 3
d114 4
a117 1
  sharing MirTypes = MirOptTypes.MirTypes
d190 1
a190 1
    fun unannotate_proc (MirOptTypes.PROC(start_tag, params, block_table)) =
d192 1
a192 1
      val alist = MirOptTypes.Table.alist_of_table block_table;
@


1.20
log
@Added Switches structure. Removed redundant MirDataFlow module.
@
text
@d4 3
d79 1
d101 1
@


1.19
log
@Removed procedure parameters to reflect changes in MirTypes.
@
text
@d4 3
d77 2
a78 1
require "mirdataflow";
d82 1
d90 2
a91 1
  structure MirDataFlow		: MIRDATAFLOW
d96 1
d100 5
a104 2
  sharing MirOptTypes = MirDataFlow.MirOptTypes =
    MirFlow.MirOptTypes = RegisterAllocator.MirOptTypes
d106 6
d118 1
d196 2
a197 1
		MirDataFlow.analyse o
@


1.18
log
@Deleted register assignments. These can now be found in the
MirRegisters structure.
@
text
@d4 4
d171 1
a171 1
  fun optimise (MirTypes.CODE(fn_call, refs, values, proc_sets, set_up_proc)) =
a182 9
    (* Allocate registers for the loader set-up set_up_proc *)

    val new_set_up_proc =
      (unannotate_proc o
       RegisterAllocator.analyse o
       MirDataFlow.analyse o
       MirFlow.trace o
       annotate_proc) set_up_proc

d185 1
a185 1
    MirTypes.CODE(fn_call, refs, values, optimised_proc_sets, new_set_up_proc)
@


1.17
log
@Slight alterations to cope with new MirTypes.
@
text
@d4 3
d83 1
d87 1
a87 1
  sharing MirTypes = MirOptTypes.MirTypes = RegisterAllocator.MirTypes
d97 1
a97 16
  structure MachSpec = RegisterAllocator.MachSpec
  structure Table = RegisterAllocator.Table


  (*  === REGISTER ASSIGNMENTS ===
   *
   *  The virtual registers in the code returned by the optimise
   *  function can be mapped on to real machine registers using the
   *  following tables.
   *)

  val gc_assign = RegisterAllocator.gc_assign
  val non_gc_assign = RegisterAllocator.non_gc_assign
  val fp_assign = RegisterAllocator.fp_assign
  val fp_double_assign = RegisterAllocator.fp_double_assign

@


1.17.1.1
log
@Tried out an idea: have one higher order function which passes over
a linearized procedure applying optimization functions.
@
text
@a3 3
Revision 1.17  91/10/11  09:56:14  richard
Slight alterations to cope with new MirTypes.

d169 1
a169 46
  end



  (*  === APPLY FUNCTIONS OVER THE OPCODES OF A PROCEDURE ===  *)

(*  val apply :
    {forward	: 'a * MirTypes.opcode -> 'a * MirTypes.opcode,
     turn	: 'a -> 'b,
     backward	: 'b * MirTypes.opcode -> 'b * MirTypes.opcode,
     finish	: 'b -> MirTypes.procedure_parameters,
     part	: 'state * 'state -> 'state,
     meet	: 'state * 'state -> 'state} ->
    'a ->
    MirOptTypes.procedure -> MirOptTypes.procedure

  fun apply {forward, turn, backward, finish, part, meet}
            start_state
            proc =
    let

      fun apply_block (MirOptTypes.BLOCK(tag, opcodes)) =
	let
	  fun b (done, state, []) = (done, finish state)
	    | b (done, state, opcode::opcodes) =
	      let
		val (new_state, new_opcode) = backward (state, opcode)
	      in
		b (new_opcode::done, new_state, opcodes)
	      end

	  fun f (done, state, []) = b ([], turn state, done)
	    | f (done, state, opcode::opcodes) =
	      let
		val (new_state, new_opcode) = forward (state, opcode)
	      in
		f (new_opcode::done, new_state, opcodes)
	      end

	in
	  MirOptTypes.BLOCK(tag, f ([], start_state, opcodes))
	end
    in
      
*)

@


1.16
log
@The loader block is now allocated.
@
text
@d4 3
d134 2
a135 2
    fun annotate_proc (MirTypes.PROC(start_tag, blocks)) =
      MirOptTypes.make_proc (start_tag, map annotate_block blocks)
d161 1
a161 1
    fun unannotate_proc (MirOptTypes.PROC(start_tag, block_table)) =
d166 1
a166 1
      MirTypes.PROC(start_tag, map unannotate_block blocks)
a171 27
  (*  == Allocate registers for the single loader set up block ==
   *
   *  This is done by building a single-block procedure and running
   *  the allocator on it.
   *)

  fun loader_block_allocate (block as MirTypes.BLOCK(tag, _)) =
    let
      val proc = MirTypes.PROC(tag, [block])

      val allocated_proc =
	unannotate_proc
	(RegisterAllocator.analyse
	 (MirDataFlow.analyse
	  (MirFlow.trace
	   (annotate_proc proc))))
    in
      case allocated_proc
	of MirTypes.PROC(_, [allocated_block]) => allocated_block
	 | _ =>
	     Crash.impossible
	     ("MirOptimiser: Register allocation of the loader set up "^
	      "block yielded a malformed procedure.")
    end



d178 1
a178 2
  fun optimise (stuff as
		MirTypes.CODE(fn_call, refs, values, proc_sets, block)) =
d190 1
a190 1
    (* Allocate registers for the loader set-up block *)
d192 6
a197 1
    val new_block = loader_block_allocate block
d201 1
a201 1
    MirTypes.CODE(fn_call, refs, values, optimised_proc_sets, new_block)
@


1.15
log
@Commented out loader block allocation for now.
@
text
@d217 1
a217 1
    val new_block = (* loader_block_allocate block *) block
@


1.14
log
@Changed dependency on MachRegisters to MachSpec.
@
text
@d4 3
d217 1
a217 1
    val new_block = loader_block_allocate block
@


1.13
log
@Optimisation and register allocation of the loader setup block.
@
text
@d4 3
d87 1
a87 1
  structure MachRegisters = RegisterAllocator.MachRegisters
@


1.12
log
@Rewrote the optimiser top level to use the new MirTypes code structure,
with significant benefits for code size and speed! Also, the functor
now exports the register assignment tables for the target machine.
@
text
@d4 5
a56 2
require "../utils/print";
require "../utils/lists";
a57 2
require "mirprint";
require "mirpeepholer";
a68 2
  structure MirPrint 		: MIRPRINT
  structure MirPeepholer	: MIRPEEPHOLER
a72 2
  structure Print		: PRINT
  structure Lists		: LISTS
d74 1
a74 3
  sharing MirTypes = MirOptTypes.MirTypes =
    MirPeepholer.MirTypes = MirPrint.MirTypes =
    RegisterAllocator.MirTypes
d163 5
d169 21
d200 2
d209 4
d215 1
a215 1
      MirTypes.CODE(fn_call, refs, values, optimised_proc_sets, block)
@


1.11
log
@Added a quick fix to allow register allocation to return some extra
stuff. The extra stuff is ignored at the moment.
@
text
@d4 4
d78 2
a79 1
    MirPeepholer.MirTypes = MirPrint.MirTypes
d89 2
d93 6
a98 4
  val show_info = true;		(* false to disable debugging output *)
  val show_info_squish = false;	(* false to disable procedure *)
				(* separation information *)
  val show_code = true;		(* false to disable listings *)
d100 4
a105 1
  (*  === DEBUGGING INFORMATION OUTPUT ===  *)
a106 8
  fun info message =
    if show_info then print ("MIR Optimiser: "^message) else ();

  fun code_info message =
    if show_code then print message else ();



d115 13
a127 7
  fun annotate_block (MirTypes.BLOCK(tag,opcodes)) =
  let
    fun f [] = []
      | f (opcode::opcodes) =
	(opcode,
	 MirOptTypes.REGS_UNKNOWN,
	 MirOptTypes.SUCCS_UNKNOWN) :: (f opcodes)
d129 4
a132 1
    MirOptTypes.BLOCK(tag,f opcodes)
d157 1
a157 1
    fun unannotate (MirOptTypes.PROC(_, block_table)) =
d162 1
a162 1
      map unannotate_block blocks
d169 5
a173 1
  (*  === Optimise MIR code ===  *)
d175 2
a176 1
  fun optimise (stuff as (MirTypes.CODE(blocks))) =
a177 1
    val _ = info "Finding procedures...";
d179 6
a184 4
    val proc_entry_tags =
      map (fn (MirTypes.BLOCK(tag,_)) => tag)
          (Lists.filterp (fn (MirTypes.BLOCK(_,MirTypes.ENTER::_)) => true
			   | _ => false) blocks);
a185 23
    val _ = info ("Procedure entry blocks:" ^
		  (Lists.foldl (fn x=>fn y=>y^" "^x) ""
		   (map MirTypes.print_tag proc_entry_tags)));

    val annotated_code = map annotate_block blocks;

    val procs =
      map (fn tag => MirOptTypes.make_proc (tag, annotated_code))
          proc_entry_tags;

    fun spong block =
      let
	val (new_block, _) = RegisterAllocator.analyse block
      in
	new_block
      end

    val optimised_blocks =
      map (unannotate o
	   spong o
	   MirDataFlow.analyse o
	   MirFlow.trace) procs;

d188 1
a188 1
    MirTypes.CODE(Lists.foldl (fn x => fn y => x@@y) [] optimised_blocks)
@


1.10
log
@Added register allocator to optimiser module.
@
text
@d4 3
d177 7
d186 1
a186 1
	   RegisterAllocator.analyse o
@


1.9
log
@Modified to use a table of blocks rather than a simple list. This allows
procedure blocks to be in _any_ order, they will all be caught by
control flow analysis. See also MirOptTypes.
@
text
@d4 5
d52 1
d65 1
d74 1
a74 1
    MirFlow.MirOptTypes
d176 1
@


1.9.1.1
log
@This is a modified version to use the reworked MirTypes module
(ver 1.23.1.1). This module is correct, but work has been suspended
on this branch because of the amount of time it would take to convert
the code generator (Mir_Cg) module.
@
text
@a3 5
Revision 1.9  91/09/24  11:31:50  richard
Modified to use a table of blocks rather than a simple list. This allows
procedure blocks to be in _any_ order, they will all be caught by
control flow analysis. See also MirOptTypes.

d44 1
d56 1
d63 2
a64 1
  sharing MirTypes = MirOptTypes.MirTypes = MirPrint.MirTypes
@


1.8
log
@Fixed the squish function, which didn't cope with single-block
procedures.
@
text
@d4 4
d95 3
a97 3
   *  This function takes a list of blocks of type MirTypes.block and
   *  converts them into a MirOptTypes.procedure. The live variable
   *  information is set to UNKNOWN. The first block of each list must
d101 7
a107 13
  local

    fun annotate_block (MirTypes.BLOCK(tag,opcodes)) =
    let
      fun f [] = []
	| f (opcode::opcodes) =
	  (opcode,
	   MirOptTypes.REGS_UNKNOWN,
	   MirOptTypes.SUCCS_UNKNOWN) :: (f opcodes)
    in
      MirOptTypes.BLOCK(tag,f opcodes)
    end

d109 2
a111 4
    fun annotate (blocks as
		  (MirTypes.BLOCK(start_tag,
				  MirTypes.ENTER::_))::_) =
	MirOptTypes.PROC(start_tag, map annotate_block blocks)
a112 7
      | annotate _ =
	Crash.impossible("MirOptimiser: Annotator was passed a "^
			 "malformed or empty procedure")

  end;


d116 3
d134 5
a138 1
    fun unannotate (MirOptTypes.PROC(_, blocks)) =
d140 1
a144 6
  (*  === SEPARATE MIR CODE INTO SEPARATE PROCEDURES ===
   *
   *  The code is converted from a list of MirTypes.blocks to a list of
   *  MirOptTypes.procedures, tupled with a list of MirTypes.blocks which
   *  occurred outside any procedure.
   *)
d146 1
a146 1
  local
d148 3
a150 4
    (*  Predicates for finding procedure entry and exit.
     *
     *  I'm assuming that an ENTER is always at the beginning of a block.
     *)
d152 4
a155 2
    fun is_entry (MirTypes.BLOCK(_,MirTypes.ENTER::_)) = true
      | is_entry _ = false;
d157 3
a159 8
    fun is_exit (MirTypes.BLOCK(_,opcodes)) =
    let
      fun f [] = false
	| f (MirTypes.RTS::_) = true
	| f (_::opcodes) = f opcodes
    in
      f opcodes
    end;
d161 1
d163 3
a165 16
    fun squish_info (s,rest,this,other) =
      if show_info_squish then
	let
	  fun p_tag (MirTypes.BLOCK(tag,_)) = MirTypes.print_tag tag;
	  fun p_list x =
	    Lists.foldl (fn x => fn y => x^" "^y) "" (map p_tag x);
	  fun p_list_list x =
	    Lists.foldl (fn x => fn y => x^"; "^y) "" (map p_list x)
	in
	  info(s ^
	       "\n  Rest:  " ^ (p_list rest) ^
	       "\n  This:  " ^ (p_list this) ^
	       "\n  Other: " ^ (p_list_list other))
	end
      else
	();
d167 1
a167 83

    fun squish ([],this_proc,other_procs) =
        (
	  squish_info("End",[],this_proc,other_procs);
	  (rev this_proc, other_procs, [])
	)

      | squish (block::blocks, this_proc, other_procs) =
	(
	  case (is_entry block, is_exit block)

	    (* If the block is both an entry and an exit, then it is a *)
	    (* single block procedure. *)
	    of (true,true) =>
	       (
		 squish_info("Single block procedure",
			     block::blocks,this_proc,other_procs);
	         squish (blocks, this_proc, [block]::other_procs)
	       )

            (* If the block begins a procedure within the this_proc, *)
	    (* run squish on it and add it to the list of other_procs. *)
             | (true,false) =>
	       (
		 squish_info("Entry",block::blocks,this_proc,other_procs);
		 let
		   val (rest_of_other, more_others, rest_of_this) =
		     squish (blocks, [], [])
		 in
		   squish (rest_of_this,
			   this_proc,
			   (block::rest_of_other)::other_procs@@more_others)
		 end
	       )
      
	    (* If the block ends this_proc, then return it, the *)
	    (* other_procs, and also any left-over blocks. *)
	     | (false,true) =>
	       (
		 squish_info("Exit",block::blocks,this_proc,other_procs);
		 (rev (block::this_proc), other_procs, blocks)
	       )

	    (* Otherwise add the block to this_proc and continue. *)
	     | (false,false) =>
		 squish (blocks, block::this_proc, other_procs)
	)

  in

    fun separate blocks =
    let
      val (top_level_blocks, procs, left_overs) = squish (blocks, [], [])
    in
      if left_overs = [] then
	(map annotate procs, top_level_blocks)
      else
	Crash.impossible
	("MirOptimiser: I've been given malformed procedures, in "^
	 "particular, I've found an extra procedure exit at top "^
	 "level.")
    end

  end
	      

  (*  === Optimise MIR code ===  *)

  fun optimise (stuff as (MirTypes.CODE(blocks))) =
  let
    val _ = info "Finding procedures...";
    val (procs, others) = separate blocks;
    val _ =
      (info ("Procedure entry blocks:" ^
	     (Lists.foldl (fn x=>fn y=>y^" "^x) ""
	      (map (fn (MirOptTypes.PROC(tag,_)) =>
		    MirTypes.print_tag tag) procs)));
       info ("Other blocks:" ^
	     (Lists.foldl (fn x=>fn y=>y^" "^x) ""
	      (map (fn (MirTypes.BLOCK(tag,_)) =>
		    MirTypes.print_tag tag) others))));

    val optimised_procs =
d174 1
a174 1
    MirTypes.CODE(Lists.foldl (fn x => fn y => x@@y) others optimised_procs)
@


1.7
log
@Code to annotate and deannotate blocks moved here from MirDataflow
module. Also minor changes related to the break-up of MirDataflow
(see log for that file).
@
text
@d4 5
d42 1
d54 1
d62 2
a63 1
  sharing MirOptTypes = MirDataFlow.MirOptTypes
d73 2
d103 3
a105 1
	  (opcode, MirOptTypes.UNKNOWN) :: (f opcodes)
d134 1
a134 1
	| f ((opcode,_)::opcodes) =
d137 1
a137 1
      MirTypes.BLOCK(tag,f opcodes)
d159 1
a159 2
     *  I'm assuming that an ENTER is always at the beginning of a block and
     *  an RTS always at the end.
d167 2
a168 2
      fun f [MirTypes.RTS] = true
	| f [] = false
d175 16
a190 1
    fun squish ([],this_proc,other_procs) = (rev this_proc, other_procs, [])
d192 7
d200 2
d203 8
a210 12
	(* If the block begins a procedure within the this_proc, run *)
	(* squish on it and add it to the list of other_procs. *)
	if is_entry block then
	  let
	    val (rest_of_other, more_others, rest_of_this) =
	      squish (blocks, [], [])
	  in
	    squish (rest_of_this,
		    this_proc,
		    (block::rest_of_other)::other_procs@@more_others)
	  end
	else
d212 22
a233 5
	  (* If the block ends this_proc, then return it, the *)
	  (* other_procs, and also any left-over blocks. *)
	  if is_exit block then
	    (rev (block::this_proc), other_procs, blocks)
	  else
d236 3
a238 1
	    squish (blocks, block::this_proc, other_procs);
d262 1
d265 1
a265 1
      (info ("Procedures: " ^
d269 1
a269 1
       info ("Others: " ^
d274 5
a278 1
    val first_proc::_ = procs
d280 3
a282 1
    MirTypes.CODE(unannotate (MirDataFlow.analyse first_proc))
d284 1
a284 2
    handle Bind =>
      (info "No procedure to analyse"; stuff)
@


1.6
log
@Rewrote separate function to cope with nested procedures produced
by the code generator.
@
text
@d4 4
d37 1
d40 1
a41 7
  structure MirTypes     : MIRTYPES
  structure MirPrint 	 : MIRPRINT
  structure MirPeepholer : MIRPEEPHOLER
  structure MirDataFlow  : MIRDATAFLOW
  structure Crash        : CRASH
  structure Print        : PRINT
  structure Lists	 : LISTS
d43 8
a50 2
  sharing MirTypes = MirPeepholer.MirTypes = MirPrint.MirTypes =
    MirDataFlow.MirTypes
d52 5
d58 1
a61 1
  structure Set = MirDataFlow.Set
d63 1
a67 1
  (* Debugging information output *)
d69 2
d78 2
a79 1
  (*  == Separate MIR code into separate procedures ==
d81 4
a84 4
   *  The code is converted from a simple list of blocks to a list of lists,
   *  each sublist being a procedure. It also filters out anything which
   *  occurs outside of a procedure and places this in another list. It
   *  returns, therefore, ([block list,block list,...],block list)
d89 56
d148 1
a148 1
     *  an EXIT always at the end.
d156 1
a156 1
      fun f [MirTypes.EXIT] = true
d197 1
a197 1
	(procs, top_level_blocks)
d211 11
a221 12
  (
    let
      val (procs, others) = separate blocks;
      val _ =
	(info ("Procedures: " ^
	       (Lists.foldl (fn x=>fn y=>y^" "^x) ""
		(map (fn (MirTypes.BLOCK(tag,_)::_) =>
		      MirTypes.print_tag tag) procs)));
	 info ("Others: " ^
	       (Lists.foldl (fn x=>fn y=>y^" "^x) ""
		(map (fn (MirTypes.BLOCK(tag,_)) =>
		      MirTypes.print_tag tag) others))));
d223 6
a228 8
      val first_proc::_ = procs
    in
      MirDataFlow.analyse first_proc;
      ()
    end
      handle Bind => info "No procedure to analyse";
    stuff
  )
@


1.5
log
@Minor changes to invocation of dataflow analyser to prevent
inexhaustive binding.
@
text
@d4 4
d28 1
a28 1
(*require "../utils/set";*)
d42 1
a42 1
(*  structure Set		 : SET*)
a93 1
    (*  Block manipulating functions  *)
d95 1
a95 2
    (* Find the first block satisfying a predicate, collecting anything
     * skipped. *)
d97 1
a97 10
    fun find_block predicate blocks =
    let
      fun f (skipped, []) = (rev skipped, [])
	| f (skipped, blocks as block::rest) =
	if predicate block
	then (rev skipped, blocks)
	else f (block::skipped, rest)
    in
      f ([], blocks)
    end;
d99 12
a110 2
    (* Separate the first procedure from a list of blocks, returning
     * also anything skipped and what's left. *)
d112 5
a116 12
    fun find_proc blocks =
      (* Use find_block to locate the block containing the procedure entry. *)
      case find_block is_entry blocks
	of (skipped,[]) => ([],[],skipped)	(* No proc found *)
	 | (skipped, proc_start) =>
	   (* Use find_block to locate the block containing the exit. *)
	   case find_block is_exit proc_start
	     of (_,[]) =>
		Crash.impossible
		"MIR optimiser: I was passed a dodgy procedure with no EXIT!"
	      | (proc_body, exit_block::rest) =>
		(proc_body@@[exit_block], rest, skipped);
d118 3
d125 1
a125 5
      fun f [] (procs, skipped) = (procs, skipped)
	| f blocks (procs, skipped) =
	  case find_proc blocks
	    of ([],_,skip) => (procs, skip@@skipped)
	     | (proc,rest,skip) => f rest (proc::procs, skip@@skipped)
d127 7
a133 1
      f blocks ([],[])
d144 12
a155 1
      val (first_proc::_,_) = separate blocks
@


1.4
log
@Changed filename of mirpeep to mirpeepholer.
Removed some redundant debugging code.
@
text
@d4 4
d141 8
a148 4
  let
    val (first_proc::_,_) = separate blocks
  in
    MirDataFlow.analyse first_proc;
d150 1
a150 1
  end
@


1.3
log
@Removed redundant dataflow data structure (to MirDataFlow module),
otherwise just test modifications to do with data flow.
@
text
@d4 4
d23 1
a23 1
require "mirpeep";
d138 1
a138 15
    fun d ([],[]) = ()
      | d ([],skipped) =
	(
	  code_info "Skipped";
	  code_info (MirPrint.print_mir_code(MirTypes.CODE(skipped)))
        )
      | d (proc::procs,skipped) =
	(
	  code_info "Proc";
	  code_info (MirPrint.print_mir_code(MirTypes.CODE(proc)));
	  d (procs,skipped)
	);

    val (procs,skipped) = separate blocks;
    val first_proc::_ = procs
a139 1
    d (procs,skipped);
@


1.2
log
@Early version of code to split up MIR code ready for
dataflow analysis.
@
text
@d4 4
d16 1
a16 1
require "../utils/set";
d20 1
d27 1
d30 1
a30 1
  structure Set		 : SET
d32 3
a34 1
  sharing MirTypes = MirPeepholer.MirTypes = MirPrint.MirTypes
d39 1
a53 23
  (*	== Data structure for optimisation ==
   *
   *  The data structure is similar to MirTypes.mir_code, but with extra
   *  information: 1. Each block knows which instructions branch to it; 2.
   *  Each opcode has a set of live variables attached.
   *)

(*    type tag = MirTypes.tag;
  val init_tag = MirTypes.init_tag;
  val new_tag = MirTypes.new_tag;
  val print_tag = MirTypes.print_tag; *)

  (* come_from refers to an opcode by block tag and position within block *)
  datatype come_from = FROM of MirTypes.tag*int;

  datatype block = BLOCK of
    MirTypes.tag *		(* The block tag *)
    come_from list *		(* List of branches which reach here *)
    MirTypes.opcode list;	(* The instructions *)

  datatype procedure = PROC of block list;


d62 2
d114 1
d116 11
a126 12
  (*  === Optimise MIR code ===
   *
   *  Early days yet: I just run the peepholer on every block.
   *)
(*
  fun optimise (MirTypes.CODE(blocks)) =
  let
    fun peephole [] = []
      | peephole ((MirTypes.BLOCK(tag, sequence)) :: blocks) =
      MirTypes.BLOCK(tag, MirPeepholer.optimise sequence) :: peephole blocks
  in
    MirTypes.CODE(peephole blocks)
d128 1
a128 1
*)
d130 2
d133 13
a145 11
  (
    (case find_proc blocks
      of ([],_,_) => code_info "No proc found."
       | (body,rest,skipped) =>
	 (
	   code_info "Body";
	   code_info (MirPrint.print_mir_code(MirTypes.CODE(body)));
	   code_info "Rest";
	   code_info (MirPrint.print_mir_code(MirTypes.CODE(rest)));
	   code_info "Skip";
	   code_info (MirPrint.print_mir_code(MirTypes.CODE(skipped)))));
d147 7
a153 2
     stuff
  )
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log:$
d10 3
d14 2
d18 10
a27 1
functor MirOptimiser( structure MirTypes : MIRTYPES ) : MIROPTIMISER =
d32 2
a33 1
  fun optimise x = x
d35 124
a158 1
end;
@
