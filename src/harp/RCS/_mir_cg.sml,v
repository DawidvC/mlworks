head	1.311;
access;
symbols
	MLW_daveb_inline_1_4_99:1.311.1
	MLWorks_21c0_1999_03_25:1.311
	MLWorks_20c1_1998_08_20:1.310
	MLWorks_20c0_1998_08_04:1.310
	MLWorks_20b2c2_1998_06_19:1.310
	MLWorks_20b2_Windows_1998_06_12:1.310
	MLWorks_20b1c1_1998_05_07:1.310
	MLWorks_20b0_1998_04_07:1.310
	MLWorks_20b0_1998_03_20:1.310
	MLWorks_20m2_1998_02_16:1.309
	MLWorks_20m1_1997_10_23:1.309
	MLWorks_11r1:1.303.1.2.1.1.1
	MLWorks_workspace_97:1.308.2
	MLWorks_dt_wizard:1.308.1
	MLWorks_11c0_1997_09_09:1.303.1.2.1.1
	MLWorks_10r3:1.303.1.2.3
	MLWorks_10r2_551:1.303.1.2.2
	MLWorks_11:1.303.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.303.1.2
	MLWorks_20m0_1997_06_20:1.304
	MLWorks_1_0_r2c2_1997_06_14:1.303.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.303.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.303.1
	MLWorks_BugFix_1997_04_24:1.304
	MLWorks_1_0_r2_Win32_1997_04_11:1.303
	MLWorks_1_0_r2_Unix_1997_04_04:1.303
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.299.3.1.1
	MLWorks_gui_1996_12_18:1.299.4
	MLWorks_1_0_Win32_1996_12_17:1.299.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.299.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.299.1.1
	MLWorks_1_0_Irix_1996_11_28:1.299.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.299.2
	MLWorks_1_0_Unix_1996_11_14:1.299.1
	MLWorks_Open_Beta2_1996_10_11:1.297.2
	MLWorks_License_dev:1.297.1
	MLWorks_1_open_beta_1996_09_13:1.295.1
	MLWorks_Open_Beta_1996_08_22:1.295
	MLWorks_Beta_1996_07_02:1.294
	MLWorks_Beta_1996_06_07:1.294
	MLWorks_Beta_1996_06_06:1.294
	MLWorks_Beta_1996_06_05:1.294
	MLWorks_Beta_1996_06_03:1.294
	MLWorks_Beta_1996_05_31:1.294
	MLWorks_Beta_1996_05_30:1.294
	ML_beta_release_12/08/94:1.241
	ML_beta_release_03/08/94:1.241
	ML_revised_beta_release_25/05/94:1.235
	ML_final_beta_release_02/03/94:1.232
	mlworks-28-01-1994:1.230
	Release:1.223
	mlworks-beta-01-09-1993:1.223
	MLWorks-1-0-4-29/01/1993:1.196
	MLWorks-1-0-3-21/12/1992:1.196
	MLWorks-1-0-2-15/12/1992:1.195
	MLWorks-1-0-1-04/12/1992:1.193
	checkpoint_17_08_92:1.171
	Ten15_release_19-08-91:1.14
	ten15_release:1.3;
locks; strict;
comment	@ * @;


1.311
date	98.09.18.15.27.48;	author jont;	state Exp;
branches
	1.311.1.1;
next	1.310;

1.310
date	98.03.16.15.20.22;	author jont;	state Exp;
branches;
next	1.309;

1.309
date	97.09.18.15.41.13;	author brucem;	state Exp;
branches;
next	1.308;

1.308
date	97.08.14.17.10.41;	author jont;	state Exp;
branches
	1.308.1.1
	1.308.2.1;
next	1.307;

1.307
date	97.08.07.11.14.18;	author jont;	state Exp;
branches;
next	1.306;

1.306
date	97.08.01.10.08.18;	author jont;	state Exp;
branches;
next	1.305;

1.305
date	97.07.03.15.20.20;	author jkbrook;	state Exp;
branches;
next	1.304;

1.304
date	97.04.11.17.17.34;	author jont;	state Exp;
branches;
next	1.303;

1.303
date	97.01.21.12.13.25;	author matthew;	state Exp;
branches
	1.303.1.1;
next	1.302;

1.302
date	97.01.16.13.12.19;	author matthew;	state Exp;
branches;
next	1.301;

1.301
date	97.01.10.17.03.55;	author andreww;	state Exp;
branches;
next	1.300;

1.300
date	97.01.03.14.44.24;	author matthew;	state Exp;
branches;
next	1.299;

1.299
date	96.11.06.11.08.05;	author matthew;	state Exp;
branches
	1.299.1.1
	1.299.2.1
	1.299.3.1
	1.299.4.1;
next	1.298;

1.298
date	96.10.30.21.12.15;	author io;	state Exp;
branches;
next	1.297;

1.297
date	96.09.26.14.00.33;	author matthew;	state Exp;
branches
	1.297.1.1
	1.297.2.1;
next	1.296;

1.296
date	96.09.23.12.09.56;	author matthew;	state Exp;
branches;
next	1.295;

1.295
date	96.08.06.12.28.12;	author andreww;	state Exp;
branches
	1.295.1.1;
next	1.294;

1.294
date	96.05.21.15.37.47;	author matthew;	state Exp;
branches;
next	1.293;

1.293
date	96.05.14.10.17.42;	author matthew;	state Exp;
branches;
next	1.292;

1.292
date	96.04.30.16.54.38;	author jont;	state Exp;
branches;
next	1.291;

1.291
date	96.04.30.16.54.38;	author jont;	state Exp;
branches;
next	1.290;

1.290
date	96.04.29.14.46.40;	author matthew;	state Exp;
branches;
next	1.289;

1.289
date	96.04.19.10.52.33;	author matthew;	state Exp;
branches;
next	1.288;

1.288
date	96.03.28.10.50.32;	author matthew;	state Exp;
branches;
next	1.287;

1.287
date	96.03.20.12.46.53;	author matthew;	state Exp;
branches;
next	1.286;

1.286
date	96.02.02.11.09.52;	author jont;	state Exp;
branches;
next	1.285;

1.285
date	96.01.31.17.36.25;	author jont;	state Exp;
branches;
next	1.284;

1.284
date	96.01.31.17.16.02;	author jont;	state Exp;
branches;
next	1.283;

1.283
date	96.01.30.10.42.22;	author jont;	state Exp;
branches;
next	1.282;

1.282
date	95.12.27.13.02.37;	author jont;	state Exp;
branches;
next	1.281;

1.281
date	95.12.22.17.39.41;	author jont;	state Exp;
branches;
next	1.280;

1.280
date	95.12.20.13.17.06;	author jont;	state Exp;
branches;
next	1.279;

1.279
date	95.12.04.12.35.41;	author matthew;	state Exp;
branches;
next	1.278;

1.278
date	95.11.06.13.52.25;	author jont;	state Exp;
branches;
next	1.277;

1.277
date	95.11.01.10.16.39;	author jont;	state Exp;
branches;
next	1.276;

1.276
date	95.10.30.16.33.28;	author jont;	state Exp;
branches;
next	1.275;

1.275
date	95.09.25.09.41.44;	author jont;	state Exp;
branches;
next	1.274;

1.274
date	95.09.12.18.03.17;	author daveb;	state Exp;
branches;
next	1.273;

1.273
date	95.09.01.15.17.51;	author jont;	state Exp;
branches;
next	1.272;

1.272
date	95.07.28.15.35.31;	author jont;	state Exp;
branches;
next	1.271;

1.271
date	95.07.26.11.16.09;	author jont;	state Exp;
branches;
next	1.270;

1.270
date	95.07.25.15.30.56;	author jont;	state Exp;
branches;
next	1.269;

1.269
date	95.07.20.15.50.23;	author jont;	state Exp;
branches;
next	1.268;

1.268
date	95.07.19.12.39.29;	author jont;	state Exp;
branches;
next	1.267;

1.267
date	95.07.14.09.48.55;	author jont;	state Exp;
branches;
next	1.266;

1.266
date	95.07.07.14.33.48;	author jont;	state Exp;
branches;
next	1.265;

1.265
date	95.06.19.11.05.46;	author jont;	state Exp;
branches;
next	1.264;

1.264
date	95.05.30.11.53.23;	author matthew;	state Exp;
branches;
next	1.263;

1.263
date	95.05.18.12.27.57;	author matthew;	state Exp;
branches;
next	1.262;

1.262
date	95.05.02.11.29.28;	author matthew;	state Exp;
branches;
next	1.261;

1.261
date	95.03.01.15.45.38;	author matthew;	state Exp;
branches;
next	1.260;

1.260
date	95.02.07.17.25.53;	author matthew;	state Exp;
branches;
next	1.259;

1.259
date	95.01.30.12.07.59;	author matthew;	state Exp;
branches;
next	1.258;

1.258
date	95.01.16.14.58.36;	author jont;	state Exp;
branches;
next	1.257;

1.257
date	94.11.23.13.15.00;	author matthew;	state Exp;
branches;
next	1.256;

1.256
date	94.11.16.17.14.04;	author jont;	state Exp;
branches;
next	1.255;

1.255
date	94.11.16.11.57.12;	author jont;	state Exp;
branches;
next	1.254;

1.254
date	94.11.10.15.40.37;	author matthew;	state Exp;
branches;
next	1.253;

1.253
date	94.11.02.12.29.42;	author matthew;	state Exp;
branches;
next	1.252;

1.252
date	94.10.26.18.04.27;	author jont;	state Exp;
branches;
next	1.251;

1.251
date	94.10.24.13.54.56;	author matthew;	state Exp;
branches;
next	1.250;

1.250
date	94.10.17.16.11.15;	author jont;	state Exp;
branches;
next	1.249;

1.249
date	94.10.11.12.02.54;	author matthew;	state Exp;
branches;
next	1.248;

1.248
date	94.09.30.12.58.21;	author jont;	state Exp;
branches;
next	1.247;

1.247
date	94.09.23.11.31.30;	author matthew;	state Exp;
branches;
next	1.246;

1.246
date	94.09.16.16.36.23;	author jont;	state Exp;
branches;
next	1.245;

1.245
date	94.09.14.16.11.48;	author jont;	state Exp;
branches;
next	1.244;

1.244
date	94.09.09.17.24.37;	author jont;	state Exp;
branches;
next	1.243;

1.243
date	94.08.25.13.32.20;	author matthew;	state Exp;
branches;
next	1.242;

1.242
date	94.08.16.09.14.48;	author jont;	state Exp;
branches;
next	1.241;

1.241
date	94.08.02.15.45.39;	author matthew;	state Exp;
branches;
next	1.240;

1.240
date	94.07.25.14.06.39;	author matthew;	state Exp;
branches;
next	1.239;

1.239
date	94.07.25.11.37.32;	author matthew;	state Exp;
branches;
next	1.238;

1.238
date	94.06.22.14.44.39;	author jont;	state Exp;
branches;
next	1.237;

1.237
date	94.06.09.15.58.58;	author nickh;	state Exp;
branches;
next	1.236;

1.236
date	94.06.07.09.44.33;	author jont;	state Exp;
branches;
next	1.235;

1.235
date	94.05.12.12.40.46;	author richard;	state Exp;
branches;
next	1.234;

1.234
date	94.03.10.14.48.45;	author jont;	state Exp;
branches;
next	1.233;

1.233
date	94.03.04.12.32.55;	author jont;	state Exp;
branches;
next	1.232;

1.232
date	94.02.21.18.24.40;	author nosa;	state Exp;
branches;
next	1.231;

1.231
date	94.02.04.15.16.22;	author matthew;	state Exp;
branches;
next	1.230;

1.230
date	94.01.19.10.52.29;	author matthew;	state Exp;
branches;
next	1.229;

1.229
date	94.01.17.18.27.19;	author daveb;	state Exp;
branches;
next	1.228;

1.228
date	93.11.17.18.26.47;	author jont;	state Exp;
branches;
next	1.227;

1.227
date	93.11.04.16.55.38;	author jont;	state Exp;
branches;
next	1.226;

1.226
date	93.10.05.13.42.31;	author daveb;	state Exp;
branches;
next	1.225;

1.225
date	93.09.28.15.11.02;	author daveb;	state Exp;
branches;
next	1.224;

1.224
date	93.09.23.11.26.03;	author nosa;	state Exp;
branches;
next	1.223;

1.223
date	93.08.23.14.42.17;	author richard;	state Exp;
branches
	1.223.1.1;
next	1.222;

1.222
date	93.08.18.16.50.04;	author jont;	state Exp;
branches;
next	1.221;

1.221
date	93.08.17.17.21.36;	author jont;	state Exp;
branches;
next	1.220;

1.220
date	93.07.30.14.47.06;	author nosa;	state Exp;
branches;
next	1.219;

1.219
date	93.07.20.16.52.38;	author jont;	state Exp;
branches;
next	1.218;

1.218
date	93.07.20.12.57.37;	author jont;	state Exp;
branches;
next	1.217;

1.217
date	93.07.12.16.48.34;	author daveb;	state Exp;
branches;
next	1.216;

1.216
date	93.07.07.17.29.02;	author daveb;	state Exp;
branches;
next	1.215;

1.215
date	93.05.28.17.31.34;	author jont;	state Exp;
branches;
next	1.214;

1.214
date	93.05.18.16.31.04;	author daveb;	state Exp;
branches;
next	1.213;

1.213
date	93.05.11.15.35.21;	author richard;	state Exp;
branches;
next	1.212;

1.212
date	93.04.30.15.47.55;	author matthew;	state Exp;
branches;
next	1.211;

1.211
date	93.04.28.15.18.04;	author richard;	state Exp;
branches;
next	1.210;

1.210
date	93.04.26.16.16.21;	author matthew;	state Exp;
branches;
next	1.209;

1.209
date	93.04.15.15.48.40;	author jont;	state Exp;
branches;
next	1.208;

1.208
date	93.03.25.15.29.53;	author jont;	state Exp;
branches;
next	1.207;

1.207
date	93.03.23.15.49.26;	author jont;	state Exp;
branches;
next	1.206;

1.206
date	93.03.19.16.21.44;	author jont;	state Exp;
branches;
next	1.205;

1.205
date	93.03.17.14.05.27;	author jont;	state Exp;
branches;
next	1.204;

1.204
date	93.03.10.18.14.12;	author matthew;	state Exp;
branches;
next	1.203;

1.203
date	93.03.09.17.26.05;	author jont;	state Exp;
branches;
next	1.202;

1.202
date	93.03.04.15.16.07;	author matthew;	state Exp;
branches;
next	1.201;

1.201
date	93.03.04.11.59.10;	author jont;	state Exp;
branches;
next	1.200;

1.200
date	93.03.02.16.53.43;	author matthew;	state Exp;
branches;
next	1.199;

1.199
date	93.03.01.15.09.41;	author matthew;	state Exp;
branches;
next	1.198;

1.198
date	93.02.26.15.08.53;	author jont;	state Exp;
branches;
next	1.197;

1.197
date	93.02.23.19.37.28;	author daveb;	state Exp;
branches;
next	1.196;

1.196
date	92.12.17.17.06.37;	author matthew;	state Exp;
branches;
next	1.195;

1.195
date	92.12.14.12.01.24;	author clive;	state Exp;
branches;
next	1.194;

1.194
date	92.12.08.19.38.52;	author jont;	state Exp;
branches;
next	1.193;

1.193
date	92.12.02.15.59.46;	author daveb;	state Exp;
branches;
next	1.192;

1.192
date	92.12.01.20.18.26;	author jont;	state Exp;
branches;
next	1.191;

1.191
date	92.11.30.10.34.48;	author jont;	state Exp;
branches;
next	1.190;

1.190
date	92.11.25.14.40.25;	author daveb;	state Exp;
branches;
next	1.189;

1.189
date	92.11.19.16.24.58;	author daveb;	state Exp;
branches;
next	1.188;

1.188
date	92.11.10.13.54.13;	author matthew;	state Exp;
branches;
next	1.187;

1.187
date	92.11.04.15.55.31;	author jont;	state Exp;
branches;
next	1.186;

1.186
date	92.11.03.12.03.45;	author daveb;	state Exp;
branches;
next	1.185;

1.185
date	92.10.30.13.47.03;	author jont;	state Exp;
branches;
next	1.184;

1.184
date	92.10.28.11.37.26;	author jont;	state Exp;
branches;
next	1.183;

1.183
date	92.10.02.16.53.52;	author clive;	state Exp;
branches;
next	1.182;

1.182
date	92.09.24.15.35.17;	author jont;	state Exp;
branches;
next	1.181;

1.181
date	92.09.09.10.02.52;	author clive;	state Exp;
branches;
next	1.180;

1.180
date	92.09.01.14.36.28;	author clive;	state Exp;
branches;
next	1.179;

1.179
date	92.08.26.14.53.59;	author jont;	state Exp;
branches;
next	1.178;

1.178
date	92.08.25.20.20.46;	author jont;	state Exp;
branches;
next	1.177;

1.177
date	92.08.24.16.13.18;	author richard;	state Exp;
branches;
next	1.176;

1.176
date	92.08.24.13.43.46;	author jont;	state Exp;
branches;
next	1.175;

1.175
date	92.08.20.12.59.29;	author davidt;	state Exp;
branches;
next	1.174;

1.174
date	92.08.20.11.06.31;	author richard;	state Exp;
branches;
next	1.173;

1.173
date	92.08.18.14.37.06;	author jont;	state Exp;
branches;
next	1.172;

1.172
date	92.08.17.16.41.08;	author jont;	state Exp;
branches;
next	1.171;

1.171
date	92.08.07.16.52.08;	author davidt;	state Exp;
branches;
next	1.170;

1.170
date	92.08.07.11.40.16;	author clive;	state Exp;
branches;
next	1.169;

1.169
date	92.08.06.16.11.43;	author jont;	state Exp;
branches;
next	1.168;

1.168
date	92.08.05.18.14.46;	author jont;	state Exp;
branches;
next	1.167;

1.167
date	92.08.05.15.01.03;	author jont;	state Exp;
branches;
next	1.166;

1.166
date	92.08.04.18.22.02;	author jont;	state Exp;
branches;
next	1.165;

1.165
date	92.08.04.16.25.07;	author davidt;	state Exp;
branches;
next	1.164;

1.164
date	92.07.29.17.25.01;	author jont;	state Exp;
branches;
next	1.163;

1.163
date	92.07.27.09.44.45;	author richard;	state Exp;
branches;
next	1.162;

1.162
date	92.07.23.15.55.53;	author clive;	state Exp;
branches;
next	1.161;

1.161
date	92.07.20.11.49.26;	author clive;	state Exp;
branches;
next	1.160;

1.160
date	92.07.14.10.15.34;	author clive;	state Exp;
branches;
next	1.159;

1.159
date	92.07.08.16.37.23;	author clive;	state Exp;
branches;
next	1.158;

1.158
date	92.07.07.10.27.25;	author clive;	state Exp;
branches;
next	1.157;

1.157
date	92.07.06.09.55.44;	author davida;	state Exp;
branches;
next	1.156;

1.156
date	92.06.29.15.20.59;	author jont;	state Exp;
branches;
next	1.155;

1.155
date	92.06.29.09.46.28;	author clive;	state Exp;
branches;
next	1.154;

1.154
date	92.06.25.10.55.41;	author jont;	state Exp;
branches;
next	1.153;

1.153
date	92.06.19.15.52.26;	author jont;	state Exp;
branches;
next	1.152;

1.152
date	92.06.19.09.41.34;	author richard;	state Exp;
branches;
next	1.151;

1.151
date	92.06.17.15.08.32;	author jont;	state Exp;
branches;
next	1.150;

1.150
date	92.06.16.20.18.10;	author jont;	state Exp;
branches;
next	1.149;

1.149
date	92.06.15.16.24.06;	author jont;	state Exp;
branches;
next	1.148;

1.148
date	92.06.12.13.03.23;	author clive;	state Exp;
branches;
next	1.147;

1.147
date	92.06.11.11.05.35;	author clive;	state Exp;
branches;
next	1.146;

1.146
date	92.06.10.14.42.06;	author jont;	state Exp;
branches;
next	1.145;

1.145
date	92.06.08.16.25.21;	author jont;	state Exp;
branches;
next	1.144;

1.144
date	92.05.22.16.00.47;	author jont;	state Exp;
branches;
next	1.143;

1.143
date	92.05.21.09.14.14;	author clive;	state Exp;
branches;
next	1.142;

1.142
date	92.05.14.11.10.26;	author clive;	state Exp;
branches;
next	1.141;

1.141
date	92.05.13.09.54.27;	author jont;	state Exp;
branches;
next	1.140;

1.140
date	92.05.08.12.51.16;	author clive;	state Exp;
branches;
next	1.139;

1.139
date	92.05.06.15.54.10;	author jont;	state Exp;
branches;
next	1.138;

1.138
date	92.04.28.15.56.17;	author clive;	state Exp;
branches;
next	1.137;

1.137
date	92.04.24.16.20.36;	author jont;	state Exp;
branches;
next	1.136;

1.136
date	92.04.14.15.48.13;	author clive;	state Exp;
branches;
next	1.135;

1.135
date	92.04.08.15.56.11;	author jont;	state Exp;
branches;
next	1.134;

1.134
date	92.04.02.23.01.37;	author jont;	state Exp;
branches;
next	1.133;

1.133
date	92.04.02.14.50.21;	author jont;	state Exp;
branches;
next	1.132;

1.132
date	92.03.31.15.52.14;	author jont;	state Exp;
branches;
next	1.131;

1.131
date	92.03.30.17.24.45;	author jont;	state Exp;
branches;
next	1.130;

1.130
date	92.03.26.16.28.44;	author jont;	state Exp;
branches;
next	1.129;

1.129
date	92.03.20.18.47.23;	author jont;	state Exp;
branches;
next	1.128;

1.128
date	92.03.19.16.41.38;	author jont;	state Exp;
branches;
next	1.127;

1.127
date	92.03.10.19.13.43;	author jont;	state Exp;
branches;
next	1.126;

1.126
date	92.03.10.15.33.32;	author clive;	state Exp;
branches;
next	1.125;

1.125
date	92.03.09.17.17.07;	author clive;	state Exp;
branches;
next	1.124;

1.124
date	92.03.04.21.35.40;	author jont;	state Exp;
branches;
next	1.123;

1.123
date	92.03.03.14.03.38;	author richard;	state Exp;
branches;
next	1.122;

1.122
date	92.03.02.16.44.52;	author richard;	state Exp;
branches;
next	1.121;

1.121
date	92.02.27.16.03.39;	author richard;	state Exp;
branches;
next	1.120;

1.120
date	92.02.25.11.00.59;	author clive;	state Exp;
branches;
next	1.119;

1.119
date	92.02.24.17.53.42;	author clive;	state Exp;
branches;
next	1.118;

1.118
date	92.02.24.15.28.52;	author clive;	state Exp;
branches;
next	1.117;

1.117
date	92.02.24.12.59.33;	author clive;	state Exp;
branches;
next	1.116;

1.116
date	92.02.21.09.02.30;	author clive;	state Exp;
branches;
next	1.115;

1.115
date	92.02.20.17.01.07;	author richard;	state Exp;
branches;
next	1.114;

1.114
date	92.02.19.18.08.08;	author clive;	state Exp;
branches;
next	1.113;

1.113
date	92.02.19.12.08.37;	author clive;	state Exp;
branches;
next	1.112;

1.112
date	92.02.18.08.56.08;	author clive;	state Exp;
branches;
next	1.111;

1.111
date	92.02.17.19.12.28;	author jont;	state Exp;
branches;
next	1.110;

1.110
date	92.02.11.11.24.16;	author clive;	state Exp;
branches;
next	1.109;

1.109
date	92.02.07.16.55.03;	author jont;	state Exp;
branches;
next	1.108;

1.108
date	92.02.06.20.28.44;	author jont;	state Exp;
branches;
next	1.107;

1.107
date	92.02.05.16.19.30;	author richard;	state Exp;
branches;
next	1.106;

1.106
date	92.02.04.11.06.14;	author clive;	state Exp;
branches;
next	1.105;

1.105
date	92.01.31.16.16.43;	author jont;	state Exp;
branches;
next	1.104;

1.104
date	92.01.28.19.03.06;	author jont;	state Exp;
branches;
next	1.103;

1.103
date	92.01.25.12.21.42;	author jont;	state Exp;
branches;
next	1.102;

1.102
date	92.01.24.17.02.32;	author clive;	state Exp;
branches;
next	1.101;

1.101
date	92.01.24.10.48.26;	author clive;	state Exp;
branches;
next	1.100;

1.100
date	92.01.23.10.12.07;	author clive;	state Exp;
branches;
next	1.99;

1.99
date	92.01.22.15.24.26;	author clive;	state Exp;
branches;
next	1.98;

1.98
date	92.01.21.18.20.16;	author clive;	state Exp;
branches;
next	1.97;

1.97
date	92.01.17.17.22.56;	author clive;	state Exp;
branches;
next	1.96;

1.96
date	92.01.16.17.24.08;	author clive;	state Exp;
branches;
next	1.95;

1.95
date	92.01.14.15.26.31;	author jont;	state Exp;
branches;
next	1.94;

1.94
date	92.01.13.10.08.28;	author richard;	state Exp;
branches;
next	1.93;

1.93
date	92.01.10.11.52.13;	author richard;	state Exp;
branches;
next	1.92;

1.92
date	92.01.08.14.45.59;	author jont;	state Exp;
branches;
next	1.91;

1.91
date	92.01.07.15.30.33;	author richard;	state Exp;
branches;
next	1.90;

1.90
date	92.01.07.12.21.26;	author jont;	state Exp;
branches;
next	1.89;

1.89
date	92.01.03.18.00.50;	author jont;	state Exp;
branches;
next	1.88;

1.88
date	92.01.03.11.42.33;	author jont;	state Exp;
branches;
next	1.87;

1.87
date	91.12.23.15.28.45;	author richard;	state Exp;
branches;
next	1.86;

1.86
date	91.12.20.13.59.19;	author richard;	state Exp;
branches;
next	1.85;

1.85
date	91.12.16.15.41.27;	author jont;	state Exp;
branches;
next	1.84;

1.84
date	91.12.09.16.51.39;	author jont;	state Exp;
branches;
next	1.83;

1.83
date	91.12.06.16.10.11;	author jont;	state Exp;
branches;
next	1.82;

1.82
date	91.12.05.19.08.37;	author jont;	state Exp;
branches;
next	1.81;

1.81
date	91.12.04.17.34.23;	author jont;	state Exp;
branches;
next	1.80;

1.80
date	91.12.02.22.04.00;	author jont;	state Exp;
branches;
next	1.79;

1.79
date	91.11.29.18.07.01;	author jont;	state Exp;
branches;
next	1.78;

1.78
date	91.11.28.17.14.14;	author richard;	state Exp;
branches;
next	1.77;

1.77
date	91.11.27.19.47.23;	author jont;	state Exp;
branches;
next	1.76;

1.76
date	91.11.27.13.08.37;	author jont;	state Exp;
branches;
next	1.75;

1.75
date	91.11.27.12.10.53;	author jont;	state Exp;
branches;
next	1.74;

1.74
date	91.11.21.19.54.17;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	91.11.20.14.52.56;	author jont;	state Exp;
branches;
next	1.72;

1.72
date	91.11.18.14.43.16;	author richard;	state Exp;
branches;
next	1.71;

1.71
date	91.11.14.17.06.00;	author jont;	state Exp;
branches;
next	1.70;

1.70
date	91.11.14.15.43.05;	author richard;	state Exp;
branches;
next	1.69;

1.69
date	91.11.14.12.39.39;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	91.11.13.19.05.04;	author jont;	state Exp;
branches;
next	1.67;

1.67
date	91.11.12.18.36.11;	author jont;	state Exp;
branches;
next	1.66;

1.66
date	91.11.08.14.44.59;	author jont;	state Exp;
branches;
next	1.65;

1.65
date	91.11.07.16.43.37;	author jont;	state Exp;
branches;
next	1.64;

1.64
date	91.11.04.10.37.44;	author jont;	state Exp;
branches;
next	1.63;

1.63
date	91.10.30.17.34.16;	author jont;	state Exp;
branches;
next	1.62;

1.62
date	91.10.29.18.29.10;	author davidt;	state Exp;
branches;
next	1.61;

1.61
date	91.10.29.17.39.46;	author jont;	state Exp;
branches;
next	1.60;

1.60
date	91.10.28.15.36.18;	author richard;	state Exp;
branches;
next	1.59;

1.59
date	91.10.28.13.15.33;	author davidt;	state Exp;
branches;
next	1.58;

1.58
date	91.10.28.11.54.34;	author davidt;	state Exp;
branches;
next	1.57;

1.57
date	91.10.25.17.09.07;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	91.10.24.11.49.19;	author jont;	state Exp;
branches;
next	1.55;

1.55
date	91.10.24.11.04.52;	author jont;	state Exp;
branches;
next	1.54;

1.54
date	91.10.23.13.34.01;	author davidt;	state Exp;
branches;
next	1.53;

1.53
date	91.10.22.18.29.54;	author davidt;	state Exp;
branches;
next	1.52;

1.52
date	91.10.21.14.45.32;	author jont;	state Exp;
branches;
next	1.51;

1.51
date	91.10.18.17.39.41;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	91.10.17.15.37.07;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	91.10.16.17.22.41;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	91.10.15.15.43.03;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	91.10.11.15.29.25;	author richard;	state Exp;
branches;
next	1.45;

1.45
date	91.10.11.10.45.22;	author richard;	state Exp;
branches;
next	1.44;

1.44
date	91.10.10.14.47.30;	author richard;	state Exp;
branches;
next	1.43;

1.43
date	91.10.10.13.43.51;	author richard;	state Exp;
branches;
next	1.42;

1.42
date	91.10.09.18.12.59;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	91.10.09.16.40.54;	author davidt;	state Exp;
branches;
next	1.40;

1.40
date	91.10.09.14.45.03;	author richard;	state Exp;
branches;
next	1.39;

1.39
date	91.10.08.18.21.44;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	91.10.08.15.58.02;	author richard;	state Exp;
branches;
next	1.37;

1.37
date	91.10.08.11.52.55;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	91.10.04.13.05.12;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	91.10.03.21.23.09;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	91.10.02.11.40.21;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	91.09.25.11.20.33;	author richard;	state Exp;
branches;
next	1.32;

1.32
date	91.09.24.15.44.55;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	91.09.23.12.31.35;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	91.09.20.15.53.57;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	91.09.19.17.08.15;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	91.09.18.15.51.40;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	91.09.17.17.04.42;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	91.09.16.16.33.35;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	91.09.10.15.14.10;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	91.09.09.13.54.45;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	91.09.05.18.19.03;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	91.09.04.18.14.26;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	91.09.03.18.19.22;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	91.09.03.14.24.58;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	91.09.02.16.35.26;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	91.08.30.17.37.18;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	91.08.29.16.10.14;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	91.08.23.18.15.17;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	91.08.23.15.00.11;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	91.08.15.16.22.23;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	91.08.15.14.00.11;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	91.08.14.14.56.03;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	91.08.13.18.24.06;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.08.09.19.12.35;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.08.07.11.31.21;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.08.06.18.38.58;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.08.05.12.30.04;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.08.02.16.49.06;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.08.01.18.52.17;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.07.31.19.39.19;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.07.30.17.48.59;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.07.26.20.17.27;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.07.25.18.11.54;	author jont;	state Exp;
branches;
next	;

1.223.1.1
date	93.08.23.14.42.17;	author jont;	state Exp;
branches;
next	1.223.1.2;

1.223.1.2
date	93.09.28.14.53.12;	author daveb;	state Exp;
branches;
next	1.223.1.3;

1.223.1.3
date	93.10.05.13.11.17;	author daveb;	state Exp;
branches;
next	;

1.295.1.1
date	96.09.13.11.14.19;	author hope;	state Exp;
branches;
next	1.295.1.2;

1.295.1.2
date	96.09.23.15.39.13;	author matthew;	state Exp;
branches;
next	;

1.297.1.1
date	96.10.07.16.04.47;	author hope;	state Exp;
branches;
next	;

1.297.2.1
date	96.10.17.11.23.01;	author hope;	state Exp;
branches;
next	;

1.299.1.1
date	96.11.14.12.47.17;	author hope;	state Exp;
branches
	1.299.1.1.1.1;
next	;

1.299.1.1.1.1
date	96.11.28.14.58.52;	author hope;	state Exp;
branches;
next	;

1.299.2.1
date	96.11.22.18.07.22;	author hope;	state Exp;
branches;
next	;

1.299.3.1
date	96.12.17.17.46.05;	author hope;	state Exp;
branches
	1.299.3.1.1.1;
next	;

1.299.3.1.1.1
date	97.02.24.11.35.42;	author hope;	state Exp;
branches;
next	;

1.299.4.1
date	96.12.18.09.40.05;	author hope;	state Exp;
branches;
next	;

1.303.1.1
date	97.05.12.10.32.25;	author hope;	state Exp;
branches;
next	1.303.1.2;

1.303.1.2
date	97.05.12.15.37.15;	author daveb;	state Exp;
branches
	1.303.1.2.1.1
	1.303.1.2.2.1
	1.303.1.2.3.1;
next	;

1.303.1.2.1.1
date	97.07.28.18.18.11;	author daveb;	state Exp;
branches
	1.303.1.2.1.1.1.1;
next	;

1.303.1.2.1.1.1.1
date	97.10.07.11.43.09;	author jkbrook;	state Exp;
branches;
next	;

1.303.1.2.2.1
date	97.09.08.17.11.44;	author daveb;	state Exp;
branches;
next	;

1.303.1.2.3.1
date	97.09.09.14.07.20;	author daveb;	state Exp;
branches;
next	;

1.308.1.1
date	97.09.10.19.22.09;	author brucem;	state Exp;
branches;
next	;

1.308.2.1
date	97.09.11.20.53.25;	author daveb;	state Exp;
branches;
next	;

1.311.1.1
date	99.04.01.17.56.05;	author daveb;	state Exp;
branches;
next	;


desc
@Code generator from lambda to mir
@


1.311
log
@[Bug #20119]
Stop fmake_if and imake_if from creating empty blocks
@
text
@(* _mir_cg.sml the functor *)
(*
$Log: _mir_cg.sml,v $
 * Revision 1.310  1998/03/16  15:20:22  jont
 * [Bug #30357]
 * Make sure tail position is passed through into letrec bodies
 *
 * Revision 1.309  1997/09/18  15:41:13  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.308  1997/08/14  17:10:41  jont
 * [Bug #30243]
 * Fix problems with constant shifts by word32 values
 *
 * Revision 1.307  1997/08/07  11:14:18  jont
 * [Bug #30243]
 * Ensure no overlong shifts produced by 32 bit shift operations
 *
 * Revision 1.306  1997/08/01  10:08:18  jont
 * [Bug #30215]
 * Remove BIC in favour of INTTAG
 *
 * Revision 1.305  1997/07/03  15:20:20  jkbrook
 * [Bug #30186]
 * Use optimising/debugging compiler options consistently with the
 * lambda optimiser
 *
 * Revision 1.304  1997/04/11  17:17:34  jont
 * [Bug #2408]
 * Sort out problems with missing tags left out by optimisations
 * performed by the match compiler
 *
 * Revision 1.303  1997/01/21  12:13:25  matthew
 * Pass options to library functions
 *
 * Revision 1.302  1997/01/16  13:12:19  matthew
 * Have tag list in tagged operations
 *
 * Revision 1.301  1997/01/10  17:03:55  andreww
 * [Bug #1818]
 * implementing floatarrays
 *
 * Revision 1.300  1997/01/03  14:44:24  matthew
 * Simplifications and rationalizations
 *
 * Revision 1.299  1996/11/06  11:08:05  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.298  1996/10/30  21:12:15  io
 * moving String from toplevel
 *
 * Revision 1.297  1996/09/26  14:00:33  matthew
 * Bytearray update is always integral
 *
 * Revision 1.296  1996/09/23  12:09:56  matthew
 * Always add end_blocks to result in make_cgt
 *
 * Revision 1.295  1996/08/06  12:28:12  andreww
 * [Bug #1521]
 * propagating changes made to lambda/_auglambda.sml (and ultimately
 * to typechecker/_types.sml).
 *
 * Revision 1.294  1996/05/21  15:37:47  matthew
 * Changed type of word32 shift operarators
 *
 * Revision 1.293  1996/05/14  10:17:42  matthew
 * Adding NOT32 MIR instruction
 *
 * Revision 1.292  1996/04/30  16:54:38  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.290  1996/04/29  14:46:40  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.289  1996/04/19  10:52:33  matthew
 * Removed some exceptions
 *
 * Revision 1.288  1996/03/28  10:50:32  matthew
 * Adding where type clause
 *
 * Revision 1.287  1996/03/20  12:46:53  matthew
 * Change for value polymorphism
 *
 * Revision 1.286  1996/02/02  11:09:52  jont
 * Recode integer 32 bit overflow detecting operations in terms of ADDW
 *
Revision 1.285  1996/01/31  17:36:25  jont
Fix problems with abs of positive int32

Revision 1.284  1996/01/31  17:16:02  jont
Fix code generation of unary negate for int32

Revision 1.283  1996/01/30  10:42:22  jont
Add warning comments to polymorphic equality about mips implementation

Revision 1.282  1995/12/27  13:02:37  jont
Removing Option in favour of MLWorks.Option

Revision 1.281  1995/12/22  17:39:41  jont
Remove references to option structure
in favour of MLWorks.Option

Revision 1.280  1995/12/20  13:17:06  jont
Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend

Revision 1.279  1995/12/04  12:35:41  matthew
Simplifying lambdatypes

Revision 1.278  1995/11/06  13:52:25  jont
Disallow handler optimisation when debug_variables is set

Revision 1.277  1995/11/01  10:16:39  jont
Modify NONE in handler case to allow compilation under NJ

Revision 1.276  1995/10/30  16:33:28  jont
Adding code to optimise compilation of handlers

Revision 1.275  1995/09/25  09:41:44  jont
Fix problems with spill counting during switch arms

Revision 1.274  1995/09/12  18:03:17  daveb
Added types for different lengths of words, ints and reals.

Revision 1.273  1995/09/01  15:17:51  jont
Improved array and vector bounds checking

Revision 1.272  1995/07/28  15:35:31  jont
Handle INTMOD and INTDIV

Revision 1.271  1995/07/26  11:16:09  jont
Fix problem of wrong integer reported too big

Revision 1.270  1995/07/25  15:30:56  jont
Translate WORD SCons

Revision 1.269  1995/07/20  15:50:23  jont
Add pervasive word operations

Revision 1.268  1995/07/19  12:39:29  jont
Deal with code generation of special constant chars

Revision 1.267  1995/07/14  09:48:55  jont
Add new operations on chars

Revision 1.266  1995/07/07  14:33:48  jont
Avoid use of global as an internediate in variable shifts
This makes code generation on the MIPS impossible

Revision 1.265  1995/06/19  11:05:46  jont
Modify handlers to put handler restoration in common sequence

Revision 1.264  1995/05/30  11:53:23  matthew
Removing timer structure

Revision 1.263  1995/05/18  12:27:57  matthew
Improving simple comparison code

Revision 1.262  1995/05/02  11:29:28  matthew
Adding CAST and UMAP primitives

Revision 1.261  1995/03/01  15:45:38  matthew
Adding GET_IMPLICIT pervasive

Revision 1.260  1995/02/07  17:25:53  matthew
Removing use of Types structure

Revision 1.259  1995/01/30  12:07:59  matthew
Renaming debugger_env to runtime_env
Other rationalizations of debugger stuff

Revision 1.258  1995/01/16  14:58:36  jont
Fix range testing in MLWorks.String.ordof

Revision 1.257  1994/11/23  13:15:00  matthew
Added code generation for various "unsafe" pervasives/
Added ALLOC_VECTOR

Revision 1.256  1994/11/16  17:14:04  jont
Do store immediate formation after copy propagation

Revision 1.255  1994/11/16  11:57:12  jont
Add immediate store operations

Revision 1.254  1994/11/10  15:40:37  matthew
Replaced use of BIC with shifts in array lengths.
BIC is hard to translate for the MIPS.
It is still used in one place.

Revision 1.253  1994/11/02  12:29:42  matthew
Fixing problem with intercept code and multiple arguments

Revision 1.252  1994/10/26  18:04:27  jont
Make continuation offsets for handlers guaranteed tagged integers

Revision 1.251  1994/10/24  13:54:56  matthew
Make lookup_in_closure return an Option value
Some reformatting and tidying up
This is ongoing work really

Revision 1.250  1994/10/17  16:11:15  jont
Also array update

Revision 1.249  1994/10/11  12:02:54  matthew
Tidying up

Revision 1.248  1994/09/30  12:58:21  jont
Remove handler register concept

Revision 1.247  1994/09/23  11:31:30  matthew
Abstraction of debug information

Revision 1.246  1994/09/16  16:36:23  jont
Removed explicit use of callee_arg in allocation of
 final result for compilation unit

Revision 1.245  1994/09/14  16:11:48  jont
Reduce handler frame size to four words
by leaving out fp

Revision 1.244  1994/09/09  17:24:37  jont
Machine specific functions is_fun and implicit_references moved to machperv

Revision 1.243  1994/08/25  13:32:20  matthew
More work on multiple arguments

Revision 1.242  1994/08/16  09:14:48  jont
Change count decrement in array and bytearray creation to
be by GP_IMM_INT ~1, as the count is always an ml integer.

Revision 1.241  1994/08/02  15:45:39  matthew
Fix for blunder

Revision 1.240  1994/07/25  14:06:39  matthew
Fixed a bug with is_integral

Revision 1.239  1994/07/25  11:37:32  matthew
Added support for multiple arguments in lambda and mir representations.
This isn't complete yet, but the old one argument case should be as it was.
Tidied up and rearranged the code a lot.  Not too many functional changes
except for the above.

Revision 1.238  1994/06/22  14:44:39  jont
Update debugger information production

Revision 1.237  1994/06/09  15:58:58  nickh
New runtime directory structure.

Revision 1.236  1994/06/07  09:44:33  jont
Added code to remove unreferenced blocks

Revision 1.235  1994/05/12  12:40:46  richard
Passing out the loop entry tag for _mirvariable.

Revision 1.234  1994/03/10  14:48:45  jont
Change handler to use LEO instead of LEA

Revision 1.233  1994/03/04  12:32:55  jont
Changes for automatic_callee mechanism removal
and moving machspec from machine to main

Revision 1.232  1994/02/21  18:24:40  nosa
Improved Control Transfer determining in HANDLEs.

Revision 1.231  1994/02/04  15:16:22  matthew
Always insert interrupt if flag is set.

Revision 1.230  1994/01/19  10:52:29  matthew
Added ConvertInt exception to MirUtils

Revision 1.230  1994/01/19  10:52:29  matthew
convert_int raises ConvertInt exception

Revision 1.229  1994/01/17  18:27:19  daveb
Removed unnecessary exceptions from closures.

Revision 1.228  1993/11/17  18:26:47  jont
Added extra indirection required to get fp values from the closure
for pattern matching

Revision 1.227  1993/11/04  16:55:38  jont
Added code generation of INTERRUPT instruction

Revision 1.226  1993/10/05  13:42:31  daveb
Merged in bug fix.

Revision 1.225  1993/09/28  15:11:02  daveb
Merged in bug fix.

Revision 1.224  1993/09/23  11:26:03  nosa
Polymorphic debugger.

Revision 1.223.1.3  1993/10/05  13:11:17  daveb
The initial value to a bytearray must be untagged before being assigned to
the bytearray.  The register must be cleaned immediately after, to avoid
GC problems.

Revision 1.223.1.2  1993/09/28  14:53:12  daveb
Handled BigNum.Unrepresentable where necessary.

Revision 1.223.1.1  1993/08/23  14:42:17  jont
Fork for bug fixing

Revision 1.223  1993/08/23  14:42:17  richard
Added missing intercept instruction after function entry in the simple
case.

Revision 1.222  1993/08/18  16:50:04  jont
Moved a few more functions into mir_utils

Revision 1.221  1993/08/17  17:21:36  jont
Fixed problem of require statements getting inside handlers etc
due to lambda optimisation.

Revision 1.220  1993/07/30  14:47:06  nosa
Local and Closure variable inspection in the debugger;
new compiler option debug_variables;
values of these variables are spilled unto the stack;
call recording to determine control transfer.

Revision 1.219  1993/07/20  16:52:38  jont
Better version of do_shift

Revision 1.218  1993/07/20  12:57:37  jont
Added support for unsafeintplus, and redid some of the bitwise operations
Dealt with the case of overlarge integers in special constants, both in
matches and atomic values using shifts and adds at runtime

Revision 1.217  1993/07/12  16:48:34  daveb
Made primitive operations refer to exception values instead of exception
names - we have to build them explicitly as a result of the recent changes
to exception environments.

Revision 1.216  1993/07/07  17:29:02  daveb
Removed Primitives structure.
Removed exception environments, and therefore references to EX*VAL.

Revision 1.215  1993/05/28  17:31:34  jont
Fixed a couple of problems which show up when compiling unoptimised lambda
code as required for the debugger. These caused references to undefined registers
and blocks without unconditional control transfers at the end.

Revision 1.214  1993/05/18  16:31:04  daveb
The debug_warning compatability option is no more (it has ceased to be).
Replaced Integer.makestring with MLWorks.Integer.makestring and removed
the Integer structure.

Revision 1.213  1993/05/11  15:35:21  richard
Added a move instruction to put the argument register back in the
right place after a return from an INTERCEPT.

Revision 1.212  1993/04/30  15:47:55  matthew
Changed name of setup function again.

Revision 1.211  1993/04/28  15:18:04  richard
Unified profiling and tracing options into `intercept'.
The argument is always in the argument register before an
INTERCEPT instruction.
Changed PROFILE instruction to INTERCEPT.

Revision 1.210  1993/04/26  16:16:21  matthew
Changed format of debug_info strings.

Revision 1.209  1993/04/15  15:48:40  jont
Removed handler chain restore code, now generated in _mach_cg from OLD_HANDLER

Revision 1.208  1993/03/25  15:29:53  jont
Ensured that the results of unsafe sub for byte array are tagged as integer

Revision 1.207  1993/03/23  15:49:26  jont
Added vector primitives and changed bytearray implementation to use ref tags

Revision 1.206  1993/03/19  16:21:44  jont
Fixed problems in ByteArray.{length,sub,update} to do with loading from
the wrong offset to get the header length, and also not tagging the result
from sub.

Revision 1.205  1993/03/17  14:05:27  jont
Modified Array.sub and Array.update to use MirRegisters.global when bounds
checking to avoid leaving dirty values in the registers

Revision 1.204  1993/03/10  18:14:12  matthew
Signature revisions

Revision 1.203  1993/03/09  17:26:05  jont
Added code for dealing with builtin string relationals

Revision 1.202  1993/03/04  15:16:07  matthew
Options & Info changes

Revision 1.201  1993/03/04  11:59:10  jont
Removed LVar_eq in favour of polymorphic equality

Revision 1.200  1993/03/02  16:53:43  matthew
Rationalised use of Mapping structure
Change of Jon's for polyeq

Revision 1.199  1993/03/01  15:09:41  matthew
Added MLVALUE lambda exp
This is handled just like a string SCON

Revision 1.198  1993/02/26  15:08:53  jont
Modified to use new variable size hashsets

Revision 1.197  1993/02/23  19:37:28  daveb
Added check that argument to ordof is non-negative.
Also removed some commented-out code.

Revision 1.196  1992/12/17  17:06:37  matthew
Changed int and real scons to carry a location around

Revision 1.195  1992/12/14  12:01:24  clive
Raised Info.errors for overflow of constants during code generation

Revision 1.194  1992/12/08  19:38:52  jont
Removed a number of duplicated signatures and structures

Revision 1.193  1992/12/02  15:59:46  daveb
Changes to propagate compiler options as parameters instead of references.

Revision 1.192  1992/12/01  20:18:26  jont
Modified to use new improved hashset signature

Revision 1.191  1992/11/30  10:34:48  jont
Removed a large number of unnecessary map operations

Revision 1.190  1992/11/25  14:40:25  daveb
Fixed misleading typo in generated Mir comment.
Also deleted redefinition of append.

Revision 1.189  1992/11/19  16:24:58  daveb
Commented out the code dealing with switches on integers, as the lambda
optimiser should deal with these.  Also stopped do_chained_tests from
generating unnecessary code in the case of an exhaustive switch without
a default (althought the lambda optimiser should catch this case too).

Revision 1.188  1992/11/10  13:54:13  matthew
Changed Error structure to Info

Revision 1.187  1992/11/04  15:55:31  jont
Removed curry_reduce. Changed top_tags map to use intnewmap

Revision 1.186  1992/11/03  12:03:45  daveb
Switches now have both value-carrying and immediate constructors in the
same switch.  Much fancy code to optimise special cases.

Revision 1.185  1992/10/30  13:47:03  jont
Changed to use LambdaTypes.Map and MirTypes.Map

Revision 1.184  1992/10/28  11:37:26  jont
Removed dependence on environ in favour of environtypes

Revision 1.183  1992/10/02  16:53:52  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.182  1992/09/24  15:35:17  jont
Removed the curry module, it wasn't doing anything

Revision 1.181  1992/09/09  10:02:52  clive
Added flag to switch off warning messages in generating recipes

Revision 1.180  1992/09/01  14:36:28  clive
Added switches for self call optimisation

Revision 1.179  1992/08/26  14:53:59  jont
Removed some redundant structures and sharing

Revision 1.178  1992/08/25  20:20:46  jont
Corrected bug in known escaping functions

Revision 1.177  1992/08/24  16:13:18  richard
Added unsafe update and bytearray primitives.

Revision 1.176  1992/08/24  13:43:46  jont
Ensured not all primitives are regarded as escaping

Revision 1.175  1992/08/20  12:59:29  davidt
Mir_Env now uses NewMap instead of Map.

Revision 1.174  1992/08/20  11:06:31  richard
Added code to do UNSAFE_UPDATE and UNSAFE_SUB.

Revision 1.173  1992/08/18  14:37:06  jont
Fixed an inexhaustive match

Revision 1.172  1992/08/17  16:41:08  jont
Added inline ordof

Revision 1.171  1992/08/07  16:52:08  davidt
String structure is now pervasive.

Revision 1.170  1992/08/07  11:40:16  clive
Added a flag to turn off tail-call optimisation

Revision 1.169  1992/08/06  16:11:43  jont
Fixed a sharing constraint problem

Revision 1.169  1992/08/06  16:11:43  jont
Fixed sharing constraint

Revision 1.168  1992/08/05  18:14:46  jont
Removed some structures and sharing

Revision 1.167  1992/08/05  15:01:03  jont
Improved polymorphic equality by anding the tags before testing

Revision 1.166  1992/08/04  18:22:02  jont
Removed various uses of NewMap.to_list in favour of fold and union

Revision 1.165  1992/08/04  16:25:07  davidt
Removed various redundant structure arguments. Added UPDATE and BECOMES optimisation.
Fixed bug causing bad code to be compiled in the interpreter.

Revision 1.164  1992/07/29  17:25:01  jont
Fixed bug in ftest usage

Revision 1.163  1992/07/27  09:44:45  richard
Changed calls to C to pass a single argument.

Revision 1.162  1992/07/23  15:55:53  clive
Used BIC to clear the bottom two bits when calculating array length

Revision 1.161  1992/07/20  11:49:26  clive
Added jont's curry_reduce

Revision 1.160  1992/07/14  10:15:34  clive
Setup procedure name needs to be passed to count_gc_objects

Revision 1.159  1992/07/08  16:37:23  clive
Jont fix to get more tail calling

Revision 1.158  1992/07/07  10:27:25  clive
Added call point information

Revision 1.157  1992/07/06  09:55:44  davida
Added LET constructor and new slot to APP.
Added diagnostic level control on curry message.

Revision 1.156  1992/06/29  15:20:59  jont
Turned off automatic printing of various timings

Revision 1.155  1992/06/29  09:46:28  clive
Added type annotation information at application points

Revision 1.154  1992/06/25  10:55:41  jont
Changed ml_call to return the result instead of the code!

Revision 1.153  1992/06/19  15:52:26  jont
Added ML_REQUIRE builtin for interpreter to get builtin library

Revision 1.152  1992/06/19  09:41:34  richard
Added parameter to RAISE once again, and some stuff that jont asked
me to put in.

Revision 1.151  1992/06/17  15:08:32  jont
Added code to deal with externals from interpretive environment

Revision 1.150  1992/06/16  20:18:10  jont
Added code to handle externals defined by the interpreter

Revision 1.150  1992/06/16  19:54:20  jont
Added code to handle externals involved with interpretation

Revision 1.149  1992/06/15  16:24:06  jont
Coded load_var etc as unimplemented at present

Revision 1.148  1992/06/12  13:03:23  clive
Changed flag so that debug information generation is off by default

Revision 1.147  1992/06/11  11:05:35  clive
Changes for the recording of FNexp type information

Revision 1.146  1992/06/10  14:42:06  jont
Some minor sharing changes

Revision 1.145  1992/06/08  16:25:21  jont
Modified to use newmap

Revision 1.144  1992/05/22  16:00:47  jont
Added some comments in the poly eq case

Revision 1.143  1992/05/21  09:14:14  clive
Added arithmetic right shift

Revision 1.142  1992/05/14  11:10:26  clive
Added the Bits structure

Revision 1.141  1992/05/13  09:54:27  jont
Changed to use lambda code augmented by number of static gc objects within
at each stage, rather than calculating every time. This produced a big win
on pathological cases like long manifest lists. Also changed the
bounds_and_frees implementation for one which calculates those lambdas
which could be free which are actually required, thus avoiding producing
huge bound variable sets which are of little use.

Revision 1.140  1992/05/08  12:51:16  clive
Added profiling to the setup procedure

Revision 1.139  1992/05/06  15:54:10  jont
Rewritten to use augmented lambda calculus to avoid recalculating
number of static garbage collectable objects within lambda expressions
Also fixed superfluous ALLOCs during integer relational operations

Revision 1.138  1992/04/28  15:56:17  clive
Arrays no longer have their size stored as one of the elements

Revision 1.137  1992/04/24  16:20:36  jont
Added code to reduce number of registers used per block

Revision 1.136  1992/04/14  15:48:13  clive
First version of the profiler

Revision 1.135  1992/04/08  15:56:11  jont
Split out utility functions into separate file. Recoded do_app for
better reliability

Revision 1.134  1992/04/02  23:01:37  jont
Fixed precedence problem in source between @@ and ::

Revision 1.133  1992/04/02  14:50:21  jont
Fixed a problem with self tail recursive functions with
escaping arguments

Revision 1.132  1992/03/31  15:52:14  jont
Removed references to pervasive hd and length

Revision 1.131  1992/03/30  17:24:45  jont
Fixed problem with if code short circuiting for more complicated tests.
Removed bug in code generation of LETREC final expression, whereby
func_in_closure was set to the number of funs generated in the LETREC,
rather than funs_in_closure of the enclosing function.

Revision 1.130  1992/03/26  16:28:44  jont
Fixed a problem with finding the function pointers when the enclosing
function is one of a set (more than one element) of mutually recursive
functions. All down the the damn zeroes. Fixed the same problem
potentially in two other places as well.

Revision 1.129  1992/03/20  18:47:23  jont
Fixed problems whereby static gc objects weren't being correctly picked
up from the surrounding closure when that closure was for more than one
function.

Revision 1.128  1992/03/19  16:41:38  jont
Ensured the correct closure pointer is made available when tail calling
a function in the same recursive set but not the same one

Revision 1.127  1992/03/10  19:13:43  jont
Fixed problem of single argument tail-recursive functions with
escaping arguments where the argument wasn't set up properly
on the tail call

Revision 1.126  1992/03/10  15:33:32  clive
Switch staements for characters did not assume a tagged stack alloc

Revision 1.125  1992/03/09  17:17:07  clive
On code to take off the modified list, code here assumed backward and forward
were tagged

Revision 1.124  1992/03/04  21:35:40  jont
Fixed problem with argument register overwrite in recursive procedures
Fixed incorrect size generated for strings by CHR
Fixed incorrect offset used to find string size by size and ord
Added some inline equality testing before invoking full polymorphic
equality
Fixed problem whereby one argument tail recursive procedures were not
putting the argument in the right register

Revision 1.123  1992/03/03  14:03:38  richard
Added missing case for Pervasives.EQFUN and lowered the diagnostic level
of the message about polymorphic equality.

Revision 1.122  1992/03/02  16:44:52  richard
Made Pervasives.EQ an inline operation.  At the moment it just calls
Pervasives.EQFUN, but soon will do some tests in inline.

Revision 1.121  1992/02/27  16:03:39  richard
Changed the way virtual registers are handled.  See MirTypes.

Revision 1.120  1992/02/25  11:00:59  clive
In chr, stb was used but the word into which we store needs to be zeroed first,
otherwise the strings are not null terminated and so confuse C

Revision 1.119  1992/02/24  17:53:42  clive
Chr and Ord did not deal with tagging of integers

Revision 1.117  1992/02/24  12:59:33  clive
Bug in ARRAY_FN - fixed

Revision 1.116  1992/02/21  09:02:30  clive
In the previous change, the link fiedls were set as (0,1) instead
of (1,0) - (1,0) represents points to older object, (0,1) represents
"on the modified list"

Revision 1.115  1992/02/20  17:01:07  richard
Changed the code for allocation of REF cells and arrays so
that they are no longer placed on any modified list.  They _cannot_
point at younger data, after all!

Revision 1.114  1992/02/19  18:08:08  clive
Arrays of size zero were not allowed - I fixed this (we often need placeholders
- see the lexer for an example)

Revision 1.113  1992/02/19  12:08:37  clive
Didn't handle the (0,0) case in the modified ref chain

Revision 1.112  1992/02/18  08:56:08  clive
Making a letrec closure was fetching at twice the offset

Revision 1.111  1992/02/17  19:12:28  jont
Fixed cg_lvar so that when code generating lambdas representing functions
in the current recursive set, where we are not using this to call,
returns an offset from the current closure, rather than a pointer to
the code

Revision 1.110  1992/02/11  11:24:16  clive
Reworking of the pervasive library

Revision 1.109  1992/02/07  16:55:03  jont
Fixed bug in SELECT(LIST...) whereby offset rather than index was
used to index the list.

Revision 1.108  1992/02/06  20:28:44  jont
Added check to cg_lvar to ensure that variables code generated
really were defined

Revision 1.107  1992/02/05  16:19:30  richard
Abolished PREVIOUS_ENVIRONMENT and PRESERVE_ALL_REGS.

Revision 1.106  1992/02/04  11:06:14  clive
Arrays expected all arguments to be present - they didn't expect a single tuple argument
That is now fixed

Revision 1.105  1992/01/31  16:16:43  jont
Fixed up ordering of stack allocation and handler declaration,
and added handler removal to continuation point after handler called

Revision 1.104  1992/01/28  19:03:06  jont
Fixed problem whereby impossible values in make_cgt went to the
continuation point. They need to define the result first

Revision 1.103  1992/01/25  12:21:42  jont
Allowed handler to be a variable (may occur by CSE)

Revision 1.102  1992/01/24  17:02:32  clive
Modified some of the ref_chain code, and added a copy of the callee_argument
to a new virtual register to the enter section of a lambda

Revision 1.101  1992/01/24  10:48:26  clive
Added array linkage to the ref_chain (for the garbage collector)

Revision 1.100  1992/01/23  10:12:07  clive
Added EXSIZEVAL and EXSUBSCRIPTVAL

Revision 1.99  1992/01/22  15:24:26  clive
Fixed some errors in references

Revision 1.98  1992/01/21  18:20:16  clive
Arrays almost work now

Revision 1.97  1992/01/17  17:22:56  clive
More MIR for arrays

Revision 1.96  1992/01/16  17:24:08  clive
Added some inlineable code for arrays - not quite working yet

Revision 1.95  1992/01/14  15:26:31  jont
Changed raise and handle to new form using implicit vector

Revision 1.94  1992/01/13  10:08:28  richard
Prevented unnecessary ADD 0 instructions being generated when look at
closures.  Added a fix to LETREC generation.

Revision 1.93  1992/01/10  11:52:13  richard
Added a SUBSTRING pervasive as a temporary measure so that the same code
can be compiled under under both New Jersey and MLWorks.

Revision 1.92  1992/01/08  14:45:59  jont
Used curried function application optimisation

Revision 1.91  1992/01/07  15:30:33  richard
Removed the raw spill size field from function closures.

Revision 1.90  1992/01/07  12:21:26  jont
Fixed bug whereby APP(BUILTIN...) demanded empty tuple_binding list,
which isn't necessarily the case

Revision 1.89  1992/01/03  18:00:50  jont
Changed use of InterProc to fit new interface

Revision 1.88  1992/01/03  11:42:33  jont
Ensured result of CALL_C moved away from caller_arg to avoid overwriting

Revision 1.87  1991/12/23  15:28:45  richard
Changed the format of handler records so that the garbage collector can deal
with them.  They now contain a pointer to a procedure (a GC object) and an offet
rather than a pointer into arbitrary code.

Revision 1.86  91/12/20  13:59:19  richard
Added EXxxxVAL exception values to some matches to make them complete.
Corrected the offsets used to load and store the exception record.
Changed raise of built-in exceptions to use the values rather than
reconstructing the packets each time.

Revision 1.85  91/12/16  15:41:27  jont
Fixed bugs in ORD and SIZE

Revision 1.84  91/12/09  16:51:39  jont
Tidied up in tail recursion/continuation

Revision 1.83  91/12/06  16:10:11  jont
More work on tail continuations and recursions

Revision 1.82  91/12/05  19:08:37  jont
Tidied up tail recursion, fixed some bugs and did exit block appending
where relevant.

Revision 1.81  91/12/04  17:34:23  jont
Added tail calling for multi argument functions to self in the case where
the argument doesn't escape.

Revision 1.80  91/12/02  22:04:00  jont
Added tail recursion for two (of the six possible) cases. Added hooks
for two others, involving recursion to self rather than continuation

Revision 1.79  91/11/29  18:07:01  jont
Added tail detection. Ensured that stack allocated stuff is deallocated.
Added parameter for detecting tail thread of control

Revision 1.78  91/11/28  17:14:14  richard
Changed the calls to the Library module to reflect the changes there.

Revision 1.77  91/11/27  19:47:23  jont
Removed some spurious debugging messages

Revision 1.76  91/11/27  13:08:37  jont
Changed Match_Utils.Qsort for Lists.qsort

Revision 1.75  91/11/27  12:10:53  jont
Fixed bug whereby tupled up updates of refs failed.

Revision 1.74  91/11/21  19:54:17  jont
Added some brackets to keep njml 0.75 happy

Revision 1.73  91/11/20  14:52:56  jont
Changed to use exception generating versions of fp opcodes

Revision 1.72  91/11/18  14:43:16  richard
Fixed the in-line code for CALL_C.  Generated lambda expression will
pervasive references filled in before making the top level tags and
counting the garbage collectible objects.

Revision 1.71  91/11/14  17:06:00  jont
Replaced eta_abstract with reference to LambdaSub

Revision 1.70  91/11/14  15:43:05  richard
Added code generation for CALL_C pervasive.  This seems to produce
incorrect code at the moment.

Revision 1.69  91/11/14  12:39:39  jont
Fixed redundant match problem

Revision 1.68  91/11/13  19:05:04  jont
Fixed bug whereby an allocation could happen before the fields of
the previous one had been written. Occurred when tupling up a list
contain FP registers, eg in val x = sqrt 1.0

Revision 1.67  91/11/12  18:36:11  jont
Added case spotting code to handle if relation and avoid doubled tests

Revision 1.66  91/11/08  14:44:59  jont
Corrected writing of stack tuples to assume correctly tagged pointers

Revision 1.65  91/11/07  16:43:37  jont
Added stack allocation of arguments in the instance where the referenced
function does not allow its argument to escape

Revision 1.64  91/11/04  10:37:44  jont
Added use of InterProc for determining procedures which don't return
their arguments

Revision 1.63  91/10/30  17:34:16  jont
Modified mutually recursive closures to have holes in them to get
code pointer alignment correct

Revision 1.62  91/10/29  18:29:10  davidt
Fixed code determining whether a procedure is a leaf procedure or not.

Revision 1.61  91/10/29  17:39:46  jont
Modified instruction order on a raise to allow better scheduling

Revision 1.60  91/10/28  15:36:18  richard
Changed the form of the ALLOCATE and DEALLOCATE instructions yet again.

Revision 1.59  91/10/28  13:15:33  davidt
Changed type of destruct_2_tuple to avoid a lot of the inexhaustive
bindings that were around in this functor. Fixed a bug where an
absent tag was mistakenly flagged as an impossible condition.

Revision 1.58  91/10/28  11:54:34  davidt
The ALLOCATE opcode doesn't need a scratch register or a way of
referencing callc so the extra arguments required to pass this
information around have been completely removed.

Revision 1.57  91/10/25  17:09:07  jont
Allowed () as a final result for programs like
val _ = output(std_out, "Hello world") (which are obviously
very important!)

Revision 1.56  91/10/24  11:49:19  jont
Fixed bug whereby call_c was being generated from wrong closure during
function and letrec generation

Revision 1.55  91/10/24  11:04:52  jont
Added BTA and BNT for tagged value testing
Allowed multiple top level blocks for handlers

Revision 1.54  91/10/23  13:34:01  davidt
Took out some old printing functions which used NewJersey print.
Put in a Crash.impossible instead of raise ...

Revision 1.53  91/10/22  18:29:54  davidt
The structure LambdaSub.LambdaTypes is now called LambdaSub.LT

Revision 1.52  91/10/21  14:45:32  jont
Modified local and external reference production.

Revision 1.51  91/10/18  17:39:41  jont
Sorted out returned value from top level procedure
Fixed bug whereby values were being lost in combine

Revision 1.50  91/10/17  15:37:07  jont
Modified ALLOC stuff again, hopefully code generation possible this time

Revision 1.49  91/10/16  17:22:41  jont
Added determination of implicit call_c requirements

Revision 1.48  91/10/16  14:08:29  jont
Updated to reflect new simplified module structure
Still needs work on call_c stuff in allocate

Revision 1.47  91/10/15  15:43:03  jont
Fixed up pointer offsets. Still to add CALL_C stuff for GC

Revision 1.46  91/10/11  15:29:25  richard
Added use of DEALLOC_STACK where possible. Fixed problem with
use of callee_arg as temporary register.

Revision 1.45  91/10/11  10:45:22  richard
Slight alterations to cope with new MirTypes.

Revision 1.44  91/10/10  14:47:30  richard
Added ENTER and RTS to final block, making it into a bona fide
proceedure.

Revision 1.43  91/10/10  13:43:51  richard
Changed register use to implement register windows on machines that
have them. Removed RESTORE_REGS and PRESERVE_REGS and replaced with
parameters on the ENTER instruction. Changed raise from an ordinary
BSR to a parameterized RAISE instruction.

Revision 1.42  91/10/09  18:12:59  jont
Mended SELECT

Revision 1.41  91/10/09  16:40:54  davidt
Made changes to generate code for selections from pairs properly

Revision 1.40  91/10/09  14:45:03  richard
Modified to generate a different procedure entry routine for those
machines with register windows.

Revision 1.39  91/10/08  18:21:44  jont
Replaced raise Lambdatypes.impossible with Crash.impossible

Revision 1.38  91/10/08  15:58:02  richard
Changed handler code to use global register when traversing the stack.

Revision 1.37  91/10/08  11:52:55  jont
Replaced lambdasub.number_from by lists.number_from_by_one

Revision 1.36  91/10/04  13:05:12  jont
Changed to use new PROC type for bundling up procedures

Revision 1.35  91/10/03  21:23:09  jont
Sorted out values from procedures

Revision 1.34  91/10/02  11:40:21  jont
Removed real register options, these are being done elsewhere

Revision 1.33  91/09/25  11:20:33  richard
Reversed the order of the RAISE and BSR instructions when raising an
exception. This makes dead code elimination easier.

Revision 1.32  91/09/24  15:44:55  jont
Fixed bug whereby blocks were getting lost during HANDLE clauses
Fixed up all exception generating instructions automatically

Revision 1.31  91/09/23  12:31:35  jont
Added implicit exception handling (eg for ADDV)

Revision 1.30  91/09/20  15:53:57  jont
Added PRESERVE_ALL_REGS for benefit of RAISE/HANDLE
Started work on impicitly used exceptions (eg ADDV)

Revision 1.29  91/09/19  17:08:15  jont
Fixed bugs in LETREC and default cases in SWITCH.
Added code for SWITCH into empty list, as this can occur
Also added exception tag for MODV, newly created

Revision 1.28  91/09/18  15:51:40  jont
Fixed bug in HANDLE causing empty blocks, and removed
fn_arg etc to separate module for better external structure

Revision 1.27  91/09/17  17:04:42  jont
Added raise and handle

Revision 1.26  91/09/16  16:33:35  jont
Started on HANDLE

Revision 1.25  91/09/10  15:14:10  jont
Added use of NON_GC_SPILL_SIZE to closure production

Revision 1.24  91/09/09  13:54:45  jont
Added slot in closure for non-gc spill area size

Revision 1.23  91/09/05  18:19:03  jont
Added code generation of switches against exception values,
and augmenting of lambda -> register environment following code
generation of certain expressions

Revision 1.22  91/09/04  18:14:26  jont
Added ord, chr, size. Sorted out STRINGEQ calling.
Removed bug in subst_ext_prims.

Revision 1.21  91/09/03  18:19:22  jont
Added STRING match (almost)

Revision 1.20  91/09/03  14:24:58  jont
Added SWITCH on REAL and recursive function call to arbitrary member
of same recursive set.

Revision 1.19  91/09/02  16:35:26  jont
Removed translations from primitives to HARP

Revision 1.18  91/08/30  17:37:18  jont
Added floating point ops, and reorganised cg_result to allow for
fp results

Revision 1.17  91/08/29  16:10:14  jont
Added code for ref, !, :=

Revision 1.16  91/08/23  18:15:17  jont
Redid primitive application coding

Revision 1.15  91/08/23  15:00:11  jont
Changed to use pervasives

Revision 1.14  91/08/15  16:22:23  jont
Added optimisation for simple recursive functions to avoid reloading via
closure by use of BSR

Revision 1.13  91/08/15  14:00:11  jont
Modified in line with later version of HARP
Added pervasives module references, plus overflow exception detection

Revision 1.12  91/08/14  14:56:03  jont
Added external references. Fixed bug in SELECT

Revision 1.11  91/08/13  18:24:06  jont
Added code to start dealing with pervasives and external references

Revision 1.10  91/08/09  19:12:35  jont
Added stuff to generate pervasive environment prior to code generating
general builtins

Revision 1.9  91/08/07  11:31:21  jont
Added relational operations for integers

Revision 1.8  91/08/06  18:38:58  jont
Added SWITCH on ints using chained branches,
and LETRECs.

Revision 1.7  91/08/05  12:30:04  jont
Added some comments to the output Harp. Ensured that SCON_TAGs involving
strings and reals were treated as garbage collectable. Spotted leaf
(no call) procedures.

Revision 1.6  91/08/02  16:49:06  jont
Completed function definition. Added function call.

Revision 1.5  91/08/01  18:52:17  jont
Sorted out closures and the top level argument a bit more

Revision 1.4  91/07/31  19:39:19  jont
Started on FNs. Looking at global analysis of static gc objects

Revision 1.3  91/07/30  17:48:59  jont
Coded most of switch, apart from reals and strings, and sparse ints

Revision 1.2  91/07/26  20:17:27  jont
Updated to deal with simple APP of FN

Revision 1.1  91/07/25  18:11:54  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "$.basis.__int";
require "$.basis.__string";

require "../utils/diagnostic";
require "../utils/_hashset";
require "../utils/lists";
require "../utils/crash";
require "../utils/intnewmap";
require "../utils/bignum";
require "../main/info";
require "../main/options";
require "../lambda/lambdaprint";
require "../lambda/simpleutils";
require "../match/type_utils";
require "../main/library";
require "../rts/gen/implicit";
require "../main/machspec";
require "../main/machperv";
require "mirregisters";
require "mirprint";
require "mir_utils";
require "mirtables";
require "mir_cg";

functor Mir_Cg(
  include sig
  structure Diagnostic : DIAGNOSTIC
  structure Lists : LISTS
  structure Crash : CRASH
  structure Info : INFO
  structure Options : OPTIONS
  structure IntMap : INTNEWMAP
  structure BigNum : BIGNUM
  structure BigNum32 : BIGNUM
  structure Library : LIBRARY
  structure LambdaPrint : LAMBDAPRINT
  structure SimpleUtils : SIMPLEUTILS
  structure MirPrint : MIRPRINT
  structure MirRegisters : MIRREGISTERS
  structure Mir_Utils : MIR_UTILS
  structure MirTables : MIRTABLES
  structure Implicit_Vector : IMPLICIT_VECTOR
  structure MachSpec : MACHSPEC
  structure MachPerv : MACHPERV
  structure TypeUtils : TYPE_UTILS

  sharing Library.AugLambda.Debugger_Types.Options = Options
  sharing TypeUtils.Datatypes.Ident.Location = Info.Location
  sharing LambdaPrint.LambdaTypes = Library.AugLambda.LambdaTypes =
    SimpleUtils.LambdaTypes = Mir_Utils.Mir_Env.LambdaTypes
  sharing MirRegisters.MirTypes = MirPrint.MirTypes = Mir_Utils.Mir_Env.MirTypes =
    MirTables.MirTypes
  sharing Library.AugLambda = Mir_Utils.AugLambda
  sharing Mir_Utils.Mir_Env.MirTypes.Debugger_Types =
	  Library.AugLambda.Debugger_Types
  sharing TypeUtils.Datatypes.NewMap = Library.NewMap = Mir_Utils.Map
  sharing LambdaPrint.LambdaTypes.Ident = TypeUtils.Datatypes.Ident

  sharing type Library.CompilerOptions = Options.compiler_options
  sharing type Mir_Utils.Mir_Env.Map = IntMap.T
  sharing type MirPrint.MirTypes.Debugger_Types.RuntimeEnv.VarInfo = LambdaPrint.LambdaTypes.VarInfo
  sharing type TypeUtils.Datatypes.Ident.SCon = MirPrint.MirTypes.SCon
  sharing type LambdaPrint.LambdaTypes.Type = TypeUtils.Datatypes.Type
  sharing type MachPerv.Pervasives.pervasive = LambdaPrint.LambdaTypes.Primitive
  sharing type MirPrint.MirTypes.Debugger_Types.RuntimeEnv.Type = LambdaPrint.LambdaTypes.Type =
    TypeUtils.Datatypes.Type
  sharing type MirPrint.MirTypes.Debugger_Types.RuntimeEnv.Tyfun = LambdaPrint.LambdaTypes.Tyfun
  sharing type MirPrint.MirTypes.Debugger_Types.RuntimeEnv.Instance = LambdaPrint.LambdaTypes.Instance =
    TypeUtils.Datatypes.Instance
  sharing type MirPrint.MirTypes.Debugger_Types.RuntimeEnv.FunInfo = LambdaPrint.LambdaTypes.FunInfo
  end where type LambdaPrint.LambdaTypes.LVar = int
): MIR_CG =
struct
  structure Pervasives = MachPerv.Pervasives
  structure LambdaTypes = LambdaPrint.LambdaTypes
  structure Set = LambdaTypes.Set
  structure Sexpr = Mir_Utils.Sexpr
  structure Mir_Env = Mir_Utils.Mir_Env
  structure AugLambda = Library.AugLambda
  structure MirTypes = MirPrint.MirTypes
  structure Datatypes = TypeUtils.Datatypes
  structure Ident = Datatypes.Ident
  structure Symbol = Ident.Symbol
  structure NewMap = Datatypes.NewMap
  structure Diagnostic = Diagnostic
  structure Debugger_Types = AugLambda.Debugger_Types
  structure HashSet = HashSet(
    structure Crash = Crash
    structure Lists = Lists
    type element = LambdaTypes.LVar
    val eq = op=
    val size = 200
    val hash = fn x => x
      )

  structure Info = Info
  structure Options = Options
  structure RuntimeEnv = Debugger_Types.RuntimeEnv

  val do_diagnostics = false
  val print_timings = false

  val N = Int.toString

  val real_offset = 3

  val hashset_size = 64

  (* A local definition for profiling purposes *)
  fun lists_reducel f =
    let
      fun red (acc, []) = acc
        | red (acc, x::xs) = red (f(acc,x), xs)
    in
      red
    end

  fun empty_hashset () = HashSet.empty_set hashset_size

  val caller_arg = MirRegisters.caller_arg
  (* The argument register for all functions *)

  val callee_arg = MirRegisters.callee_arg
  (* The local copy of the argument register *)

  val caller_closure = MirRegisters.caller_closure
  (* The closure pointer for all function calls *)

  val callee_closure = MirRegisters.callee_closure
  (* The local copy of the closure pointer *)

  val fp = MirRegisters.fp
  (* The frame pointer within all functions *)

  val sp = MirRegisters.sp
  (* The stack pointer within all functions *)

  val no_code = ((Sexpr.NIL, [], NONE, Sexpr.NIL), [], [])

  val ident_fn = fn x => x

  fun count_gc_tags(AugLambda.SCON_TAG(Ident.REAL _, _)) = 1		(* Need size? *)
    | count_gc_tags(AugLambda.SCON_TAG(Ident.STRING _, _)) = 1
    | count_gc_tags _ = 0

  val empty_string_tree = NewMap.empty ((op<):string*string->bool,op= : string * string -> bool)

  fun last [] = Crash.impossible"Last empty list"
    | last [x] = x
    | last (_ :: xs) = last xs

  fun new_frees(vars as (old_set, new_set), {lexp=lexp, size=_}) =
    case lexp of
      AugLambda.APP(le, (lel,fpel),_) => new_frees_list (new_frees (vars, le), fpel @@ lel)
    | AugLambda.LET((_,_,lb),le) =>
	new_frees (new_frees (vars,lb), le)
    | AugLambda.FN (args, le,_,_) => new_frees (vars, le)
    | AugLambda.STRUCT le_list => new_frees_list (vars, le_list)
    | AugLambda.SELECT(_, le) => new_frees (vars, le)
    | AugLambda.SWITCH(le, info, tag_le_list, opt) =>
	lists_reducel
	(fn (vars, (tag, le)) =>
	 let
	   val vars = new_frees (vars, le)
	 in
	   case tag of
	     AugLambda.EXP_TAG lexp => new_frees (vars, lexp)
	   | _ => vars
	 end)
	(bandf_opt (new_frees (vars, le), opt), tag_le_list)
    | AugLambda.VAR lv =>
	(old_set,
	 if HashSet.is_member(old_set, lv)
           then HashSet.add_member(new_set, lv)
	 else new_set)
    | AugLambda.LETREC(lv_list, le_list, le) =>
	new_frees_list (vars, le :: le_list)
    | AugLambda.INT _ => vars
    | AugLambda.SCON _ => vars
    | AugLambda.MLVALUE _ => vars
    | AugLambda.HANDLE(le, le') =>
	new_frees(new_frees (vars, le), le')
    | AugLambda.RAISE (le) => new_frees (vars, le)
    | AugLambda.BUILTIN _ => vars

  and new_frees_list (vars, []) = vars
    | new_frees_list (vars,le::rest) = new_frees_list (new_frees (vars,le),rest)

  and bandf_opt(vars, SOME le) = new_frees (vars, le)
    | bandf_opt(vars,_) = vars

  (* Can someone think of a better name for these functions? *)
  fun do_pos1(_, []) = []
    | do_pos1(pos, (_, {size=size:int, lexp=_}) :: rest) =
      pos :: do_pos1(pos+size, rest)

  fun do_pos2(_, []) = []
    | do_pos2(pos, (tag,_) :: rest) =
      pos :: do_pos2(pos+count_gc_tags tag, rest)

  fun do_pos3(_, []) = []
    | do_pos3(pos, {size=size:int, lexp=_} :: rest) =
      pos :: do_pos3(pos+size, rest)

  (* General utilities *)

  val zip2 = Lists.zip

  fun zip3 (l1,l2,l3) =
    let
      fun aux ([],[],[],acc) = rev acc
        | aux (a1::b1,a2::b2,a3::b3,acc) =
          aux (b1,b2,b3,(a1,a2,a3)::acc)
        | aux _ = Crash.impossible "zip3"
    in
      aux (l1,l2,l3,[])
    end

  fun zip4 (l1,l2,l3,l4) =
    let
      fun aux ([],[],[],[],acc) = rev acc
        | aux (a1::b1,a2::b2,a3::b3,a4::b4,acc) =
          aux (b1,b2,b3,b4,(a1,a2,a3,a4)::acc)
        | aux _ = Crash.impossible "zip5"
    in
      aux (l1,l2,l3,l4,[])
    end

  fun zip5 (l1,l2,l3,l4,l5) =
    let
      fun aux ([],[],[],[],[],acc) = rev acc
        | aux (a1::b1,a2::b2,a3::b3,a4::b4,a5::b5,acc) =
          aux (b1,b2,b3,b4,b5,(a1,a2,a3,a4,a5)::acc)
        | aux _ = Crash.impossible "zip5"
    in
      aux (l1,l2,l3,l4,l5,[])
    end

  fun zip7 (l1,l2,l3,l4,l5,l6,l7) =
    let
      fun aux ([],[],[],[],[],[],[],acc) = rev acc
        | aux (a1::b1,a2::b2,a3::b3,a4::b4,a5::b5,a6::b6,a7::b7,acc) =
          aux (b1,b2,b3,b4,b5,b6,b7,(a1,a2,a3,a4,a5,a6,a7)::acc)
        | aux _ = Crash.impossible "zip7"
    in
      aux (l1,l2,l3,l4,l5,l6,l7,[])
    end

  (* Stuff for multi-argument functions *)

  (* Map function parameters onto a fixed set of registers *)
  local
    val caller_arg_regs = MirRegisters.caller_arg_regs
    val callee_arg_regs = MirRegisters.callee_arg_regs

    fun assign_regs regs args =
      let
        fun assign ([],regs,acc) = rev acc
          | assign (rest,[reg],acc) = rev (reg::acc)
          | assign (arg::rest,reg::restregs,acc) = assign (rest,restregs,reg::acc)
          | assign _ = Crash.impossible "Not enough arg regs"
      in
        assign (args,regs,[])
      end
  in
    val assign_caller_regs = assign_regs caller_arg_regs
    val assign_callee_regs = assign_regs callee_arg_regs
    val assign_fp_regs = assign_regs MirRegisters.fp_arg_regs
  end

  fun make_get_args_code (args,copies) =
    let
      fun make_code ([],[],acc) = rev acc
        | make_code ([arg],copies as (_::_::_),acc) =
          let
            fun do_loads (n,copy::rest,acc) =
              do_loads (n+1,rest,
                        MirTypes.STOREOP (MirTypes.LD,
                                          MirTypes.GC_REG copy,
                                          MirTypes.GC_REG arg,
                                          MirTypes.GP_IMM_ANY (n * 4 - 1)) ::
                        acc)
              | do_loads (n,[],acc) = rev acc
          in
            do_loads (0,copies,acc)
          end
        | make_code (arg::restargs,copy::restcopies,acc) =
          make_code (restargs,restcopies,
                     MirTypes.UNARY(MirTypes.MOVE,
                                    MirTypes.GC_REG copy,
                                    MirTypes.GP_GC_REG arg) ::
                     acc)
        | make_code _ = Crash.impossible "make_get_args_code"
    in
      make_code (args,copies,[])
    end

  fun make_fp_get_args_code (args,copies) =
    let
      fun make_code ([],[],acc) = rev acc
        | make_code (arg::restargs,copy::restcopies,acc) =
          make_code (restargs,restcopies,
                     MirTypes.UNARYFP(MirTypes.FMOVE,
                                      MirTypes.FP_REG copy,
                                      MirTypes.FP_REG arg) ::
                     acc)
        | make_code _ = Crash.impossible "make_fp_get_args_code"
    in
      make_code (args,copies,[])
    end

  fun is_simple_relation lexp =
    case lexp of
      AugLambda.APP({lexp=AugLambda.BUILTIN(prim,_), ...},_,_) =>
        (case prim of
           Pervasives.INTLESS => true
         | Pervasives.REALLESS => true
         | Pervasives.CHARLT => true
         | Pervasives.WORDLT => true
         | Pervasives.INTGREATER => true
         | Pervasives.REALGREATER => true
         | Pervasives.CHARGT => true
         | Pervasives.WORDGT => true
         | Pervasives.INTLESSEQ => true
         | Pervasives.REALLESSEQ => true
         | Pervasives.CHARLE => true
         | Pervasives.WORDLE => true
         | Pervasives.INTGREATEREQ => true
         | Pervasives.REALGREATEREQ => true
         | Pervasives.CHARGE => true
         | Pervasives.WORDGE => true
         | Pervasives.INTEQ => true
         | Pervasives.INTNE => true
         | Pervasives.REALEQ => true
         | Pervasives.REALNE => true
         | Pervasives.CHAREQ => true
         | Pervasives.CHARNE => true
         | Pervasives.WORDEQ => true
         | Pervasives.WORDNE => true
         | _ => false)
    | _ => false

  fun convert_tag tag =
    case tag of
      AugLambda.VCC_TAG(tag,_) => RuntimeEnv.CONSTRUCTOR(tag)
    | AugLambda.IMM_TAG(tag,_) => RuntimeEnv.CONSTRUCTOR(tag)
    | AugLambda.SCON_TAG(tag, _) => 				(* Need size? *)
        (case tag of
           Ident.INT(tag,_) => RuntimeEnv.INT(tag)
         | Ident.REAL(tag,_) => RuntimeEnv.REAL(tag)
         | Ident.STRING(tag) => RuntimeEnv.STRING(tag)
         | Ident.CHAR(tag) => RuntimeEnv.CHAR(tag)
         | Ident.WORD(tag, _) => RuntimeEnv.WORD(tag))
    | AugLambda.EXP_TAG(_) => RuntimeEnv.DYNAMIC

    (* Generates a map from primitives to lambda variables *)
    fun make_prim_info (options,lambda_exp) =
      let
        val (prim_to_lambda_map, new_lambda_exp) =
          Library.build_external_environment (options, lambda_exp)
        val prim_to_lambda = NewMap.apply prim_to_lambda_map
      in
        (prim_to_lambda,new_lambda_exp)
      end

  fun do_externals (new_exp_and_size,number_of_gc_objects) =
    let

    val (top_tags_list, next) =
      Lists.number_from_by_one(Mir_Utils.list_of_tags (number_of_gc_objects+1), 0,
                               ident_fn)

    val top_closure = IntMap.apply (IntMap.from_list (map (fn (x,y) => (y,x)) top_tags_list))

(*
      (lists_reducel
       (fn (x, (t, i)) => IntMap.define(x, i, t))
       (IntMap.empty, top_tags_list))
*)

    fun wrap_tree_bindings(tree, prim, le) =
      NewMap.fold
      (* Theoretically the wrong order, but there is no dependence *)
      (fn (le as {size=size, ...}, string, lv) =>
       {lexp=AugLambda.LET
        ((lv, NONE,
         {lexp=AugLambda.APP
	      ({lexp=AugLambda.BUILTIN(prim,LambdaTypes.null_type_annotation),
		size=0},
	       ([{lexp=AugLambda.SCON(Ident.STRING string, NONE), size=0}],[]),
               Debugger_Types.null_backend_annotation),
               size=0}), le), size=size})
      (le, tree)

    val needs_transform = Mir_Utils.transform_needed(false, new_exp_and_size)

    val ((var_tree, exn_tree, str_tree, fun_tree, ext_tree), new_exp_and_size) =
      if needs_transform then
	Mir_Utils.lift_externals((empty_string_tree, empty_string_tree, empty_string_tree,
                                  empty_string_tree, empty_string_tree), new_exp_and_size)
      else
	((empty_string_tree, empty_string_tree, empty_string_tree,
	  empty_string_tree, empty_string_tree), new_exp_and_size)

    val ext_vars = NewMap.domain var_tree
    val ext_exns = NewMap.domain exn_tree
    val ext_strs = NewMap.domain str_tree
    val ext_funs = NewMap.domain fun_tree
    val new_exp_and_size =
      if needs_transform then
	wrap_tree_bindings
	(ext_tree, Pervasives.LOAD_STRING, wrap_tree_bindings
	 (var_tree, Pervasives.LOAD_VAR, wrap_tree_bindings
	  (exn_tree, Pervasives.LOAD_EXN, wrap_tree_bindings
	   (str_tree, Pervasives.LOAD_STRUCT, wrap_tree_bindings
	    (fun_tree, Pervasives.LOAD_FUNCT, new_exp_and_size)))))
      else
	new_exp_and_size

    val ext_strings =
      if needs_transform
        then NewMap.domain ext_tree
      else Set.set_to_list (Mir_Utils.get_string new_exp_and_size)

    val (ext_string_list, next) =
      Lists.number_from_by_one(ext_strings, next, ident_fn)
    val (ext_var_list, next) =
      Lists.number_from_by_one(ext_vars, next, ident_fn)
    val (ext_exn_list, next) =
      Lists.number_from_by_one(ext_exns, next, ident_fn)
    val (ext_str_list, next) =
      Lists.number_from_by_one(ext_strs, next, ident_fn)
    val (ext_fun_list, next) =
      Lists.number_from_by_one(ext_funs, next, ident_fn)
    in
      (new_exp_and_size, top_tags_list, top_closure,
       (ext_string_list,ext_var_list,ext_exn_list,ext_str_list,ext_fun_list))
  end


  fun find_frees (env,closure,fcn,prim_to_lambda) =
          let
            val Mir_Env.LAMBDA_ENV lambda_env = env
            val Mir_Env.CLOSURE_ENV closure_env = closure
            fun add_members x = IntMap.fold (fn (set, x,_) => HashSet.add_member(set, x)) x
            val (_,free) =
              new_frees
              ((add_members (add_members (empty_hashset(), closure_env), lambda_env),
                empty_hashset()),
               {lexp=fcn, size=0})
            val free' =
              if Mir_Utils.needs_prim_stringeq fcn then
                HashSet.add_member(free, prim_to_lambda Pervasives.STRINGEQ)
              else
                free
          in
            HashSet.set_to_list
            (lists_reducel
             (fn (free', x) => HashSet.add_member(free', prim_to_lambda x))
             (free', Set.set_to_list (Library.implicit_external_references fcn)))
          end

      (* Code generation utilities *)
      fun load_external (lexp,index_fn,env,spills,calls) =
	(case lexp of
	  AugLambda.SCON(Ident.STRING chars, _) =>
	    let
	      val result = MirTypes.GC.new()
	    in
	      (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
               ((Sexpr.ATOM[MirTypes.STOREOP(MirTypes.LD,
                                             MirTypes.GC_REG result,
                                             MirTypes.GC_REG callee_closure,
                                             MirTypes.GP_IMM_ANY(~1 + 4 * (index_fn chars)))],
               [], NONE, Sexpr.NIL), [], []),
               env,spills,calls)
	    end
	| _ => Crash.impossible"Bad parameter to load_external")

      fun do_get_implicit (lexp,env,spills,calls) =
        (case lexp of
           AugLambda.INT offset =>
             let
               val result = MirTypes.GC.new()
             in
               (Mir_Utils.ONE (Mir_Utils.INT (MirTypes.GP_GC_REG result)),
                ((Sexpr.ATOM
                  [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG result,
                                    MirTypes.GC_REG MirRegisters.implicit,
                                    MirTypes.GP_IMM_ANY (4 * offset))],
                [],NONE, Sexpr.NIL),[],[]),
               env,spills,calls)
             end
         | _ => Crash.impossible "Bad parameter to get_implicit")

      fun get_int_pair regs =
        case regs of
          Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)) =>
	    Mir_Utils.destruct_2_tuple reg
        | Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] =>
	    (reg1, reg2, [])
        | _ => Crash.impossible "get_int_pair"

      fun get_real_pair regs =
        case regs of
          Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)) =>
            let
              val (reg1, reg2, des_code) = Mir_Utils.destruct_2_tuple reg
              val (fp1, code1) = Mir_Utils.get_real (Mir_Utils.INT reg1)
              val (fp2, code2) = Mir_Utils.get_real (Mir_Utils.INT reg2)
            in
              (fp1, fp2, des_code @@ code1 @@ code2)
            end
        | Mir_Utils.LIST[reg1, reg2] =>
            let
              val (fp1, code1) = Mir_Utils.get_real reg1
              val (fp2, code2) = Mir_Utils.get_real reg2
            in
              (fp1, fp2, code1 @@ code2)
            end
        | _ => Crash.impossible"get_real_pair"

      (* Word32 (and Int32) values are stored as four-byte strings. *)
      fun get_word32_pair regs =
        case regs of
          Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)) =>
            let
              val (reg1, reg2, des_code) = Mir_Utils.destruct_2_tuple reg
              val (w1, code1, clean1) =
		Mir_Utils.get_word32 (Mir_Utils.INT reg1)
              val (w2, code2, clean2) =
		Mir_Utils.get_word32 (Mir_Utils.INT reg2)
            in
              (w1, w2, des_code @@ code1 @@ code2, clean1 @@ clean2)
            end
        | Mir_Utils.LIST[reg1, reg2] =>
            let
              val (w1, code1, clean1) = Mir_Utils.get_word32 reg1
              val (w2, code2, clean2) = Mir_Utils.get_word32 reg2
            in
              (w1, w2, code1 @@ code2, clean1 @@ clean2)
            end
        | _ => Crash.impossible"get_word32_pair"

      fun getint (Mir_Utils.INT x) = x
        | getint _ = Crash.impossible "getint"

      (* Word32 (and Int32) values are stored as four-byte strings. *)
      fun get_word32_and_word regs =
        case regs of
          Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)) =>
            let
              val (reg1, reg2, des_code) = Mir_Utils.destruct_2_tuple reg
              val (w1, code1, clean1) =
		Mir_Utils.get_word32 (Mir_Utils.INT reg1)
            in
              (w1, reg2, des_code @@ code1, clean1)
            end
        | Mir_Utils.LIST[reg1, reg2] =>
            let
              val (w1, code1, clean1) = Mir_Utils.get_word32 reg1
            in
              (w1, getint reg2, code1, clean1)
            end
        | _ => Crash.impossible"get_word32_pair"

      fun unary_negate(opcode,regs,the_code,exn_code) =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val (exn_blocks, exn_tag_list) = exn_code
	in
	  case regs of
	    Mir_Utils.ONE(Mir_Utils.INT reg) =>
	      (Mir_Utils.ONE(Mir_Utils.INT res1),
	       Mir_Utils.combine(the_code,
                                 ((Sexpr.ATOM[(MirTypes.TBINARY(opcode, exn_tag_list, res2,
                                                                MirTypes.GP_IMM_INT 0, reg))], exn_blocks,
                                   NONE, Sexpr.NIL), [], [])))
	  | _ => Crash.impossible"unary_negate"
	end

      (* This doesn't work if an exception is raised, because it the
	 exception is handled by a trap, and the argument register isn't
	 cleaned. See also int32_binary_calc and do_int32abs. *)

      fun int32_unary_negate (opcode, Mir_Utils.ONE(Mir_Utils.INT reg), the_code, exn_code) =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val (exn_blocks, exn_tag_list) = exn_code

          val (w, arg_code, clean_arg) =
	    Mir_Utils.get_word32 (Mir_Utils.INT reg)

	  val new_code =
	    arg_code @@
	    [MirTypes.TBINARY
	       (opcode, exn_tag_list, res2, MirTypes.GP_IMM_INT 0, w)] @@ clean_arg
	  val (final_res, final_code) = Mir_Utils.save_word32 result
	  val clean_res = [MirTypes.NULLARY(MirTypes.CLEAN, res2)]
	in
	  (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG final_res)),
	   Mir_Utils.combine
	     (the_code,
              ((Sexpr.ATOM(new_code @@ final_code @@ clean_res), exn_blocks,
		NONE, Sexpr.NIL),
	       [], [])))
	end
	| int32_unary_negate _ = Crash.impossible "int32_unary_negate"

      fun tagged_binary_fcalc(opcode,regs,the_code,exn_code) =
	let
	  val result = MirTypes.FP_REG(MirTypes.FP.new())
	  val (val1,val2, new_code) = get_real_pair regs
	  val (exn_blocks, exn_tag_list) = exn_code
	in
          (Mir_Utils.ONE(Mir_Utils.REAL result),
           Mir_Utils.combine(the_code,
                              ((Sexpr.ATOM(new_code @@
                                           [(MirTypes.TBINARYFP(opcode, exn_tag_list, result,
                                                                val1, val2))]),
                              exn_blocks, NONE, Sexpr.NIL), [], [])))
	end

      fun unary_fcalc (opcode,regs,the_code) =
	let
	  val result = MirTypes.FP_REG(MirTypes.FP.new())
	in
	  (Mir_Utils.ONE(Mir_Utils.REAL result),
	    Mir_Utils.combine(the_code,
                              (((case regs of
                                   Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG reg)) =>
                                     Sexpr.ATOM[MirTypes.STOREFPOP(MirTypes.FLD, result,
                                                                   MirTypes.GC_REG reg,
                                                                   MirTypes.GP_IMM_ANY real_offset),
                                     MirTypes.UNARYFP(opcode, result, result)]
                                 | Mir_Utils.ONE(Mir_Utils.REAL reg) =>
                                     Sexpr.ATOM[MirTypes.UNARYFP(opcode, result, reg)]
                                 | _ => Crash.impossible"unary_fcalc"),
                                   [], NONE, Sexpr.NIL), [], [])))
	end

      fun tagged_unary_fcalc (opcode,regs,the_code,exn_code) =
	let
	  val result = MirTypes.FP_REG(MirTypes.FP.new())
	  val (exn_blocks, exn_tag_list) = exn_code
	in
	  (Mir_Utils.ONE(Mir_Utils.REAL result),
	    Mir_Utils.combine(the_code,
	      (((case regs of
		Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG reg)) =>
		  Sexpr.ATOM[MirTypes.STOREFPOP(MirTypes.FLD, result,
				      MirTypes.GC_REG reg,
				      MirTypes.GP_IMM_ANY real_offset),
		    MirTypes.TUNARYFP(opcode, exn_tag_list, result, result)]
		| Mir_Utils.ONE(Mir_Utils.REAL reg) =>
		    Sexpr.ATOM[MirTypes.TUNARYFP(opcode, exn_tag_list, result, reg)]
		| _ => Crash.impossible"tagged_unary_fcalc"),
		  exn_blocks, NONE, Sexpr.NIL), [], [])))
	end

      fun make_test (test_instr,res_reg,finish_tag) =
        [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
                        MirTypes.GP_IMM_INT 1),
         test_instr,
         MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
                        MirTypes.GP_IMM_INT 0),
         MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]

      fun test (opcode,regs,the_code) =
	let
	  val res_reg = MirTypes.GC.new()
	  val finish_tag = MirTypes.new_tag()
          val (val1, val2, new_code) = get_int_pair regs
        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG res_reg)),
           Mir_Utils.combine(the_code,
                             ((Sexpr.ATOM(new_code @@
                                          make_test (MirTypes.TEST(opcode, finish_tag, val1, val2),
                                                     res_reg,
                                                     finish_tag)),
			       [], SOME finish_tag,
			       Sexpr.ATOM[MirTypes.COMMENT"Code following test"]), [], [])))
        end

      fun test32 (opcode,regs,the_code) =
	let
	  val res = MirTypes.GC.new()
	  val res2 = MirTypes.GC_REG res
	  val finish_tag = MirTypes.new_tag()

          val (val1, val2, arg_code, clean_arg_code) = get_word32_pair regs

	  val new_code =
	    arg_code
	    @@ make_test
		(MirTypes.TEST (opcode, finish_tag, val1, val2),
		 res, finish_tag)
        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG res)),
           Mir_Utils.combine
	     (the_code,
              ((Sexpr.ATOM new_code, [], SOME finish_tag,
		Sexpr.ATOM clean_arg_code),
	       [], [])))
        end

      (* These functions are used in switches on relational expressions *)
      fun imake_if (opcode,regs,the_code,true_tag,false_tag) =
        let
          val (val1, val2, new_code) = get_int_pair regs
        in
          Mir_Utils.combine(the_code,
                             ((Sexpr.ATOM(new_code @@
                                          [MirTypes.TEST(opcode, true_tag, val1, val2),
                                           MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG false_tag)]),
                               [], NONE, Sexpr.NIL), [], []))
        end

      fun fmake_if (opcode,sense,regs,the_code,true_tag,false_tag) =
        let
          val (val1, val2, new_code) = get_real_pair regs
          val (val1, val2) = if sense then (val1, val2) else (val2, val1)
        in
          Mir_Utils.combine(the_code,
                             ((Sexpr.ATOM(new_code @@
                                          [MirTypes.FTEST(opcode, true_tag, val1, val2),
                                           MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG false_tag)]),
                               [], NONE, Sexpr.NIL), [], []))
        end

      fun make_if (test, regs, code, true_tag, false_tag) =
	case test
	of Pervasives.INTLESS =>
	  imake_if (MirTypes.BLT, regs, code, true_tag, false_tag)
	|  Pervasives.CHARLT =>
	  imake_if (MirTypes.BLT, regs, code, true_tag, false_tag)
	|  Pervasives.WORDLT =>
	  imake_if (MirTypes.BLO, regs, code, true_tag, false_tag)
	|  Pervasives.REALLESS =>
          fmake_if (MirTypes.FBLT,true, regs, code, true_tag, false_tag)
        |  Pervasives.INTGREATER =>
	  imake_if (MirTypes.BGT, regs, code, true_tag, false_tag)
        |  Pervasives.CHARGT =>
	  imake_if (MirTypes.BGT, regs, code, true_tag, false_tag)
        |  Pervasives.WORDGT =>
	  imake_if (MirTypes.BHI, regs, code, true_tag, false_tag)
        |  Pervasives.REALGREATER =>
	  fmake_if (MirTypes.FBLT,false, regs, code, true_tag, false_tag)
        |  Pervasives.INTLESSEQ =>
	  imake_if (MirTypes.BLE, regs, code, true_tag, false_tag)
        |  Pervasives.CHARLE =>
	  imake_if (MirTypes.BLE, regs, code, true_tag, false_tag)
        |  Pervasives.WORDLE =>
	  imake_if (MirTypes.BLS, regs, code, true_tag, false_tag)
        |  Pervasives.REALLESSEQ =>
	  fmake_if (MirTypes.FBLE, true, regs, code, true_tag, false_tag)
        |  Pervasives.INTGREATEREQ =>
	  imake_if (MirTypes.BGE, regs, code, true_tag, false_tag)
        |  Pervasives.CHARGE =>
	  imake_if (MirTypes.BGE, regs, code, true_tag, false_tag)
        |  Pervasives.WORDGE =>
	  imake_if (MirTypes.BHS, regs, code, true_tag, false_tag)
        |  Pervasives.REALGREATEREQ =>
	  fmake_if (MirTypes.FBLE, false, regs, code, true_tag, false_tag)
        |  Pervasives.INTEQ =>
	  imake_if (MirTypes.BEQ, regs, code, true_tag, false_tag)
        |  Pervasives.INTNE =>
	  imake_if (MirTypes.BNE, regs, code, true_tag, false_tag)
        |  Pervasives.CHAREQ =>
	  imake_if (MirTypes.BEQ, regs, code, true_tag, false_tag)
        |  Pervasives.CHARNE =>
	  imake_if (MirTypes.BNE, regs, code, true_tag, false_tag)
        |  Pervasives.WORDEQ =>
	  imake_if (MirTypes.BEQ, regs, code, true_tag, false_tag)
        |  Pervasives.WORDNE =>
	  imake_if (MirTypes.BNE, regs, code, true_tag, false_tag)
        |  Pervasives.REALEQ =>
	  fmake_if (MirTypes.FBEQ, true, regs, code, true_tag, false_tag)
        |  Pervasives.REALNE =>
	  fmake_if (MirTypes.FBNE, true, regs, code, true_tag, false_tag)
        |  _ => Crash.impossible "bad relational operator"

      fun ftest(opcode,sense,regs,the_code) =
	let
	  val res_reg = MirTypes.GC.new()
	  val finish_tag = MirTypes.new_tag()
	in
	  let
	    val (val1, val2, new_code) = get_real_pair regs
	    val (val1, val2) = if sense then (val1, val2) else (val2, val1)
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG res_reg)),
	      Mir_Utils.combine
              (the_code,
               ((Sexpr.ATOM(new_code @@
                            make_test (MirTypes.FTEST(opcode, finish_tag, val1, val2),
                                       res_reg,finish_tag)),
                 [], SOME finish_tag,
		 Sexpr.ATOM[MirTypes.COMMENT"End of float test"]), [], [])))
	  end
	end

      fun do_external_prim prim =
	Crash.impossible"do_external_prim"

      fun make_size_code regs =
	let
	  val new_reg = case regs of
	    Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG reg)) => MirTypes.GC_REG reg
	  | _ => Crash.impossible"Bad string pointer"
	  val res_reg = MirTypes.GC.new()
	in
	  (new_reg, MirTypes.GP_GC_REG res_reg,
	    [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG res_reg, new_reg,
			      MirTypes.GP_IMM_ANY ~5),
	     (* Reference size from header at offset -5 *)
	     MirTypes.BINARY(MirTypes.LSR, MirTypes.GC_REG res_reg,
			     MirTypes.GP_GC_REG res_reg,
			     MirTypes.GP_IMM_ANY 6),
	     MirTypes.COMMENT"Divide by 64",
	     MirTypes.BINARY(MirTypes.SUBU, MirTypes.GC_REG res_reg,
			     MirTypes.GP_GC_REG res_reg,
			     MirTypes.GP_IMM_ANY 1),
	     MirTypes.COMMENT"Remove one for 0 terminator",
	     MirTypes.BINARY(MirTypes.ASL, MirTypes.GC_REG res_reg,
			     MirTypes.GP_GC_REG res_reg,
			     MirTypes.GP_IMM_ANY 2),
	     MirTypes.COMMENT"And tag"])
	end

      fun tagged_binary_calc(opcode,regs,the_code,exn_code) =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val (val1, val2, new_code) = get_int_pair regs
	  val (exn_blocks, exn_tag_list) = exn_code
	in
	  (Mir_Utils.ONE(Mir_Utils.INT res1),
           Mir_Utils.combine (the_code,
                              ((Sexpr.ATOM(new_code @@
                                           [(MirTypes.TBINARY(opcode,
                                                              exn_tag_list, res2, val1, val2))]),
                                exn_blocks, NONE, Sexpr.NIL), [], [])))
	end

      fun tagged_binary_calc(opcode,regs,the_code,exn_code) =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val (val1, val2, new_code) = get_int_pair regs
	  val (exn_blocks, exn_tag_list) = exn_code
	in
	  (Mir_Utils.ONE(Mir_Utils.INT res1),
           Mir_Utils.combine (the_code,
                              ((Sexpr.ATOM(new_code @@
                                           [(MirTypes.TBINARY(opcode,
                                                              exn_tag_list, res2, val1, val2))]),
                                exn_blocks, NONE, Sexpr.NIL), [], [])))
	end

      (* NB This doesn't work.  The exceptions are handled by traps, so
	 the argument registers are never cleaned if an exception occurs. *)
      fun tagged32_binary_calc (opcode, regs, the_code, exn_code) =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val tmp = MirTypes.GC.new()
	  val tmp2 = MirTypes.GC_REG tmp

	  val (val1, val2, arg_code, clean_arg_code) = get_word32_pair regs
	  val (exn_blocks, exn_tag_list) = exn_code

	  val new_code =
	    (* Do the allocation first - we are using unsafe values *)
	    MirTypes.ALLOCATE
	      (MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT 4)
	    :: arg_code
	    @@ [MirTypes.TBINARY(opcode, exn_tag_list, tmp2, val1, val2),
	       MirTypes.STOREOP
		 (MirTypes.ST, tmp2, res2, MirTypes.GP_IMM_ANY ~1),
	       MirTypes.NULLARY(MirTypes.CLEAN, tmp2)]
	    @@ clean_arg_code
	in
	  (Mir_Utils.ONE(Mir_Utils.INT res1),
	   Mir_Utils.combine
	     (the_code,
	      ((Sexpr.ATOM new_code, exn_blocks, NONE, Sexpr.NIL),
	       [], [])))
	end

      fun binary_calc (opcode,regs,the_code) =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val (val1, val2, new_code) = get_int_pair regs
	in
	  (Mir_Utils.ONE(Mir_Utils.INT res1), Mir_Utils.combine
	   (the_code,
	    ((Sexpr.ATOM(new_code @@
	     [(MirTypes.BINARY(opcode, res2, val1, val2))]),
	      [], NONE, Sexpr.NIL), [], [])))
	end

      fun untagged32_binary_calc (opcode,regs,the_code) =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val tmp = MirTypes.GC.new()
	  val tmp2 = MirTypes.GC_REG tmp

	  val (val1, val2, arg_code, clean_arg_code) = get_word32_pair regs

	  val new_code =
	    (* Do the allocation first - we are using unsafe values *)
	    MirTypes.ALLOCATE
	      (MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT 4)
	    :: arg_code
	    @@ [MirTypes.BINARY(opcode, tmp2, val1, val2),
	       MirTypes.STOREOP
		 (MirTypes.ST, tmp2, res2, MirTypes.GP_IMM_ANY ~1),
	       MirTypes.NULLARY(MirTypes.CLEAN, tmp2)]
	    @@ clean_arg_code
	in
	  (Mir_Utils.ONE(Mir_Utils.INT res1),
	   Mir_Utils.combine
	     (the_code,
	      ((Sexpr.ATOM new_code, [], NONE, Sexpr.NIL), [], [])))
	end

      fun do_shift_operator(mir_operator,need_to_clear_bottom_two_bits,regs,the_code) =
	let
	  val _ =
	    if need_to_clear_bottom_two_bits then
	      if mir_operator = MirTypes.ASR orelse
		mir_operator = MirTypes.LSR then
		()
	      else
		Crash.impossible("mir_cg:do_shift_operator:bad shift and clear combination with " ^ MirPrint.binary_op mir_operator)
	    else
	      ()
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val spare = MirTypes.GC.new()
	  val spare1 = MirTypes.GP_GC_REG spare
	  val spare2 = MirTypes.GC_REG spare
	  val (val1, val2, new_code) = get_int_pair regs
	  val shift_code =
            case val2 of
              MirTypes.GP_IMM_INT i =>
		(* Optimise the shift by constant case *)
		(* Also check for shifts by more than word size here *)
		let
		  val (shift_limit, replace_by_zero) = case mir_operator of
		    MirTypes.ASR => (MachSpec.bits_per_word-1, false)
		  | _ => (MachSpec.bits_per_word, true)
		  val i = if i > shift_limit then shift_limit else i
		in
		  if i >= shift_limit andalso replace_by_zero then
		    [MirTypes.UNARY(MirTypes.MOVE, res2, MirTypes.GP_IMM_INT 0)]
		  else
		    if need_to_clear_bottom_two_bits then
		      (* Must be the shift right case, *)
		      (* so go two further then shift back *)
		      [MirTypes.BINARY(mir_operator, res2, val1,
				       MirTypes.GP_IMM_ANY(i+2)),
		       MirTypes.BINARY(MirTypes.ASL, res2, res1,
				       MirTypes.GP_IMM_ANY 2)]
		    else
		      [MirTypes.BINARY(mir_operator, res2, val1,
				       MirTypes.GP_IMM_ANY i)]
		end
            | _ =>
		let
		  val clean_code =
		    [MirTypes.NULLARY(MirTypes.CLEAN, spare2)]
		  val clear_code =
		    if need_to_clear_bottom_two_bits then
		      MirTypes.UNARY(MirTypes.INTTAG, res2, res1) :: clean_code
		    else
		      clean_code
		in
		  MirTypes.BINARY(MirTypes.LSR, spare2,
				  val2, MirTypes.GP_IMM_ANY 2) ::
		  MirTypes.BINARY(mir_operator,MirTypes.GC_REG result,val1,
				  spare1) ::
		  clear_code
		end
	in
	  (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
	   Mir_Utils.combine(the_code,
			     ((Sexpr.CONS(Sexpr.ATOM new_code, Sexpr.ATOM shift_code),
			       [],NONE,Sexpr.NIL),[],[])))
	end

      fun full_machine_word_shift_operator(mir_operator, regs, the_code) =
	let
	  val result = MirTypes.GC.new()
	  val res2 = MirTypes.GC_REG result
	  val tmp = MirTypes.GC.new()
	  val tmp2 = MirTypes.GC_REG tmp
          val spare = MirTypes.GC.new()
	  val spare1 = MirTypes.GP_GC_REG spare
          val spare2 = MirTypes.GC_REG spare

	  val (val1, val2, arg_code, clean_arg_code) = get_word32_and_word regs

	  val alloc_code = MirTypes.ALLOCATE
	    (MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT 4)
	  val imm_val = case val2 of
	    MirTypes.GP_IMM_INT i => SOME i
	  | MirTypes.GP_IMM_ANY w => SOME w (* immediate word32s can come out like this *)
	  | _ => NONE
	  val new_code =
            case imm_val of
              SOME i =>
		let
		  val (shift_limit, replace_by_zero) = case mir_operator of
		    MirTypes.ASR => (MachSpec.bits_per_word+1, false)
		  | _ => (MachSpec.bits_per_word+2, true)
		  val i = if i > shift_limit then shift_limit else i
		  val shift_operation =
		    if i >= shift_limit andalso replace_by_zero then
		      MirTypes.UNARY(MirTypes.MOVE, tmp2, MirTypes.GP_IMM_INT 0)
		    else
		      MirTypes.BINARY(mir_operator, tmp2, val1, MirTypes.GP_IMM_ANY i)
		in
		  alloc_code ::
		  (arg_code @@
		   (shift_operation ::
		    MirTypes.STOREOP
		    (MirTypes.ST, tmp2, res2, MirTypes.GP_IMM_ANY ~1) ::
		    MirTypes.NULLARY(MirTypes.CLEAN, tmp2) ::
		    clean_arg_code))
		end
            | _ =>
		alloc_code ::
                (arg_code @@
		 (MirTypes.BINARY(MirTypes.LSR, spare2,val2, MirTypes.GP_IMM_ANY 2) ::
		  MirTypes.BINARY(mir_operator, tmp2, val1, spare1) ::
		  MirTypes.STOREOP(MirTypes.ST, tmp2, res2, MirTypes.GP_IMM_ANY ~1) ::
		  MirTypes.NULLARY(MirTypes.CLEAN, tmp2) ::
		  MirTypes.NULLARY(MirTypes.CLEAN, spare2) ::
		  clean_arg_code))
	in
	  (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
	   Mir_Utils.combine
	     (the_code,
	      ((Sexpr.ATOM new_code, [],NONE,Sexpr.NIL),
	       [],[])))
	end


      fun array_code (bytearray,regs,the_code,exn_code) =
        let
          val (constantp, constant_value) =
            (case regs
               of Mir_Utils.LIST[Mir_Utils.INT(size), initial] =>
                 (case size
                    of MirTypes.GP_IMM_INT v => (true,v )
                     | _ => (false,0))
                | _ => (false,0))


          val ((new_reg, code),(new_reg', code')) =
            case regs of
              Mir_Utils.LIST[ Mir_Utils.INT(size), initial] =>
                 (Mir_Utils.send_to_new_reg(Mir_Utils.ONE(initial)),
                  Mir_Utils.send_to_new_reg(Mir_Utils.ONE(Mir_Utils.INT size)))
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                (let
                  val new_reg = MirTypes.GC.new()
                  val new_reg' = MirTypes.GC.new()
                in
                  ((MirTypes.GP_GC_REG new_reg,[MirTypes.STOREOP(MirTypes.LD,
                                    MirTypes.GC_REG new_reg,
                                    Mir_Utils.reg_from_gp reg,
                                    MirTypes.GP_IMM_ANY 3)]),
                  (MirTypes.GP_GC_REG new_reg',[MirTypes.STOREOP(MirTypes.LD,
                                              MirTypes.GC_REG new_reg',
                                              Mir_Utils.reg_from_gp reg,
                                              MirTypes.GP_IMM_ANY ~1)]))
                  end)
            | _ => Crash.impossible "_mir_cg : array_fn can't code generate arguments "

          val result = MirTypes.GC.new()
          val res1 = MirTypes.GC_REG result
          val work1 = MirTypes.GC_REG(MirTypes.GC.new())
          val work2 = MirTypes.GC_REG(MirTypes.GC.new())
          val temp_reg = MirTypes.GC.new()
	  val temp = MirTypes.GC_REG temp_reg
	  val temp_gp = MirTypes.GP_GC_REG temp_reg
          val count =  MirTypes.GC.new()
          val main_tag = MirTypes.new_tag()
          val loop_tag = MirTypes.new_tag()
          val finish_tag = MirTypes.new_tag()
	  val (exn_blocks, exn_tag_list) = exn_code
	  val exn_tag =
	    case exn_tag_list of
              [tag] => tag
	    |  _ => Crash.impossible "bad exn_tag for Bytearray.array"
          val after_alignment = MirTypes.new_tag()
        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
           Mir_Utils.combine
           (the_code,
            ((Sexpr.ATOM
              (code @@ code' @@
               (if constantp then
                  (if constant_value >= 0 then
                     [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG main_tag)]
                   else
                     [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)])
                else
                  [MirTypes.TEST(MirTypes.BGE, main_tag, new_reg', MirTypes.GP_IMM_INT 0),
                   MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)])),

              (* begin main block: allocate memory *)
              MirTypes.BLOCK(main_tag,
               (if constantp then
                  [MirTypes.UNARY(MirTypes.MOVE,
                                  Mir_Utils.reg_from_gp new_reg',
                                  MirTypes.GP_IMM_INT constant_value)]
                else []) @@
               (if bytearray then
                  [MirTypes.COMMENT"ByteArray creation operation",
                   MirTypes.ALLOCATE(MirTypes.ALLOC_BYTEARRAY, res1,
                                     if constantp then
                                       MirTypes.GP_IMM_INT constant_value
                                     else new_reg')]
                else
                   [MirTypes.COMMENT"Array creation operation",
                    MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1,
                                      (if constantp then
                                         MirTypes.GP_IMM_INT constant_value
                                       else new_reg'))]
                )@@
               [MirTypes.COMMENT"Initialise all of the values"] @@
               (if constantp then
                  [MirTypes.UNARY(MirTypes.MOVE,
                                  MirTypes.GC_REG count,
                                  MirTypes.GP_IMM_INT constant_value)]
                else
                  [MirTypes.UNARY(MirTypes.MOVE,
                                  MirTypes.GC_REG count,
                                  new_reg')]
               ) @@
	       (if bytearray then (* remove integer tags (least 2 bits) *)
		    [MirTypes.BINARY(MirTypes.LSR,
		   	      Mir_Utils.reg_from_gp new_reg,
			      new_reg,
			      MirTypes.GP_IMM_ANY 2)]
		else []) @@
               [MirTypes.UNARY(MirTypes.MOVE,
                               temp,
                               MirTypes.GP_GC_REG result),
                MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)])

              (* end main block *)
              ::
              (* begin loop block: initializing values *)
              (if bytearray then
                 MirTypes.BLOCK
                   (loop_tag,
                    [MirTypes.STOREOP(MirTypes.STB,
			 	      Mir_Utils.reg_from_gp new_reg,
                                      temp,
                                      MirTypes.GP_IMM_ANY 1),
                     MirTypes.BINARY(MirTypes.ADDU,
                                     temp,
                                     temp_gp,
                                     MirTypes.GP_IMM_ANY 1),
                     MirTypes.BINARY(MirTypes.ADDU,
                                     MirTypes.GC_REG count,
                                     MirTypes.GP_GC_REG count,
                                     MirTypes.GP_IMM_INT ~1),
                     MirTypes.TEST(MirTypes.BGT,
                                   loop_tag,
                                   MirTypes.GP_GC_REG count,
                                   MirTypes.GP_IMM_ANY 0),
		     MirTypes.NULLARY(MirTypes.CLEAN,
				      Mir_Utils.reg_from_gp new_reg),
		     MirTypes.NULLARY(MirTypes.CLEAN, temp),
                     MirTypes.BRANCH(MirTypes.BRA,
                                     MirTypes.TAG finish_tag)])
               else
                 MirTypes.BLOCK
                   (loop_tag,
                    [MirTypes.STOREOP(MirTypes.STREF,
                                      Mir_Utils.reg_from_gp new_reg,
                                      temp,
                                      MirTypes.GP_IMM_ANY 9),
                     MirTypes.BINARY(MirTypes.ADDU,
                                     temp,
                                     temp_gp,
                                     MirTypes.GP_IMM_ANY 4),
                     MirTypes.BINARY(MirTypes.ADDU,
                                     MirTypes.GC_REG count,
                                     MirTypes.GP_GC_REG count,
                                     MirTypes.GP_IMM_INT ~1),
                     MirTypes.TEST(MirTypes.BGT,
                                   loop_tag,
                                   MirTypes.GP_GC_REG count,
                                   MirTypes.GP_IMM_ANY 0),
		     MirTypes.NULLARY(MirTypes.CLEAN, temp),
                     MirTypes.BRANCH(MirTypes.BRA,
                                     MirTypes.TAG finish_tag)]))
              (* end of loop block *)
              ::
              exn_blocks,
              SOME finish_tag,
              if bytearray then
                Sexpr.ATOM[MirTypes.COMMENT"End bytearray code"]
              else
                Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE,
                                          work1,
                                          MirTypes.GP_IMM_ANY 0),
                           MirTypes.STOREOP(MirTypes.STREF,
                                            work1,
                                            res1,
                                            MirTypes.GP_IMM_ANY 5),
                           MirTypes.UNARY(MirTypes.MOVE,
                                          work2,
                                          MirTypes.GP_IMM_INT 1),
                           MirTypes.STOREOP(MirTypes.STREF,
                                            work2,
                                            res1,
                                            MirTypes.GP_IMM_ANY 1)]),
            [], [])))
        end




      (* have a special treatment for float arrays: essentially to
         avoid boxing and then unboxing fp values.
         See <URI:MLW/design/floatarray.doc> for details.*)


      fun floatarray_code (regs,the_code,exn_code) =
        let
          val (constantp, constant_value) =
            (case regs
               of Mir_Utils.LIST[Mir_Utils.INT(size), initial] =>
                 (case size
                    of MirTypes.GP_IMM_INT v => (true,v )
                     | _ => (false,0))
                | _ => (false,0))

          val ((float_reg,code),(new_reg', code')) =
            case regs of
              Mir_Utils.LIST[Mir_Utils.INT(size),
                             Mir_Utils.REAL reg] =>
                ((reg,[]),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE(Mir_Utils.INT size)))
            | Mir_Utils.LIST[Mir_Utils.INT(size),
                             Mir_Utils.INT(MirTypes.GP_GC_REG reg)] =>
                let val float_reg = MirTypes.FP_REG(MirTypes.FP.new())
                in
                 ((float_reg,
                  [MirTypes.STOREFPOP(MirTypes.FLD,
                                      float_reg,
                                      MirTypes.GC_REG reg,
                                      MirTypes.GP_IMM_ANY real_offset)]),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE(Mir_Utils.INT size)))
                end
            | Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG reg)) =>
                (let
                  val float_reg = MirTypes.FP.new()
                  val new_reg' = MirTypes.GC.new()
                in
                   (* note --- does double word alignment affect us here?
                      (yes on a SPARC v9) *)
                  ((MirTypes.FP_REG float_reg,
                    [MirTypes.STOREFPOP(MirTypes.FLD,
                                        MirTypes.FP_REG float_reg,
                                        MirTypes.GC_REG reg,
                                        MirTypes.GP_IMM_ANY 3)]),
                  (MirTypes.GP_GC_REG new_reg',
                   [MirTypes.STOREOP(MirTypes.LD,
                                     MirTypes.GC_REG new_reg',
                                     MirTypes.GC_REG reg,
                                     MirTypes.GP_IMM_ANY ~1)]))
                  end)
            | _ => Crash.impossible "_mir_cg : floatarray can't code generate arguments "

          val result = MirTypes.GC.new()
          val res1 = MirTypes.GC_REG result
          val work1 = MirTypes.GC_REG(MirTypes.GC.new())
          val work2 = MirTypes.GC_REG(MirTypes.GC.new())
          val temp_reg = MirTypes.GC.new()
	  val temp = MirTypes.GC_REG temp_reg
	  val temp_gp = MirTypes.GP_GC_REG temp_reg
          val count =  MirTypes.GC.new()
          val main_tag = MirTypes.new_tag()
          val loop_tag = MirTypes.new_tag()
          val finish_tag = MirTypes.new_tag()
	  val (exn_blocks, exn_tag_list) = exn_code
	  val exn_tag =
	    case exn_tag_list of
              [tag] => tag
	    |  _ => Crash.impossible "bad exn_tag for FloatArray.array"
          val after_alignment = MirTypes.new_tag()
        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
           Mir_Utils.combine
           (the_code,
            ((Sexpr.ATOM
              (code @@ code' @@
               (if constantp then
                  (if constant_value >= 0 then
                     [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG main_tag)]
                   else
                     [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)])
                else
                  [MirTypes.TEST(MirTypes.BGE, main_tag, new_reg', MirTypes.GP_IMM_INT 0),
                   MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)])),

              (* begin main block: allocate memory *)
              MirTypes.BLOCK(main_tag,
               (if constantp then
                  [MirTypes.UNARY(MirTypes.MOVE,
                                  Mir_Utils.reg_from_gp new_reg',
                                  MirTypes.GP_IMM_INT constant_value)]
                else []) @@
                [MirTypes.COMMENT"FloatArray creation operation"] @@
                (if constantp then []
                        (* convert number of floats into number of bytes
                           --- i.e., multiply by 8, or shift left by 3
                           and add 4 (a blank word inserted after header
                             word to regain double-word alignment) *)
                 else [MirTypes.BINARY(MirTypes.ASL,
                                       temp,
                                       new_reg',
                                       MirTypes.GP_IMM_ANY 3),
                       MirTypes.BINARY(MirTypes.ADDU,
                                       temp,
                                       temp_gp,
                                       MirTypes.GP_IMM_ANY 4)]) @@
                 [MirTypes.ALLOCATE(MirTypes.ALLOC_BYTEARRAY, res1,
                                    if constantp then
                                        MirTypes.GP_IMM_INT(constant_value*8+4)
                                    else temp_gp)]
                @@
               [MirTypes.COMMENT"Initialise all of the values"] @@
               (if constantp then
                  [MirTypes.UNARY(MirTypes.MOVE,
                                  MirTypes.GC_REG count,
                                  MirTypes.GP_IMM_INT constant_value)]
                else
                  [MirTypes.UNARY(MirTypes.MOVE,
                                  MirTypes.GC_REG count,
                                  new_reg')]
               ) @@
               [MirTypes.UNARY(MirTypes.MOVE,
                               temp,
                               MirTypes.GP_GC_REG result),
                MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)])

              (* end main block *)
              ::
              (* begin loop block: initializing values *)
              (MirTypes.BLOCK
                 (loop_tag,
                  (* temp is ptr to bytearray.  1st word is header,
                     2nd is a dummy to maintain double-word alignment.
                     Since ptr tag is 3, we add 5 to pt to the 8th
                     byte in the array.  This is addr of 1st float. *)
                  [MirTypes.STOREFPOP(MirTypes.FST,
                                      float_reg,
                                      temp,
                                      MirTypes.GP_IMM_ANY 5),
                   MirTypes.BINARY(MirTypes.ADDU,
                                   temp,
                                   temp_gp,
                                   MirTypes.GP_IMM_ANY 8),
                   MirTypes.BINARY(MirTypes.ADDU,
                                   MirTypes.GC_REG count,
                                   MirTypes.GP_GC_REG count,
                                   MirTypes.GP_IMM_INT ~1),
                   MirTypes.TEST(MirTypes.BGT,
                                 loop_tag,
                                 MirTypes.GP_GC_REG count,
                                 MirTypes.GP_IMM_ANY 0),
		   MirTypes.NULLARY(MirTypes.CLEAN, temp),
                   MirTypes.BRANCH(MirTypes.BRA,
                                   MirTypes.TAG finish_tag)]))
              (* end of loop block *)
              ::
              exn_blocks,
              SOME finish_tag,
	      Sexpr.ATOM[MirTypes.COMMENT"End of float_array code"]),
            [], [])))
        end


      fun do_alloc_vector_code (regs,arg_code) =
        let
          val (constantp, constant_value) =
            (case regs of
               Mir_Utils.ONE (Mir_Utils.INT size) =>
                 (case size
                    of MirTypes.GP_IMM_INT v => (true,v )
                     | _ => (false,0))
             | _ => (false,0))

          val (size_reg, get_arg_code) =
            case regs of
              Mir_Utils.ONE(Mir_Utils.INT(reg)) => Mir_Utils.send_to_reg regs
            | _ => Crash.impossible "_mir_cg : args to alloc_vector_code "

          val result = MirTypes.GC.new()
          val result_gc = MirTypes.GC_REG result
          val temp_reg = MirTypes.GC.new()     (* temporary pointer into vector *)
	  val temp = MirTypes.GC_REG temp_reg
	  val temp_gp = MirTypes.GP_GC_REG temp_reg
          val value_reg = MirTypes.GC_REG (MirTypes.GC.new ())
          val count =  MirTypes.GC.new()       (* Count register for loop *)
          val loop_tag = MirTypes.new_tag()    (* Entry for while loop to fill with zero *)
          val finish_tag = MirTypes.new_tag()  (* Final block -- clean the temporary pointer reg *)
        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
           Mir_Utils.combine
           (arg_code,
            ((Sexpr.ATOM
              (get_arg_code @@
               [MirTypes.COMMENT "Vector creation",
                MirTypes.ALLOCATE(MirTypes.ALLOC_VECTOR, result_gc,
                                  (if constantp then
                                     MirTypes.GP_IMM_INT constant_value
                                   else
                                     size_reg))] @@
               [MirTypes.COMMENT"Initialise all of the values"] @@
               (if constantp then
                  [MirTypes.UNARY(MirTypes.MOVE,
                                  MirTypes.GC_REG count,
                                  MirTypes.GP_IMM_INT constant_value)]
                else
                  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG count, size_reg)]) @@
               [MirTypes.UNARY(MirTypes.MOVE,
                               temp,
                               MirTypes.GP_GC_REG result),
                MirTypes.UNARY(MirTypes.MOVE,
                               value_reg,
                               MirTypes.GP_IMM_ANY 0),
                MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)]),
            MirTypes.BLOCK(loop_tag,
                           [MirTypes.TEST(MirTypes.BLE, finish_tag, MirTypes.GP_GC_REG count,MirTypes.GP_IMM_ANY 0),
                            MirTypes.STOREOP(MirTypes.STREF, value_reg,
                                             temp,
                                             MirTypes.GP_IMM_ANY ~1),
                            MirTypes.BINARY(MirTypes.ADDU,
                                            temp,
                                            temp_gp,
                                            MirTypes.GP_IMM_ANY 4),
                            MirTypes.BINARY(MirTypes.ADDU,
                                            MirTypes.GC_REG count,
                                            MirTypes.GP_GC_REG count,
                                            MirTypes.GP_IMM_INT ~1),
                            MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)]) ::
            [],
            SOME finish_tag,
            Sexpr.ATOM [MirTypes.NULLARY(MirTypes.CLEAN, temp)]),
            [], [])))
        end




      fun do_alloc_pair_code (regs,arg_code) =
        let
          val result = MirTypes.GC.new()
          val result_gc = MirTypes.GC_REG result
          val value_reg = MirTypes.GC_REG (MirTypes.GC.new ())
        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
           Mir_Utils.combine
           (arg_code,
            ((Sexpr.ATOM
              ([MirTypes.COMMENT "Pair creation",
                MirTypes.ALLOCATE(MirTypes.ALLOC, result_gc,
                                  (MirTypes.GP_IMM_INT 2)),
                MirTypes.COMMENT"Initialise the values",
                MirTypes.UNARY(MirTypes.MOVE,
                               value_reg,
                               MirTypes.GP_IMM_ANY 0),
                MirTypes.STOREOP(MirTypes.STREF, value_reg,
                                 result_gc,
                                 MirTypes.GP_IMM_ANY ~1),
                MirTypes.STOREOP(MirTypes.STREF, value_reg,
                                 result_gc,
                                 MirTypes.GP_IMM_ANY 3)]),
              [],
              NONE,
              Sexpr.NIL),
           [], [])))
        end

      fun do_alloc_string_code (regs,arg_code) =
        let
          val (constantp, constant_value) =
            (case regs of
               Mir_Utils.ONE (Mir_Utils.INT size) =>
                 (case size
                    of MirTypes.GP_IMM_INT v => (true,v )
                     | _ => (false,0))
             | _ => (false,0))

          val (size_reg, get_arg_code) =
            case regs of
              Mir_Utils.ONE(Mir_Utils.INT(reg)) => Mir_Utils.send_to_reg regs
            | _ => Crash.impossible "_mir_cg : args to alloc_string_code "

          val result = MirTypes.GC.new()
          val result_gc = MirTypes.GC_REG result
        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
           Mir_Utils.combine
           (arg_code,
            ((Sexpr.ATOM
              (get_arg_code @@
               [MirTypes.COMMENT "String creation",
                MirTypes.ALLOCATE(MirTypes.ALLOC_STRING, result_gc,
                                  (if constantp then
                                     MirTypes.GP_IMM_INT (constant_value)
                                   else
                                     size_reg))]),
            [],
            NONE,
            Sexpr.NIL),
            [], [])))
        end

      fun length_code (bytearray,floatarray,regs,the_code) =
        (case regs of
           Mir_Utils.ONE(array) =>
             let
               val (new_reg, code) = Mir_Utils.send_to_reg regs
               val result = MirTypes.GC.new()
               val res1 = MirTypes.GC_REG result
             in
               (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
                Mir_Utils.combine
                (the_code,
                 ((Sexpr.ATOM
                   (code @@
                    [MirTypes.COMMENT ((if bytearray then "Byte" else
                                          if floatarray then "Float" else "")
                                       ^ "Array length operation"),
                     MirTypes.STOREOP(MirTypes.LDREF,res1,
                                      Mir_Utils.reg_from_gp new_reg,
                                      MirTypes.GP_IMM_ANY (~3)),
                         (* next remove 6 lowest header bits to get size.
                            if also floatarray, divide also by 8 (i.e.,
                              shift left 3 more) to convert num bytes into
                              num floats *)
                     MirTypes.BINARY(MirTypes.LSR,res1,
                                     MirTypes.GP_GC_REG result,
                                     MirTypes.GP_IMM_ANY
                                     (if floatarray then 9 else 6)),
                         (* next add two 0 bits for integer tag *)
                     MirTypes.BINARY(MirTypes.ASL,res1,
                                     MirTypes.GP_GC_REG result,
                                     MirTypes.GP_IMM_ANY 2)
                     ]),
                   [], NONE, Sexpr.NIL), [], [])))
             end
         | _ =>
             Crash.impossible "Array.length not called with one argument")



      fun vector_length_code (regs,the_code) =
        (case regs of
           Mir_Utils.ONE vector =>
             let
               val (new_reg, code) = Mir_Utils.send_to_reg regs
               val result = MirTypes.GC.new()
               val res1 = MirTypes.GC_REG result
             in
               (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
                Mir_Utils.combine
                (the_code,
                 ((Sexpr.ATOM
                   (code @@
                    [MirTypes.COMMENT"Vector length operation",
                     MirTypes.STOREOP(MirTypes.LDREF, res1, Mir_Utils.reg_from_gp new_reg,
                                      MirTypes.GP_IMM_ANY(~5)),
                     MirTypes.BINARY(MirTypes.LSR, res1,
                                     MirTypes.GP_GC_REG result, MirTypes.GP_IMM_ANY 6),
                     MirTypes.BINARY(MirTypes.ASL,res1,
                                     MirTypes.GP_GC_REG result,MirTypes.GP_IMM_ANY 2)
                     ]),
                   [], NONE, Sexpr.NIL), [], [])))
             end
         | _ =>
             Crash.impossible "Vector.length not called with one argument")



      fun sub_code (bytearray, safe,regs,the_code,exn_code) =
        let
          val (constantp,constant_value) =
            case regs of
              Mir_Utils.LIST[array,offset] =>
                (case offset of
                   Mir_Utils.INT(MirTypes.GP_IMM_INT v) => (true,v)
                 | _ => (false,0))
            | _ => (false,0)

          val ((new_reg, code),(new_reg', code')) =
            case regs of
              Mir_Utils.LIST[array,offset] =>
                (Mir_Utils.send_to_new_reg(Mir_Utils.ONE offset),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE array))
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                (let
                  val new_reg = MirTypes.GC.new()
                  val new_reg' = MirTypes.GC.new()
                in
                  ((MirTypes.GP_GC_REG new_reg,[MirTypes.STOREOP(MirTypes.LD,
                                    MirTypes.GC_REG new_reg,
                                    Mir_Utils.reg_from_gp reg,
                                    MirTypes.GP_IMM_ANY 3)]),
                  (MirTypes.GP_GC_REG new_reg',[MirTypes.STOREOP(MirTypes.LD,
                                              MirTypes.GC_REG new_reg',
                                              Mir_Utils.reg_from_gp reg,
                                              MirTypes.GP_IMM_ANY ~1)]))
                  end)
            | _ => Crash.impossible
                   "can't code generate the argument given to\
                    \ Array.sub in _mir_cg"

          val result = MirTypes.GC.new()
          val res1 = MirTypes.GC_REG result
          val res2 = MirTypes.GP_GC_REG result
        in
          if safe then
            let
	      val (exn_blocks, exn_tag_list) = exn_code
	      val exn_tag =
	        case exn_tag_list
	        of [tag] => tag
	        |  _ => Crash.impossible "no exn_tag for Array.sub"
              val main_tag = MirTypes.new_tag()
              val finish_tag = MirTypes.new_tag()
            in
              (Mir_Utils.ONE(Mir_Utils.INT res2),
               Mir_Utils.combine
               (the_code,
                ((Sexpr.ATOM
                  (code @@ code' @@
                   [MirTypes.COMMENT "Check the subscript range"] @@
		(if constantp then
		   if constant_value < 0 then
                     [MirTypes.BRANCH(MirTypes.BRA,
                                      MirTypes.TAG exn_tag)]
                   else
                     [MirTypes.STOREOP(MirTypes.LDREF,
                                       MirTypes.GC_REG MirRegisters.global,
                                       Mir_Utils.reg_from_gp new_reg',
                                       MirTypes.GP_IMM_ANY ~3),
		      MirTypes.BINARY(MirTypes.LSR,
                                      MirTypes.GC_REG MirRegisters.global,
                                      MirTypes.GP_GC_REG MirRegisters.global,
                                      MirTypes.GP_IMM_ANY 6),
                                                (* Length in words *)
		      MirTypes.TEST(MirTypes.BGT,
                                    main_tag,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY constant_value),
		      MirTypes.BRANCH(MirTypes.BRA,
                                      MirTypes.TAG exn_tag)]
                 else
(*
                   (if constantp then
                      if constant_value < 0 then
                        [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
                      else
                        []
                    else
                      [MirTypes.TEST(MirTypes.BLT, exn_tag, new_reg,
                       MirTypes.GP_IMM_INT 0)]) @@
                   [MirTypes.STOREOP(MirTypes.LDREF,
                                     MirTypes.GC_REG MirRegisters.global,
                                     Mir_Utils.reg_from_gp new_reg',
                                     MirTypes.GP_IMM_ANY ~3),
                    MirTypes.BINARY(MirTypes.LSR,
                                    MirTypes.GC_REG MirRegisters.global,
                                    MirTypes.GP_GC_REG MirRegisters.global,
                                    MirTypes.GP_IMM_ANY 4),
                    MirTypes.BINARY(MirTypes.SUBU,
                                    MirTypes.GC_REG MirRegisters.global,
                                    MirTypes.GP_GC_REG MirRegisters.global,
                                    MirTypes.GP_IMM_ANY 1),
                    MirTypes.TEST(MirTypes.BGE, main_tag,
			          MirTypes.GP_GC_REG MirRegisters.global,
				  MirTypes.GP_IMM_ANY 5),
		    (* Note that the 5 includes the left over bit of
                       secondary tag *)
                    MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
*)
		   [MirTypes.STOREOP(MirTypes.LDREF,
                                     MirTypes.GC_REG MirRegisters.global,
				     Mir_Utils.reg_from_gp new_reg',
				     MirTypes.GP_IMM_ANY ~3),
		    MirTypes.BINARY(MirTypes.LSR,
                                    MirTypes.GC_REG MirRegisters.global,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY 4),
		    MirTypes.BINARY(MirTypes.SUBU,
                                    MirTypes.GC_REG MirRegisters.global,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY 1),
		    MirTypes.TEST(MirTypes.BHI, main_tag,
				  MirTypes.GP_GC_REG MirRegisters.global,
				  new_reg),
		    MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)])
		   ),
                  MirTypes.BLOCK
                    (main_tag,
                     if bytearray then
                       [MirTypes.COMMENT "ByteArray subscript operation",
                        MirTypes.BINARY(MirTypes.LSR,
                                        MirTypes.GC_REG MirRegisters.global,
                                        new_reg,
                                        MirTypes.GP_IMM_ANY 2),
                        MirTypes.BINARY(MirTypes.ADDU,
                                        MirTypes.GC_REG MirRegisters.global,
                                        MirTypes.GP_GC_REG MirRegisters.global,
                                        new_reg'),
                        MirTypes.STOREOP(MirTypes.LDB,
                                         res1,
                                         MirTypes.GC_REG MirRegisters.global,
                                         MirTypes.GP_IMM_ANY 1),
			MirTypes.BINARY(MirTypes.ASL,
                                        res1,
                                        res2,
					MirTypes.GP_IMM_ANY 2),
                        MirTypes.BRANCH(MirTypes.BRA,
                                        MirTypes.TAG finish_tag)]

                      else (*not bytearray *)
                       [MirTypes.COMMENT "Array subscript operation",
                        MirTypes.BINARY(MirTypes.ADDU,
                                        MirTypes.GC_REG MirRegisters.global,
                                        new_reg',
                                        new_reg),
                        MirTypes.STOREOP(MirTypes.LDREF,
                                         res1,
                                         MirTypes.GC_REG MirRegisters.global,
                                         MirTypes.GP_IMM_ANY 9),
                        MirTypes.BRANCH(MirTypes.BRA,
                                        MirTypes.TAG finish_tag)]) ::
                  exn_blocks, SOME finish_tag,
		  Sexpr.ATOM[MirTypes.COMMENT"End of array sub"]), [], [])))
            end
          else
            (Mir_Utils.ONE(Mir_Utils.INT res2),
             Mir_Utils.combine
             (the_code,
              ((Sexpr.ATOM
                (code @@ code' @@
                 (if bytearray then
                   [MirTypes.COMMENT "Unsafe ByteArray subscript operation",
                    MirTypes.BINARY(MirTypes.LSR,
                                    MirTypes.GC_REG MirRegisters.global,
                                    new_reg,
                                    MirTypes.GP_IMM_ANY 2),
                    MirTypes.BINARY(MirTypes.ADDU,
			            MirTypes.GC_REG MirRegisters.global,
                                    MirTypes.GP_GC_REG MirRegisters.global,
				    new_reg'),
                    MirTypes.STOREOP(MirTypes.LDB,
                                     res1,
                                     MirTypes.GC_REG MirRegisters.global,
				     MirTypes.GP_IMM_ANY 1),
		    MirTypes.BINARY(MirTypes.ASL,
                                    res1,
                                    res2,
				    MirTypes.GP_IMM_ANY 2)]

                  else (*not bytearray*)
                    [MirTypes.COMMENT "Unsafe array subscript operation",
                     MirTypes.BINARY(MirTypes.ADDU,
                                     MirTypes.GC_REG MirRegisters.global,
                                     new_reg',
                                     new_reg),
                     MirTypes.STOREOP(MirTypes.LDREF,
                                      res1,
                                      MirTypes.GC_REG MirRegisters.global,
                                      MirTypes.GP_IMM_ANY 9)])),
              [], NONE, Sexpr.NIL), [], [])))
        end



      (* special version for floatarrays: returns result in an FP register
         rather than a normal int register. See
         <URI:MLW/design/floatarray.doc> for details. *)


      fun floatarray_sub_code (safe,regs,the_code,exn_code) =
        let
          val (constantp,constant_value) =
            case regs of
              Mir_Utils.LIST[array,offset] =>
                (case offset of
                   Mir_Utils.INT(MirTypes.GP_IMM_INT v) => (true,v)
                 | _ => (false,0))
            | _ => (false,0)

          val ((new_reg, code),(new_reg', code')) =
            case regs of
              Mir_Utils.LIST[array,offset] =>
                (Mir_Utils.send_to_new_reg(Mir_Utils.ONE offset),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE array))
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                (let
                  val new_reg = MirTypes.GC.new()
                  val new_reg' = MirTypes.GC.new()
                in
                  ((MirTypes.GP_GC_REG new_reg,
                    [MirTypes.STOREOP(MirTypes.LD,
                                      MirTypes.GC_REG new_reg,
                                      Mir_Utils.reg_from_gp reg,
                                      MirTypes.GP_IMM_ANY 3)]),
                  (MirTypes.GP_GC_REG new_reg',
                   [MirTypes.STOREOP(MirTypes.LD,
                                     MirTypes.GC_REG new_reg',
                                     Mir_Utils.reg_from_gp reg,
                                     MirTypes.GP_IMM_ANY ~1)]))
                  end)
            | _ => Crash.impossible
                   "can't code generate the argument given to\
                    \ FloatArray.sub in _mir_cg"

          val result = MirTypes.FP.new()
          val res1 = MirTypes.FP_REG result
        in
          if safe then
            let
	      val (exn_blocks, exn_tag_list) = exn_code
	      val exn_tag =
	        case exn_tag_list
	        of [tag] => tag
	        |  _ => Crash.impossible "no exn_tag for FloatArray.sub"
              val main_tag = MirTypes.new_tag()
              val finish_tag = MirTypes.new_tag()
            in
              (Mir_Utils.ONE(Mir_Utils.REAL res1),
               Mir_Utils.combine
               (the_code,
                ((Sexpr.ATOM
                  (code @@
                    [MirTypes.BINARY(MirTypes.ASL,
                                     Mir_Utils.reg_from_gp new_reg,
                                     new_reg,
                                     MirTypes.GP_IMM_ANY 1)] @@
                     (* cunning hack: since new_reg is an integer, its
                        lower two bits will be 00.  Shifting it left one
                        more will mean new_reg will be a number 8 times
                        the size of the offset --- i.e., the number of
                        bytes from the beginning of array. *)
                   code' @@
                   [MirTypes.COMMENT "Check the subscript range"] @@
		(if constantp then
		   if constant_value < 0 then
                     [MirTypes.BRANCH(MirTypes.BRA,
                                      MirTypes.TAG exn_tag)]
                   else
                     [MirTypes.STOREOP(MirTypes.LDREF,
                                       MirTypes.GC_REG MirRegisters.global,
                                       Mir_Utils.reg_from_gp new_reg',
                                       MirTypes.GP_IMM_ANY ~3),
		      MirTypes.BINARY(MirTypes.LSR,
                                      MirTypes.GC_REG MirRegisters.global,
                                      MirTypes.GP_GC_REG MirRegisters.global,
                                      MirTypes.GP_IMM_ANY 9),
                                                  (* remove 6 header bits
                                                     for number of bytes.
                                                     Then divide by 8
                                                     (ie shift right 3)
                                                     for number of floats.*)
		      MirTypes.TEST(MirTypes.BLE,
                                    exn_tag,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY constant_value),
		      MirTypes.BRANCH(MirTypes.BRA,
                                      MirTypes.TAG main_tag)]
                 else
		   [MirTypes.STOREOP(MirTypes.LDREF,
                                     MirTypes.GC_REG MirRegisters.global,
				     Mir_Utils.reg_from_gp new_reg',
				     MirTypes.GP_IMM_ANY ~3),
                                     (* 3 is tag of reference pointer. *)
		    MirTypes.BINARY(MirTypes.LSR,
                                    MirTypes.GC_REG MirRegisters.global,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY 9),
		    MirTypes.BINARY(MirTypes.ASL,
                                    MirTypes.GC_REG MirRegisters.global,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY 3),
                                    (* remove the header bits.  Gives
                                       number of floats * 8.  The two shifts
                                       effectively mask off the 4 bytes used
                                       in the dummy word. *)
                    MirTypes.TEST(MirTypes.BLS ,
                                  exn_tag,
                                  MirTypes.GP_GC_REG MirRegisters.global,
                                  new_reg),
                                    (* unsigned test here is cunning:
                                       it Mir_Utils.combine lowerand upper
                                       bound tests together.  If a subscript
                                       is less than 0, as an unsigned
                                       integer, it is very big, much bigger
                                       than the maximum size of any array *)
                    MirTypes.BRANCH(MirTypes.BRA,
                                    MirTypes.TAG main_tag)]
		   )),
                  MirTypes.BLOCK
                    (main_tag,
                       [MirTypes.COMMENT "FloatArray subscript operation",
                        MirTypes.BINARY(MirTypes.ADDU,
                                        MirTypes.GC_REG MirRegisters.global,
                                        new_reg',
                                        new_reg),
                        MirTypes.STOREFPOP(MirTypes.FLD,
                                           res1,
                                           MirTypes.GC_REG MirRegisters.global,
                                           MirTypes.GP_IMM_ANY 5),
                                           (* offset 5 points to first
                                              entry in array (since we're
                                              3 bytes into the header
                                              word because the pointer tag
                                              equals 3, and the next
                                              word is a dummy to maintain
                                              double word alignment.) *)
                        MirTypes.BRANCH(MirTypes.BRA,
                                        MirTypes.TAG finish_tag)]) ::
                  exn_blocks, SOME finish_tag,
		  Sexpr.ATOM[MirTypes.COMMENT"End of floatarray_sub"]), [], [])))
            end
          else
            (Mir_Utils.ONE(Mir_Utils.REAL res1),
             Mir_Utils.combine
             (the_code,
              ((Sexpr.ATOM
                (code @@ code' @@
                 [MirTypes.COMMENT "Unsafe FloatArray subscript operation",
                  MirTypes.BINARY(MirTypes.ASL,
                                  Mir_Utils.reg_from_gp new_reg,
                                  new_reg,
                                  MirTypes.GP_IMM_ANY 1),
                                  (* add extra 0 to int tag 00 in order
                                     to multiply num floats by 8 for num
                                     bytes. *)
                  MirTypes.BINARY(MirTypes.ADDU,
                                  MirTypes.GC_REG MirRegisters.global,
                                  new_reg',
                                  new_reg),
                  MirTypes.STOREFPOP(MirTypes.FLD,
                                     res1,
                                     MirTypes.GC_REG MirRegisters.global,
                                     MirTypes.GP_IMM_ANY 5)]),
              [], NONE, Sexpr.NIL), [], [])))
        end



      fun vector_sub_code (safe,regs,the_code,exn_code) =
        let
          val (constantp,constant_value) =
            case regs of
              Mir_Utils.LIST[vector, offset] =>
                (case offset of
                   Mir_Utils.INT(MirTypes.GP_IMM_INT v) => (true,v)
                 | _ => (false,0))
            | _ => (false,0)

          val ((vector_reg, code),(offset_reg, code')) =
            case regs of
              Mir_Utils.LIST[vector ,offset] =>
                (Mir_Utils.send_to_new_reg(Mir_Utils.ONE vector),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE offset))
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                (let
                  val new_reg = MirTypes.GC.new()
                  val new_reg' = MirTypes.GC.new()
                in
                  ((MirTypes.GP_GC_REG new_reg,[MirTypes.STOREOP(MirTypes.LD,
                                    MirTypes.GC_REG new_reg,
                                    Mir_Utils.reg_from_gp reg,
                                    MirTypes.GP_IMM_ANY ~1)]),
                  (MirTypes.GP_GC_REG new_reg',[MirTypes.STOREOP(MirTypes.LD,
                                              MirTypes.GC_REG new_reg',
                                              Mir_Utils.reg_from_gp reg,
                                              MirTypes.GP_IMM_ANY 3)]))
                  end)
            | _ => Crash.impossible "can't code generate the argument given to Vector.sub in _mir_cg"

          val result = MirTypes.GC.new()
          val res1 = MirTypes.GC_REG result
          val res2 = MirTypes.GP_GC_REG result
        in
          if safe then
	    let
	      val (exn_blocks, exn_tag_list) = exn_code
	      val exn_tag =
		case exn_tag_list
		  of [tag] => tag
		|  _ => Crash.impossible "no exn_tag for Vector.sub"
	      val finish_tag = MirTypes.new_tag()
	      val main_tag = MirTypes.new_tag()
	    in
	      (Mir_Utils.ONE(Mir_Utils.INT res2),
	       Mir_Utils.combine
	       (the_code,
		((Sexpr.ATOM
		  (code @@ code' @@
		   [MirTypes.COMMENT "Check the subscript range"] @@
		(if constantp then
		   if constant_value < 0 then
                     [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
                   else
                     [MirTypes.STOREOP
		      (MirTypes.LDREF, MirTypes.GC_REG MirRegisters.global,
		       Mir_Utils.reg_from_gp vector_reg, MirTypes.GP_IMM_ANY ~5),
		      MirTypes.BINARY
		      (MirTypes.LSR, MirTypes.GC_REG MirRegisters.global,
		       MirTypes.GP_GC_REG MirRegisters.global,
		       MirTypes.GP_IMM_ANY 6), (* Length in words *)
		      MirTypes.TEST(MirTypes.BGT, main_tag,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY constant_value),
		      MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
                 else
		   [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG MirRegisters.global,
				     Mir_Utils.reg_from_gp vector_reg,
				     MirTypes.GP_IMM_ANY ~5),
		    MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY 4),
		    MirTypes.TEST(MirTypes.BHI, main_tag,
				  MirTypes.GP_GC_REG MirRegisters.global,
				  offset_reg),
		    MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)])
(*
		      [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG MirRegisters.global,
					Mir_Utils.reg_from_gp vector_reg,
					MirTypes.GP_IMM_ANY(~5)),
		       MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
				       MirTypes.GP_GC_REG MirRegisters.global,
				       MirTypes.GP_IMM_ANY 4),
		       MirTypes.BINARY(MirTypes.SUBU,MirTypes.GC_REG MirRegisters.global,
				       MirTypes.GP_GC_REG MirRegisters.global,
				       offset_reg),
		       MirTypes.TEST(MirTypes.BGE, main_tag,
				     MirTypes.GP_GC_REG MirRegisters.global,
				     MirTypes.GP_IMM_ANY 4),
		       MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
*)
		      ),
		  MirTypes.BLOCK(main_tag,
				 [MirTypes.COMMENT "Vector subscript operation",
				  MirTypes.BINARY(MirTypes.ADDU,
						  MirTypes.GC_REG MirRegisters.global,
						  vector_reg, offset_reg),
				  MirTypes.STOREOP(MirTypes.LD, res1,
						   MirTypes.GC_REG MirRegisters.global,
						   MirTypes.GP_IMM_ANY(~1)),
				  MirTypes.BRANCH(MirTypes.BRA,
						  MirTypes.TAG finish_tag)]) ::
		  exn_blocks, SOME finish_tag,
		  Sexpr.ATOM[MirTypes.COMMENT"End of vector sub"]), [], [])))
	    end
          else
            (* Unsafe code *)
            (Mir_Utils.ONE(Mir_Utils.INT res2),
             Mir_Utils.combine
             (the_code,
              ((Sexpr.ATOM
                (code @@ code' @@
                 [MirTypes.COMMENT "Unsafe vector subscript operation"] @@
                 (if constantp
                    then
                      [MirTypes.STOREOP(MirTypes.LD, res1,
                                        Mir_Utils.reg_from_gp vector_reg,
                                        MirTypes.GP_IMM_ANY((constant_value * 4) - 1))]
                  else
                    [MirTypes.BINARY(MirTypes.ADDU,
                                     MirTypes.GC_REG MirRegisters.global,
                                     vector_reg, offset_reg),
                     MirTypes.STOREOP(MirTypes.LD, res1,
                                      MirTypes.GC_REG MirRegisters.global,
                                      MirTypes.GP_IMM_ANY(~1))])),
                [], NONE, Sexpr.NIL), [], [])))
        end



      fun update_code (bytearray,safe,isIntegral,regs,the_code,exn_code) =
        let
          val (constantp,constant_value) =
            case regs of
              Mir_Utils.LIST[array,offset,value] =>
                (case offset of
                   Mir_Utils.INT(MirTypes.GP_IMM_INT v) => (true,v)
                 | _ => (false,0))
            | _ => (false,0)

          val ((new_reg, code),(new_reg', code'),(new_reg'', code'')) =
            case regs of
              Mir_Utils.LIST[array,offset,value] =>
                (Mir_Utils.send_to_new_reg(Mir_Utils.ONE offset),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE array),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE value))
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                (let
                   val new_reg = MirTypes.GC.new()
                   val new_reg' = MirTypes.GC.new()
                   val new_reg'' = MirTypes.GC.new()
                in
                   ((MirTypes.GP_GC_REG new_reg,
                     [MirTypes.STOREOP(MirTypes.LD,
                                       MirTypes.GC_REG new_reg,
                                       Mir_Utils.reg_from_gp reg,
                                       MirTypes.GP_IMM_ANY 3)]),
                    (MirTypes.GP_GC_REG new_reg',
                     [MirTypes.STOREOP(MirTypes.LD,
                                       MirTypes.GC_REG new_reg',
                                       Mir_Utils.reg_from_gp reg,
                                       MirTypes.GP_IMM_ANY ~1)]),
                    (MirTypes.GP_GC_REG new_reg'',
                     [MirTypes.STOREOP(MirTypes.LD,
                                       MirTypes.GC_REG new_reg'',
                                       Mir_Utils.reg_from_gp reg,
                                       MirTypes.GP_IMM_ANY 7)]))
                 end)
            | _ => Crash.impossible "_mir_cg : update can't code generate\
                                     \ arguments "

          val result = MirTypes.GC.new()
          val res1 = MirTypes.GC_REG result
          val reg1 = new_reg'
          val scratch = MirTypes.GC.new()
          val scratch_reg = MirTypes.GC_REG scratch
          val forward = MirTypes.GC.new()
          val forward_reg = MirTypes.GC_REG forward
          val backward = MirTypes.GC.new()
          val backward_reg = MirTypes.GC_REG backward
          val unlink_tag = MirTypes.new_tag()
          val modified_tag = MirTypes.new_tag()

          val main_tag = MirTypes.new_tag()
          val finish_tag = MirTypes.new_tag()
	  val (exn_blocks, exn_tag_list) = exn_code

	  val exn_test =
	    if safe then
	      let val exn_tag =
		    case exn_tag_list
	            of [tag] => tag
	            |  _ => Crash.impossible "no exn_tag for update"
	      in
                [MirTypes.COMMENT "Check the subscript range"] @@
		(if constantp then
		   if constant_value < 0 then
                     [MirTypes.BRANCH(MirTypes.BRA,
                                      MirTypes.TAG exn_tag)]
                   else
                     [MirTypes.STOREOP(MirTypes.LDREF,
                                       MirTypes.GC_REG MirRegisters.global,
                                       Mir_Utils.reg_from_gp new_reg',
                                       MirTypes.GP_IMM_ANY ~3),
		      MirTypes.BINARY(MirTypes.LSR,
                                      MirTypes.GC_REG MirRegisters.global,
                                      MirTypes.GP_GC_REG MirRegisters.global,
                                      MirTypes.GP_IMM_ANY 6),
                                                (* Length in words *)
		      MirTypes.TEST(MirTypes.BGT,
                                    main_tag,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY constant_value),
		      MirTypes.BRANCH(MirTypes.BRA,
                                      MirTypes.TAG exn_tag)]
                 else
(*
		(if constantp then
                   if constant_value < 0 then
                     [MirTypes.BRANCH(MirTypes.BRA,
                                      MirTypes.TAG exn_tag)]
                   else
                     []
                 else
                   [MirTypes.TEST(MirTypes.BLT,
                                  exn_tag,
                                  new_reg,
		                  MirTypes.GP_IMM_INT 0)]) @@
                [MirTypes.STOREOP(MirTypes.LDREF,
                                  MirTypes.GC_REG MirRegisters.global,
                                  Mir_Utils.reg_from_gp new_reg',
                                  MirTypes.GP_IMM_ANY ~3),
                 MirTypes.BINARY(MirTypes.LSR,
                                 MirTypes.GC_REG MirRegisters.global,
                                 MirTypes.GP_GC_REG MirRegisters.global,
                                 MirTypes.GP_IMM_ANY 4),
                 MirTypes.BINARY(MirTypes.SUBU,
                                 MirTypes.GC_REG MirRegisters.global,
                                 MirTypes.GP_GC_REG MirRegisters.global,
                                 new_reg),
                 MirTypes.TEST(MirTypes.BGE,
                               main_tag,
		               MirTypes.GP_GC_REG MirRegisters.global,
		               MirTypes.GP_IMM_ANY 5),
		 (* Note that the 5 includes the left over bit of
		    secondary tag *)
                 MirTypes.BRANCH(MirTypes.BRA,
                                 MirTypes.TAG exn_tag)]
*)
		   [MirTypes.STOREOP(MirTypes.LDREF,
                                     MirTypes.GC_REG MirRegisters.global,
				     Mir_Utils.reg_from_gp new_reg',
				     MirTypes.GP_IMM_ANY ~3),
		    MirTypes.BINARY(MirTypes.LSR,
                                    MirTypes.GC_REG MirRegisters.global,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY 4),
		    MirTypes.BINARY(MirTypes.SUBU,
                                    MirTypes.GC_REG MirRegisters.global,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY 1),
		    MirTypes.TEST(MirTypes.BHI,
                                  main_tag,
				  MirTypes.GP_GC_REG MirRegisters.global,
				  new_reg),
		    MirTypes.BRANCH(MirTypes.BRA,
                                    MirTypes.TAG exn_tag)])
	      end
            else
              [MirTypes.BRANCH(MirTypes.BRA,
                               MirTypes.TAG main_tag)]

        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
           Mir_Utils.combine
           (the_code,
            ((Sexpr.ATOM
              (code @@ code' @@ code'' @@ exn_test),
              MirTypes.BLOCK
               (main_tag,
                let
                  val address = MirTypes.GC.new ()
                in
                  if bytearray then
                    [MirTypes.COMMENT ((if safe then "" else "Unsafe ")
                                       ^ "ByteArray update operation"),
                     MirTypes.BINARY(MirTypes.LSR,
                                     MirTypes.GC_REG address,
                                     new_reg,
                                     MirTypes.GP_IMM_ANY 2),
                     MirTypes.BINARY(MirTypes.ADDU,
                                     MirTypes.GC_REG address,
                                     MirTypes.GP_GC_REG address,
                                     new_reg'),
                     MirTypes.BINARY(MirTypes.LSR,
                                     MirTypes.GC_REG MirRegisters.global,
                                     new_reg'',
                                     MirTypes.GP_IMM_ANY 2),
                     MirTypes.STOREOP(MirTypes.STB,
                                      MirTypes.GC_REG MirRegisters.global,
                                      MirTypes.GC_REG address,
                                      MirTypes.GP_IMM_ANY 1),
                     MirTypes.NULLARY(MirTypes.CLEAN,
                                      MirTypes.GC_REG address),
                     MirTypes.BRANCH(MirTypes.BRA,
                                     MirTypes.TAG finish_tag)]
                  else
                    [MirTypes.COMMENT ((if safe then "" else "Unsafe ")
                                       ^ "Array update operation"),
                     MirTypes.BINARY(MirTypes.ADDU,
                                     MirTypes.GC_REG address,
                                     new_reg',
                                     new_reg),
                     MirTypes.STOREOP(MirTypes.STREF,
                                      Mir_Utils.reg_from_gp new_reg'',
                                      MirTypes.GC_REG address,
                                      MirTypes.GP_IMM_ANY 9),
                     MirTypes.NULLARY(MirTypes.CLEAN,
                                      MirTypes.GC_REG address)] @@
                    (if isIntegral then
                       [MirTypes.BRANCH(MirTypes.BRA,
                                        MirTypes.TAG finish_tag)]
                     else
                       [MirTypes.COMMENT"Do we need to unlink it",
                        MirTypes.STOREOP(MirTypes.LDREF,
                                         forward_reg,
                                         Mir_Utils.reg_from_gp reg1,
                                         MirTypes.GP_IMM_ANY 1),
                        MirTypes.TEST(MirTypes.BEQ,
                                      finish_tag,
                                      MirTypes.GP_GC_REG forward,
                                      MirTypes.GP_IMM_INT 0),
                        MirTypes.BRANCH(MirTypes.BRA,
                                        MirTypes.TAG unlink_tag)])
                end) ::
               (if isIntegral then
                  exn_blocks
                else
                  MirTypes.BLOCK
                   (unlink_tag,
                    [MirTypes.STOREOP(MirTypes.LDREF,
                                      backward_reg,
                                      Mir_Utils.reg_from_gp reg1,
                                      MirTypes.GP_IMM_ANY 5),
                     MirTypes.TEST(MirTypes.BEQ,
                                   modified_tag,
                                   MirTypes.GP_GC_REG backward,
                                   MirTypes.GP_IMM_INT 0),
                     MirTypes.COMMENT "Unlink the cell",
                     MirTypes.STOREOP(MirTypes.STREF,
                                      backward_reg,
                                      forward_reg,
                                      MirTypes.GP_IMM_ANY 8),
                     MirTypes.STOREOP(MirTypes.STREF,
                                      forward_reg,
                                      backward_reg,
                                      MirTypes.GP_IMM_ANY 4),
                     MirTypes.BRANCH(MirTypes.BRA,
                                     MirTypes.TAG modified_tag)]) ::
                 MirTypes.BLOCK
                  (modified_tag,
                   [MirTypes.UNARY(MirTypes.MOVE,
                                   scratch_reg,
                                   MirTypes.GP_IMM_INT 0),
                    MirTypes.STOREOP(MirTypes.STREF,
                                     scratch_reg,
                                     Mir_Utils.reg_from_gp reg1,
                                     MirTypes.GP_IMM_ANY 1),
                    MirTypes.STOREOP(MirTypes.LDREF,
                                     scratch_reg,
                                     MirTypes.GC_REG MirRegisters.implicit,
                                     MirTypes.GP_IMM_ANY
                                               Implicit_Vector.ref_chain),
                    MirTypes.STOREOP(MirTypes.STREF,
                                     scratch_reg,
                                     Mir_Utils.reg_from_gp reg1,
                                     MirTypes.GP_IMM_ANY 5),
                    MirTypes.BINARY(MirTypes.ADDU,
                                    MirTypes.GC_REG MirRegisters.global,
                                    reg1,
                                    MirTypes.GP_IMM_ANY ~3),
                    MirTypes.STOREOP(MirTypes.STREF,
                                     MirTypes.GC_REG MirRegisters.global,
                                     MirTypes.GC_REG MirRegisters.implicit,
                                     MirTypes.GP_IMM_ANY
                                               Implicit_Vector.ref_chain),
                    MirTypes.BRANCH(MirTypes.BRA,
                                    MirTypes.TAG finish_tag)]) ::
                 exn_blocks),
                 SOME finish_tag,
                 Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE,
                                           res1,
                                           MirTypes.GP_IMM_INT 0)]), [], [])))
        end


      (* see <URI:MLW/src/floatarray.doc> for an explanation of
         the implementation of floatarrays. *)

      fun floatarray_update_code (safe,regs,the_code,exn_code) =
        let
          val (constantp,constant_value) =
            case regs of
              Mir_Utils.LIST[array,offset,value] =>
                (case offset of
                   Mir_Utils.INT(MirTypes.GP_IMM_INT v) => (true,v)
                 | _ => (false,0))
            | _ => (false,0)

          val ((new_reg, code),(new_reg', code'),(float_reg, code'')) =
            case regs of
              Mir_Utils.LIST[array,offset,Mir_Utils.REAL fp_op] =>
                (Mir_Utils.send_to_new_reg(Mir_Utils.ONE offset),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE array),
                 (fp_op,[]))
            | Mir_Utils.LIST[array,offset,
                             Mir_Utils.INT(MirTypes.GP_GC_REG reg)] =>
                let val float_reg = MirTypes.FP_REG(MirTypes.FP.new())
                in
                 (Mir_Utils.send_to_new_reg(Mir_Utils.ONE offset),
                  Mir_Utils.send_to_new_reg(Mir_Utils.ONE array),
                  (float_reg,
                   [MirTypes.STOREFPOP(MirTypes.FLD,
                                       float_reg,
                                       MirTypes.GC_REG reg,
                                       MirTypes.GP_IMM_ANY real_offset)]))
                end
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                (let
                   val new_reg = MirTypes.GC.new()
                   val new_reg' = MirTypes.GC.new()
                   val float_reg = MirTypes.FP.new()
                in
                   ((MirTypes.GP_GC_REG new_reg,
                     [MirTypes.STOREOP(MirTypes.LD,
                                       MirTypes.GC_REG new_reg,
                                       Mir_Utils.reg_from_gp reg,
                                       MirTypes.GP_IMM_ANY 3)]),
                    (MirTypes.GP_GC_REG new_reg',
                     [MirTypes.STOREOP(MirTypes.LD,
                                       MirTypes.GC_REG new_reg',
                                       Mir_Utils.reg_from_gp reg,
                                       MirTypes.GP_IMM_ANY ~1)]),
                    (MirTypes.FP_REG float_reg,
                     [MirTypes.STOREFPOP(MirTypes.FLD,
                                       MirTypes.FP_REG float_reg,
                                       Mir_Utils.reg_from_gp reg,
                                       MirTypes.GP_IMM_ANY 7)]))
                 end)
            | _ => Crash.impossible "_mir_cg : update can't code generate\
                                     \ arguments "

          val result = MirTypes.GC.new()
          val res1 = MirTypes.GC_REG result
          val reg1 = new_reg'
          val scratch = MirTypes.GC.new()
          val scratch_reg = MirTypes.GC_REG scratch
          val forward = MirTypes.GC.new()
          val forward_reg = MirTypes.GC_REG forward
          val backward = MirTypes.GC.new()
          val backward_reg = MirTypes.GC_REG backward
          val unlink_tag = MirTypes.new_tag()
          val modified_tag = MirTypes.new_tag()

          val main_tag = MirTypes.new_tag()
          val finish_tag = MirTypes.new_tag()
	  val (exn_blocks, exn_tag_list) = exn_code

	  val exn_test =
	    if safe then
	      let val exn_tag =
		    case exn_tag_list
	            of [tag] => tag
	            |  _ => Crash.impossible "no exn_tag for floatarray_update"
	      in
                [MirTypes.COMMENT "Check the subscript range"] @@
		(if constantp then
		   if constant_value < 0 then
                     [MirTypes.BRANCH(MirTypes.BRA,
                                      MirTypes.TAG exn_tag)]
                   else
                     [MirTypes.STOREOP(MirTypes.LDREF,
                                       MirTypes.GC_REG MirRegisters.global,
                                       Mir_Utils.reg_from_gp new_reg',
                                       MirTypes.GP_IMM_ANY ~3),
		      MirTypes.BINARY(MirTypes.LSR,
                                      MirTypes.GC_REG MirRegisters.global,
                                      MirTypes.GP_GC_REG MirRegisters.global,
                                      MirTypes.GP_IMM_ANY 9),
                                                  (* remove 6 header bits
                                                     for number of bytes, then
                                                     divide by 8 (shift 3 bits)
                                                     for number of floats *)
		      MirTypes.TEST(MirTypes.BGT,
                                    main_tag,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY constant_value),
		      MirTypes.BRANCH(MirTypes.BRA,
                                      MirTypes.TAG exn_tag)]
                 else
		   [MirTypes.STOREOP(MirTypes.LDREF,
                                     MirTypes.GC_REG MirRegisters.global,
				     Mir_Utils.reg_from_gp new_reg',
				     MirTypes.GP_IMM_ANY ~3),
                                     (* 3 is tag of reference pointer. *)
		    MirTypes.BINARY(MirTypes.LSR,
                                    MirTypes.GC_REG MirRegisters.global,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY 9),
		    MirTypes.BINARY(MirTypes.ASL,
                                    MirTypes.GC_REG MirRegisters.global,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY 3),
                                    (* remove the header bits.  Gives
                                       size of array *in bytes*. note
                                       that shifing right by 9 and then
                                       shifting left by 3 removes the
                                       4 bytes associated with the dummy
                                       word. *)
(*                    MirTypes.BINARY(MirTypes.ASL,
                                    Mir_Utils.reg_from_gp new_reg,
                                    new_reg,
                                    MirTypes.GP_IMM_ANY 1),
                                    (* cunning hack: since new_reg is an
                                       integer, its lower two bits will
                                       be 00.  Shifting it left one more
                                       will mean new_reg will be a number
                                       8 times the size of the offset ---
                                       i.e., the number of bytes from
                                       beginning of array. *)*)
                    MirTypes.TEST(MirTypes.BHI,
                                  main_tag,
                                  MirTypes.GP_GC_REG MirRegisters.global,
                                  new_reg),
                    MirTypes.BRANCH(MirTypes.BRA,
                                    MirTypes.TAG exn_tag)])
              end
            else
              [MirTypes.BRANCH(MirTypes.BRA,
                               MirTypes.TAG main_tag)]

        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
           Mir_Utils.combine
           (the_code,
            ((Sexpr.ATOM
              (code @@
                [MirTypes.BINARY(MirTypes.ASL,
                                 Mir_Utils.reg_from_gp new_reg,
                                 new_reg,
                                 MirTypes.GP_IMM_ANY 1)
                 (* cunning hack: since new_reg is an integer, its lower
                    two bits will be 00.  Shifting it left one more will
                    mean new_reg will be a number 8 times the size of the
                    offset --- i.e., the number of bytes from beginning
                    of array. *)] @@
               code' @@ code'' @@ exn_test),
              MirTypes.BLOCK
               (main_tag,
                let
                  val address = MirTypes.GC.new ()
                in
                    [MirTypes.COMMENT ((if safe then "" else "Unsafe ")
                                       ^ "FloatArray update operation"),
                     MirTypes.BINARY(MirTypes.ADDU,
                                     MirTypes.GC_REG address,
                                     new_reg',
                                     new_reg),
                     MirTypes.STOREFPOP(MirTypes.FST,
                                        float_reg,
                                        MirTypes.GC_REG address,
                                        MirTypes.GP_IMM_ANY 5),
                             (* the address is a ptr, which means it has
                                an extra 3 tag, i.e., it pts to an address
                                3 bytes into the header.  To maintain
                                double word alignment, we have to pad
                                an extra dummy word between the header
                                and the first float.  Hence we add 5 offset
                                to pt to the start of the 3rd word (the 1st
                                actual float *)
                     MirTypes.NULLARY(MirTypes.CLEAN,
                                      MirTypes.GC_REG address),
                     MirTypes.BRANCH(MirTypes.BRA,
                                     MirTypes.TAG finish_tag)]
                end) ::
               exn_blocks,
            SOME finish_tag,
            Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE,
                                      res1,
                                      MirTypes.GP_IMM_INT 0)]), [], [])))
        end



      fun string_unsafe_update_code (regs,the_code) =
        let
          val (constantp,constant_value) =
            case regs of
              Mir_Utils.LIST[array,offset,value] =>
                (case offset of
                   Mir_Utils.INT(MirTypes.GP_IMM_INT v) => (true,v)
                 | _ => (false,0))
            | _ => (false,0)

          val ((string_reg, code),(offset_reg, code'),(value_reg, code'')) =
            case regs of
              Mir_Utils.LIST[string,offset,value] =>
                (Mir_Utils.send_to_new_reg(Mir_Utils.ONE string),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE offset),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE value))
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                (let
                   val new_reg = MirTypes.GC.new()
                   val new_reg' = MirTypes.GC.new()
                   val new_reg'' = MirTypes.GC.new()
                in
                   ((MirTypes.GP_GC_REG new_reg,
                     [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
                                       Mir_Utils.reg_from_gp reg,
                                       MirTypes.GP_IMM_ANY ~1)]),
                    (MirTypes.GP_GC_REG new_reg',
                     [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg',
                                       Mir_Utils.reg_from_gp reg,
                                       MirTypes.GP_IMM_ANY 3)]),
                    (MirTypes.GP_GC_REG new_reg'',
                     [MirTypes.STOREOP(MirTypes.LD,
                                       MirTypes.GC_REG new_reg'',
                                       Mir_Utils.reg_from_gp reg,
                                       MirTypes.GP_IMM_ANY 7)]))
                 end)
            | _ => Crash.impossible "_mir_cg : string update can't code generate arguments "

          val result = MirTypes.GC.new()
          val res1 = MirTypes.GC_REG result
          val reg1 = offset_reg
          val address = MirTypes.GC.new ()
        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
           Mir_Utils.combine
           (the_code,
            ((Sexpr.ATOM
              (code @@ code' @@ code'' @@
               [MirTypes.COMMENT ("Unsafe string update operation"),
                MirTypes.BINARY(MirTypes.LSR, MirTypes.GC_REG address,
                                offset_reg, MirTypes.GP_IMM_ANY 2),
                MirTypes.BINARY(MirTypes.ADDU, MirTypes.GC_REG address,
                                MirTypes.GP_GC_REG address, string_reg),
                MirTypes.BINARY(MirTypes.LSR, MirTypes.GC_REG MirRegisters.global,
                                value_reg, MirTypes.GP_IMM_ANY 2),
                MirTypes.STOREOP(MirTypes.STB, MirTypes.GC_REG MirRegisters.global,
                                 MirTypes.GC_REG address, MirTypes.GP_IMM_ANY ~1),
                MirTypes.NULLARY(MirTypes.CLEAN, MirTypes.GC_REG address),
                MirTypes.UNARY(MirTypes.MOVE, res1, MirTypes.GP_IMM_INT 0)]),
              [],
              NONE,
              Sexpr.NIL), [], [])))
        end

      fun record_unsafe_update_code (regs,the_code) =
        let
          (* Is the offset a constant *)
          val (constantp,offset_value) =
            case regs of
              Mir_Utils.LIST[array,offset,value] =>
                (case offset of
                   Mir_Utils.INT(MirTypes.GP_IMM_INT v) => (true,v)
                 | _ => (false,0))
            | _ => (false,0)

          (* Move the stuff into registers *)
          val ((vector_reg, code),(offset_reg, code'),(value_reg, code'')) =
            case regs of
              Mir_Utils.LIST[vector,offset,value] =>
                (Mir_Utils.send_to_new_reg(Mir_Utils.ONE vector),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE offset),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE value))
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                (let
                   val new_reg = MirTypes.GC.new()
                   val new_reg' = MirTypes.GC.new()
                   val new_reg'' = MirTypes.GC.new()
                in
                   ((MirTypes.GP_GC_REG new_reg,
                     [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
                                       Mir_Utils.reg_from_gp reg,
                                       MirTypes.GP_IMM_ANY ~1)]),
                    (MirTypes.GP_GC_REG new_reg',
                     [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg',
                                       Mir_Utils.reg_from_gp reg,
                                       MirTypes.GP_IMM_ANY 3)]),
                    (MirTypes.GP_GC_REG new_reg'',
                     [MirTypes.STOREOP(MirTypes.LD,
                                       MirTypes.GC_REG new_reg'',
                                       Mir_Utils.reg_from_gp reg,
                                       MirTypes.GP_IMM_ANY 7)]))
                 end)
            | _ => Crash.impossible "_mir_cg : update can't code generate arguments "

          val result = MirTypes.GC.new()
          val address = MirTypes.GC.new ()

        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
           Mir_Utils.combine
           (the_code,
            ((Sexpr.ATOM
              (code @@ code' @@ code'' @@
               [MirTypes.COMMENT ("Unsafe vector update operation")] @@
               (if constantp
                  then
                    [MirTypes.STOREOP(MirTypes.STREF,
                                      Mir_Utils.reg_from_gp value_reg,
                                      Mir_Utils.reg_from_gp vector_reg,
                                      MirTypes.GP_IMM_ANY ((4 * offset_value) - 1))]
                else
                  [MirTypes.BINARY(MirTypes.ADDU,
                                   MirTypes.GC_REG address, offset_reg,
                                   vector_reg),
                   MirTypes.STOREOP(MirTypes.STREF,
                                    Mir_Utils.reg_from_gp value_reg,
                                    MirTypes.GC_REG address,
                                    MirTypes.GP_IMM_ANY ~1),
                   MirTypes.NULLARY(MirTypes.CLEAN,
                                    MirTypes.GC_REG address)]) @@
               [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG result, MirTypes.GP_IMM_INT 0)]),
              [],
              NONE,
              Sexpr.NIL), [], [])))
        end

      fun do_ml_call (regs,the_code) =
	  let
	    val res = MirTypes.GC.new()
            val scratch_reg = MirTypes.GC_REG (MirTypes.GC.new ())
	    val opcodes = Sexpr.ATOM (Mir_Utils.send_to_given_reg(regs, caller_arg))
	    val call_code =
	      Sexpr.ATOM
	      ([MirTypes.UNARY(MirTypes.MOVE,
			       MirTypes.GC_REG caller_closure,
			       MirTypes.GP_GC_REG caller_arg),
		MirTypes.STOREOP(MirTypes.LD, scratch_reg,
				 MirTypes.GC_REG caller_closure,
				 MirTypes.GP_IMM_ANY ~1),
		MirTypes.BRANCH_AND_LINK(MirTypes.BLR,
					 MirTypes.REG scratch_reg,
                                         Debugger_Types.null_backend_annotation,
                                         [MirTypes.GC caller_arg]),
		MirTypes.UNARY(MirTypes.MOVE,
			       MirTypes.GC_REG res,
			       MirTypes.GP_GC_REG caller_arg)])
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG res)),
	     Mir_Utils.combine(the_code,
			       ((Sexpr.CONS(opcodes, call_code), [],
				 NONE, Sexpr.NIL), [], [])))
	  end

      fun do_ref (regs,the_code) =
        let
          val scratch = MirTypes.GC.new()
          val scratch_reg = MirTypes.GC_REG scratch
          val (new_reg, code) = Mir_Utils.send_to_reg(regs)
          val result = MirTypes.GC.new()
          val res1 = MirTypes.GC_REG result
          val work1 = MirTypes.GC_REG(MirTypes.GC.new ())
          val work2 = MirTypes.GC_REG(MirTypes.GC.new ())
        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
           Mir_Utils.combine(the_code,
                             ((Sexpr.ATOM(code @@
                                          [MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, MirTypes.GP_IMM_INT 1),
                                           MirTypes.COMMENT"Allocate a ref cell",
                                           MirTypes.STOREOP(MirTypes.STREF, Mir_Utils.reg_from_gp new_reg, res1,
                                                            MirTypes.GP_IMM_ANY 9),
                                           MirTypes.UNARY(MirTypes.MOVE, work1, MirTypes.GP_IMM_ANY 0),
                                           MirTypes.STOREOP(MirTypes.STREF, work1, res1, MirTypes.GP_IMM_ANY 5),
                                           MirTypes.UNARY(MirTypes.MOVE, work2, MirTypes.GP_IMM_INT 1),
                                           MirTypes.STOREOP(MirTypes.STREF, work2, res1, MirTypes.GP_IMM_ANY 1),
                                           MirTypes.COMMENT"Initialise the other pointers"]),
                             [], NONE, Sexpr.NIL), [], [])))
        end

      fun do_ml_offset (regs,the_code) =
	  let
	    val (reg1, reg2, code) =
             case regs of
	      Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] =>
		(reg1, reg2, [])
	    | Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG reg)) =>
		let
		  val reg1 = MirTypes.GC.new()
		  val reg2 = MirTypes.GC.new()
		  val gc_reg = MirTypes.GC_REG reg
		in
		  (MirTypes.GP_GC_REG reg1, MirTypes.GP_GC_REG reg2,
		   [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG reg1,
				     gc_reg, MirTypes.GP_IMM_ANY ~1),
		    MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG reg2,
				     gc_reg, MirTypes.GP_IMM_ANY 3)])
		end
	    | _ => Crash.impossible"Mir_Cg bad args for ML_OFFSET"
	    val reg = MirTypes.GC.new()
	    val gc_reg = MirTypes.GC_REG reg
	    val gp_gc_reg = MirTypes.GP_GC_REG reg
	    val op_code =
	      [MirTypes.BINARY(MirTypes.LSR, gc_reg, reg2,
			       MirTypes.GP_IMM_ANY 2),
	       MirTypes.BINARY(MirTypes.ADDU, gc_reg, reg1, gp_gc_reg)]
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT gp_gc_reg),
	     Mir_Utils.combine(the_code,
			       ((Sexpr.ATOM(code @@ op_code), [],
				 NONE, Sexpr.NIL), [], [])))
	  end

          fun do_becomes (isIntegral,regs,the_code) =
	  let
            val scratch = MirTypes.GC.new()
            val scratch_reg = MirTypes.GC_REG scratch
            val forward = MirTypes.GC.new()
            val forward_reg = MirTypes.GC_REG forward
            val backward = MirTypes.GC.new()
            val backward_reg = MirTypes.GC_REG backward
	    val unlink_tag = MirTypes.new_tag()
	    val modified_tag = MirTypes.new_tag()
	    val already_on_ref_chain_tag = MirTypes.new_tag()
            val result = MirTypes.GC.new()
	    val res1 = MirTypes.GP_GC_REG result
	    val res2 = MirTypes.GC_REG result
	    val (reg1, arg, new_code) =
	      case regs of
		Mir_Utils.ONE(Mir_Utils.INT reg) => Mir_Utils.destruct_2_tuple reg
	      | Mir_Utils.LIST[Mir_Utils.INT reg1, arg] =>
		  let
		    val (new_reg, code) = Mir_Utils.send_to_reg(Mir_Utils.ONE arg)
		  in
		    (reg1, new_reg, code)
		  end
	    | _ => Crash.impossible"BECOMES of bad parms"
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT res1),
	     Mir_Utils.combine(the_code,
		     ((Sexpr.ATOM(new_code @@
		       [MirTypes.COMMENT"Update a reference cell",
                        MirTypes.STOREOP(MirTypes.STREF,
					 Mir_Utils.reg_from_gp arg,
                                         Mir_Utils.reg_from_gp reg1,
					 MirTypes.GP_IMM_ANY 9)] @@
		       (if isIntegral then
			  [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG already_on_ref_chain_tag)]
			else
                        [MirTypes.COMMENT"Do we need to unlink it",
                         MirTypes.STOREOP(MirTypes.LDREF, forward_reg,
					  Mir_Utils.reg_from_gp reg1,
					  MirTypes.GP_IMM_ANY 1),
			 MirTypes.TEST(MirTypes.BEQ, already_on_ref_chain_tag,
				       MirTypes.GP_GC_REG forward,
				       MirTypes.GP_IMM_INT 0),
			 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG unlink_tag)])),
		       (if isIntegral then [] else
			 [MirTypes.BLOCK(unlink_tag,
                                       [MirTypes.STOREOP(MirTypes.LDREF, backward_reg,
                                                         Mir_Utils.reg_from_gp reg1,
                                                         MirTypes.GP_IMM_ANY 5),
                                       MirTypes.TEST(MirTypes.BEQ, modified_tag,
                                                     MirTypes.GP_GC_REG backward,
                                                     MirTypes.GP_IMM_INT 0),
                                       MirTypes.COMMENT "Unlink the cell",
                                        MirTypes.STOREOP(MirTypes.STREF, backward_reg,
                                                         forward_reg,
                                                         MirTypes.GP_IMM_ANY 8),
                                        MirTypes.STOREOP(MirTypes.STREF, forward_reg,
                                                         backward_reg,
                                                         MirTypes.GP_IMM_ANY 4),
                                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG modified_tag)]),
                         MirTypes.BLOCK(modified_tag,
                                      [MirTypes.UNARY(MirTypes.MOVE, scratch_reg, MirTypes.GP_IMM_INT 0),
                                       MirTypes.STOREOP(MirTypes.STREF,
                                                        scratch_reg,
                                                        Mir_Utils.reg_from_gp reg1,
                                                        MirTypes.GP_IMM_ANY 1),
                                       MirTypes.STOREOP(MirTypes.LDREF, scratch_reg,
                                                        MirTypes.GC_REG MirRegisters.implicit,
                                                        MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain),
                                       MirTypes.STOREOP(MirTypes.STREF, scratch_reg,
                                                        Mir_Utils.reg_from_gp reg1,
                                                        MirTypes.GP_IMM_ANY 5),
                                       MirTypes.BINARY(MirTypes.ADDU, MirTypes.GC_REG MirRegisters.global,
                                                       reg1,
                                                       MirTypes.GP_IMM_ANY ~3),
                                       MirTypes.STOREOP(MirTypes.STREF,
                                                        MirTypes.GC_REG MirRegisters.global,
                                                        MirTypes.GC_REG MirRegisters.implicit,
                                                        MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain),
                                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG already_on_ref_chain_tag)])]),
                       SOME already_on_ref_chain_tag,
                       Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE, res2, MirTypes.GP_IMM_INT 0),
			MirTypes.COMMENT"Dummy result"]), [], [])))
	  end

          fun do_deref (regs,the_code) =
	  (case regs of
	    Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG reg)) =>
	      let
		val result = MirTypes.GC.new()
		val res1 = MirTypes.GC_REG result
	      in
		(Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
		  Mir_Utils.combine(the_code,
		    ((Sexpr.ATOM [MirTypes.STOREOP(MirTypes.LDREF, res1,
					MirTypes.GC_REG reg,
					MirTypes.GP_IMM_ANY 9),
		      MirTypes.COMMENT"Dereference a ref cell"],
		  [], NONE, Sexpr.NIL), [], [])))
	      end
          | _ => Crash.impossible"DEREF of non-gc")

          fun do_floor (regs,the_code,exn_code) =
	  let
	    val result = MirTypes.GC.new()
	    val result_gp = MirTypes.GP_GC_REG result
	    val result_reg = MirTypes.GC_REG result
	    val (exn_blocks, exn_tag_list) = exn_code
	    val exn_tag =
	      case exn_tag_list
	      of [tag] => tag
	      |  _ => Crash.impossible "no exn_tag for floor"
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT result_gp),
	      Mir_Utils.combine(the_code,
		(((case regs of
		  Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG reg)) =>
		    let
		      val fp_op = MirTypes.FP_REG(MirTypes.FP.new())
		    in
		      Sexpr.ATOM[MirTypes.STOREFPOP(MirTypes.FLD, fp_op,
					  MirTypes.GC_REG reg,
					  MirTypes.GP_IMM_ANY real_offset),
		        MirTypes.FLOOR(MirTypes.FTOI, exn_tag, result_reg,
				       fp_op)]
		    end
		| Mir_Utils.ONE(Mir_Utils.REAL reg) =>
		    Sexpr.ATOM[MirTypes.FLOOR(MirTypes.FTOI, exn_tag, result_reg, reg)]
		| _ => Crash.impossible"FLOOR bad value"),
		  exn_blocks, NONE, Sexpr.NIL), [], [])))
	  end

          fun do_real (regs,the_code) =
	  let
	    val result = MirTypes.FP_REG(MirTypes.FP.new())
	  in
	    (Mir_Utils.ONE(Mir_Utils.REAL result),
	     Mir_Utils.combine(the_code,
	       (((case regs of
		 Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_GC_REG _)) =>
		   Sexpr.ATOM[MirTypes.REAL(MirTypes.ITOF, result,
				  arg)]
	       | Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_IMM_INT _)) =>
		   Sexpr.ATOM[MirTypes.REAL(MirTypes.ITOF, result,
				    arg)]
	       | Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_IMM_SYMB _)) =>
		   Sexpr.ATOM[MirTypes.REAL(MirTypes.ITOF, result,
				    arg)]
	       | _ => Crash.impossible"convert of non-gc"),
		  [], NONE, Sexpr.NIL), [], [])))
	  end

      fun do_size (regs,the_code) =
	let
	  val (_, result, code) = make_size_code regs
	in
	  (Mir_Utils.ONE(Mir_Utils.INT result),
	   Mir_Utils.combine(the_code,
			     ((Sexpr.ATOM code, [], NONE,
			       Sexpr.NIL), [], [])))
	end
      fun do_char_chr(regs, the_code, exn_code) =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val (exn_blocks, exn_tag_list) = exn_code
	  val exn_tag =
	    case exn_tag_list
	    of [tag] => tag
	    |  _ => Crash.impossible "no exn_tag for chr"
	in
	  case regs of
	    Mir_Utils.ONE(Mir_Utils.INT reg) =>
	    let
	      val (new_reg, code) = Mir_Utils.send_to_reg(regs)
	      val byte_reg = MirTypes.GC.new()
	    in
	      (Mir_Utils.ONE(Mir_Utils.INT res1), Mir_Utils.combine(the_code,
		((Sexpr.ATOM(code @@
		  [MirTypes.TEST(MirTypes.BLT, exn_tag, new_reg,
				 MirTypes.GP_IMM_INT 0),
                   MirTypes.TEST(MirTypes.BGT, exn_tag, new_reg,
				MirTypes.GP_IMM_INT 255),
		  MirTypes.COMMENT"Fail if out of range 0 <= x <= 255",
		  MirTypes.ALLOCATE(MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT 2),
		  MirTypes.UNARY(MirTypes.MOVE, res2, new_reg)]), exn_blocks,
		NONE, Sexpr.NIL), [], [])))
	    end
	  | _ => Crash.impossible"do_char_chr"
	end

      fun do_chr (regs,the_code,exn_code) =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val (exn_blocks, exn_tag_list) = exn_code
	  val exn_tag =
	    case exn_tag_list
	    of [tag] => tag
	    |  _ => Crash.impossible "no exn_tag for chr"
	in
	  case regs of
	    Mir_Utils.ONE(Mir_Utils.INT reg) =>
	    let
	      val (new_reg, code) = Mir_Utils.send_to_reg(regs)
	      val byte_reg = MirTypes.GC.new()
	    in
	      (Mir_Utils.ONE(Mir_Utils.INT res1), Mir_Utils.combine(the_code,
		((Sexpr.ATOM(code @@
		  [MirTypes.TEST(MirTypes.BLT, exn_tag, new_reg,
				 MirTypes.GP_IMM_INT 0),
                   MirTypes.TEST(MirTypes.BGT, exn_tag, new_reg,
				MirTypes.GP_IMM_INT 255),
		  MirTypes.COMMENT"Fail if out of range 0 <= x <= 255",
		  MirTypes.ALLOCATE(MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT 2),
		  (* Allow space for null termination of string *)
                  MirTypes.UNARY(MirTypes.MOVE,MirTypes.GC_REG byte_reg,MirTypes.GP_IMM_ANY 0),
                  MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG byte_reg, res2,
                                   MirTypes.GP_IMM_ANY ~1),
		  MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG byte_reg,
                                  new_reg,MirTypes.GP_IMM_ANY 2),
                  MirTypes.STOREOP(MirTypes.STB, MirTypes.GC_REG byte_reg, res2,
                                   MirTypes.GP_IMM_ANY ~1),
		  MirTypes.NULLARY(MirTypes.CLEAN, MirTypes.GC_REG byte_reg)
		  ]), exn_blocks,
		NONE, Sexpr.NIL), [], [])))
	    end
	  | _ => Crash.impossible"do_chr"
	end

      fun do_ord  (regs,the_code,exn_code) =
	let
	  val (the_ptr, the_size, code) = make_size_code regs
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GC_REG result
	  val res2 = MirTypes.GP_GC_REG result
	  val (exn_blocks, exn_tag_list) = exn_code
	  val exn_tag =
	    case exn_tag_list
	    of [tag] => tag
	    |  _ => Crash.impossible "no exn_tag for ord"
	in
	  (Mir_Utils.ONE(Mir_Utils.INT res2),
	   Mir_Utils.combine(the_code,
		   ((Sexpr.ATOM(code @@
		     [MirTypes.TEST(MirTypes.BLE, exn_tag, the_size,
				    MirTypes.GP_IMM_INT 0),
		      MirTypes.STOREOP(MirTypes.LDB, res1, the_ptr,
				       MirTypes.GP_IMM_ANY ~1),
                      MirTypes.BINARY(MirTypes.ASL, res1,res2, MirTypes.GP_IMM_ANY 2)]),
		     exn_blocks, NONE, Sexpr.NIL), [], [])))
	end

      fun do_ordof (safe,regs,the_code,exn_code) =
	let
	  val (string, offset, new_code) = get_int_pair regs
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GC_REG result
	  val res2 = MirTypes.GP_GC_REG result
	  val (is_constant, constant_value) =
	    case offset of
	      MirTypes.GP_IMM_INT x => (true, x)
	    | _ => (false, 0)
	in
          if safe
            then
              let
                val (exn_blocks, exn_tag_list) = exn_code
                val exn_tag =
                  case exn_tag_list
                    of [tag] => tag
                     |  _ => Crash.impossible "no exn_tag for ordof"
              in
                if is_constant andalso constant_value < 0 then
                  (Mir_Utils.ONE(Mir_Utils.INT res2),
                   Mir_Utils.combine(the_code,
                                     ((Sexpr.ATOM[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)],
                                       exn_blocks, NONE, Sexpr.NIL),
                                      [], [])))
                else
                  let
                    val (the_ptr, the_size, code) =
                      make_size_code(Mir_Utils.ONE(Mir_Utils.INT string))
                    val final_instructions =
                      case offset of
                        MirTypes.GP_IMM_INT i =>
                          [MirTypes.STOREOP(MirTypes.LDB, res1, the_ptr,
                                            MirTypes.GP_IMM_ANY(i-1)),
                           MirTypes.BINARY(MirTypes.ASL, res1,res2,
                                           MirTypes.GP_IMM_ANY 2)]
                      | reg as MirTypes.GP_GC_REG _ =>
                          [MirTypes.TEST(MirTypes.BGT, exn_tag,
                                         MirTypes.GP_IMM_INT 0, reg),
                           MirTypes.BINARY(MirTypes.LSR, res1, reg,
                                           MirTypes.GP_IMM_ANY 2),
                           MirTypes.BINARY(MirTypes.ADDU, res1, res2,
                                           Mir_Utils.gp_from_reg the_ptr),
                           MirTypes.STOREOP(MirTypes.LDB, res1, res1,
                                            MirTypes.GP_IMM_ANY ~1),
                           MirTypes.BINARY(MirTypes.ASL, res1,res2,
                                           MirTypes.GP_IMM_ANY 2)]
                      | _ => Crash.impossible"Bad args for ordof"
                  in
                    (Mir_Utils.ONE(Mir_Utils.INT res2),
                     Mir_Utils.combine(the_code,
                                       ((Sexpr.ATOM(new_code @@ code @@
                                                    (MirTypes.TEST(MirTypes.BLE,exn_tag,the_size,offset) ::
                                                     final_instructions)),
                                       exn_blocks, NONE, Sexpr.NIL), [], [])))
                  end
              end
          else
            let
              val string_reg = Mir_Utils.reg_from_gp string
              val final_instructions =
                case offset of
                  MirTypes.GP_IMM_INT i =>
                    [MirTypes.STOREOP(MirTypes.LDB, res1, string_reg,
                                      MirTypes.GP_IMM_ANY(i-1)),
                     MirTypes.BINARY(MirTypes.ASL, res1,res2,
                                     MirTypes.GP_IMM_ANY 2)]
                | reg as MirTypes.GP_GC_REG _ =>
                    [MirTypes.BINARY(MirTypes.LSR, res1, reg,
                                     MirTypes.GP_IMM_ANY 2),
                     MirTypes.BINARY(MirTypes.ADDU, res1, res2,string),
                     MirTypes.STOREOP(MirTypes.LDB, res1, res1,MirTypes.GP_IMM_ANY ~1),
                     MirTypes.BINARY(MirTypes.ASL, res1,res2,MirTypes.GP_IMM_ANY 2)]
                | _ => Crash.impossible"Bad args for ordof"
            in
              (Mir_Utils.ONE(Mir_Utils.INT res2),
               Mir_Utils.combine(the_code,
                                 ((Sexpr.ATOM(new_code @@ final_instructions),
                                   [], NONE, Sexpr.NIL), [], [])))
            end
        end

      fun do_intabs (regs,the_code,exn_code) =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val tag = MirTypes.new_tag()
	  val (exn_blocks, exn_tag_list) = exn_code
	  val opcode = MirTypes.SUBS
	in
	  case regs of
	    Mir_Utils.ONE(Mir_Utils.INT reg) =>
	      (Mir_Utils.ONE(Mir_Utils.INT res1), Mir_Utils.combine(the_code,
	        ((Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE, res2, reg),
		  MirTypes.TEST(MirTypes.BGE, tag, reg, MirTypes.GP_IMM_INT 0),
		  MirTypes.TBINARY(opcode, exn_tag_list, res2,
				   MirTypes.GP_IMM_INT 0, reg),
                   MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag)], exn_blocks,
		  SOME tag,
		  Sexpr.ATOM[MirTypes.COMMENT"End of intabs"]), [], [])))
	  | _ => Crash.impossible"do_intabs"
	end

      (* This doesn't clean the argument register in the exceptional case,
	 because the exception is handled by trapping. *)
      fun do_int32abs (Mir_Utils.ONE(Mir_Utils.INT reg), the_code, exn_code) =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val tag = MirTypes.new_tag()
	  val (exn_blocks, exn_tag_list) = exn_code
	  val opcode = MirTypes.SUB32S
          val (w, arg_code, clean_arg_code) =
	    Mir_Utils.get_word32 (Mir_Utils.INT reg)
	  val tmp = MirTypes.GC.new()
	  val tmp2 = MirTypes.GC_REG tmp
	  val new_code =
	    arg_code @@
	    [MirTypes.UNARY(MirTypes.MOVE, res2, reg),
	     MirTypes.TEST(MirTypes.BGE, tag, w, MirTypes.GP_IMM_INT 0),
	     MirTypes.TBINARY
	     (opcode, exn_tag_list, tmp2, MirTypes.GP_IMM_INT 0, w)] @@
	    Mir_Utils.save_word32_in_reg(tmp, result) @@
	    [MirTypes.NULLARY(MirTypes.CLEAN, tmp2),
	     MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag)]
	in
	  (Mir_Utils.ONE(Mir_Utils.INT res1),
	   Mir_Utils.combine
	     (the_code,
	      ((Sexpr.ATOM new_code,
	        exn_blocks,
	        SOME tag,
	        Sexpr.ATOM clean_arg_code),
	       [], [])))
	end
	| do_int32abs _ = Crash.impossible "do_int32abs"

      fun do_call_c (regs,the_code) =
        let
          val res_reg = MirTypes.GC.new()
          fun make_args_for_call_c arg =
            let
              val get_result =
                [MirTypes.CALL_C,
                 MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
                                MirTypes.GP_GC_REG caller_arg),
                 MirTypes.COMMENT"And acquire result"]
            in
              case arg of
                Mir_Utils.ONE (Mir_Utils.INT(reg)) =>
                  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG caller_arg, reg) ::
                  get_result
              | _ => Crash.impossible "Bad arguments to make_args_for_call_c"
            end
        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG res_reg)),
           Mir_Utils.combine (the_code,
                              ((Sexpr.ATOM(make_args_for_call_c regs), [],
                                NONE, Sexpr.NIL),
                               [], [])))
        end

      fun do_cast_code (regs,the_code) = (regs,the_code)

      fun do_notb (regs,the_code) =
          let
            val (new_reg,code) =
	      Mir_Utils.send_to_new_reg regs
	      (*
              case regs of
                (arg as Mir_Utils.ONE(_)) => Mir_Utils.send_to_new_reg arg
              | _ => Crash.impossible "Not applied to more than one argument"
	      *)
            val result = MirTypes.GC.new()
          in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
             Mir_Utils.combine(the_code,
                     ((Sexpr.ATOM(code @@ [MirTypes.UNARY(MirTypes.NOT,MirTypes.GC_REG result,new_reg)]),
                       [],NONE,Sexpr.NIL),
                      [],[])))
          end

      fun word32_notb (regs,the_code) =
        let
          val (new_reg, arg_code, clean_arg_code) =
            case regs of
              (arg as Mir_Utils.ONE(reg)) => Mir_Utils.get_word32 reg
            | _ => Crash.impossible "Not32 applied to more than one argument"

          val result = MirTypes.GC.new()
          val res2 = MirTypes.GC_REG result
          val tmp = MirTypes.GC.new()
          val tmp2 = MirTypes.GC_REG tmp

	  val new_code =
	    MirTypes.ALLOCATE
	      (MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT 4)
	    :: arg_code
	    @@ [MirTypes.UNARY (MirTypes.NOT32, tmp2, new_reg),
	       MirTypes.STOREOP
	         (MirTypes.ST, tmp2, res2, MirTypes.GP_IMM_ANY ~1),
	       MirTypes.NULLARY(MirTypes.CLEAN, tmp2)]
	    @@ clean_arg_code
        in
	  (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
           Mir_Utils.combine
	     (the_code,
              ((Sexpr.ATOM new_code, [], NONE, Sexpr.NIL),
               [],[])))
        end


  (* convert32 stores an integer or word in a 4-byte string, the
     representation used for 32-bit values. *)
  fun convert32 (w, size, spills, calls) =
    let
      val result = MirTypes.GC.new()
      val res1 = MirTypes.GP_GC_REG result
      val res2 = MirTypes.GC_REG result
      val tmp = MirTypes.GC.new()

      val (use_zero, zero_reg) =
	if w = 0 then
	  case MirRegisters.zero of
	    SOME zero_reg => (true, zero_reg)
	  | _ => (false, MirRegisters.global)
	else
	  (false, MirRegisters.global)
	
      val opcodes =
	if MachSpec.has_immediate_stores then
	  [MirTypes.ALLOCATE
	   (MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT (size div 8)),
	   MirTypes.IMMSTOREOP
	   (MirTypes.ST, MirTypes.GP_IMM_ANY w , res2, MirTypes.GP_IMM_ANY ~1)]
	else
	  if use_zero then
	    [MirTypes.ALLOCATE
	     (MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT (size div 8)),
	     MirTypes.STOREOP
	     (MirTypes.ST, MirTypes.GC_REG zero_reg , res2, MirTypes.GP_IMM_ANY ~1)]
	  else
	    [MirTypes.ALLOCATE
	     (MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT (size div 8)),
	     MirTypes.UNARY
	     (MirTypes.MOVE, MirTypes.GC_REG tmp, MirTypes.GP_IMM_ANY w),
	     MirTypes.STOREOP
	     (MirTypes.ST, MirTypes.GC_REG tmp, res2, MirTypes.GP_IMM_ANY ~1),
	     MirTypes.NULLARY(MirTypes.CLEAN, MirTypes.GC_REG tmp)]

      val code =
        ((Sexpr.ATOM opcodes, [], NONE, Sexpr.NIL), [], [])
    in
      (Mir_Utils.ONE(Mir_Utils.INT res1), code, RuntimeEnv.EMPTY, spills, calls)
    end

  fun mir_cg
    error_info
      (options as Options.OPTIONS {compiler_options,print_options,...},
     lambda_exp, filename, mapping) =
  let

    (* Reset the virtual register counters *)

    val Options.COMPILEROPTIONS {generate_debug_info,
                                 debug_variables,
                                 generate_moduler,
                                 intercept,
                                 interrupt,
                                 opt_handlers,
                                 opt_self_calls,
                                 opt_tail_calls,
				 local_functions,
                                 ...} =
      compiler_options

    (* We need to know which of the optimisations at the lambda stage
       which are controlled by the debugging and local_functions options
       are being done. The following code should be kept consistent
       with that in lambda/_simplelambda.sml#optimise.
    *)

    (* Full lambda optimisation is done only if no debug options set *)

    val do_full_lambda_opt = not generate_moduler andalso
                             not generate_debug_info andalso
                             not debug_variables andalso
                             not intercept

    (* local-function optimisations are done only if already doing full
     lambda optimisation *)

    val do_local_functions = do_full_lambda_opt andalso local_functions


    val _ =
      (MirTypes.GC.reset();
       MirTypes.NonGC.reset();
       MirTypes.FP.reset())

    val name_of_setup_function = "<Setup>[" ^ filename ^ ":1,1]"

    (* Always insert interrupt if the flag is set *)
    (* Not relevant if no tail optimisation *)
    val insert_interrupt = interrupt

    (* Variable debugging stuff *)
    val variable_debug = debug_variables orelse generate_moduler

    (* Note this ref is _not_ global *)

    val opt_first_spill : RuntimeEnv.Offset ref list ref option =
      if variable_debug then
        SOME (ref ( [ref(RuntimeEnv.OFFSET1 1)]))
      else
        NONE

    fun get_current_spills () =
      case opt_first_spill of
        NONE => Crash.impossible "current_spills:mir_cg:mir_cg"
      | SOME first_spill => !first_spill

    (* Make a function to reset the spills ref (if there is one) *)
    fun spill_restorer () =
      case opt_first_spill of
        NONE => (fn _ => ())
      | SOME first_spill =>
          let
            val old_spill = !first_spill
          in
            fn _ => first_spill := old_spill
          end

    (* Reset spills to initial state.  Return the new initial state *)
    fun initialize_spills () =
      case opt_first_spill of
        NONE => []
      | SOME first_spill =>
          let
            val spill = [ref(RuntimeEnv.OFFSET1 1)]
          in
            (first_spill := spill;
             spill)
          end

    (* Set the spills to the given value *)
    fun reset_spills spill =
      case opt_first_spill of
        NONE => ()
      | SOME first_spill =>
          first_spill := spill

    (* Add the given spill to the front of the list *)
    (* This only seems to be used during HANDLEs *)
    fun append_spill spill =
      case opt_first_spill of
        NONE => ()
      | SOME first_spill =>
          first_spill := spill::(!first_spill)

    fun head_spill [spill] = spill
      | head_spill _ = Crash.impossible "head_spill:mir_cg:mir_cg"

    fun new_ref_slot slot = ref (RuntimeEnv.OFFSET1 slot)

    (* calls is some kind of index of the calls made *)

    fun make_call_code(calls,code) =
      if variable_debug then
        let
          val reg = MirTypes.GC.new()
          val current_spills = get_current_spills ()
          val ((code,bs,ts,ops),vs,ps) = code
        in
          ((Lists.reducer
            (fn (ref_slot,code) =>
             Sexpr.CONS(Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG reg,
                                                   MirTypes.GP_IMM_INT (calls)),
                                    MirTypes.STOREOP(MirTypes.STREF,MirTypes.GC_REG (reg),
                                                     MirTypes.GC_REG fp,
                                                     MirTypes.GP_IMM_SYMB (MirTypes.GC_SPILL_SLOT
                                                                           (MirTypes.DEBUG (ref_slot,
                                                                                            "call_code"))))],
                        code))
            (current_spills,code),bs,ts,ops),vs,ps)
        end
      else
        code

    (* End of variable debugging stuff *)

    val (prim_to_lambda, new_lambda_exp) = make_prim_info (compiler_options, lambda_exp)

    (* Get the lambda variables representing all the functions *)

    val top_lambdas = SimpleUtils.function_lvars new_lambda_exp

    (* Construct a loop entry tag for every function *)

    val top_lambda_loop_tags =
      IntMap.apply
      (lists_reducel
       (fn (tree, lv) =>
	IntMap.define(tree, lv, MirTypes.new_tag()))
       (IntMap.empty, top_lambdas))

(*
    val _ = Diagnostic.output 5
      (fn _ => (["Lambdas representing functions"] @@
                (map (fn x => " " ^ LambdaTypes.printLVar x)
                 top_lambdas)))
*)

    (* Count the static gc objects *)
    val (new_exp_and_size as {size=number_of_gc_objects, lexp=new_lambda_exp},debug_information) =
      AugLambda.count_gc_objects (options,new_lambda_exp,
                                  true (* generate_debug_info *), (* always generate debug info, for now *)
                                  mapping,
                                  name_of_setup_function)

    (* Construct references to external values *)
    (* top_closure is the static object *)
    (* top_tags_list is the list of corresponding tags *)
    (* The others are lists of external references *)

    val (new_exp_and_size, top_tags_list, top_closure,
         (ext_string_list,ext_var_list,ext_exn_list,ext_str_list,ext_fun_list)) =
      do_externals (new_exp_and_size,number_of_gc_objects)

    (* new_lambda_exp is what cg_sub gets called on *)

    val {lexp = new_lambda_exp, ... } = new_exp_and_size

    (* And make some mapping functions to get external indices *)

    local
      val make_str_order_tree = NewMap.from_list ((op<):string*string->bool, op =)
      val ext_string_tree = make_str_order_tree ext_string_list
      val ext_var_tree = make_str_order_tree ext_var_list
      val ext_exn_tree = make_str_order_tree ext_exn_list
      val ext_str_tree = make_str_order_tree ext_str_list
      val ext_fun_tree = make_str_order_tree ext_fun_list
    in
      val find_ext_string = NewMap.apply ext_string_tree
      val find_ext_var = NewMap.apply ext_var_tree
      val find_ext_exn = NewMap.apply ext_exn_tree
      val find_ext_str = NewMap.apply ext_str_tree
      val find_ext_fun = NewMap.apply ext_fun_tree
    end

    fun append_runtime_envs(env1,env2) =
      case !env1 of
        RuntimeEnv.LIST(env) => RuntimeEnv.LIST(env@@[env2])
      | RuntimeEnv.EMPTY => env2
      | env1 => RuntimeEnv.LIST[env1,env2]

    fun has_local_functions ({lexp = AugLambda.FN (vl,e,s,info),size} :: _) =
      LambdaTypes.isLocalFn info
      | has_local_functions _ = false

    (* Put the returned value in the right place *)
    fun make_exit_code res =
      let
        val restemp = MirTypes.GC.new ()
      in
        ((Sexpr.ATOM
          (Mir_Utils.send_to_given_reg(res, restemp) @@
           [MirTypes.UNARY(MirTypes.MOVE,
                           MirTypes.GC_REG callee_arg,
                           MirTypes.GP_GC_REG restemp),
            MirTypes.RTS]),
          [], NONE, Sexpr.NIL), [], [])
      end

    (* Code generate for a variable binding *)

    fun cg_bind({lexp=lexp, size=gc_in_arg},
                env, static_offset,start_at,

                (closure,funs_in_closure, fn_tag_list, local_fns),
                spills,calls) =
      let
        (* Code generate the expression *)
	val (regs,the_code,runtime_env,spills,calls) =
	  cg_sub(lexp, env, static_offset, start_at,false,
                 (closure,funs_in_closure, fn_tag_list, local_fns),spills,calls)
        (* Now assemble the result into a single register *)
	val (reg, more_code) =
          case regs of
            Mir_Utils.ONE(Mir_Utils.INT reg) =>
              (case reg of
                 MirTypes.GP_GC_REG x =>
                   (MirTypes.GC x, [])
               | MirTypes.GP_NON_GC_REG x =>
                   (MirTypes.NON_GC x, [])
               | MirTypes.GP_IMM_INT _ =>
                   let
                     val new_reg = MirTypes.GC.new()
                   in
                     (MirTypes.GC new_reg,
                      [MirTypes.UNARY(MirTypes.MOVE,
                                      MirTypes.GC_REG new_reg,
                                      reg)])
                   end
               | MirTypes.GP_IMM_SYMB _ =>
                   let
                     val new_reg = MirTypes.GC.new()
                   in
                     (MirTypes.GC new_reg,
                      [MirTypes.UNARY(MirTypes.MOVE,
                                      MirTypes.GC_REG new_reg,
                                      reg)])
                   end
               | _ => Crash.impossible"Untagged value to LET")
          | Mir_Utils.ONE(Mir_Utils.REAL(MirTypes.FP_REG fp_reg)) =>
              (MirTypes.FLOAT fp_reg, [])
          | Mir_Utils.LIST many =>
              let val (gc_reg, more_code) = Mir_Utils.tuple_up many
              in
                (MirTypes.GC gc_reg, more_code)
              end
      in
	(reg,
	 Mir_Utils.combine(the_code,((Sexpr.ATOM more_code, [], NONE,Sexpr.NIL),[], [])),
	 static_offset + gc_in_arg, start_at + gc_in_arg,runtime_env,spills,calls)
      end

    (* Code generate a list of bindings, typically for a let *)
    and cg_bind_list([], env,static_offset, start_at,_,spills,calls) =
      (no_code, env, static_offset, start_at,RuntimeEnv.LIST(nil),spills,calls)

    | cg_bind_list((lv, le) :: rest, env, static_offset, start_at,
                   (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls) =
      let
	val (reg, code, static_offset', start_at',runtime_env,spills,calls) =
	  cg_bind(le, env, static_offset, start_at,
                  (closure,funs_in_closure,fn_tag_list,local_fns),spills,calls)
	val env' = Mir_Env.add_lambda_env ((lv, reg), env)
	val (new_code, env, static_offset, start_at, runtime_envs,spills,calls) =
	  cg_bind_list (rest, env', static_offset', start_at',
                        (closure,funs_in_closure, fn_tag_list,local_fns), spills,calls)
        val runtime_envs =
          case runtime_envs of
            RuntimeEnv.LIST runtime_envs => runtime_envs
          | _ => Crash.impossible "cg_bind_list:_mir_cg.sml"
      in
	(Mir_Utils.combine(code, new_code), env, static_offset, start_at,
         RuntimeEnv.LIST(runtime_env::runtime_envs),spills,calls)
      end

    (* This is used for compiling function bodies *)
    and cg_letrec_sub (lexp,env,static_offset,start_at,tail_position,
                         (closure,funs_in_closure,fn_tag_list,local_fns),
                         spills,calls) =
        case lexp of
          AugLambda.LETREC (lv_list,le_list,{lexp = body_exp,...}) =>
            if not (has_local_functions le_list)
              then
                cg_sub (lexp,env,static_offset,start_at,tail_position,
                        (closure,funs_in_closure,fn_tag_list,local_fns),
                        spills,calls)
            else
              let
                (* val _ = print (Int.toString (Lists.length lv_list) ^ " in local\n") *)

(*
                val _ =
                  Lists.iterate
                  (fn {lexp=AugLambda.FN((lvl,fp_args),e,name,info),...} =>
                   (case fp_args of [] => ()
                 | _ => (print ("Local " ^ name ^ ":");
                         Lists.iterate (fn v => print (N v ^ " ")) fp_args;
                         print "\n"))
                | _ => ())
                  le_list
*)

                val vars = map #1 lv_list
                val tags = map (fn _ => MirTypes.new_tag ()) vars

                val args_bodies = map
                                  (fn {lexp = AugLambda.FN((args,fp_args),body,_,_),...} =>
                                   ((args,fp_args),body)
                                   | _ => Crash.impossible ("Bad function in letrec"))
                                  le_list
                val full_args_list = map #1 args_bodies
                val args_list = map #1 full_args_list
                val fp_args_list = map #2 full_args_list
                val bodies = map #2 args_bodies
                val arg_regs_list = map (map (fn _ => MirTypes.GC.new ())) args_list
                val fp_arg_regs_list = map (map (fn _ => MirTypes.FP.new ())) fp_args_list

                val new_local_functions =
                  local_fns @@
                  map
                  (fn (var,tag,args,fp_args) => (var,(tag,(args,fp_args))))
                  (zip4 (vars,tags, arg_regs_list,fp_arg_regs_list))

                (* The environments for compiling the bodies of the local functions *)
                val new_envs =
                  map
                  (fn (args,regs,fp_args,fp_regs) =>
                   let
                     val env =
                       Lists.reducel
                       (fn (env,(arg,reg)) => Mir_Env.add_lambda_env ((arg,MirTypes.GC reg),env))
                       (Mir_Env.empty_lambda_env, zip2 (args,regs))
                   in
                     Lists.reducel
                     (fn (env,(arg,reg)) => Mir_Env.add_lambda_env ((arg,MirTypes.FLOAT reg),env))
                     (env, zip2 (fp_args,fp_regs))
                   end)
                  (zip4 (args_list,arg_regs_list,fp_args_list,fp_arg_regs_list))

                val start_offsets = ref 0
                val locals_code =
                  map
                  (fn ({lexp=body,size=body_size},new_env,tag) =>
                   let
                     val (regs, body_code,runtime_env,spills,calls) =
                       cg_sub (body,new_env,static_offset + !start_offsets,start_at + !start_offsets,tail_position,
                               (closure,funs_in_closure,fn_tag_list,new_local_functions),
                               spills,calls)
                     val ((first,blocks,tag_opt,last),vals,procs) =
                       Mir_Utils.combine (body_code, make_exit_code (regs))
                     val _ = start_offsets := !start_offsets + body_size
                   in
                     (MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr first) ::
                      blocks @@
                      (case tag_opt of
                         NONE => []
                       | SOME tag =>
                           [MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr last)]),
                      vals,
                      procs)
                   end)
                  (zip3 (bodies,new_envs,tags))

                fun appendl' ([],[],acc) = rev acc
                  | appendl' (a::b, rest, acc) = appendl' (b,rest,a::acc)
                  | appendl' ([], l :: rest, acc) = appendl' (l,rest,acc)
                fun appendl l = appendl' ([],l,[])

                val local_blocks = appendl (map #1 locals_code)
                val local_vals = appendl (map #2 locals_code)
                val local_procs = appendl (map #3 locals_code)

                (* And finally the body *)
                val (regs, ((first, body_blocks, tag_opt, last), body_vals, body_procs),runtime_env,spills,calls) =
                  cg_sub (body_exp,env,static_offset + !start_offsets,start_at + !start_offsets,tail_position,
                          (closure,funs_in_closure,fn_tag_list,new_local_functions),
                          spills,calls)
              in
                (regs, ((first, body_blocks @@ local_blocks, tag_opt, last), body_vals @@ local_vals, body_procs @@ local_procs),
                 runtime_env,spills,calls)
              end

        | _ =>
            cg_sub (lexp,env,static_offset,start_at,tail_position,
                    (closure,funs_in_closure,fn_tag_list,local_fns),
                    spills,calls)

    (* Code generate for an expression *)
    (* Application of builtin case *)
    and cg_sub(arg as AugLambda.APP ({lexp=AugLambda.BUILTIN(prim,primTy), ...},
                                     ([{lexp=lexp, size=gc_objects_in_parm}],[]),_),
               env,static_offset, start_at, tail_position,
               (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls) =
      (* env is the local lambda to register environment
       closure is the free lambda to offsets from callee_closure environment
       static_offset is the offset within the closure of the current function
       of static garbage collectable objects (functions and non-integer scons)
       start_at is the offset within the outermost closure of the tags
       for the static garbage collectable objects
       funs_in_closure is the number of functions following callee_closure
       within the current closure
       *)
    let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out,
		 "In cg_sub(APP), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating APP(BUILTIN...)\n",
	LambdaPrint.string_of_lambda arg])
*)

    in
    (case prim of
       (* External loads are treated specially *)
       Pervasives.LOAD_STRING => load_external (lexp,find_ext_string, RuntimeEnv.EMPTY,spills,calls)
     | Pervasives.LOAD_VAR => load_external (lexp,find_ext_var, RuntimeEnv.EMPTY,spills,calls)
     | Pervasives.LOAD_EXN => load_external (lexp,find_ext_exn, RuntimeEnv.EMPTY,spills,calls)
     | Pervasives.LOAD_STRUCT => load_external (lexp,find_ext_str, RuntimeEnv.EMPTY,spills,calls)
     | Pervasives.LOAD_FUNCT => load_external (lexp,find_ext_fun, RuntimeEnv.EMPTY,spills,calls)
     | Pervasives.GET_IMPLICIT => do_get_implicit (lexp,RuntimeEnv.EMPTY,spills,calls)
     | _ =>
         let
           (* Otherwise, we code generate for the argument *)
           val (regs, the_code,runtime_env',spills,calls') =
             cg_sub(lexp, env, static_offset, start_at, false,
                    (closure,funs_in_closure,fn_tag_list,local_fns),spills,calls)

           val calls : int ref = ref(calls')
           val spills : (int * int * int) ref = ref(spills)
           val runtime_env : RuntimeEnv.RuntimeEnv ref = ref(RuntimeEnv.BUILTIN)

           (* Don't like the refs here *)
           fun exn_code_for_prim prim =
             let
               fun scan [] = ([], [])
                 | scan (exception_needed::rest) =
                  let
                      val exception_packet =
                        AugLambda.VAR(prim_to_lambda exception_needed)

                      val (exn_f, exn_b, exn_o, exn_l) =
                        case cg_sub (AugLambda.RAISE({lexp=AugLambda.STRUCT
                                                      [{lexp=exception_packet, size=0},
                                                       {lexp=AugLambda.STRUCT[], size=0}],
                                                      size=0}),
                                     env, static_offset, start_at, false,
                                     (closure,funs_in_closure,fn_tag_list,local_fns),!spills,!calls)
                          of (_, ((exn_f, exn_b, exn_o, exn_l), [], []),
                              runtime_env',spills',calls') =>
                            (calls := calls';
                             runtime_env := append_runtime_envs(runtime_env,runtime_env');
                             spills := spills';
                             (exn_f, exn_b, exn_o, exn_l))
                            | _ => Crash.impossible"Bad code for RAISE primitive exception"

                      val _ =
                        case exn_o of
                          NONE => ()
                        | _ => Crash.impossible"Too much raise code"

                      val exn_tag = MirTypes.new_tag()
                      val (rest_blocks,rest_tags) = scan rest
                    in
                      (MirTypes.BLOCK(exn_tag, Mir_Utils.contract_sexpr exn_f) :: exn_b @@ rest_blocks,
                       exn_tag :: rest_tags)
                    end
             in
               scan (MachPerv.implicit_references prim)
             end

           (* Need to put poly eq here because of recursive call *)
           fun do_eq (regs,the_code) =
             let
(*
               val _ = Diagnostic.output 3 (fn _ => ["Mir_Cg: Translating polymorphic equality"])
*)
               val primitive =
                 case MachPerv.implicit_references Pervasives.EQ
                   of [p] => p
                    | _ =>
                        Crash.impossible
                        ("Mir_Cg: I was expecting the implicit reference of EQ " ^
                         "to be a single external thing!")

               val polymorphic_equality =
                 AugLambda.VAR(prim_to_lambda primitive)
               val (reg, extra_code) =
                 case Mir_Utils.send_to_reg regs of
                   (MirTypes.GP_GC_REG reg, code) => (reg, code)
                 | _ => Crash.impossible"Mir_Utils.send_to_reg doesn't give GP_GC_REG"
               val extra_code = ((Sexpr.ATOM extra_code, [], NONE,Sexpr.NIL), [], [])
               val lvar = LambdaTypes.new_LVar()
               val env' = Mir_Env.add_lambda_env((lvar, MirTypes.GC reg), env)
               val (reg, poly_code,runtime_env',spills',calls') =
                 cg_sub(AugLambda.APP({lexp=polymorphic_equality, size=0},
                                      ([{lexp=AugLambda.VAR lvar, size=0}],[]),
                                      Debugger_Types.null_backend_annotation), env',
                        static_offset + gc_objects_in_parm,
                        start_at + gc_objects_in_parm,
                        tail_position,
                        (closure,funs_in_closure,fn_tag_list,local_fns),!spills,!calls)
               val _ = calls := calls'
               val _ = spills := spills'
               val _ = runtime_env := append_runtime_envs(runtime_env,runtime_env')
             in
               case regs of
                 Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] =>
                   let
                     val good_tag = MirTypes.new_tag()  (* For true *)
                     val bad_tag = MirTypes.new_tag()   (* For false *)
                     val test_tag = MirTypes.new_tag()  (* For dunno *)
                     val final_tag = MirTypes.new_tag() (* Where we end up *)
                     val res_reg = MirTypes.GC.new()
                     val gc_res_reg = MirTypes.GC_REG res_reg
                     val new_code =
                       (Sexpr.ATOM[MirTypes.COMMENT"Start of poly eq",
                                   MirTypes.TEST(MirTypes.BEQ, good_tag, reg1,
                                                 reg2),
                                   (* Ok if equal values in the registers *)
                                   MirTypes.BINARY(MirTypes.AND,
                                                   MirTypes.GC_REG(MirRegisters.global),
                                                   reg1, MirTypes.GP_IMM_ANY 3),
                                   MirTypes.BINARY(MirTypes.AND,
                                                   MirTypes.GC_REG MirRegisters.global, reg2,
                                                   MirTypes.GP_GC_REG MirRegisters.global),
                                   MirTypes.TEST(MirTypes.BNE, bad_tag,
                                                 MirTypes.GP_GC_REG(MirRegisters.global),
                                                 MirTypes.GP_IMM_ANY 1),
				   (* Warning: On the MIPS we implement this by *)
				   (* decrementing global, in order to avoid *)
				   (* overloading global and thus always entering *)
				   (* the rts to do polymorphic equality *)
				   (* If you change this, polymorphic equality *)
				   (* on the mips may stop working, *)
				   (* or may lose efficiency *)

                                   (* Is second one an ordinary pointer *)
                                   MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG test_tag)],
                       [MirTypes.BLOCK(good_tag,
                                       [MirTypes.UNARY(MirTypes.MOVE, gc_res_reg,
                                                       MirTypes.GP_IMM_INT 1),
                                        MirTypes.BRANCH(MirTypes.BRA,
                                                        MirTypes.TAG final_tag)]),
                       MirTypes.BLOCK(bad_tag,
                                      [MirTypes.UNARY(MirTypes.MOVE, gc_res_reg,
                                                      MirTypes.GP_IMM_INT 0),
                                       MirTypes.BRANCH(MirTypes.BRA,
                                                       MirTypes.TAG final_tag)])],
                       SOME test_tag, Sexpr.NIL)
                     val new_code =
                       Mir_Utils.combine
                       (the_code,
                        Mir_Utils.combine
                        ((new_code, [], []),
                         Mir_Utils.combine
                         (Mir_Utils.combine(extra_code, poly_code),
                          ((Sexpr.ATOM(Mir_Utils.send_to_given_reg(reg, res_reg) @@
                                       [MirTypes.BRANCH(MirTypes.BRA,
                                                        MirTypes.TAG final_tag)]),
                          [], SOME final_tag,
                          Sexpr.ATOM[MirTypes.COMMENT"End of poly eq"]),
                          [], []))))
                   in
                     (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG res_reg)),
                      new_code)
                   end
               | _ =>
                   (reg,
                    Mir_Utils.combine(the_code,
                                      Mir_Utils.combine(extra_code, poly_code)))
             end

      (* Primitives *)
      val (result, code) =
      case prim of
	Pervasives.IDENT_FN => Crash.impossible"Unexpanded IDENT_FN"
      | Pervasives.ENTUPLE => do_external_prim prim
      | Pervasives.ML_REQUIRE => do_external_prim prim
      | Pervasives.ML_CALL => do_ml_call (regs,the_code)
      | Pervasives.ML_OFFSET => do_ml_offset (regs,the_code)
      | Pervasives.LOAD_VAR => do_external_prim prim
      | Pervasives.LOAD_EXN => do_external_prim prim
      | Pervasives.LOAD_STRUCT => do_external_prim prim
      | Pervasives.LOAD_FUNCT => do_external_prim prim
      | Pervasives.REF => do_ref (regs,the_code)
      | Pervasives.BECOMES => do_becomes (TypeUtils.is_integral2 primTy,regs,the_code)
      | Pervasives.DEREF => do_deref (regs,the_code)
      | Pervasives.EXORD => Crash.impossible"APP of non-function"
      | Pervasives.EXCHR => Crash.impossible"APP of non-function"
      | Pervasives.EXDIV => Crash.impossible"APP of non-function"
      | Pervasives.EXSQRT => Crash.impossible"APP of non-function"
      | Pervasives.EXEXP => Crash.impossible"APP of non-function"
      | Pervasives.EXLN => Crash.impossible"APP of non-function"
      | Pervasives.EXIO => Crash.impossible"APP of non-function"
      | Pervasives.EXMATCH => Crash.impossible"APP of non-function"
      | Pervasives.EXBIND => Crash.impossible"APP of non-function"
      | Pervasives.EXINTERRUPT => Crash.impossible"APP of non-function"
      | Pervasives.EXOVERFLOW => Crash.impossible"APP of non-function"
      | Pervasives.EXRANGE => Crash.impossible"APP of non-function"
      | Pervasives.MAP => do_external_prim prim
      | Pervasives.UMAP => do_external_prim prim
      | Pervasives.REV => do_external_prim prim
      | Pervasives.NOT => Crash.impossible"Primitive NOT"
      | Pervasives.ABS => Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.FLOOR => do_floor (regs,the_code,exn_code_for_prim prim)
      | Pervasives.REAL => do_real (regs,the_code)
      | Pervasives.SQRT => tagged_unary_fcalc(MirTypes.FSQRTV,regs,the_code,exn_code_for_prim prim)
      | Pervasives.SIN => unary_fcalc (MirTypes.FSIN,regs,the_code)
      | Pervasives.COS => unary_fcalc (MirTypes.FCOS,regs,the_code)
      | Pervasives.ARCTAN => unary_fcalc (MirTypes.FATAN,regs,the_code)
      | Pervasives.EXP => tagged_unary_fcalc(MirTypes.FETOXV,regs,the_code,exn_code_for_prim prim)
      | Pervasives.LN => tagged_unary_fcalc(MirTypes.FLOGEV,regs,the_code,exn_code_for_prim prim)
      | Pervasives.SIZE => do_size (regs,the_code)
      | Pervasives.CHR => do_chr (regs,the_code,exn_code_for_prim prim)
      | Pervasives.ORD => do_ord (regs,the_code,exn_code_for_prim prim)
      | Pervasives.CHARCHR => do_char_chr (regs,the_code,exn_code_for_prim prim)
      | Pervasives.CHARORD => (regs, the_code) (* Ord on char is nop *)
      | Pervasives.ORDOF => do_ordof (true,regs,the_code,exn_code_for_prim prim)
      | Pervasives.EXPLODE => do_external_prim prim
      | Pervasives.IMPLODE => do_external_prim prim
      | Pervasives.FDIV => tagged_binary_fcalc(MirTypes.FDIVV,regs,the_code,exn_code_for_prim prim)
      | Pervasives.DIV => Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.MOD => Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.INTDIV => tagged_binary_calc(MirTypes.DIVS,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INTMOD => tagged_binary_calc(MirTypes.MODS,regs,the_code,exn_code_for_prim prim)
      | Pervasives.PLUS => Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.STAR => Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.MINUS => Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.HAT => do_external_prim prim
      | Pervasives.AT => do_external_prim prim
      | Pervasives.NE => do_external_prim prim
      | Pervasives.LESS => Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.GREATER => Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.LESSEQ => Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.GREATEREQ => Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.O => Crash.impossible"Primitive composition"
      | Pervasives.UMINUS => Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.EQFUN => do_external_prim prim (* This shouldn't ever occur *)
      | Pervasives.EQ => do_eq (regs,the_code)
      | Pervasives.REALPLUS => tagged_binary_fcalc(MirTypes.FADDV,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INTPLUS => tagged_binary_calc(MirTypes.ADDS,regs,the_code,exn_code_for_prim prim)
      | Pervasives.UNSAFEINTPLUS => binary_calc (MirTypes.ADDU,regs,the_code)
      | Pervasives.UNSAFEINTMINUS => binary_calc (MirTypes.SUBU,regs,the_code)
      | Pervasives.WORDPLUS => binary_calc (MirTypes.ADDU,regs,the_code)
      | Pervasives.WORDMINUS => binary_calc (MirTypes.SUBU,regs,the_code)
      | Pervasives.WORDSTAR => binary_calc (MirTypes.MULU,regs,the_code)
      | Pervasives.WORDDIV => tagged_binary_calc (MirTypes.DIVU,regs, the_code, exn_code_for_prim prim)
      | Pervasives.WORDMOD => tagged_binary_calc (MirTypes.MODU,regs, the_code, exn_code_for_prim prim)
      | Pervasives.INT32PLUS => tagged32_binary_calc (MirTypes.ADD32S,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INT32MINUS => tagged32_binary_calc (MirTypes.SUB32S,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INT32STAR => tagged32_binary_calc (MirTypes.MUL32S,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INT32DIV => tagged32_binary_calc (MirTypes.DIV32S,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INT32MOD => tagged32_binary_calc (MirTypes.MOD32S,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INT32UMINUS => int32_unary_negate(MirTypes.SUB32S,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INT32ABS => do_int32abs (regs,the_code,exn_code_for_prim prim)
      | Pervasives.WORD32PLUS => untagged32_binary_calc (MirTypes.ADDU,regs,the_code)
      | Pervasives.WORD32MINUS => untagged32_binary_calc (MirTypes.SUBU,regs,the_code)
      | Pervasives.WORD32STAR => untagged32_binary_calc (MirTypes.MUL32U,regs,the_code)
      | Pervasives.WORD32DIV => tagged32_binary_calc (MirTypes.DIV32U,regs,the_code,exn_code_for_prim prim)
      | Pervasives.WORD32MOD => tagged32_binary_calc (MirTypes.MOD32U,regs,the_code,exn_code_for_prim prim)
      | Pervasives.REALSTAR => tagged_binary_fcalc(MirTypes.FMULV,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INTSTAR => tagged_binary_calc(MirTypes.MULS,regs,the_code,exn_code_for_prim prim)
      | Pervasives.REALMINUS => tagged_binary_fcalc(MirTypes.FSUBV,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INTMINUS => tagged_binary_calc(MirTypes.SUBS,regs,the_code,exn_code_for_prim prim)
      | Pervasives.REALUMINUS => tagged_unary_fcalc(MirTypes.FNEGV,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INTUMINUS => unary_negate(MirTypes.SUBS,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INTLESS => test (MirTypes.BLT,regs,the_code)
      | Pervasives.CHARLT => test (MirTypes.BLT,regs,the_code)
      | Pervasives.WORDLT => test (MirTypes.BLO,regs,the_code)
      | Pervasives.REALLESS => ftest(MirTypes.FBLT, true,regs,the_code)
      | Pervasives.INTGREATER => test (MirTypes.BGT,regs,the_code)
      | Pervasives.CHARGT => test (MirTypes.BGT,regs,the_code)
      | Pervasives.WORDGT => test (MirTypes.BHI,regs,the_code)
      | Pervasives.REALGREATER => ftest(MirTypes.FBLT, false,regs,the_code)
      | Pervasives.INTLESSEQ => test (MirTypes.BLE,regs,the_code)
      | Pervasives.CHARLE => test (MirTypes.BLE,regs,the_code)
      | Pervasives.WORDLE => test (MirTypes.BLS,regs,the_code)
      | Pervasives.REALLESSEQ => ftest(MirTypes.FBLE, true,regs,the_code)
      | Pervasives.INTGREATEREQ => test (MirTypes.BGE,regs,the_code)
      | Pervasives.CHARGE => test (MirTypes.BGE,regs,the_code)
      | Pervasives.WORDGE => test (MirTypes.BHS,regs,the_code)
      | Pervasives.REALGREATEREQ => ftest(MirTypes.FBLE, false,regs,the_code)
      | Pervasives.INTEQ => test (MirTypes.BEQ,regs,the_code)
      | Pervasives.INTNE => test (MirTypes.BNE,regs,the_code)
      | Pervasives.CHAREQ => test (MirTypes.BEQ,regs,the_code)
      | Pervasives.CHARNE => test (MirTypes.BNE,regs,the_code)
      | Pervasives.WORDEQ => test (MirTypes.BEQ,regs,the_code)
      | Pervasives.WORDNE => test (MirTypes.BNE,regs,the_code)
      | Pervasives.REALEQ => ftest(MirTypes.FBEQ, true,regs,the_code)
      | Pervasives.REALNE => ftest(MirTypes.FBNE, true,regs,the_code)
      | Pervasives.INT32EQ => test32 (MirTypes.BEQ,regs,the_code)
      | Pervasives.INT32NE => test32 (MirTypes.BNE,regs,the_code)
      | Pervasives.INT32LESS => test32 (MirTypes.BLT,regs,the_code)
      | Pervasives.INT32LESSEQ => test32 (MirTypes.BLE,regs,the_code)
      | Pervasives.INT32GREATER => test32 (MirTypes.BGT,regs,the_code)
      | Pervasives.INT32GREATEREQ => test32 (MirTypes.BGE,regs,the_code)
      | Pervasives.WORD32EQ => test32 (MirTypes.BEQ,regs,the_code)
      | Pervasives.WORD32NE => test32 (MirTypes.BNE,regs,the_code)
      | Pervasives.WORD32LT => test32 (MirTypes.BLO,regs,the_code)
      | Pervasives.WORD32LE => test32 (MirTypes.BLS,regs,the_code)
      | Pervasives.WORD32GT => test32 (MirTypes.BHI,regs,the_code)
      | Pervasives.WORD32GE => test32 (MirTypes.BHS,regs,the_code)
      | Pervasives.STRINGEQ => do_external_prim prim
      | Pervasives.STRINGNE => do_external_prim prim
      | Pervasives.STRINGLT => do_external_prim prim
      | Pervasives.STRINGLE => do_external_prim prim
      | Pervasives.STRINGGT => do_external_prim prim
      | Pervasives.STRINGGE => do_external_prim prim
      | Pervasives.INTABS => do_intabs (regs,the_code,exn_code_for_prim prim)
      | Pervasives.REALABS => tagged_unary_fcalc(MirTypes.FABSV,regs,the_code,exn_code_for_prim prim)
      | Pervasives.CALL_C => do_call_c (regs,the_code)
      | Pervasives.LOAD_STRING => Crash.impossible "Impossible load_string"

      | Pervasives.ARRAY_FN =>
          array_code (false,regs,the_code,exn_code_for_prim prim)
      | Pervasives.LENGTH => length_code (false,false,regs,the_code)
      | Pervasives.SUB =>
          sub_code (false, true,regs,the_code,exn_code_for_prim prim)
      | Pervasives.UPDATE =>
          update_code (false, true,TypeUtils.is_integral3 primTy,
                       regs,the_code,exn_code_for_prim prim)
      | Pervasives.UNSAFE_SUB =>
          sub_code (false, false,regs,the_code,exn_code_for_prim prim)
      | Pervasives.UNSAFE_UPDATE =>
          update_code(false, false,TypeUtils.is_integral3 primTy,
                      regs,the_code,exn_code_for_prim prim)

      | Pervasives.BYTEARRAY =>
          array_code (true,regs,the_code,exn_code_for_prim prim)
      | Pervasives.BYTEARRAY_LENGTH => length_code (true,false,regs,the_code)
      | Pervasives.BYTEARRAY_SUB =>
          sub_code (true, true,regs,the_code,exn_code_for_prim prim)
      | Pervasives.BYTEARRAY_UNSAFE_SUB =>
          sub_code (true, false,regs,the_code,exn_code_for_prim prim)
      | Pervasives.BYTEARRAY_UPDATE =>
          update_code (true, true,true,regs, the_code,
                       exn_code_for_prim prim)
      | Pervasives.BYTEARRAY_UNSAFE_UPDATE =>
          update_code(true, false, true,regs,the_code,
                      exn_code_for_prim prim)

      | Pervasives.FLOATARRAY =>
          floatarray_code(regs,the_code,exn_code_for_prim prim)
      | Pervasives.FLOATARRAY_LENGTH =>
          length_code (false,true,regs,the_code)
      | Pervasives.FLOATARRAY_SUB =>
          floatarray_sub_code (true,regs,the_code,exn_code_for_prim prim)
      | Pervasives.FLOATARRAY_UPDATE =>
          floatarray_update_code (true,regs, the_code,
                                  exn_code_for_prim prim)
      | Pervasives.FLOATARRAY_UNSAFE_SUB =>
          floatarray_sub_code (false,regs,the_code,exn_code_for_prim prim)
      | Pervasives.FLOATARRAY_UNSAFE_UPDATE =>
          floatarray_update_code (false,regs, the_code,
                                  exn_code_for_prim prim)

      | Pervasives.VECTOR_LENGTH => vector_length_code (regs,the_code)
      | Pervasives.VECTOR_SUB => vector_sub_code (true,regs,the_code,exn_code_for_prim prim)
      | Pervasives.VECTOR => do_external_prim prim
      | Pervasives.EXSIZE => Crash.impossible"APP of non-function"
      | Pervasives.EXSUBSCRIPT => Crash.impossible"APP of non-function"

      | Pervasives.ANDB => binary_calc (MirTypes.AND,regs,the_code)
      | Pervasives.ORB => binary_calc (MirTypes.OR,regs,the_code)
      | Pervasives.XORB => binary_calc (MirTypes.EOR,regs,the_code)
      | Pervasives.WORDANDB => binary_calc (MirTypes.AND,regs,the_code)
      | Pervasives.WORDORB => binary_calc (MirTypes.OR,regs,the_code)
      | Pervasives.WORDXORB => binary_calc (MirTypes.EOR,regs,the_code)
      | Pervasives.WORD32ANDB => untagged32_binary_calc (MirTypes.AND,regs,the_code)
      | Pervasives.WORD32ORB => untagged32_binary_calc (MirTypes.OR,regs,the_code)
      | Pervasives.WORD32XORB => untagged32_binary_calc (MirTypes.EOR,regs,the_code)

      | Pervasives.LSHIFT => do_shift_operator(MirTypes.ASL,false,regs,the_code)
      | Pervasives.RSHIFT => do_shift_operator(MirTypes.LSR,true,regs,the_code)
      | Pervasives.ARSHIFT => do_shift_operator(MirTypes.ASR,true,regs,the_code)
      | Pervasives.WORDLSHIFT =>
	do_shift_operator(MirTypes.ASL,false,regs,the_code)
      | Pervasives.WORDRSHIFT =>
	do_shift_operator(MirTypes.LSR,true,regs,the_code)
      | Pervasives.WORDARSHIFT =>
	do_shift_operator(MirTypes.ASR,true,regs,the_code)
      (* Note: For the 32 bit shift operations, we currently assume *)
      (* that these are on full machine words *)
      (* If/when we code generate for a 64 bit machine, *)
      (* this may have to change *)
      | Pervasives.WORD32LSHIFT =>
	full_machine_word_shift_operator (MirTypes.ASL, regs, the_code)
      | Pervasives.WORD32RSHIFT =>
	full_machine_word_shift_operator (MirTypes.LSR, regs, the_code)
      | Pervasives.WORD32ARSHIFT =>
	full_machine_word_shift_operator (MirTypes.ASR, regs, the_code)
      | Pervasives.NOTB => do_notb (regs,the_code)
      | Pervasives.WORDNOTB => do_notb (regs,the_code)
      | Pervasives.WORD32NOTB => word32_notb (regs,the_code)
      | Pervasives.CAST => do_cast_code (regs,the_code)
      | Pervasives.ALLOC_STRING => do_alloc_string_code (regs,the_code)
      | Pervasives.ALLOC_VECTOR => do_alloc_vector_code (regs,the_code)
      | Pervasives.ALLOC_PAIR => do_alloc_pair_code (regs,the_code)
      | Pervasives.RECORD_UNSAFE_SUB => vector_sub_code (false,regs,the_code,exn_code_for_prim prim)
      | Pervasives.RECORD_UNSAFE_UPDATE => record_unsafe_update_code (regs,the_code)
      | Pervasives.STRING_UNSAFE_SUB => do_ordof (false,regs,the_code,exn_code_for_prim prim)
      | Pervasives.STRING_UNSAFE_UPDATE => string_unsafe_update_code (regs, the_code)
      | Pervasives.GET_IMPLICIT => do_external_prim "get_implicit"

      (* End of switch on pervasives *)

      val (runtime_env,calls) = (!runtime_env,!calls)
      val (code,option,calls) =
       case runtime_env of
         RuntimeEnv.BUILTIN => (code,NONE,calls)
       | _ => (make_call_code(calls+1,code),
               SOME calls',
               calls+1)
    in
      (result, code,
       if variable_debug then
         RuntimeEnv.APP(runtime_env,runtime_env',option)
       else
         RuntimeEnv.EMPTY,
       !spills,calls)
    end)
    end

    | cg_sub(arg as AugLambda.LET ((lvar, info,lexp2), {lexp=lexp1,...}),
             env,static_offset, start_at, tail_position,
             (closure,funs_in_closure, fn_tag_list,local_fns),
             spills,calls) =
    let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out,
		 "In cg_sub(LET), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating LET...\n",
	LambdaPrint.string_of_lambda arg])
*)
      (* Code generate the bound expression *)
      val (reg, code, static_offset', start_at', runtime_env,
           spills as (gc_spills,non_gc_spills,fp_spills),calls) =
	cg_bind(lexp2, env, static_offset, start_at,
                (closure,funs_in_closure,fn_tag_list,local_fns),spills,calls)

      (* Find the debug info, if any *)
      val debug_info =
        case info of
          SOME (ref debug_info) => debug_info
        | _ => RuntimeEnv.NOVARINFO

      (* This seems to be concerned with moving the bound var into a spill slot, if necessary *)
      (* And updating the debug info accordingly *)
      val ((code,spills),debug_info) =
        case debug_info of
          RuntimeEnv.NOVARINFO => ((code,spills),RuntimeEnv.NOVARINFO)
        | RuntimeEnv.VARINFO (name,info,tyvar_slot) =>
            let
              fun find_tyvar_slot (tyvar_slot,slot) =
                case tyvar_slot of
                  NONE =>
                    (ref (RuntimeEnv.OFFSET1 slot),false)
                | SOME offset =>
                    (offset := RuntimeEnv.OFFSET1 slot;
                     (offset,true))
            in
              (case reg of
               MirTypes.GC reg =>
                 let
                   val slot = gc_spills+1
                   val (ref_slot,has_tyvar_slot) = find_tyvar_slot (tyvar_slot,slot)
                 in
                   ((Mir_Utils.combine(code,
                    ((Sexpr.ATOM [MirTypes.STOREOP(MirTypes.STREF,MirTypes.GC_REG (reg),
		     MirTypes.GC_REG fp,
                     MirTypes.GP_IMM_SYMB (MirTypes.GC_SPILL_SLOT (MirTypes.DEBUG (ref_slot,name))))],
		     [],NONE, Sexpr.NIL), [], [])),
		    	               (slot,non_gc_spills,fp_spills)),
                   if has_tyvar_slot then RuntimeEnv.NOVARINFO
                   else RuntimeEnv.VARINFO (name,info,SOME(ref_slot)))
                 end
             | MirTypes.NON_GC reg =>
                 let
                   val slot = non_gc_spills+1
                   val (ref_slot,has_tyvar_slot) = find_tyvar_slot (tyvar_slot,slot)
                 in
                   ((Mir_Utils.combine(code,
                    ((Sexpr.ATOM [MirTypes.STOREOP(MirTypes.STREF,
                                                   MirTypes.NON_GC_REG reg,
                                                   MirTypes.GC_REG fp,
                                                   MirTypes.GP_IMM_SYMB (MirTypes.NON_GC_SPILL_SLOT
                                                                         (MirTypes.DEBUG (ref_slot,name))))],
                    [],NONE, Sexpr.NIL), [], [])),
                   (gc_spills,slot,fp_spills)),
                   if has_tyvar_slot then RuntimeEnv.NOVARINFO
                   else RuntimeEnv.VARINFO(name,info,SOME(ref_slot)))
                 end
             | MirTypes.FLOAT reg =>
                 let
                   val slot = fp_spills+1
                   val (ref_slot,has_tyvar_slot) = find_tyvar_slot (tyvar_slot,slot)
                 in
                   ((Mir_Utils.combine
                     (code,
                      ((Sexpr.ATOM [MirTypes.STOREFPOP(MirTypes.FSTREF,
                                                       MirTypes.FP_REG reg,
                                                       MirTypes.GC_REG fp,
                                                       MirTypes.GP_IMM_SYMB (MirTypes.FP_SPILL_SLOT
                                                                             (MirTypes.DEBUG (ref_slot,name))))],
                      [],NONE, Sexpr.NIL), [], [])),
                     (gc_spills,non_gc_spills,slot)),
                   if has_tyvar_slot then RuntimeEnv.NOVARINFO
                   else RuntimeEnv.VARINFO (name,info,SOME(ref_slot)))
                 end)
            end

      (* Extend lambda environment *)
      val env' = Mir_Env.add_lambda_env((lvar, reg), env)

(*
      val (foo, fp_spills) =
	let
	  val (_, _, fp_spills) = spills
	in
	  (fp_spills > 0, fp_spills)
	end
      val _ =
	if foo then
	  output(std_out,
		 "After spilling fp, fp_spills = " ^ Int.toString fp_spills ^ "\n")
	else
	  ()
*)

      (* And code generate the body *)
      val (rest_regs, rest_code, runtime_env',spills,calls) =
	cg_sub(lexp1, env', static_offset', start_at',tail_position,
	       (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls)
(*
      val _ =
	if foo then
	  let
	    val (_, _, fp_spills) = spills
	  in
	    output(std_out,
		 "After let body, fp_spills = " ^ Int.toString fp_spills ^ "\n")
	  end
	else
	  ()
*)
    in
      (rest_regs, Mir_Utils.combine(code, rest_code),
       if variable_debug then
         RuntimeEnv.LET([(debug_info,runtime_env)], runtime_env')
       else
         RuntimeEnv.EMPTY,spills,calls)
    end

      (* Regular function application *)
    | cg_sub(arg as AugLambda.APP({lexp=le1,size=gc_objects_in_call},
				  (arg_list,fp_arg_list),
                                  debugger_information),
             env,static_offset, start_at,tail_position,
	     (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls) =
      let
        (* First code generate to evaluate which function should be called, *)
        (* then evaluate the argument, then call the function *)
        fun lookup (lvar, l) =

          if (opt_self_calls orelse do_local_functions) andalso tail_position

            then
              let
                fun lookup' (lvar, []) = NONE
                  | lookup' (lvar, (lvar',stuff)::rest) =
                  if lvar = lvar' then SOME stuff else lookup' (lvar,rest)
              in
                lookup' (lvar,l)
              end
          else NONE
        val dummy_info =
          (* The cg_result here is just a dummy *)
          (* We should get an error if it actually gets used *)
          (Mir_Utils.ONE (Mir_Utils.INT (MirTypes.GP_IMM_INT 0)),
           ((Sexpr.ATOM [], [], NONE, Sexpr.NIL), [], []),
           RuntimeEnv.EMPTY,spills,calls+1)
        val ((fn_reg,fn_code,runtime_env,spills,calls'), calltype) =
          case le1 of
            (* If its a lambda var, then we may know the function *)
            AugLambda.VAR lvar =>
              (case lookup (lvar, local_fns) of
                 SOME (tag,(arglist,fp_arglist)) => (dummy_info,Mir_Utils.LOCAL (tag,arglist,fp_arglist))
               | _ =>
                   let
                     val ((reg, code), pos, is_same_set) =
                       Mir_Utils.cg_lvar (lvar, env, closure, funs_in_closure)
                   in
                     if is_same_set then
                       (dummy_info, Mir_Utils.SAMESET pos)
                     else
                       ((Mir_Utils.ONE reg,
                         ((Sexpr.ATOM code, [], NONE, Sexpr.NIL), [], []),
                         RuntimeEnv.EMPTY,spills,calls+1),
                        Mir_Utils.EXTERNAL)
                   end)
          | _ =>
              (* Else code generate as usual *)
              (cg_sub(le1, env, static_offset, start_at,false,
                      (closure,funs_in_closure,fn_tag_list,local_fns),spills,calls+1),
               Mir_Utils.EXTERNAL)

        val gc_objects_in_arglist =
          Lists.reducel
          (fn (n,{size,lexp}) => n + size)
          (0,arg_list)

        (* Do the argument *)
        val (arg_reg, arg_code,runtime_env',spills,calls') =
          cg_sub(AugLambda.STRUCT arg_list, env,
                 static_offset + gc_objects_in_call,
                 start_at + gc_objects_in_call, false,
                 (closure,funs_in_closure, fn_tag_list,local_fns),
                 spills,calls')

        (* This should leave things in FP registers *)
        val (fp_arg_reg, fp_arg_code,runtime_env'',spills,calls') =
          cg_sub(AugLambda.STRUCT fp_arg_list, env,
                 static_offset + gc_objects_in_call + gc_objects_in_arglist,
                 start_at + gc_objects_in_call + gc_objects_in_arglist,
                 false,
                 (closure,funs_in_closure, fn_tag_list,local_fns),
                 spills,calls')

        (* Punt the complicated stuff to Mir_Utils *)
        val (reg, fn_code, arg_code, call_code) =
          Mir_Utils.do_multi_app(debugger_information,
                                 fn_reg, fn_code,
                                 arg_reg, arg_code,
                                 fp_arg_reg,fp_arg_code,
                                 calltype,
                                 funs_in_closure, fn_tag_list,
                                 tail_position andalso opt_tail_calls)
        val code as ((first, blocks, tag_opt, last), values, procs_list) =
          Mir_Utils.combine
          (fn_code,
           Mir_Utils.combine
           (arg_code, make_call_code(calls+1,call_code)))
        val runtime_env =
          if variable_debug then
            RuntimeEnv.APP (RuntimeEnv.APP(runtime_env,runtime_env',NONE),runtime_env'',NONE)
          else
            RuntimeEnv.EMPTY
      in
        (reg, code, runtime_env,spills,calls')
      end

    | cg_sub(arg as AugLambda.STRUCT le_list, env, static_offset, start_at,_,
	   (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls) =
    (* Dispose of unit case *)
    (case le_list of
      [] => (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_IMM_INT 0)), no_code,
             RuntimeEnv.EMPTY,spills,calls)
    | _ =>
      let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out,
		 "In cg_sub(STRUCT), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating STRUCT\n",
	LambdaPrint.string_of_lambda arg])
*)

        (* Iterate over the subexpressions *)
	fun make_code([],_,spills,calls) = ([],no_code,[],spills,calls)
	  | make_code({lexp=le, size=size} :: rest, pos,spills,calls) =
	    let
	      val (reg,code,runtime_env,spills,calls) =
		cg_sub(le, env, static_offset + pos, start_at + pos, false,
                       (closure,funs_in_closure,fn_tag_list,local_fns),spills,calls)
              val (reg_list,code',runtime_envs,spills,calls) =
                                         make_code(rest, pos+size,spills,calls)
	    in
	      (reg::reg_list,Mir_Utils.combine(code, code'),
               runtime_env::runtime_envs,spills,calls)
	    end
        val (reg_list,the_code,runtime_env,spills,calls) = make_code(le_list, 0, spills,calls)

        (* Coerce to single registers *)
	val new_reg_list =
	  map
	  (fn Mir_Utils.ONE reg =>
	   (reg, [MirTypes.COMMENT("Argument to tuple")])
	  |   Mir_Utils.LIST regs =>
	      let
		val (reg, code) = Mir_Utils.tuple_up regs
	      in
		(Mir_Utils.INT(MirTypes.GP_GC_REG reg),
		 MirTypes.COMMENT("Argument to tuple") :: code)
	      end)
	  reg_list

	val new_code =
	  lists_reducel
	  (fn (code', (_,code)) => Sexpr.CONS(code', Sexpr.ATOM code))
	  (Sexpr.NIL, new_reg_list)

        val runtime_env =
          if variable_debug
            then RuntimeEnv.STRUCT runtime_env
          else
            RuntimeEnv.EMPTY

      (* Note that all the tuple elements are constructed, and then are themselves tupled up *)
      in
	(Mir_Utils.LIST(map #1 new_reg_list),
	 Mir_Utils.combine(the_code, ((new_code, [], NONE,
				       Sexpr.NIL), [], [])),
         runtime_env,spills,calls)
      end)

    | cg_sub(arg as AugLambda.SELECT({index, size}, {lexp=lexp, ...}),
	     env, static_offset, start_at,_,
             (closure,funs_in_closure, fn_tag_list,local_fns),
             spills,calls) =
    let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out,
		 "In cg_sub(SELECT), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating SELECT\n",
	LambdaPrint.string_of_lambda arg])
*)

      val (regs, the_code,runtime_env,spills,calls) =
	cg_sub(lexp, env, static_offset,start_at, false,
               (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls)
      val offset = (index * 4) - 1

    in
      case regs of
	Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG reg)) =>
	  let
	    val new_reg = MirTypes.GC.new()
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG new_reg)), Mir_Utils.combine(the_code,
	      ((Sexpr.ATOM[MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
				 MirTypes.GC_REG reg,
		  MirTypes.GP_IMM_ANY offset),
		MirTypes.COMMENT("Destructure tuple")], [], NONE,
	      Sexpr.NIL), [], [])),
            if variable_debug
              then RuntimeEnv.SELECT(index,runtime_env)
            else RuntimeEnv.EMPTY,
            spills,calls)

	  end
      | Mir_Utils.ONE _ => Crash.impossible"SELECT(Mir_Utils.ONE(bad value))"
      | Mir_Utils.LIST many =>
          (* This case should be optimized by the lambda optimizer *)
          ((Mir_Utils.ONE(Lists.nth(index, many)), the_code,
            if variable_debug
              then RuntimeEnv.SELECT(index,runtime_env)
            else RuntimeEnv.EMPTY,spills,calls)
           handle Lists.Nth =>
             Crash.impossible
             ("Trying to select item " ^
              Int.toString index ^ " from list size " ^
              Int.toString(length many) ^
              " with struct size " ^ Int.toString size ^ "\n"))
    end

    | cg_sub(arg as AugLambda.SWITCH
	      ({lexp=lexp,size=arg_size}, info, tag_le_list, dflt),
	     env, static_offset, start_at,tail_position,
             (closure,funs_in_closure,fn_tag_list,local_fns),spills,calls) =
      let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out,
		 "In cg_sub(SWITCH), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
*)
        val positions = do_pos1(arg_size, tag_le_list)
        val list_size =
          lists_reducel (fn (x:int, (_, {size=size, lexp=_})) => x + size)
          (0, tag_le_list)
        val tag_sizes =
          lists_reducel
          (fn (x, (tag,_)) => x + count_gc_tags tag)
          (0, tag_le_list)
	val tag_test_mask = 3
        val (gc_spills,non_gc_spills,fp_spills) = spills
        val slot = gc_spills+1
        val ref_slot = new_ref_slot slot
      in
        let
          (* Initial set up *)
          val tag_positions = do_pos2(arg_size + list_size, tag_le_list)

          val main_tag = MirTypes.new_tag() (* This tag marks the start of the body of the switch. *)
          val end_tag = MirTypes.new_tag() (* For the end of switch *)

          val main_branch = MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG main_tag)
          val final_branch = MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG end_tag)

          val is_con =
            case tag_le_list of
              (AugLambda.IMM_TAG _,_) :: _ => true
            | (AugLambda.VCC_TAG _,_) :: _ => true
            | _ => false

          val dflt_exists = case dflt of
            NONE => false
          | SOME _ => true

          val end_reg = MirTypes.GC.new() (* For the result *)

          (* Construct the default blocks and tags *)
          fun get_blocks_for_dflts(dflt, static_offset, start_at, comment) =
            case dflt of
              NONE => ([], end_tag, [], [],RuntimeEnv.EMPTY,spills,calls)
            | SOME {lexp,size} =>
                let
                  (* Code generate the body of the default case *)
                  val (regs, body_code,runtime_env,spills,calls) =
                    cg_sub(lexp, env, static_offset, start_at,tail_position,
                           (closure,funs_in_closure, fn_tag_list,local_fns),
                           (slot,non_gc_spills,fp_spills),calls)

                  val debug_code =
                    if variable_debug then
		      let
			val new_reg = MirTypes.GC.new()
		      in
			((Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE,
						     MirTypes.GC_REG (new_reg),
						     MirTypes.GP_IMM_INT 0),
				      MirTypes.STOREOP(MirTypes.STREF,
						       MirTypes.GC_REG (new_reg),
						       MirTypes.GC_REG fp,
						       MirTypes.GP_IMM_SYMB
						       (MirTypes.GC_SPILL_SLOT
							(MirTypes.DEBUG (ref_slot,"default for switch"))))],
                          [],NONE, Sexpr.NIL), [], [])
		      end
                    else
                      no_code

                  val result_code =
                    (case regs of
                       Mir_Utils.ONE(Mir_Utils.INT reg) =>
                         [MirTypes.UNARY(MirTypes.MOVE,
                                         MirTypes.GC_REG end_reg,
                                         reg)]
                     | Mir_Utils.ONE(Mir_Utils.REAL reg) =>
                         Mir_Utils.save_real_to_reg(reg,
                                                    MirTypes.GC_REG end_reg)
                     | Mir_Utils.LIST many =>
                         (#2 (Mir_Utils.tuple_up_in_reg (many,end_reg))))
		
                  val full_body_code =
                    Mir_Utils.combine (debug_code,
                                       Mir_Utils.combine (body_code,
                                                          ((Sexpr.ATOM(MirTypes.COMMENT comment ::
                                                                       result_code @@ [final_branch]),
							    [],NONE,Sexpr.NIL),
							   [],[])))

                  val new_tag =  MirTypes.new_tag()
                  val ((first,blocks,opttag,last),values,procs) = full_body_code
                  val newblocks =
                    case opttag of
                      NONE =>
                        MirTypes.BLOCK(new_tag,Mir_Utils.contract_sexpr first) ::
                        blocks
                    | SOME tag =>
                        MirTypes.BLOCK(new_tag,Mir_Utils.contract_sexpr first) ::
                        MirTypes.BLOCK(tag,Mir_Utils.contract_sexpr last) ::
                        blocks
                in
                  (newblocks,new_tag,values,procs,runtime_env,spills,calls)
                end (* of get_blocks_for_dflts *)

          (* Generate for the default case, if it exists *)
          val (dflt_blocks, dflt_tag, dflt_values, dflt_procs,runtime_env,spills',calls') =
            get_blocks_for_dflts(dflt,
                                 static_offset + arg_size + list_size + tag_sizes,
                                 start_at + arg_size + list_size + tag_sizes,
                                 "simple default")

          (* Count the different types of constructor, if appropriate. *)
          val (num_vcc_tags, num_imm_tags) =
            if not is_con then (0, 0)
            else
              lists_reducel
              (fn ((nv, ni), (AugLambda.IMM_TAG _,_)) => (nv, ni + 1)
               | ((nv, ni), (AugLambda.VCC_TAG _,_)) => (nv + 1, ni)
               | _ => Crash.impossible "bad constructor tag")
              ((0, 0), tag_le_list)

          (* Generate for the non-default cases *)
          val tagged_code =
            if variable_debug
              then
                let
                  val switch_cases = length tag_le_list
                in
                  #2 (Lists.reducer
                      (fn (((t, {lexp=x, ...}), le_offset),(switch_case,tagged_code)) =>
                       let
                         val (reg, code,runtime_env,spills,calls) =
                           cg_sub(x, env, static_offset + le_offset,start_at + le_offset,tail_position,
                                  (closure,funs_in_closure, fn_tag_list, local_fns),
                                  (slot,non_gc_spills,fp_spills),calls)
                         (* This may be a tail, but only if we are in the tail line *)
                         val new_reg = MirTypes.GC.new()
                       in
                         (switch_case-1,
                          (t, (reg,
                               Mir_Utils.combine
                               (((Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG (new_reg),
                                                             MirTypes.GP_IMM_INT switch_case),
                                              MirTypes.STOREOP(MirTypes.STREF,MirTypes.GC_REG (new_reg),
                                                               MirTypes.GC_REG fp,
                                                               MirTypes.GP_IMM_SYMB
                                                               (MirTypes.GC_SPILL_SLOT
                                                                (MirTypes.DEBUG (ref_slot,
                                                                                 "switch case " ^
                                                                                 Int.toString switch_case))))],
				  [],NONE, Sexpr.NIL), [], []),code),
                               (convert_tag t,runtime_env),
                               spills,calls),
                          MirTypes.new_tag ()) :: tagged_code)
                       end)
                      (Lists.zip (tag_le_list, positions), (switch_cases,nil)))
                end
            else
              map
              (fn ((t, {lexp=x, ...}), le_offset) =>
               let
                 val (reg, code,runtime_env,spills,calls) =
                   cg_sub(x, env, static_offset + le_offset,start_at + le_offset,tail_position,
                          (closure,funs_in_closure, fn_tag_list, local_fns),
                          (slot,non_gc_spills,fp_spills),calls)
               (* This may be a tail, but only if we are in the tail line *)
               in
                 (t, (reg, code, (convert_tag t,runtime_env),
                      spills,calls),MirTypes.new_tag())
               end)
              (Lists.zip (tag_le_list, positions))

          (* I wonder what this is about *)
          val spills = map (fn tuple => #4 (#2 tuple)) tagged_code
          val calls = map (fn tuple => #5 (#2 tuple)) tagged_code

          local
	    fun max(a, b : int) = if a >= b then a else b
            fun order ((gc_spills:int, non_gc_spills:int, fp_spills:int),
                       (gc_spills':int, non_gc_spills':int, fp_spills':int)) =
              gc_spills >= gc_spills' andalso
              non_gc_spills >= non_gc_spills' andalso
              fp_spills >= fp_spills'
          in
            val maximum_spills =
              lists_reducel
              (fn (max_spill as (s1, s2, s3),spill as (t1, t2, t3)) =>
               if order (max_spill,spill) then
		 max_spill
	       else
		 if order(spill, max_spill) then
		   spill
		 else
		   (max(s1, t1), max(s2, t2), max(s3, t3)))
              ((spills', spills))
          end

(*
	  val (_, _, fp_spills) = maximum_spills
	  val _ = output(std_out,
			 "maximum_spills = " ^ Int.toString fp_spills ^ "\n")
*)

          val maximum_calls =
            lists_reducel
            (fn (max_app,app) => if max_app > app then max_app else app)
            (0,(calls'::calls))

          val switch_runtime_env = (RuntimeEnv.DEFAULT,runtime_env) :: map (fn tuple => #3 (#2 tuple)) tagged_code

          (* Test is we are going to do a simple relational test *)
          val is_rel = is_simple_relation lexp

          (* In the case of if..then, need to know this *)
          val (true_tag, false_tag) =
            if is_rel then
              case (tagged_code, dflt) of
                ([(AugLambda.IMM_TAG (_,t1),_, tag)], SOME _) =>
                  if t1 = 1 then (tag, dflt_tag) else (dflt_tag, tag)
            | ([(AugLambda.IMM_TAG (_,t1),_, tag),
		    (AugLambda.IMM_TAG (_,t2),_, tag')], NONE) =>
		    if t1 = 1 then (tag, tag') else (tag', tag)
		  | _ => Crash.impossible "Relational expression with bad IMM_TAGs"
            else (dflt_tag, dflt_tag) (* Rubbish values *)

          (* get_vcc_tag and get_imm_tag are only called when there is only one tag of the appropriate type. *)

          fun get_vcc_tag [] = Crash.impossible "Missing VCC tag"
            | get_vcc_tag ((AugLambda.VCC_TAG _,_, tag) :: _) = tag
            | get_vcc_tag (_ :: rest) = get_vcc_tag rest

          fun get_imm_tag [] = Crash.impossible "Missing IMM tag"
            | get_imm_tag ((AugLambda.IMM_TAG t,_, tag) :: _) = tag
            | get_imm_tag (_ :: rest) = get_imm_tag rest

          fun con_tag_to_reg (from_reg, to_reg) =
            let
              val offset = ~1
            in
              MirTypes.STOREOP(MirTypes.LD,
                               MirTypes.GC_REG to_reg,
                               MirTypes.GC_REG from_reg,
                               MirTypes.GP_IMM_ANY offset)
            end

          (* Put the correct value in the register on which we switch.
           In the general case this requires testing the runtime tag
           on the value, but in some common cases we can improve on this.
           The boolean third field of the result is true if we still
           need to test the actual tag number.
           *)
          (* Returns:
           1: The register with the value to test
           2: The code to extract the value
           3: Do we still need to test?
           *)
          (* This seems to do the extraction of tags so the subsequent code doesn't *)
          (* have to worry about the difference between VCC's and IMM's *)

          (* only used in the is_con case *)

          fun destructuring_code regs =
            case regs of
              (* Single value case *)
              Mir_Utils.ONE(Mir_Utils.INT(gp_op as MirTypes.GP_GC_REG reg)) =>
                let
		  val (num_vccs, num_imms) = case info of
                    (* Only called for constructor matches *)
                    NONE => Crash.impossible "Missing switch info"
                  | SOME {num_imms, num_vccs, ...} => (num_vccs, num_imms)
		  val tmp_reg = MirTypes.GC.new()
                in
                  if num_imms = 0 then
                    (* No immediate values, all VCC's *)
		    (MirTypes.GP_GC_REG tmp_reg,
		     [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 0 IMM_TAG",
		      con_tag_to_reg (reg, tmp_reg),
		      main_branch],
		     true)
                  else if num_vccs = 0 then
                    (* All immediates *)
                    (gp_op,
                     [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 0 VCC_TAG",
                      main_branch],
                     true)
                  else if num_vccs = 1 then
                    (* Just one vcc *)
		    if num_vcc_tags = 1 orelse dflt_exists then
		      let
			val vcc_tag =
			  if num_vcc_tags = 1 then
			    get_vcc_tag tagged_code
			  else
			    dflt_tag
		      in
			(gp_op,
			 MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 1 VCC" ::
			 (* Branch if it's a boxed value *)
			 MirTypes.TEST (MirTypes.BTA,
					vcc_tag,
					gp_op,
					MirTypes.GP_IMM_ANY tag_test_mask) ::
			 (if num_imm_tags = 1 andalso num_imms = 1 then
			    (* 1 VCC and 1 IMM *)
			    [MirTypes.BRANCH (MirTypes.BRA,
					      MirTypes.TAG (get_imm_tag tagged_code))]
			  else if num_imm_tags = 0 then
			    (* num_imms = 1 => num_imm_tags = 0 here *)
			    (* So any imm tag must be the default *)
			    let
			      val branch =
				[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG dflt_tag)]
			    in
			      case dflt of
				NONE =>
				  (* This is the nasty semantically invalid case *)
				  (* Why isn't this a Crash? *)
				  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG end_reg,
						 MirTypes.GP_IMM_INT 0) :: branch
			      | _ => branch
			    end
			       else [main_branch]),
			    num_imms <> 1 andalso num_imm_tags <> 0)
		      end
		    else
		      (* The match compiler has optimised away a case *)
		      (* given that it can't occur from any of the call sites *)
		      (* We must be in a match default function *)
		      (* Treat as for the num_vccs = 0 case above *)
		      (gp_op,
		       [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 0 VCC_TAG",
			main_branch],
		       true)
                  else if num_imms = 1 then
		    (* 1 IMM case *)
		    if num_imm_tags = 1 orelse dflt_exists then
		      let
			val imm_tag =
			  if num_imm_tags = 1 then
			    get_imm_tag tagged_code
			  else dflt_tag
		      in
			(MirTypes.GP_GC_REG tmp_reg,
			 MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 1 IMM_TAG" ::
			 MirTypes.TEST(MirTypes.BNT,
				       imm_tag,
				       gp_op,
				       MirTypes.GP_IMM_ANY tag_test_mask) ::
			 (if num_vcc_tags = 0 then
			    [MirTypes.BRANCH(MirTypes.BRA,
					     MirTypes.TAG dflt_tag)]
			  else
			    [con_tag_to_reg (reg, tmp_reg),
			     main_branch]),
			    num_vcc_tags <> 0)
		      end
		    else
		      (* The match compiler has optimised away a case *)
		      (* given that it can't occur from any of the call sites *)
		      (* We must be in a match default function *)
		      (* Treat as for the num_imms = 0 case above *)
		      (MirTypes.GP_GC_REG tmp_reg,
		       [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 0 IMM_TAG",
			con_tag_to_reg (reg, tmp_reg),
			main_branch],
		       true)
		  else
		    (* num_vccs > 1 andalso num_imms > 1 *)
		    if num_vcc_tags = 0 then
		      (gp_op,
		       [MirTypes.TEST(MirTypes.BTA,
				      dflt_tag,
				      gp_op,
				      MirTypes.GP_IMM_ANY tag_test_mask),
			main_branch],
		       true)
                  else if num_imm_tags = 0 then
		    (MirTypes.GP_GC_REG tmp_reg,
		     [MirTypes.TEST(MirTypes.BNT,
				    dflt_tag,
				    gp_op,
				    MirTypes.GP_IMM_ANY tag_test_mask),
		      con_tag_to_reg (reg, tmp_reg),
		      main_branch],
		     true)
                  else
		    (MirTypes.GP_GC_REG tmp_reg,
		     [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, general case",
		      MirTypes.UNARY(MirTypes.MOVE,
				     MirTypes.GC_REG tmp_reg,
				     gp_op),
		      MirTypes.TEST(MirTypes.BNT,
				    main_tag,
				    MirTypes.GP_GC_REG tmp_reg,
				    MirTypes.GP_IMM_ANY tag_test_mask),
		      con_tag_to_reg (reg, tmp_reg),
		      main_branch],
		     true)
		end
	    | Mir_Utils.ONE(Mir_Utils.INT(gp_op)) => Crash.impossible "_mir_cg: Mir_Utils.INT\n"
	    (* Do we need to handle GP_NON_GC_REG? *)
	    | Mir_Utils.ONE(Mir_Utils.REAL _) => Crash.impossible "SWITCH(Mir_Utils.ONE(Mir_Utils.REAL))"
	    | Mir_Utils.LIST many =>
		(* It's implausible that this gets past the lambda optimizer *)
		let
		  val tmp_reg = MirTypes.GC.new()
		  val index = 0
		  val extra =
		    (case Lists.nth(index, many) of
		       Mir_Utils.INT gp_op =>
			 MirTypes.UNARY(MirTypes.MOVE,
					MirTypes.GC_REG tmp_reg,
					gp_op)
		     | Mir_Utils.REAL fp_op => Crash.impossible "REAL when decoding list")
                       handle
	               Lists.Nth =>
	                 Crash.impossible("Trying to select constructor tag " ^
                                          " from list size " ^
                                          Int.toString(length many) ^
                                          "\n")
		in
		  (MirTypes.GP_GC_REG tmp_reg,
		   MirTypes.COMMENT "select for LIST" ::
		   [extra, main_branch],
		   true)
		end

	  (* what is the result here? *)
	  (* it depends on what sort of switch we have *)
	  (* arg_regs:  The switch argument, possible unboxed, literal or untupled -- only used for scons and exns *)
	  (* the_reg_opt:  A register with the switch arg in *)
	  (* switch_arg_code:  Code for producing the switch argument *)
	  (* need_main_test:  Something cunning! *)

	  val (arg_regs, the_reg_opt, switch_arg_code,need_main_test,runtime_env',spills,calls) =
	    (* A simple relational test *)
	    if is_rel then
	      let
		val (test,arg) =
		  case lexp of
		    AugLambda.APP({lexp=AugLambda.BUILTIN (test,_), ...},([{lexp=arg,...}],[]),_) =>
		      (test,arg)
		  | AugLambda.APP({lexp=AugLambda.BUILTIN _, ...},args,_) =>
		      Crash.impossible "Arglist in rel expr"
		  | _ => Crash.impossible"Bad rel lexp"

		(* Code generate the arguments *)
		val (arg_regs, arg_code,arg_runtime_env,spills,calls) =
		  cg_sub
		  (arg, env, static_offset, start_at,false,
		   (closure, funs_in_closure, fn_tag_list, local_fns),
		   maximum_spills,maximum_calls)

		val (the_reg, extra) = Mir_Utils.send_to_reg arg_regs
		(* This is bogus -- but it doesn't matter!!! *)

		val code =
		  make_if (test, arg_regs,arg_code, true_tag, false_tag)
	      in
		(arg_regs, SOME the_reg, code,
		 false,arg_runtime_env,spills,calls)
	      end
	    else if is_con then
	      (* datatype constructor matches *)
	      let
		val (regs, the_code,runtime_env,spills,calls) =
		  (* Code generate the switch argument *)
		  cg_sub(lexp, env, static_offset, start_at,false,
			 (closure,funs_in_closure, fn_tag_list,local_fns),
			 maximum_spills,maximum_calls)

		(* And make some code to get the tags *)
		val (the_reg, select_code, need_main_test) = destructuring_code regs

		val block =
		  Mir_Utils.combine(the_code,
				    ((Sexpr.ATOM (select_code),[],NONE,Sexpr.NIL),
				     [],
				     []))
	      in
		(Mir_Utils.ONE(Mir_Utils.INT(the_reg)),
		 SOME the_reg,
		 block,   (* Compute arg and extract tag *)
		 need_main_test,runtime_env,spills,calls)
	      end
	    else
	      (* scon and expression matches *)
	      let
		val (regs, the_code,runtime_env,spills,calls) =
		  (* Code generate the switch argument *)
		  cg_sub(lexp, env, static_offset, start_at,false,
			 (closure,funs_in_closure, fn_tag_list,local_fns),
			 maximum_spills,maximum_calls);

		val block =
		  Mir_Utils.combine(the_code,
				    ((Sexpr.ATOM [main_branch],[],NONE,Sexpr.NIL),
				     [],[]))
	      in
		(regs, NONE, block, true,runtime_env,spills,calls)
	      end

	  val calls : int ref = ref calls
	  val spills : (int * int * int) ref = ref spills
	  val runtime_env' : RuntimeEnv.RuntimeEnv ref = ref runtime_env'

	  (* Some auxiliary functions *)

	  (* Handle the case of using computed gotos *)
	  fun make_cgt(MirTypes.GP_IMM_INT _,_,_,_) =
	    Crash.impossible"make_cgt GP_IMM_INT"
	    | make_cgt(MirTypes.GP_IMM_ANY _,_,_,_) =
	    Crash.impossible"make_cgt GP_IMM_ANY"
	    | make_cgt(MirTypes.GP_IMM_SYMB _,_,_,_) =
	    Crash.impossible"make_cgt GP_IMM_SYMB"
	    | make_cgt(gp_operand, low, high, val_code_tag_list) =
	    let
	      val reg_op = Mir_Utils.reg_from_gp gp_operand
	      val (dflt_tag, end_blocks) =
		case dflt of
		  NONE =>
		    let val tag1 = MirTypes.new_tag()
		    in (tag1,
			[MirTypes.BLOCK(tag1,
					[MirTypes.COMMENT "CGT default",
					 MirTypes.UNARY(MirTypes.MOVE,
							MirTypes.GC_REG end_reg,
							MirTypes.GP_IMM_ANY 1),
					 final_branch])])
		    end
		| _ => (dflt_tag, [])

	      val full_tag_list =
		let
		  fun expand [] = []
		    | expand ([(_,_, tag)]) = [tag]
		    | expand ((i,_, tag) :: (rest as ((j,_,_) :: _))) =
		    tag :: Mir_Utils.list_of (j-i-1, dflt_tag) @@ expand rest
		in
		  expand val_code_tag_list
		end

	      val values =
		Lists.reducer
		(fn ((_, (_, (_, value,_),_,_,_),_), value') =>
		 value @@ value')
		(val_code_tag_list, [])

	      val procs =
		Lists.reducer
		(fn ((_, (_, (_,_, proc),_,_,_),_), proc') => proc @@ proc')
		(val_code_tag_list, [])

	      val body =
		map
		(fn (_, (regs, ((first, blocks, tag_opt, last),_,_),_,_,_),tag) =>
		 let
		   val end_code =
		     Mir_Utils.send_to_given_reg(regs, end_reg) @@
		     [MirTypes.COMMENT "end CGT", final_branch]
		 in
		   (case tag_opt of
		      NONE =>
			[MirTypes.BLOCK(tag,
					Mir_Utils.contract_sexpr(Sexpr.CONS(first, Sexpr.ATOM end_code)))]
		    | SOME tag1 =>
			[MirTypes.BLOCK(tag,
					Mir_Utils.contract_sexpr first),
			 MirTypes.BLOCK(tag1,
					Mir_Utils.contract_sexpr(Sexpr.CONS(last, Sexpr.ATOM end_code)))])
		      @@ blocks
		 end)
		val_code_tag_list
	    in
	      ((if is_rel orelse not need_main_test
		  then Sexpr.NIL
		else
		  Sexpr.ATOM(
			     if low = 0 then
			       [MirTypes.SWITCH(MirTypes.CGT,
						reg_op,
						full_tag_list)]
			     else
			       let val new_reg_op = MirTypes.GC.new()
			       in [MirTypes.TEST(MirTypes.BLT,
						 dflt_tag,
						 gp_operand,
						 MirTypes.GP_IMM_INT low),
				   MirTypes.BINARY(MirTypes.SUBU,
						   MirTypes.GC_REG new_reg_op,
						   gp_operand,
						   MirTypes.GP_IMM_INT low),
				   MirTypes.SWITCH(MirTypes.CGT,
						   MirTypes.GC_REG new_reg_op,
						   full_tag_list),
				   MirTypes.COMMENT "Switch relative to lowest tag"]
			       end
			     ),
		  Lists.reducer
		  op@@
		  (end_blocks :: body, []),
		  NONE,
		  Sexpr.NIL
		  ),
		  values,
		  procs
		  )
	    end (* of make_cgt *)

	  fun bounds(low:int, high, []) = (low, high)
	    | bounds(low, high, i :: xs) =
	    if (i < low) then bounds(i, high, xs)
	    else if (i > high) then bounds(low, i, xs)
                 else bounds(low, high, xs)

	  (* Test as one damn thing after another *)
	  fun do_chained_tests(_, default, [], test_opt, clean_code) =
	    (((case (default, test_opt) of
		 (* This should never be called without a default,
		  but it's worth being on the safe side.
		  *)
		 (SOME _, SOME _) =>
		   Sexpr.ATOM
		   (clean_code @@
		    [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG dflt_tag),
		     MirTypes.COMMENT "default or end"])
	       | (SOME _, NONE) =>
		   Sexpr.NIL (* This one ok *)
	       | (_, SOME _) =>
		   (* This one ok, but should have converted previous *)
		   (* conditional branch to be unconditional *)
		   Sexpr.NIL
	       | _ => Sexpr.NIL (* This one ok *)),
		 [],
		 NONE,
		 Sexpr.NIL),
		 [],[])
	    | do_chained_tests
		 (the_reg, default, head :: rest, test_opt, clean_code) =
                 let
		   val (scon, le, (regs, code_block, _, _, _), tag) = head

                   val ((first, blocks, tag_opt, last), values, procs) =
		     code_block

                   val {test_code, test_clean} =
		     case test_opt of
		       SOME f => f (the_reg, scon, le, tag)
		     | NONE => {test_code = Sexpr.NIL, test_clean = []}

		   val the_test = case rest of
		     [] =>
		       (* Last test coming up *)
		       (case default of
			  NONE =>
			    (* Constructor stuff *)
			    (case test_opt of
			       SOME _ =>
				 (* A real test *)
				 (case test_code of
				    Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag,_,_)] =>
				      Sexpr.ATOM
				      [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag)]
				  | _ => Crash.impossible"Bad constructor test")
			     | _ => test_code)
			| _ => test_code)
		   | _ => test_code

                   val end_code =
                     Mir_Utils.send_to_given_reg(regs, end_reg) @@
		       [MirTypes.COMMENT "end chained test", final_branch]

                   val result =
                     case tag_opt of
                       NONE =>
                         (Sexpr.CONS (the_test, Sexpr.ATOM test_clean),
                          MirTypes.BLOCK
			    (tag,
                             Mir_Utils.contract_sexpr
                               (Sexpr.CONS
				  (Sexpr.ATOM (test_clean @@ clean_code),
				   Sexpr.CONS
				     (first, Sexpr.ATOM end_code))))
			  :: blocks,
                          NONE,
			  Sexpr.NIL)
                     | SOME tag'=>
                         (Sexpr.CONS (the_test, Sexpr.ATOM test_clean),
                          MirTypes.BLOCK
			    (tag,
			     Mir_Utils.contract_sexpr
			       (Sexpr.CONS
				  (Sexpr.ATOM (test_clean @@ clean_code),
				   first)))
			  :: blocks
			  @@ [MirTypes.BLOCK
			       (tag',
				Mir_Utils.contract_sexpr
                                  (Sexpr.CONS(last, Sexpr.ATOM end_code)))],
                          NONE,
                          Sexpr.NIL)
                 in Mir_Utils.combine(
		      (result, values, procs),
                      do_chained_tests(the_reg, default, rest, test_opt, clean_code))
                 end (* of do_chained_tests *)

               (* This seems to be the main point for doing datatype switches *)
	  fun constructor_code () =
	    let
	      (* Bind tags to previously generated body code *)
	      val val_code_tags_list =
		Lists.qsort (fn ((i:int,_,_), (i',_,_)) => i < i')
		(map
		 (fn (AugLambda.IMM_TAG (_,i), le, tag) => (i, le, tag)
	       |  (AugLambda.VCC_TAG (_,i), le, tag) => (i, le, tag)
	       | _ => Crash.impossible "Mixed tag type in switch")
		 tagged_code)

	      val (i, (result_reg, code,_,_,_), first_tag) =
		case val_code_tags_list of
		  x :: _ => x
		| _ => Crash.impossible "Empty datatype list"

	      val the_reg =
		case the_reg_opt of
		  SOME x => x
		| NONE => Crash.impossible "Missing the_reg"
	    in
	      if length val_code_tags_list < 3
		(* The small case *)
		then
		  let
		    fun do_test(reg, i,_, tag) =
		      {test_code =
		       Sexpr.ATOM [MirTypes.TEST(MirTypes.BEQ, tag, reg,
						 MirTypes.GP_IMM_INT i)],
		       test_clean = []}
		    val val_le_tags_list =
		      map
		      (fn (i, code, tag) => (i, 0, code, tag))
		      val_code_tags_list
		  in ([],
		      do_chained_tests
		      (the_reg, dflt, val_le_tags_list,
		       if need_main_test then
			 SOME do_test
		       else
			 NONE,
			 []))
		  end
	      else
		(* Computed goto case *)
		let
		  val (low, high) = bounds (i, i, map #1 val_code_tags_list)
		  val dflt_code =
		    case dflt of
		      NONE => []
		    | SOME _ =>
			[MirTypes.TEST(MirTypes.BGT, dflt_tag, the_reg,
				       MirTypes.GP_IMM_INT high)]
		  val main =
		    make_cgt(the_reg, low, high, val_code_tags_list)
		in
		  (dflt_code, main)
		end
	    end

	  fun empty_tel_code () =
	    let
	      val dflt_code = case dflt of
		NONE => []
	      | SOME _ =>
		  [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG dflt_tag)]
	    in
	      (MirTypes.COMMENT "nil main def" :: dflt_code, no_code)
	    end

	  fun find_large_value to_bignum (v1, v2) =
	    let
	      val v = to_bignum v1
	    in
	      v2
	    end
	  handle
	  BigNum.Unrepresentable => v1
	| BigNum32.Unrepresentable => v1

	  fun scon_code (scon, max_size_opt) =
	    (* Returns (main_default, main_code).   Both opcode lists.
	     main_default: the code for the default case
	     main_code : the code for the non-default cases *)
	    (* From a special constant match, use a computed goto for ints
	     in a suitably small range, and multiple tests and branches
	     for other int cases, reals and strings. *)
	    (* We now have to deal with chars, which could in some cases
	     be treated as constructors from a set of 256.
	     Also there are words. *)
	    (case scon of
	       Ident.INT _ =>
		 let
		   (* 32-bit ints are stored as four-byte strings on
		    32-bit architectures, and require special code. *)
		   val is_32_bits =
		     case max_size_opt of
		       NONE => false
		     | SOME sz =>
			 if sz <= MachSpec.bits_per_word then
			   false
			 else if sz = 32 then
			   true
                              else
                                Crash.impossible
				("Unknown integer size in pattern " ^ Int.toString sz)
		   (* clean_code cleans the register that holds the
		    unboxed 32-bit value. *)
		   val (the_reg, extra, clean_code) =
		     if is_32_bits then
		       case arg_regs of
			 Mir_Utils.ONE reg => Mir_Utils.get_word32 reg
		       |  _ =>
			   Crash.impossible "LIST found in switch on Integer32"
		     else
		       let
			 val (reg, code) = Mir_Utils.send_to_reg arg_regs
		       in
			 (reg, code, [])
		       end
		 in
		   let
		     fun do_conversion (AugLambda.SCON_TAG (Ident.INT (i,location), max_size_opt),
					code, tag) =
		       (Mir_Utils.convert_int (i, max_size_opt), 0, code, tag)
		       | do_conversion _ = Crash.impossible "Mixed tag type in switch"

		     (* If we get here (i.e. no exception has been
		      raised), then all the scons fit in integers
		      of the compiling machine.  We still don't
			know the size of the value being switched on. *)
		     val val_le_tags_list =
		       Lists.qsort
		       (fn ((i:int,_,_,_), (i',_,_,_)) => i < i')
		       (map do_conversion tagged_code)

		     (* Patch for Jont *)
		     val a_value = case val_le_tags_list of
		       {1=i, ...} :: _ => i
		     | _ => Crash.impossible"empty val_le_tags_list"

		     val (low, high) =
		       bounds (a_value, a_value, map #1 val_le_tags_list)

		     val len = length val_le_tags_list

		     val use_cgt =
		       not (is_32_bits) andalso
		       high + 1 - low <= 2 * len andalso len > 2

		     (* Not too many holes, but a bigger than two list *)

		     (* We possibly could construct a computed goto for
		      32 bit integers, since all the patterns fit in
		      single integers.  We would first test the argument
		      to see if the top two bits were set, branching
		      to the default case if so, and shifting left by
		      two otherwise. *)

		     val dflt_code = case dflt of
		       NONE =>
			 [MirTypes.COMMENT
			  "No default (strange for scon match)"]
		     | SOME _ =>
			 if is_32_bits then
			   [MirTypes.COMMENT "Default",
			    MirTypes.TEST
			    (MirTypes.BGT, dflt_tag, the_reg,
			     MirTypes.GP_IMM_ANY high)]
			 else
			   [MirTypes.COMMENT "Default",
			    MirTypes.TEST
			    (MirTypes.BGT, dflt_tag, the_reg,
			     MirTypes.GP_IMM_INT high)]
		   in
		     if use_cgt then
		       (extra @@ dflt_code,
			make_cgt
			(the_reg, low, high,
			 map
			 (fn (x,_, y, z) => (x, y, z))
			 val_le_tags_list))
		     else
		       let
			 fun do_test(reg, i, _, tag) =
			   if is_32_bits then
			     {test_code =
			      Sexpr.ATOM
			      [MirTypes.TEST
			       (MirTypes.BEQ, tag, reg,
				MirTypes.GP_IMM_ANY i)],
			      test_clean = []}
			   else
			     {test_code =
			      Sexpr.ATOM
			      [MirTypes.TEST
			       (MirTypes.BEQ, tag, reg,
				MirTypes.GP_IMM_INT i)],
			      test_clean = []}
		       in
			 (extra,
			  do_chained_tests
			  (the_reg, dflt, val_le_tags_list,
			   SOME do_test, clean_code))
		       end
		   end
		 handle
		 Mir_Utils.ConvertInt =>
		   (* If we have values that don't fit in a machine
		    word on the compiling machine, we use runtime
		    evaluation of the integers in the patterns. *)
		   let
		     fun to_string(Ident.INT(i,_)) = i
		       | to_string _ =
		       Crash.impossible"Mixed tag type in switch"

		     fun location_scon(Ident.INT(_, location)) =
		       location
		       |   location_scon _ =
		       Crash.impossible"Mixed tag type in switch"

		     fun to_bignum x =
		       let
			 val str_x = to_string x
		       in
			 if size str_x < 2 then
			   BigNum.string_to_bignum str_x
			 else
			   case substring (* could raise Substring *)(str_x, 0, 2)
			     of "0x" =>
			       BigNum.hex_string_to_bignum str_x
			   | _ =>
			       BigNum.string_to_bignum str_x
		       end

		     (* Again, 32-bit values are a special case. *)
		     fun to_bignum32 x =
		       let
			 val str_x = to_string x
		       in
			 if size str_x < 2 then
			   BigNum32.string_to_bignum str_x
			 else
			   case substring (* could raise Substring *)(str_x, 0, 2)
			     of "0x" =>
			       BigNum32.hex_string_to_bignum str_x
			   | _ =>
			       BigNum32.string_to_bignum str_x
		       end

		     fun compare_bignums ((i,_,_,_), (i',_,_,_)) =
		       BigNum.<(to_bignum i, to_bignum i')
		       handle BigNum.Unrepresentable =>
			 let
			   val i = find_large_value to_bignum (i, i')
			 in
			   Info.error'
			   error_info
			   (Info.FATAL, location_scon i,
			    "Integer too big: " ^ to_string i)
			 end

		     fun compare_bignums32 ((i,_,_,_), (i',_,_,_)) =
		       BigNum32.<(to_bignum32 i, to_bignum32 i')
		       handle BigNum32.Unrepresentable =>
			 let
			   val i = find_large_value to_bignum32 (i, i')
			 in
			   Info.error'
			   error_info
			   (Info.FATAL, location_scon i,
			    "Integer too big: " ^ to_string i)
			 end

		     (* This is the equivalent of do_conversion in the
		      main case.  It differs in that it doesn't
		      convert the scon. *)
		     fun check_tag
		       (AugLambda.SCON_TAG (scon, _), code, tag) =
		       (scon, 0, code, tag)
		       |   check_tag _ =
		       Crash.impossible"Mixed tag type in switch"

		     val val_le_tags_list =
		       Lists.qsort
		       (if is_32_bits then
			  compare_bignums32
			else
			  compare_bignums)
			  (map check_tag tagged_code)

		     val low =
		       case val_le_tags_list of
			 (scon,_,_,_) :: _ => scon
		       | _ => Crash.impossible "Empty switch list"

		     val high =
		       case (last val_le_tags_list) of
			 (scon,_,_,_) => scon

		     fun do_test(reg, long_i,_, tag) =
		       let
			 val (reg', the_code) =
			   (case cg_sub(Mir_Utils.convert_long_int (long_i, max_size_opt), env,
					static_offset, start_at,false,
					(closure,funs_in_closure, fn_tag_list,local_fns),
					!spills,!calls) of
			      (Mir_Utils.ONE(Mir_Utils.INT(r as MirTypes.GP_GC_REG _)),
			       ((code, [], NONE, Sexpr.NIL),
				[], []),_,_,_) => (r, code)
			      | _ => Crash.impossible"Bad code for big integer")
			      handle
			      Mir_Utils.Unrepresentable =>
				Info.error'
				error_info
				(Info.FATAL, location_scon long_i,
				 "Integer too big: " ^ to_string long_i)

			 val (arg_reg, arg_code, arg_clean) =
			   Mir_Utils.get_word32 (Mir_Utils.INT reg')

			 val test =
			   MirTypes.TEST
			   (MirTypes.BEQ, tag, reg, arg_reg)
		       in
			 {test_code =
			  Sexpr.CONS
			  (the_code,
			   Sexpr.ATOM (arg_code @@ [test ])),
			  test_clean = arg_clean}
		       end
		   in
		     (extra,
		      do_chained_tests
		      (the_reg, dflt, val_le_tags_list,
		       SOME do_test, clean_code))
		   end (* of handler *)
		 end (* of INTSCON case *)
	     | Ident.WORD _ =>
		 (* Words are very much like ints *)
		 (* 32-bit words are stored as four-byte strings on
		  32-bit architectures, and require special code. *)
		 let
		   val is_32_bits =
		     case max_size_opt
		       of NONE => false
		     |  SOME sz =>
			 if sz <= MachSpec.bits_per_word then
			   false
			 else if sz = 32 then
			   true
			      else
				Crash.impossible
				("Unknown word size in pattern "
				 ^ Int.toString sz)

		   val (the_reg, extra, clean_code) =
		     if is_32_bits then
		       case arg_regs
			 of Mir_Utils.ONE reg =>
			   Mir_Utils.get_word32 reg
		       |  _ =>
			   Crash.impossible
			   "LIST found in switch on Word32"
		     else
		       let
			 val (reg, code) = Mir_Utils.send_to_reg arg_regs
		       in
			 (reg, code, [])
		       end
		 in
		   let
		     fun do_conversion
		       (AugLambda.SCON_TAG
			(Ident.WORD (i,location), max_size_opt),
			code, tag) =
		       (Mir_Utils.convert_word (i, max_size_opt),
			0, code, tag)
		       |   do_conversion _ =
		       Crash.impossible "Mixed tag type in switch"

		     (* If we get here (i.e. no exception has been
		      raised), then all the scons fit in words
		      of the compiling machine.  We still don't know
			the size of the value being switched on. *)
		     val val_le_tags_list =
		       Lists.qsort
		       (fn ((i:int,_,_,_), (i',_,_,_)) => i < i')
		       (map do_conversion tagged_code)

		     (* Patch for Jont *)
		     val a_value = case val_le_tags_list of
		       {1=i, ...} :: _ => i
		     | _ => Crash.impossible"empty val_le_tags_list"

		     val (low, high) =
		       bounds (a_value, a_value, map #1 val_le_tags_list)

		     val len = length val_le_tags_list

		     val use_cgt =
		       not (is_32_bits) andalso
		       high + 1 - low <= 2 * len andalso len > 2

		     (* Not too many holes, but a bigger than two list *)

		     (* We possibly could construct a computed goto for
		      32 bit words, since all the patterns fit in
		      single words.  We would first test the argument
		      to see if the top two bits were set, branching
		      to the default case if so, and shifting left by
		      two otherwise. *)

		     val dflt_code = case dflt of
		       NONE =>
			 [MirTypes.COMMENT
			  "No default (strange for scon match)"]
		     | SOME _ =>
			 if is_32_bits then
			   [MirTypes.COMMENT "Default",
			    MirTypes.TEST
			    (MirTypes.BHI, dflt_tag, the_reg,
			     MirTypes.GP_IMM_ANY high)]
			 else
			   [MirTypes.COMMENT "Default",
			    MirTypes.TEST
			    (MirTypes.BHI, dflt_tag, the_reg,
			     MirTypes.GP_IMM_INT high)]
		   in
		     if use_cgt then
		       (extra @@ dflt_code,
			make_cgt
			(the_reg, low, high,
			 map
			 (fn (x,_, y, z) => (x, y, z))
			 val_le_tags_list))
		     else
		       let
			 fun do_test(reg, i, _, tag) =
			   if is_32_bits then
			     {test_code =
			      Sexpr.ATOM
			      [MirTypes.TEST
			       (MirTypes.BEQ, tag, reg,
				MirTypes.GP_IMM_ANY i)],
			      test_clean = []}
			   else
			     {test_code =
			      Sexpr.ATOM
			      [MirTypes.TEST
			       (MirTypes.BEQ, tag, reg,
				MirTypes.GP_IMM_INT i)],
			      test_clean = []}
		       in
			 (extra,
			  do_chained_tests
			  (the_reg, dflt, val_le_tags_list,
			   SOME do_test, clean_code))
		       end
		   end
		 handle
		 Mir_Utils.ConvertInt =>
		   (* If we have values that don't fit in a machine
		    word on the compiling machine, we use runtime
		    evaluation of the words in the patterns. *)
		   let
		     fun to_string(Ident.WORD(i,_)) = i
		       | to_string _ =
		       Crash.impossible"Mixed tag type in switch"

		     fun location_scon(Ident.WORD(_, location)) =
		       location
		       |   location_scon _ =
		       Crash.impossible"Mixed tag type in switch"

		     fun to_bignum x =
		       let
			 val str_x = to_string x
		       in
			 if size str_x < 3 then
			   BigNum.word_string_to_bignum str_x
			 else
			   case substring (* could raise Substring *)(str_x, 0, 3)
			     of "0wx" =>
			       BigNum.hex_word_string_to_bignum str_x
			   | _ =>
			       BigNum.word_string_to_bignum str_x
		       end

		     (* Again, 32-bit values are a special case. *)
		     fun to_bignum32 x =
		       let
			 val str_x = to_string x
		       in
			 if size str_x < 3 then
			   BigNum32.word_string_to_bignum str_x
			 else
			   case substring (* could raise Substring *)(str_x, 0, 3)
			     of "0wx" =>
			       BigNum32.hex_word_string_to_bignum str_x
			   | _ =>
			       BigNum32.word_string_to_bignum str_x
		       end

		     fun compare_bignums ((i,_,_,_), (i',_,_,_)) =
		       BigNum.<(to_bignum i, to_bignum i')
		       handle BigNum.Unrepresentable =>
			 let
			   val i = find_large_value to_bignum (i, i')
			 in
			   Info.error'
			   error_info
			   (Info.FATAL, location_scon i,
			    "Word too big: " ^ to_string i)
			 end

		     fun compare_bignums32 ((i,_,_,_), (i',_,_,_)) =
		       BigNum32.<(to_bignum32 i, to_bignum32 i')
		       handle BigNum32.Unrepresentable =>
			 let
			   val i = find_large_value to_bignum32 (i, i')
			 in
			   Info.error'
			   error_info
			   (Info.FATAL, location_scon i,
			    "Word too big: " ^ to_string i)
			 end

		     (* This is the equivalent of do_conversion in the
		      main case.  It differs in that it doesn't
		      convert the scon. *)
		     fun check_tag
		       (AugLambda.SCON_TAG (scon, _), code, tag) =
		       (scon, 0, code, tag)
		       |   check_tag _ =
		       Crash.impossible"Mixed tag type in switch"

		     val val_le_tags_list =
		       Lists.qsort
		       (if is_32_bits then
			  compare_bignums32
			else
			  compare_bignums)
			  (map check_tag tagged_code)

		     val low =
		       case val_le_tags_list of
			 (scon,_,_,_) :: _ => scon
		       | _ => Crash.impossible "Empty switch list"

		     val high =
		       case (last val_le_tags_list) of
			 (scon,_,_,_) => scon

		     fun do_test(reg, long_i,_, tag) =
		       let
			 val (reg', the_code) =
			   (case cg_sub(Mir_Utils.convert_long_word (long_i, max_size_opt), env,
					static_offset, start_at,false,
					(closure,funs_in_closure, fn_tag_list,local_fns),
					!spills,!calls) of
			      (Mir_Utils.ONE(Mir_Utils.INT(r as MirTypes.GP_GC_REG _)),
			       ((code, [], NONE, Sexpr.NIL),
				[], []),_,_,_) => (r, code)
			      | _ => Crash.impossible"Bad code for big word")
			      handle
			      Mir_Utils.Unrepresentable =>
				Info.error'
				error_info
				(Info.FATAL, location_scon long_i,
				 "Word too big: " ^ to_string long_i)

			 val (arg_reg, arg_code, arg_clean) =
			   Mir_Utils.get_word32 (Mir_Utils.INT reg')

			 val test =
			   MirTypes.TEST
			   (MirTypes.BEQ, tag, reg, arg_reg)
		       in
			 {test_code =
			  Sexpr.CONS
			  (the_code,
			   Sexpr.ATOM (arg_code @@ [test ])),
			  test_clean = arg_clean}
		       end
		   in
		     (extra,
		      do_chained_tests
		      (the_reg, dflt, val_le_tags_list,
		       SOME do_test, clean_code))
		   end (* of handler *)
		 end (* of WORDSCON case *)
	     | Ident.CHAR _ =>
		 let
		   val (the_reg, extra) = Mir_Utils.send_to_reg arg_regs
		 in
		   let
		     val val_le_tags_list =
		       Lists.qsort (fn ((i:int,_,_,_), (i',_,_,_)) =>
				    i < i')
		       (map (fn (AugLambda.SCON_TAG(Ident.CHAR s, _), code, tag) =>
			     (ord(String.sub (s, 0)), 0, code, tag)
		     | _ => Crash.impossible"Mixed tag type in switch")
			tagged_code)
		     (* Patch for Jont *)
		     val a_value = case val_le_tags_list of
		       {1=i, ...} :: _ => i
		     | _ => Crash.impossible"empty val_le_tags_list"
		     val (low, high) = bounds(a_value, a_value, map #1 val_le_tags_list)
		     val len = length val_le_tags_list
		     val use_cgt = high + 1 - low <= 2 * len andalso len > 2
		     (* Not too many holes, but a bigger than two list *)

		     val dflt_code = case dflt of
		       NONE => [MirTypes.COMMENT"No default (strange for scon match)"]
		     | SOME _ =>
			 [MirTypes.COMMENT "Default",
			  MirTypes.TEST(MirTypes.BHI, dflt_tag, the_reg,
					MirTypes.GP_IMM_INT high)]
		   in
		     if use_cgt then
		       (extra @@ dflt_code,
			make_cgt(the_reg, low, high,
				 map
				 (fn (x,_, y, z) => (x, y, z))
				 val_le_tags_list))
		     else
		       let
			 fun do_test(reg, i,_, tag) =
			   {test_code =
			    Sexpr.ATOM
			    [MirTypes.TEST(MirTypes.BEQ, tag, reg,
					   MirTypes.GP_IMM_INT i)],
			    test_clean = []}
		       in
			 (extra,
			  do_chained_tests(the_reg,
					   dflt,
					   val_le_tags_list,
					   SOME do_test,
					   []))
		       end
		   end
		 end (* of CHARSCON case *)
	     | Ident.REAL _ =>
		 (* The real case *)
		 let
		   val val_le_tags_list =
		     map (fn ((AugLambda.SCON_TAG(Ident.REAL _, _), code, tag), p) =>
			  (p, 0, code, tag)
		   | _ => Crash.impossible"Mixed tag type in switch")
		     (Lists.zip(tagged_code, tag_positions))
		   val (the_reg, extra) =
		     case arg_regs of
		       Mir_Utils.ONE reg => Mir_Utils.get_real reg
		     | _ => Crash.impossible "struct gives single REAL"

		   fun do_test(reg, i,_, tag) =
		     (* reg is the value input,
		      i is the immediate constant (in the case of an int)
		      or the position in the closure for this function,
		      relative to static_offset + funs_in_closure
		      in the case of a real or string
		      tag is where to go to on successful comparison *)
		     let
		       val fp_op = MirTypes.FP_REG(MirTypes.FP.new())
		     in
		       {test_code =
			Sexpr.ATOM
			[MirTypes.STOREOP
			 (MirTypes.LD,
			  MirTypes.GC_REG MirRegisters.global,
			  MirTypes.GC_REG callee_closure,
			  MirTypes.GP_IMM_ANY
			  (4 * (static_offset + i + (funs_in_closure * 2 - 1)) - 1)),
			 MirTypes.STOREFPOP
			 (MirTypes.FLD, fp_op,
			  MirTypes.GC_REG MirRegisters.global,
			  MirTypes.GP_IMM_ANY real_offset),
			 MirTypes.FTEST(MirTypes.FBEQ, tag, fp_op, reg)],
			test_clean = []}
		     end

		   val tags_code =
		     map
		     (fn (p, (t,_)) =>
		      case t of
			AugLambda.SCON_TAG(scon as Ident.REAL _, _) =>
			  MirTypes.VALUE(top_closure (start_at + p + 1),
					 MirTypes.SCON scon)
		      | _ => Crash.impossible"non-REAL in REAL switch"
			  )
		     (Lists.zip(tag_positions, tag_le_list))
		 in
		   (extra,
		    Mir_Utils.combine(((Sexpr.NIL, [], NONE, Sexpr.NIL), tags_code, []),
				      do_chained_tests(the_reg, dflt, val_le_tags_list, SOME do_test, [])))
		 end (* of REALSCON case *)
	     | Ident.STRING _ =>
		 let
		   val val_le_tags_list =
		     map
		     (fn ((AugLambda.SCON_TAG(Ident.STRING _, _), code, tag), p) =>
		      (p, 0, code, tag)
		   | _ => Crash.impossible"Mixed tag type in switch")
		     (Lists.zip(tagged_code, tag_positions))
		   val the_reg =
		     case arg_regs of
		       Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_GC_REG _)) => arg
		     | _ => Crash.impossible"struct gives single STRING"

		   fun do_test(reg, i,_, tag) =
		     (* reg is the value input,
		      i is the immediate constant (in the case of an int)
		      or the position in the closure for this function,
		      relative to static_offset + funs_in_closure
		      in the case of a real or string
		      tag is where to go to on successful comparison *)
		     let
		       val scon_reg = MirTypes.GC_REG(MirTypes.GC.new())
		       val (regs', the_code',runtime_env'',spills',calls') =
			 cg_sub(AugLambda.VAR(prim_to_lambda Pervasives.STRINGEQ),
				env, static_offset, start_at,false,
				(closure,funs_in_closure, [], []),!spills,!calls)
		       val _ = calls := calls'
		       val _ = spills := spills'
		       val _ =
			 runtime_env' := append_runtime_envs(runtime_env',runtime_env'')
		       val app_code =
			 case Mir_Utils.do_app(Debugger_Types.null_backend_annotation,
					       regs', the_code',
					       Mir_Utils.ONE (Mir_Utils.INT(MirTypes.GP_GC_REG
									    caller_arg)),
					       no_code)
			   of
			     (_, ((app_code, [], NONE, last), [], [])) =>
			       (case Mir_Utils.contract_sexpr last of
				  [] => app_code
				| _ => Crash.impossible"Bad result for STRINGEQ")
			   | _ => Crash.impossible"Bad result for STRINGEQ"
		     in
		       {test_code =
			Sexpr.CONS
			(Sexpr.ATOM
			 [MirTypes.STOREOP
			  (MirTypes.LD, scon_reg,
			   MirTypes.GC_REG callee_closure,
			   MirTypes.GP_IMM_ANY
			   (4 * (static_offset + i + (2 * funs_in_closure - 1)) - 1)),
			  MirTypes.ALLOCATE_STACK
			  (MirTypes.ALLOC,
			   MirTypes.GC_REG caller_arg,
			   2, NONE),
			  MirTypes.STOREOP
			  (MirTypes.ST,
			   Mir_Utils.reg_from_gp the_reg,
			   MirTypes.GC_REG caller_arg,
			   MirTypes.GP_IMM_ANY ~1),
			  MirTypes.STOREOP
			  (MirTypes.ST, scon_reg,
			   MirTypes.GC_REG caller_arg,
			   MirTypes.GP_IMM_ANY 3),
			  MirTypes.COMMENT "Call external STRINGEQ"],
			 Sexpr.CONS
			 (app_code,
			  Sexpr.ATOM
			  [MirTypes.DEALLOCATE_STACK
			   (MirTypes.ALLOC, 2),
			   MirTypes.TEST
			   (MirTypes.BEQ, tag,
			    MirTypes.GP_GC_REG caller_arg,
			    MirTypes.GP_IMM_INT 1)])),
			test_clean = []}
		     end
		   val tags_code =
		     map
		     (fn (p, (t,_)) =>
		      case t of
			AugLambda.SCON_TAG (scon as Ident.STRING _, _) =>
			  MirTypes.VALUE(
					 top_closure(start_at + p + 1),
					 MirTypes.SCON scon)
		      | _ =>
			  Crash.impossible"non-STRING in STRING switch")
		     (Lists.zip(tag_positions, tag_le_list))
		 in
		   ([],
		    Mir_Utils.combine(((Sexpr.NIL, [], NONE, Sexpr.NIL), tags_code, []),
				      do_chained_tests(the_reg, dflt, val_le_tags_list, SOME do_test, [])))
		 end (* of STRINGSCON case *) )

	  fun exp_code () =
	    (* From an exception constructor match, use tests and branches *)
	    let
	      val val_le_tags_list =
		map
		(fn (AugLambda.EXP_TAG{lexp=le, ...}, code, tag) =>
		 (0, le, code, tag)
	         | _ => Crash.impossible"Mixed tag type in switch")
		tagged_code
	      val the_reg =
		case arg_regs of
		  Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_GC_REG _)) => arg
		| _ => Crash.impossible"Bad reg for exception"
	      fun do_test(reg,_, le, tag) =
		(* reg is the value input,
		 le is the exception expression to match
		 tag is where to go to on successful comparison *)
		let
		  val (regs, the_code) =
		    case cg_sub(le, env, static_offset, start_at,false,
				(closure,funs_in_closure, [],[]),!spills,!calls) of
		      (Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)),
		       ((code, [], NONE, last), [], []),
		       runtime_env'',spills',calls') =>
		      (calls := calls';
		       spills := spills';
		       runtime_env' := append_runtime_envs(runtime_env',runtime_env'');
		       (case Mir_Utils.contract_sexpr last of
			  [] => (reg, code)
			| _ => Crash.impossible"Bad result from cg(exception)"))
		     | _ =>
		      Crash.impossible"Bad result from cg(exception)"
		(* Get the value to test against *)
		in
		  {test_code =
		   Sexpr.CONS
		   (the_code,
		    Sexpr.ATOM
		    [MirTypes.TEST(MirTypes.BEQ, tag, reg, regs)]),
		   test_clean = []}
		end
	    in
	      ([], do_chained_tests(the_reg, dflt, val_le_tags_list, SOME do_test, []))
	    end

	  (* End of auxiliary functions *)

	  (* Despatch on type of switch *)
	  (* main_default: the code for the default case *)
	  (* main_code : the code for the non-default cases *)

	  val (main_default, main_code) =
	    case tag_le_list of
	      [] => empty_tel_code ()
	    | (AugLambda.IMM_TAG _,_) :: _ => constructor_code ()
	    | (AugLambda.VCC_TAG _,_) :: _ => constructor_code ()
	    | (AugLambda.SCON_TAG scon,_) :: rest => scon_code scon
	    | (AugLambda.EXP_TAG _,_) :: rest => exp_code ()

	  (* Put it all together *)
	  val result_code =
	    Mir_Utils.combine
	    (Mir_Utils.combine
	     (switch_arg_code,
	      Mir_Utils.combine
	      (((Sexpr.NIL, [], SOME main_tag,
		 Sexpr.ATOM main_default),
		[],
		[]),
	       main_code
	       )
	      ),
	     ((Sexpr.NIL, dflt_blocks, SOME end_tag,
	       Sexpr.ATOM[MirTypes.COMMENT"End of switch"]),
	      dflt_values,
	      dflt_procs)
	     )
	in
(*
		  let
		    val (_, _, fp_spills) = !spills
		  in
		    output(std_out,
			   "After cg_sub(SWITCH), fp_spill = " ^ Int.toString fp_spills ^ "\n")
		  end;
*)
	  (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG end_reg)), result_code,
	   if variable_debug
	     then RuntimeEnv.SWITCH(!runtime_env',ref_slot,
				    maximum_calls,switch_runtime_env)
	   else RuntimeEnv.EMPTY,
	     !spills,!calls)
	end
      end

    | cg_sub(arg as AugLambda.VAR lvar,env,_,_,_,(closure,funs_in_closure,_,_),spills,calls) =
    let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out,
		 "In cg_sub(VAR), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating VAR\n",
	LambdaPrint.string_of_lambda arg, " funs_in_closure = " ^ Int.toString funs_in_closure ^ "\n"])
*)
      val (reg, code) = Mir_Utils.cg_lvar_fn(lvar, env, closure, funs_in_closure)
    in
      (Mir_Utils.ONE reg, ((Sexpr.ATOM code, [], NONE,
			    Sexpr.NIL), [], []),RuntimeEnv.EMPTY,spills,calls)
    end

    | cg_sub(arg as AugLambda.INT i,_,_,_,_,_,spills,calls) =
      let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out,
		 "In cg_sub(INT), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating INT\n",
	LambdaPrint.string_of_lambda arg])
*)
      in
	(Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_IMM_INT i)), no_code,
         RuntimeEnv.EMPTY,spills,calls)
      end
    | cg_sub(arg as AugLambda.SCON (scon, size), e,static_offset, start_at,tail_position,
	     (closure,funs_in_closure, fn_tag_list, local_fns),spills,calls) =
      let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out,
		 "In cg_sub(SCON), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
	val _ =
	  Diagnostic.output 4
	  (fn i => ["Mir generating SCON\n",
		    LambdaPrint.string_of_lambda arg])
*)
      in
	(case scon of
	   Ident.INT(i,location) =>
	   ((let
	       val w = Mir_Utils.convert_int (i, size)
	     in
	       case size
	       of NONE =>
		 (Mir_Utils.ONE (Mir_Utils.INT (MirTypes.GP_IMM_INT w)),
	          no_code,RuntimeEnv.EMPTY,spills,calls)
	       |  SOME sz =>
	         if sz <= MachSpec.bits_per_word then
		   (Mir_Utils.ONE (Mir_Utils.INT (MirTypes.GP_IMM_INT w)),
	            no_code,RuntimeEnv.EMPTY,spills,calls)
	         else if sz = 32 then
		   (* NB. If bits_per_word >= 32, this code is not used *)
		   convert32 (w, sz, spills, calls)
		 else
		   Crash.impossible
		     ("unknown int size " ^ Int.toString sz)
	     end
	     handle Mir_Utils.ConvertInt =>
	       (* The value is too large to fit in one word on the compiler's
		  machine, but may fit on the target machine.  Compile an
		  expression to calculate the value instead of using an
		  immediate value. *)
	           cg_sub(Mir_Utils.convert_long_int (scon, size), e,
		          static_offset,start_at,tail_position,
		          (closure,funs_in_closure,fn_tag_list,local_fns),
		          spills,calls))
	      handle
	        Mir_Utils.Unrepresentable =>
	          Info.error'
	            error_info
		    (Info.FATAL, location, "Integer too big: " ^ i))
	 | Ident.WORD(i, location) =>
	   ((let
	       val w = Mir_Utils.convert_word (i, size)
	     in
	       case size
	       of NONE =>
		 (Mir_Utils.ONE (Mir_Utils.INT (MirTypes.GP_IMM_INT w)),
	          no_code,RuntimeEnv.EMPTY,spills,calls)
	       |  SOME sz =>
	         if sz <= MachSpec.bits_per_word then
		   (Mir_Utils.ONE (Mir_Utils.INT (MirTypes.GP_IMM_INT w)),
	            no_code,RuntimeEnv.EMPTY,spills,calls)
	         else if sz = 32 then
		   (* NB. If bits_per_word >= 32, this code is not used *)
		   convert32 (w, sz, spills, calls)
		 else
		   Crash.impossible
		     ("unknown word size " ^ Int.toString sz)
	     end
	     handle Mir_Utils.ConvertInt =>
	       (* The value is too large to fit in one word on the compiler's
		  machine, but may fit on the target machine.  Compile an
		  expression to calculate the value instead of using an
		  immediate value. *)
	           cg_sub(Mir_Utils.convert_long_word (scon, size), e,
		          static_offset,start_at,tail_position,
		          (closure,funs_in_closure,fn_tag_list,local_fns),
		          spills,calls))
	    handle
	      Mir_Utils.Unrepresentable =>
	        Info.error'
	          error_info
		  (Info.FATAL, location, "Word too big: " ^ i))

	 | Ident.CHAR s =>
	     (Mir_Utils.ONE
	      (Mir_Utils.INT
	       (MirTypes.GP_IMM_INT
		(ord (String.sub(s, 0))))),
	      no_code,RuntimeEnv.EMPTY,spills,calls)
	 | _ =>
	     let
	       val new_reg = MirTypes.GC.new()
	       val new_tag =
		 top_closure(start_at + 1)
	     in
	       (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG new_reg)),
		((Sexpr.ATOM[MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
					      MirTypes.GC_REG callee_closure,
					      MirTypes.GP_IMM_ANY(4*(static_offset +
                                                                     (funs_in_closure * 2 - 1)) - 1))],
	      [],
	      NONE, Sexpr.NIL),
	      [MirTypes.VALUE(new_tag, MirTypes.SCON scon)],
	      []),RuntimeEnv.EMPTY,spills,calls)
	end)
      end
    | cg_sub(arg as AugLambda.MLVALUE mlvalue,_,static_offset, start_at,_,
	     (closure,funs_in_closure,_,_),spills,calls) =
      let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out,
		 "In cg_sub(MLVALUE), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
*)
        val new_reg = MirTypes.GC.new()
        val new_tag = top_closure(start_at + 1)
      in
        (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG new_reg)),
         ((Sexpr.ATOM[MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
                                       MirTypes.GC_REG callee_closure,
                                       MirTypes.GP_IMM_ANY(4*(static_offset +
                                                              (funs_in_closure * 2 - 1)) - 1))],
         [],
         NONE, Sexpr.NIL),
         [MirTypes.VALUE(new_tag, MirTypes.MLVALUE mlvalue)],
         []),RuntimeEnv.EMPTY,spills,calls)
      end

    (* Non recursive function case *)
    | cg_sub(fcn as AugLambda.FN((lvl,fp_vars),
                                 {lexp=lexp, size=gc_objects_within},
				 name_string,instances),
	     env, static_offset,start_at,_,
             (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls) =
      let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out,
		 "In cg_sub(FN), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
*)
(*
        val _ = case fp_vars of [] => ()
          | _ => (print (name_string ^ ":");
                  Lists.iterate (fn v => print (N v ^ " ")) fp_vars;
                  print "\n")
*)
        val _ =
          if do_diagnostics
            then
              if LambdaTypes.isLocalFn instances then print "local function found\n"
              else if name_string = "letbody fun" then print "letbody found\n"
              else if name_string = "switch body<Match>" then print "switch body found\n"
              else ()
          else ()

        val restore_spills = spill_restorer ()
        val _ = initialize_spills()

        (* Determine the free variables of the function *)
        val free = find_frees (env,closure,fcn,prim_to_lambda)

        (* The preassigned tag for the function (code vector?) *)
        val tag = top_closure (start_at + gc_objects_within + 1)
        val gc_reg = MirTypes.GC_REG(MirTypes.GC.new())

        (* Code to make the closure *)

        val (cl_reg, code, new_closure) =
          case Mir_Utils.make_closure([tag], free, gc_objects_within,
                                      static_offset + (funs_in_closure * 2 - 1), env,
                                      closure, funs_in_closure) of
            (reg, code, [new_closure]) =>
              (reg,
               Sexpr.CONS(code,
                          Sexpr.ATOM[MirTypes.COMMENT"Copy in function pointer",
                                     MirTypes.STOREOP(MirTypes.LD, gc_reg,
                                                      MirTypes.GC_REG callee_closure,
                                                      MirTypes.GP_IMM_ANY(4*((funs_in_closure*2-1) + static_offset +
                                                                             gc_objects_within) - 1)),
                                     MirTypes.STOREOP(MirTypes.ST, gc_reg, reg,
                                                      MirTypes.GP_IMM_ANY ~1)]),
               new_closure)
          | _ => Crash.impossible"Single FN with multiple tags"

        (* Now for the function itself *)

        val arg_regs = assign_callee_regs lvl
        val fp_arg_regs = assign_fp_regs fp_vars
        val internal_regs = map (fn lvar => (lvar,MirTypes.GC.new())) lvl
        val fp_internal_regs = map (fn lvar => (lvar,MirTypes.FP.new())) fp_vars

        val comment_string =
          if name_string = ""
            then []
          else [MirTypes.COMMENT name_string]

        (* Enter the function *)

        (* Move the arguments to somewhere safe, and let register colouring deal with allocation *)
        val entry_code =
          (Sexpr.ATOM
           (comment_string @@
            [MirTypes.ENTER (map MirTypes.GC arg_regs @@ map MirTypes.FLOAT fp_arg_regs)] @@
            (* Put the intercept call right after function entry *)
            (if intercept then [MirTypes.INTERCEPT] else []) @@
             make_get_args_code (arg_regs,map #2 internal_regs) @@
             make_fp_get_args_code (fp_arg_regs,map #2 fp_internal_regs)),
           [], NONE, Sexpr.NIL)

        val lambda_env =
          lists_reducel
          (fn (env,(lvar,copy)) =>
           Mir_Env.add_lambda_env((lvar, MirTypes.GC copy),env))
          (Mir_Env.empty_lambda_env,internal_regs)

        val lambda_env =
          lists_reducel
          (fn (env,(lvar,copy)) =>
           Mir_Env.add_lambda_env((lvar, MirTypes.FLOAT copy),env))
          (lambda_env,fp_internal_regs)

        (* Code generate the body with the args in the assigned registers *)
        val (fn_reg, fn_code,runtime_env,(gc_spills,non_gc_spills,fp_spills),_) =
          cg_letrec_sub(lexp,lambda_env, 0, start_at, true,
                        (new_closure,1, [tag] (* tag for this function *), []),
                        (1,0,0),0)

        (* No information for untupling, cos function doesn't recurse *)

        val exit_code =
          let
            val result_temporary = MirTypes.GC.new ()
          in
            (Sexpr.ATOM (Mir_Utils.send_to_given_reg(fn_reg, result_temporary) @@
                         [MirTypes.UNARY(MirTypes.MOVE,
                                         MirTypes.GC_REG callee_arg,
                                         MirTypes.GP_GC_REG result_temporary),
                          MirTypes.RTS]),
            [], NONE, Sexpr.NIL)
          end

        (* And put it all together *)
        val ((first, blocks, tag_opt, last), values, procs) =
          Mir_Utils.combine((entry_code, [], []), Mir_Utils.combine (make_call_code (0,fn_code), (exit_code, [], [])))

        val spill_sizes =
          if variable_debug
            then SOME{gc = gc_spills+1,
                                non_gc = non_gc_spills+1,
                                fp = fp_spills+1}
          else NONE

        val runtime_env =
          if variable_debug
            then RuntimeEnv.FN (name_string,runtime_env,head_spill (get_current_spills ()),instances)
          else RuntimeEnv.EMPTY

        val the_fn =
          [MirTypes.PROC(name_string,
                         tag,
                         MirTypes.PROC_PARAMS {spill_sizes =  spill_sizes,
					       old_spill_sizes = NONE,
                                               stack_allocated = NONE},
                         MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr first) ::
                         blocks @@
                         (case tag_opt of
                            NONE => []
                          | SOME tag =>
                              [MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr last)]),
                         runtime_env)]

        val _ = restore_spills()
      in
        (Mir_Utils.ONE (Mir_Utils.INT (Mir_Utils.gp_from_reg cl_reg)),
         ((code, [], NONE, Sexpr.NIL),
          values,
          the_fn :: procs),
         RuntimeEnv.EMPTY,spills,calls)
      end

      (* The LETREC case *)
   | cg_sub(exp as AugLambda.LETREC(lv_list, le_list, {lexp=lexp, ...}),
	     env, static_offset, start_at,tail_position,
             (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls) =
    let
      (* Could we not move this down to where used? *)
      val runtime_lets =
        Lists.reducer
        (fn ((lvar, SOME (ref (RuntimeEnv.VARINFO (name,ty,_)))),acc) =>
         (RuntimeEnv.VARINFO (name,ty,NONE),RuntimeEnv.EMPTY) :: acc
      | ((lvar,_),acc) => acc)
        (lv_list,[])

      val lv_list = map #1 lv_list
      val funs = length lv_list

(*
      val _ =
        Lists.iterate
        (fn {lexp=AugLambda.FN((lvl,fp_args),e,name,info),...} =>
         (case fp_args of [] => ()
      | _ => (print (name ^ ":");
	    Lists.iterate (fn v => print (N v ^ " ")) fp_args;
	    print "\n"))
      | _ => ())
        le_list
*)

      (* Make sure all the functions look like functions *)
      val fn_args_and_bodies =
	map
	(fn {lexp=AugLambda.FN((lvl,fp_args), le,_,info), ...} => ((lvl,fp_args), le)
          | _ => Crash.impossible"non-FN in LETREC")
	le_list

      val lambda_names =
	map
	(fn {lexp=AugLambda.FN(_,_,name,instances), ...} => (name,instances)
        | _ => Crash.impossible"non-FN in LETREC")
	le_list

      val _ =
        if do_diagnostics
          then
            Lists.iterate
            (fn ((name,instances),lv) =>
             if LambdaTypes.isLocalFn instances then print ("local function found: " ^ N lv ^ " \n")
             else if name = "letbody fun" then print ("letbody found: " ^ N lv ^ " \n")
             else if name = "switch body<Match>" then print ("switch body found: " ^ N lv ^ "\n")
             else ())
            (zip2 (lambda_names,lv_list))
        else ()

      val (fn_args, fn_bodies) = Lists.unzip fn_args_and_bodies

      val free = find_frees (env,closure,AugLambda.STRUCT fn_bodies,prim_to_lambda)

      val gc_objects_within =
	lists_reducel (fn (x, {size=size, lexp=_}) => x+size) (0, fn_bodies)
      val positions = do_pos3 (0, fn_bodies)
      val offsets =
	map #2 (#1 (Lists.number_from (Mir_Utils.list_of (funs, 0), 0, 2, ident_fn)))
      (* Changed above to allow for interspersed zeroes in closures *)

      val tags =
	map (fn x => top_closure(start_at + gc_objects_within + (x div 2) + 1))
	offsets

      val gc_reg = MirTypes.GC_REG(MirTypes.GC.new())

      val (cl_reg, code, new_closure_list) =
	Mir_Utils.make_closure(tags, free, gc_objects_within,
                               static_offset + (2 * funs_in_closure - 1),
                               env, closure,funs_in_closure)

      val new_reg_list = map (fn x => (x, MirTypes.GC.new())) offsets

      val new_closure_code =
	map
	(fn (0, reg) => MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG reg,
                                       Mir_Utils.gp_from_reg cl_reg)
          | (x, reg) => MirTypes.BINARY(MirTypes.ADDU, MirTypes.GC_REG reg,
					Mir_Utils.gp_from_reg cl_reg,
					MirTypes.GP_IMM_INT x))
	new_reg_list

      (* Load in the code vector pointers *)
      val code = Lists.reducer
	(fn (x, y) => Sexpr.CONS(x, y))
	(code :: Sexpr.ATOM new_closure_code ::
	  Sexpr.ATOM[MirTypes.COMMENT "Copy in function pointers"] :: (map
	  (fn x =>
	    Sexpr.ATOM[MirTypes.STOREOP(MirTypes.LD, gc_reg,
                                        MirTypes.GC_REG callee_closure,
                                        MirTypes.GP_IMM_ANY(4*((funs_in_closure*2-1) + static_offset +
                                                               gc_objects_within + (x div 2)) - 1)),
                       MirTypes.STOREOP(MirTypes.ST, gc_reg, cl_reg,
                                        MirTypes.GP_IMM_ANY(4*x-1))])
	  offsets), Sexpr.NIL)

      (* Pad out the closure with zeros, if necessary *)
      val code = case offsets of
	[] => Crash.impossible"Empty recursive set"
      | [_] => code (* Single recursive function, no padding *)
      | _ =>
	  let
	    val gc_reg = MirTypes.GC_REG(MirTypes.GC.new())
	  in
	    Sexpr.CONS
	    (code,
	     Sexpr.ATOM
	     (MirTypes.UNARY(MirTypes.MOVE, gc_reg, MirTypes.GP_IMM_INT 0) ::
	      map
	      (fn x =>
	       MirTypes.STOREOP(MirTypes.ST, gc_reg, cl_reg,
				MirTypes.GP_IMM_ANY(4*(x-1)-1)))
	      (Lists.tl offsets)))
	  end

      (* Here we generate the code for the function bodies *)

      (* Calculate the closures for the code generation of the functions *)
      val new_closure_list =
	map (fn (closure, offset) =>
	  lists_reducel
	  (fn (clos, (lv, off)) => Mir_Env.add_closure_env((lv, off), clos))
	  (closure, #1 (Lists.number_from(lv_list, 0 - offset, 2, fn x=> x))))
	(Lists.zip(new_closure_list, offsets))

      (* Assign argument registers and copies thereof *)
      val arg_regs_list =
        map (fn (arg_regs,fp_regs) => (assign_callee_regs arg_regs,
                                       assign_fp_regs fp_regs))
        fn_args

      val args_and_copied_callee_arg_list =
	map
        (fn (arg_regs, fp_regs) =>
         (map (fn lvar => (lvar, MirTypes.GC.new())) arg_regs,
          map (fn lvar => (lvar, MirTypes.FP.new())) fp_regs))
         fn_args

      (* The initial environments -- just the parameters are defined *)
      val initial_env_list =
	map
        (fn (arg_reg_copies,fn_arg_reg_copies) =>
         let
           val env =
             lists_reducel
             (fn (env,(lvar, copy)) => Mir_Env.add_lambda_env((lvar, MirTypes.GC copy),env))
             (Mir_Env.empty_lambda_env,arg_reg_copies)
         in
           lists_reducel
           (fn (env,(lvar, copy)) => Mir_Env.add_lambda_env((lvar, MirTypes.FLOAT copy),env))
           (env,fn_arg_reg_copies)
         end)
         args_and_copied_callee_arg_list

      (* Insertion of intercept put here instead of in end_block *)
      (* see comment at that point *)
      fun generate_entry_code ((name,_),arginfo) =
        let
          val comment_for_name =
            if name = ""
              then []
            else [MirTypes.COMMENT name]
        in
          ((Sexpr.ATOM(comment_for_name @@ [MirTypes.ENTER arginfo] @@
                       (if intercept
                          then [MirTypes.INTERCEPT]
                        else [])),
            [], NONE, Sexpr.NIL), [], [])
        end

      val entry_code_list =
        map
        generate_entry_code
        (Lists.zip (lambda_names,
                    map (fn (arg_regs,fp_arg_regs) =>
                         map MirTypes.GC arg_regs @@
                         map MirTypes.FLOAT fp_arg_regs)
                    arg_regs_list))


      (* All bets for registers are off, barring the argument *)
      val arg_copy_list =
	(map (fn ((arg_regs,fp_arg_regs),(arg_copies,fp_arg_copies)) =>
              (make_get_args_code (arg_regs,map #2 arg_copies) @@
               make_fp_get_args_code (fp_arg_regs,map #2 fp_arg_copies)))
         (Lists.zip (arg_regs_list,args_and_copied_callee_arg_list)))

      val restore_spills = spill_restorer()

      (* Move and detuple the parameter, if necessary *)
      val code_env_static_start_list =
	map
	(fn (arg_copy, env, new_closure, pos, x) =>
	 let
           val first_spill = initialize_spills()
	   val (static, start,spills,calls) = (pos, start_at + pos, (1,0,0),0)
           val entry_code = ((Sexpr.ATOM arg_copy, [], NONE, Sexpr.NIL), [], [])
	 in
	   (make_call_code (0,entry_code),env, static, start,spills,calls,first_spill)
	 end)
	(zip5 (arg_copy_list,
               initial_env_list,
               new_closure_list,
               positions,
               offsets))

      (* Make a map of from detupled arguments to registers *)
      val tuple_bindings_list =
        map
        (fn (args,fp_args) => (map #2 args,map #2 fp_args))
        args_and_copied_callee_arg_list

      val fn_reg_code_list =
	map
	(fn ({lexp,...},
             (entry_code, env, static_offset, start_at,spills,calls,first_spill),
             new_closure, x, lvar, tuple_bindings, fn_args) =>
	 let
           val _ = reset_spills first_spill
           (* generate the code for the body *)
           val loop_tag = top_lambda_loop_tags lvar
           val new_local_functions = [(lvar,(loop_tag,tuple_bindings))]
	   val (regs, body_code,runtime_env',spills,calls) =
                cg_letrec_sub(lexp, env, static_offset, start_at,true,
                              (new_closure,funs - x div 2, tags,new_local_functions),spills,calls)
           (* Leave a point at which tail recursion can re-enter *)
           (* Jumps to here are generated from the APP code *)
             (* We used to put INTERCEPT's here, but the interaction with *)
             (* the debugger is poor when arguments are in registers so it *)
             (* has been moved to immediately after function entry (as in *)
             (* the non-recursive case *)
	   val end_block =
             ((Sexpr.ATOM [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)],
               [],
               SOME loop_tag,
	       Sexpr.ATOM
	       [if insert_interrupt then
		  MirTypes.INTERRUPT
               else
		  MirTypes.COMMENT"Interrupt point (not coded)"]),
              [], [])
           val runtime_env =
             RuntimeEnv.LIST([runtime_env'])
	 in
	   (regs, Mir_Utils.combine(Mir_Utils.combine(entry_code, end_block),body_code),
            (runtime_env,spills,first_spill),
            loop_tag)
	 end)
        (zip7 (fn_bodies,
               code_env_static_start_list,
               new_closure_list,
               offsets,
               lv_list,
               tuple_bindings_list,
               fn_args))
	
      val _ = restore_spills()

      val fn_list =
	map
	(fn ((res, fn_code, env_spills, loop_tag), entry_code) =>
	  (Mir_Utils.combine (entry_code, Mir_Utils.combine (fn_code, make_exit_code res)),
	   env_spills,
           loop_tag))
	(zip2 (fn_reg_code_list, entry_code_list))

      val fn_val_procs_proc_list =
	map
	(fn (tag,

             (((first, blocks, tag_opt, last), vals, procs),
              (runtime_env, (gc_spills, non_gc_spills, fp_spills), first_spill),
              loop_tag),
             (name,instances)) =>
        let
          val spill_sizes =
            if variable_debug
              then SOME{gc = gc_spills+1,
                                  non_gc = non_gc_spills+1,
                                  fp = fp_spills+1}
            else NONE
          val runtime_env =
            if variable_debug
              then RuntimeEnv.FN(name,runtime_env,head_spill(first_spill),instances)
            else RuntimeEnv.EMPTY
          val proc =
            MirTypes.PROC(name,
                          tag,
                          MirTypes.PROC_PARAMS {spill_sizes = spill_sizes,
						old_spill_sizes = NONE,
                                                stack_allocated = NONE},
                          MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr first) ::
                          blocks @@
                          (case tag_opt of
                             NONE => []
                           | SOME tag =>
                               [MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr last)]),
                          runtime_env)
        in
          (vals,procs,proc)
        end)
	(zip3 (tags, fn_list,lambda_names))

      val letrec_vals =
	Lists.reducer
	(fn ((value,_,_), value') => value @@ value')
	(fn_val_procs_proc_list, [])

      (* The subprocedures of the letrec *)
      val proc_list =
	Lists.reducer
	(fn ((_, procs,_), procs') => procs @@ procs')
	(fn_val_procs_proc_list, [])

      (* The new procedures *)
      val letrec_proc_list = map #3 fn_val_procs_proc_list

      (* Code generate the body *)

      (* Calculate the bindings of letrec functions to registers *)
      val letrec_env =
	lists_reducel
	(fn (env, (lv, (_, reg))) =>
	  Mir_Env.add_lambda_env((lv, MirTypes.GC reg), env))
	(Mir_Env.empty_lambda_env, Lists.zip(lv_list, new_reg_list))

      val (regs, ((first, body_blocks, tag_opt, last), body_vals, body_procs),runtime_env,spills,calls) =
	cg_sub(lexp, Mir_Env.augment_lambda_env (env, letrec_env),
	       static_offset + gc_objects_within + funs,start_at + gc_objects_within + funs,tail_position,
               (closure,funs_in_closure,fn_tag_list,local_fns),spills,calls)

      val runtime_env =
        if variable_debug
          then RuntimeEnv.LET(runtime_lets,runtime_env)
        else RuntimeEnv.EMPTY
    in
      (regs, ((Sexpr.CONS(code, first), body_blocks, tag_opt, last),
	      body_vals @@ letrec_vals,
	      letrec_proc_list :: body_procs @@ proc_list),
       runtime_env,
       spills,calls)
    end

      (* RAISE expressions *)
    | cg_sub(arg as AugLambda.RAISE({lexp=le, ...}), env, static_offset,start_at,_,
             (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls) =
    let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out,
		 "In cg_sub(RAISE), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
*)
      val (reg, code,runtime_env,spills,calls') =
	cg_sub(le, env, static_offset, start_at, false,
               (closure,funs_in_closure,fn_tag_list,local_fns),spills,calls+1)
      val final_code =
        let
          val r = MirTypes.GC.new ()
        in
          Mir_Utils.send_to_given_reg(reg, r) @@
          [MirTypes.RAISE (MirTypes.GC_REG r),
           MirTypes.COMMENT"Call the exception handler, so we can backtrace"]
        end
      val total_code =
             Mir_Utils.combine(code,
                               make_call_code(calls+1,
                                              ((Sexpr.ATOM final_code, [], NONE,
                                                Sexpr.NIL), [], [])))
    in
      (reg, total_code,
       if variable_debug then
         RuntimeEnv.RAISE(runtime_env)
       else
         RuntimeEnv.EMPTY,spills,calls')
    end

      (* HANDLE expression *)
    | cg_sub(exp as AugLambda.HANDLE
	     ({lexp=le, size=gc_objects_in_le}, {lexp=le', size=gc_objects_in_le'}),
	       env, static_offset,start_at, tail_position,
               (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls) =
      (* Modify for tail case with a simple handler *)
      let
	val lv = LambdaTypes.new_LVar()
	val handler_arg = MirTypes.GC.new()
	val foo = ref ""
	fun convert_handler(AugLambda.FN(([lv'],[]), body, name, _)) =
	  (foo := name;
	  SOME
	  (AugLambda.LET((lv', NONE,
			  {size=0, lexp=AugLambda.VAR lv}), body))
	   )
	  | convert_handler(AugLambda.LET(larg, {lexp=body, ...})) =
	    (case convert_handler body of
	       SOME le =>
		 SOME
		 (AugLambda.LET(larg, {size=0, lexp=le}))
	     | x => x)
	  | convert_handler(AugLambda.FN _) =
	    Crash.impossible"Handler has multiple parameters"
	  | convert_handler le = NONE
	val end_tag = MirTypes.new_tag() (* The end of the code we'll generate *)
	val common_tag = MirTypes.new_tag() (* Some common handler restoration stuff *)
	val continue_tag = MirTypes.new_tag() (* Where a taken handler returns to *)
	val handler_frame_reg = MirTypes.GC.new()
	val handler_frame = MirTypes.GC_REG handler_frame_reg

	(* Allocate a new gc_spill *)
	val (gc_spills,non_gc_spills,fp_spills) = spills
	val slot = gc_spills+1
	val spills = (gc_spills+1,non_gc_spills,fp_spills)
	val ref_slot = new_ref_slot slot
	val result_reg = MirTypes.GC.new()
	val frame_size = (*length frame_setup*)4
	val exn_common = (* Common between exceptional and normal route *)
	  MirTypes.BLOCK
	  (common_tag,
	   [MirTypes.OLD_HANDLER,
	    MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, frame_size),
	    MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG end_tag)])
	(* Handler record layout *)
	(* Offset Name *)
	(* 0      previous handler record *)
	(* 1      stack pointer (machine stack) *)
	(* 2	handler closure pointer *)
	(* 3	offset from procedure start of continuation point (GC safe) *)

	fun make_frame_setup(Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG r))) =
	  let
	    val exn_result_reg = MirTypes.GC_REG r
	    val offset_reg = MirTypes.GC.new()
	    val offset = MirTypes.GC_REG offset_reg
	    val gp_offset = MirTypes.GP_GC_REG offset_reg
	    val frame_setup =
	      [MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG sp, handler_frame,
				MirTypes.GP_IMM_ANY 3),
	       MirTypes.STOREOP(MirTypes.ST, exn_result_reg,
				handler_frame, MirTypes.GP_IMM_ANY 7),
	       MirTypes.STOREOP(MirTypes.ST, offset, handler_frame,
				MirTypes.GP_IMM_ANY 11)]
	  in
	    MirTypes.ALLOCATE_STACK(MirTypes.ALLOC,
				    handler_frame,
				    frame_size,
				    NONE) ::
	    MirTypes.ADR(MirTypes.LEO, offset, continue_tag) ::
	    MirTypes.COMMENT "Calculate offset of continuation code" ::
	    MirTypes.BINARY(MirTypes.ASL, offset, gp_offset, MirTypes.GP_IMM_ANY 2) ::
	    MirTypes.COMMENT "Ensure it's tagged" ::
	    MirTypes.NEW_HANDLER(handler_frame, continue_tag) ::
	    frame_setup @@
	    [MirTypes.COMMENT"Set up new handler pointer"]
	  end
	| make_frame_setup _ =
	  Crash.impossible"Exn_result_reg""Exn_result_reg"

      in
	case (convert_handler le',
	      opt_handlers andalso gc_objects_in_le' = 1 andalso not debug_variables) of
	  (SOME new_la, true) =>
	    let
	      val new_handler_lambda =
		let
		  val lv = LambdaTypes.new_LVar()
		in
		  AugLambda.FN(([lv],[]),{size = 0, lexp = AugLambda.VAR lv},
			       "replacement handler", RuntimeEnv.USER_FUNCTION)
		end
	      val (exn_result_reg, (* Pointer to closure of handler *)
		   exn_code (*(exn_f, exn_b, exn_o, exn_l),
				exn_vals, exn_procs*),runtime_env,spills,calls') =
		cg_sub(new_handler_lambda, env,
		       static_offset + gc_objects_in_le,
		       start_at + gc_objects_in_le,false,
		       (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls)
	      local
		val env' = Mir_Env.add_lambda_env ((lv, MirTypes.GC handler_arg), env)
		val (tail_reg, tail_code,runtime_env',spills,calls) =
		  cg_sub(new_la, env',
			 static_offset + gc_objects_in_le,start_at + gc_objects_in_le,tail_position,
			 (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls)
	      in
		val exn_end =
		  Mir_Utils.combine
		  (Mir_Utils.combine
		   (((Sexpr.NIL, [], SOME continue_tag,
		      Sexpr.ATOM
		      (Mir_Utils.send_to_given_reg(Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG caller_arg)),
						   handler_arg) @@
		       [MirTypes.OLD_HANDLER,
			MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, frame_size)])),
		   [], []), tail_code),
		   ((Sexpr.ATOM
		     (Mir_Utils.send_to_given_reg(tail_reg, result_reg) @@
		      [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG end_tag)]),
		     [], SOME end_tag,
		     Sexpr.ATOM[MirTypes.COMMENT"Handle result point"]), [], [])
		   )
	      end

	      val frame_setup = make_frame_setup exn_result_reg

	      val exn_whole =
		Mir_Utils.combine(exn_code,
				  ((Sexpr.ATOM frame_setup, [exn_common], NONE,
				    Sexpr.NIL), [], []))
	      val restore_spills = spill_restorer()
	      (* This is the only call to append_spill *)
	      val _ = append_spill ref_slot
	      val (main_reg, main_code,runtime_env',spills,calls) =
		cg_sub(le, env, static_offset, start_at, false,
		       (closure,funs_in_closure,fn_tag_list,local_fns),spills,calls')
	      val _ = restore_spills()
	      val main_end =
		Mir_Utils.send_to_given_reg(main_reg, result_reg) @@
		[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG common_tag)]
	      val main_whole =
		Mir_Utils.combine(main_code,
				  ((Sexpr.ATOM main_end, [], NONE,
				    Sexpr.NIL), [], []))
	      val total_code =
		Mir_Utils.combine(Mir_Utils.combine(exn_whole, main_whole), exn_end)
	    in
	      (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result_reg)), total_code,
	       RuntimeEnv.EMPTY,spills,calls)
	    end
	| _ =>
	    let
	      val (exn_result_reg, (* Pointer to closure of handler *)
		   exn_code (*(exn_f, exn_b, exn_o, exn_l),
				exn_vals, exn_procs*),runtime_env,spills,calls') =
		cg_sub(le', env,
		       static_offset + gc_objects_in_le,start_at + gc_objects_in_le,false,
		       (closure,funs_in_closure, fn_tag_list,local_fns),spills,calls)
	      val exn_end =
		MirTypes.BLOCK
		(continue_tag,
		 Mir_Utils.send_to_given_reg(Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG caller_arg)),
					     result_reg) @@
		 [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG common_tag)])

	      val frame_setup = make_frame_setup exn_result_reg

	      val exn_whole =
		Mir_Utils.combine(exn_code,
				  ((Sexpr.ATOM frame_setup, [exn_common, exn_end], NONE,
				    Sexpr.NIL), [], []))
	      val restore_spills = spill_restorer()
	      (* This is the only call to append_spill *)
	      val _ = append_spill ref_slot
	      val (main_reg, main_code,runtime_env',spills,calls) =
		cg_sub(le, env, static_offset, start_at, false,
		       (closure,funs_in_closure,fn_tag_list,local_fns),spills,calls')
	      val _ = restore_spills()
	      val main_end =
		Mir_Utils.send_to_given_reg(main_reg, result_reg) @@
		[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG common_tag)]
	      val main_whole =
		Mir_Utils.combine(main_code,
			       ((Sexpr.ATOM main_end, [], SOME end_tag,
				 Sexpr.ATOM[MirTypes.COMMENT"Handle result point"]), [], []))
	      val total_code =
		Mir_Utils.combine(exn_whole, main_whole)
	    in
	      (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result_reg)), total_code,
	       if variable_debug then
		 RuntimeEnv.HANDLE(runtime_env',ref_slot,calls',calls,runtime_env)
	       else
		 RuntimeEnv.EMPTY,spills,calls)
	    end
      end
    | cg_sub(AugLambda.BUILTIN(prim,_), env, static_offset,start_at,_,
             (closure,funs_in_closure, fn_tag_list,local_fns),_,_) =
      let
        val string = LambdaPrint.string_of_lambda(LambdaTypes.BUILTIN prim)
      in
	Crash.impossible (concat ["cg_sub(BUILTIN): ",string, " should have been translated"])
      end (* of cg_sub *)

    val restore_spills = spill_restorer()
    val new_tag = top_closure 0
    val (regs,
         ((first, blocks, tag_opt, last), values, proc_lists),
         runtime_env,
         (gc_spills,non_gc_spills,fp_spills),_) =
      (* Initial spills are (1,0,0) *)
      cg_sub(new_lambda_exp, Mir_Env.empty_lambda_env, 0, 0, false,
             (Mir_Env.empty_closure_env,1, [new_tag], []),(1,0,0),0)

    val (reg, last') =
     case regs of
      Mir_Utils.LIST sub_regs =>
      let
	val result_reg = MirTypes.GC.new()
	val (reg, new_code) = Mir_Utils.tuple_up_in_reg (sub_regs, result_reg)
      in
	(MirTypes.GP_GC_REG callee_arg,
	 Sexpr.CONS
	 (last,
	  Sexpr.CONS
	  (Sexpr.ATOM new_code,
	   Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE,
				      MirTypes.GC_REG callee_arg,
				      MirTypes.GP_GC_REG result_reg)])))
      end
    | Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_GC_REG _)) =>
	(* This compilation unit equal to another one, a rarity! *)
	(MirTypes.GP_GC_REG callee_arg,
	 Sexpr.CONS(last,
		    Sexpr.ATOM
		    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_arg,
				    arg)]))
    | Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_IMM_INT 0)) =>
	(* This is the case of struct[], a rarity! *)
	(MirTypes.GP_GC_REG callee_arg,
	 Sexpr.CONS
	 (last, Sexpr.ATOM
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_arg,
			  MirTypes.GP_IMM_INT 0)]))
    | Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_IMM_INT 1)) =>
	(* This is the case of [], a rarity! *)
	(MirTypes.GP_GC_REG callee_arg,
	 Sexpr.CONS
	 (last, Sexpr.ATOM
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_arg,
			  MirTypes.GP_IMM_INT 1)]))
    | _ => Crash.impossible"Non-struct final result??"

    val last'' = Sexpr.CONS(last', Sexpr.ATOM[MirTypes.RTS])

    val setup_entry =
      Sexpr.CONS
      ((if intercept then
	  Sexpr.ATOM[MirTypes.ENTER [MirTypes.GC callee_arg],
		     MirTypes.INTERCEPT]
	else
	  Sexpr.ATOM[MirTypes.ENTER [MirTypes.GC callee_arg]]),
	  Sexpr.CONS
	  (Sexpr.ATOM
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_closure,
                      MirTypes.GP_GC_REG callee_arg)],  first))

    val (first, blocks) =
      case (tag_opt, Mir_Utils.contract_sexpr last) of
	(NONE, []) => (Sexpr.CONS (setup_entry, last''), blocks)
      | (SOME tag,_) =>
	  (setup_entry, MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr last'') ::
	   blocks)
      | (NONE,_) =>
	  Crash.impossible "ABSENT tag with non-empty last"

    val loc_refs = top_tags_list

    val set_up_proc =
      MirTypes.PROC(name_of_setup_function,
                    new_tag,
		    MirTypes.PROC_PARAMS {spill_sizes =
                                          if variable_debug then
                                            SOME{gc = gc_spills+1,
                                                           non_gc = non_gc_spills+1,
                                                           fp = fp_spills+1}
                                          else
                                            NONE,
					  old_spill_sizes = NONE,
					  stack_allocated = NONE},
		    MirTypes.BLOCK(new_tag,
				   Mir_Utils.contract_sexpr first) :: blocks,
                    if variable_debug then
                      (restore_spills ();
                       RuntimeEnv.FN(name_of_setup_function,runtime_env,
                                     head_spill(get_current_spills ()),RuntimeEnv.USER_FUNCTION))
                    else
                      RuntimeEnv.EMPTY)

    val all_procs = [set_up_proc] :: proc_lists

(*
    (* and now some post optimizations *)
    local
      open MirTypes

      fun get_opt NONE = []
	| get_opt(SOME tag) = [tag]

      fun tag_ref(TBINARY(_, tag_opt,_,_,_)) = get_opt tag_opt
	| tag_ref(BINARY _) = []
	| tag_ref(UNARY _) = []
	| tag_ref(NULLARY _) = []
	| tag_ref(TBINARYFP(_, tag_opt,_,_,_)) = get_opt tag_opt
	| tag_ref(TUNARYFP(_, tag_opt,_,_)) = get_opt tag_opt
	| tag_ref(BINARYFP _) = []
	| tag_ref(UNARYFP _) = []
	| tag_ref(STACKOP _) = []
	| tag_ref(STOREOP _) = []
	| tag_ref(IMMSTOREOP _) = []
	| tag_ref(STOREFPOP _) = []
	| tag_ref(REAL _) = []
	| tag_ref(FLOOR(_, tag,_,_)) = [tag]
	| tag_ref(BRANCH(_, bl_dest)) =
	  (case bl_dest of
	     TAG tag => [tag]
	   | REG _ => [])
	| tag_ref(TEST(_, tag,_,_)) = [tag]
	| tag_ref(FTEST(_, tag,_,_)) = [tag]
	| tag_ref(BRANCH_AND_LINK(_,bl_dest,_,_)) =
	  (case bl_dest of
	     TAG tag => [tag]
	   | REG _ => [])
	| tag_ref(TAIL_CALL(_, bl_dest,_)) =
	  (case bl_dest of
	     TAG tag => [tag]
	   | REG _ => [])
	| tag_ref CALL_C = []
	| tag_ref(SWITCH(_,_, tag_list)) = tag_list
	| tag_ref(ALLOCATE _) = []
	| tag_ref(ALLOCATE_STACK _) = []
	| tag_ref(DEALLOCATE_STACK _) = []
	| tag_ref(ADR(_,_, tag)) = [tag]
	| tag_ref INTERCEPT = []
	| tag_ref INTERRUPT = []
	| tag_ref (ENTER _) = []
	| tag_ref RTS = []
	| tag_ref(NEW_HANDLER(_, tag)) = [tag]
	| tag_ref OLD_HANDLER = []
	| tag_ref(RAISE _) = []
	| tag_ref(COMMENT _) = []

      fun rev_app([], acc) = acc
	| rev_app(x :: xs, acc) = rev_app(xs, x :: acc)

      (* collect the tags referenced by an opcode list *)
      fun process_block(tags, []) = tags
	| process_block(tags, opcode :: opcode_list) =
	  process_block(rev_app (tag_ref opcode, tags), opcode_list)
    in
      (* This discards unreferenced blocks in a procedure *)
      fun process_blocks(_, new_block_map, []) = Map.range new_block_map
	| process_blocks(old_block_map, new_block_map, tag :: tag_list) =
	  case Map.tryApply'(new_block_map, tag) of
	    SOME _ => process_blocks(old_block_map, new_block_map, tag_list)
	  | NONE =>
	      case Map.tryApply'(old_block_map, tag) of
		SOME(block as BLOCK(_, opcodes)) =>
		  process_blocks(old_block_map, Map.define(new_block_map, tag, block),
				 process_block(tag_list, opcodes))
	      | NONE =>
		  (* This case occurs with a call to a different function *)
		  (* in the same recursive set *)
		  process_blocks(old_block_map, new_block_map, tag_list)
	
    end

    fun add_block(map, block as MirTypes.BLOCK(tag,_)) =
      MirTypes.Map.define(map, tag, block)

    (* If there is a 'small' exit block, then this gets appended onto other blocks that *)
    (* branch to it -- maybe we should do this for all short blocks and for blocks only referenced once *)

    fun sort_out_small_exit_blocks(proc as MirTypes.PROC(name,tag, params, blocks,runtime_env)) =
      let
	val exit_block = Mir_Utils.exit_block blocks
	val block_list =
	  case exit_block of
	    NONE =>
              blocks
	  | SOME exit_block =>
	      if Mir_Utils.small_exit_block exit_block then
		let
		  val block_list = Mir_Utils.append_small_exit (exit_block, blocks)
		  val old_block_map = lists_reducel add_block (MirTypes.Map.empty, block_list)
		in
                  (* Throw out unused exit block if possible *)
		  process_blocks(old_block_map, MirTypes.Map.empty, [tag])
		end
	      else
		blocks
      in
	MirTypes.PROC(name,tag, params, block_list,runtime_env)
      end

    val all_procs =
      map
      (fn proc_list => map sort_out_small_exit_blocks proc_list)
      all_procs
*)
  in
    (MirTypes.CODE(MirTypes.REFS(loc_refs,
				 {requires = ext_string_list,
				  vars = ext_var_list,
				  exns = ext_exn_list,
				  strs = ext_str_list,
				  funs = ext_fun_list}),
		  values, all_procs),
     debug_information)
  end
end
@


1.311.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.311  1998/09/18  15:27:48  jont
 * [Bug #20119]
 * Stop fmake_if and imake_if from creating empty blocks
 *
@


1.310
log
@[Bug #30357]
Make sure tail position is passed through into letrec bodies
@
text
@d4 4
d1139 1
a1139 1
  include sig 
d1162 1
a1162 1
  sharing LambdaPrint.LambdaTypes = Library.AugLambda.LambdaTypes = 
d1178 1
a1178 1
  sharing type MirPrint.MirTypes.Debugger_Types.RuntimeEnv.Type = LambdaPrint.LambdaTypes.Type = 
d1181 1
a1181 1
  sharing type MirPrint.MirTypes.Debugger_Types.RuntimeEnv.Instance = LambdaPrint.LambdaTypes.Instance = 
d1223 1
a1223 1
  fun lists_reducel f = 
d1227 1
a1227 1
    in 
d1230 1
a1230 1
    
d1268 1
a1268 1
    | AugLambda.LET((_,_,lb),le) => 
d1286 1
a1286 1
	 if HashSet.is_member(old_set, lv) 
d1321 1
a1321 1
      
d1331 1
a1331 1
      
d1341 1
a1341 1
      
d1351 1
a1351 1
      
d1384 1
a1384 1
  fun make_get_args_code (args,copies) = 
d1391 1
a1391 1
                        MirTypes.STOREOP (MirTypes.LD, 
d1402 1
a1402 1
                     MirTypes.UNARY(MirTypes.MOVE, 
d1411 1
a1411 1
  fun make_fp_get_args_code (args,copies) = 
d1416 1
a1416 1
                     MirTypes.UNARYFP(MirTypes.FMOVE, 
d1425 1
a1425 1
  fun is_simple_relation lexp = 
d1534 1
a1534 1
      if needs_transform 
d1600 1
a1600 1
                ((Sexpr.ATOM 
d1734 1
a1734 1
           Mir_Utils.combine (the_code,
d1798 2
a1799 1
                             [], SOME finish_tag, Sexpr.NIL), [], [])))
d1829 1
a1829 1
          Mir_Utils.combine (the_code,
d1833 1
a1833 1
                               [], SOME false_tag, Sexpr.NIL), [], []))
d1841 1
a1841 1
          Mir_Utils.combine (the_code,
d1845 1
a1845 1
                               [], SOME false_tag, Sexpr.NIL), [], []))
d1915 2
a1916 1
                 [], SOME finish_tag, Sexpr.NIL), [], [])))
d1956 1
a1956 1
	  (Mir_Utils.ONE(Mir_Utils.INT res1), 
d1972 1
a1972 1
	  (Mir_Utils.ONE(Mir_Utils.INT res1), 
d1980 1
a1980 1
      (* NB This doesn't work.  The exceptions are handled by traps, so 
d2052 1
a2052 1
      fun do_shift_operator(mir_operator,need_to_clear_bottom_two_bits,regs,the_code) = 
d2070 1
a2070 1
	  val shift_code = 
d2118 1
a2118 1
      fun full_machine_word_shift_operator(mir_operator, regs, the_code) = 
d2165 1
a2165 1
		  MirTypes.NULLARY(MirTypes.CLEAN, spare2) :: 
d2180 1
a2180 1
               of Mir_Utils.LIST[Mir_Utils.INT(size), initial] => 
d2189 1
a2189 1
              Mir_Utils.LIST[ Mir_Utils.INT(size), initial] => 
d2239 1
a2239 1
              
d2242 1
a2242 1
               (if constantp then 
d2255 1
a2255 1
                    MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, 
d2261 2
a2262 2
               (if constantp then 
                  [MirTypes.UNARY(MirTypes.MOVE, 
d2266 2
a2267 2
                  [MirTypes.UNARY(MirTypes.MOVE, 
                                  MirTypes.GC_REG count, 
d2291 1
a2291 1
                     MirTypes.BINARY(MirTypes.ADDU, 
d2295 1
a2295 1
                     MirTypes.BINARY(MirTypes.ADDU, 
d2300 2
a2301 2
                                   loop_tag, 
                                   MirTypes.GP_GC_REG count, 
d2303 1
a2303 1
		     MirTypes.NULLARY(MirTypes.CLEAN, 
d2315 1
a2315 1
                     MirTypes.BINARY(MirTypes.ADDU, 
d2319 1
a2319 1
                     MirTypes.BINARY(MirTypes.ADDU, 
d2325 1
a2325 1
                                   MirTypes.GP_GC_REG count, 
d2333 1
a2333 1
              SOME finish_tag, 
d2335 1
a2335 1
                Sexpr.NIL
d2358 1
a2358 1
         avoid boxing and then unboxing fp values. 
d2366 1
a2366 1
               of Mir_Utils.LIST[Mir_Utils.INT(size), initial] => 
d2375 1
a2375 1
                             Mir_Utils.REAL reg] => 
d2379 1
a2379 1
                             Mir_Utils.INT(MirTypes.GP_GC_REG reg)] => 
d2440 1
a2440 1
              
d2443 1
a2443 1
               (if constantp then 
d2451 1
a2451 1
                           --- i.e., multiply by 8, or shift left by 3 
d2468 2
a2469 2
               (if constantp then 
                  [MirTypes.UNARY(MirTypes.MOVE, 
d2473 2
a2474 2
                  [MirTypes.UNARY(MirTypes.MOVE, 
                                  MirTypes.GC_REG count, 
d2495 1
a2495 1
                   MirTypes.BINARY(MirTypes.ADDU, 
d2499 1
a2499 1
                   MirTypes.BINARY(MirTypes.ADDU, 
d2505 1
a2505 1
                                 MirTypes.GP_GC_REG count, 
d2513 2
a2514 2
              SOME finish_tag, 
                Sexpr.NIL),
d2523 1
a2523 1
               Mir_Utils.ONE (Mir_Utils.INT size) => 
d2529 1
a2529 1
          val (size_reg, get_arg_code) = 
d2548 1
a2548 1
              (get_arg_code @@ 
d2550 1
a2550 1
                MirTypes.ALLOCATE(MirTypes.ALLOC_VECTOR, result_gc, 
d2556 2
a2557 2
               (if constantp then 
                  [MirTypes.UNARY(MirTypes.MOVE, 
d2574 1
a2574 1
                            MirTypes.BINARY(MirTypes.ADDU, 
d2578 1
a2578 1
                            MirTypes.BINARY(MirTypes.ADDU, 
d2584 1
a2584 1
            SOME finish_tag, 
d2603 1
a2603 1
                MirTypes.ALLOCATE(MirTypes.ALLOC, result_gc, 
d2616 1
a2616 1
              NONE, 
d2625 1
a2625 1
               Mir_Utils.ONE (Mir_Utils.INT size) => 
d2631 1
a2631 1
          val (size_reg, get_arg_code) = 
d2643 1
a2643 1
              (get_arg_code @@ 
d2645 1
a2645 1
                MirTypes.ALLOCATE(MirTypes.ALLOC_STRING, result_gc, 
d2651 1
a2651 1
            NONE, 
d2669 1
a2669 1
                    [MirTypes.COMMENT ((if bytearray then "Byte" else 
d2681 1
a2681 1
                                     MirTypes.GP_IMM_ANY 
d2752 1
a2752 1
            | _ => Crash.impossible 
d2821 1
a2821 1
		    (* Note that the 5 includes the left over bit of 
d2877 2
a2878 1
                  exn_blocks, SOME finish_tag, Sexpr.NIL), [], [])))
d2904 1
a2904 1
                    
d2956 1
a2956 1
            | _ => Crash.impossible 
d2977 1
a2977 1
                  (code @@ 
d2982 1
a2982 1
                     (* cunning hack: since new_reg is an integer, its 
d3004 1
a3004 1
                                                     Then divide by 8 
d3036 1
a3036 1
                                       it combines both lower and upper
d3057 1
a3057 1
                                              3 bytes into the header 
d3064 2
a3065 1
                  exn_blocks, SOME finish_tag, Sexpr.NIL), [], [])))
d3197 2
a3198 1
		  exn_blocks, SOME finish_tag, Sexpr.NIL), [], [])))
d3241 1
a3241 1
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) => 
d3263 1
a3263 1
            | _ => Crash.impossible "_mir_cg : update can't code generate\ 
d3379 1
a3379 1
                    [MirTypes.COMMENT ((if safe then "" else "Unsafe ") 
d3440 1
a3440 1
                                   modified_tag, 
d3456 2
a3457 2
                   [MirTypes.UNARY(MirTypes.MOVE, 
                                   scratch_reg, 
d3459 1
a3459 1
                    MirTypes.STOREOP(MirTypes.STREF, 
d3466 1
a3466 1
                                     MirTypes.GP_IMM_ANY 
d3476 1
a3476 1
                    MirTypes.STOREOP(MirTypes.STREF, 
d3484 3
a3486 3
                 SOME finish_tag, 
                 Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE, 
                                           res1, 
d3511 1
a3511 1
                             Mir_Utils.INT(MirTypes.GP_GC_REG reg)] => 
d3522 1
a3522 1
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) => 
d3544 1
a3544 1
            | _ => Crash.impossible "_mir_cg : update can't code generate\ 
d3641 1
a3641 1
              (code @@ 
d3649 1
a3649 1
                    offset --- i.e., the number of bytes from beginning 
d3681 3
a3683 3
            SOME finish_tag, 
            Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE, 
                                      res1, 
d3705 1
a3705 1
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) => 
d3749 1
a3749 1
              NONE, 
d3771 1
a3771 1
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) => 
d3800 1
a3800 1
            ((Sexpr.ATOM 
d3821 1
a3821 1
              NONE, 
d3877 1
a3877 1
      fun do_ml_offset (regs,the_code) = 
d3879 1
a3879 1
	    val (reg1, reg2, code) = 
d3939 1
a3939 1
                        MirTypes.STOREOP(MirTypes.STREF, 
d3950 1
a3950 1
			 MirTypes.TEST(MirTypes.BEQ, already_on_ref_chain_tag, 
d3959 1
a3959 1
                                       MirTypes.TEST(MirTypes.BEQ, modified_tag, 
d3972 1
a3972 1
                                       MirTypes.STOREOP(MirTypes.STREF, 
d3985 1
a3985 1
                                       MirTypes.STOREOP(MirTypes.STREF, 
d3990 1
a3990 1
                       SOME already_on_ref_chain_tag, 
d3995 1
a3995 1
          fun do_deref (regs,the_code) = 
d4012 1
a4012 1
          fun do_floor (regs,the_code,exn_code) = 
d4042 1
a4042 1
          fun do_real (regs,the_code) = 
d4130 1
a4130 1
                                   MirTypes.GP_IMM_ANY ~1), 
d4171 1
a4171 1
	  val (is_constant, constant_value) = 
d4191 1
a4191 1
                else 
d4195 1
a4195 1
                    val final_instructions = 
d4226 1
a4226 1
              val final_instructions = 
d4265 2
a4266 1
		SOME tag, Sexpr.NIL), [], [])))
d4324 1
a4324 1
           Mir_Utils.combine (the_code, 
d4331 1
a4331 1
        
d4337 1
a4337 1
              case regs of 
d4353 1
a4353 1
            case regs of 
d4438 1
a4438 1
                                 opt_self_calls, 
d4445 2
a4446 2
       which are controlled by the debugging and local_functions options 
       are being done. The following code should be kept consistent 
d4452 3
a4454 3
    val do_full_lambda_opt = not generate_moduler andalso  
                             not generate_debug_info andalso 
                             not debug_variables andalso 
d4457 1
a4457 1
    (* local-function optimisations are done only if already doing full 
d4472 1
a4472 1
    val insert_interrupt = interrupt 
d4479 2
a4480 2
    val opt_first_spill : RuntimeEnv.Offset ref list ref option = 
      if variable_debug then 
d4482 1
a4482 1
      else 
d4485 1
a4485 1
    fun get_current_spills () = 
d4491 1
a4491 1
    fun spill_restorer () = 
d4494 2
a4495 2
      | SOME first_spill => 
          let 
d4502 1
a4502 1
    fun initialize_spills () = 
d4505 1
a4505 1
      | SOME first_spill => 
d4514 1
a4514 1
    fun reset_spills spill = 
d4517 1
a4517 1
      | SOME first_spill => 
d4525 1
a4525 1
      | SOME first_spill => 
d4534 4
a4537 4
        
    fun make_call_code(calls,code) = 
      if variable_debug then 
        let 
d4542 1
a4542 1
          ((Lists.reducer 
d4548 1
a4548 1
                                                     MirTypes.GP_IMM_SYMB (MirTypes.GC_SPILL_SLOT 
d4576 1
a4576 1
      (fn _ => (["Lambdas representing functions"] @@ 
d4587 1
a4587 1
      
d4618 1
a4618 1
    fun append_runtime_envs(env1,env2) = 
d4644 1
a4644 1
    fun cg_bind({lexp=lexp, size=gc_in_arg}, 
d4655 1
a4655 1
	val (reg, more_code) = 
d4657 1
a4657 1
            Mir_Utils.ONE(Mir_Utils.INT reg) => 
d4703 1
a4703 1
	  cg_bind(le, env, static_offset, start_at, 
d4709 2
a4710 2
        val runtime_envs = 
          case runtime_envs of 
d4732 1
a4732 1
                
d4759 1
a4759 1
                  
d4762 1
a4762 1
                  map 
d4771 2
a4772 2
                     val env = 
                       Lists.reducel 
d4776 1
a4776 1
                     Lists.reducel 
d4791 1
a4791 1
                     val ((first,blocks,tag_opt,last),vals,procs) = 
d4795 1
a4795 1
                     (MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr first) :: 
d4814 1
a4814 1
                  
d4829 1
a4829 1
            
d4832 2
a4833 2
    and cg_sub(arg as AugLambda.APP ({lexp=AugLambda.BUILTIN(prim,primTy), ...}, 
                                     ([{lexp=lexp, size=gc_objects_in_parm}],[]),_), 
d4851 1
a4851 1
	  output(std_out, 
d4859 1
a4859 1
        
d4882 1
a4882 1
             let 
d4903 3
a4905 3
                         
                      val _ = 
                        case exn_o of 
d4913 1
a4913 1
                       exn_tag :: rest_tags) 
d4920 1
a4920 1
           fun do_eq (regs,the_code) = 
d4928 1
a4928 1
                    | _ => 
d4932 1
a4932 1
                        
d4935 1
a4935 1
               val (reg, extra_code) = 
d5176 1
a5176 1
      | Pervasives.BYTEARRAY => 
d5179 1
a5179 1
      | Pervasives.BYTEARRAY_SUB => 
d5183 1
a5183 1
      | Pervasives.BYTEARRAY_UPDATE => 
d5256 1
a5256 1
      val (code,option,calls) = 
d5264 1
a5264 1
       if variable_debug then 
d5282 1
a5282 1
	  output(std_out, 
d5293 1
a5293 1
	cg_bind(lexp2, env, static_offset, start_at, 
d5297 2
a5298 2
      val debug_info = 
        case info of 
d5304 1
a5304 1
      val ((code,spills),debug_info) = 
d5307 1
a5307 1
        | RuntimeEnv.VARINFO (name,info,tyvar_slot) => 
d5318 2
a5319 2
               MirTypes.GC reg => 
                 let 
d5326 1
a5326 1
                     MirTypes.GP_IMM_SYMB (MirTypes.GC_SPILL_SLOT (MirTypes.DEBUG (ref_slot,name))))], 
d5332 2
a5333 2
             | MirTypes.NON_GC reg => 
                 let 
d5341 2
a5342 2
                                                   MirTypes.GP_IMM_SYMB (MirTypes.NON_GC_SPILL_SLOT 
                                                                         (MirTypes.DEBUG (ref_slot,name))))], 
d5348 2
a5349 2
             | MirTypes.FLOAT reg =>  
                 let 
d5358 2
a5359 2
                                                       MirTypes.GP_IMM_SYMB (MirTypes.FP_SPILL_SLOT 
                                                                             (MirTypes.DEBUG (ref_slot,name))))], 
d5379 1
a5379 1
	  output(std_out, 
d5395 1
a5395 1
	    output(std_out, 
d5402 2
a5403 2
      (rest_regs, Mir_Utils.combine(code, rest_code), 
       if variable_debug then 
d5405 1
a5405 1
       else 
d5411 1
a5411 1
				  (arg_list,fp_arg_list), 
d5418 1
a5418 1
        fun lookup (lvar, l) = 
d5422 1
a5422 1
            then 
d5428 1
a5428 1
                lookup' (lvar,l) 
d5431 1
a5431 1
        val dummy_info = 
d5441 1
a5441 1
              (case lookup (lvar, local_fns) of 
d5443 1
a5443 1
               | _ => 
d5487 1
a5487 1
                                 fn_reg, fn_code, 
d5493 1
a5493 1
        val code as ((first, blocks, tag_opt, last), values, procs_list) = 
d5499 1
a5499 1
          if variable_debug then 
d5501 1
a5501 1
          else 
d5520 1
a5520 1
	  output(std_out, 
d5536 1
a5536 1
              val (reg_list,code',runtime_envs,spills,calls) = 
d5564 1
a5564 1
          if variable_debug 
d5566 1
a5566 1
          else 
d5587 1
a5587 1
	  output(std_out, 
d5613 1
a5613 1
            if variable_debug 
d5623 1
a5623 1
            if variable_debug 
d5625 1
a5625 1
            else RuntimeEnv.EMPTY,spills,calls) 
d5644 1
a5644 1
	  output(std_out, 
d5649 1
a5649 1
        val list_size = 
d5671 1
a5671 1
          val is_con = 
d5700 1
a5700 1
			((Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, 
d5706 3
a5708 3
						       MirTypes.GP_IMM_SYMB 
						       (MirTypes.GC_SPILL_SLOT 
							(MirTypes.DEBUG (ref_slot,"default for switch"))))], 
d5725 2
a5726 2
		       
                  val full_body_code = 
d5729 1
a5729 1
                                                          ((Sexpr.ATOM(MirTypes.COMMENT comment :: 
d5736 1
a5736 1
                  val newblocks = 
d5744 1
a5744 1
                        blocks 
d5767 2
a5768 2
          val tagged_code = 
            if variable_debug 
d5773 1
a5773 1
                  #2 (Lists.reducer 
d5776 1
a5776 1
                         val (reg, code,runtime_env,spills,calls) = 
d5784 1
a5784 1
                          (t, (reg, 
d5790 2
a5791 2
                                                               MirTypes.GP_IMM_SYMB 
                                                               (MirTypes.GC_SPILL_SLOT 
d5793 2
a5794 2
                                                                                 "switch case " ^ 
                                                                                 Int.toString switch_case))))], 
d5825 1
a5825 1
              gc_spills >= gc_spills' andalso 
d5829 3
a5831 3
            val maximum_spills = 
              lists_reducel 
              (fn (max_spill as (s1, s2, s3),spill as (t1, t2, t3)) => 
d5844 1
a5844 1
	  val _ = output(std_out, 
d5848 3
a5850 3
          val maximum_calls = 
            lists_reducel 
            (fn (max_app,app) => if max_app > app then max_app else app) 
d5881 1
a5881 1
            let 
d5883 1
a5883 1
            in 
d5906 1
a5906 1
          fun destructuring_code regs = 
d5935 1
a5935 1
			  if num_vcc_tags = 1 then 
d5983 1
a5983 1
			  if num_imm_tags = 1 then 
d6052 1
a6052 1
		  val extra = 
d6058 1
a6058 1
		     | Mir_Utils.REAL fp_op => Crash.impossible "REAL when decoding list") 
d6083 1
a6083 1
		val (test,arg) = 
d6085 1
a6085 1
		    AugLambda.APP({lexp=AugLambda.BUILTIN (test,_), ...},([{lexp=arg,...}],[]),_) => 
d6104 1
a6104 1
		(arg_regs, SOME the_reg, code, 
d6132 1
a6132 1
	      let 
d6163 1
a6163 1
	      val (dflt_tag, end_blocks) = 
d6198 1
a6198 1
	      val body = 
d6219 1
a6219 1
	      ((if is_rel orelse not need_main_test 
d6326 1
a6326 1
				   Sexpr.CONS 
d6376 1
a6376 1
		  let 
d6383 1
a6383 1
		      map 
d6397 1
a6397 1
		let 
d6399 1
a6399 1
		  val dflt_code = 
d6407 1
a6407 1
		in 
d6434 1
a6434 1
	     main_default: the code for the default case   
d6447 1
a6447 1
		   val is_32_bits = 
d6455 1
a6455 1
                              else 
d6695 1
a6695 1
		   val is_32_bits = 
d6703 1
a6703 1
			      else 
d6724 2
a6725 2
		     fun do_conversion 
		       (AugLambda.SCON_TAG 
d7004 1
a7004 1
		   val (the_reg, extra) = 
d7058 1
a7058 1
		   val the_reg = 
d7078 1
a7078 1
		       val _ = 
d7080 1
a7080 1
		       val app_code = 
d7083 1
a7083 1
					       Mir_Utils.ONE (Mir_Utils.INT(MirTypes.GP_GC_REG 
d7152 1
a7152 1
	      val the_reg = 
d7194 1
a7194 1
	  val (main_default, main_code) = 
d7215 2
a7216 1
	     ((Sexpr.NIL, dflt_blocks, SOME end_tag, Sexpr.NIL),
d7225 1
a7225 1
		    output(std_out, 
d7230 1
a7230 1
	   if variable_debug 
d7245 1
a7245 1
	  output(std_out, 
d7266 1
a7266 1
	  output(std_out, 
d7286 1
a7286 1
	  output(std_out, 
d7326 1
a7326 1
	          Info.error' 
d7359 1
a7359 1
	        Info.error' 
d7394 1
a7394 1
	  output(std_out, 
d7424 1
a7424 1
	  output(std_out, 
d7437 1
a7437 1
              if LambdaTypes.isLocalFn instances then print "local function found\n" 
d7445 1
a7445 1
 
d7448 1
a7448 1
            
d7460 1
a7460 1
              (reg, 
d7480 2
a7481 2
          if name_string = "" 
            then [] 
d7502 1
a7502 1
           
d7508 1
a7508 1
           
d7534 2
a7535 2
          if variable_debug 
            then SOME{gc = gc_spills+1, 
d7541 1
a7541 1
          if variable_debug 
d7561 1
a7561 1
        (Mir_Utils.ONE (Mir_Utils.INT (Mir_Utils.gp_from_reg cl_reg)), 
d7574 1
a7574 1
      val runtime_lets = 
d7576 1
a7576 1
        (fn ((lvar, SOME (ref (RuntimeEnv.VARINFO (name,ty,_)))),acc) => 
d7612 2
a7613 2
            Lists.iterate 
            (fn ((name,instances),lv) => 
d7640 1
a7640 1
                               static_offset + (2 * funs_in_closure - 1), 
d7696 1
a7696 1
      
d7698 1
a7698 1
      val arg_regs_list = 
d7704 1
a7704 1
	map 
d7728 1
a7728 1
      fun generate_entry_code ((name,_),arginfo) = 
d7742 2
a7743 2
      val entry_code_list = 
        map 
d7786 2
a7787 2
	(fn ({lexp,...}, 
             (entry_code, env, static_offset, start_at,spills,calls,first_spill), 
d7807 3
a7809 2
               if insert_interrupt then
                 Sexpr.ATOM[MirTypes.INTERRUPT]
d7811 1
a7811 1
                 Sexpr.NIL),
d7820 1
a7820 1
        (zip7 (fn_bodies, 
d7840 1
a7840 1
	(fn (tag, 
d7848 2
a7849 2
            if variable_debug 
              then SOME{gc = gc_spills+1, 
d7854 1
a7854 1
            if variable_debug 
d7863 1
a7863 1
                          MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr first) :: 
d7903 2
a7904 2
      val runtime_env = 
        if variable_debug 
d7915 1
a7915 1
      (* RAISE expressions *) 
d7924 1
a7924 1
	  output(std_out, 
d7939 2
a7940 2
      val total_code = 
             Mir_Utils.combine(code, 
d7946 1
a7946 1
       if variable_debug then 
d7948 1
a7948 1
       else 
d8045 1
a8045 1
		   exn_code (*(exn_f, exn_b, exn_o, exn_l), 
d8071 2
a8072 1
		     [], SOME end_tag, Sexpr.NIL), [], [])
d8105 1
a8105 1
		   exn_code (*(exn_f, exn_b, exn_o, exn_l), 
d8135 2
a8136 2
				  ((Sexpr.ATOM main_end, [], SOME end_tag,
				    Sexpr.NIL), [], []))
d8141 1
a8141 1
	       if variable_debug then 
d8157 1
a8157 1
    val (regs, 
d8165 1
a8165 1
    val (reg, last') = 
d8232 3
a8234 3
		    MirTypes.PROC_PARAMS {spill_sizes = 
                                          if variable_debug then 
                                            SOME{gc = gc_spills+1, 
d8243 1
a8243 1
                    if variable_debug then 
d8325 1
a8325 1
	  
d8339 1
a8339 1
	    NONE => 
@


1.309
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 4
d7559 1
a7559 1
	     env, static_offset, start_at,_,
d7578 3
a7580 3
       | _ => (print (name ^ ":");
               Lists.iterate (fn v => print (N v ^ " ")) fp_args;
               print "\n"))
d7888 1
a7888 1
	       static_offset + gc_objects_within + funs,start_at + gc_objects_within + funs,false,
@


1.308
log
@[Bug #30243]
Fix problems with constant shifts by word32 values
@
text
@d4 4
d1106 2
a1107 1
require "../basis/__int";
a1128 1
require "^.basis.__old";
d6939 1
a6939 1
			     (Old.ord s, 0, code, tag)
d7352 1
a7352 1
		(Old.ord s))),
@


1.308.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.308  1997/08/14  17:10:41  jont
 * [Bug #30243]
 * Fix problems with constant shifts by word32 values
 *
@


1.308.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.308  1997/08/14  17:10:41  jont
 * [Bug #30243]
 * Fix problems with constant shifts by word32 values
 *
@


1.307
log
@[Bug #30243]
Ensure no overlong shifts produced by 32 bit shift operations
@
text
@d4 4
d2118 4
d2123 2
a2124 2
            case val2 of
              MirTypes.GP_IMM_INT i =>
@


1.306
log
@[Bug #30215]
@
text
@d4 4
d2100 1
a2100 1
      fun word32_shift_operator (mir_operator, regs, the_code) = 
d2112 2
d2117 28
a2144 18
                MirTypes.ALLOCATE
                (MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT 4)
                :: arg_code
                @@ [MirTypes.BINARY(mir_operator, tmp2, val1, MirTypes.GP_IMM_ANY i),
                   MirTypes.STOREOP
                   (MirTypes.ST, tmp2, res2, MirTypes.GP_IMM_ANY ~1),
                   MirTypes.NULLARY(MirTypes.CLEAN, tmp2)]
                @@ clean_arg_code
            | _ => 
                MirTypes.ALLOCATE
                (MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT 4)
                :: arg_code
                @@ [MirTypes.BINARY(MirTypes.LSR, spare2,val2, MirTypes.GP_IMM_ANY 2),
                   MirTypes.BINARY(mir_operator, tmp2, val1, spare1),
                   MirTypes.STOREOP(MirTypes.ST, tmp2, res2, MirTypes.GP_IMM_ANY ~1),
                   MirTypes.NULLARY(MirTypes.CLEAN, tmp2),
                   MirTypes.NULLARY(MirTypes.CLEAN, spare2)]
                @@ clean_arg_code
d5204 4
d5209 1
a5209 1
	word32_shift_operator (MirTypes.ASL, regs, the_code)
d5211 1
a5211 1
	word32_shift_operator (MirTypes.LSR, regs, the_code)
d5213 1
a5213 2
	word32_shift_operator (MirTypes.ASR, regs, the_code)

@


1.305
log
@[Bug #30186]
Use optimising/debugging compiler options consistently with the
lambda optimiser
@
text
@d4 5
d2032 9
a2047 11
	  val clean_code =
	    case val2 of
	      MirTypes.GP_IMM_INT i => []
	    | _ => [MirTypes.NULLARY(MirTypes.CLEAN, spare2)]
	  val clear_code =
	    if need_to_clear_bottom_two_bits then
	      MirTypes.BINARY(MirTypes.BIC,MirTypes.GC_REG result,
			      MirTypes.GP_GC_REG result,
			      MirTypes.GP_IMM_ANY 3) :: clean_code
	    else
	      clean_code
d2052 21
a2072 2
                MirTypes.BINARY(mir_operator,MirTypes.GC_REG result, val1,
                                MirTypes.GP_IMM_ANY i) :: clear_code
d2074 15
a2088 5
                MirTypes.BINARY(MirTypes.LSR, spare2,
                                val2, MirTypes.GP_IMM_ANY 2) ::
                MirTypes.BINARY(mir_operator,MirTypes.GC_REG result,val1,
                                spare1) ::
		clear_code
a2648 4
(*
                     MirTypes.BINARY(MirTypes.BIC,res1,
                                     MirTypes.GP_GC_REG result,MirTypes.GP_IMM_ANY 3) 
*)
a2676 4
(*
                     MirTypes.BINARY(MirTypes.BIC, res1,
                                     MirTypes.GP_GC_REG result, MirTypes.GP_IMM_ANY 3)
*)
@


1.304
log
@[Bug #2408]
Sort out problems with missing tags left out by optimisations
performed by the match compiler
@
text
@d4 5
d4374 1
d4378 19
d4581 1
a4581 1
                (closure,funs_in_closure, fn_tag_list, local_functions),
d4587 1
a4587 1
                 (closure,funs_in_closure, fn_tag_list, local_functions),spills,calls)
d4634 1
a4634 1
                   (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls) =
d4638 1
a4638 1
                  (closure,funs_in_closure,fn_tag_list,local_functions),spills,calls)
d4642 1
a4642 1
                        (closure,funs_in_closure, fn_tag_list,local_functions), spills,calls)
d4654 1
a4654 1
                         (closure,funs_in_closure,fn_tag_list,local_functions),
d4661 1
a4661 1
                        (closure,funs_in_closure,fn_tag_list,local_functions),
d4695 1
a4695 1
                  local_functions @@
d4761 1
a4761 1
                    (closure,funs_in_closure,fn_tag_list,local_functions),
d4769 1
a4769 1
               (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls) =
d4808 1
a4808 1
                    (closure,funs_in_closure,fn_tag_list,local_functions),spills,calls)
d4829 1
a4829 1
                                     (closure,funs_in_closure,fn_tag_list,local_functions),!spills,!calls)
d4883 1
a4883 1
                        (closure,funs_in_closure,fn_tag_list,local_functions),!spills,!calls)
d5205 1
a5205 1
             (closure,funs_in_closure, fn_tag_list,local_functions),
d5225 1
a5225 1
                (closure,funs_in_closure,fn_tag_list,local_functions),spills,calls)
d5319 1
a5319 1
	       (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls)
d5345 1
a5345 1
	     (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls) =
d5350 3
a5352 1
          if opt_self_calls andalso tail_position
d5372 1
a5372 1
              (case lookup (lvar, local_functions) of 
d5390 1
a5390 1
                      (closure,funs_in_closure,fn_tag_list,local_functions),spills,calls+1),
d5403 1
a5403 1
                 (closure,funs_in_closure, fn_tag_list,local_functions),
d5412 1
a5412 1
                 (closure,funs_in_closure, fn_tag_list,local_functions),
d5439 1
a5439 1
	   (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls) =
d5466 1
a5466 1
                       (closure,funs_in_closure,fn_tag_list,local_functions),spills,calls)
d5510 1
a5510 1
             (closure,funs_in_closure, fn_tag_list,local_functions),
d5529 1
a5529 1
               (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls)
d5568 1
a5568 1
             (closure,funs_in_closure,fn_tag_list,local_functions),spills,calls) =
d5623 1
a5623 1
                           (closure,funs_in_closure, fn_tag_list,local_functions),
d5709 1
a5709 1
                                  (closure,funs_in_closure, fn_tag_list, local_functions),
d5739 1
a5739 1
                          (closure,funs_in_closure, fn_tag_list, local_functions),
d6026 1
a6026 1
		   (closure, funs_in_closure, fn_tag_list, local_functions),
d6044 1
a6044 1
			 (closure,funs_in_closure, fn_tag_list,local_functions),
d6067 1
a6067 1
			 (closure,funs_in_closure, fn_tag_list,local_functions),
d6588 1
a6588 1
					(closure,funs_in_closure, fn_tag_list,local_functions),
d6842 1
a6842 1
					(closure,funs_in_closure, fn_tag_list,local_functions),
d7209 1
a7209 1
	     (closure,funs_in_closure, fn_tag_list, local_functions),spills,calls) =
d7252 1
a7252 1
		          (closure,funs_in_closure,fn_tag_list,local_functions),
d7285 1
a7285 1
		          (closure,funs_in_closure,fn_tag_list,local_functions),
d7347 1
a7347 1
             (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls) =
d7501 1
a7501 1
             (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls) =
d7830 1
a7830 1
               (closure,funs_in_closure,fn_tag_list,local_functions),spills,calls)
d7846 1
a7846 1
             (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls) =
d7859 1
a7859 1
               (closure,funs_in_closure,fn_tag_list,local_functions),spills,calls+1)
d7885 1
a7885 1
               (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls) =
d7979 1
a7979 1
		       (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls)
d7985 1
a7985 1
			 (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls)
d8015 1
a8015 1
		       (closure,funs_in_closure,fn_tag_list,local_functions),spills,calls')
d8037 1
a8037 1
		       (closure,funs_in_closure, fn_tag_list,local_functions),spills,calls)
d8056 1
a8056 1
		       (closure,funs_in_closure,fn_tag_list,local_functions),spills,calls')
d8076 1
a8076 1
             (closure,funs_in_closure, fn_tag_list,local_functions),_,_) =
@


1.303
log
@Pass options to library functions
@
text
@d4 3
d5574 1
a5574 1
             
d5600 13
a5612 14
                    if variable_debug 
                      then 
                        let
                          val new_reg = MirTypes.GC.new()
                        in
                          ((Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, 
                                                       MirTypes.GC_REG (new_reg),
                                                       MirTypes.GP_IMM_INT 0),
                                        MirTypes.STOREOP(MirTypes.STREF,
                                                         MirTypes.GC_REG (new_reg),
                                                         MirTypes.GC_REG fp,
                                                         MirTypes.GP_IMM_SYMB 
                                                         (MirTypes.GC_SPILL_SLOT 
                                                          (MirTypes.DEBUG (ref_slot,"default for switch"))))], 
d5614 1
a5614 1
                        end
d5629 1
a5629 1

d5635 2
a5636 2
                                                          [],NONE,Sexpr.NIL),
                                                          [],[])))
d5642 1
a5642 1
                      NONE => 
d5652 1
a5652 1
                 
d5659 1
a5659 1
               
d5666 2
a5667 2
            |  ((nv, ni), (AugLambda.VCC_TAG _,_)) => (nv + 1, ni)
            |  _ => Crash.impossible "bad constructor tag")
d5699 1
a5699 1
                               [],NONE, Sexpr.NIL), [], []),code),
d5706 1
a5706 1
            else 
d5769 3
a5771 3
                (AugLambda.IMM_TAG (_,t2),_, tag')], NONE) =>
              if t1 = 1 then (tag, tag') else (tag', tag)
              | _ => Crash.impossible "Relational expression with bad IMM_TAGs"
d5814 2
a5815 2
                let val (num_vccs, num_imms) =
                  case info of
d5819 1
d5823 5
a5827 8
                    let val tmp_reg = MirTypes.GC.new()
                    in 
                      (MirTypes.GP_GC_REG tmp_reg,
                       [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 0 IMM_TAG",
                        con_tag_to_reg (reg, tmp_reg),
                        main_branch],
                       true)
                    end
d5836 127
a5962 109
                    let val vcc_tag =
                      if num_vcc_tags = 1 then 
                        get_vcc_tag tagged_code
                      else if dflt_exists then
                        dflt_tag
                      else Crash.impossible ("Missing vcc_tag or default")
                    in
                      (gp_op,
                       MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 1 VCC" ::
                       (* Branch if it's a boxed value *)
                       MirTypes.TEST (MirTypes.BTA,
                                      vcc_tag,
                                      gp_op,
                                      MirTypes.GP_IMM_ANY tag_test_mask) ::
                       (if num_imm_tags = 1 andalso num_imms = 1 then
                          (* 1 VCC and 1 IMM *)
                          [MirTypes.BRANCH (MirTypes.BRA,
                                            MirTypes.TAG (get_imm_tag tagged_code))]
                       else if num_imm_tags = 0 then
                         (* num_imms = 1 => num_imm_tags = 0 here *)
                         (* So any imm tag must be the default *)
                         let
                           val branch =
                             [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG dflt_tag)]
                         in
                           case dflt of
                             NONE =>
                               (* This is the nasty semantically invalid case *)
                               (* Why isn't this a Crash? *)
                               MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG end_reg,
                                              MirTypes.GP_IMM_INT 0) :: branch
                           | _ => branch
                         end
                       else [main_branch]),
                       num_imms <> 1 andalso num_imm_tags <> 0)
                    end
                    else if num_imms = 1 then
                      (* 1 IMM case *)
                      let val tmp_reg = MirTypes.GC.new()
                        val imm_tag =
                          if num_imm_tags = 1 then 
                            get_imm_tag tagged_code
                          else if dflt_exists then dflt_tag
                          else Crash.impossible "Missing imm_tag or default"
                      in (MirTypes.GP_GC_REG tmp_reg,
                          MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 1 IMM_TAG" ::
                          MirTypes.TEST(MirTypes.BNT,
                                        imm_tag,
                                        gp_op,
                                        MirTypes.GP_IMM_ANY tag_test_mask) ::
                          (if num_vcc_tags = 0 then
                             [MirTypes.BRANCH(MirTypes.BRA,
                                              MirTypes.TAG dflt_tag)]
                           else
                             [con_tag_to_reg (reg, tmp_reg),
                              main_branch]),
                             num_vcc_tags <> 0)
                      end
                     else 
                       (* num_vccs > 1 andalso num_imms > 1 *)
                       if num_vcc_tags = 0 then
                         (gp_op,
                          [MirTypes.TEST(MirTypes.BTA,
                                         dflt_tag,
                                         gp_op,
                                         MirTypes.GP_IMM_ANY tag_test_mask),
                          main_branch],
                          true)
                       else if num_imm_tags = 0 then
                         let val tmp_reg = MirTypes.GC.new()
                         in (MirTypes.GP_GC_REG tmp_reg,
                             [MirTypes.TEST(MirTypes.BNT,
                                            dflt_tag,
                                            gp_op,
                                            MirTypes.GP_IMM_ANY tag_test_mask),
                             con_tag_to_reg (reg, tmp_reg),
                             main_branch],
                             true)
                         end
                       else
                         let val tmp_reg = MirTypes.GC.new()
                         in (MirTypes.GP_GC_REG tmp_reg,
                             [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, general case",
                              MirTypes.UNARY(MirTypes.MOVE,
                                             MirTypes.GC_REG tmp_reg,
                                             gp_op),
                              MirTypes.TEST(MirTypes.BNT,
                                            main_tag,
                                            MirTypes.GP_GC_REG tmp_reg,
                                            MirTypes.GP_IMM_ANY tag_test_mask),
                              con_tag_to_reg (reg, tmp_reg),
                              main_branch],
                             true)
                         end
		   end
	     | Mir_Utils.ONE(Mir_Utils.INT(gp_op)) => Crash.impossible "_mir_cg: Mir_Utils.INT\n"
	     (* Do we need to handle GP_NON_GC_REG? *)
             | Mir_Utils.ONE(Mir_Utils.REAL _) => Crash.impossible "SWITCH(Mir_Utils.ONE(Mir_Utils.REAL))"
             | Mir_Utils.LIST many =>
             (* It's implausible that this gets past the lambda optimizer *)
                 let val tmp_reg = MirTypes.GC.new()
		     val index = 0
		     val extra = 
                       (case Lists.nth(index, many) of
                          Mir_Utils.INT gp_op =>
                            MirTypes.UNARY(MirTypes.MOVE,
                                           MirTypes.GC_REG tmp_reg,
                                           gp_op)
                        | Mir_Utils.REAL fp_op => Crash.impossible "REAL when decoding list") 
d5969 81
a6049 5
                 in (MirTypes.GP_GC_REG tmp_reg,
	  	     MirTypes.COMMENT "select for LIST" ::
		     [extra, main_branch],
		     true)
		 end
d6051 29
a6079 25
             (* what is the result here? *)
             (* it depends on what sort of switch we have *)
             (* arg_regs:  The switch argument, possible unboxed, literal or untupled -- only used for scons and exns *)
             (* the_reg_opt:  A register with the switch arg in *)
             (* switch_arg_code:  Code for producing the switch argument *)
             (* need_main_test:  Something cunning! *)

             val (arg_regs, the_reg_opt, switch_arg_code,need_main_test,runtime_env',spills,calls) =
               (* A simple relational test *)
               if is_rel then
                 let
                   val (test,arg) = 
                     case lexp of
                       AugLambda.APP({lexp=AugLambda.BUILTIN (test,_), ...},([{lexp=arg,...}],[]),_) => 
                         (test,arg)
                     | AugLambda.APP({lexp=AugLambda.BUILTIN _, ...},args,_) =>
                         Crash.impossible "Arglist in rel expr"
                     | _ => Crash.impossible"Bad rel lexp"

                   (* Code generate the arguments *)
                   val (arg_regs, arg_code,arg_runtime_env,spills,calls) =
                     cg_sub
		       (arg, env, static_offset, start_at,false,
                        (closure, funs_in_closure, fn_tag_list, local_functions),
			maximum_spills,maximum_calls)
d6081 9
a6089 2
                   val (the_reg, extra) = Mir_Utils.send_to_reg arg_regs
		     (* This is bogus -- but it doesn't matter!!! *)
d6091 18
a6108 23
                   val code =
		     make_if (test, arg_regs,arg_code, true_tag, false_tag)
                 in
                   (arg_regs, SOME the_reg, code, 
                    false,arg_runtime_env,spills,calls)
                 end
               else if is_con then
                 (* datatype constructor matches *)
                 let
                   val (regs, the_code,runtime_env,spills,calls) =
                     (* Code generate the switch argument *)
                     cg_sub(lexp, env, static_offset, start_at,false,
                            (closure,funs_in_closure, fn_tag_list,local_functions),
                            maximum_spills,maximum_calls)

                   (* And make some code to get the tags *)
                   val (the_reg, select_code, need_main_test) = destructuring_code regs
		   
		   val block =
		     Mir_Utils.combine(the_code,
                                       ((Sexpr.ATOM (select_code),[],NONE,Sexpr.NIL),
                                        [],
                                        []))
d6110 47
a6156 21
                   (Mir_Utils.ONE(Mir_Utils.INT(the_reg)),
		    SOME the_reg,
		    block,   (* Compute arg and extract tag *)
		    need_main_test,runtime_env,spills,calls)
                 end
	       else
                 (* scon and expression matches *)
		 let 
                   val (regs, the_code,runtime_env,spills,calls) =
                     (* Code generate the switch argument *)
                     cg_sub(lexp, env, static_offset, start_at,false,
                            (closure,funs_in_closure, fn_tag_list,local_functions),
                            maximum_spills,maximum_calls);

		   val block =
		     Mir_Utils.combine(the_code,
                                       ((Sexpr.ATOM [main_branch],[],NONE,Sexpr.NIL),
                                        [],[]))
		 in
		   (regs, NONE, block, true,runtime_env,spills,calls)
		 end
d6158 4
a6161 111
             val calls : int ref = ref calls
             val spills : (int * int * int) ref = ref spills
             val runtime_env' : RuntimeEnv.RuntimeEnv ref = ref runtime_env'

             (* Some auxiliary functions *)

             (* Handle the case of using computed gotos *)
             fun make_cgt(MirTypes.GP_IMM_INT _,_,_,_) =
                 Crash.impossible"make_cgt GP_IMM_INT"
               | make_cgt(MirTypes.GP_IMM_ANY _,_,_,_) =
                 Crash.impossible"make_cgt GP_IMM_ANY"
               | make_cgt(MirTypes.GP_IMM_SYMB _,_,_,_) =
                 Crash.impossible"make_cgt GP_IMM_SYMB"
               | make_cgt(gp_operand, low, high, val_code_tag_list) =
                 let
                   val reg_op = Mir_Utils.reg_from_gp gp_operand
                   val (dflt_tag, end_blocks) = 
                     case dflt of
                       NONE =>
                         let val tag1 = MirTypes.new_tag()
                         in (tag1,
                             [MirTypes.BLOCK(tag1,
                                             [MirTypes.COMMENT "CGT default",
                                              MirTypes.UNARY(MirTypes.MOVE,
                                                             MirTypes.GC_REG end_reg,
                                                             MirTypes.GP_IMM_ANY 1),
                                              final_branch])])
                         end
                     | _ => (dflt_tag, [])

                   val full_tag_list =
                     let
                       fun expand [] = []
                         | expand ([(_,_, tag)]) = [tag]
                         | expand ((i,_, tag) :: (rest as ((j,_,_) :: _))) =
                           tag :: Mir_Utils.list_of (j-i-1, dflt_tag) @@ expand rest
                     in
                       expand val_code_tag_list
                     end

                   val values =
                     Lists.reducer
		     (fn ((_, (_, (_, value,_),_,_,_),_), value') =>
		      value @@ value')
		     (val_code_tag_list, [])

                   val procs =
                     Lists.reducer
		     (fn ((_, (_, (_,_, proc),_,_,_),_), proc') => proc @@ proc')
		     (val_code_tag_list, [])

		   val body = 
                     map
                     (fn (_, (regs, ((first, blocks, tag_opt, last),_,_),_,_,_),tag) =>
                      let
                        val end_code =
                          Mir_Utils.send_to_given_reg(regs, end_reg) @@
                          [MirTypes.COMMENT "end CGT", final_branch]
                      in
                        (case tag_opt of
                           NONE =>
                             [MirTypes.BLOCK(tag,
                                             Mir_Utils.contract_sexpr(Sexpr.CONS(first, Sexpr.ATOM end_code)))]
                         | SOME tag1 =>
                             [MirTypes.BLOCK(tag,
                                             Mir_Utils.contract_sexpr first),
                              MirTypes.BLOCK(tag1,
                                             Mir_Utils.contract_sexpr(Sexpr.CONS(last, Sexpr.ATOM end_code)))])
                        @@ blocks
                      end)
                     val_code_tag_list
                 in
                   ((if is_rel orelse not need_main_test 
                       then Sexpr.NIL
		     else
		       Sexpr.ATOM(
			 if low = 0 then
                           [MirTypes.SWITCH(MirTypes.CGT,
					    reg_op,
					    full_tag_list)]
                         else
                           let val new_reg_op = MirTypes.GC.new()
                           in [MirTypes.TEST(MirTypes.BLT,
					     dflt_tag,
					     gp_operand,
                                             MirTypes.GP_IMM_INT low),
                               MirTypes.BINARY(MirTypes.SUBU,
					       MirTypes.GC_REG new_reg_op,
                                               gp_operand,
					       MirTypes.GP_IMM_INT low),
                               MirTypes.SWITCH(MirTypes.CGT,
			      		       MirTypes.GC_REG new_reg_op,
                                               full_tag_list),
                               MirTypes.COMMENT "Switch relative to lowest tag"]
                           end
		       ),
                     Lists.reducer
		       op@@
                       (end_blocks :: body, []),
                     NONE,
		     Sexpr.NIL
		    ),
		    values,
		    procs
		   )
                 end (* of make_cgt *)

             fun bounds(low:int, high, []) = (low, high)
               | bounds(low, high, i :: xs) =
                 if (i < low) then bounds(i, high, xs)
                 else if (i > high) then bounds(low, i, xs)
d6164 24
a6187 24
             (* Test as one damn thing after another *)
             fun do_chained_tests(_, default, [], test_opt, clean_code) =
               (((case (default, test_opt) of
		    (* This should never be called without a default,
		     but it's worth being on the safe side.
		     *)
		    (SOME _, SOME _) =>
		      Sexpr.ATOM
			(clean_code @@
			 [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG dflt_tag),
			  MirTypes.COMMENT "default or end"])
		  | (SOME _, NONE) =>
		      Sexpr.NIL (* This one ok *)
		  | (_, SOME _) =>
		      (* This one ok, but should have converted previous *)
		      (* conditional branch to be unconditional *)
		      Sexpr.NIL
		  | _ => Sexpr.NIL (* This one ok *)),
		    [],
		    NONE,
		    Sexpr.NIL),
		    [],[])
	       |   do_chained_tests
		     (the_reg, default, head :: rest, test_opt, clean_code) =
d6256 59
a6314 59
	       fun constructor_code () =
                 let
                   (* Bind tags to previously generated body code *)
                   val val_code_tags_list =
                     Lists.qsort (fn ((i:int,_,_), (i',_,_)) => i < i')
                     (map
                      (fn (AugLambda.IMM_TAG (_,i), le, tag) => (i, le, tag)
                       |  (AugLambda.VCC_TAG (_,i), le, tag) => (i, le, tag)
                       | _ => Crash.impossible "Mixed tag type in switch")
                      tagged_code)

                   val (i, (result_reg, code,_,_,_), first_tag) =
		     case val_code_tags_list of
                       x :: _ => x
                     | _ => Crash.impossible "Empty datatype list"

		   val the_reg =
		     case the_reg_opt of
		       SOME x => x
		     | NONE => Crash.impossible "Missing the_reg"
                 in
		   if length val_code_tags_list < 3
                     (* The small case *)
                     then
                       let 
                         fun do_test(reg, i,_, tag) =
                           {test_code =
			      Sexpr.ATOM [MirTypes.TEST(MirTypes.BEQ, tag, reg,
                                                        MirTypes.GP_IMM_INT i)],
			    test_clean = []}
                         val val_le_tags_list =
                           map 
                           (fn (i, code, tag) => (i, 0, code, tag))
                           val_code_tags_list
                       in ([],
                           do_chained_tests
			     (the_reg, dflt, val_le_tags_list,
                              if need_main_test then
				SOME do_test
                              else
				NONE,
			      []))
                       end
                   else
                     (* Computed goto case *)
                     let 
                       val (low, high) = bounds (i, i, map #1 val_code_tags_list)
                       val dflt_code = 
                         case dflt of
                           NONE => []
                         | SOME _ =>
                             [MirTypes.TEST(MirTypes.BGT, dflt_tag, the_reg,
                                            MirTypes.GP_IMM_INT high)]
                       val main =
                         make_cgt(the_reg, low, high, val_code_tags_list)
                     in 
                       (dflt_code, main)
                     end
                 end
d6316 9
a6324 9
               fun empty_tel_code () =
                 let
                   val dflt_code = case dflt of
                     NONE => []
                   | SOME _ =>
	               [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG dflt_tag)]
                 in
                   (MirTypes.COMMENT "nil main def" :: dflt_code, no_code)
                 end
d6326 22
a6347 1
	       fun find_large_value to_bignum (v1, v2) =
d6349 27
a6375 1
		   val v = to_bignum v1
d6377 85
a6461 2
		   v2
		 end
d6463 83
a6545 2
		   BigNum.Unrepresentable => v1
		 | BigNum32.Unrepresentable => v1
d6547 62
a6608 273
               fun scon_code (scon, max_size_opt) =
		 (* Returns (main_default, main_code).   Both opcode lists.
                    main_default: the code for the default case   
                    main_code : the code for the non-default cases *)
                 (* From a special constant match, use a computed goto for ints
		    in a suitably small range, and multiple tests and branches
		    for other int cases, reals and strings. *)
                 (* We now have to deal with chars, which could in some cases
		    be treated as constructors from a set of 256.
		    Also there are words. *)
                 (case scon of
		    Ident.INT _ =>
		      let
			(* 32-bit ints are stored as four-byte strings on
			   32-bit architectures, and require special code. *)
			val is_32_bits = 
			  case max_size_opt of
                            NONE => false
			  | SOME sz =>
                              if sz <= MachSpec.bits_per_word then
                                false
                              else if sz = 32 then
                                true
                              else 
                                Crash.impossible
				("Unknown integer size in pattern " ^ Int.toString sz)
			(* clean_code cleans the register that holds the
			   unboxed 32-bit value. *)
			val (the_reg, extra, clean_code) =
			  if is_32_bits then
			    case arg_regs of
                              Mir_Utils.ONE reg => Mir_Utils.get_word32 reg
			    |  _ =>
                                 Crash.impossible "LIST found in switch on Integer32"
			  else
			    let
			      val (reg, code) = Mir_Utils.send_to_reg arg_regs
			    in
			      (reg, code, [])
			    end
		      in
			let
			  fun do_conversion (AugLambda.SCON_TAG (Ident.INT (i,location), max_size_opt),
                                             code, tag) =
			    (Mir_Utils.convert_int (i, max_size_opt), 0, code, tag)
                            | do_conversion _ = Crash.impossible "Mixed tag type in switch"

			  (* If we get here (i.e. no exception has been
			     raised), then all the scons fit in integers
			     of the compiling machine.  We still don't
			     know the size of the value being switched on. *)
			  val val_le_tags_list =
			    Lists.qsort
			      (fn ((i:int,_,_,_), (i',_,_,_)) => i < i')
			      (map do_conversion tagged_code)

			  (* Patch for Jont *)
			  val a_value = case val_le_tags_list of
			    {1=i, ...} :: _ => i
			  | _ => Crash.impossible"empty val_le_tags_list"

			  val (low, high) =
			    bounds (a_value, a_value, map #1 val_le_tags_list)

			  val len = length val_le_tags_list

			  val use_cgt =
			    not (is_32_bits) andalso
			    high + 1 - low <= 2 * len andalso len > 2

			  (* Not too many holes, but a bigger than two list *)

			  (* We possibly could construct a computed goto for
			     32 bit integers, since all the patterns fit in
			     single integers.  We would first test the argument
			     to see if the top two bits were set, branching
			     to the default case if so, and shifting left by
			     two otherwise. *)

			  val dflt_code = case dflt of
			    NONE =>
			      [MirTypes.COMMENT
				"No default (strange for scon match)"]
			  | SOME _ =>
			      if is_32_bits then
			        [MirTypes.COMMENT "Default",
			         MirTypes.TEST
			           (MirTypes.BGT, dflt_tag, the_reg,
				    MirTypes.GP_IMM_ANY high)]
			      else
			        [MirTypes.COMMENT "Default",
			         MirTypes.TEST
			           (MirTypes.BGT, dflt_tag, the_reg,
				    MirTypes.GP_IMM_INT high)]
			in
			  if use_cgt then
			    (extra @@ dflt_code,
			     make_cgt
			       (the_reg, low, high,
			        map
				  (fn (x,_, y, z) => (x, y, z))
				  val_le_tags_list))
			  else
			    let
			      fun do_test(reg, i, _, tag) =
				if is_32_bits then
			  	  {test_code =
				     Sexpr.ATOM
				       [MirTypes.TEST
				          (MirTypes.BEQ, tag, reg,
				           MirTypes.GP_IMM_ANY i)],
				   test_clean = []}
				else
			  	  {test_code =
			  	     Sexpr.ATOM
				       [MirTypes.TEST
				          (MirTypes.BEQ, tag, reg,
				           MirTypes.GP_IMM_INT i)],
				   test_clean = []}
			    in
			      (extra,
			       do_chained_tests
				 (the_reg, dflt, val_le_tags_list,
				  SOME do_test, clean_code))
			    end
			end
			handle
			  Mir_Utils.ConvertInt =>
                          (* If we have values that don't fit in a machine
			     word on the compiling machine, we use runtime
			     evaluation of the integers in the patterns. *)
			  let
			    fun to_string(Ident.INT(i,_)) = i
			      | to_string _ =
			      Crash.impossible"Mixed tag type in switch"

			    fun location_scon(Ident.INT(_, location)) =
			      location
			    |   location_scon _ =
			      Crash.impossible"Mixed tag type in switch"

			    fun to_bignum x =
			      let
				val str_x = to_string x
			      in
				if size str_x < 2 then
				  BigNum.string_to_bignum str_x
				else
				  case substring (* could raise Substring *)(str_x, 0, 2)
				  of "0x" =>
				    BigNum.hex_string_to_bignum str_x
				  | _ =>
				    BigNum.string_to_bignum str_x
			      end

			    (* Again, 32-bit values are a special case. *)
			    fun to_bignum32 x =
			      let
				val str_x = to_string x
			      in
				if size str_x < 2 then
				  BigNum32.string_to_bignum str_x
				else
				  case substring (* could raise Substring *)(str_x, 0, 2)
				  of "0x" =>
				    BigNum32.hex_string_to_bignum str_x
				  | _ =>
				    BigNum32.string_to_bignum str_x
			      end

			    fun compare_bignums ((i,_,_,_), (i',_,_,_)) =
			      BigNum.<(to_bignum i, to_bignum i')
			      handle BigNum.Unrepresentable =>
			 	let
				   val i = find_large_value to_bignum (i, i')
				in
				  Info.error'
				    error_info
				    (Info.FATAL, location_scon i,
				     "Integer too big: " ^ to_string i)
				end

			    fun compare_bignums32 ((i,_,_,_), (i',_,_,_)) =
			      BigNum32.<(to_bignum32 i, to_bignum32 i')
			      handle BigNum32.Unrepresentable =>
			 	let
				   val i = find_large_value to_bignum32 (i, i')
				in
				  Info.error'
				    error_info
				    (Info.FATAL, location_scon i,
				     "Integer too big: " ^ to_string i)
				end

			    (* This is the equivalent of do_conversion in the
			       main case.  It differs in that it doesn't
			       convert the scon. *)
			    fun check_tag
				  (AugLambda.SCON_TAG (scon, _), code, tag) =
			      (scon, 0, code, tag)
		            |   check_tag _ =
			      Crash.impossible"Mixed tag type in switch"
					
			    val val_le_tags_list =
			      Lists.qsort
				(if is_32_bits then
				   compare_bignums32
				 else
				   compare_bignums)
			        (map check_tag tagged_code)

			    val low =
                              case val_le_tags_list of
                                (scon,_,_,_) :: _ => scon
                              | _ => Crash.impossible "Empty switch list"

			    val high =
                              case (last val_le_tags_list) of
                                (scon,_,_,_) => scon

			    fun do_test(reg, long_i,_, tag) =
			      let
				val (reg', the_code) = (case
				  cg_sub(Mir_Utils.convert_long_int (long_i, max_size_opt), env,
					 static_offset, start_at,false,
					 (closure,funs_in_closure, fn_tag_list,local_functions),
                                         !spills,!calls) of
				  (Mir_Utils.ONE(Mir_Utils.INT(r as MirTypes.GP_GC_REG _)),
				   ((code, [], NONE, Sexpr.NIL),
				    [], []),_,_,_) => (r, code)
				  | _ => Crash.impossible"Bad code for big integer")
			          handle
				    Mir_Utils.Unrepresentable =>
				      Info.error'
				        error_info
				        (Info.FATAL, location_scon long_i,
				         "Integer too big: " ^ to_string long_i)

				val (arg_reg, arg_code, arg_clean) =
			          Mir_Utils.get_word32 (Mir_Utils.INT reg')

				val test =
				  MirTypes.TEST
				    (MirTypes.BEQ, tag, reg, arg_reg)
			      in
				{test_code =
				   Sexpr.CONS
				     (the_code,
				      Sexpr.ATOM (arg_code @@ [test ])),
				 test_clean = arg_clean}
			      end
			  in
			    (extra,
			     do_chained_tests
			       (the_reg, dflt, val_le_tags_list,
				SOME do_test, clean_code))
			  end (* of handler *)
		      end (* of INTSCON case *)
		  | Ident.WORD _ =>
		      (* Words are very much like ints *)
			(* 32-bit words are stored as four-byte strings on
			   32-bit architectures, and require special code. *)
		      let
			val is_32_bits = 
			  case max_size_opt
		          of NONE => false
			  |  SOME sz =>
			    if sz <= MachSpec.bits_per_word then
			      false
			    else if sz = 32 then
			      true
			    else 
			      Crash.impossible
d6612 385
a6996 470
			val (the_reg, extra, clean_code) =
			  if is_32_bits then
			    case arg_regs
			    of Mir_Utils.ONE reg =>
			      Mir_Utils.get_word32 reg
			    |  _ =>
			      Crash.impossible
				"LIST found in switch on Word32"
			  else
			    let
			      val (reg, code) = Mir_Utils.send_to_reg arg_regs
			    in
			      (reg, code, [])
			    end
		      in
			let
			  fun do_conversion 
			        (AugLambda.SCON_TAG 
				   (Ident.WORD (i,location), max_size_opt),
				 code, tag) =
			    (Mir_Utils.convert_word (i, max_size_opt),
			     0, code, tag)
			  |   do_conversion _ =
			    Crash.impossible "Mixed tag type in switch"

			  (* If we get here (i.e. no exception has been
			     raised), then all the scons fit in words
			     of the compiling machine.  We still don't know
			     the size of the value being switched on. *)
			  val val_le_tags_list =
			    Lists.qsort
			      (fn ((i:int,_,_,_), (i',_,_,_)) => i < i')
			      (map do_conversion tagged_code)

			  (* Patch for Jont *)
			  val a_value = case val_le_tags_list of
			    {1=i, ...} :: _ => i
			  | _ => Crash.impossible"empty val_le_tags_list"

			  val (low, high) =
			    bounds (a_value, a_value, map #1 val_le_tags_list)

			  val len = length val_le_tags_list

			  val use_cgt =
			    not (is_32_bits) andalso
			    high + 1 - low <= 2 * len andalso len > 2

			  (* Not too many holes, but a bigger than two list *)

			  (* We possibly could construct a computed goto for
			     32 bit words, since all the patterns fit in
			     single words.  We would first test the argument
			     to see if the top two bits were set, branching
			     to the default case if so, and shifting left by
			     two otherwise. *)

			  val dflt_code = case dflt of
			    NONE =>
			      [MirTypes.COMMENT
				"No default (strange for scon match)"]
			  | SOME _ =>
			      if is_32_bits then
			        [MirTypes.COMMENT "Default",
			         MirTypes.TEST
			           (MirTypes.BHI, dflt_tag, the_reg,
				    MirTypes.GP_IMM_ANY high)]
			      else
			        [MirTypes.COMMENT "Default",
			         MirTypes.TEST
			           (MirTypes.BHI, dflt_tag, the_reg,
				    MirTypes.GP_IMM_INT high)]
			in
			  if use_cgt then
			    (extra @@ dflt_code,
			     make_cgt
			       (the_reg, low, high,
			        map
				  (fn (x,_, y, z) => (x, y, z))
				  val_le_tags_list))
			  else
			    let
			      fun do_test(reg, i, _, tag) =
				if is_32_bits then
			  	  {test_code =
				     Sexpr.ATOM
				       [MirTypes.TEST
				          (MirTypes.BEQ, tag, reg,
				           MirTypes.GP_IMM_ANY i)],
				   test_clean = []}
				else
			  	  {test_code =
			  	     Sexpr.ATOM
				       [MirTypes.TEST
				          (MirTypes.BEQ, tag, reg,
				           MirTypes.GP_IMM_INT i)],
				   test_clean = []}
			    in
			      (extra,
			       do_chained_tests
				 (the_reg, dflt, val_le_tags_list,
				  SOME do_test, clean_code))
			    end
			end
			handle
			  Mir_Utils.ConvertInt =>
                          (* If we have values that don't fit in a machine
			     word on the compiling machine, we use runtime
			     evaluation of the words in the patterns. *)
			  let
			    fun to_string(Ident.WORD(i,_)) = i
			      | to_string _ =
			      Crash.impossible"Mixed tag type in switch"

			    fun location_scon(Ident.WORD(_, location)) =
			      location
			    |   location_scon _ =
			      Crash.impossible"Mixed tag type in switch"

			    fun to_bignum x =
			      let
				val str_x = to_string x
			      in
				if size str_x < 3 then
				  BigNum.word_string_to_bignum str_x
				else
				  case substring (* could raise Substring *)(str_x, 0, 3)
				  of "0wx" =>
				    BigNum.hex_word_string_to_bignum str_x
				  | _ =>
				    BigNum.word_string_to_bignum str_x
			      end

			    (* Again, 32-bit values are a special case. *)
			    fun to_bignum32 x =
			      let
				val str_x = to_string x
			      in
				if size str_x < 3 then
				  BigNum32.word_string_to_bignum str_x
				else
				  case substring (* could raise Substring *)(str_x, 0, 3)
				  of "0wx" =>
				    BigNum32.hex_word_string_to_bignum str_x
				  | _ =>
				    BigNum32.word_string_to_bignum str_x
			      end

			    fun compare_bignums ((i,_,_,_), (i',_,_,_)) =
			      BigNum.<(to_bignum i, to_bignum i')
			      handle BigNum.Unrepresentable =>
			 	let
				   val i = find_large_value to_bignum (i, i')
				in
				  Info.error'
				    error_info
				    (Info.FATAL, location_scon i,
				     "Word too big: " ^ to_string i)
				end

			    fun compare_bignums32 ((i,_,_,_), (i',_,_,_)) =
			      BigNum32.<(to_bignum32 i, to_bignum32 i')
			      handle BigNum32.Unrepresentable =>
			 	let
				   val i = find_large_value to_bignum32 (i, i')
				in
				  Info.error'
				    error_info
				    (Info.FATAL, location_scon i,
				     "Word too big: " ^ to_string i)
				end

			    (* This is the equivalent of do_conversion in the
			       main case.  It differs in that it doesn't
			       convert the scon. *)
			    fun check_tag
				  (AugLambda.SCON_TAG (scon, _), code, tag) =
			      (scon, 0, code, tag)
		            |   check_tag _ =
			      Crash.impossible"Mixed tag type in switch"
					
			    val val_le_tags_list =
			      Lists.qsort
				(if is_32_bits then
				   compare_bignums32
				 else
				   compare_bignums)
			        (map check_tag tagged_code)

			    val low =
                              case val_le_tags_list of
                                (scon,_,_,_) :: _ => scon
                              | _ => Crash.impossible "Empty switch list"

			    val high =
                              case (last val_le_tags_list) of
                                (scon,_,_,_) => scon

			    fun do_test(reg, long_i,_, tag) =
			      let
				val (reg', the_code) = (case
				  cg_sub(Mir_Utils.convert_long_word (long_i, max_size_opt), env,
					 static_offset, start_at,false,
					 (closure,funs_in_closure, fn_tag_list,local_functions),
                                         !spills,!calls) of
				  (Mir_Utils.ONE(Mir_Utils.INT(r as MirTypes.GP_GC_REG _)),
				   ((code, [], NONE, Sexpr.NIL),
				    [], []),_,_,_) => (r, code)
				  | _ => Crash.impossible"Bad code for big word")
			          handle
				    Mir_Utils.Unrepresentable =>
				      Info.error'
				        error_info
				        (Info.FATAL, location_scon long_i,
				         "Word too big: " ^ to_string long_i)

				val (arg_reg, arg_code, arg_clean) =
			          Mir_Utils.get_word32 (Mir_Utils.INT reg')

				val test =
				  MirTypes.TEST
				    (MirTypes.BEQ, tag, reg, arg_reg)
			      in
				{test_code =
				   Sexpr.CONS
				     (the_code,
				      Sexpr.ATOM (arg_code @@ [test ])),
				 test_clean = arg_clean}
			      end
			  in
			    (extra,
			     do_chained_tests
			       (the_reg, dflt, val_le_tags_list,
				SOME do_test, clean_code))
			  end (* of handler *)
		      end (* of WORDSCON case *)
		  | Ident.CHAR _ =>
		      let
			val (the_reg, extra) = Mir_Utils.send_to_reg arg_regs
		      in
			let
			  val val_le_tags_list =
			    Lists.qsort (fn ((i:int,_,_,_), (i',_,_,_)) =>
					 i < i')
			    (map (fn (AugLambda.SCON_TAG(Ident.CHAR s, _), code, tag) =>
				  (Old.ord s, 0, code, tag)
			          | _ => Crash.impossible"Mixed tag type in switch")
			     tagged_code)
			  (* Patch for Jont *)
			  val a_value = case val_le_tags_list of
			    {1=i, ...} :: _ => i
			  | _ => Crash.impossible"empty val_le_tags_list"
			  val (low, high) = bounds(a_value, a_value, map #1 val_le_tags_list)
			  val len = length val_le_tags_list
			  val use_cgt = high + 1 - low <= 2 * len andalso len > 2
			  (* Not too many holes, but a bigger than two list *)

			  val dflt_code = case dflt of
			    NONE => [MirTypes.COMMENT"No default (strange for scon match)"]
			  | SOME _ =>
			      [MirTypes.COMMENT "Default",
			       MirTypes.TEST(MirTypes.BHI, dflt_tag, the_reg,
					     MirTypes.GP_IMM_INT high)]
			in
			  if use_cgt then
			    (extra @@ dflt_code,
			     make_cgt(the_reg, low, high,
				      map
				      (fn (x,_, y, z) => (x, y, z))
				      val_le_tags_list))
			  else
			    let
			      fun do_test(reg, i,_, tag) =
				{test_code =
				   Sexpr.ATOM
				     [MirTypes.TEST(MirTypes.BEQ, tag, reg,
						    MirTypes.GP_IMM_INT i)],
				 test_clean = []}
			    in
			      (extra,
			       do_chained_tests(the_reg,
						dflt,
						val_le_tags_list,
						SOME do_test,
						[]))
			    end
			end
		      end (* of CHARSCON case *)
                  | Ident.REAL _ =>
                      (* The real case *)
                      let
                        val val_le_tags_list =
                          map (fn ((AugLambda.SCON_TAG(Ident.REAL _, _), code, tag), p) =>
                               (p, 0, code, tag)
                        | _ => Crash.impossible"Mixed tag type in switch")
                          (Lists.zip(tagged_code, tag_positions))
                        val (the_reg, extra) = 
                          case arg_regs of
                            Mir_Utils.ONE reg => Mir_Utils.get_real reg
                          | _ => Crash.impossible "struct gives single REAL"

                        fun do_test(reg, i,_, tag) =
                          (* reg is the value input,
                           i is the immediate constant (in the case of an int)
                           or the position in the closure for this function,
                           relative to static_offset + funs_in_closure
                           in the case of a real or string
                           tag is where to go to on successful comparison *)
                          let
                            val fp_op = MirTypes.FP_REG(MirTypes.FP.new())
                          in
			    {test_code =
                               Sexpr.ATOM
				 [MirTypes.STOREOP
				    (MirTypes.LD,
				     MirTypes.GC_REG MirRegisters.global,
				     MirTypes.GC_REG callee_closure,
				     MirTypes.GP_IMM_ANY
					(4 * (static_offset + i + (funs_in_closure * 2 - 1)) - 1)),
				  MirTypes.STOREFPOP
                                    (MirTypes.FLD, fp_op,
                                     MirTypes.GC_REG MirRegisters.global,
                                     MirTypes.GP_IMM_ANY real_offset),
                                  MirTypes.FTEST(MirTypes.FBEQ, tag, fp_op, reg)],
			     test_clean = []}
                          end

                        val tags_code =
                          map
                          (fn (p, (t,_)) =>
                           case t of
                             AugLambda.SCON_TAG(scon as Ident.REAL _, _) =>
                               MirTypes.VALUE(top_closure (start_at + p + 1),
                                              MirTypes.SCON scon)
                           | _ => Crash.impossible"non-REAL in REAL switch"
                               )
                          (Lists.zip(tag_positions, tag_le_list))
                      in
                        (extra,
                         Mir_Utils.combine(((Sexpr.NIL, [], NONE, Sexpr.NIL), tags_code, []),
                                           do_chained_tests(the_reg, dflt, val_le_tags_list, SOME do_test, [])))
                      end (* of REALSCON case *)
                  | Ident.STRING _ =>
                      let
                        val val_le_tags_list =
                          map
                          (fn ((AugLambda.SCON_TAG(Ident.STRING _, _), code, tag), p) =>
                           (p, 0, code, tag)
                        | _ => Crash.impossible"Mixed tag type in switch")
                          (Lists.zip(tagged_code, tag_positions))
                        val the_reg = 
                          case arg_regs of
                            Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_GC_REG _)) => arg
                          | _ => Crash.impossible"struct gives single STRING"
                            
                        fun do_test(reg, i,_, tag) =
                          (* reg is the value input,
                           i is the immediate constant (in the case of an int)
                           or the position in the closure for this function,
                           relative to static_offset + funs_in_closure
                           in the case of a real or string
                           tag is where to go to on successful comparison *)
                          let
                            val scon_reg = MirTypes.GC_REG(MirTypes.GC.new())
                            val (regs', the_code',runtime_env'',spills',calls') =
                              cg_sub(AugLambda.VAR(prim_to_lambda Pervasives.STRINGEQ),
                                     env, static_offset, start_at,false,
                                     (closure,funs_in_closure, [], []),!spills,!calls)
                            val _ = calls := calls'
                            val _ = spills := spills'
                            val _ = 
                              runtime_env' := append_runtime_envs(runtime_env',runtime_env'')
                            val app_code = 
                              case Mir_Utils.do_app(Debugger_Types.null_backend_annotation,
                                                    regs', the_code',
                                                    Mir_Utils.ONE (Mir_Utils.INT(MirTypes.GP_GC_REG 
                                                                                 caller_arg)),
                                                    no_code)
                                of
                                  (_, ((app_code, [], NONE, last), [], [])) =>
                                    (case Mir_Utils.contract_sexpr last of
                                       [] => app_code
                                     | _ => Crash.impossible"Bad result for STRINGEQ")
                                | _ => Crash.impossible"Bad result for STRINGEQ"
                          in
			    {test_code =
                               Sexpr.CONS
				 (Sexpr.ATOM
				    [MirTypes.STOREOP
				       (MirTypes.LD, scon_reg,
                                        MirTypes.GC_REG callee_closure,
                                        MirTypes.GP_IMM_ANY
					  (4 * (static_offset + i + (2 * funs_in_closure - 1)) - 1)),
                                     MirTypes.ALLOCATE_STACK
				       (MirTypes.ALLOC,
                                        MirTypes.GC_REG caller_arg,
                                        2, NONE),
                                     MirTypes.STOREOP
				       (MirTypes.ST,
					Mir_Utils.reg_from_gp the_reg,
                                        MirTypes.GC_REG caller_arg,
                                        MirTypes.GP_IMM_ANY ~1),
                                     MirTypes.STOREOP
				       (MirTypes.ST, scon_reg,
                                        MirTypes.GC_REG caller_arg,
                                        MirTypes.GP_IMM_ANY 3),
                                     MirTypes.COMMENT "Call external STRINGEQ"],
                                  Sexpr.CONS
                                    (app_code,
                                     Sexpr.ATOM
				       [MirTypes.DEALLOCATE_STACK
					  (MirTypes.ALLOC, 2),
                                        MirTypes.TEST
					  (MirTypes.BEQ, tag,
                                           MirTypes.GP_GC_REG caller_arg,
                                           MirTypes.GP_IMM_INT 1)])),
			     test_clean = []}
                          end
                        val tags_code =
                          map
                          (fn (p, (t,_)) =>
                           case t of
                             AugLambda.SCON_TAG (scon as Ident.STRING _, _) =>
                               MirTypes.VALUE(
                                              top_closure(start_at + p + 1),
                                              MirTypes.SCON scon)
                           | _ =>
                               Crash.impossible"non-STRING in STRING switch")
                          (Lists.zip(tag_positions, tag_le_list))
                      in
                        ([],
                         Mir_Utils.combine(((Sexpr.NIL, [], NONE, Sexpr.NIL), tags_code, []),
                                           do_chained_tests(the_reg, dflt, val_le_tags_list, SOME do_test, [])))
                      end (* of STRINGSCON case *) )
                    
               fun exp_code () =
                 (* From an exception constructor match, use tests and branches *)
                 let
                   val val_le_tags_list =
                     map
                     (fn (AugLambda.EXP_TAG{lexp=le, ...}, code, tag) =>
		      (0, le, code, tag)
                   | _ => Crash.impossible"Mixed tag type in switch")
                     tagged_code
                   val the_reg = 
                     case arg_regs of
                       Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_GC_REG _)) => arg
                     | _ => Crash.impossible"Bad reg for exception"
                       
                   fun do_test(reg,_, le, tag) =
                     (* reg is the value input,
                        le is the exception expression to match
                        tag is where to go to on successful comparison *)
                     let
                       val (regs, the_code) =
                         case cg_sub(le, env, static_offset, start_at,false,
                                     (closure,funs_in_closure, [],[]),!spills,!calls) of
                           (Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)),
                            ((code, [], NONE, last), [], []),
                            runtime_env'',spills',calls') =>
                           (calls := calls';
                            spills := spills';
                            runtime_env' := append_runtime_envs(runtime_env',runtime_env'');
                            (case Mir_Utils.contract_sexpr last of
                               [] => (reg, code)
                             | _ => Crash.impossible"Bad result from cg(exception)"))
                          | _ =>
                              Crash.impossible"Bad result from cg(exception)"
                     (* Get the value to test against *)
                     in
d6998 30
a7027 4
                          Sexpr.CONS
			    (the_code,
                             Sexpr.ATOM
			       [MirTypes.TEST(MirTypes.BEQ, tag, reg, regs)]),
d7029 17
a7045 4
                     end
                 in
                   ([], do_chained_tests(the_reg, dflt, val_le_tags_list, SOME do_test, []))
                 end
d7047 44
a7090 1
             (* End of auxiliary functions *)
d7092 1
a7092 11
             (* Despatch on type of switch *)
             (* main_default: the code for the default case *)
             (* main_code : the code for the non-default cases *)

             val (main_default, main_code) = 
              case tag_le_list of
               [] => empty_tel_code ()
             | (AugLambda.IMM_TAG _,_) :: _ => constructor_code ()
             | (AugLambda.VCC_TAG _,_) :: _ => constructor_code ()
             | (AugLambda.SCON_TAG scon,_) :: rest => scon_code scon
             | (AugLambda.EXP_TAG _,_) :: rest => exp_code ()
d7094 30
a7123 18
             (* Put it all together *)
	     val result_code =
	       Mir_Utils.combine
	       (Mir_Utils.combine
		(switch_arg_code,
		 Mir_Utils.combine
		 (((Sexpr.NIL, [], SOME main_tag,
		    Sexpr.ATOM main_default),
		   [],
		   []),
		  main_code
		  )
		 ),
		((Sexpr.NIL, dflt_blocks, SOME end_tag, Sexpr.NIL),
		 dflt_values,
		 dflt_procs)
		)
		in
d7132 7
a7138 7
		  (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG end_reg)), result_code,
                   if variable_debug 
                     then RuntimeEnv.SWITCH(!runtime_env',ref_slot,
                                            maximum_calls,switch_runtime_env)
                   else RuntimeEnv.EMPTY,
                   !spills,!calls)
		end
@


1.303.1.1
log
@branched from 1.303
@
text
@a3 3
 * Revision 1.303  1997/01/21  12:13:25  matthew
 * Pass options to library functions
 *
@


1.303.1.2
log
@[Bug #2048]
Sort out problems with missing tags left out by optimisations
performed by the match compiler.
@
text
@a3 8
 * Revision 1.303.1.1  1997/05/12  10:32:25  hope
 * branched from 1.303
 *
 * Revision 1.304  1997/04/11  17:17:34  jont
 * [Bug #2048]
 * Sort out problems with missing tags left out by optimisations
 * performed by the match compiler
 *
d5574 1
a5574 1

d5600 14
a5613 13
                    if variable_debug then
		      let
			val new_reg = MirTypes.GC.new()
		      in
			((Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, 
						     MirTypes.GC_REG (new_reg),
						     MirTypes.GP_IMM_INT 0),
				      MirTypes.STOREOP(MirTypes.STREF,
						       MirTypes.GC_REG (new_reg),
						       MirTypes.GC_REG fp,
						       MirTypes.GP_IMM_SYMB 
						       (MirTypes.GC_SPILL_SLOT 
							(MirTypes.DEBUG (ref_slot,"default for switch"))))], 
d5615 1
a5615 1
		      end
d5630 1
a5630 1
		       
d5636 2
a5637 2
							    [],NONE,Sexpr.NIL),
							   [],[])))
d5643 1
a5643 1
                      NONE =>
d5653 1
a5653 1

d5660 1
a5660 1

d5667 2
a5668 2
               | ((nv, ni), (AugLambda.VCC_TAG _,_)) => (nv + 1, ni)
               | _ => Crash.impossible "bad constructor tag")
d5700 1
a5700 1
				  [],NONE, Sexpr.NIL), [], []),code),
d5707 1
a5707 1
            else
d5770 3
a5772 3
		    (AugLambda.IMM_TAG (_,t2),_, tag')], NONE) =>
		    if t1 = 1 then (tag, tag') else (tag', tag)
		  | _ => Crash.impossible "Relational expression with bad IMM_TAGs"
d5815 2
a5816 2
                let
		  val (num_vccs, num_imms) = case info of
a5819 1
		  val tmp_reg = MirTypes.GC.new()
d5823 8
a5830 5
		    (MirTypes.GP_GC_REG tmp_reg,
		     [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 0 IMM_TAG",
		      con_tag_to_reg (reg, tmp_reg),
		      main_branch],
		     true)
d5839 109
a5947 127
		    if num_vcc_tags = 1 orelse dflt_exists then
		      let
			val vcc_tag =
			  if num_vcc_tags = 1 then 
			    get_vcc_tag tagged_code
			  else
			    dflt_tag
		      in
			(gp_op,
			 MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 1 VCC" ::
			 (* Branch if it's a boxed value *)
			 MirTypes.TEST (MirTypes.BTA,
					vcc_tag,
					gp_op,
					MirTypes.GP_IMM_ANY tag_test_mask) ::
			 (if num_imm_tags = 1 andalso num_imms = 1 then
			    (* 1 VCC and 1 IMM *)
			    [MirTypes.BRANCH (MirTypes.BRA,
					      MirTypes.TAG (get_imm_tag tagged_code))]
			  else if num_imm_tags = 0 then
			    (* num_imms = 1 => num_imm_tags = 0 here *)
			    (* So any imm tag must be the default *)
			    let
			      val branch =
				[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG dflt_tag)]
			    in
			      case dflt of
				NONE =>
				  (* This is the nasty semantically invalid case *)
				  (* Why isn't this a Crash? *)
				  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG end_reg,
						 MirTypes.GP_IMM_INT 0) :: branch
			      | _ => branch
			    end
			       else [main_branch]),
			    num_imms <> 1 andalso num_imm_tags <> 0)
		      end
		    else
		      (* The match compiler has optimised away a case *)
		      (* given that it can't occur from any of the call sites *)
		      (* We must be in a match default function *)
		      (* Treat as for the num_vccs = 0 case above *)
		      (gp_op,
		       [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 0 VCC_TAG",
			main_branch],
		       true)
                  else if num_imms = 1 then
		    (* 1 IMM case *)
		    if num_imm_tags = 1 orelse dflt_exists then
		      let
			val imm_tag =
			  if num_imm_tags = 1 then 
			    get_imm_tag tagged_code
			  else dflt_tag
		      in
			(MirTypes.GP_GC_REG tmp_reg,
			 MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 1 IMM_TAG" ::
			 MirTypes.TEST(MirTypes.BNT,
				       imm_tag,
				       gp_op,
				       MirTypes.GP_IMM_ANY tag_test_mask) ::
			 (if num_vcc_tags = 0 then
			    [MirTypes.BRANCH(MirTypes.BRA,
					     MirTypes.TAG dflt_tag)]
			  else
			    [con_tag_to_reg (reg, tmp_reg),
			     main_branch]),
			    num_vcc_tags <> 0)
		      end
		    else
		      (* The match compiler has optimised away a case *)
		      (* given that it can't occur from any of the call sites *)
		      (* We must be in a match default function *)
		      (* Treat as for the num_imms = 0 case above *)
		      (MirTypes.GP_GC_REG tmp_reg,
		       [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 0 IMM_TAG",
			con_tag_to_reg (reg, tmp_reg),
			main_branch],
		       true)
		  else
		    (* num_vccs > 1 andalso num_imms > 1 *)
		    if num_vcc_tags = 0 then
		      (gp_op,
		       [MirTypes.TEST(MirTypes.BTA,
				      dflt_tag,
				      gp_op,
				      MirTypes.GP_IMM_ANY tag_test_mask),
			main_branch],
		       true)
                  else if num_imm_tags = 0 then
		    (MirTypes.GP_GC_REG tmp_reg,
		     [MirTypes.TEST(MirTypes.BNT,
				    dflt_tag,
				    gp_op,
				    MirTypes.GP_IMM_ANY tag_test_mask),
		      con_tag_to_reg (reg, tmp_reg),
		      main_branch],
		     true)
                  else
		    (MirTypes.GP_GC_REG tmp_reg,
		     [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, general case",
		      MirTypes.UNARY(MirTypes.MOVE,
				     MirTypes.GC_REG tmp_reg,
				     gp_op),
		      MirTypes.TEST(MirTypes.BNT,
				    main_tag,
				    MirTypes.GP_GC_REG tmp_reg,
				    MirTypes.GP_IMM_ANY tag_test_mask),
		      con_tag_to_reg (reg, tmp_reg),
		      main_branch],
		     true)
		end
	    | Mir_Utils.ONE(Mir_Utils.INT(gp_op)) => Crash.impossible "_mir_cg: Mir_Utils.INT\n"
	    (* Do we need to handle GP_NON_GC_REG? *)
	    | Mir_Utils.ONE(Mir_Utils.REAL _) => Crash.impossible "SWITCH(Mir_Utils.ONE(Mir_Utils.REAL))"
	    | Mir_Utils.LIST many =>
		(* It's implausible that this gets past the lambda optimizer *)
		let
		  val tmp_reg = MirTypes.GC.new()
		  val index = 0
		  val extra = 
		    (case Lists.nth(index, many) of
		       Mir_Utils.INT gp_op =>
			 MirTypes.UNARY(MirTypes.MOVE,
					MirTypes.GC_REG tmp_reg,
					gp_op)
		     | Mir_Utils.REAL fp_op => Crash.impossible "REAL when decoding list") 
d5954 5
a5958 6
		in
		  (MirTypes.GP_GC_REG tmp_reg,
		   MirTypes.COMMENT "select for LIST" ::
		   [extra, main_branch],
		   true)
		end
d5960 25
a5984 25
	  (* what is the result here? *)
	  (* it depends on what sort of switch we have *)
	  (* arg_regs:  The switch argument, possible unboxed, literal or untupled -- only used for scons and exns *)
	  (* the_reg_opt:  A register with the switch arg in *)
	  (* switch_arg_code:  Code for producing the switch argument *)
	  (* need_main_test:  Something cunning! *)

	  val (arg_regs, the_reg_opt, switch_arg_code,need_main_test,runtime_env',spills,calls) =
	    (* A simple relational test *)
	    if is_rel then
	      let
		val (test,arg) = 
		  case lexp of
		    AugLambda.APP({lexp=AugLambda.BUILTIN (test,_), ...},([{lexp=arg,...}],[]),_) => 
		      (test,arg)
		  | AugLambda.APP({lexp=AugLambda.BUILTIN _, ...},args,_) =>
		      Crash.impossible "Arglist in rel expr"
		  | _ => Crash.impossible"Bad rel lexp"

		(* Code generate the arguments *)
		val (arg_regs, arg_code,arg_runtime_env,spills,calls) =
		  cg_sub
		  (arg, env, static_offset, start_at,false,
		   (closure, funs_in_closure, fn_tag_list, local_functions),
		   maximum_spills,maximum_calls)
d5986 2
a5987 2
		val (the_reg, extra) = Mir_Utils.send_to_reg arg_regs
		(* This is bogus -- but it doesn't matter!!! *)
d5989 42
a6030 104
		val code =
		  make_if (test, arg_regs,arg_code, true_tag, false_tag)
	      in
		(arg_regs, SOME the_reg, code, 
		 false,arg_runtime_env,spills,calls)
	      end
	    else if is_con then
	      (* datatype constructor matches *)
	      let
		val (regs, the_code,runtime_env,spills,calls) =
		  (* Code generate the switch argument *)
		  cg_sub(lexp, env, static_offset, start_at,false,
			 (closure,funs_in_closure, fn_tag_list,local_functions),
			 maximum_spills,maximum_calls)

		(* And make some code to get the tags *)
		val (the_reg, select_code, need_main_test) = destructuring_code regs

		val block =
		  Mir_Utils.combine(the_code,
				    ((Sexpr.ATOM (select_code),[],NONE,Sexpr.NIL),
				     [],
				     []))
	      in
		(Mir_Utils.ONE(Mir_Utils.INT(the_reg)),
		 SOME the_reg,
		 block,   (* Compute arg and extract tag *)
		 need_main_test,runtime_env,spills,calls)
	      end
	    else
	      (* scon and expression matches *)
	      let 
		val (regs, the_code,runtime_env,spills,calls) =
		  (* Code generate the switch argument *)
		  cg_sub(lexp, env, static_offset, start_at,false,
			 (closure,funs_in_closure, fn_tag_list,local_functions),
			 maximum_spills,maximum_calls);

		val block =
		  Mir_Utils.combine(the_code,
				    ((Sexpr.ATOM [main_branch],[],NONE,Sexpr.NIL),
				     [],[]))
	      in
		(regs, NONE, block, true,runtime_env,spills,calls)
	      end

	  val calls : int ref = ref calls
	  val spills : (int * int * int) ref = ref spills
	  val runtime_env' : RuntimeEnv.RuntimeEnv ref = ref runtime_env'

	  (* Some auxiliary functions *)

	  (* Handle the case of using computed gotos *)
	  fun make_cgt(MirTypes.GP_IMM_INT _,_,_,_) =
	    Crash.impossible"make_cgt GP_IMM_INT"
	    | make_cgt(MirTypes.GP_IMM_ANY _,_,_,_) =
	    Crash.impossible"make_cgt GP_IMM_ANY"
	    | make_cgt(MirTypes.GP_IMM_SYMB _,_,_,_) =
	    Crash.impossible"make_cgt GP_IMM_SYMB"
	    | make_cgt(gp_operand, low, high, val_code_tag_list) =
	    let
	      val reg_op = Mir_Utils.reg_from_gp gp_operand
	      val (dflt_tag, end_blocks) = 
		case dflt of
		  NONE =>
		    let val tag1 = MirTypes.new_tag()
		    in (tag1,
			[MirTypes.BLOCK(tag1,
					[MirTypes.COMMENT "CGT default",
					 MirTypes.UNARY(MirTypes.MOVE,
							MirTypes.GC_REG end_reg,
							MirTypes.GP_IMM_ANY 1),
					 final_branch])])
		    end
		| _ => (dflt_tag, [])

	      val full_tag_list =
		let
		  fun expand [] = []
		    | expand ([(_,_, tag)]) = [tag]
		    | expand ((i,_, tag) :: (rest as ((j,_,_) :: _))) =
		    tag :: Mir_Utils.list_of (j-i-1, dflt_tag) @@ expand rest
		in
		  expand val_code_tag_list
		end

	      val values =
		Lists.reducer
		(fn ((_, (_, (_, value,_),_,_,_),_), value') =>
		 value @@ value')
		(val_code_tag_list, [])

	      val procs =
		Lists.reducer
		(fn ((_, (_, (_,_, proc),_,_,_),_), proc') => proc @@ proc')
		(val_code_tag_list, [])

	      val body = 
		map
		(fn (_, (regs, ((first, blocks, tag_opt, last),_,_),_,_,_),tag) =>
		 let
		   val end_code =
		     Mir_Utils.send_to_given_reg(regs, end_reg) @@
		     [MirTypes.COMMENT "end CGT", final_branch]
d6032 2
a6033 47
		   (case tag_opt of
		      NONE =>
			[MirTypes.BLOCK(tag,
					Mir_Utils.contract_sexpr(Sexpr.CONS(first, Sexpr.ATOM end_code)))]
		    | SOME tag1 =>
			[MirTypes.BLOCK(tag,
					Mir_Utils.contract_sexpr first),
			 MirTypes.BLOCK(tag1,
					Mir_Utils.contract_sexpr(Sexpr.CONS(last, Sexpr.ATOM end_code)))])
		      @@ blocks
		 end)
		val_code_tag_list
	    in
	      ((if is_rel orelse not need_main_test 
		  then Sexpr.NIL
		else
		  Sexpr.ATOM(
			     if low = 0 then
			       [MirTypes.SWITCH(MirTypes.CGT,
						reg_op,
						full_tag_list)]
			     else
			       let val new_reg_op = MirTypes.GC.new()
			       in [MirTypes.TEST(MirTypes.BLT,
						 dflt_tag,
						 gp_operand,
						 MirTypes.GP_IMM_INT low),
				   MirTypes.BINARY(MirTypes.SUBU,
						   MirTypes.GC_REG new_reg_op,
						   gp_operand,
						   MirTypes.GP_IMM_INT low),
				   MirTypes.SWITCH(MirTypes.CGT,
						   MirTypes.GC_REG new_reg_op,
						   full_tag_list),
				   MirTypes.COMMENT "Switch relative to lowest tag"]
			       end
			     ),
		  Lists.reducer
		  op@@
		  (end_blocks :: body, []),
		  NONE,
		  Sexpr.NIL
		  ),
		  values,
		  procs
		  )
	    end (* of make_cgt *)
d6035 111
a6145 4
	  fun bounds(low:int, high, []) = (low, high)
	    | bounds(low, high, i :: xs) =
	    if (i < low) then bounds(i, high, xs)
	    else if (i > high) then bounds(low, i, xs)
d6148 24
a6171 24
	  (* Test as one damn thing after another *)
	  fun do_chained_tests(_, default, [], test_opt, clean_code) =
	    (((case (default, test_opt) of
		 (* This should never be called without a default,
		  but it's worth being on the safe side.
		  *)
		 (SOME _, SOME _) =>
		   Sexpr.ATOM
		   (clean_code @@
		    [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG dflt_tag),
		     MirTypes.COMMENT "default or end"])
	       | (SOME _, NONE) =>
		   Sexpr.NIL (* This one ok *)
	       | (_, SOME _) =>
		   (* This one ok, but should have converted previous *)
		   (* conditional branch to be unconditional *)
		   Sexpr.NIL
	       | _ => Sexpr.NIL (* This one ok *)),
		 [],
		 NONE,
		 Sexpr.NIL),
		 [],[])
	    | do_chained_tests
		 (the_reg, default, head :: rest, test_opt, clean_code) =
d6240 59
a6298 59
	  fun constructor_code () =
	    let
	      (* Bind tags to previously generated body code *)
	      val val_code_tags_list =
		Lists.qsort (fn ((i:int,_,_), (i',_,_)) => i < i')
		(map
		 (fn (AugLambda.IMM_TAG (_,i), le, tag) => (i, le, tag)
	       |  (AugLambda.VCC_TAG (_,i), le, tag) => (i, le, tag)
	       | _ => Crash.impossible "Mixed tag type in switch")
		 tagged_code)

	      val (i, (result_reg, code,_,_,_), first_tag) =
		case val_code_tags_list of
		  x :: _ => x
		| _ => Crash.impossible "Empty datatype list"

	      val the_reg =
		case the_reg_opt of
		  SOME x => x
		| NONE => Crash.impossible "Missing the_reg"
	    in
	      if length val_code_tags_list < 3
		(* The small case *)
		then
		  let 
		    fun do_test(reg, i,_, tag) =
		      {test_code =
		       Sexpr.ATOM [MirTypes.TEST(MirTypes.BEQ, tag, reg,
						 MirTypes.GP_IMM_INT i)],
		       test_clean = []}
		    val val_le_tags_list =
		      map 
		      (fn (i, code, tag) => (i, 0, code, tag))
		      val_code_tags_list
		  in ([],
		      do_chained_tests
		      (the_reg, dflt, val_le_tags_list,
		       if need_main_test then
			 SOME do_test
		       else
			 NONE,
			 []))
		  end
	      else
		(* Computed goto case *)
		let 
		  val (low, high) = bounds (i, i, map #1 val_code_tags_list)
		  val dflt_code = 
		    case dflt of
		      NONE => []
		    | SOME _ =>
			[MirTypes.TEST(MirTypes.BGT, dflt_tag, the_reg,
				       MirTypes.GP_IMM_INT high)]
		  val main =
		    make_cgt(the_reg, low, high, val_code_tags_list)
		in 
		  (dflt_code, main)
		end
	    end
d6300 9
a6308 9
	  fun empty_tel_code () =
	    let
	      val dflt_code = case dflt of
		NONE => []
	      | SOME _ =>
		  [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG dflt_tag)]
	    in
	      (MirTypes.COMMENT "nil main def" :: dflt_code, no_code)
	    end
d6310 1
a6310 22
	  fun find_large_value to_bignum (v1, v2) =
	    let
	      val v = to_bignum v1
	    in
	      v2
	    end
	  handle
	  BigNum.Unrepresentable => v1
	| BigNum32.Unrepresentable => v1

	  fun scon_code (scon, max_size_opt) =
	    (* Returns (main_default, main_code).   Both opcode lists.
	     main_default: the code for the default case   
	     main_code : the code for the non-default cases *)
	    (* From a special constant match, use a computed goto for ints
	     in a suitably small range, and multiple tests and branches
	     for other int cases, reals and strings. *)
	    (* We now have to deal with chars, which could in some cases
	     be treated as constructors from a set of 256.
	     Also there are words. *)
	    (case scon of
	       Ident.INT _ =>
d6312 31
a6342 10
		   (* 32-bit ints are stored as four-byte strings on
		    32-bit architectures, and require special code. *)
		   val is_32_bits = 
		     case max_size_opt of
		       NONE => false
		     | SOME sz =>
			 if sz <= MachSpec.bits_per_word then
			   false
			 else if sz = 32 then
			   true
d6346 247
a6592 247
		   (* clean_code cleans the register that holds the
		    unboxed 32-bit value. *)
		   val (the_reg, extra, clean_code) =
		     if is_32_bits then
		       case arg_regs of
			 Mir_Utils.ONE reg => Mir_Utils.get_word32 reg
		       |  _ =>
			   Crash.impossible "LIST found in switch on Integer32"
		     else
		       let
			 val (reg, code) = Mir_Utils.send_to_reg arg_regs
		       in
			 (reg, code, [])
		       end
		 in
		   let
		     fun do_conversion (AugLambda.SCON_TAG (Ident.INT (i,location), max_size_opt),
					code, tag) =
		       (Mir_Utils.convert_int (i, max_size_opt), 0, code, tag)
		       | do_conversion _ = Crash.impossible "Mixed tag type in switch"

		     (* If we get here (i.e. no exception has been
		      raised), then all the scons fit in integers
		      of the compiling machine.  We still don't
			know the size of the value being switched on. *)
		     val val_le_tags_list =
		       Lists.qsort
		       (fn ((i:int,_,_,_), (i',_,_,_)) => i < i')
		       (map do_conversion tagged_code)

		     (* Patch for Jont *)
		     val a_value = case val_le_tags_list of
		       {1=i, ...} :: _ => i
		     | _ => Crash.impossible"empty val_le_tags_list"

		     val (low, high) =
		       bounds (a_value, a_value, map #1 val_le_tags_list)

		     val len = length val_le_tags_list

		     val use_cgt =
		       not (is_32_bits) andalso
		       high + 1 - low <= 2 * len andalso len > 2

		     (* Not too many holes, but a bigger than two list *)

		     (* We possibly could construct a computed goto for
		      32 bit integers, since all the patterns fit in
		      single integers.  We would first test the argument
		      to see if the top two bits were set, branching
		      to the default case if so, and shifting left by
		      two otherwise. *)

		     val dflt_code = case dflt of
		       NONE =>
			 [MirTypes.COMMENT
			  "No default (strange for scon match)"]
		     | SOME _ =>
			 if is_32_bits then
			   [MirTypes.COMMENT "Default",
			    MirTypes.TEST
			    (MirTypes.BGT, dflt_tag, the_reg,
			     MirTypes.GP_IMM_ANY high)]
			 else
			   [MirTypes.COMMENT "Default",
			    MirTypes.TEST
			    (MirTypes.BGT, dflt_tag, the_reg,
			     MirTypes.GP_IMM_INT high)]
		   in
		     if use_cgt then
		       (extra @@ dflt_code,
			make_cgt
			(the_reg, low, high,
			 map
			 (fn (x,_, y, z) => (x, y, z))
			 val_le_tags_list))
		     else
		       let
			 fun do_test(reg, i, _, tag) =
			   if is_32_bits then
			     {test_code =
			      Sexpr.ATOM
			      [MirTypes.TEST
			       (MirTypes.BEQ, tag, reg,
				MirTypes.GP_IMM_ANY i)],
			      test_clean = []}
			   else
			     {test_code =
			      Sexpr.ATOM
			      [MirTypes.TEST
			       (MirTypes.BEQ, tag, reg,
				MirTypes.GP_IMM_INT i)],
			      test_clean = []}
		       in
			 (extra,
			  do_chained_tests
			  (the_reg, dflt, val_le_tags_list,
			   SOME do_test, clean_code))
		       end
		   end
		 handle
		 Mir_Utils.ConvertInt =>
		   (* If we have values that don't fit in a machine
		    word on the compiling machine, we use runtime
		    evaluation of the integers in the patterns. *)
		   let
		     fun to_string(Ident.INT(i,_)) = i
		       | to_string _ =
		       Crash.impossible"Mixed tag type in switch"

		     fun location_scon(Ident.INT(_, location)) =
		       location
		       |   location_scon _ =
		       Crash.impossible"Mixed tag type in switch"

		     fun to_bignum x =
		       let
			 val str_x = to_string x
		       in
			 if size str_x < 2 then
			   BigNum.string_to_bignum str_x
			 else
			   case substring (* could raise Substring *)(str_x, 0, 2)
			     of "0x" =>
			       BigNum.hex_string_to_bignum str_x
			   | _ =>
			       BigNum.string_to_bignum str_x
		       end

		     (* Again, 32-bit values are a special case. *)
		     fun to_bignum32 x =
		       let
			 val str_x = to_string x
		       in
			 if size str_x < 2 then
			   BigNum32.string_to_bignum str_x
			 else
			   case substring (* could raise Substring *)(str_x, 0, 2)
			     of "0x" =>
			       BigNum32.hex_string_to_bignum str_x
			   | _ =>
			       BigNum32.string_to_bignum str_x
		       end

		     fun compare_bignums ((i,_,_,_), (i',_,_,_)) =
		       BigNum.<(to_bignum i, to_bignum i')
		       handle BigNum.Unrepresentable =>
			 let
			   val i = find_large_value to_bignum (i, i')
			 in
			   Info.error'
			   error_info
			   (Info.FATAL, location_scon i,
			    "Integer too big: " ^ to_string i)
			 end

		     fun compare_bignums32 ((i,_,_,_), (i',_,_,_)) =
		       BigNum32.<(to_bignum32 i, to_bignum32 i')
		       handle BigNum32.Unrepresentable =>
			 let
			   val i = find_large_value to_bignum32 (i, i')
			 in
			   Info.error'
			   error_info
			   (Info.FATAL, location_scon i,
			    "Integer too big: " ^ to_string i)
			 end

		     (* This is the equivalent of do_conversion in the
		      main case.  It differs in that it doesn't
		      convert the scon. *)
		     fun check_tag
		       (AugLambda.SCON_TAG (scon, _), code, tag) =
		       (scon, 0, code, tag)
		       |   check_tag _ =
		       Crash.impossible"Mixed tag type in switch"

		     val val_le_tags_list =
		       Lists.qsort
		       (if is_32_bits then
			  compare_bignums32
			else
			  compare_bignums)
			  (map check_tag tagged_code)

		     val low =
		       case val_le_tags_list of
			 (scon,_,_,_) :: _ => scon
		       | _ => Crash.impossible "Empty switch list"

		     val high =
		       case (last val_le_tags_list) of
			 (scon,_,_,_) => scon

		     fun do_test(reg, long_i,_, tag) =
		       let
			 val (reg', the_code) =
			   (case cg_sub(Mir_Utils.convert_long_int (long_i, max_size_opt), env,
					static_offset, start_at,false,
					(closure,funs_in_closure, fn_tag_list,local_functions),
					!spills,!calls) of
			      (Mir_Utils.ONE(Mir_Utils.INT(r as MirTypes.GP_GC_REG _)),
			       ((code, [], NONE, Sexpr.NIL),
				[], []),_,_,_) => (r, code)
			      | _ => Crash.impossible"Bad code for big integer")
			      handle
			      Mir_Utils.Unrepresentable =>
				Info.error'
				error_info
				(Info.FATAL, location_scon long_i,
				 "Integer too big: " ^ to_string long_i)

			 val (arg_reg, arg_code, arg_clean) =
			   Mir_Utils.get_word32 (Mir_Utils.INT reg')

			 val test =
			   MirTypes.TEST
			   (MirTypes.BEQ, tag, reg, arg_reg)
		       in
			 {test_code =
			  Sexpr.CONS
			  (the_code,
			   Sexpr.ATOM (arg_code @@ [test ])),
			  test_clean = arg_clean}
		       end
		   in
		     (extra,
		      do_chained_tests
		      (the_reg, dflt, val_le_tags_list,
		       SOME do_test, clean_code))
		   end (* of handler *)
		 end (* of INTSCON case *)
	     | Ident.WORD _ =>
		 (* Words are very much like ints *)
		 (* 32-bit words are stored as four-byte strings on
		  32-bit architectures, and require special code. *)
		 let
		   val is_32_bits = 
		     case max_size_opt
		       of NONE => false
		     |  SOME sz =>
			 if sz <= MachSpec.bits_per_word then
			   false
			 else if sz = 32 then
			   true
			      else 
				Crash.impossible
d6596 470
a7065 311
		   val (the_reg, extra, clean_code) =
		     if is_32_bits then
		       case arg_regs
			 of Mir_Utils.ONE reg =>
			   Mir_Utils.get_word32 reg
		       |  _ =>
			   Crash.impossible
			   "LIST found in switch on Word32"
		     else
		       let
			 val (reg, code) = Mir_Utils.send_to_reg arg_regs
		       in
			 (reg, code, [])
		       end
		 in
		   let
		     fun do_conversion 
		       (AugLambda.SCON_TAG 
			(Ident.WORD (i,location), max_size_opt),
			code, tag) =
		       (Mir_Utils.convert_word (i, max_size_opt),
			0, code, tag)
		       |   do_conversion _ =
		       Crash.impossible "Mixed tag type in switch"

		     (* If we get here (i.e. no exception has been
		      raised), then all the scons fit in words
		      of the compiling machine.  We still don't know
			the size of the value being switched on. *)
		     val val_le_tags_list =
		       Lists.qsort
		       (fn ((i:int,_,_,_), (i',_,_,_)) => i < i')
		       (map do_conversion tagged_code)

		     (* Patch for Jont *)
		     val a_value = case val_le_tags_list of
		       {1=i, ...} :: _ => i
		     | _ => Crash.impossible"empty val_le_tags_list"

		     val (low, high) =
		       bounds (a_value, a_value, map #1 val_le_tags_list)

		     val len = length val_le_tags_list

		     val use_cgt =
		       not (is_32_bits) andalso
		       high + 1 - low <= 2 * len andalso len > 2

		     (* Not too many holes, but a bigger than two list *)

		     (* We possibly could construct a computed goto for
		      32 bit words, since all the patterns fit in
		      single words.  We would first test the argument
		      to see if the top two bits were set, branching
		      to the default case if so, and shifting left by
		      two otherwise. *)

		     val dflt_code = case dflt of
		       NONE =>
			 [MirTypes.COMMENT
			  "No default (strange for scon match)"]
		     | SOME _ =>
			 if is_32_bits then
			   [MirTypes.COMMENT "Default",
			    MirTypes.TEST
			    (MirTypes.BHI, dflt_tag, the_reg,
			     MirTypes.GP_IMM_ANY high)]
			 else
			   [MirTypes.COMMENT "Default",
			    MirTypes.TEST
			    (MirTypes.BHI, dflt_tag, the_reg,
			     MirTypes.GP_IMM_INT high)]
		   in
		     if use_cgt then
		       (extra @@ dflt_code,
			make_cgt
			(the_reg, low, high,
			 map
			 (fn (x,_, y, z) => (x, y, z))
			 val_le_tags_list))
		     else
		       let
			 fun do_test(reg, i, _, tag) =
			   if is_32_bits then
			     {test_code =
			      Sexpr.ATOM
			      [MirTypes.TEST
			       (MirTypes.BEQ, tag, reg,
				MirTypes.GP_IMM_ANY i)],
			      test_clean = []}
			   else
			     {test_code =
			      Sexpr.ATOM
			      [MirTypes.TEST
			       (MirTypes.BEQ, tag, reg,
				MirTypes.GP_IMM_INT i)],
			      test_clean = []}
		       in
			 (extra,
			  do_chained_tests
			  (the_reg, dflt, val_le_tags_list,
			   SOME do_test, clean_code))
		       end
		   end
		 handle
		 Mir_Utils.ConvertInt =>
		   (* If we have values that don't fit in a machine
		    word on the compiling machine, we use runtime
		    evaluation of the words in the patterns. *)
		   let
		     fun to_string(Ident.WORD(i,_)) = i
		       | to_string _ =
		       Crash.impossible"Mixed tag type in switch"

		     fun location_scon(Ident.WORD(_, location)) =
		       location
		       |   location_scon _ =
		       Crash.impossible"Mixed tag type in switch"

		     fun to_bignum x =
		       let
			 val str_x = to_string x
		       in
			 if size str_x < 3 then
			   BigNum.word_string_to_bignum str_x
			 else
			   case substring (* could raise Substring *)(str_x, 0, 3)
			     of "0wx" =>
			       BigNum.hex_word_string_to_bignum str_x
			   | _ =>
			       BigNum.word_string_to_bignum str_x
		       end

		     (* Again, 32-bit values are a special case. *)
		     fun to_bignum32 x =
		       let
			 val str_x = to_string x
		       in
			 if size str_x < 3 then
			   BigNum32.word_string_to_bignum str_x
			 else
			   case substring (* could raise Substring *)(str_x, 0, 3)
			     of "0wx" =>
			       BigNum32.hex_word_string_to_bignum str_x
			   | _ =>
			       BigNum32.word_string_to_bignum str_x
		       end

		     fun compare_bignums ((i,_,_,_), (i',_,_,_)) =
		       BigNum.<(to_bignum i, to_bignum i')
		       handle BigNum.Unrepresentable =>
			 let
			   val i = find_large_value to_bignum (i, i')
			 in
			   Info.error'
			   error_info
			   (Info.FATAL, location_scon i,
			    "Word too big: " ^ to_string i)
			 end

		     fun compare_bignums32 ((i,_,_,_), (i',_,_,_)) =
		       BigNum32.<(to_bignum32 i, to_bignum32 i')
		       handle BigNum32.Unrepresentable =>
			 let
			   val i = find_large_value to_bignum32 (i, i')
			 in
			   Info.error'
			   error_info
			   (Info.FATAL, location_scon i,
			    "Word too big: " ^ to_string i)
			 end

		     (* This is the equivalent of do_conversion in the
		      main case.  It differs in that it doesn't
		      convert the scon. *)
		     fun check_tag
		       (AugLambda.SCON_TAG (scon, _), code, tag) =
		       (scon, 0, code, tag)
		       |   check_tag _ =
		       Crash.impossible"Mixed tag type in switch"

		     val val_le_tags_list =
		       Lists.qsort
		       (if is_32_bits then
			  compare_bignums32
			else
			  compare_bignums)
			  (map check_tag tagged_code)

		     val low =
		       case val_le_tags_list of
			 (scon,_,_,_) :: _ => scon
		       | _ => Crash.impossible "Empty switch list"

		     val high =
		       case (last val_le_tags_list) of
			 (scon,_,_,_) => scon

		     fun do_test(reg, long_i,_, tag) =
		       let
			 val (reg', the_code) =
			   (case cg_sub(Mir_Utils.convert_long_word (long_i, max_size_opt), env,
					static_offset, start_at,false,
					(closure,funs_in_closure, fn_tag_list,local_functions),
					!spills,!calls) of
			      (Mir_Utils.ONE(Mir_Utils.INT(r as MirTypes.GP_GC_REG _)),
			       ((code, [], NONE, Sexpr.NIL),
				[], []),_,_,_) => (r, code)
			      | _ => Crash.impossible"Bad code for big word")
			      handle
			      Mir_Utils.Unrepresentable =>
				Info.error'
				error_info
				(Info.FATAL, location_scon long_i,
				 "Word too big: " ^ to_string long_i)

			 val (arg_reg, arg_code, arg_clean) =
			   Mir_Utils.get_word32 (Mir_Utils.INT reg')

			 val test =
			   MirTypes.TEST
			   (MirTypes.BEQ, tag, reg, arg_reg)
		       in
			 {test_code =
			  Sexpr.CONS
			  (the_code,
			   Sexpr.ATOM (arg_code @@ [test ])),
			  test_clean = arg_clean}
		       end
		   in
		     (extra,
		      do_chained_tests
		      (the_reg, dflt, val_le_tags_list,
		       SOME do_test, clean_code))
		   end (* of handler *)
		 end (* of WORDSCON case *)
	     | Ident.CHAR _ =>
		 let
		   val (the_reg, extra) = Mir_Utils.send_to_reg arg_regs
		 in
		   let
		     val val_le_tags_list =
		       Lists.qsort (fn ((i:int,_,_,_), (i',_,_,_)) =>
				    i < i')
		       (map (fn (AugLambda.SCON_TAG(Ident.CHAR s, _), code, tag) =>
			     (Old.ord s, 0, code, tag)
		     | _ => Crash.impossible"Mixed tag type in switch")
			tagged_code)
		     (* Patch for Jont *)
		     val a_value = case val_le_tags_list of
		       {1=i, ...} :: _ => i
		     | _ => Crash.impossible"empty val_le_tags_list"
		     val (low, high) = bounds(a_value, a_value, map #1 val_le_tags_list)
		     val len = length val_le_tags_list
		     val use_cgt = high + 1 - low <= 2 * len andalso len > 2
		     (* Not too many holes, but a bigger than two list *)

		     val dflt_code = case dflt of
		       NONE => [MirTypes.COMMENT"No default (strange for scon match)"]
		     | SOME _ =>
			 [MirTypes.COMMENT "Default",
			  MirTypes.TEST(MirTypes.BHI, dflt_tag, the_reg,
					MirTypes.GP_IMM_INT high)]
		   in
		     if use_cgt then
		       (extra @@ dflt_code,
			make_cgt(the_reg, low, high,
				 map
				 (fn (x,_, y, z) => (x, y, z))
				 val_le_tags_list))
		     else
		       let
			 fun do_test(reg, i,_, tag) =
			   {test_code =
			    Sexpr.ATOM
			    [MirTypes.TEST(MirTypes.BEQ, tag, reg,
					   MirTypes.GP_IMM_INT i)],
			    test_clean = []}
		       in
			 (extra,
			  do_chained_tests(the_reg,
					   dflt,
					   val_le_tags_list,
					   SOME do_test,
					   []))
		       end
		   end
		 end (* of CHARSCON case *)
	     | Ident.REAL _ =>
		 (* The real case *)
		 let
		   val val_le_tags_list =
		     map (fn ((AugLambda.SCON_TAG(Ident.REAL _, _), code, tag), p) =>
			  (p, 0, code, tag)
		   | _ => Crash.impossible"Mixed tag type in switch")
		     (Lists.zip(tagged_code, tag_positions))
		   val (the_reg, extra) = 
		     case arg_regs of
		       Mir_Utils.ONE reg => Mir_Utils.get_real reg
		     | _ => Crash.impossible "struct gives single REAL"

		   fun do_test(reg, i,_, tag) =
		     (* reg is the value input,
		      i is the immediate constant (in the case of an int)
		      or the position in the closure for this function,
		      relative to static_offset + funs_in_closure
		      in the case of a real or string
		      tag is where to go to on successful comparison *)
		     let
		       val fp_op = MirTypes.FP_REG(MirTypes.FP.new())
		     in
d7067 4
a7070 12
			Sexpr.ATOM
			[MirTypes.STOREOP
			 (MirTypes.LD,
			  MirTypes.GC_REG MirRegisters.global,
			  MirTypes.GC_REG callee_closure,
			  MirTypes.GP_IMM_ANY
			  (4 * (static_offset + i + (funs_in_closure * 2 - 1)) - 1)),
			 MirTypes.STOREFPOP
			 (MirTypes.FLD, fp_op,
			  MirTypes.GC_REG MirRegisters.global,
			  MirTypes.GP_IMM_ANY real_offset),
			 MirTypes.FTEST(MirTypes.FBEQ, tag, fp_op, reg)],
d7072 4
a7075 108
		     end
		   val tags_code =
		     map
		     (fn (p, (t,_)) =>
		      case t of
			AugLambda.SCON_TAG(scon as Ident.REAL _, _) =>
			  MirTypes.VALUE(top_closure (start_at + p + 1),
					 MirTypes.SCON scon)
		      | _ => Crash.impossible"non-REAL in REAL switch"
			  )
		     (Lists.zip(tag_positions, tag_le_list))
		 in
		   (extra,
		    Mir_Utils.combine(((Sexpr.NIL, [], NONE, Sexpr.NIL), tags_code, []),
				      do_chained_tests(the_reg, dflt, val_le_tags_list, SOME do_test, [])))
		 end (* of REALSCON case *)
	     | Ident.STRING _ =>
		 let
		   val val_le_tags_list =
		     map
		     (fn ((AugLambda.SCON_TAG(Ident.STRING _, _), code, tag), p) =>
		      (p, 0, code, tag)
		   | _ => Crash.impossible"Mixed tag type in switch")
		     (Lists.zip(tagged_code, tag_positions))
		   val the_reg = 
		     case arg_regs of
		       Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_GC_REG _)) => arg
		     | _ => Crash.impossible"struct gives single STRING"

		   fun do_test(reg, i,_, tag) =
		     (* reg is the value input,
		      i is the immediate constant (in the case of an int)
		      or the position in the closure for this function,
		      relative to static_offset + funs_in_closure
		      in the case of a real or string
		      tag is where to go to on successful comparison *)
		     let
		       val scon_reg = MirTypes.GC_REG(MirTypes.GC.new())
		       val (regs', the_code',runtime_env'',spills',calls') =
			 cg_sub(AugLambda.VAR(prim_to_lambda Pervasives.STRINGEQ),
				env, static_offset, start_at,false,
				(closure,funs_in_closure, [], []),!spills,!calls)
		       val _ = calls := calls'
		       val _ = spills := spills'
		       val _ = 
			 runtime_env' := append_runtime_envs(runtime_env',runtime_env'')
		       val app_code = 
			 case Mir_Utils.do_app(Debugger_Types.null_backend_annotation,
					       regs', the_code',
					       Mir_Utils.ONE (Mir_Utils.INT(MirTypes.GP_GC_REG 
									    caller_arg)),
					       no_code)
			   of
			     (_, ((app_code, [], NONE, last), [], [])) =>
			       (case Mir_Utils.contract_sexpr last of
				  [] => app_code
				| _ => Crash.impossible"Bad result for STRINGEQ")
			   | _ => Crash.impossible"Bad result for STRINGEQ"
		     in
		       {test_code =
			Sexpr.CONS
			(Sexpr.ATOM
			 [MirTypes.STOREOP
			  (MirTypes.LD, scon_reg,
			   MirTypes.GC_REG callee_closure,
			   MirTypes.GP_IMM_ANY
			   (4 * (static_offset + i + (2 * funs_in_closure - 1)) - 1)),
			  MirTypes.ALLOCATE_STACK
			  (MirTypes.ALLOC,
			   MirTypes.GC_REG caller_arg,
			   2, NONE),
			  MirTypes.STOREOP
			  (MirTypes.ST,
			   Mir_Utils.reg_from_gp the_reg,
			   MirTypes.GC_REG caller_arg,
			   MirTypes.GP_IMM_ANY ~1),
			  MirTypes.STOREOP
			  (MirTypes.ST, scon_reg,
			   MirTypes.GC_REG caller_arg,
			   MirTypes.GP_IMM_ANY 3),
			  MirTypes.COMMENT "Call external STRINGEQ"],
			 Sexpr.CONS
			 (app_code,
			  Sexpr.ATOM
			  [MirTypes.DEALLOCATE_STACK
			   (MirTypes.ALLOC, 2),
			   MirTypes.TEST
			   (MirTypes.BEQ, tag,
			    MirTypes.GP_GC_REG caller_arg,
			    MirTypes.GP_IMM_INT 1)])),
			test_clean = []}
		     end
		   val tags_code =
		     map
		     (fn (p, (t,_)) =>
		      case t of
			AugLambda.SCON_TAG (scon as Ident.STRING _, _) =>
			  MirTypes.VALUE(
					 top_closure(start_at + p + 1),
					 MirTypes.SCON scon)
		      | _ =>
			  Crash.impossible"non-STRING in STRING switch")
		     (Lists.zip(tag_positions, tag_le_list))
		 in
		   ([],
		    Mir_Utils.combine(((Sexpr.NIL, [], NONE, Sexpr.NIL), tags_code, []),
				      do_chained_tests(the_reg, dflt, val_le_tags_list, SOME do_test, [])))
		 end (* of STRINGSCON case *) )
d7077 1
a7077 44
	  fun exp_code () =
	    (* From an exception constructor match, use tests and branches *)
	    let
	      val val_le_tags_list =
		map
		(fn (AugLambda.EXP_TAG{lexp=le, ...}, code, tag) =>
		 (0, le, code, tag)
	         | _ => Crash.impossible"Mixed tag type in switch")
		tagged_code
	      val the_reg = 
		case arg_regs of
		  Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_GC_REG _)) => arg
		| _ => Crash.impossible"Bad reg for exception"
	      fun do_test(reg,_, le, tag) =
		(* reg is the value input,
		 le is the exception expression to match
		 tag is where to go to on successful comparison *)
		let
		  val (regs, the_code) =
		    case cg_sub(le, env, static_offset, start_at,false,
				(closure,funs_in_closure, [],[]),!spills,!calls) of
		      (Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)),
		       ((code, [], NONE, last), [], []),
		       runtime_env'',spills',calls') =>
		      (calls := calls';
		       spills := spills';
		       runtime_env' := append_runtime_envs(runtime_env',runtime_env'');
		       (case Mir_Utils.contract_sexpr last of
			  [] => (reg, code)
			| _ => Crash.impossible"Bad result from cg(exception)"))
		     | _ =>
		      Crash.impossible"Bad result from cg(exception)"
		(* Get the value to test against *)
		in
		  {test_code =
		   Sexpr.CONS
		   (the_code,
		    Sexpr.ATOM
		    [MirTypes.TEST(MirTypes.BEQ, tag, reg, regs)]),
		   test_clean = []}
		end
	    in
	      ([], do_chained_tests(the_reg, dflt, val_le_tags_list, SOME do_test, []))
	    end
d7079 11
a7089 1
	  (* End of auxiliary functions *)
d7091 18
a7108 30
	  (* Despatch on type of switch *)
	  (* main_default: the code for the default case *)
	  (* main_code : the code for the non-default cases *)

	  val (main_default, main_code) = 
	    case tag_le_list of
	      [] => empty_tel_code ()
	    | (AugLambda.IMM_TAG _,_) :: _ => constructor_code ()
	    | (AugLambda.VCC_TAG _,_) :: _ => constructor_code ()
	    | (AugLambda.SCON_TAG scon,_) :: rest => scon_code scon
	    | (AugLambda.EXP_TAG _,_) :: rest => exp_code ()

	  (* Put it all together *)
	  val result_code =
	    Mir_Utils.combine
	    (Mir_Utils.combine
	     (switch_arg_code,
	      Mir_Utils.combine
	      (((Sexpr.NIL, [], SOME main_tag,
		 Sexpr.ATOM main_default),
		[],
		[]),
	       main_code
	       )
	      ),
	     ((Sexpr.NIL, dflt_blocks, SOME end_tag, Sexpr.NIL),
	      dflt_values,
	      dflt_procs)
	     )
	in
d7117 7
a7123 7
	  (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG end_reg)), result_code,
	   if variable_debug 
	     then RuntimeEnv.SWITCH(!runtime_env',ref_slot,
				    maximum_calls,switch_runtime_env)
	   else RuntimeEnv.EMPTY,
	     !spills,!calls)
	end
@


1.303.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 5
 * Revision 1.303.1.2  1997/05/12  15:37:15  daveb
 * [Bug #2048]
 * Sort out problems with missing tags left out by optimisations
 * performed by the match compiler.
 *
@


1.303.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 5
 * Revision 1.303.1.2  1997/05/12  15:37:15  daveb
 * [Bug #2048]
 * Sort out problems with missing tags left out by optimisations
 * performed by the match compiler.
 *
@


1.303.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 5
 * Revision 1.303.1.2  1997/05/12  15:37:15  daveb
 * [Bug #2048]
 * Sort out problems with missing tags left out by optimisations
 * performed by the match compiler.
 *
@


1.303.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.303.1.2.1.1  1997/07/28  18:18:11  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.302
log
@Have tag list in tagged operations
@
text
@d4 3
d1139 1
d1437 1
a1437 1
    fun make_prim_info lambda_exp =
d1440 1
a1440 1
          Library.build_external_environment lambda_exp
d4352 1
a4352 11
      (options as Options.OPTIONS {compiler_options =
			  Options.COMPILEROPTIONS {generate_debug_info,
                                                   debug_variables,
                                                   generate_moduler,
                                                   intercept,
						   interrupt,
						   opt_handlers,
                                                   opt_self_calls, 
                                                   opt_tail_calls,
                                                   ...},print_options,
                       ...},
d4358 11
d4465 1
a4465 1
    val (prim_to_lambda, new_lambda_exp) = make_prim_info lambda_exp
@


1.301
log
@[Bug #1818]
implementing floatarrays
@
text
@d4 4
d1648 1
a1648 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d1654 1
a1654 1
                                 ((Sexpr.ATOM[(MirTypes.TBINARY(opcode, exn_tag_opt, res2,
d1664 1
a1664 2
      fun int32_unary_negate
	    (opcode, Mir_Utils.ONE(Mir_Utils.INT reg), the_code, exn_code) =
d1669 1
a1669 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d1677 1
a1677 1
	       (opcode, exn_tag_opt, res2, MirTypes.GP_IMM_INT 0, w)] @@ clean_arg
d1694 1
a1694 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d1699 1
a1699 1
                                           [(MirTypes.TBINARYFP(opcode, exn_tag_opt, result,
d1725 1
a1725 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d1734 1
a1734 1
		    MirTypes.TUNARYFP(opcode, exn_tag_opt, result, result)]
d1736 1
a1736 1
		    Sexpr.ATOM[MirTypes.TUNARYFP(opcode, exn_tag_opt, result, reg)]
d1899 1
a1899 1
	     MirTypes.BINARY(MirTypes.SUB, MirTypes.GC_REG res_reg,
d1915 1
a1915 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d1921 1
a1921 1
                                                              exn_tag_opt, res2, val1, val2))]),
d1931 1
a1931 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d1937 1
a1937 1
                                                              exn_tag_opt, res2, val1, val2))]),
d1943 1
a1943 1
      fun int32_binary_calc (opcode, regs, the_code, exn_code) =
d1952 1
a1952 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d1959 1
a1959 1
	    @@ [MirTypes.TBINARY(opcode, exn_tag_opt, tmp2, val1, val2),
d1986 1
a1986 1
      fun word32_binary_calc (opcode,regs,the_code) =
d2137 1
a2137 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d2139 3
a2141 3
	    case exn_tag_opt of
              SOME tag => tag
	    |  _ => Crash.impossible "no exn_tag for Bytearray.array"
d2209 1
a2209 1
                     MirTypes.BINARY(MirTypes.ADD, 
d2213 1
a2213 1
                     MirTypes.BINARY(MirTypes.ADD, 
d2233 1
a2233 1
                     MirTypes.BINARY(MirTypes.ADD, 
d2237 1
a2237 1
                     MirTypes.BINARY(MirTypes.ADD, 
d2338 1
a2338 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d2340 3
a2342 3
	    case exn_tag_opt of
              SOME tag => tag
	    |  _ => Crash.impossible "no exn_tag for FloatArray.array"
d2376 1
a2376 1
                       MirTypes.BINARY(MirTypes.ADD,
d2413 1
a2413 1
                   MirTypes.BINARY(MirTypes.ADD, 
d2417 1
a2417 1
                   MirTypes.BINARY(MirTypes.ADD, 
d2492 1
a2492 1
                            MirTypes.BINARY(MirTypes.ADD, 
d2496 1
a2496 1
                            MirTypes.BINARY(MirTypes.ADD, 
d2688 1
a2688 1
	      val (exn_blocks, exn_tag_opt) = exn_code
d2690 2
a2691 2
	        case exn_tag_opt
	        of SOME tag => tag
d2740 1
a2740 1
                    MirTypes.BINARY(MirTypes.SUB,
d2759 1
a2759 1
		    MirTypes.BINARY(MirTypes.SUB,
d2776 1
a2776 1
                        MirTypes.BINARY(MirTypes.ADD,
d2793 1
a2793 1
                        MirTypes.BINARY(MirTypes.ADD,
d2817 1
a2817 1
                    MirTypes.BINARY(MirTypes.ADD,
d2832 1
a2832 1
                     MirTypes.BINARY(MirTypes.ADD,
d2890 1
a2890 1
	      val (exn_blocks, exn_tag_opt) = exn_code
d2892 2
a2893 2
	        case exn_tag_opt
	        of SOME tag => tag
d2972 1
a2972 1
                        MirTypes.BINARY(MirTypes.ADD,
d3005 1
a3005 1
                  MirTypes.BINARY(MirTypes.ADD,
d3055 1
a3055 1
	      val (exn_blocks, exn_tag_opt) = exn_code
d3057 2
a3058 2
		case exn_tag_opt
		  of SOME tag => tag
d3102 1
a3102 1
		       MirTypes.BINARY(MirTypes.SUB,MirTypes.GC_REG MirRegisters.global,
d3113 1
a3113 1
				  MirTypes.BINARY(MirTypes.ADD,
d3137 1
a3137 1
                    [MirTypes.BINARY(MirTypes.ADD,
d3203 1
a3203 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d3208 2
a3209 2
		    case exn_tag_opt
	            of SOME tag => tag
d3254 1
a3254 1
                 MirTypes.BINARY(MirTypes.SUB,
d3275 1
a3275 1
		    MirTypes.BINARY(MirTypes.SUB,
d3308 1
a3308 1
                     MirTypes.BINARY(MirTypes.ADD,
d3327 1
a3327 1
                     MirTypes.BINARY(MirTypes.ADD,
d3395 1
a3395 1
                    MirTypes.BINARY(MirTypes.ADD,
d3484 1
a3484 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d3489 2
a3490 2
		    case exn_tag_opt
	            of SOME tag => tag
d3582 1
a3582 1
                     MirTypes.BINARY(MirTypes.ADD,
d3663 1
a3663 1
                MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG address,
d3733 1
a3733 1
                  [MirTypes.BINARY(MirTypes.ADD,
d3825 1
a3825 1
	       MirTypes.BINARY(MirTypes.ADD, gc_reg, reg1, gp_gc_reg)]
d3905 1
a3905 1
                                       MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG MirRegisters.global,
d3940 1
a3940 1
	    val (exn_blocks, exn_tag_opt) = exn_code
d3942 2
a3943 2
	      case exn_tag_opt
	      of SOME tag => tag
d3999 1
a3999 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d4001 2
a4002 2
	    case exn_tag_opt
	    of SOME tag => tag
d4030 1
a4030 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d4032 2
a4033 2
	    case exn_tag_opt
	    of SOME tag => tag
d4071 1
a4071 1
	  val (exn_blocks, exn_tag_opt) = exn_code
d4073 2
a4074 2
	    case exn_tag_opt
	    of SOME tag => tag
d4102 1
a4102 1
                val (exn_blocks, exn_tag_opt) = exn_code
d4104 2
a4105 2
                  case exn_tag_opt
                    of SOME tag => tag
d4130 1
a4130 1
                           MirTypes.BINARY(MirTypes.ADD, res1, res2,
d4159 1
a4159 1
                     MirTypes.BINARY(MirTypes.ADD, res1, res2,string),
d4177 2
a4178 2
	  val (exn_blocks, exn_tag_opt) = exn_code
	  val opcode = MirTypes.SUBV
d4185 1
a4185 1
		  MirTypes.TBINARY(opcode, exn_tag_opt, res2,
d4200 2
a4201 2
	  val (exn_blocks, exn_tag_opt) = exn_code
	  val opcode = MirTypes.SUBW
d4211 1
a4211 1
	     (opcode, exn_tag_opt, tmp2, MirTypes.GP_IMM_INT 0, w)] @@
d4783 4
a4786 4
             case MachPerv.implicit_references prim
               of [] => ([], NONE)
                | [exception_needed] =>
                    let
d4811 1
d4813 2
a4814 2
                      (MirTypes.BLOCK(exn_tag, Mir_Utils.contract_sexpr exn_f) :: exn_b,
                       SOME exn_tag)
d4816 3
a4818 5
                | _ => 
                    Crash.unimplemented
                    ("Mir_Cg: Unable to cope with multiple implicit " ^
                     "exceptions generated from the in-line pervasive " ^
                     Pervasives.print_pervasive prim)
d4973 2
a4974 2
      | Pervasives.INTDIV => tagged_binary_calc(MirTypes.DIVV,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INTMOD => tagged_binary_calc(MirTypes.MODV,regs,the_code,exn_code_for_prim prim)
d4990 5
a4994 5
      | Pervasives.INTPLUS => tagged_binary_calc(MirTypes.ADDV,regs,the_code,exn_code_for_prim prim)
      | Pervasives.UNSAFEINTPLUS => binary_calc (MirTypes.ADD,regs,the_code)
      | Pervasives.UNSAFEINTMINUS => binary_calc (MirTypes.SUB,regs,the_code)
      | Pervasives.WORDPLUS => binary_calc (MirTypes.ADD,regs,the_code)
      | Pervasives.WORDMINUS => binary_calc (MirTypes.SUB,regs,the_code)
d4996 14
a5009 28
      | Pervasives.WORDDIV =>
	  tagged_binary_calc
	    (MirTypes.DIVV,regs, the_code, exn_code_for_prim prim)
      | Pervasives.WORDMOD =>
	  tagged_binary_calc
	    (MirTypes.MODV,regs, the_code, exn_code_for_prim prim)
      | Pervasives.INT32PLUS =>
	  int32_binary_calc (MirTypes.ADDW,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INT32MINUS =>
	  int32_binary_calc (MirTypes.SUBW,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INT32STAR =>
	  int32_binary_calc (MirTypes.MULW,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INT32DIV =>
	  int32_binary_calc (MirTypes.DIVW,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INT32MOD =>
	  int32_binary_calc (MirTypes.MODW,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INT32UMINUS =>
     	  int32_unary_negate(MirTypes.SUBW,regs,the_code,exn_code_for_prim prim)
      | Pervasives.INT32ABS =>
	  do_int32abs (regs,the_code,exn_code_for_prim prim)
      | Pervasives.WORD32PLUS =>
	  word32_binary_calc (MirTypes.ADD,regs,the_code)
      | Pervasives.WORD32MINUS =>
	  word32_binary_calc (MirTypes.SUB,regs,the_code)
      | Pervasives.WORD32STAR =>
	  word32_binary_calc (MirTypes.MULU,regs,the_code)
      | Pervasives.WORD32DIV => word32_binary_calc (MirTypes.DIVU,regs,the_code)
      | Pervasives.WORD32MOD => word32_binary_calc (MirTypes.MODU,regs,the_code)
d5011 1
a5011 1
      | Pervasives.INTSTAR => tagged_binary_calc(MirTypes.MULV,regs,the_code,exn_code_for_prim prim)
d5013 1
a5013 1
      | Pervasives.INTMINUS => tagged_binary_calc(MirTypes.SUBV,regs,the_code,exn_code_for_prim prim)
d5015 1
a5015 1
      | Pervasives.INTUMINUS => unary_negate(MirTypes.SUBV,regs,the_code,exn_code_for_prim prim)
d5118 3
a5120 3
      | Pervasives.WORD32ANDB => word32_binary_calc (MirTypes.AND,regs,the_code)
      | Pervasives.WORD32ORB => word32_binary_calc (MirTypes.OR,regs,the_code)
      | Pervasives.WORD32XORB => word32_binary_calc (MirTypes.EOR,regs,the_code)
d6113 1
a6113 1
                               MirTypes.BINARY(MirTypes.SUB,
d7529 1
a7529 1
          | (x, reg) => MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG reg,
@


1.300
log
@Simplifications and rationalizations
@
text
@d4 3
d2090 1
d2101 1
d2105 2
a2106 2
                (Mir_Utils.send_to_new_reg(Mir_Utils.ONE(initial)),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE(Mir_Utils.INT size)))
d2154 2
d2157 42
a2198 38
                             (if constantp then 
                                [MirTypes.UNARY(MirTypes.MOVE,
                                                Mir_Utils.reg_from_gp new_reg',
                                                MirTypes.GP_IMM_INT constant_value)]
                              else
                                []) @@
                             (if bytearray then
                                [MirTypes.COMMENT"ByteArray creation operation",
                                 MirTypes.ALLOCATE(MirTypes.ALLOC_BYTEARRAY, res1,
                                                   if constantp then
                                                     MirTypes.GP_IMM_INT constant_value
                                                   else
                                                     new_reg')]
                              else
                                [MirTypes.COMMENT"Array creation operation",
                                 MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, 
                                                   (if constantp then
                                                      MirTypes.GP_IMM_INT constant_value
                                                    else
                                                      new_reg'))]) @@
                             [MirTypes.COMMENT"Initialise all of the values"] @@
                             (if constantp then 
                                [MirTypes.UNARY(MirTypes.MOVE, 
                                                MirTypes.GC_REG count,
                                                MirTypes.GP_IMM_INT constant_value)]
                              else
                                [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG count, new_reg')]) @@
			     (if bytearray then
				[MirTypes.BINARY(MirTypes.LSR,
						 Mir_Utils.reg_from_gp new_reg,
						 new_reg,
						 MirTypes.GP_IMM_ANY 2)]
			      else
				[]) @@
                             [MirTypes.UNARY(MirTypes.MOVE,
                                             temp,
                                             MirTypes.GP_GC_REG result),
                              MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)]) ::
d2200 23
a2222 19
                 MirTypes.BLOCK(loop_tag,
                                [MirTypes.STOREOP(MirTypes.STB,
						  Mir_Utils.reg_from_gp new_reg,
                                                  temp,
                                                  MirTypes.GP_IMM_ANY 1),
                                 MirTypes.BINARY(MirTypes.ADD, 
                                                 temp,
                                                 temp_gp,
                                                 MirTypes.GP_IMM_ANY 1),
                                 MirTypes.BINARY(MirTypes.ADD, 
                                                 MirTypes.GC_REG count,
                                                 MirTypes.GP_GC_REG count,
                                                 MirTypes.GP_IMM_INT ~1),
                                 MirTypes.TEST(MirTypes.BGT, loop_tag, MirTypes.GP_GC_REG count, 
                                               MirTypes.GP_IMM_ANY 0),
				 MirTypes.NULLARY(MirTypes.CLEAN, 
						Mir_Utils.reg_from_gp new_reg),
				 MirTypes.NULLARY(MirTypes.CLEAN, temp),
                                 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)])
d2224 23
a2246 16
                 MirTypes.BLOCK(loop_tag,
                                [MirTypes.STOREOP(MirTypes.STREF, Mir_Utils.reg_from_gp new_reg,
                                                  temp,
                                                  MirTypes.GP_IMM_ANY 9),
                                 MirTypes.BINARY(MirTypes.ADD, 
                                                 temp,
                                                 temp_gp,
                                                 MirTypes.GP_IMM_ANY 4),
                                 MirTypes.BINARY(MirTypes.ADD, 
                                                 MirTypes.GC_REG count,
                                                 MirTypes.GP_GC_REG count,
                                                 MirTypes.GP_IMM_INT ~1),
                                 MirTypes.TEST(MirTypes.BGT, loop_tag, MirTypes.GP_GC_REG count, 
                                               MirTypes.GP_IMM_ANY 0),
				 MirTypes.NULLARY(MirTypes.CLEAN, temp),
                                 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)])) ::
d2252 14
a2265 4
                Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE, work1, MirTypes.GP_IMM_ANY 0),
                           MirTypes.STOREOP(MirTypes.STREF, work1, res1, MirTypes.GP_IMM_ANY 5),
                           MirTypes.UNARY(MirTypes.MOVE, work2, MirTypes.GP_IMM_INT 1),
                           MirTypes.STOREOP(MirTypes.STREF, work2, res1, MirTypes.GP_IMM_ANY 1)]),
d2269 165
d2504 3
d2571 1
a2571 1
      fun length_code (bytearray,regs,the_code) =
d2584 5
a2588 2
                    [MirTypes.COMMENT ((if bytearray then "Byte" else "") ^ "Array length operation"),
                     MirTypes.STOREOP(MirTypes.LDREF,res1,Mir_Utils.reg_from_gp new_reg,
d2590 4
d2595 4
a2598 1
                                     MirTypes.GP_GC_REG result,MirTypes.GP_IMM_ANY 6),
d2600 2
a2601 1
                                     MirTypes.GP_GC_REG result,MirTypes.GP_IMM_ANY 2)
d2612 2
d2644 2
d2675 3
a2677 1
            | _ => Crash.impossible "can't code generate the argument given to Array.sub in _mir_cg"
d2701 2
a2702 1
                     [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
d2704 11
a2714 8
                     [MirTypes.STOREOP
		      (MirTypes.LDREF, MirTypes.GC_REG MirRegisters.global,
		       Mir_Utils.reg_from_gp new_reg', MirTypes.GP_IMM_ANY ~3),
		      MirTypes.BINARY
		      (MirTypes.LSR, MirTypes.GC_REG MirRegisters.global,
		       MirTypes.GP_GC_REG MirRegisters.global,
		       MirTypes.GP_IMM_ANY 6), (* Length in words *)
		      MirTypes.TEST(MirTypes.BGT, main_tag,
d2717 2
a2718 1
		      MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
d2727 20
a2746 15
                      [MirTypes.TEST(MirTypes.BLT, exn_tag, new_reg, MirTypes.GP_IMM_INT 0)]) @@
                      [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG MirRegisters.global,
                                        Mir_Utils.reg_from_gp new_reg',
                                        MirTypes.GP_IMM_ANY ~3),
                      MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
                                      MirTypes.GP_GC_REG MirRegisters.global,
                                      MirTypes.GP_IMM_ANY 4),
                      MirTypes.BINARY(MirTypes.SUB,MirTypes.GC_REG MirRegisters.global,
                                      MirTypes.GP_GC_REG MirRegisters.global,
                                      MirTypes.GP_IMM_ANY 1),
                      MirTypes.TEST(MirTypes.BGE, main_tag,
				    MirTypes.GP_GC_REG MirRegisters.global,
				    MirTypes.GP_IMM_ANY 5),
		    (* Note that the 5 includes the left over bit of secondary tag *)
                      MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
d2748 2
a2749 1
		   [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG MirRegisters.global,
d2752 2
a2753 1
		    MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
d2756 2
a2757 1
		    MirTypes.BINARY(MirTypes.SUB,MirTypes.GC_REG MirRegisters.global,
d2765 35
a2799 19
                  MirTypes.BLOCK(main_tag,
                                 if bytearray then
                                   [MirTypes.COMMENT "ByteArray subscript operation",
                                    MirTypes.BINARY(MirTypes.LSR, MirTypes.GC_REG MirRegisters.global,
                                                    new_reg, MirTypes.GP_IMM_ANY 2),
                                    MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG MirRegisters.global,
                                                    MirTypes.GP_GC_REG MirRegisters.global, new_reg'),
                                    MirTypes.STOREOP(MirTypes.LDB, res1,
                                                     MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 1),
				    MirTypes.BINARY(MirTypes.ASL, res1, res2,
						    MirTypes.GP_IMM_ANY 2),
                                    MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]
                                 else
                                   [MirTypes.COMMENT "Array subscript operation",
                                    MirTypes.BINARY(MirTypes.ADD,
                                                    MirTypes.GC_REG MirRegisters.global,new_reg', new_reg),
                                    MirTypes.STOREOP(MirTypes.LDREF, res1,
                                                     MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9),
                                    MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]) ::
d2806 204
a3009 21
              ((Sexpr.ATOM (code @@ code' @@
                            (if bytearray then
                               [MirTypes.COMMENT "Unsafe ByteArray subscript operation",
                                MirTypes.BINARY(MirTypes.LSR, MirTypes.GC_REG MirRegisters.global,
                                                new_reg, MirTypes.GP_IMM_ANY 2),
                                MirTypes.BINARY(MirTypes.ADD,
						MirTypes.GC_REG MirRegisters.global,
                                                MirTypes.GP_GC_REG MirRegisters.global,
						new_reg'),
                                MirTypes.STOREOP(MirTypes.LDB, res1,
                                                 MirTypes.GC_REG MirRegisters.global,
						 MirTypes.GP_IMM_ANY 1),
				MirTypes.BINARY(MirTypes.ASL, res1, res2,
						MirTypes.GP_IMM_ANY 2)
				]
                             else
                               [MirTypes.COMMENT "Unsafe array subscript operation",
                                MirTypes.BINARY(MirTypes.ADD,
                                                MirTypes.GC_REG MirRegisters.global, new_reg', new_reg),
                                MirTypes.STOREOP(MirTypes.LDREF, res1,
                                                 MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9)])),
d3013 2
d3143 2
d3168 2
a3169 1
                     [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
d3173 2
a3174 1
                     [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg',
d3183 2
a3184 1
            | _ => Crash.impossible "_mir_cg : update can't code generate arguments "
d3212 2
a3213 1
                     [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
d3215 11
a3225 8
                     [MirTypes.STOREOP
		      (MirTypes.LDREF, MirTypes.GC_REG MirRegisters.global,
		       Mir_Utils.reg_from_gp new_reg', MirTypes.GP_IMM_ANY ~3),
		      MirTypes.BINARY
		      (MirTypes.LSR, MirTypes.GC_REG MirRegisters.global,
		       MirTypes.GP_GC_REG MirRegisters.global,
		       MirTypes.GP_IMM_ANY 6), (* Length in words *)
		      MirTypes.TEST(MirTypes.BGT, main_tag,
d3228 2
a3229 1
		      MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
d3234 2
a3235 1
                     [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
d3239 20
a3258 17
                   [MirTypes.TEST
		      (MirTypes.BLT, exn_tag, new_reg,
		       MirTypes.GP_IMM_INT 0)]) @@
                [MirTypes.STOREOP
		   (MirTypes.LDREF, MirTypes.GC_REG MirRegisters.global,
                    Mir_Utils.reg_from_gp new_reg', MirTypes.GP_IMM_ANY ~3),
                 MirTypes.BINARY
		   (MirTypes.LSR, MirTypes.GC_REG MirRegisters.global,
                    MirTypes.GP_GC_REG MirRegisters.global,
                    MirTypes.GP_IMM_ANY 4),
                 MirTypes.BINARY
		   (MirTypes.SUB, MirTypes.GC_REG MirRegisters.global,
                    MirTypes.GP_GC_REG MirRegisters.global, new_reg),
                 MirTypes.TEST
		   (MirTypes.BGE, main_tag,
		    MirTypes.GP_GC_REG MirRegisters.global,
		    MirTypes.GP_IMM_ANY 5),
d3261 2
a3262 1
                 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
d3264 2
a3265 1
		   [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG MirRegisters.global,
d3268 2
a3269 1
		    MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
d3272 2
a3273 1
		    MirTypes.BINARY(MirTypes.SUB,MirTypes.GC_REG MirRegisters.global,
d3276 2
a3277 1
		    MirTypes.TEST(MirTypes.BHI, main_tag,
d3280 2
a3281 1
		    MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)])
d3284 2
a3285 1
              [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG main_tag)]
d3293 110
a3402 77
              MirTypes.BLOCK(main_tag,
			     let
			       val address = MirTypes.GC.new ()
			     in
			       if bytearray then
                                 [MirTypes.COMMENT ((if safe then "" else "Unsafe ") ^ "ByteArray update operation"),
                                  MirTypes.BINARY(MirTypes.LSR, MirTypes.GC_REG address,
                                                  new_reg, MirTypes.GP_IMM_ANY 2),
                                  MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG address,
                                                  MirTypes.GP_GC_REG address, new_reg'),
                                  MirTypes.BINARY(MirTypes.LSR, MirTypes.GC_REG MirRegisters.global,
                                                  new_reg'', MirTypes.GP_IMM_ANY 2),
                                  MirTypes.STOREOP(MirTypes.STB, MirTypes.GC_REG MirRegisters.global,
                                                   MirTypes.GC_REG address, MirTypes.GP_IMM_ANY 1),
                                  MirTypes.NULLARY(MirTypes.CLEAN, MirTypes.GC_REG address),
                                  MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]
			       else
				 [MirTypes.COMMENT ((if safe then "" else "Unsafe ") ^ "Array update operation"),
				  MirTypes.BINARY(MirTypes.ADD,
						  MirTypes.GC_REG address, new_reg',
						  new_reg),
				  MirTypes.STOREOP(MirTypes.STREF,
						   Mir_Utils.reg_from_gp new_reg'',
						   MirTypes.GC_REG address,
						   MirTypes.GP_IMM_ANY 9),
                                  MirTypes.NULLARY(MirTypes.CLEAN,
						   MirTypes.GC_REG address)] @@
				 (if isIntegral then
				    [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]
				  else
				    [MirTypes.COMMENT"Do we need to unlink it",
				     MirTypes.STOREOP(MirTypes.LDREF, forward_reg,
						      Mir_Utils.reg_from_gp reg1,
						      MirTypes.GP_IMM_ANY 1),
				     MirTypes.TEST(MirTypes.BEQ, finish_tag, MirTypes.GP_GC_REG forward,
						   MirTypes.GP_IMM_INT 0),
				     MirTypes.BRANCH(MirTypes.BRA,
						     MirTypes.TAG unlink_tag)])
			     end) ::
              (if isIntegral then
                 exn_blocks
               else
                 MirTypes.BLOCK(unlink_tag,
                                [MirTypes.STOREOP(MirTypes.LDREF, backward_reg,
                                                  Mir_Utils.reg_from_gp reg1,
                                                  MirTypes.GP_IMM_ANY 5),
                                MirTypes.TEST(MirTypes.BEQ, modified_tag, 
                                              MirTypes.GP_GC_REG backward,
                                              MirTypes.GP_IMM_INT 0),
                                MirTypes.COMMENT "Unlink the cell",
                                MirTypes.STOREOP(MirTypes.STREF, backward_reg,
                                                 forward_reg,
                                                 MirTypes.GP_IMM_ANY 8),
                                MirTypes.STOREOP(MirTypes.STREF, forward_reg,
                                                 backward_reg,
                                                 MirTypes.GP_IMM_ANY 4),
                                MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG modified_tag)]) ::
                 MirTypes.BLOCK(modified_tag,
                                [MirTypes.UNARY(MirTypes.MOVE, scratch_reg, MirTypes.GP_IMM_INT 0),
                                 MirTypes.STOREOP(MirTypes.STREF, 
                                                  scratch_reg,
                                                  Mir_Utils.reg_from_gp reg1,
                                                  MirTypes.GP_IMM_ANY 1),
                                 MirTypes.STOREOP(MirTypes.LDREF, scratch_reg,
                                                  MirTypes.GC_REG MirRegisters.implicit,
                                                  MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain),
                                 MirTypes.STOREOP(MirTypes.STREF, scratch_reg,
                                                  Mir_Utils.reg_from_gp reg1,
                                                  MirTypes.GP_IMM_ANY 5),
                                 MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG MirRegisters.global,
                                                 reg1,
                                                 MirTypes.GP_IMM_ANY ~3),
                                 MirTypes.STOREOP(MirTypes.STREF, 
                                                  MirTypes.GC_REG MirRegisters.global,
                                                  MirTypes.GC_REG MirRegisters.implicit,
                                                  MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain),
                                 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]) ::
d3405 3
a3407 1
                 Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE, res1, MirTypes.GP_IMM_INT 0)]), [], [])))
d3410 199
d5075 42
a5116 13
      | Pervasives.ARRAY_FN => array_code (false,regs,the_code,exn_code_for_prim prim)
      | Pervasives.LENGTH => length_code (false,regs,the_code)
      | Pervasives.SUB => sub_code (false, true,regs,the_code,exn_code_for_prim prim)
      | Pervasives.UPDATE => update_code (false, true,TypeUtils.is_integral3 primTy,regs,the_code,exn_code_for_prim prim)
      | Pervasives.UNSAFE_SUB => sub_code (false, false,regs,the_code,exn_code_for_prim prim)
      | Pervasives.UNSAFE_UPDATE => update_code (false, false,TypeUtils.is_integral3 primTy,regs,the_code,exn_code_for_prim prim)

      | Pervasives.BYTEARRAY => array_code (true,regs,the_code,exn_code_for_prim prim)
      | Pervasives.BYTEARRAY_LENGTH => length_code (true,regs,the_code)
      | Pervasives.BYTEARRAY_SUB => sub_code (true, true,regs,the_code,exn_code_for_prim prim)
      | Pervasives.BYTEARRAY_UNSAFE_SUB => sub_code (true, false,regs,the_code,exn_code_for_prim prim)
      | Pervasives.BYTEARRAY_UPDATE => update_code (true, true,true,regs,the_code,exn_code_for_prim prim)
      | Pervasives.BYTEARRAY_UNSAFE_UPDATE => update_code (true, false,true,regs,the_code,exn_code_for_prim prim)
@


1.299
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d1082 1
a1082 2
require "../lambda/interproc";
require "../lambda/tail";
d1107 1
a1107 2
  structure InterProc : INTERPROC
  structure Tail : TAIL
d1120 1
a1120 1
    InterProc.LambdaTypes = Mir_Utils.Mir_Env.LambdaTypes
d1123 1
a1123 1
  sharing Library.AugLambda = Tail.AugLambda = Mir_Utils.AugLambda
d1126 1
a1126 1
  sharing TypeUtils.Datatypes.NewMap = Library.NewMap = Mir_Utils.NewMap
a1127 1
  sharing MachPerv.Pervasives = Mir_Utils.Pervasives
d1129 1
a1129 1
  sharing type Mir_Utils.Mir_Env.Map = InterProc.Map = IntMap.T
d1133 1
a1133 1
  sharing type Mir_Utils.Pervasives.pervasive = LambdaPrint.LambdaTypes.Primitive
a1139 1
  sharing type Mir_Utils.bignum = BigNum.bignum
d1143 1
a1143 1
  structure Pervasives = Mir_Utils.Pervasives
d1169 1
d1172 1
a1172 1
  fun lprint s = MLWorks.IO.output (MLWorks.IO.std_out,s ^ "\n")
d1223 1
a1223 1
      AugLambda.APP(le, lel,_) => new_frees_list (new_frees (vars, le), lel)
d1226 1
a1226 1
    | AugLambda.FN(lvl, le,_,_) => new_frees (vars, le)
d1276 2
d1288 11
a1298 1
  fun zip6 (l1,l2,l3,l4,l5,l6) =
d1300 4
a1303 4
      fun aux ([],[],[],[],[],[],acc) = rev acc
        | aux (a1::b1,a2::b2,a3::b3,a4::b4,a5::b5,a6::b6,acc) =
          aux (b1,b2,b3,b4,b5,b6,(a1,a2,a3,a4,a5,a6)::acc)
        | aux _ = Crash.impossible "zip6"
d1305 1
a1305 1
      aux (l1,l2,l3,l4,l5,l6,[])
d1337 1
d1367 14
a1425 1
    (* And a list of primitives whose args don't escape *)
d1428 1
a1428 1
        val (prim_to_lambda_map, prim_lvars, new_lambda_exp) =
a1430 10

        val escaping_lvars =
          lists_reducel
          (fn (new, prim) =>
           (case NewMap.tryApply'(prim_to_lambda_map, prim) of
              SOME lv => Set.add_member(lv, new)
            | _ => new))
          (Set.empty_set, InterProc.escaping_prim_list)

        val prim_lvars = Set.setdiff(prim_lvars, escaping_lvars)
d1432 1
a1432 1
        (prim_to_lambda,prim_lvars,new_lambda_exp)
d1459 3
a1461 3
	       [{lexp=AugLambda.SCON(Ident.STRING string, NONE), size=0}],
	       Debugger_Types.null_backend_annotation),
	      size=0}), le), size=size})
d1510 1
a1510 1
        fun find_frees (env,closure,fcn,prim_to_lambda) =
d3673 7
d3771 1
a3771 3
    val (prim_to_lambda, prim_lvars, new_lambda_exp) = make_prim_info lambda_exp

    val fn_bindings = InterProc.binding_list new_lambda_exp
d3773 1
a3773 1
    val escape_map = InterProc.escape_map fn_bindings
d3775 1
a3775 7
    fun funarg_escapes fvar = 
      case IntMap.tryApply' (escape_map,fvar) of
        SOME x => x
      | _ => true

    (* Should be the lambda variables representing all the functions *)
    val top_lambdas = IntMap.domain escape_map
d3836 18
d3858 2
a3859 1
                (closure,funs_in_closure, fn_tag_list, tuple_bindings),
d3865 1
a3865 1
                 (closure,funs_in_closure, fn_tag_list, tuple_bindings),spills,calls)
d3912 1
a3912 1
                   (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls) =
d3916 1
a3916 1
                  (closure,funs_in_closure,fn_tag_list,tuple_bindings),spills,calls)
d3920 1
a3920 1
                        (closure,funs_in_closure, fn_tag_list,tuple_bindings), spills,calls)
d3930 112
d4045 3
a4047 3
                                     [{lexp=lexp, size=gc_objects_in_parm}],_), 
               env,static_offset, start_at, tails,
               (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls) =
d4086 1
a4086 1
                    (closure,funs_in_closure,fn_tag_list,tuple_bindings),spills,calls)
d4107 1
a4107 1
                                     (closure,funs_in_closure,fn_tag_list,tuple_bindings),!spills,!calls)
d4157 1
a4157 1
                                      [{lexp=AugLambda.VAR lvar, size=0}],
d4161 2
a4162 2
                        tails,
                        (closure,funs_in_closure,fn_tag_list,tuple_bindings),!spills,!calls)
d4468 2
a4469 2
             env,static_offset, start_at, tails,
             (closure,funs_in_closure, fn_tag_list,tuple_bindings),
d4489 1
a4489 1
                (closure,funs_in_closure,fn_tag_list,tuple_bindings),spills,calls)
d4582 2
a4583 2
	cg_sub(lexp1, env', static_offset', start_at',tails,
	       (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls)
a4603 11
(*
      (* APP (FN ..) should be eliminated by lambda optimizer *)
      (* But the optimizer may be switched off *)
    | cg_sub(arg as AugLambda.APP
	     ({lexp=AugLambda.FN(lvarl, {lexp=lexp1, ...},name,_), ...},[lexp2],_), env,
             static_offset, start_at,tails,
             (closure,funs_in_closure, fn_tag_list,tuple_bindings),
             spills,calls) =
      Crash.impossible "APP-FN:cg_sub:mir_cg"
*)

d4606 93
a4698 120
				  arg_list,debugger_information),
             env,static_offset, start_at,tails,
	     (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls) =
    let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out, 
		 "In cg_sub(APP), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
*)
      (* First code generate to evaluate which function should be called, *)
      (* then evaluate the argument, then call the function *)
      val ((fn_reg, fn_code,runtime_env,spills,calls'), pos, is_same_set, can_stack_args, tails, loop_tag) =
	case le1 of
          (* If its a lambda var, then we may know the function *)
	  AugLambda.VAR lvar =>
	    let
	      val ((reg, code), pos, is_same_set) =
		Mir_Utils.cg_lvar (lvar, env, closure, funs_in_closure)
              (* Interceptable code must not have an stacked argument. *)
              (* or the back tracer gets very confused *)
              val can_stack_args =
                Set.is_member(lvar, prim_lvars) orelse 
                (not intercept andalso not (funarg_escapes lvar))
	    in
	      ((Mir_Utils.ONE reg,
		((Sexpr.ATOM code, [], NONE, Sexpr.NIL), [], []),
                RuntimeEnv.EMPTY,spills,calls+1),
	       pos,
               is_same_set, 
               can_stack_args,
               tails,
               if is_same_set 
                 then top_lambda_loop_tags lvar
               else Lists.hd fn_tag_list)
	    end
        | _ =>
            (* Else code generate as usual *)
            (cg_sub(le1, env, static_offset, start_at,false,
                    (closure,funs_in_closure,fn_tag_list,tuple_bindings),spills,calls+1),
             0, false, false, tails, Lists.hd fn_tag_list)

      (* What we should do here is code generate arglist as a STRUCT and then *)
      (* sort out the various cases in new_do_app *)
       
      fun do_single_arg le2 =
        let
          (* Do the argument *)
          val (arg_reg, arg_code,runtime_env',spills,calls') =
            cg_sub(le2, env,static_offset + gc_objects_in_call,start_at + gc_objects_in_call, false,
                   (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls')

          (* Punt the complicated stuff to Mir_Utils *)
          (* Note that can_stack_args is false if intercept is true *)
          val (reg, fn_code, arg_code, call_code) =
            Mir_Utils.new_do_app(debugger_information,
                                 fn_reg, fn_code, arg_reg, arg_code,
                                 loop_tag, tuple_bindings,
                                 (* Don't treat interceptable code as if the arguments escape *)
                                 not can_stack_args,
                                 is_same_set, pos, funs_in_closure, fn_tag_list,
                                 tails, opt_tail_calls, opt_self_calls)

          (* We ought to do better on the has_tupled_arg parameter *)
          (* But it requires more interprocedural analysis *)
          val code as ((first, blocks, tag_opt, last), values, procs_list) = 
            Mir_Utils.combine
            (fn_code,
             Mir_Utils.combine
             (arg_code, make_call_code(calls+1,call_code)))

          val runtime_env =
            if variable_debug then 
              RuntimeEnv.APP(runtime_env,runtime_env',NONE)
            else 
              RuntimeEnv.EMPTY
        in
          (reg, code, runtime_env,spills,calls')
        end

      fun do_multi_arg arg_list =
        let
          (* Do the argument *)
          val (arg_reg, arg_code,runtime_env',spills,calls') =
            cg_sub(AugLambda.STRUCT arg_list, env,
                   static_offset + gc_objects_in_call,
                   start_at + gc_objects_in_call, false,
                   (closure,funs_in_closure, fn_tag_list,tuple_bindings),
                   spills,calls')
          (* Punt the complicated stuff to Mir_Utils *)
          val (reg, fn_code, arg_code, call_code) =
            Mir_Utils.do_multi_app(debugger_information,
                                   fn_reg, fn_code, arg_reg, arg_code,
                                   loop_tag,tuple_bindings,
                                   is_same_set, pos, funs_in_closure, fn_tag_list,
                                   tails, opt_tail_calls, opt_self_calls)
          val code as ((first, blocks, tag_opt, last), values, procs_list) = 
            Mir_Utils.combine
            (fn_code,
             Mir_Utils.combine
             (arg_code, make_call_code(calls+1,call_code)))

          val runtime_env =
            if variable_debug then 
              Crash.impossible "variable debug and multi arg app"
            else 
              RuntimeEnv.EMPTY
        in
          (reg, code, runtime_env,spills,calls')
        end
    in
        case arg_list of 
          [{lexp=le2, ...}] => do_single_arg le2
        | _ => do_multi_arg arg_list
    end

      
d4701 1
a4701 1
	   (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls) =
d4728 1
a4728 1
                       (closure,funs_in_closure,fn_tag_list,tuple_bindings),spills,calls)
d4744 1
a4744 1
		val (reg, code) = Mir_Utils.tuple_up(regs)
d4772 1
a4772 1
             (closure,funs_in_closure, fn_tag_list,tuple_bindings),
d4791 1
a4791 1
               (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls)
d4829 2
a4830 2
	     env, static_offset, start_at,tails,
             (closure,funs_in_closure,fn_tag_list,tuple_bindings),spills,calls) =
d4884 2
a4885 2
                    cg_sub(lexp, env, static_offset, start_at,tails,
                           (closure,funs_in_closure, fn_tag_list,tuple_bindings),
d4918 1
a4918 1
                         (#2 (Mir_Utils.tuple_up_in_reg(many,end_reg))))
d4971 2
a4972 2
                           cg_sub(x, env, static_offset + le_offset,start_at + le_offset,tails,
                                  (closure,funs_in_closure, fn_tag_list, tuple_bindings),
d5001 2
a5002 2
                   cg_sub(x, env, static_offset + le_offset,start_at + le_offset,tails,
                          (closure,funs_in_closure, fn_tag_list, tuple_bindings),
d5262 3
a5264 2
                       AugLambda.APP({lexp=AugLambda.BUILTIN (test,_), ...},[{lexp=arg,...}],_) => (test,arg)
                     | AugLambda.APP({lexp=AugLambda.BUILTIN _, ...},argl,_) =>
d5272 1
a5272 1
                        (closure, funs_in_closure, fn_tag_list, tuple_bindings),
d5290 1
a5290 1
                            (closure,funs_in_closure, fn_tag_list,tuple_bindings),
d5313 1
a5313 1
                            (closure,funs_in_closure, fn_tag_list,tuple_bindings),
d5359 1
a5359 1
                           tag :: Mir_Utils.list_of(j-i-1, dflt_tag) @@ expand rest
d5550 1
a5550 1
		   if length val_code_tags_list < 3 
d5625 10
a5634 12
			  case max_size_opt
		          of NONE => false
			  |  SOME sz =>
			    if sz <= MachSpec.bits_per_word then
			      false
			    else if sz = 32 then
			      true
			    else 
			      Crash.impossible
				("Unknown integer size in pattern "
				 ^ Int.toString sz)

d5639 2
a5640 3
			    case arg_regs
			    of Mir_Utils.ONE reg =>
			      Mir_Utils.get_word32 reg
d5642 1
a5642 2
			      Crash.impossible
				"LIST found in switch on Integer32"
d5651 4
a5654 8
			  fun do_conversion 
			        (AugLambda.SCON_TAG 
				   (Ident.INT (i,location), max_size_opt),
				 code, tag) =
			    (Mir_Utils.convert_int (i, max_size_opt),
			     0, code, tag)
			  |   do_conversion _ =
			    Crash.impossible "Mixed tag type in switch"
d5834 1
a5834 1
					 (closure,funs_in_closure, fn_tag_list,tuple_bindings),
d6088 1
a6088 1
					 (closure,funs_in_closure, fn_tag_list,tuple_bindings),
d6203 1
a6203 2
					(4*(static_offset + i +
					   (funs_in_closure * 2 - 1)) - 1)),
d6258 11
a6268 13
                               case 
                              Mir_Utils.do_app(Debugger_Types.null_backend_annotation,
                                               regs', the_code',
                                               Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG 
                                                                           caller_arg)),
                                               no_code)
                                             of
                                              (_, ((app_code, [], NONE, last), 
                                                   [], [])) =>
                                                 (case Mir_Utils.contract_sexpr last of
                                                    [] => app_code
                                                  | _ => Crash.impossible"Bad result for STRINGEQ")
                                             | _ => Crash.impossible"Bad result for STRINGEQ"
d6277 1
a6277 2
					  (4*(static_offset + i +
                                              (2*funs_in_closure-1)) - 1)),
d6455 2
a6456 2
    | cg_sub(arg as AugLambda.SCON (scon, size), e,static_offset, start_at,tails,
	     (closure,funs_in_closure, fn_tag_list, tuple_bindings),spills,calls) =
d6498 2
a6499 2
		          static_offset,start_at,tails,
		          (closure,funs_in_closure,fn_tag_list,tuple_bindings),
d6531 2
a6532 2
		          static_offset,start_at,tails,
		          (closure,funs_in_closure,fn_tag_list,tuple_bindings),
d6590 1
a6590 1
    | cg_sub(fcn as AugLambda.FN(lvl, 
d6594 1
a6594 1
             (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls) =
d6605 15
d6652 1
d6654 1
d6667 1
a6667 1
            [MirTypes.ENTER (map MirTypes.GC arg_regs)] @@
d6670 2
a6671 1
             make_get_args_code (arg_regs,map #2 internal_regs)),
d6680 6
d6688 3
a6690 3
          cg_sub(lexp,lambda_env, 0, start_at, true,
                 (new_closure,1, [tag] (* tag for this function *), []),
                 (1,0,0),0)
d6746 1
a6746 1
    | cg_sub(exp as AugLambda.LETREC(lv_list, le_list, {lexp=lexp, ...}),
d6748 1
a6748 1
             (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls) =
a6749 14
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out, 
		 "In cg_sub(LETREC), fp_spill = " ^ Int.toString fp_spills ^ "\n")
	end
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating LETREC\n",
		  LambdaPrint.string_of_lambda exp])
*)

d6761 12
d6776 1
a6776 1
	(fn {lexp=AugLambda.FN(lvl, le,_,_), ...} => (lvl, le)
d6786 12
a6873 8
      (* First, unwrap the outer lets if any, *)
      (* and look for selects off the argument, bringing these to the front *)
      (* This is to allow for the tail call reentry point *)

      val select_rest_list = map Tail.get_simple_selects fn_args_and_bodies

      val (arg_select_list, new_bodies) = Lists.unzip select_rest_list

d6875 4
a6878 1
      val arg_regs_list = map assign_callee_regs fn_args
d6882 4
a6885 2
        (map (fn lvar => (lvar, MirTypes.GC.new())))
        fn_args
d6887 1
a6887 1
      (* The initial environments -- just the parameter is defined *)
d6890 12
a6901 5
        (fn arg_reg_copies =>
         (lists_reducel
          (fn (env,(lvar, copy)) => Mir_Env.add_lambda_env((lvar, MirTypes.GC copy),env))
          (Mir_Env.empty_lambda_env,arg_reg_copies)))
	args_and_copied_callee_arg_list
d6912 1
a6912 1
          ((Sexpr.ATOM(comment_for_name @@ [MirTypes.ENTER (map MirTypes.GC arginfo)] @@
d6922 6
a6927 1
        (Lists.zip (lambda_names,arg_regs_list))
d6931 4
a6934 3
	map
        make_get_args_code
	(Lists.zip (arg_regs_list,map (map #2) args_and_copied_callee_arg_list))
d6941 1
a6941 1
	(fn (arg_copy, bindings, env, new_closure, pos, x) =>
d6944 2
a6945 4
	   val (code, env, static, start,runtime_env,spills,calls) = 
	     cg_bind_list(bindings, env, pos, start_at + pos,
			  (new_closure, funs - (x div 2), tags,[]), (1,0,0),0)
           val entry_code = Mir_Utils.combine (((Sexpr.ATOM arg_copy, [], NONE, Sexpr.NIL), [], []), code)
d6947 1
a6947 1
	   (make_call_code(0,entry_code),env, static, start,runtime_env,spills,calls,first_spill)
d6949 1
a6949 2
	(zip6 (arg_copy_list,
               arg_select_list,
a6954 2
      val env_list = map #2 code_env_static_start_list

d6957 3
a6959 21
	map
	(fn (env, [(_,reg)], arg_selects) =>
	 (0, MirTypes.GC reg) ::
	 map
	 (fn (lv, {lexp=AugLambda.SELECT({index = index, ...},_), ...}) =>
          (case Mir_Env.lookup_lambda (lv, env) of
             SOME offset => (index, offset)
           | _ => Crash.impossible "Can't find variable in tuple_bindings")
          | _ => Crash.impossible"Binding not to select")
	 arg_selects
         (* For multiple arg case just collect a list of the assigned argument registers *)
         (* This is rather inelegant as tuple_bindings is used with two meanings *)
         | (env, arg_regs,[]) =>
             #2
             (lists_reducel
              (fn ((n,acc),(_,reg)) => (n+1,(n,MirTypes.GC reg)::acc))
              ((0,[]),rev arg_regs))
         | (_, arg_regs,_) => Crash.impossible "arg_selects in tuple_bindings_list")
        (zip3 (env_list,
               args_and_copied_callee_arg_list,
               arg_select_list))
d6963 2
a6964 2
	(fn (lexp, 
             (entry_code, env, static_offset, start_at,runtime_env,spills,calls,first_spill), 
d6969 2
d6972 2
a6973 3
                cg_sub(lexp, env, static_offset, start_at,true,
                       (new_closure,funs - x div 2, tags,tuple_bindings),spills,calls)
           val loop_tag = top_lambda_loop_tags lvar
d6990 1
a6990 3
             case runtime_env of 
               RuntimeEnv.LIST(runtime_envs) => RuntimeEnv.LIST(runtime_envs@@[runtime_env'])
             | _ => Crash.impossible "fn_reg_code_list:LETREC:_mir_cg.sml"
d6996 1
a6996 1
        (zip7 (new_bodies, 
a7005 22
      (* Put the returned value in the right place *)
      val final_code_list =
	let
	  fun send (res,_,_,_) =
	   let
	     val result_temporary = MirTypes.GC.new ()
	   in
	     Mir_Utils.send_to_given_reg(res, result_temporary) @@
	     [MirTypes.UNARY(MirTypes.MOVE,
			     MirTypes.GC_REG callee_arg,
			     MirTypes.GP_GC_REG result_temporary)]
	   end
	in
	  map send fn_reg_code_list
	end

      val exit_code_list =
	map (fn final_code =>
	     ((Sexpr.CONS (Sexpr.ATOM final_code, Sexpr.ATOM[MirTypes.RTS]),
	      [], NONE, Sexpr.NIL), [], []))
	final_code_list

d7008 2
a7009 2
	(fn ((_, fn_code, env_spills, loop_tag), exit_code,entry_code) =>
	  (Mir_Utils.combine (entry_code, Mir_Utils.combine (fn_code, exit_code)),
d7012 1
a7012 1
	(zip3 (fn_reg_code_list, exit_code_list,entry_code_list))
d7017 1
d7077 1
a7077 1
               (closure,funs_in_closure,fn_tag_list,tuple_bindings),spills,calls)
d7093 1
a7093 1
             (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls) =
d7106 1
a7106 1
               (closure,funs_in_closure,fn_tag_list,tuple_bindings),spills,calls+1)
d7131 2
a7132 2
	       env, static_offset,start_at, tails,
               (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls) =
d7138 1
a7138 1
	fun convert_handler(AugLambda.FN([lv'], body, name, _)) =
d7217 1
a7217 1
		  AugLambda.FN([lv], {size = 0, lexp = AugLambda.VAR lv},
d7226 1
a7226 1
		       (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls)
d7231 2
a7232 2
			 static_offset + gc_objects_in_le,start_at + gc_objects_in_le,tails,
			 (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls)
d7262 1
a7262 1
		       (closure,funs_in_closure,fn_tag_list,tuple_bindings),spills,calls')
d7284 1
a7284 1
		       (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls)
d7303 1
a7303 1
		       (closure,funs_in_closure,fn_tag_list,tuple_bindings),spills,calls')
d7323 1
a7323 1
             (closure,funs_in_closure, fn_tag_list,tuple_bindings),_,_) =
d7345 1
a7345 1
	val (reg, new_code) = Mir_Utils.tuple_up_in_reg(sub_regs, result_reg)
d7427 1
a7484 1

d7531 1
a7531 1
    val new_procs =
d7535 1
d7543 1
a7543 1
		  values, new_procs),
@


1.299.4.1
log
@branched from 1.299
@
text
@a3 4
 * Revision 1.299  1996/11/06  11:08:05  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.299.3.1
log
@branched from 1.299
@
text
@a3 4
 * Revision 1.299  1996/11/06  11:08:05  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.299.3.1.1.1
log
@branched from 1.299.3.1
@
text
@a3 3
 * Revision 1.299.3.1  1996/12/17  17:46:05  hope
 * branched from 1.299
 *
@


1.299.2.1
log
@branched from 1.299
@
text
@a3 4
 * Revision 1.299  1996/11/06  11:08:05  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.299.1.1
log
@branched from 1.299
@
text
@a3 4
 * Revision 1.299  1996/11/06  11:08:05  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.299.1.1.1.1
log
@branched from 1.299.1.1
@
text
@a3 3
 * Revision 1.299.1.1  1996/11/14  12:47:17  hope
 * branched from 1.299
 *
@


1.298
log
@moving String from toplevel
@
text
@d4 3
d1067 1
a1067 1
require "../basis/__integer";
@


1.297
log
@Bytearray update is always integral
@
text
@d4 3
d128 1
a128 1
Fix range testing in String.ordof
d1087 1
d1203 1
a1203 1
  val no_code = ((Sexpr.NIL, [], MLWorks.Option.NONE, Sexpr.NIL), [], [])
d1211 1
a1211 1
  val empty_string_tree = NewMap.empty (String.<,op= : string * string -> bool)
d1254 1
a1254 1
  and bandf_opt(vars, MLWorks.Option.SOME le) = new_frees (vars, le)
d1406 1
a1406 1
              MLWorks.Option.SOME lv => Set.add_member(lv, new)
d1435 1
a1435 1
        ((lv, MLWorks.Option.NONE,
d1439 1
a1439 1
	       [{lexp=AugLambda.SCON(Ident.STRING string, MLWorks.Option.NONE), size=0}],
d1524 1
a1524 1
               [], MLWorks.Option.NONE, Sexpr.NIL), [], []),
d1540 1
a1540 1
                [],MLWorks.Option.NONE, Sexpr.NIL),[],[]),
d1629 1
a1629 1
                                   MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d1659 1
a1659 1
		MLWorks.Option.NONE, Sexpr.NIL),
d1675 1
a1675 1
                              exn_blocks, MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d1693 1
a1693 1
                                   [], MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d1712 1
a1712 1
		  exn_blocks, MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d1735 1
a1735 1
                             [], MLWorks.Option.SOME finish_tag, Sexpr.NIL), [], [])))
d1755 1
a1755 1
              ((Sexpr.ATOM new_code, [], MLWorks.Option.SOME finish_tag,
d1769 1
a1769 1
                               [], MLWorks.Option.SOME false_tag, Sexpr.NIL), [], []))
d1781 1
a1781 1
                               [], MLWorks.Option.SOME false_tag, Sexpr.NIL), [], []))
d1851 1
a1851 1
                 [], MLWorks.Option.SOME finish_tag, Sexpr.NIL), [], [])))
d1896 1
a1896 1
                                exn_blocks, MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d1912 1
a1912 1
                                exn_blocks, MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d1942 1
a1942 1
	      ((Sexpr.ATOM new_code, exn_blocks, MLWorks.Option.NONE, Sexpr.NIL),
d1957 1
a1957 1
	      [], MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d1984 1
a1984 1
	      ((Sexpr.ATOM new_code, [], MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d2023 1
a2023 1
			       [],MLWorks.Option.NONE,Sexpr.NIL),[],[])))
d2063 1
a2063 1
	      ((Sexpr.ATOM new_code, [],MLWorks.Option.NONE,Sexpr.NIL),
d2112 1
a2112 1
              MLWorks.Option.SOME tag => tag
d2206 1
a2206 1
              MLWorks.Option.SOME finish_tag, 
d2282 1
a2282 1
            MLWorks.Option.SOME finish_tag, 
d2311 1
a2311 1
              MLWorks.Option.NONE, 
d2346 1
a2346 1
            MLWorks.Option.NONE, 
d2376 1
a2376 1
                   [], MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d2406 1
a2406 1
                   [], MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d2451 1
a2451 1
	        of MLWorks.Option.SOME tag => tag
d2534 1
a2534 1
                  exn_blocks, MLWorks.Option.SOME finish_tag, Sexpr.NIL), [], [])))
d2561 1
a2561 1
              [], MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d2604 1
a2604 1
		  of MLWorks.Option.SOME tag => tag
d2667 1
a2667 1
		  exn_blocks, MLWorks.Option.SOME finish_tag, Sexpr.NIL), [], [])))
d2689 1
a2689 1
                [], MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d2750 1
a2750 1
	            of MLWorks.Option.SOME tag => tag
d2899 1
a2899 1
                 MLWorks.Option.SOME finish_tag, 
d2963 1
a2963 1
              MLWorks.Option.NONE, 
d3035 1
a3035 1
              MLWorks.Option.NONE, 
d3063 1
a3063 1
				 MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d3088 1
a3088 1
                             [], MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d3121 1
a3121 1
				 MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d3204 1
a3204 1
                       MLWorks.Option.SOME already_on_ref_chain_tag, 
d3222 1
a3222 1
		  [], MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d3234 1
a3234 1
	      of MLWorks.Option.SOME tag => tag
d3253 1
a3253 1
		  exn_blocks, MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d3273 1
a3273 1
		  [], MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d3282 1
a3282 1
			     ((Sexpr.ATOM code, [], MLWorks.Option.NONE,
d3293 1
a3293 1
	    of MLWorks.Option.SOME tag => tag
d3311 1
a3311 1
		MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d3324 1
a3324 1
	    of MLWorks.Option.SOME tag => tag
d3351 1
a3351 1
		MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d3365 1
a3365 1
	    of MLWorks.Option.SOME tag => tag
d3376 1
a3376 1
		     exn_blocks, MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d3396 1
a3396 1
                    of MLWorks.Option.SOME tag => tag
d3403 1
a3403 1
                                       exn_blocks, MLWorks.Option.NONE, Sexpr.NIL),
d3434 1
a3434 1
                                       exn_blocks, MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d3458 1
a3458 1
                                   [], MLWorks.Option.NONE, Sexpr.NIL), [], [])))
d3479 1
a3479 1
		MLWorks.Option.SOME tag, Sexpr.NIL), [], [])))
d3512 1
a3512 1
	        MLWorks.Option.SOME tag,
d3539 1
a3539 1
                                MLWorks.Option.NONE, Sexpr.NIL),
d3559 1
a3559 1
                       [],MLWorks.Option.NONE,Sexpr.NIL),
d3588 1
a3588 1
              ((Sexpr.ATOM new_code, [], MLWorks.Option.NONE, Sexpr.NIL),
d3605 1
a3605 1
	    MLWorks.Option.SOME zero_reg => (true, zero_reg)
d3632 1
a3632 1
        ((Sexpr.ATOM opcodes, [], MLWorks.Option.NONE, Sexpr.NIL), [], [])
d3664 1
a3664 1
    val opt_first_spill : RuntimeEnv.Offset ref list ref MLWorks.Option.option = 
d3666 1
a3666 1
        MLWorks.Option.SOME (ref ( [ref(RuntimeEnv.OFFSET1 1)]))
d3668 1
a3668 1
        MLWorks.Option.NONE
d3672 2
a3673 2
        MLWorks.Option.NONE => Crash.impossible "current_spills:mir_cg:mir_cg"
      | MLWorks.Option.SOME first_spill => !first_spill
d3678 2
a3679 2
        MLWorks.Option.NONE => (fn _ => ())
      | MLWorks.Option.SOME first_spill => 
d3689 2
a3690 2
        MLWorks.Option.NONE => []
      | MLWorks.Option.SOME first_spill => 
d3701 2
a3702 2
        MLWorks.Option.NONE => ()
      | MLWorks.Option.SOME first_spill => 
d3709 2
a3710 2
        MLWorks.Option.NONE => ()
      | MLWorks.Option.SOME first_spill => 
d3752 1
a3752 1
        MLWorks.Option.SOME x => x
d3797 1
a3797 1
      val make_str_order_tree = NewMap.from_list (String.<, op =)
d3865 1
a3865 1
	 Mir_Utils.combine(the_code,((Sexpr.ATOM more_code, [], MLWorks.Option.NONE,Sexpr.NIL),[], [])),
d3945 1
a3945 1
               of [] => ([], MLWorks.Option.NONE)
d3968 1
a3968 1
                          MLWorks.Option.NONE => ()
d3974 1
a3974 1
                       MLWorks.Option.SOME exn_tag)
d4002 1
a4002 1
               val extra_code = ((Sexpr.ATOM extra_code, [], MLWorks.Option.NONE,Sexpr.NIL), [], [])
d4060 1
a4060 1
                       MLWorks.Option.SOME test_tag, Sexpr.NIL)
d4071 1
a4071 1
                          [], MLWorks.Option.SOME final_tag,
d4303 1
a4303 1
         RuntimeEnv.BUILTIN => (code,MLWorks.Option.NONE,calls)
d4305 1
a4305 1
               MLWorks.Option.SOME calls',
d4344 1
a4344 1
          MLWorks.Option.SOME (ref debug_info) => debug_info
d4356 1
a4356 1
                  MLWorks.Option.NONE =>
d4358 1
a4358 1
                | MLWorks.Option.SOME offset =>
d4372 1
a4372 1
		     [],MLWorks.Option.NONE, Sexpr.NIL), [], [])),
d4375 1
a4375 1
                   else RuntimeEnv.VARINFO (name,info,MLWorks.Option.SOME(ref_slot)))
d4388 1
a4388 1
                    [],MLWorks.Option.NONE, Sexpr.NIL), [], [])),
d4391 1
a4391 1
                   else RuntimeEnv.VARINFO(name,info,MLWorks.Option.SOME(ref_slot)))
d4405 1
a4405 1
                      [],MLWorks.Option.NONE, Sexpr.NIL), [], [])),
d4408 1
a4408 1
                   else RuntimeEnv.VARINFO (name,info,MLWorks.Option.SOME(ref_slot)))
d4496 1
a4496 1
		((Sexpr.ATOM code, [], MLWorks.Option.NONE, Sexpr.NIL), [], []),
d4543 1
a4543 1
              RuntimeEnv.APP(runtime_env,runtime_env',MLWorks.Option.NONE)
d4653 1
a4653 1
	 Mir_Utils.combine(the_code, ((new_code, [], MLWorks.Option.NONE,
d4692 1
a4692 1
		MirTypes.COMMENT("Destructure tuple")], [], MLWorks.Option.NONE,
d4711 1
a4711 1
              Int.toString(Lists.length many) ^
d4759 2
a4760 2
            MLWorks.Option.NONE => false
          | MLWorks.Option.SOME _ => true
d4767 2
a4768 2
              MLWorks.Option.NONE => ([], end_tag, [], [],RuntimeEnv.EMPTY,spills,calls)
            | MLWorks.Option.SOME {lexp,size} =>
d4791 1
a4791 1
                          [],MLWorks.Option.NONE, Sexpr.NIL), [], [])
d4813 1
a4813 1
                                                          [],MLWorks.Option.NONE,Sexpr.NIL),
d4820 1
a4820 1
                      MLWorks.Option.NONE => 
d4823 1
a4823 1
                    | MLWorks.Option.SOME tag =>
d4853 1
a4853 1
                  val switch_cases = Lists.length tag_le_list
d4877 1
a4877 1
                               [],MLWorks.Option.NONE, Sexpr.NIL), [], []),code),
d4944 1
a4944 1
                ([(AugLambda.IMM_TAG (_,t1),_, tag)], MLWorks.Option.SOME _) =>
d4947 1
a4947 1
                (AugLambda.IMM_TAG (_,t2),_, tag')], MLWorks.Option.NONE) =>
d4995 2
a4996 2
                    MLWorks.Option.NONE => Crash.impossible "Missing switch info"
                  | MLWorks.Option.SOME {num_imms, num_vccs, ...} => (num_vccs, num_imms)
d5042 1
a5042 1
                             MLWorks.Option.NONE =>
d5129 1
a5129 1
                                          Int.toString(Lists.length many) ^
d5168 1
a5168 1
                   (arg_regs, MLWorks.Option.SOME the_reg, code, 
d5185 1
a5185 1
                                       ((Sexpr.ATOM (select_code),[],MLWorks.Option.NONE,Sexpr.NIL),
d5190 1
a5190 1
		    MLWorks.Option.SOME the_reg,
d5205 1
a5205 1
                                       ((Sexpr.ATOM [main_branch],[],MLWorks.Option.NONE,Sexpr.NIL),
d5208 1
a5208 1
		   (regs, MLWorks.Option.NONE, block, true,runtime_env,spills,calls)
d5229 1
a5229 1
                       MLWorks.Option.NONE =>
d5271 1
a5271 1
                           MLWorks.Option.NONE =>
d5274 1
a5274 1
                         | MLWorks.Option.SOME tag1 =>
d5310 1
a5310 1
                     MLWorks.Option.NONE,
d5330 1
a5330 1
		    (MLWorks.Option.SOME _, MLWorks.Option.SOME _) =>
d5335 1
a5335 1
		  | (MLWorks.Option.SOME _, MLWorks.Option.NONE) =>
d5337 1
a5337 1
		  | (_, MLWorks.Option.SOME _) =>
d5343 1
a5343 1
		    MLWorks.Option.NONE,
d5356 2
a5357 2
		       MLWorks.Option.SOME f => f (the_reg, scon, le, tag)
		     | MLWorks.Option.NONE => {test_code = Sexpr.NIL, test_clean = []}
d5363 1
a5363 1
			  MLWorks.Option.NONE =>
d5366 1
a5366 1
			       MLWorks.Option.SOME _ =>
d5383 1
a5383 1
                       MLWorks.Option.NONE =>
d5393 1
a5393 1
                          MLWorks.Option.NONE,
d5395 1
a5395 1
                     | MLWorks.Option.SOME tag'=>
d5408 1
a5408 1
                          MLWorks.Option.NONE,
d5434 2
a5435 2
		       MLWorks.Option.SOME x => x
		     | MLWorks.Option.NONE => Crash.impossible "Missing the_reg"
d5437 1
a5437 1
		   if Lists.length val_code_tags_list < 3 
d5454 1
a5454 1
				MLWorks.Option.SOME do_test
d5456 1
a5456 1
				MLWorks.Option.NONE,
d5465 2
a5466 2
                           MLWorks.Option.NONE => []
                         | MLWorks.Option.SOME _ =>
d5479 2
a5480 2
                     MLWorks.Option.NONE => []
                   | MLWorks.Option.SOME _ =>
d5513 2
a5514 2
		          of MLWorks.Option.NONE => false
			  |  MLWorks.Option.SOME sz =>
d5568 1
a5568 1
			  val len = Lists.length val_le_tags_list
d5584 1
a5584 1
			    MLWorks.Option.NONE =>
d5587 1
a5587 1
			  | MLWorks.Option.SOME _ =>
d5627 1
a5627 1
				  MLWorks.Option.SOME do_test, clean_code))
d5652 1
a5652 1
				  case String.substring(str_x, 0, 2)
d5667 1
a5667 1
				  case String.substring(str_x, 0, 2)
d5732 1
a5732 1
				   ((code, [], MLWorks.Option.NONE, Sexpr.NIL),
d5759 1
a5759 1
				MLWorks.Option.SOME do_test, clean_code))
d5769 2
a5770 2
		          of MLWorks.Option.NONE => false
			  |  MLWorks.Option.SOME sz =>
d5822 1
a5822 1
			  val len = Lists.length val_le_tags_list
d5838 1
a5838 1
			    MLWorks.Option.NONE =>
d5841 1
a5841 1
			  | MLWorks.Option.SOME _ =>
d5881 1
a5881 1
				  MLWorks.Option.SOME do_test, clean_code))
d5906 1
a5906 1
				  case String.substring(str_x, 0, 3)
d5921 1
a5921 1
				  case String.substring(str_x, 0, 3)
d5986 1
a5986 1
				   ((code, [], MLWorks.Option.NONE, Sexpr.NIL),
d6013 1
a6013 1
				MLWorks.Option.SOME do_test, clean_code))
d6025 1
a6025 1
				  (String.ord s, 0, code, tag)
d6033 1
a6033 1
			  val len = Lists.length val_le_tags_list
d6038 2
a6039 2
			    MLWorks.Option.NONE => [MirTypes.COMMENT"No default (strange for scon match)"]
			  | MLWorks.Option.SOME _ =>
d6063 1
a6063 1
						MLWorks.Option.SOME do_test,
d6120 2
a6121 2
                         Mir_Utils.combine(((Sexpr.NIL, [], MLWorks.Option.NONE, Sexpr.NIL), tags_code, []),
                                           do_chained_tests(the_reg, dflt, val_le_tags_list, MLWorks.Option.SOME do_test, [])))
d6161 1
a6161 1
                                              (_, ((app_code, [], MLWorks.Option.NONE, last), 
d6180 1
a6180 1
                                        2, MLWorks.Option.NONE),
d6215 2
a6216 2
                         Mir_Utils.combine(((Sexpr.NIL, [], MLWorks.Option.NONE, Sexpr.NIL), tags_code, []),
                                           do_chained_tests(the_reg, dflt, val_le_tags_list, MLWorks.Option.SOME do_test, [])))
d6242 1
a6242 1
                            ((code, [], MLWorks.Option.NONE, last), [], []),
d6262 1
a6262 1
                   ([], do_chained_tests(the_reg, dflt, val_le_tags_list, MLWorks.Option.SOME do_test, []))
d6285 1
a6285 1
		 (((Sexpr.NIL, [], MLWorks.Option.SOME main_tag,
d6292 1
a6292 1
		((Sexpr.NIL, dflt_blocks, MLWorks.Option.SOME end_tag, Sexpr.NIL),
d6331 1
a6331 1
      (Mir_Utils.ONE reg, ((Sexpr.ATOM code, [], MLWorks.Option.NONE,
d6377 1
a6377 1
	       of MLWorks.Option.NONE =>
d6380 1
a6380 1
	       |  MLWorks.Option.SOME sz =>
d6410 1
a6410 1
	       of MLWorks.Option.NONE =>
d6413 1
a6413 1
	       |  MLWorks.Option.SOME sz =>
d6443 1
a6443 1
		(String.ord s))),
d6457 1
a6457 1
	      MLWorks.Option.NONE, Sexpr.NIL),
d6483 1
a6483 1
         MLWorks.Option.NONE, Sexpr.NIL),
d6553 1
a6553 1
           [], MLWorks.Option.NONE, Sexpr.NIL)
d6578 1
a6578 1
            [], MLWorks.Option.NONE, Sexpr.NIL)
d6587 1
a6587 1
            then MLWorks.Option.SOME{gc = gc_spills+1, 
d6590 1
a6590 1
          else MLWorks.Option.NONE
d6601 2
a6602 2
					       old_spill_sizes = MLWorks.Option.NONE,
                                               stack_allocated = MLWorks.Option.NONE},
d6606 2
a6607 2
                            MLWorks.Option.NONE => []
                          | MLWorks.Option.SOME tag =>
d6614 1
a6614 1
         ((code, [], MLWorks.Option.NONE, Sexpr.NIL),
d6642 2
a6643 2
        (fn ((lvar, MLWorks.Option.SOME (ref (RuntimeEnv.VARINFO (name,ty,_)))),acc) => 
         (RuntimeEnv.VARINFO (name,ty,MLWorks.Option.NONE),RuntimeEnv.EMPTY) :: acc
d6648 1
a6648 1
      val funs = Lists.length lv_list
d6777 1
a6777 1
            [], MLWorks.Option.NONE, Sexpr.NIL), [], [])
d6802 1
a6802 1
           val entry_code = Mir_Utils.combine (((Sexpr.ATOM arg_copy, [], MLWorks.Option.NONE, Sexpr.NIL), [], []), code)
d6823 1
a6823 1
             MLWorks.Option.SOME offset => (index, offset)
d6860 1
a6860 1
               MLWorks.Option.SOME loop_tag,
d6904 1
a6904 1
	      [], MLWorks.Option.NONE, Sexpr.NIL), [], []))
d6925 1
a6925 1
              then MLWorks.Option.SOME{gc = gc_spills+1, 
d6928 1
a6928 1
            else MLWorks.Option.NONE
d6937 2
a6938 2
						old_spill_sizes = MLWorks.Option.NONE,
                                                stack_allocated = MLWorks.Option.NONE},
d6942 2
a6943 2
                             MLWorks.Option.NONE => []
                           | MLWorks.Option.SOME tag =>
d7018 1
a7018 1
                                              ((Sexpr.ATOM final_code, [], MLWorks.Option.NONE,
d7040 2
a7041 2
	  MLWorks.Option.SOME
	  (AugLambda.LET((lv', MLWorks.Option.NONE,
d7046 2
a7047 2
	       MLWorks.Option.SOME le =>
		 MLWorks.Option.SOME
d7052 1
a7052 1
	  | convert_handler le = MLWorks.Option.NONE
d7096 1
a7096 1
				    MLWorks.Option.NONE) ::
d7111 1
a7111 1
	  (MLWorks.Option.SOME new_la, true) =>
d7137 1
a7137 1
		   (((Sexpr.NIL, [], MLWorks.Option.SOME continue_tag,
d7147 1
a7147 1
		     [], MLWorks.Option.SOME end_tag, Sexpr.NIL), [], [])
d7155 1
a7155 1
				  ((Sexpr.ATOM frame_setup, [exn_common], MLWorks.Option.NONE,
d7169 1
a7169 1
				  ((Sexpr.ATOM main_end, [], MLWorks.Option.NONE,
d7196 1
a7196 1
				  ((Sexpr.ATOM frame_setup, [exn_common, exn_end], MLWorks.Option.NONE,
d7210 1
a7210 1
				  ((Sexpr.ATOM main_end, [], MLWorks.Option.SOME end_tag,
d7227 1
a7227 1
	Crash.impossible (String.implode ["cg_sub(BUILTIN): ",string, " should have been translated"])
d7295 2
a7296 2
	(MLWorks.Option.NONE, []) => (Sexpr.CONS (setup_entry, last''), blocks)
      | (MLWorks.Option.SOME tag,_) =>
d7299 1
a7299 1
      | (MLWorks.Option.NONE,_) =>
d7309 1
a7309 1
                                            MLWorks.Option.SOME{gc = gc_spills+1, 
d7313 3
a7315 3
                                            MLWorks.Option.NONE,
					  old_spill_sizes = MLWorks.Option.NONE,
					  stack_allocated = MLWorks.Option.NONE},
d7331 2
a7332 2
      fun get_opt MLWorks.Option.NONE = []
	| get_opt(MLWorks.Option.SOME tag) = [tag]
d7390 2
a7391 2
	    MLWorks.Option.SOME _ => process_blocks(old_block_map, new_block_map, tag_list)
	  | MLWorks.Option.NONE =>
d7393 1
a7393 1
		MLWorks.Option.SOME(block as BLOCK(_, opcodes)) =>
d7396 1
a7396 1
	      | MLWorks.Option.NONE =>
d7414 1
a7414 1
	    MLWorks.Option.NONE => 
d7416 1
a7416 1
	  | MLWorks.Option.SOME exit_block =>
@


1.297.2.1
log
@branched from 1.297
@
text
@a3 3
 * Revision 1.297  1996/09/26  14:00:33  matthew
 * Bytearray update is always integral
 *
@


1.297.1.1
log
@branched from 1.297
@
text
@a3 3
 * Revision 1.297  1996/09/26  14:00:33  matthew
 * Bytearray update is always integral
 *
@


1.296
log
@Always add end_blocks to result in make_cgt
@
text
@d4 3
d4246 2
a4247 2
      | Pervasives.BYTEARRAY_UPDATE => update_code (true, true,TypeUtils.is_integral3 primTy,regs,the_code,exn_code_for_prim prim)
      | Pervasives.BYTEARRAY_UNSAFE_UPDATE => update_code (true, false,TypeUtils.is_integral3 primTy,regs,the_code,exn_code_for_prim prim)
@


1.295
log
@[Bug #1521]
propagating changes made to lambda/_auglambda.sml (and ultimately
to typechecker/_types.sml).
@
text
@d4 5
d5302 1
a5302 4
                       (if is_rel orelse low = 0 then
			  body
			else
			  end_blocks :: body, []),
@


1.295.1.1
log
@branched from 1.295
@
text
@a3 5
 * Revision 1.295  1996/08/06  12:28:12  andreww
 * [Bug #1521]
 * propagating changes made to lambda/_auglambda.sml (and ultimately
 * to typechecker/_types.sml).
 *
@


1.295.1.2
log
@Always add end_blocks in computed gotos
@
text
@a3 3
 * Revision 1.295.1.1  1996/09/13  11:14:19  hope
 * branched from 1.295
 *
d5302 4
a5305 1
                       (end_blocks :: body, []),
@


1.294
log
@Changed type of word32 shift operarators
@
text
@d4 3
d1100 1
d3627 1
a3627 1
      (Options.OPTIONS {compiler_options =
d3764 1
a3764 1
      AugLambda.count_gc_objects (new_lambda_exp,
@


1.293
log
@Adding NOT32 MIR instruction
@
text
@d4 3
d1578 22
a1996 1

d2016 3
d2020 1
a2020 1
	  val (val1, val2, arg_code, clean_arg_code) = get_word32_pair regs
d2023 20
a2042 8
	    MirTypes.ALLOCATE
	      (MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT 4)
	    :: arg_code
            @@ [MirTypes.BINARY(mir_operator, tmp2, val1, val2),
	       MirTypes.STOREOP
	         (MirTypes.ST, tmp2, res2, MirTypes.GP_IMM_ANY ~1),
	       MirTypes.NULLARY(MirTypes.CLEAN, tmp2)]
	    @@ clean_arg_code
@


1.292
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d3524 1
a3524 1
	    @@ [MirTypes.UNARY (MirTypes.NOT, tmp2, new_reg),
@


1.291
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@@


1.290
log
@Removing MLWorks.Integer
@
text
@d4 3
d1143 1
a1143 1
  fun lprint s = output (std_out,s ^ "\n")
d5967 1
a5967 1
				  (ord s, 0, code, tag)
d6385 1
a6385 1
		(ord s))),
d7169 1
a7169 1
	Crash.impossible (implode ["cg_sub(BUILTIN): ",string, " should have been translated"])
@


1.289
log
@Removed some exceptions
@
text
@d4 3
d1038 2
d3850 1
a3850 1
		 "In cg_sub(APP), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d4264 1
a4264 1
		 "In cg_sub(LET), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d4361 1
a4361 1
		 "After spilling fp, fp_spills = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d4377 1
a4377 1
		 "After let body, fp_spills = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d4413 1
a4413 1
		 "In cg_sub(APP), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d4538 1
a4538 1
		 "In cg_sub(STRUCT), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d4605 1
a4605 1
		 "In cg_sub(SELECT), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d4646 3
a4648 3
              MLWorks.Integer.makestring index ^ " from list size " ^
              MLWorks.Integer.makestring(Lists.length many) ^
              " with struct size " ^ MLWorks.Integer.makestring size ^ "\n"))
d4662 1
a4662 1
		 "In cg_sub(SWITCH), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d4812 1
a4812 1
                                                                                 MLWorks.Integer.makestring switch_case))))], 
d4863 1
a4863 1
			 "maximum_spills = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d5065 1
a5065 1
                                          MLWorks.Integer.makestring(Lists.length many) ^
d5461 1
a5461 1
				 ^ MLWorks.Integer.makestring sz)
d5717 1
a5717 1
				 ^ MLWorks.Integer.makestring sz)
d6241 1
a6241 1
			   "After cg_sub(SWITCH), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d6261 1
a6261 1
		 "In cg_sub(VAR), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d6266 1
a6266 1
	LambdaPrint.string_of_lambda arg, " funs_in_closure = " ^ MLWorks.Integer.makestring funs_in_closure ^ "\n"])
d6282 1
a6282 1
		 "In cg_sub(INT), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d6302 1
a6302 1
		 "In cg_sub(SCON), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d6328 1
a6328 1
		     ("unknown int size " ^ MLWorks.Integer.makestring sz)
d6361 1
a6361 1
		     ("unknown word size " ^ MLWorks.Integer.makestring sz)
d6410 1
a6410 1
		 "In cg_sub(MLVALUE), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d6440 1
a6440 1
		 "In cg_sub(FN), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d6570 1
a6570 1
		 "In cg_sub(LETREC), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
d6940 1
a6940 1
		 "In cg_sub(RAISE), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
@


1.288
log
@Adding where type clause
@
text
@d4 3
a4029 1
      | Pervasives.EXABS => Crash.impossible"APP of non-function"
a4032 7
      | Pervasives.EXMOD => Crash.impossible"APP of non-function"
      | Pervasives.EXQUOT => Crash.impossible"APP of non-function"
      | Pervasives.EXPROD => Crash.impossible"APP of non-function"
      | Pervasives.EXNEG => Crash.impossible"APP of non-function"
      | Pervasives.EXSUM => Crash.impossible"APP of non-function"
      | Pervasives.EXDIFF => Crash.impossible"APP of non-function"
      | Pervasives.EXFLOOR => Crash.impossible"APP of non-function"
d4040 1
a4041 1
      | Pervasives.EXOVERFLOW => Crash.impossible"APP of non-function"
@


1.287
log
@Change for value polymorphism
@
text
@d4 3
d1055 1
a1089 1
  sharing type LambdaPrint.LambdaTypes.LVar = int
d1101 1
@


1.286
log
@Recode integer 32 bit overflow detecting operations in terms of ADDW
@
text
@d4 3
d1454 1
a1454 1
            val add_members = IntMap.fold (fn (set, x,_) => HashSet.add_member(set, x))
@


1.285
log
@Fix problems with abs of positive int32
@
text
@d4 3
d3413 1
a3413 1
	  val opcode = MirTypes.SUBV
d4094 1
a4094 1
	  int32_binary_calc (MirTypes.ADDV,regs,the_code,exn_code_for_prim prim)
d4096 1
a4096 1
	  int32_binary_calc (MirTypes.SUBV,regs,the_code,exn_code_for_prim prim)
d4098 1
a4098 1
	  int32_binary_calc (MirTypes.MULV,regs,the_code,exn_code_for_prim prim)
d4100 1
a4100 1
	  int32_binary_calc (MirTypes.DIVV,regs,the_code,exn_code_for_prim prim)
d4102 1
a4102 1
	  int32_binary_calc (MirTypes.MODV,regs,the_code,exn_code_for_prim prim)
d4104 1
a4104 1
     	  int32_unary_negate(MirTypes.SUBV,regs,the_code,exn_code_for_prim prim)
@


1.284
log
@Fix code generation of unary negate for int32
@
text
@d4 3
d3417 1
a3417 1
	    [MirTypes.UNARY(MirTypes.MOVE, res2, w),
@


1.283
log
@Add warning comments to polymorphic equality about mips implementation
@
text
@d4 3
d1565 1
d1580 3
a1582 1
	       (opcode, exn_tag_opt, res2, MirTypes.GP_IMM_INT 0, w)]
d1584 1
a1584 1
	  (Mir_Utils.ONE(Mir_Utils.INT res1),
d1587 2
a1588 2
              ((Sexpr.ATOM new_code, exn_blocks,
		MLWorks.Option.NONE, Sexpr.ATOM clean_arg),
d1591 1
a1591 1
      |   int32_unary_negate _ = Crash.impossible "int32_unary_negate"
d3410 2
a3411 1

d3413 8
a3420 7
	    arg_code
	    @@ [MirTypes.UNARY(MirTypes.MOVE, res2, w),
	       MirTypes.TEST(MirTypes.BGE, tag, w, MirTypes.GP_IMM_INT 0),
	       MirTypes.TBINARY
		 (opcode, exn_tag_opt, res2, MirTypes.GP_IMM_INT 0, w),
               MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag)]
	    @@ clean_arg_code
d3431 1
a3431 1
      |    do_int32abs _ = Crash.impossible "do_int32abs"
d3517 8
d3526 19
a3544 7
        [MirTypes.ALLOCATE
          (MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT (size div 8)),
	 MirTypes.UNARY
	   (MirTypes.MOVE, MirTypes.GC_REG tmp, MirTypes.GP_IMM_ANY w),
	 MirTypes.STOREOP
	   (MirTypes.ST, MirTypes.GC_REG tmp, res2, MirTypes.GP_IMM_ANY ~1),
	 MirTypes.NULLARY(MirTypes.CLEAN, MirTypes.GC_REG tmp)]
@


1.282
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d3927 8
@


1.281
log
@Remove references to option structure
in favour of MLWorks.Option
@
text
@d4 4
a1067 2
  sharing MirPrint.MirTypes.Debugger_Types.RuntimeEnv.Option = 
    TypeUtils.Datatypes.Option
d4187 1
a4187 1
         RuntimeEnv.BUILTIN => (code,RuntimeEnv.Option.ABSENT,calls)
d4189 1
a4189 1
               RuntimeEnv.Option.PRESENT calls',
d4240 1
a4240 1
                  RuntimeEnv.Option.ABSENT =>
d4242 1
a4242 1
                | RuntimeEnv.Option.PRESENT offset =>
d4259 1
a4259 1
                   else RuntimeEnv.VARINFO (name,info,RuntimeEnv.Option.PRESENT(ref_slot)))
d4275 1
a4275 1
                   else RuntimeEnv.VARINFO(name,info,RuntimeEnv.Option.PRESENT(ref_slot)))
d4292 1
a4292 1
                   else RuntimeEnv.VARINFO (name,info,RuntimeEnv.Option.PRESENT(ref_slot)))
d4427 1
a4427 1
              RuntimeEnv.APP(runtime_env,runtime_env',RuntimeEnv.Option.ABSENT)
d6530 1
a6530 1
         (RuntimeEnv.VARINFO (name,ty,RuntimeEnv.Option.ABSENT),RuntimeEnv.EMPTY) :: acc
@


1.280
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d4 4
d1064 1
a1064 1
  sharing MirPrint.MirTypes.Debugger_Types.RuntimeEnv.Option = LambdaPrint.LambdaTypes.Option = 
a1107 1
  structure Option = LambdaTypes.Option
d3546 1
a3546 1
    val opt_first_spill : RuntimeEnv.Offset ref list ref Option.opt = 
d3548 1
a3548 1
        Option.PRESENT (ref ( [ref(RuntimeEnv.OFFSET1 1)]))
d3550 1
a3550 1
        Option.ABSENT
d3554 2
a3555 2
        Option.ABSENT => Crash.impossible "current_spills:mir_cg:mir_cg"
      | Option.PRESENT first_spill => !first_spill
d3560 2
a3561 2
        Option.ABSENT => (fn _ => ())
      | Option.PRESENT first_spill => 
d3571 2
a3572 2
        Option.ABSENT => []
      | Option.PRESENT first_spill => 
d3583 2
a3584 2
        Option.ABSENT => ()
      | Option.PRESENT first_spill => 
d3591 2
a3592 2
        Option.ABSENT => ()
      | Option.PRESENT first_spill => 
d4185 1
a4185 1
         RuntimeEnv.BUILTIN => (code,Option.ABSENT,calls)
d4187 1
a4187 1
               Option.PRESENT calls',
d4238 1
a4238 1
                  Option.ABSENT =>
d4240 1
a4240 1
                | Option.PRESENT offset =>
d4257 1
a4257 1
                   else RuntimeEnv.VARINFO (name,info,Option.PRESENT(ref_slot)))
d4273 1
a4273 1
                   else RuntimeEnv.VARINFO(name,info,Option.PRESENT(ref_slot)))
d4290 1
a4290 1
                   else RuntimeEnv.VARINFO (name,info,Option.PRESENT(ref_slot)))
d4425 1
a4425 1
              RuntimeEnv.APP(runtime_env,runtime_env',Option.ABSENT)
d6528 1
a6528 1
         (RuntimeEnv.VARINFO (name,ty,Option.ABSENT),RuntimeEnv.EMPTY) :: acc
@


1.279
log
@Simplifying lambdatypes
@
text
@d4 3
d1061 1
a1061 1
    TypeUtils.Datatypes.Option = MirPrint.MirTypes.Option
d1143 1
a1143 1
  val no_code = ((Sexpr.NIL, [], Option.ABSENT, Sexpr.NIL), [], [])
d1464 1
a1464 1
               [], Option.ABSENT, Sexpr.NIL), [], []),
d1480 1
a1480 1
                [],Option.ABSENT, Sexpr.NIL),[],[]),
d1547 1
a1547 1
                                   Option.ABSENT, Sexpr.NIL), [], [])))
d1574 1
a1574 1
		Option.ABSENT, Sexpr.ATOM clean_arg),
d1590 1
a1590 1
                              exn_blocks, Option.ABSENT, Sexpr.NIL), [], [])))
d1608 1
a1608 1
                                   [], Option.ABSENT, Sexpr.NIL), [], [])))
d1627 1
a1627 1
		  exn_blocks, Option.ABSENT, Sexpr.NIL), [], [])))
d1650 1
a1650 1
                             [], Option.PRESENT finish_tag, Sexpr.NIL), [], [])))
d1670 1
a1670 1
              ((Sexpr.ATOM new_code, [], Option.PRESENT finish_tag,
d1684 1
a1684 1
                               [], Option.PRESENT false_tag, Sexpr.NIL), [], []))
d1696 1
a1696 1
                               [], Option.PRESENT false_tag, Sexpr.NIL), [], []))
d1766 1
a1766 1
                 [], Option.PRESENT finish_tag, Sexpr.NIL), [], [])))
d1811 1
a1811 1
                                exn_blocks, Option.ABSENT, Sexpr.NIL), [], [])))
d1827 1
a1827 1
                                exn_blocks, Option.ABSENT, Sexpr.NIL), [], [])))
d1857 1
a1857 1
	      ((Sexpr.ATOM new_code, exn_blocks, Option.ABSENT, Sexpr.NIL),
d1872 1
a1872 1
	      [], Option.ABSENT, Sexpr.NIL), [], [])))
d1899 1
a1899 1
	      ((Sexpr.ATOM new_code, [], Option.ABSENT, Sexpr.NIL), [], [])))
d1939 1
a1939 1
			       [],Option.ABSENT,Sexpr.NIL),[],[])))
d1964 1
a1964 1
	      ((Sexpr.ATOM new_code, [],Option.ABSENT,Sexpr.NIL),
d2013 1
a2013 1
              Option.PRESENT tag => tag
d2107 1
a2107 1
              Option.PRESENT finish_tag, 
d2183 1
a2183 1
            Option.PRESENT finish_tag, 
d2212 1
a2212 1
              Option.ABSENT, 
d2247 1
a2247 1
            Option.ABSENT, 
d2277 1
a2277 1
                   [], Option.ABSENT, Sexpr.NIL), [], [])))
d2307 1
a2307 1
                   [], Option.ABSENT, Sexpr.NIL), [], [])))
d2352 1
a2352 1
	        of Option.PRESENT tag => tag
d2435 1
a2435 1
                  exn_blocks, Option.PRESENT finish_tag, Sexpr.NIL), [], [])))
d2462 1
a2462 1
              [], Option.ABSENT, Sexpr.NIL), [], [])))
d2505 1
a2505 1
		  of Option.PRESENT tag => tag
d2568 1
a2568 1
		  exn_blocks, Option.PRESENT finish_tag, Sexpr.NIL), [], [])))
d2590 1
a2590 1
                [], Option.ABSENT, Sexpr.NIL), [], [])))
d2651 1
a2651 1
	            of Option.PRESENT tag => tag
d2800 1
a2800 1
                 Option.PRESENT finish_tag, 
d2864 1
a2864 1
              Option.ABSENT, 
d2936 1
a2936 1
              Option.ABSENT, 
d2964 1
a2964 1
				 Option.ABSENT, Sexpr.NIL), [], [])))
d2989 1
a2989 1
                             [], Option.ABSENT, Sexpr.NIL), [], [])))
d3022 1
a3022 1
				 Option.ABSENT, Sexpr.NIL), [], [])))
d3105 1
a3105 1
                       Option.PRESENT already_on_ref_chain_tag, 
d3123 1
a3123 1
		  [], Option.ABSENT, Sexpr.NIL), [], [])))
d3135 1
a3135 1
	      of Option.PRESENT tag => tag
d3154 1
a3154 1
		  exn_blocks, Option.ABSENT, Sexpr.NIL), [], [])))
d3174 1
a3174 1
		  [], Option.ABSENT, Sexpr.NIL), [], [])))
d3183 1
a3183 1
			     ((Sexpr.ATOM code, [], Option.ABSENT,
d3194 1
a3194 1
	    of Option.PRESENT tag => tag
d3212 1
a3212 1
		Option.ABSENT, Sexpr.NIL), [], [])))
d3225 1
a3225 1
	    of Option.PRESENT tag => tag
d3252 1
a3252 1
		Option.ABSENT, Sexpr.NIL), [], [])))
d3266 1
a3266 1
	    of Option.PRESENT tag => tag
d3277 1
a3277 1
		     exn_blocks, Option.ABSENT, Sexpr.NIL), [], [])))
d3297 1
a3297 1
                    of Option.PRESENT tag => tag
d3304 1
a3304 1
                                       exn_blocks, Option.ABSENT, Sexpr.NIL),
d3335 1
a3335 1
                                       exn_blocks, Option.ABSENT, Sexpr.NIL), [], [])))
d3359 1
a3359 1
                                   [], Option.ABSENT, Sexpr.NIL), [], [])))
d3380 1
a3380 1
		Option.PRESENT tag, Sexpr.NIL), [], [])))
d3411 1
a3411 1
	        Option.PRESENT tag,
d3438 1
a3438 1
                                Option.ABSENT, Sexpr.NIL),
d3458 1
a3458 1
                       [],Option.ABSENT,Sexpr.NIL),
d3487 1
a3487 1
              ((Sexpr.ATOM new_code, [], Option.ABSENT, Sexpr.NIL),
d3511 1
a3511 1
        ((Sexpr.ATOM opcodes, [], Option.ABSENT, Sexpr.NIL), [], [])
d3744 1
a3744 1
	 Mir_Utils.combine(the_code,((Sexpr.ATOM more_code, [], Option.ABSENT,Sexpr.NIL),[], [])),
d3824 1
a3824 1
               of [] => ([], Option.ABSENT)
d3847 1
a3847 1
                          Option.ABSENT => ()
d3853 1
a3853 1
                       Option.PRESENT exn_tag)
d3881 1
a3881 1
               val extra_code = ((Sexpr.ATOM extra_code, [], Option.ABSENT,Sexpr.NIL), [], [])
d3931 1
a3931 1
                       Option.PRESENT test_tag, Sexpr.NIL)
d3942 1
a3942 1
                          [], Option.PRESENT final_tag,
d4251 1
a4251 1
		     [],Option.ABSENT, Sexpr.NIL), [], [])),
d4267 1
a4267 1
                    [],Option.ABSENT, Sexpr.NIL), [], [])),
d4284 1
a4284 1
                      [],Option.ABSENT, Sexpr.NIL), [], [])),
d4375 1
a4375 1
		((Sexpr.ATOM code, [], Option.ABSENT, Sexpr.NIL), [], []),
d4532 1
a4532 1
	 Mir_Utils.combine(the_code, ((new_code, [], Option.ABSENT,
d4571 1
a4571 1
		MirTypes.COMMENT("Destructure tuple")], [], Option.ABSENT,
d4670 1
a4670 1
                          [],Option.ABSENT, Sexpr.NIL), [], [])
d4692 1
a4692 1
                                                          [],Option.ABSENT,Sexpr.NIL),
d4699 1
a4699 1
                      Option.ABSENT => 
d4702 1
a4702 1
                    | Option.PRESENT tag =>
d4756 1
a4756 1
                               [],Option.ABSENT, Sexpr.NIL), [], []),code),
d5047 1
a5047 1
                   (arg_regs, Option.PRESENT the_reg, code, 
d5064 1
a5064 1
                                       ((Sexpr.ATOM (select_code),[],Option.ABSENT,Sexpr.NIL),
d5069 1
a5069 1
		    Option.PRESENT the_reg,
d5084 1
a5084 1
                                       ((Sexpr.ATOM [main_branch],[],Option.ABSENT,Sexpr.NIL),
d5087 1
a5087 1
		   (regs, Option.ABSENT, block, true,runtime_env,spills,calls)
d5150 1
a5150 1
                           Option.ABSENT =>
d5153 1
a5153 1
                         | Option.PRESENT tag1 =>
d5192 1
a5192 1
                     Option.ABSENT,
d5212 1
a5212 1
		    (MLWorks.Option.SOME _, Option.PRESENT _) =>
d5217 1
a5217 1
		  | (MLWorks.Option.SOME _, Option.ABSENT) =>
d5219 1
a5219 1
		  | (_, Option.PRESENT _) =>
d5225 1
a5225 1
		    Option.ABSENT,
d5238 2
a5239 2
		       Option.PRESENT f => f (the_reg, scon, le, tag)
		     | Option.ABSENT => {test_code = Sexpr.NIL, test_clean = []}
d5248 1
a5248 1
			       Option.PRESENT _ =>
d5265 1
a5265 1
                       Option.ABSENT =>
d5275 1
a5275 1
                          Option.ABSENT,
d5277 1
a5277 1
                     | Option.PRESENT tag'=>
d5290 1
a5290 1
                          Option.ABSENT,
d5316 2
a5317 2
		       Option.PRESENT x => x
		     | Option.ABSENT => Crash.impossible "Missing the_reg"
d5336 1
a5336 1
				Option.PRESENT do_test
d5338 1
a5338 1
				Option.ABSENT,
d5509 1
a5509 1
				  Option.PRESENT do_test, clean_code))
d5614 1
a5614 1
				   ((code, [], Option.ABSENT, Sexpr.NIL),
d5641 1
a5641 1
				Option.PRESENT do_test, clean_code))
d5763 1
a5763 1
				  Option.PRESENT do_test, clean_code))
d5868 1
a5868 1
				   ((code, [], Option.ABSENT, Sexpr.NIL),
d5895 1
a5895 1
				Option.PRESENT do_test, clean_code))
d5945 1
a5945 1
						Option.PRESENT do_test,
d6002 2
a6003 2
                         Mir_Utils.combine(((Sexpr.NIL, [], Option.ABSENT, Sexpr.NIL), tags_code, []),
                                           do_chained_tests(the_reg, dflt, val_le_tags_list, Option.PRESENT do_test, [])))
d6043 1
a6043 1
                                              (_, ((app_code, [], Option.ABSENT, last), 
d6062 1
a6062 1
                                        2, Option.ABSENT),
d6097 2
a6098 2
                         Mir_Utils.combine(((Sexpr.NIL, [], Option.ABSENT, Sexpr.NIL), tags_code, []),
                                           do_chained_tests(the_reg, dflt, val_le_tags_list, Option.PRESENT do_test, [])))
d6124 1
a6124 1
                            ((code, [], Option.ABSENT, last), [], []),
d6144 1
a6144 1
                   ([], do_chained_tests(the_reg, dflt, val_le_tags_list, Option.PRESENT do_test, []))
d6167 1
a6167 1
		 (((Sexpr.NIL, [], Option.PRESENT main_tag,
d6174 1
a6174 1
		((Sexpr.NIL, dflt_blocks, Option.PRESENT end_tag, Sexpr.NIL),
d6213 1
a6213 1
      (Mir_Utils.ONE reg, ((Sexpr.ATOM code, [], Option.ABSENT,
d6339 1
a6339 1
	      Option.ABSENT, Sexpr.NIL),
d6365 1
a6365 1
         Option.ABSENT, Sexpr.NIL),
d6435 1
a6435 1
           [], Option.ABSENT, Sexpr.NIL)
d6460 1
a6460 1
            [], Option.ABSENT, Sexpr.NIL)
d6469 1
a6469 1
            then Option.PRESENT{gc = gc_spills+1, 
d6472 1
a6472 1
          else Option.ABSENT
d6483 2
a6484 1
                                               stack_allocated = Option.ABSENT},
d6488 2
a6489 2
                            Option.ABSENT => []
                          | Option.PRESENT tag =>
d6496 1
a6496 1
         ((code, [], Option.ABSENT, Sexpr.NIL),
d6659 1
a6659 1
            [], Option.ABSENT, Sexpr.NIL), [], [])
d6684 1
a6684 1
           val entry_code = Mir_Utils.combine (((Sexpr.ATOM arg_copy, [], Option.ABSENT, Sexpr.NIL), [], []), code)
d6742 1
a6742 1
               Option.PRESENT loop_tag,
d6786 1
a6786 1
	      [], Option.ABSENT, Sexpr.NIL), [], []))
d6807 1
a6807 1
              then Option.PRESENT{gc = gc_spills+1, 
d6810 1
a6810 1
            else Option.ABSENT
d6819 2
a6820 1
                                                stack_allocated = Option.ABSENT},
d6824 2
a6825 2
                             Option.ABSENT => []
                           | Option.PRESENT tag =>
d6900 1
a6900 1
                                              ((Sexpr.ATOM final_code, [], Option.ABSENT,
d6978 1
a6978 1
				    Option.ABSENT) ::
d7019 1
a7019 1
		   (((Sexpr.NIL, [], Option.PRESENT continue_tag,
d7029 1
a7029 1
		     [], Option.PRESENT end_tag, Sexpr.NIL), [], [])
d7037 1
a7037 1
				  ((Sexpr.ATOM frame_setup, [exn_common], Option.ABSENT,
d7051 1
a7051 1
				  ((Sexpr.ATOM main_end, [], Option.ABSENT,
d7078 1
a7078 1
				  ((Sexpr.ATOM frame_setup, [exn_common, exn_end], Option.ABSENT,
d7092 1
a7092 1
				  ((Sexpr.ATOM main_end, [], Option.PRESENT end_tag,
d7177 2
a7178 2
	(Option.ABSENT, []) => (Sexpr.CONS (setup_entry, last''), blocks)
      | (Option.PRESENT tag,_) =>
d7181 1
a7181 1
      | (Option.ABSENT,_) =>
d7191 1
a7191 1
                                            Option.PRESENT{gc = gc_spills+1, 
d7195 3
a7197 2
                                            Option.ABSENT,
					  stack_allocated = Option.ABSENT},
d7213 2
a7214 2
      fun get_opt Option.ABSENT = []
	| get_opt(Option.PRESENT tag) = [tag]
d7296 1
a7296 1
	    Option.ABSENT => 
d7298 1
a7298 1
	  | Option.PRESENT exit_block =>
@


1.278
log
@Disallow handler optimisation when debug_variables is set
@
text
@d4 3
d1061 2
d1095 1
a1095 1
    val hash = LambdaTypes.int_of_LVar
d1431 1
a1431 1
            val add_members = LambdaTypes.Map.fold (fn (set, x,_) => HashSet.add_member(set, x))
d3627 1
a3627 1
      case LambdaTypes.Map.tryApply' (escape_map,fvar) of
d3632 1
a3632 1
    val top_lambdas = LambdaTypes.Map.domain escape_map
d3637 1
a3637 1
      LambdaTypes.Map.apply
d3640 2
a3641 2
	LambdaTypes.Map.define(tree, lv, MirTypes.new_tag()))
       (LambdaTypes.Map.empty, top_lambdas))
@


1.277
log
@Modify NONE in handler case to allow compilation under NJ
@
text
@d4 3
d6981 2
a6982 1
	case (convert_handler le', opt_handlers andalso gc_objects_in_le' = 1) of
d7047 1
a7047 4
	       if variable_debug then 
		 RuntimeEnv.HANDLE(runtime_env',ref_slot,calls',calls,runtime_env)
	       else
		 RuntimeEnv.EMPTY,spills,calls)
@


1.276
log
@Adding code to optimise compilation of handlers
@
text
@d4 3
d7048 1
a7048 1
	| (NONE, _) =>
@


1.275
log
@Fix problems with spill counting during switch arms
@
text
@d4 3
d3510 1
d6895 3
a6897 3
    | cg_sub(AugLambda.HANDLE
	     ({lexp=le, size=gc_objects_in_le}, {lexp=le', ...}),
	       env, static_offset,start_at,_,
d6899 75
a6973 55
    let
(*
      val _ =
	let
	  val (_, _, fp_spills) = spills
	in
	  output(std_out, 
		 "In cg_sub(HANDLE), fp_spill = " ^ MLWorks.Integer.makestring fp_spills ^ "\n")
	end
*)
      val end_tag = MirTypes.new_tag() (* The end of the code we'll generate *)
      val common_tag = MirTypes.new_tag() (* Some common handler restoration stuff *)
      val continue_tag = MirTypes.new_tag() (* Where a taken handler returns to *)
      val handler_frame_reg = MirTypes.GC.new()
      val handler_frame = MirTypes.GC_REG handler_frame_reg

      (* Allocate a new gc_spill *)
      val (gc_spills,non_gc_spills,fp_spills) = spills
      val slot = gc_spills+1
      val spills = (gc_spills+1,non_gc_spills,fp_spills)
      val ref_slot = new_ref_slot slot

      val (exn_result_reg, (* Pointer to closure of handler *)
	   exn_code as ((exn_f, exn_b, exn_o, exn_l), 
                        exn_vals, exn_procs),runtime_env,spills,calls') =
	cg_sub(le', env,
	       static_offset + gc_objects_in_le,start_at + gc_objects_in_le,false,
               (closure,funs_in_closure, fn_tag_list,tuple_bindings),spills,calls)
      val result_reg = MirTypes.GC.new()
      val frame_size = (*length frame_setup*)4
      val exn_common = (* Common between exceptional and normal route *)
	MirTypes.BLOCK
	(common_tag,
	 [MirTypes.OLD_HANDLER,
	  MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, frame_size),
	  MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG end_tag)])
      val exn_end =
	MirTypes.BLOCK
	(continue_tag,
	 Mir_Utils.send_to_given_reg(Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG caller_arg)),
			   result_reg) @@
	 [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG common_tag)])
      (* Handler record layout *)
      (* Offset Name *)
      (* 0      previous handler record *)
      (* 1      stack pointer (machine stack) *)
      (* 2	handler closure pointer *)
      (* 3	offset from procedure start of continuation point (GC safe) *)
      local
	val offset_reg = MirTypes.GC.new()
	val offset = MirTypes.GC_REG offset_reg
	val gp_offset = MirTypes.GP_GC_REG offset_reg
	val exn_result_reg = case exn_result_reg of
	  Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG reg)) => MirTypes.GC_REG reg
	| _ => Crash.impossible"Exn_result_reg"
d6975 42
a7016 24
	val frame_setup =
	  [(*MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG handler,
			    handler_frame, MirTypes.GP_IMM_ANY ~1),*)
           MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG sp, handler_frame,
                          MirTypes.GP_IMM_ANY 3),
           MirTypes.STOREOP(MirTypes.ST, exn_result_reg,
			    handler_frame, MirTypes.GP_IMM_ANY 7),
           MirTypes.STOREOP(MirTypes.ST, offset, handler_frame,
                            MirTypes.GP_IMM_ANY 11)]
	val frame_setup =
	  MirTypes.ALLOCATE_STACK(MirTypes.ALLOC,
				  handler_frame,
				  frame_size,
				  Option.ABSENT) ::
	  MirTypes.ADR(MirTypes.LEO, offset, continue_tag) ::
	  MirTypes.COMMENT "Calculate offset of continuation code" ::
	  MirTypes.BINARY(MirTypes.ASL, offset, gp_offset, MirTypes.GP_IMM_ANY 2) ::
	  MirTypes.COMMENT "Ensire it's tagged" ::
	  MirTypes.NEW_HANDLER(handler_frame, continue_tag) ::
	  frame_setup @@
	  [(*MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG handler,
			    MirTypes.GP_GC_REG handler_frame_reg),*)
	   MirTypes.COMMENT"Set up new handler pointer"]
        end
d7018 72
a7089 27
      val exn_whole =
	Mir_Utils.combine(exn_code,
		((Sexpr.ATOM frame_setup, [exn_common, exn_end], Option.ABSENT,
		  Sexpr.NIL), [], []))
      val restore_spills = spill_restorer()
      (* This is the only call to append_spill *)
      val _ = append_spill ref_slot
      val (main_reg, main_code,runtime_env',spills,calls) =
	cg_sub(le, env, static_offset, start_at, false,
               (closure,funs_in_closure,fn_tag_list,tuple_bindings),spills,calls')
      val _ = restore_spills()
      val main_end =
	Mir_Utils.send_to_given_reg(main_reg, result_reg) @@
	[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG common_tag)]
      val main_whole =
	Mir_Utils.combine(main_code,
		((Sexpr.ATOM main_end, [], Option.PRESENT end_tag,
		  Sexpr.NIL), [], []))
      val total_code =
	Mir_Utils.combine(exn_whole, main_whole)
    in
      (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result_reg)), total_code,
       if variable_debug then 
         RuntimeEnv.HANDLE(runtime_env',ref_slot,calls',calls,runtime_env)
       else
         RuntimeEnv.EMPTY,spills,calls)
    end
d7276 1
a7276 1
    fun sort_out_small_exit_blocks(MirTypes.PROC(name,tag, params, blocks,runtime_env)) =
@


1.274
log
@Added types for different lengths of words, ints and reals.
@
text
@d4 3
a1250 1
            (* val _ = output (std_out,"Doing do_loads\n") *)
a3586 1
          (* val _ = if Lists.length current_spills > 1 then output (std_out,"Multiple spills\n") else () *)
d3771 7
d4185 7
d4276 15
d4295 12
d4332 9
d4459 7
d4526 7
d4581 9
d4765 1
d4770 1
a4770 1
              fp_spills >= fp_spills
d4774 9
a4782 3
              (fn (max_spill,spill) => 
               if order (max_spill,spill) then max_spill else spill)
              ((0,0,0),(spills'::spills))
d4785 6
d6161 8
d6182 7
d6203 7
d6222 7
d6329 9
d6359 9
d6490 7
d6857 9
d6896 10
a6905 1
      val end_tag = MirTypes.new_tag() (* The aend of the code we'll generate *)
@


1.273
log
@Improved array and vector bounds checking
@
text
@d4 3
d178 1
a178 1
Handled Bignum.Unrepresentable where necessary.
d1018 1
d1056 1
d1127 2
a1128 2
  fun count_gc_tags(AugLambda.SCON_TAG(Ident.REAL _)) = 1
    | count_gc_tags(AugLambda.SCON_TAG(Ident.STRING _)) = 1
d1133 4
d1174 1
a1174 1
  and bandf_opt(vars, Option.PRESENT le) = new_frees (vars, le)
d1306 1
a1306 1
    | AugLambda.SCON_TAG(tag) => 
d1356 1
a1356 1
        ((lv,Option.ABSENT,
d1360 1
a1360 1
	       [{lexp=AugLambda.SCON(Ident.STRING string), size=0}],
d1436 1
a1436 1
	  AugLambda.SCON(Ident.STRING chars) =>
d1468 4
a1471 2
          Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)) => Mir_Utils.destruct_2_tuple reg
        | Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] => (reg1, reg2, [])
d1493 21
a1513 15
      fun tagged_binary_calc(opcode,regs,the_code,exn_code) =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val (val1, val2, new_code) = get_int_pair regs
	  val (exn_blocks, exn_tag_opt) = exn_code
	in
	  (Mir_Utils.ONE(Mir_Utils.INT res1), 
           Mir_Utils.combine (the_code,
                              ((Sexpr.ATOM(new_code @@
                                           [(MirTypes.TBINARY(opcode,
                                                              exn_tag_opt, res2, val1, val2))]),
                                exn_blocks, Option.ABSENT, Sexpr.NIL), [], [])))
	end
d1532 28
d1634 22
d1657 1
a1657 1
      fun make_if (opcode,regs,the_code,true_tag,false_tag) =
d1680 52
d1779 63
d1856 27
d1923 26
d3365 33
d3428 2
d3433 1
d3443 47
a3489 1
      (* afg *)
d3491 5
d4011 28
a4038 2
      | Pervasives.WORDDIV => binary_calc (MirTypes.DIVU,regs,the_code)
      | Pervasives.WORDMOD => binary_calc (MirTypes.MODU,regs,the_code)
d4069 12
d4118 3
d4125 12
a4136 3
      | Pervasives.WORDLSHIFT => do_shift_operator(MirTypes.ASL,false,regs,the_code)
      | Pervasives.WORDRSHIFT => do_shift_operator(MirTypes.LSR,true,regs,the_code)
      | Pervasives.WORDARSHIFT => do_shift_operator(MirTypes.ASR,true,regs,the_code)
d4140 1
a4141 3
      | Pervasives.INTTOWORD => do_cast_code (regs,the_code)
      | Pervasives.WORDTOINT => do_cast_code (regs,the_code)
      | Pervasives.SIGNEXTEND => do_cast_code (regs,the_code)
d4190 1
a4190 1
          Option.PRESENT (ref debug_info) => debug_info
d4546 2
a4547 2
            Option.ABSENT => false
          | Option.PRESENT _ => true
d4554 2
a4555 2
              Option.ABSENT => ([], end_tag, [], [],RuntimeEnv.EMPTY,spills,calls)
            | Option.PRESENT{lexp,size} =>
d4718 1
a4718 1
                ([(AugLambda.IMM_TAG (_,t1),_, tag)], Option.PRESENT _) =>
d4721 1
a4721 1
                (AugLambda.IMM_TAG (_,t2),_, tag')], Option.ABSENT) =>
d4769 2
a4770 2
                    Option.ABSENT => Crash.impossible "Missing switch info"
                  | Option.PRESENT {num_imms, num_vccs, ...} => (num_vccs, num_imms)
d4816 1
a4816 1
                             Option.ABSENT =>
d4931 10
a4940 23
                     cg_sub(arg, env, static_offset, start_at,false,
                            (closure,funs_in_closure, fn_tag_list, tuple_bindings),maximum_spills,maximum_calls)
                   val (the_reg, extra) = Mir_Utils.send_to_reg arg_regs (* This is bogus -- but it doesn't matter!!! *)
                   val code = case test of
		     Pervasives.INTLESS => make_if (MirTypes.BLT,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.REALLESS => fmake_if (MirTypes.FBLT, true,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.INTGREATER => make_if (MirTypes.BGT,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.REALGREATER => fmake_if (MirTypes.FBLT,false,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.INTLESSEQ => make_if (MirTypes.BLE,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.REALLESSEQ => fmake_if (MirTypes.FBLE, true,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.INTGREATEREQ => make_if (MirTypes.BGE,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.REALGREATEREQ => fmake_if (MirTypes.FBLE, false,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.INTEQ => make_if (MirTypes.BEQ,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.INTNE => make_if (MirTypes.BNE,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.REALEQ => fmake_if (MirTypes.FBEQ, true,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.REALNE => fmake_if (MirTypes.FBNE, true,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.WORDEQ => make_if (MirTypes.BEQ,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.WORDNE => make_if (MirTypes.BNE,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.WORDLT => make_if (MirTypes.BLO,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.WORDLE => make_if (MirTypes.BLS,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.WORDGT => make_if (MirTypes.BHI,arg_regs,arg_code,true_tag,false_tag)
		   | Pervasives.WORDGE => make_if (MirTypes.BHS,arg_regs,arg_code,true_tag,false_tag)
		   | _ => Crash.impossible "bad relational operator"
d5003 1
a5003 1
                       Option.ABSENT =>
d5102 2
a5103 2
             fun do_chained_tests(_, default, [], test_code) =
               (((case (default, test_code) of
d5107 6
a5112 4
		    (Option.PRESENT _, Option.PRESENT _) =>
		      Sexpr.ATOM[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG dflt_tag),
				 MirTypes.COMMENT "default or end"]
		  | (Option.PRESENT _, Option.ABSENT) =>
d5123 2
a5124 11
	       |   do_chained_tests(the_reg,
                                    default,
                                    (scon,
                                     le,
                                     (regs,
                                      ((first, blocks, tag_opt, last),
                                       values,
                                       procs
                                       ),_,_,_),
                                     tag) :: rest,
                                    test_code) =
d5126 7
a5132 2
                   val the_test =
		     case test_code of
d5134 1
a5134 1
		     | Option.ABSENT => Sexpr.NIL
d5140 1
a5140 1
			  Option.ABSENT =>
d5142 1
a5142 1
			    (case test_code of
d5145 1
a5145 1
				 (case the_test of
d5150 4
a5153 3
			     | _ => the_test)
			| _ => the_test)
		   | _ => the_test
d5161 11
a5171 7
                         (the_test,
                          MirTypes.BLOCK(tag,
                                         Mir_Utils.contract_sexpr
                                         (Sexpr.CONS(first,
                                                     Sexpr.ATOM end_code
					))) :: blocks,
                          Option.ABSENT, Sexpr.NIL)
d5173 12
a5184 7
                         (the_test,
                          MirTypes.BLOCK(tag,
                                         Mir_Utils.contract_sexpr first) :: blocks @@
                          [MirTypes.BLOCK(tag', Mir_Utils.contract_sexpr
                                          (Sexpr.CONS(last,
                                                      Sexpr.ATOM
                                                      end_code)))],
d5189 1
a5189 1
                      do_chained_tests(the_reg, default, rest, test_code))
d5219 4
a5222 2
                           Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag, reg,
                                                    MirTypes.GP_IMM_INT i)]
d5228 7
a5234 6
                           do_chained_tests(the_reg,
                                            dflt,
                                            val_le_tags_list,
                                            if need_main_test 
                                              then Option.PRESENT do_test
                                            else Option.ABSENT))
d5242 2
a5243 2
                           Option.ABSENT => []
                         | Option.PRESENT _ =>
d5256 2
a5257 2
                     Option.ABSENT => []
                   | Option.PRESENT _ =>
d5268 9
a5276 3
		 end handle BigNum.Unrepresentable => v1

               fun scon_code scon =
d5281 1
a5281 1
		    be treated as constrcutors from a set of 256.
d5284 1
a5284 1
                    Ident.INT _ =>
d5286 31
a5316 1
			val (the_reg, extra) = Mir_Utils.send_to_reg arg_regs
d5319 13
d5333 4
a5336 6
			    Lists.qsort (fn ((i:int,_,_,_), (i',_,_,_)) =>
					 i < i')
			    (map (fn (AugLambda.SCON_TAG(Ident.INT (i,location)), code, tag) =>
				  (Mir_Utils.convert_int i, 0, code, tag)
			            | _ => Crash.impossible"Mixed tag type in switch")
			     tagged_code)
d5341 4
a5344 1
			  val (low, high) = bounds (a_value, a_value, map #1 val_le_tags_list)
d5346 5
a5350 1
			  val use_cgt = high + 1 - low <= 2 * len andalso len > 2
d5353 7
d5361 14
a5374 5
			    Option.ABSENT => [MirTypes.COMMENT"No default (strange for scon match)"]
			  | Option.PRESENT _ =>
			      [MirTypes.COMMENT "Default",
			       MirTypes.TEST(MirTypes.BGT, dflt_tag, the_reg,
					     MirTypes.GP_IMM_INT high)]
d5378 5
a5382 4
			     make_cgt(the_reg, low, high,
				      map
				      (fn (x,_, y, z) => (x, y, z))
				      val_le_tags_list))
d5385 15
a5399 3
			      fun do_test(reg, i,_, tag) =
				Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag, reg,
							 MirTypes.GP_IMM_INT i)]
d5402 3
a5404 4
			       do_chained_tests(the_reg,
						dflt,
						val_le_tags_list,
						Option.PRESENT do_test))
d5406 6
a5411 8
			end handle Mir_Utils.ConvertInt =>
                          (* If we have unrepresentable integers, we go for this lot *)
                          (* What does it do I wonder *)
			  (* Who wrote that? *)
			  (* It uses runtime evaluation of the integers *)
			  (* in the patterns, in the case where they cannot *)
			  (* be represented on the compiling machine *)
			  (* because of word size differences *)
a5412 3
			    fun last [] = Crash.impossible"Last empty list"
			      | last [x] = x
			      | last (_ :: xs) = last xs
d5414 8
a5421 3
			      | to_string _ = Crash.impossible"Mixed tag type in switch"
			    fun location_scon(Ident.INT(_, location)) = location
			      | location_scon _ = Crash.impossible"Mixed tag type in switch"
d5429 5
a5433 3
				  case String.substring(str_x, 0, 2) of
				    "0x" => BigNum.hex_string_to_bignum str_x
				  | _ => BigNum.string_to_bignum str_x
d5436 48
d5486 7
a5492 17
			      (fn ((i,_,_,_), (i',_,_,_)) =>
			       BigNum.<(to_bignum i, to_bignum i')
			       handle BigNum.Unrepresentable =>
				 let
				   val i = find_large_value to_bignum (i, i')
				 in
				   Info.error' 
				   error_info
				   (Info.FATAL, location_scon i, "Integer too big : " ^
				    to_string i)
				 end)
			      (map (fn (AugLambda.SCON_TAG scon, code, tag) =>
				    (scon, 0, code, tag)
			            | _ => Crash.impossible"Mixed tag type in switch"
					)
				tagged_code)
			    val low = 
d5495 3
a5497 2
                              | _ => Crash.impossible"Empty switch list"
			    val high = 
d5500 1
a5500 25
			    val dflt_code = case dflt of
			      Option.ABSENT => [MirTypes.COMMENT "No default (strange for scon match)"]
			    | Option.PRESENT _ =>
				let
				  val (reg, the_code) = 
                                    (case
                                       cg_sub(Mir_Utils.convert_long_int high, env,
                                              static_offset, start_at,false,
                                              (closure,funs_in_closure, fn_tag_list, tuple_bindings),
                                              !spills,!calls) of
				    (Mir_Utils.ONE(Mir_Utils.INT(r as MirTypes.GP_GC_REG _)),
				     ((code, [], Option.ABSENT, Sexpr.NIL),
				      [], []),_,_,_) => (r, code)
				  | _ => Crash.impossible"Bad code for big int")
			          handle BigNum.Unrepresentable =>
				    Info.error' 
				      error_info
				      (Info.FATAL, location_scon high,
				       "Integer too big : " ^ to_string high)
				in
				  MirTypes.COMMENT "Default" ::
				  (Mir_Utils.contract_sexpr the_code @@
				   [MirTypes.TEST(MirTypes.BGT, dflt_tag, the_reg,
						  reg)])
				end
d5504 1
a5504 1
				  cg_sub(Mir_Utils.convert_long_int long_i, env,
d5511 14
a5524 6
				  | _ => Crash.impossible"Bad code for big int")
			          handle BigNum.Unrepresentable =>
				    Info.error' 
				      error_info
				      (Info.FATAL, location_scon long_i,
				       "Integer too big : " ^ to_string long_i)
d5526 5
a5530 4
				Sexpr.CONS
				(the_code,
				 Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag,
							  reg, reg')])
d5534 3
a5536 4
			     do_chained_tests(the_reg,
					      dflt,
					      val_le_tags_list,
					      Option.PRESENT do_test))
d5541 2
d5544 27
a5570 1
			val (the_reg, extra) = Mir_Utils.send_to_reg arg_regs
d5573 13
d5587 4
a5590 6
			    Lists.qsort (fn ((i:int,_,_,_), (i',_,_,_)) =>
					 i < i')
			    (map (fn (AugLambda.SCON_TAG(Ident.WORD(i,location)), code, tag) =>
				  (Mir_Utils.convert_word i, 0, code, tag)
			            | _ => Crash.impossible"Mixed tag type in switch")
			     tagged_code)
d5595 4
a5598 1
			  val (low, high) = bounds (a_value, a_value, map #1 val_le_tags_list)
d5600 5
a5604 1
			  val use_cgt = high + 1 - low <= 2 * len andalso len > 2
d5607 7
d5615 14
a5628 5
			    Option.ABSENT => [MirTypes.COMMENT"No default (strange for scon match)"]
			  | Option.PRESENT _ =>
			      [MirTypes.COMMENT "Default",
			       MirTypes.TEST(MirTypes.BGT, dflt_tag, the_reg,
					     MirTypes.GP_IMM_INT high)]
d5632 5
a5636 4
			     make_cgt(the_reg, low, high,
				      map
				      (fn (x,_, y, z) => (x, y, z))
				      val_le_tags_list))
d5639 15
a5653 3
			      fun do_test(reg, i,_, tag) =
				Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag, reg,
							 MirTypes.GP_IMM_INT i)]
d5656 3
a5658 4
			       do_chained_tests(the_reg,
						dflt,
						val_le_tags_list,
						Option.PRESENT do_test))
d5660 6
a5665 8
			end handle Mir_Utils.ConvertInt =>
                          (* If we have unrepresentable integers, we go for this lot *)
                          (* What does it do I wonder *)
			  (* Who wrote that? *)
			  (* It uses runtime evaluation of the words *)
			  (* in the patterns, in the case where they cannot *)
			  (* be represented on the compiling machine *)
			  (* because of word size differences *)
a5666 3
			    fun last [] = Crash.impossible"Last empty list"
			      | last [x] = x
			      | last (_ :: xs) = last xs
d5668 8
a5675 3
			      | to_string _ = Crash.impossible"Mixed tag type in switch"
			    fun location_scon(Ident.WORD(_, location)) = location
			      | location_scon _ = Crash.impossible"Mixed tag type in switch"
d5680 1
a5680 1
				if size str_x < 2 then
d5683 20
a5702 3
				  case String.substring(str_x, 0, 2) of
				    "0wx" => BigNum.hex_word_string_to_bignum str_x
				  | _ => BigNum.word_string_to_bignum str_x
d5705 33
d5740 6
a5745 16
			      (fn ((i,_,_,_), (i',_,_,_)) =>
			       BigNum.<(to_bignum i, to_bignum i')
			       handle BigNum.Unrepresentable =>
				 let
				   val i = find_large_value to_bignum (i, i')
				 in
				   Info.error'
				   error_info
				   (Info.FATAL, location_scon i, "Word too big : " ^
				    to_string i)
				 end)
			      (map (fn (AugLambda.SCON_TAG scon, code, tag) =>
				    (scon, 0, code, tag)
			            | _ => Crash.impossible"Mixed tag type in switch"
					)
				tagged_code)
d5749 2
a5750 1
                              | _ => Crash.impossible"Empty switch list"
d5754 1
a5754 25
			    val dflt_code = case dflt of
			      Option.ABSENT => [MirTypes.COMMENT "No default (strange for scon match)"]
			    | Option.PRESENT _ =>
				let
				  val (reg, the_code) = 
                                    (case
                                       cg_sub(Mir_Utils.convert_long_word high, env,
                                              static_offset, start_at,false,
                                              (closure,funs_in_closure, fn_tag_list, tuple_bindings),
                                              !spills,!calls) of
				    (Mir_Utils.ONE(Mir_Utils.INT(r as MirTypes.GP_GC_REG _)),
				     ((code, [], Option.ABSENT, Sexpr.NIL),
				      [], []),_,_,_) => (r, code)
				  | _ => Crash.impossible"Bad code for big word")
			          handle BigNum.Unrepresentable =>
				    Info.error' 
				      error_info
				      (Info.FATAL, location_scon high,
				       "Word too big : " ^ to_string high)
				in
				  MirTypes.COMMENT "Default" ::
				  (Mir_Utils.contract_sexpr the_code @@
				   [MirTypes.TEST(MirTypes.BGT, dflt_tag, the_reg,
						  reg)])
				end
d5758 1
a5758 1
				  cg_sub(Mir_Utils.convert_long_word long_i, env,
d5766 13
a5778 5
			          handle BigNum.Unrepresentable =>
				    Info.error'
				      error_info
				      (Info.FATAL, location_scon long_i,
				       "Word too big : " ^ to_string long_i)
d5780 5
a5784 4
				Sexpr.CONS
				(the_code,
				 Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag,
							  reg, reg')])
d5788 3
a5790 4
			     do_chained_tests(the_reg,
					      dflt,
					      val_le_tags_list,
					      Option.PRESENT do_test))
d5801 1
a5801 1
			    (map (fn (AugLambda.SCON_TAG(Ident.CHAR s), code, tag) =>
d5815 2
a5816 2
			    Option.ABSENT => [MirTypes.COMMENT"No default (strange for scon match)"]
			  | Option.PRESENT _ =>
d5818 1
a5818 1
			       MirTypes.TEST(MirTypes.BGT, dflt_tag, the_reg,
d5830 5
a5834 2
				Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag, reg,
							 MirTypes.GP_IMM_INT i)]
d5840 2
a5841 1
						Option.PRESENT do_test))
d5849 1
a5849 1
                          map (fn ((AugLambda.SCON_TAG(Ident.REAL _), code, tag), p) =>
d5868 7
a5874 4
                            Sexpr.ATOM[MirTypes.STOREOP
				       (MirTypes.LD, MirTypes.GC_REG MirRegisters.global,
					MirTypes.GC_REG callee_closure,
					MirTypes.GP_IMM_ANY
d5876 7
a5882 6
					    (funs_in_closure * 2 - 1)) - 1)),
				       MirTypes.STOREFPOP
                                       (MirTypes.FLD, fp_op,
                                        MirTypes.GC_REG MirRegisters.global,
                                        MirTypes.GP_IMM_ANY real_offset),
                                       MirTypes.FTEST(MirTypes.FBEQ, tag, fp_op, reg)]
d5884 1
d5889 1
a5889 1
                             AugLambda.SCON_TAG(scon as Ident.REAL _) =>
d5898 1
a5898 1
                                           do_chained_tests(the_reg, dflt, val_le_tags_list, Option.PRESENT do_test)))
d5904 1
a5904 1
                          (fn ((AugLambda.SCON_TAG(Ident.STRING _), code, tag), p) =>
d5945 33
a5977 22
                            Sexpr.CONS(
                                       Sexpr.ATOM[MirTypes.STOREOP(MirTypes.LD, scon_reg,
                                                                   MirTypes.GC_REG callee_closure,
                                                                   MirTypes.GP_IMM_ANY(4*(static_offset + i +
                                                                                          (2*funs_in_closure-1)) - 1)),
                                       MirTypes.ALLOCATE_STACK(MirTypes.ALLOC,
                                                               MirTypes.GC_REG caller_arg,
                                                               2,
                                                               Option.ABSENT),
                                       MirTypes.STOREOP(MirTypes.ST, Mir_Utils.reg_from_gp the_reg,
                                                        MirTypes.GC_REG caller_arg,
                                                        MirTypes.GP_IMM_ANY ~1),
                                       MirTypes.STOREOP(MirTypes.ST, scon_reg,
                                                        MirTypes.GC_REG caller_arg,
                                                        MirTypes.GP_IMM_ANY 3),
                                       MirTypes.COMMENT"Call external STRINGEQ"],
                                       Sexpr.CONS
                                       (app_code,
                                        Sexpr.ATOM[MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, 2),
                                                   MirTypes.TEST(MirTypes.BEQ, tag,
                                                                 MirTypes.GP_GC_REG caller_arg,
                                                                 MirTypes.GP_IMM_INT 1)]))
d5983 1
a5983 1
                             AugLambda.SCON_TAG(scon as Ident.STRING _) =>
d5993 1
a5993 1
                                           do_chained_tests(the_reg, dflt, val_le_tags_list, Option.PRESENT do_test)))
d6031 6
a6036 2
                       Sexpr.CONS(the_code,
                                  Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag, reg, regs)])
d6039 1
a6039 1
                   ([], do_chained_tests(the_reg, dflt, val_le_tags_list, Option.PRESENT do_test))
d6062 2
a6063 1
		 (((Sexpr.NIL, [], Option.PRESENT main_tag, Sexpr.ATOM main_default),
d6109 1
a6109 1
    | cg_sub(arg as AugLambda.SCON scon, e,static_offset, start_at,tails,
d6121 32
a6152 11
	     ((Mir_Utils.ONE
	       (Mir_Utils.INT
		(MirTypes.GP_IMM_INT
		 (Mir_Utils.convert_int i))),
	       no_code,RuntimeEnv.EMPTY,spills,calls) handle Mir_Utils.ConvertInt =>
	     (cg_sub(Mir_Utils.convert_long_int scon, e,static_offset,start_at,tails,
                     (closure,funs_in_closure, fn_tag_list, tuple_bindings),spills,calls)
	      handle BigNum.Unrepresentable =>
	        Info.error' 
	          error_info
		  (Info.FATAL, location, "Integer too big : " ^ i)))
d6154 29
a6182 8
	     ((Mir_Utils.ONE
	       (Mir_Utils.INT
		(MirTypes.GP_IMM_INT
		 (Mir_Utils.convert_word i))),
	       no_code,RuntimeEnv.EMPTY,spills,calls) handle Mir_Utils.ConvertInt =>
	     (cg_sub(Mir_Utils.convert_long_word scon, e,static_offset,start_at,tails,
                     (closure,funs_in_closure, fn_tag_list, tuple_bindings),spills,calls)
	      handle BigNum.Unrepresentable =>
d6185 2
a6186 1
		  (Info.FATAL, location, "word too big : " ^ i)))
d6364 1
a6364 1
        (fn ((lvar,Option.PRESENT (ref (RuntimeEnv.VARINFO (name,ty,_)))),acc) => 
@


1.272
log
@Handle INTMOD and INTDIV
@
text
@d4 3
d2109 17
d2141 1
a2141 1
                                      new_reg),
d2145 17
a2161 2
		      (* Note that the 5 includes the left over bit of secondary tag *)
                      MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]),
d2246 70
a2315 49
          if safe 
            then
              let
                val (exn_blocks, exn_tag_opt) = exn_code
                val exn_tag =
                  case exn_tag_opt
                    of Option.PRESENT tag => tag
                     |  _ => Crash.impossible "no exn_tag for Vector.sub"
                val finish_tag = MirTypes.new_tag()
                val main_tag = MirTypes.new_tag()
              in
                (Mir_Utils.ONE(Mir_Utils.INT res2),
                 Mir_Utils.combine
                 (the_code,
                  ((Sexpr.ATOM
                    (code @@ code' @@
                     [MirTypes.COMMENT "Check the subscript range"] @@
                     (if constantp then
                        if constant_value < 0 then
                          [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
                        else
                          []
                      else
                        [MirTypes.TEST(MirTypes.BLT, exn_tag, offset_reg, MirTypes.GP_IMM_INT 0)]) @@
                        [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG MirRegisters.global,
                                          Mir_Utils.reg_from_gp vector_reg,
                                          MirTypes.GP_IMM_ANY(~5)),
                        MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
                                        MirTypes.GP_GC_REG MirRegisters.global,
                                        MirTypes.GP_IMM_ANY 4),
                        MirTypes.BINARY(MirTypes.SUB,MirTypes.GC_REG MirRegisters.global,
                                        MirTypes.GP_GC_REG MirRegisters.global,
                                        offset_reg),
                        MirTypes.TEST(MirTypes.BGE, main_tag,
                                      MirTypes.GP_GC_REG MirRegisters.global,
                                      MirTypes.GP_IMM_ANY 4),
                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]),
                    MirTypes.BLOCK(main_tag,
                                   [MirTypes.COMMENT "Vector subscript operation",
                                    MirTypes.BINARY(MirTypes.ADD,
                                                    MirTypes.GC_REG MirRegisters.global,
                                                    vector_reg, offset_reg),
                                    MirTypes.STOREOP(MirTypes.LD, res1,
                                                     MirTypes.GC_REG MirRegisters.global,
                                                     MirTypes.GP_IMM_ANY(~1)),
                                    MirTypes.BRANCH(MirTypes.BRA,
                                                    MirTypes.TAG finish_tag)]) ::
                    exn_blocks, Option.PRESENT finish_tag, Sexpr.NIL), [], [])))
              end
d2402 17
d2444 14
d4564 20
a4583 15
                   val code =
                     case test of
                       Pervasives.INTLESS => make_if (MirTypes.BLT,arg_regs,arg_code,true_tag,false_tag)
                     | Pervasives.REALLESS => fmake_if (MirTypes.FBLT, true,arg_regs,arg_code,true_tag,false_tag)
                     | Pervasives.INTGREATER => make_if (MirTypes.BGT,arg_regs,arg_code,true_tag,false_tag)
                     | Pervasives.REALGREATER => fmake_if (MirTypes.FBLT,false,arg_regs,arg_code,true_tag,false_tag)
                     | Pervasives.INTLESSEQ => make_if (MirTypes.BLE,arg_regs,arg_code,true_tag,false_tag)
                     | Pervasives.REALLESSEQ => fmake_if (MirTypes.FBLE, true,arg_regs,arg_code,true_tag,false_tag)
                     | Pervasives.INTGREATEREQ => make_if (MirTypes.BGE,arg_regs,arg_code,true_tag,false_tag)
                     | Pervasives.REALGREATEREQ => fmake_if (MirTypes.FBLE, false,arg_regs,arg_code,true_tag,false_tag)
                     | Pervasives.INTEQ => make_if (MirTypes.BEQ,arg_regs,arg_code,true_tag,false_tag)
                     | Pervasives.INTNE => make_if (MirTypes.BNE,arg_regs,arg_code,true_tag,false_tag)
                     | Pervasives.REALEQ => fmake_if (MirTypes.FBEQ, true,arg_regs,arg_code,true_tag,false_tag)
                     | Pervasives.REALNE => fmake_if (MirTypes.FBNE, true,arg_regs,arg_code,true_tag,false_tag)
                     | _ => Crash.impossible "bad relational operator"
@


1.271
log
@Fix problem of wrong integer reported too big
@
text
@d4 3
d3577 4
a3580 2
      | Pervasives.DIV => tagged_binary_calc(MirTypes.DIVV,regs,the_code,exn_code_for_prim prim)
      | Pervasives.MOD => tagged_binary_calc(MirTypes.MODV,regs,the_code,exn_code_for_prim prim)
@


1.270
log
@Translate WORD SCons
@
text
@d4 3
d4798 7
d4862 5
d4892 8
a4899 4
				 Info.error' 
				 error_info
				 (Info.FATAL, location_scon i, "Integer too big : " ^
				  to_string i))
d5018 1
a5018 1
			  (* It uses runtime evaluation of the integers *)
d5047 8
a5054 4
				 Info.error'
				 error_info
				 (Info.FATAL, location_scon i, "Word too big : " ^
				  to_string i))
@


1.269
log
@Add pervasive word operations
@
text
@d4 3
d1293 2
a1294 1
         | Ident.CHAR(tag) => RuntimeEnv.CHAR(tag))
d3548 1
d4799 3
d4860 12
a4871 1
			    val to_bignum = BigNum.string_to_bignum o to_string
d4948 151
d5413 12
@


1.268
log
@Deal with code generation of special constant chars
@
text
@d4 3
d1257 1
d1261 1
d1265 1
d1269 1
d1276 2
d3586 5
d3599 1
d3603 1
d3607 1
d3611 1
d3617 2
d3655 3
d3662 3
d3667 1
d3669 3
@


1.267
log
@Add new operations on chars
@
text
@d4 3
d1280 2
a1281 1
         | Ident.STRING(tag) => RuntimeEnv.STRING(tag))
a4896 6
(*
			    Info.error' 
			    error_info
			    (Info.FATAL,location,
			     "Integer too big : " ^ i)
*)
d4899 48
d5213 6
@


1.266
log
@Avoid use of global as an internediate in variable shifts
This makes code generation on the MIPS impossible
@
text
@d4 4
d1250 1
d1253 1
d1256 1
d1259 1
d1264 2
d2822 31
d3547 2
d3580 1
d3583 1
d3586 1
d3589 1
d3593 2
@


1.265
log
@Modify handlers to put handler restoration in common sequence
@
text
@d4 3
d1643 3
d1647 4
d1653 5
a1657 4
	      [MirTypes.BINARY(MirTypes.BIC,MirTypes.GC_REG result,
			       MirTypes.GP_GC_REG result,
			       MirTypes.GP_IMM_ANY 3)]
	    else []
d1661 1
a1664 1
	  (* Optimise the shift by constant case *)
d1666 1
a1666 1
                MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
d1669 2
a1670 2
                                MirTypes.GP_GC_REG MirRegisters.global) ::
                clear_code
@


1.264
log
@Removing timer structure
@
text
@d4 3
d5660 3
a5662 2
      val end_tag = MirTypes.new_tag()
      val continue_tag = MirTypes.new_tag()
d5680 6
a5688 2
	 MirTypes.OLD_HANDLER ::
	 MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, frame_size) ::
d5691 1
a5691 1
	 [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG end_tag)])
d5733 1
a5733 1
		((Sexpr.ATOM frame_setup, [exn_end], Option.ABSENT,
d5744 1
a5744 4
	[MirTypes.OLD_HANDLER,
	 MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, frame_size),
	 MirTypes.COMMENT"Restore previous handler",
	 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG end_tag)]
@


1.263
log
@Improving simple comparison code
@
text
@d4 3
a960 1
require "../utils/timer";
a982 1
  structure Timer : TIMER
d3119 3
a3121 9
    val fn_bindings =
      Timer.xtime
      ("calculating fn bindings", print_timings,
       fn () => InterProc.binding_list new_lambda_exp)

    val escape_map =
      Timer.xtime
      ("calculating escape map", print_timings,
       fn () => InterProc.escape_map fn_bindings)
d3149 5
a3153 7
      Timer.xtime
      ("counting new_lambda", print_timings,
       fn () => AugLambda.count_gc_objects (new_lambda_exp,
                                            true (* generate_debug_info *), (* always generate debug info, for now *)
                                            mapping,
                                            name_of_setup_function))

@


1.262
log
@Adding CAST and UMAP primitives
@
text
@d4 3
d1414 25
d1444 1
a1444 5
	  val (val1, val2, new_code) =
	    case regs of
	      Mir_Utils.ONE(Mir_Utils.INT reg) => Mir_Utils.destruct_2_tuple reg
	    | Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] => (reg1, reg2, [])
	    | _ => Crash.impossible "tagged_binary_calc"
d1475 1
a1475 25
	  val (regs, new_code) =
	    case regs of
	      Mir_Utils.ONE(Mir_Utils.INT reg) =>
		let
		  val (reg1, reg2, new_code) = Mir_Utils.destruct_2_tuple reg
		  val freg1 = MirTypes.FP_REG(MirTypes.FP.new())
		  val freg2 = MirTypes.FP_REG(MirTypes.FP.new())
		in
		  (Mir_Utils.LIST[Mir_Utils.REAL freg1, Mir_Utils.REAL freg2],
		   new_code @@
		   [MirTypes.STOREFPOP
		    (MirTypes.FLD, freg1,
		     Mir_Utils.reg_from_gp reg1, MirTypes.GP_IMM_ANY real_offset),
		    MirTypes.STOREFPOP
		    (MirTypes.FLD, freg2,
		     Mir_Utils.reg_from_gp reg2, MirTypes.GP_IMM_ANY real_offset)])
		end
	    | Mir_Utils.LIST[val1, val2] =>
		let
		  val (fp_op1, code1) = Mir_Utils.get_real val1
		  val (fp_op2, code2) = Mir_Utils.get_real val2
		in
		  (Mir_Utils.LIST[Mir_Utils.REAL fp_op1, Mir_Utils.REAL fp_op2], code1 @@ code2)
		end
	    | _ => Crash.impossible"tagged_binary_fcalc 1"
d1478 6
a1483 9
	  case regs of
	    Mir_Utils.LIST[Mir_Utils.REAL val1, Mir_Utils.REAL val2] =>
	      (Mir_Utils.ONE(Mir_Utils.REAL result),
	       Mir_Utils.combine (the_code,
                                  ((Sexpr.ATOM(new_code @@
                                               [(MirTypes.TBINARYFP(opcode, exn_tag_opt, result,
                                                                    val1, val2))]),
                                  exn_blocks, Option.ABSENT, Sexpr.NIL), [], [])))
	  | _ => Crash.impossible"tagged_binary_fcalc 2"
d1523 8
d1534 35
a1568 20
	  val tag = MirTypes.new_tag()
	in
	  let
	    val (val1, val2, new_code) = case regs of
	      Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)) => Mir_Utils.destruct_2_tuple reg
	    | Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] => (reg1, reg2, [])
	    | _ => Crash.impossible"test"
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG res_reg)),
	      Mir_Utils.combine(the_code,
		      ((Sexpr.ATOM(new_code @@
			[MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
				       MirTypes.GP_IMM_INT 1),
			MirTypes.TEST(opcode, tag, val1, val2),
			MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
				       MirTypes.GP_IMM_INT 0),
			MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag)]),
		       [], Option.PRESENT tag, Sexpr.NIL), [], [])))
	  end
	end
d1573 1
a1573 1
	  val tag = MirTypes.new_tag()
d1576 1
a1576 18
	    val (val1, val2, new_code) =
	      case regs of
		Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)) =>
		  let
		    val (reg1, reg2, des_code) = Mir_Utils.destruct_2_tuple reg
		    val (fp1, code1) = Mir_Utils.get_real (Mir_Utils.INT reg1)
		    val (fp2, code2) = Mir_Utils.get_real (Mir_Utils.INT reg2)
		  in
		    (fp1, fp2, des_code @@ code1 @@ code2)
		  end
	      | Mir_Utils.LIST[reg1, reg2] =>
		  let
		    val (fp1, code1) = Mir_Utils.get_real reg1
		    val (fp2, code2) = Mir_Utils.get_real reg2
		  in
		    (fp1, fp2, code1 @@ code2)
		  end
	      | _ => Crash.impossible"ftest"
d1580 6
a1585 9
	      Mir_Utils.combine(the_code,
		      ((Sexpr.ATOM(new_code @@
			[MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
				       MirTypes.GP_IMM_INT 1),
			MirTypes.FTEST(opcode, tag, val1, val2),
			MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
				       MirTypes.GP_IMM_INT 0),
			MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag)]),
		       [], Option.PRESENT tag, Sexpr.NIL), [], [])))
d1622 1
a1622 5
	  val (val1, val2, new_code) =
	    case regs of
	      Mir_Utils.ONE(Mir_Utils.INT reg) => Mir_Utils.destruct_2_tuple reg
	    | Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] => (reg1, reg2, [])
	    | _ => Crash.impossible"binary_calc"
d1636 1
a1636 5
	  val (val1, val2, new_code) =
	    case regs of
	      Mir_Utils.ONE(Mir_Utils.INT reg) => Mir_Utils.destruct_2_tuple reg
	    | Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] => (reg1, reg2, [])
	    | _ => Crash.impossible"do_shift_operator"
d1675 1
a1675 1
              Mir_Utils.LIST[ Mir_Utils.INT(size), initial ] => 
d2862 1
a2862 5
	  val (string, offset, new_code) =
	    case regs of
	      Mir_Utils.ONE(Mir_Utils.INT reg) => Mir_Utils.destruct_2_tuple reg
	    | Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] => (reg1, reg2, [])
	    | _ => Crash.impossible"do_ordof"
d3970 2
a3971 2
             (* Initial set up *)
             val tag_positions = do_pos2(arg_size + list_size, tag_le_list)
d3973 2
a3974 1
	     val main_tag = MirTypes.new_tag() (* This tag marks the start of the body of the switch. *)
d3976 2
a3977 1
             val main_branch = MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG main_tag)
d3979 43
a4021 50
	     val is_con = 
               case tag_le_list of
                 (AugLambda.IMM_TAG _,_) :: _ => true
               | (AugLambda.VCC_TAG _,_) :: _ => true
               | _ => false

             val dflt_exists = case dflt of
               Option.ABSENT => false
             | Option.PRESENT _ => true

             val end_tag = MirTypes.new_tag()
             (* For the end of switch *)

             val final_branch =
	       MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG end_tag)

             val end_reg = MirTypes.GC.new() (* For the result *)

             (* Construct the default blocks and tags *)
             fun get_blocks_for_dflts(dflt, static_offset, start_at, comment) =
               case dflt of
                 Option.ABSENT => ([], end_tag, [], [],RuntimeEnv.EMPTY,spills,calls)
               | Option.PRESENT{lexp,size} =>
                   let
                     (* Code generate the body *)
                     val (regs, body_code,runtime_env,spills,calls) =
                       cg_sub(lexp, env, static_offset, start_at,tails,
                              (closure,funs_in_closure, fn_tag_list,tuple_bindings),
                              (slot,non_gc_spills,fp_spills),calls)

                     val debug_code =
                       if variable_debug 
                         then 
                           let
                             val new_reg = MirTypes.GC.new()
                           in
                             ((Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, 
                                                          MirTypes.GC_REG (new_reg),
                                                          MirTypes.GP_IMM_INT 0),
                                           MirTypes.STOREOP(MirTypes.STREF,
                                                            MirTypes.GC_REG (new_reg),
                                                            MirTypes.GC_REG fp,
                                                            MirTypes.GP_IMM_SYMB 
                                                            (MirTypes.GC_SPILL_SLOT 
                                                             (MirTypes.DEBUG (ref_slot,
                                                                              "default for switch"))))], 
                             [],Option.ABSENT, Sexpr.NIL), [], [])
                           end
                       else
                         no_code
d4023 34
a4056 34
                     val result_code =
                       (case regs of
                          Mir_Utils.ONE(Mir_Utils.INT reg) =>
                            [MirTypes.UNARY(MirTypes.MOVE,
                                            MirTypes.GC_REG end_reg,
                                            reg)]
                        | Mir_Utils.ONE(Mir_Utils.REAL reg) =>
                            Mir_Utils.save_real_to_reg(reg,
                                                       MirTypes.GC_REG end_reg)
                        | Mir_Utils.LIST many =>
                            (#2 (Mir_Utils.tuple_up_in_reg(many,end_reg))))

                     val full_body_code = 
                       Mir_Utils.combine (debug_code,
                                          Mir_Utils.combine (body_code,
                                                             ((Sexpr.ATOM(MirTypes.COMMENT comment :: 
                                                                          result_code @@ [final_branch]),
                                                             [],Option.ABSENT,Sexpr.NIL),
                                                             [],[])))

                     val new_tag =  MirTypes.new_tag()
                     val ((first,blocks,opttag,last),values,procs) = full_body_code
                     val newblocks = 
                       case opttag of
                         Option.ABSENT => 
                           MirTypes.BLOCK(new_tag,Mir_Utils.contract_sexpr first) ::
                           blocks
                       | Option.PRESENT tag =>
                           MirTypes.BLOCK(new_tag,Mir_Utils.contract_sexpr first) ::
                           MirTypes.BLOCK(tag,Mir_Utils.contract_sexpr last) ::
                           blocks 
                   in
                     (newblocks,new_tag,values,procs,runtime_env,spills,calls)
                   end
d4058 6
a4063 6
             (* Generate for the default case, if it exists *)
             val (dflt_blocks, dflt_tag, dflt_values, dflt_procs,runtime_env,spills',calls') =
               get_blocks_for_dflts(dflt,
                                    static_offset + arg_size + list_size + tag_sizes,
                                    start_at + arg_size + list_size + tag_sizes,
                                    "simple default")
d4065 9
a4073 60
	     (* Count the different types of constructor, if appropriate. *)
	     val (num_vcc_tags, num_imm_tags) =
	       if not is_con then (0, 0)
	       else
	         lists_reducel
	  	   (fn ((nv, ni), (AugLambda.IMM_TAG _,_)) => (nv, ni + 1)
		    |  ((nv, ni), (AugLambda.VCC_TAG _,_)) => (nv + 1, ni)
		    |  _ => Crash.impossible "bad constructor tag")
		   ((0, 0), tag_le_list)

             (* Generate for the non-default cases *)
             val tagged_code = 
              if variable_debug 
                then
                  let
                    val switch_cases = Lists.length tag_le_list
                  in
                    #2 (Lists.reducer 
                        (fn (((t, {lexp=x, ...}), le_offset),(switch_case,tagged_code)) =>
                         let
                           val (reg, code,runtime_env,spills,calls) = 
                             cg_sub(x, env, static_offset + le_offset,start_at + le_offset,tails,
                                    (closure,funs_in_closure, fn_tag_list, tuple_bindings),
                                    (slot,non_gc_spills,fp_spills),calls)
                           (* This may be a tail, but only if we are in the tail line *)
                           val new_reg = MirTypes.GC.new()
                         in
                           (switch_case-1,
                            (t, (reg, 
                                 Mir_Utils.combine
                                 (((Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG (new_reg),
                                                               MirTypes.GP_IMM_INT switch_case),
                                                MirTypes.STOREOP(MirTypes.STREF,MirTypes.GC_REG (new_reg),
                                                                 MirTypes.GC_REG fp,
                                                                 MirTypes.GP_IMM_SYMB 
                                                                 (MirTypes.GC_SPILL_SLOT 
                                                                  (MirTypes.DEBUG (ref_slot,
                                                                                   "switch case " ^ 
                                                                                   MLWorks.Integer.makestring switch_case))))], 
                                 [],Option.ABSENT, Sexpr.NIL), [], []),code),
                                 (convert_tag t,runtime_env),
                                 spills,calls),
                            MirTypes.new_tag ()) :: tagged_code)
                         end)
                        (Lists.zip (tag_le_list, positions), (switch_cases,nil)))
                  end
              else 
                map
                (fn ((t, {lexp=x, ...}), le_offset) =>
                 let
                   val (reg, code,runtime_env,spills,calls) =
                     cg_sub(x, env, static_offset + le_offset,start_at + le_offset,tails,
                            (closure,funs_in_closure, fn_tag_list, tuple_bindings),
                            (slot,non_gc_spills,fp_spills),calls)
                 (* This may be a tail, but only if we are in the tail line *)
                 in
                   (t, (reg, code, (convert_tag t,runtime_env),
                        spills,calls),MirTypes.new_tag())
                 end)
                (Lists.zip (tag_le_list, positions))
d4075 68
a4142 17
             (* I wonder what this is about *)
             val spills = map (fn tuple => #4 (#2 tuple)) tagged_code
             val calls = map (fn tuple => #5 (#2 tuple)) tagged_code

             local
               fun order ((gc_spills:int, non_gc_spills:int, fp_spills:int),
                          (gc_spills':int, non_gc_spills':int, fp_spills':int)) =
                 gc_spills >= gc_spills' andalso 
                 non_gc_spills >= non_gc_spills' andalso
                 fp_spills >= fp_spills
             in
               val maximum_spills = 
                 lists_reducel 
                 (fn (max_spill,spill) => 
                  if order (max_spill,spill) then max_spill else spill)
                 ((0,0,0),(spills'::spills))
             end
d4144 41
a4184 4
             val maximum_calls = 
               lists_reducel 
               (fn (max_app,app) => if max_app > app then max_app else app) 
               (0,(calls'::calls))
d4186 13
a4198 1
             val runtime_env = (RuntimeEnv.DEFAULT,runtime_env) :: map (fn tuple => #3 (#2 tuple)) tagged_code
d4200 1
a4200 1
             val is_rel = is_simple_relation lexp
d4202 86
a4287 133
             (* In the case of if..then, need to know this *)
             val (true_tag, false_tag) =
               if is_rel then
                 case (tagged_code, dflt) of
                   ([(AugLambda.IMM_TAG (_,t1),_, tag)], Option.PRESENT _) =>
                     if t1 = 1 then (tag, dflt_tag) else (dflt_tag, tag)
                 | ([(AugLambda.IMM_TAG (_,t1),_, tag),
                     (AugLambda.IMM_TAG (_,t2),_, tag')], Option.ABSENT) =>
                   if t1 = 1 then (tag, tag') else (tag', tag)
                 | _ =>
		   Crash.impossible "Relational expression with bad IMM_TAGs"
               else (dflt_tag, dflt_tag) (* Rubbish values *)

	     (* get_vcc_tag and get_imm_tag are only called when there is only one tag of the appropriate type. *)

	     fun get_vcc_tag [] = Crash.impossible "Missing VCC tag"
	     |   get_vcc_tag ((AugLambda.VCC_TAG _,_, tag) :: _) = tag
	     |   get_vcc_tag (_ :: rest) = get_vcc_tag rest

	     fun get_imm_tag [] = Crash.impossible "Missing IMM tag"
	     |   get_imm_tag ((AugLambda.IMM_TAG t,_, tag) :: _) = tag
	     |   get_imm_tag (_ :: rest) = get_imm_tag rest

	     fun con_tag_to_reg (from_reg, to_reg) =
	       let 
                 val offset = ~1
	       in 
                 MirTypes.STOREOP(MirTypes.LD,
                                  MirTypes.GC_REG to_reg,
                                  MirTypes.GC_REG from_reg,
                                  MirTypes.GP_IMM_ANY offset)
	       end

	     (* Put the correct value in the register on which we switch.
		In the general case this requires testing the runtime tag
		on the value, but in some common cases we can improve on this.
		The boolean third field of the result is true if we still
		need to test the actual tag number.
	      *)
            (* Returns:
             1: The register with the value to test
             2: The code to extract the value
             3: Do we still need to test?
             *)
             (* This seems to do the extraction of tags so the subsequent code doesn't *)
             (* have to worry about the difference between VCC's and IMM's *)

             fun destructuring_code regs = 
               case regs of
                 (* Single value case *)
                 Mir_Utils.ONE(Mir_Utils.INT(gp_op as MirTypes.GP_GC_REG reg)) =>
                   let val (num_vccs, num_imms) =
                     case info of
                       (* Only called for constructor matches *)
                       Option.ABSENT => Crash.impossible "Missing switch info"
                     | Option.PRESENT {num_imms, num_vccs, ...} => (num_vccs, num_imms)
                   in
                     if num_imms = 0 then
                       (* No immediate values, all VCC's *)
                       let val tmp_reg = MirTypes.GC.new()
                       in 
                         (MirTypes.GP_GC_REG tmp_reg,
                          [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 0 IMM_TAG",
                           con_tag_to_reg (reg, tmp_reg),
                           main_branch],
                          true)
                       end
                     else if num_vccs = 0 then
                       (* All immediates *)
                       (gp_op,
                        [MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 0 VCC_TAG",
                         main_branch],
                        true)
                     else if num_vccs = 1 then
                       (* Just one vcc *)
                       let val vcc_tag =
                         if num_vcc_tags = 1 then 
                           get_vcc_tag tagged_code
                         else if dflt_exists then
                           dflt_tag
                         else Crash.impossible ("Missing vcc_tag or default")
                       in
                         (gp_op,
                          MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 1 VCC" ::
                          (* Branch if it's a boxed value *)
                          MirTypes.TEST (MirTypes.BTA,
                                         vcc_tag,
                                         gp_op,
                                         MirTypes.GP_IMM_ANY tag_test_mask) ::
                          (if num_imm_tags = 1 andalso num_imms = 1 then
                             (* 1 VCC and 1 IMM *)
                             [MirTypes.BRANCH (MirTypes.BRA,
                                               MirTypes.TAG (get_imm_tag tagged_code))]
                          else if num_imm_tags = 0 then
                            (* num_imms = 1 => num_imm_tags = 0 here *)
                            (* So any imm tag must be the default *)
                            let
                              val branch =
                                [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG dflt_tag)]
                            in
                              case dflt of
                                Option.ABSENT =>
                                  (* This is the nasty semantically invalid case *)
                                  (* Why isn't this a Crash? *)
                                  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG end_reg,
                                                 MirTypes.GP_IMM_INT 0) :: branch
                              | _ => branch
                            end
                          else [main_branch]),
                          num_imms <> 1 andalso num_imm_tags <> 0)
                       end
                     else if num_imms = 1 then
                       (* 1 IMM case *)
                       let val tmp_reg = MirTypes.GC.new()
		         val imm_tag =
			   if num_imm_tags = 1 then 
			     get_imm_tag tagged_code
			   else if dflt_exists then dflt_tag
			   else Crash.impossible "Missing imm_tag or default"
                       in (MirTypes.GP_GC_REG tmp_reg,
                           MirTypes.COMMENT "select for ONE/INT/GP_GC_REG, 1 IMM_TAG" ::
                           MirTypes.TEST(MirTypes.BNT,
                                         imm_tag,
                                         gp_op,
                                         MirTypes.GP_IMM_ANY tag_test_mask) ::
                           (if num_vcc_tags = 0 then
                              [MirTypes.BRANCH(MirTypes.BRA,
                                               MirTypes.TAG dflt_tag)]
                            else
                              [con_tag_to_reg (reg, tmp_reg),
                               main_branch]),
                           num_vcc_tags <> 0)
                       end
d4353 1
a4353 1
             (* regs:  The switch argument, possible unboxed, literal or untupled *)
d4355 1
a4355 2
             (* the_code:  Code for producing the switch argument *)
             (* test_code:  Test code for relational tests *)
d4358 1
a4358 1
             val (regs, the_reg_opt, the_code, test_code, need_main_test,runtime_env',spills,calls) =
d4362 1
a4362 1
                   val (primAndTy, arg, is_struct) = 
d4364 2
a4365 6
                       AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, ...},
                                     [{lexp=AugLambda.STRUCT le_list, ...}],_) =>
                       (primAndTy, le_list, true)
                     | AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, ...},[arg],_) =>
                         (primAndTy, [arg], false)
                     | AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, ...},argl,_) =>
d4369 20
a4388 42
                   val lv_le_list = map (fn le => (LambdaTypes.new_LVar(), le)) arg

                   val (code, env', static_offset', start_at',runtime_env,spills,calls) =
                     cg_bind_list(lv_le_list, env,static_offset, start_at,
                                  (closure,funs_in_closure, fn_tag_list,tuple_bindings),
                                  maximum_spills,maximum_calls)

                   val lvar = case lv_le_list of
                     (lvar,_) :: _ => lvar
                   | _ => Crash.impossible"Empty arg to relation"

                   val new_test =
                     AugLambda.APP(
		       {lexp=AugLambda.BUILTIN primAndTy, size=0},
                       [{lexp=(if is_struct then
                                 AugLambda.STRUCT(map 
                                                  (fn (lvar,_) => {lexp=AugLambda.VAR lvar, size=0})
                                                  lv_le_list)
                               else AugLambda.VAR lvar),
			size=0}],
                        Debugger_Types.null_backend_annotation)

                   val (rest_regs, rest_code,runtime_env',spills,calls) =
                     cg_sub(new_test, env', static_offset', start_at',false,
                            (closure,funs_in_closure, fn_tag_list, tuple_bindings),spills,calls)

                   val runtime_env = 
                     case runtime_env of 
                       RuntimeEnv.LIST(runtime_envs) => 
                         RuntimeEnv.LIST(runtime_envs@@[runtime_env'])
                     | _ => Crash.impossible "new_test:SWITCH:_mir_cg.sml"

		   val (the_reg, extra) = Mir_Utils.send_to_reg rest_regs

		   val code =
		     Mir_Utils.combine(
		       code,
		       ((Sexpr.ATOM extra, [], Option.ABSENT, Sexpr.NIL),
			[],
			[]
		       )
		     )
d4390 2
a4391 2
                   (rest_regs, Option.PRESENT the_reg, code, 
                    rest_code, false,runtime_env,spills,calls)
a4413 1
		    no_code, (* No code generated for test *)
d4430 1
a4430 2
                   (* No test code here either *)
		   (regs, Option.ABSENT, block, no_code, true,runtime_env,spills,calls)
d4568 1
a4568 3
		    [],
		    []
		    )
d4630 1
a4630 1
                 end
d4669 3
a4671 5
                                            if need_main_test then
                                              Option.PRESENT do_test
                                            else
                                              Option.ABSENT)
                           )
d4707 1
a4707 1
			val (the_reg, extra) = Mir_Utils.send_to_reg regs
d4854 1
a4854 1
                          case regs of
d4904 1
a4904 1
                          case regs of
d4990 1
a4990 1
                     case regs of
a5021 81
               fun make_arg_code () =
               if is_rel then
                 (* Attempt to apply branch destination substitution *)
                 (* ie. case x < y of 0 => e1 | 1 => e2 becomes if x < y then e1 else e2 *)
                 let
                   val ((first, blocks, tag_opt, last), values, procs) = test_code
                   val _ = case blocks of
                     [] => ()
                   | _ => Crash.impossible"Test code for relation has blocks"
		   val first' = rev (Mir_Utils.contract_sexpr first)
		   val last_branch = case first' of
		     MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag) ::
		     (move_inst as
		      MirTypes.UNARY(MirTypes.MOVE, rn, MirTypes.GP_IMM_INT i)) ::
		     xs =>
		       let
			 val new_tag = if i = 1 then true_tag else false_tag
		       in
			 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG new_tag)
		       (* Remove the setup true/false in register *)
		       end
		   | _ => Crash.impossible
		       (implode
			("Bad relational expression code in\n" ::
			 "blocks =\n" ::
			 (map (fn x => MirPrint.block x ^ "\n") blocks) @@
			 ("Tag_opt = " ::
			  (case tag_opt of Option.ABSENT => "ABSENT"
			| Option.PRESENT tag => MirTypes.print_tag tag) ::
			     "\nfirst =\n" ::
			     (map (fn x => MirPrint.opcode x ^ "\n")
			      (Mir_Utils.contract_sexpr first)) @@
			     ("last =\n" ::
			      (map (fn x => MirPrint.opcode x ^ "\n")
			       (Mir_Utils.contract_sexpr last))))))
		       
		   val first' = Lists.tl(Lists.tl first')
		   val prev_branch = case first' of
		     MirTypes.TEST(cond_branch, tag, e1, e2) ::
		     (move_inst as
		      MirTypes.UNARY(MirTypes.MOVE, rn, MirTypes.GP_IMM_INT i)) ::
		     xs =>
		       let
			 val new_tag = if i = 1 then true_tag else false_tag
		       in
			 MirTypes.TEST(cond_branch, new_tag, e1, e2)
		       (* Remove the setup true/false in register *)
		       end
		   | MirTypes.FTEST(cond_branch, tag, e1, e2) ::
		     (move_inst as
		      MirTypes.UNARY(MirTypes.MOVE, rn, MirTypes.GP_IMM_INT i)) ::
		     xs =>
		       let
			 val new_tag = if i = 1 then true_tag else false_tag
		       in
			 MirTypes.FTEST(cond_branch, new_tag, e1, e2)
		       (* Remove the setup true/false in register *)
		       end
		   | _ => Crash.impossible
		       (implode
			("Bad relational expression code in\n" ::
			 "blocks =\n" ::
			 (map (fn x => MirPrint.block x ^ "\n") blocks) @@
			 ("Tag_opt = " ::
			  (case tag_opt of Option.ABSENT => "ABSENT"
			| Option.PRESENT tag => MirTypes.print_tag tag) ::
			     "\nfirst =\n" ::
			     (map (fn x => MirPrint.opcode x ^ "\n")
			      (Mir_Utils.contract_sexpr first)) @@
			     ("last =\n" ::
			      (map (fn x => MirPrint.opcode x ^ "\n")
			       (Mir_Utils.contract_sexpr last))))))
		   val new_first = rev(last_branch :: prev_branch ::
				       (Lists.tl(Lists.tl first')))
		 in
		   Mir_Utils.combine(the_code, ((Sexpr.ATOM new_first, [], tag_opt,
						 last), values, procs))
		 end
	       else
		 Mir_Utils.combine(the_code, test_code)

a5035 4
             (* Sort of the code for getting the argument to switch on *)

             val arg_code = make_arg_code ()

d5040 1
a5040 1
		(arg_code,
d5056 1
a5056 1
                                            maximum_calls,runtime_env)
d5766 1
a5766 1
      end
d5864 1
d5917 1
d5920 1
a5920 1
	  process_block(rev_app(tag_ref opcode, tags), opcode_list)
d5923 1
d5943 3
d5951 2
a5952 1
	    Option.ABSENT => blocks
d5956 2
a5957 4
		  val block_list =
		    Mir_Utils.append_small_exit(exit_block, blocks)
		  val old_block_map =
		    lists_reducel add_block (MirTypes.Map.empty, block_list)
d5959 1
a5971 2

    val new_procs' = new_procs
d5979 1
a5979 1
		  values, new_procs'),
@


1.261
log
@Adding GET_IMPLICIT pervasive
@
text
@d4 3
d3000 3
a3002 1
      
a3025 1
                                                   debug_polyvariables,
d3043 1
a3043 1
    val variable_debug = debug_variables orelse debug_polyvariables orelse generate_moduler
d3496 1
d3593 1
@


1.260
log
@Removing use of Types structure
@
text
@d4 3
d956 1
d977 1
d1001 1
a1001 1
  sharing TypeUtils.Datatypes.NewMap = Library.AugLambda.Debugger_Types.NewMap
d1042 1
a1042 1
  structure Options = Debugger_Types.Options
d1375 1
a1375 1
  (* Code generation utilities *)
d1380 1
a1380 1
	      val new_reg = MirTypes.GC.new()
d1382 1
a1382 1
	      (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG new_reg)),
d1384 1
a1384 1
                                             MirTypes.GC_REG new_reg,
d1392 16
a2557 1
            val scratch = MirTypes.GC.new()
d2559 1
a2559 1
            val scratch_reg = MirTypes.GC_REG scratch
d2583 26
a2608 25
          fun do_ref (regs,the_code) =
	  let
            val scratch = MirTypes.GC.new()
            val scratch_reg = MirTypes.GC_REG scratch
	    val (new_reg, code) = Mir_Utils.send_to_reg(regs)
	    val result = MirTypes.GC.new()
	    val res1 = MirTypes.GC_REG result
	    val work1 = MirTypes.GC_REG(MirTypes.GC.new ())
            val work2 = MirTypes.GC_REG(MirTypes.GC.new ())
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
	      Mir_Utils.combine(the_code,
		((Sexpr.ATOM(code @@
		  [MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, MirTypes.GP_IMM_INT 1),
		  MirTypes.COMMENT"Allocate a ref cell",
		  MirTypes.STOREOP(MirTypes.STREF, Mir_Utils.reg_from_gp new_reg, res1,
				   MirTypes.GP_IMM_ANY 9),
		  MirTypes.UNARY(MirTypes.MOVE, work1, MirTypes.GP_IMM_ANY 0),
		  MirTypes.STOREOP(MirTypes.STREF, work1, res1, MirTypes.GP_IMM_ANY 5),
                  MirTypes.UNARY(MirTypes.MOVE, work2, MirTypes.GP_IMM_INT 1),
                  MirTypes.STOREOP(MirTypes.STREF, work2, res1, MirTypes.GP_IMM_ANY 1),
		  MirTypes.COMMENT"Initialise the other pointers"]),
		  [], Option.ABSENT, Sexpr.NIL), [], [])))
	  end
          fun do_ml_offset (regs,the_code) = 
d2973 26
a2998 26
          fun do_call_c (regs,the_code) =
	  let
	    val res_reg = MirTypes.GC.new()
	    fun make_args_for_call_c arg =
	      let
		val get_result =
		  [MirTypes.CALL_C,
		   MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
				  MirTypes.GP_GC_REG caller_arg),
		   MirTypes.COMMENT"And acquire result"]
	      in
		case arg of
		  Mir_Utils.ONE (Mir_Utils.INT(reg)) =>
                    MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG caller_arg, reg) ::
                    get_result
                | _ => Crash.impossible "Bad arguments to make_args_for_call_c"
	      end
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG res_reg)),
	     Mir_Utils.combine (the_code, 
		      ((Sexpr.ATOM(make_args_for_call_c regs), [],
			Option.ABSENT, Sexpr.NIL),
		       [], [])))
	  end

          fun do_notb (regs,the_code) =
d3019 1
a3019 1
			  Options.COMPILEROPTIONS {debug,
a3038 1

d3045 1
a3045 1
        Option.PRESENT(ref([ref(RuntimeEnv.OFFSET1 1)]))
d3164 4
a3167 3
       fn () => AugLambda.count_gc_objects (new_lambda_exp,true
					    (*debug (always collect debug info)*),
                                            mapping,name_of_setup_function))
d3311 1
d3408 48
a3455 48
		  (Sexpr.ATOM[MirTypes.COMMENT"Start of poly eq",
			      MirTypes.TEST(MirTypes.BEQ, good_tag, reg1,
					    reg2),
		    (* Ok if equal values in the registers *)
		    MirTypes.BINARY(MirTypes.AND,
				    MirTypes.GC_REG(MirRegisters.global),
				    reg1, MirTypes.GP_IMM_ANY 3),
		    MirTypes.BINARY(MirTypes.AND,
				    MirTypes.GC_REG MirRegisters.global, reg2,
				    MirTypes.GP_GC_REG MirRegisters.global),
		    MirTypes.TEST(MirTypes.BNE, bad_tag,
				  MirTypes.GP_GC_REG(MirRegisters.global),
				  MirTypes.GP_IMM_ANY 1),
		    (* Is second one an ordinary pointer *)
		    MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG test_tag)],
		  [MirTypes.BLOCK(good_tag,
				  [MirTypes.UNARY(MirTypes.MOVE, gc_res_reg,
						  MirTypes.GP_IMM_INT 1),
				   MirTypes.BRANCH(MirTypes.BRA,
						   MirTypes.TAG final_tag)]),
		   MirTypes.BLOCK(bad_tag,
				  [MirTypes.UNARY(MirTypes.MOVE, gc_res_reg,
						  MirTypes.GP_IMM_INT 0),
				   MirTypes.BRANCH(MirTypes.BRA,
						   MirTypes.TAG final_tag)])],
		  Option.PRESENT test_tag, Sexpr.NIL)
		val new_code =
		  Mir_Utils.combine
		  (the_code,
		   Mir_Utils.combine
		   ((new_code, [], []),
		    Mir_Utils.combine
		    (Mir_Utils.combine(extra_code, poly_code),
		     ((Sexpr.ATOM(Mir_Utils.send_to_given_reg(reg, res_reg) @@
		       [MirTypes.BRANCH(MirTypes.BRA,
					MirTypes.TAG final_tag)]),
		       [], Option.PRESENT final_tag,
		       Sexpr.ATOM[MirTypes.COMMENT"End of poly eq"]),
		     [], []))))
	      in
		(Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG res_reg)),
		 new_code)
	      end
	  | _ =>
	      (reg,
	       Mir_Utils.combine(the_code,
				 Mir_Utils.combine(extra_code, poly_code)))
        end
d3595 2
d3746 1
d3779 1
d3784 1
d5325 1
d5327 1
a5327 1
               make_get_args_code (arg_regs,map #2 internal_regs)),
d5511 1
d5531 2
d5540 4
a5543 1
          ((Sexpr.ATOM(comment_for_name @@ [MirTypes.ENTER (map MirTypes.GC arginfo)]),
d5620 4
d5627 3
a5629 19
               Option.PRESENT loop_tag, 
               if intercept then
                 case fn_args of
                   [fn_arg] =>
                     (case (Mir_Env.lookup_lambda (fn_arg, env)) of
                        MLWorks.Option.SOME (MirTypes.GC reg) =>
                          Sexpr.ATOM
                          ((if insert_interrupt then [MirTypes.INTERRUPT] else []) @@
                              [MirTypes.UNARY(MirTypes.MOVE,
                                              MirTypes.GC_REG callee_arg,
                                              MirTypes.GP_GC_REG reg),
                               MirTypes.INTERCEPT,
                               MirTypes.UNARY(MirTypes.MOVE,
                                              MirTypes.GC_REG callee_arg,
                                              MirTypes.GP_GC_REG reg)])
                      | _ => Crash.impossible "fn_arg not GC register")
                 | _ => 
                     Sexpr.ATOM ((if insert_interrupt then [MirTypes.INTERRUPT] else []) @@
                                 [MirTypes.INTERCEPT])
d5631 1
a5631 4
                 if insert_interrupt then
                   Sexpr.ATOM[MirTypes.INTERRUPT]
                 else
                   Sexpr.NIL),
d5894 1
d5946 1
a5946 1
    val entry =
d5960 1
a5960 1
	(Option.ABSENT, []) => (Sexpr.CONS(entry, last''), blocks)
d5962 1
a5962 1
	  (entry, MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr last'') ::
d5985 1
a5985 1
                                     head_spill(get_current_spills ()),Datatypes.Option.ABSENT))
@


1.259
log
@Renaming debugger_env to runtime_env
Other rationalizations of debugger stuff
@
text
@d4 4
a949 1
require "../utils/print";
a952 1
require "../lambda/lambdasub";
a955 1
require "../typechecker/types";
a971 1
  structure Print : PRINT
a975 1
  structure LambdaSub : LAMBDASUB
d986 1
a986 2
  structure Types : TYPES
  structure Type_Utils : TYPE_UTILS
d988 3
a990 5
  sharing Types.Datatypes.Ident.Location = Info.Location
  sharing LambdaSub.LT = LambdaPrint.LambdaTypes =
	  Library.AugLambda.LambdaTypes = InterProc.LambdaTypes =
    	  Mir_Utils.Mir_Env.LambdaTypes
  sharing Type_Utils.DataTypes = Types.Datatypes
d996 2
a997 2
  sharing Types.Datatypes.NewMap = Library.AugLambda.Debugger_Types.NewMap
  sharing LambdaPrint.LambdaTypes.Ident = Types.Datatypes.Ident
d999 1
a999 2
    Types.Datatypes.Option = MirPrint.MirTypes.Option
  sharing Library.AugLambda.Debugger_Types.Options = Types.Options
d1003 8
a1010 7
  sharing type Types.Datatypes.Ident.SCon = MirPrint.MirTypes.SCon
  sharing type LambdaPrint.LambdaTypes.Type = Types.Datatypes.Type
  sharing type Mir_Utils.Pervasives.pervasive = LambdaSub.LT.Primitive
  sharing type MirPrint.MirTypes.Debugger_Types.RuntimeEnv.Type = LambdaSub.LT.Type = Types.Datatypes.Type
  sharing type MirPrint.MirTypes.Debugger_Types.RuntimeEnv.Tyfun = LambdaSub.LT.Tyfun
  sharing type MirPrint.MirTypes.Debugger_Types.RuntimeEnv.Instance = LambdaSub.LT.Instance = 
    Types.Datatypes.Instance
d1015 1
a1015 1
  structure LambdaTypes = LambdaSub.LT
d1021 1
a1021 1
  structure Datatypes = Types.Datatypes
a1140 14
  (* The two type utilities we need *)

  fun is_integral2 primTy =
    case Types.the_type primTy of
      ty as Datatypes.RECTYPE _ =>
        Type_Utils.is_integral(Types.get_type_from_lab (Ident.LAB(Symbol.find_symbol "2"), ty))
    | _ => false

  fun is_integral3 primTy =
    case Types.the_type primTy of
      ty as Datatypes.RECTYPE _ =>
        Type_Utils.is_integral(Types.get_type_from_lab (Ident.LAB(Symbol.find_symbol "3"), ty))
    | _ => false

d3133 1
d3138 1
d3344 1
d3346 1
d3448 1
a3448 1
      | Pervasives.BECOMES => do_becomes (is_integral2 primTy,regs,the_code)
d3540 1
a3540 1
      | Pervasives.UPDATE => update_code (false, true,is_integral3 primTy,regs,the_code,exn_code_for_prim prim)
d3542 1
a3542 1
      | Pervasives.UNSAFE_UPDATE => update_code (false, false,is_integral3 primTy,regs,the_code,exn_code_for_prim prim)
d3548 2
a3549 2
      | Pervasives.BYTEARRAY_UPDATE => update_code (true, true,is_integral3 primTy,regs,the_code,exn_code_for_prim prim)
      | Pervasives.BYTEARRAY_UNSAFE_UPDATE => update_code (true, false,is_integral3 primTy,regs,the_code,exn_code_for_prim prim)
d3918 1
a3918 3
          (Diagnostic.output 2
           (fn _ => ["Selecting from literal struct - should have been optimized!"]);
           (Mir_Utils.ONE(Lists.nth(index, many)), the_code,
d3921 2
a3922 2
            else RuntimeEnv.EMPTY,spills,calls) handle
           Lists.Nth =>
d5871 1
a5871 3
	val _ = Print.print
	  ("The bad primitive\n" ^
	   LambdaPrint.string_of_lambda(LambdaTypes.BUILTIN prim))
d5873 1
a5873 1
	Crash.impossible"cg_sub(BUILTIN) (should have been translated)"
@


1.258
log
@Fix range testing in String.ordof
@
text
@d4 3
d1047 2
d3039 3
a3041 2
    (* first spill is used for control transfer determination *)
    val first_spill : RuntimeEnv.Offset ref list ref Option.opt = 
d3043 1
a3043 1
        Option.PRESENT(ref([ref(RuntimeEnv.OFFSET1(1))]))
d3047 8
a3054 7
    fun deref_spill() = 
      case first_spill of
        Option.ABSENT => Crash.impossible "deref_spill:mir_cg:mir_cg"
      | Option.PRESENT(first_spill) => !first_spill

    fun restore_spill() = 
      case first_spill of
d3056 1
a3056 1
      | Option.PRESENT(first_spill) => 
d3058 1
a3058 1
            val spill = !first_spill
d3060 1
a3060 1
            (fn _ => first_spill := spill)
d3063 5
a3067 4
    fun assign_spill() = 
      case first_spill of
        Option.ABSENT => Option.ABSENT
      | Option.PRESENT(first_spill) => 
d3069 1
a3069 1
            val spill = [ref(RuntimeEnv.OFFSET1(1))]
d3072 1
a3072 1
             Option.PRESENT(spill))
d3075 3
a3077 2
    fun assign_spill' spill = 
      case first_spill of
d3079 2
a3080 9
      | Option.PRESENT(first_spill) => 
          (case spill of
             Option.ABSENT => Crash.impossible "assign_spill':mir_cg:mir_cg"
           | Option.PRESENT(spill) => first_spill := spill)

    fun fetch_spill spill = 
      case spill of 
        Option.ABSENT => Crash.impossible "fetch_spill:mir_cg:mir_cg"
      | Option.PRESENT(spill) => spill
d3082 2
d3085 1
a3085 1
      case first_spill of
d3087 2
a3088 5
      | Option.PRESENT(first_spill) => 
          first_spill := 
          (case spill of 
             Option.ABSENT => Crash.impossible "append_spill:mir_cg:mir_cg"
           | Option.PRESENT(spill) => spill)::(!first_spill)
d3093 1
a3093 5
    val new_ref_slot = 
      if variable_debug then 
        fn slot =>Option.PRESENT(ref (RuntimeEnv.OFFSET1(slot)))
      else
        fn _ =>Option.ABSENT
d3095 2
d3101 1
a3101 1
          val ref_slot = deref_spill()
d3103 1
d3115 1
a3115 1
            (ref_slot,code),bs,ts,ops),vs,ps)
d3162 1
a3162 2
                                            mapping,name_of_setup_function,
                                            true))
d3315 1
a3315 1
           val runtime_env : RuntimeEnv.debugger_env ref = ref(RuntimeEnv.BUILTIN)
d3349 1
a3349 1
                       Option.PRESENT (exn_tag))
d3594 1
a3594 1
               Option.PRESENT(calls'),
d3626 2
a3627 2
          Option.PRESENT(ref (RuntimeEnv.VARINFO debug_info)) => debug_info
            | _ => Option.ABSENT
d3633 2
a3634 2
          Option.ABSENT => ((code,spills),Option.ABSENT)
        | Option.PRESENT(name,info,tyvar_slot) => 
d3636 7
a3642 8
              (* Don't know what this is about *)
              fun null_offset(Option.ABSENT) = true
                | null_offset _ = false
              fun assign_offset(Option.PRESENT(offset)) value = 
                offset := RuntimeEnv.OFFSET1(value)
                | assign_offset _ _ = Crash.impossible "assign_offset:mir_cg"
              fun fetch_offset(Option.PRESENT(offset)) = offset 
                | fetch_offset _ = Crash.impossible "assign_offset:mir_cg"
d3648 1
a3648 5
                   val (ref_slot,tyvar_slot) = 
                     if null_offset tyvar_slot
                       then (ref (RuntimeEnv.OFFSET1(slot)),false)
                     else (assign_offset tyvar_slot slot;
                           (fetch_offset tyvar_slot,true))
d3656 2
a3657 2
                   if tyvar_slot then Option.ABSENT
                   else Option.PRESENT(name,info,Option.PRESENT(ref_slot)))
d3662 1
a3662 5
                   val (ref_slot,tyvar_slot) = 
                     if null_offset tyvar_slot then 
                       (ref (RuntimeEnv.OFFSET1(slot)),false)
                     else (assign_offset tyvar_slot slot;
                           (fetch_offset tyvar_slot,true))
d3672 2
a3673 2
                   if tyvar_slot then Option.ABSENT
                   else Option.PRESENT(name,info,Option.PRESENT(ref_slot)))
d3678 1
a3678 5
                   val (ref_slot,tyvar_slot) = 
                     if null_offset tyvar_slot then 
                       (ref (RuntimeEnv.OFFSET1(slot)),false)
                     else (assign_offset tyvar_slot slot;
                           (fetch_offset tyvar_slot,true))
d3689 2
a3690 2
                   if tyvar_slot then Option.ABSENT
                   else Option.PRESENT(name,info,Option.PRESENT(ref_slot)))
d3704 1
a3704 1
         RuntimeEnv.LET([(RuntimeEnv.VARINFO debug_info,runtime_env)], runtime_env')
d3709 1
a3709 1
      (* shouldn't need this case now *)
d3711 1
d3718 1
a3727 4
(*
      val _ = Diagnostic.output 4 (fn i => ["Mir generating APP\n", LambdaPrint.string_of_lambda arg])
*)

d3964 1
a3964 5
        (case lexp of
           (* The lambda stage should have handled this case *)
           AugLambda.INT arg => Crash.impossible "_mir_cg: AugLambda.INT\n"
         | _ => 
           let
d4016 1
a4016 1
                                                             (MirTypes.DEBUG (fetch_spill ref_slot,
d4101 1
a4101 1
                                                                  (MirTypes.DEBUG (fetch_spill ref_slot,
d4233 1
a4233 1
                         else Crash.impossible "Missing vcc_tag or default"
d4462 1
a4462 1
             val runtime_env' : RuntimeEnv.debugger_env ref = ref runtime_env'
d5171 1
a5171 1
                     then RuntimeEnv.SWITCH(!runtime_env',fetch_spill ref_slot,
d5175 1
a5175 1
		end)
d5268 2
a5269 2
        val prev_first_spill = restore_spill()
        val _ = assign_spill()
d5357 1
a5357 1
            then RuntimeEnv.FN (name_string,runtime_env,head_spill(deref_spill()),instances)
d5373 1
a5373 1
        val _ = prev_first_spill()
d5394 1
a5394 1
      (* This badly needs rewriting *)
d5396 5
a5400 8
        Lists.reducer (fn (Option.PRESENT x,xs) => (RuntimeEnv.VARINFO x,RuntimeEnv.EMPTY)::xs
                        | (Option.ABSENT,xs) => xs)
        (map 
         (fn (lvar,Option.PRESENT (ref (RuntimeEnv.VARINFO (Option.PRESENT(name,ty,_))))) => 
               (Option.PRESENT(Option.PRESENT (name,ty,Option.ABSENT)))
           | (lvar,_) => Option.ABSENT)
        lv_list,
        nil)
d5540 1
a5540 1
      val prev_first_spill = restore_spill()
d5547 1
a5547 1
           val firstspill = assign_spill()
d5553 1
a5553 1
	   (make_call_code(0,entry_code),env, static, start,runtime_env,spills,calls,firstspill)
d5591 1
a5591 1
             (entry_code, env, static_offset, start_at,runtime_env,spills,calls,firstspill), 
d5594 1
a5594 1
           val _ = assign_spill' firstspill
d5636 1
a5636 1
            (runtime_env,spills,firstspill),
d5647 1
a5647 1
      val _ = prev_first_spill()
d5695 1
a5695 1
              then RuntimeEnv.FN(name,runtime_env,head_spill(fetch_spill first_spill),instances)
d5783 1
a5783 1
    | cg_sub(hand as AugLambda.HANDLE
a5787 7
(*
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating HANDLE\n",
		  LambdaPrint.string_of_lambda hand])
      val gc_objects_in_le = Mir_Utils.count_gc_objects le
*)
d5792 2
d5798 1
d5858 3
a5860 2
      val prev_first_spill = restore_spill()
      val _ = append_spill(ref_slot)
d5864 1
a5864 1
      val _ = prev_first_spill()
a5868 4
(* Moved to _mach_cg
	 MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG handler,
			  MirTypes.GC_REG handler, MirTypes.GP_IMM_ANY ~1),
*)
d5880 1
a5880 1
         RuntimeEnv.HANDLE(runtime_env',fetch_spill ref_slot,calls',calls,runtime_env)
d5893 1
a5893 1
    val firstspill = restore_spill()
d5895 5
a5899 1
    val (regs, ((first, blocks, tag_opt, last), values, proc_lists),runtime_env,(gc_spills,non_gc_spills,fp_spills),_) =
d5981 1
a5981 1
                      (firstspill();
d5983 1
a5983 1
                                     head_spill(deref_spill()),Datatypes.Option.ABSENT))
@


1.257
log
@Added code generation for various "unsafe" pervasives/
Added ALLOC_VECTOR
@
text
@d4 4
d2900 1
a2900 1
                                         MirTypes.GP_IMM_INT ~1, reg),
@


1.256
log
@Do store immediate formation after copy propagation
@
text
@d4 3
d1806 134
d2121 1
a2121 1
      fun vector_sub_code (regs,the_code,exn_code) =
d2131 1
a2131 1
          val ((new_reg, code),(new_reg', code')) =
d2134 2
a2135 2
                (Mir_Utils.send_to_new_reg(Mir_Utils.ONE offset),
                 Mir_Utils.send_to_new_reg(Mir_Utils.ONE vector))
d2144 1
a2144 1
                                    MirTypes.GP_IMM_ANY 3)]),
d2148 1
a2148 1
                                              MirTypes.GP_IMM_ANY ~1)]))
d2156 70
a2225 47
	  let
	    val (exn_blocks, exn_tag_opt) = exn_code
	    val exn_tag =
	      case exn_tag_opt
	      of Option.PRESENT tag => tag
	      |  _ => Crash.impossible "no exn_tag for Vector.sub"
	    val finish_tag = MirTypes.new_tag()
	    val main_tag = MirTypes.new_tag()
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT res2),
	     Mir_Utils.combine
	     (the_code,
	      ((Sexpr.ATOM
		(code @@ code' @@
		 [MirTypes.COMMENT "Check the subscript range"] @@
		 (if constantp then
		    if constant_value < 0 then
		      [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
		    else
		      []
		  else
		    [MirTypes.TEST(MirTypes.BLT, exn_tag, new_reg, MirTypes.GP_IMM_INT 0)]) @@
		    [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG MirRegisters.global,
				      Mir_Utils.reg_from_gp new_reg',
				      MirTypes.GP_IMM_ANY(~5)),
		     MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
				     MirTypes.GP_GC_REG MirRegisters.global,
				     MirTypes.GP_IMM_ANY 4),
		     MirTypes.BINARY(MirTypes.SUB,MirTypes.GC_REG MirRegisters.global,
				     MirTypes.GP_GC_REG MirRegisters.global,
				     new_reg),
		     MirTypes.TEST(MirTypes.BGE, main_tag,
				   MirTypes.GP_GC_REG MirRegisters.global,
				   MirTypes.GP_IMM_ANY 4),
		     MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]),
		MirTypes.BLOCK(main_tag,
			       [MirTypes.COMMENT "Vector subscript operation",
				MirTypes.BINARY(MirTypes.ADD,
						MirTypes.GC_REG MirRegisters.global,
						new_reg', new_reg),
				MirTypes.STOREOP(MirTypes.LD, res1,
						 MirTypes.GC_REG MirRegisters.global,
						 MirTypes.GP_IMM_ANY(~1)),
				MirTypes.BRANCH(MirTypes.BRA,
						MirTypes.TAG finish_tag)]) ::
		exn_blocks, Option.PRESENT finish_tag, Sexpr.NIL), [], [])))
	  end
d2408 136
d2853 1
a2853 1
      fun do_ordof (regs,the_code,exn_code) =
d2855 1
a2855 1
	  val (val1, val2, new_code) =
a2859 5
	  val (exn_blocks, exn_tag_opt) = exn_code
	  val exn_tag =
	    case exn_tag_opt
	    of Option.PRESENT tag => tag
	    |  _ => Crash.impossible "no exn_tag for ordof"
d2864 1
a2864 1
	    case val2 of
d2868 71
a2938 36
	  if is_constant andalso constant_value < 0 then
	    (Mir_Utils.ONE(Mir_Utils.INT res2),
	      Mir_Utils.combine(the_code,
	      ((Sexpr.ATOM[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)],
		exn_blocks, Option.ABSENT, Sexpr.NIL),
	       [], [])))
          else let
	    val (the_ptr, the_size, code) =
	      make_size_code(Mir_Utils.ONE(Mir_Utils.INT val1))
	    val final_instructions = case val2 of
	      MirTypes.GP_IMM_INT i =>
	        [MirTypes.STOREOP(MirTypes.LDB, res1, the_ptr,
				  MirTypes.GP_IMM_ANY(i-1)),
	         MirTypes.BINARY(MirTypes.ASL, res1,res2,
				 MirTypes.GP_IMM_ANY 2)]
	    | reg as MirTypes.GP_GC_REG _ =>
		[MirTypes.TEST(MirTypes.BGT, exn_tag,
		 	       MirTypes.GP_IMM_INT ~1, reg),
	         MirTypes.BINARY(MirTypes.LSR, res1, reg,
				 MirTypes.GP_IMM_ANY 2),
	         MirTypes.BINARY(MirTypes.ADD, res1, res2,
			         Mir_Utils.gp_from_reg the_ptr),
	         MirTypes.STOREOP(MirTypes.LDB, res1, res1,
				  MirTypes.GP_IMM_ANY ~1),
	         MirTypes.BINARY(MirTypes.ASL, res1,res2,
				 MirTypes.GP_IMM_ANY 2)]
	    | _ => Crash.impossible"Bad args for ordof"
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT res2),
	     Mir_Utils.combine(the_code,
	     	  ((Sexpr.ATOM(new_code @@ code @@
	           (MirTypes.TEST(MirTypes.BLE, exn_tag, the_size, val2) ::
		    final_instructions)),
	         exn_blocks, Option.ABSENT, Sexpr.NIL), [], [])))
	  end
	end
d3495 1
a3495 1
      | Pervasives.ORDOF => do_ordof (regs,the_code,exn_code_for_prim prim)
d3518 1
d3563 1
a3563 1
      | Pervasives.VECTOR_SUB => vector_sub_code (regs,the_code,exn_code_for_prim prim)
d3577 7
@


1.255
log
@Add immediate store operations
@
text
@d4 3
d5780 1
a5780 118
    fun convert_to_immediate_stores proc_list_list =
      if MachSpec.has_immediate_stores then
	let
	  fun gp_not_zero(MirTypes.GP_IMM_INT 0) = false
	    | gp_not_zero(MirTypes.GP_IMM_ANY 0) = false
	    | gp_not_zero _ = true

	  fun count_instr((gc_table, non_gc_table), opcode) =
	    let
	      val defines = MirTables.defined_by opcode
	      val uses = MirTables.referenced_by opcode
	      fun gc_add(table, element) =
		let
		  val so_far = MirTypes.GC.Map.apply_default'(table, 0, element)
		in
		  MirTypes.GC.Map.define(table, element, so_far+1)
		end
	      fun non_gc_add(table, element) =
		let
		  val so_far = MirTypes.NonGC.Map.apply_default'(table, 0, element)
		in
		  MirTypes.NonGC.Map.define(table, element, so_far+1)
		end
	      val reduce_gc = MirTypes.GC.Set.reduce gc_add
	      val reduce_non_gc = MirTypes.NonGC.Set.reduce non_gc_add
	    in
	      (reduce_gc (reduce_gc (gc_table, #gc defines), #gc uses),
	       reduce_non_gc (reduce_non_gc (non_gc_table, #non_gc defines), #non_gc uses))
	    end

	  fun convert_proc(proc as MirTypes.PROC(string, tag, params, block_list, debug_env)) =
	    let
	      val gc_reg_map = MirTypes.GC.Map.empty
	      val non_gc_reg_map = MirTypes.NonGC.Map.empty
	      val (gc_table, non_gc_table) =
		Lists.reducel
		(fn (tables, block as MirTypes.BLOCK(tag, opcode_list)) =>
		 Lists.reducel
		 count_instr
		 (tables, opcode_list))
		((gc_reg_map, non_gc_reg_map), block_list)
	      (* This tells us how often each virtual register occurs *)
	      (* In cases where the registers occurs only twice, *)
	      (* and it is of the form MOV rn, #x; ST rn, rm, #gp *)
	      (* We can convert the store into a store immediate and remove the move *)
	      (* Otherwise, we may not be able to remove the move *)
	      fun check_occurrences(MirTypes.GC_REG reg) =
		(case MirTypes.GC.Map.tryApply'(gc_table, reg) of
		   MLWorks.Option.SOME a => a
		 | _ => Crash.impossible"convert_proc looks up reg not in gc table")
		| check_occurrences(MirTypes.NON_GC_REG reg) =
		(case MirTypes.NonGC.Map.tryApply'(non_gc_table, reg) of
		   MLWorks.Option.SOME a => a
		 | _ => Crash.impossible"convert_proc looks up reg not in non_gc table")
	      fun do_block(done, []) = rev done
		| do_block(done, (move as MirTypes.UNARY(MirTypes.MOVE, reg, gp)) ::
			   (store as MirTypes.STOREOP(store_op, rn, rm, gp')) ::
			   rest) =
		  let
		    val is_load =
		      case store_op of
			MirTypes.LD => true
		      | MirTypes.LDB => true
		      | MirTypes.LDREF => true
		      | _ => false
		  in
		    if reg = rn then
		      if is_load then
			Crash.impossible"Load overwrites preceding move"
		      else
			if check_occurrences reg = 2 then
			  if gp_not_zero gp then
			    let
			      val new_store =
				MirTypes.IMMSTOREOP(store_op, gp, rm, gp')
			    in
			      ((*output(std_out, "Replacing move,store pair with store imm\n");*)
			       do_block(new_store :: done, rest))
			    end
			  else
			    ((*output(std_out, "Not replacing move, store pair because immediate is zero\n");*)
			     do_block(store :: move :: done, rest))
			else
			  ((*output(std_out,
				  "Not replacing move,store pair with move,store imm\n" ^
				  "because " ^
				  MLWorks.Integer.makestring (check_occurrences reg) ^
				  " occurrences of register found\n");*)
			  do_block(store :: move :: done, rest))
		    else
		      do_block(store :: move :: done, rest)
		  end
		| do_block(done, (move as MirTypes.UNARY(MirTypes.MOVE, reg, gp)) :: rest) =
		  let
(*
		    val _ =
		      if check_occurrences reg = 2 then
			output(std_out, "Found move immediate register with two non-adjacent occurences of register\n")
		      else
			()
*)
		  in
		    do_block(move :: done, rest)
		  end
		| do_block(done, opcode :: rest) = do_block(opcode :: done, rest)
	    in
	      MirTypes.PROC(string, tag, params,
			    map (fn (MirTypes.BLOCK(tag, opcodes)) =>
				 MirTypes.BLOCK(tag, do_block([], opcodes)))
			    block_list, debug_env)
	    end
	in
	  map (fn proc_list => map convert_proc proc_list) proc_list_list
	end
      else
	new_procs

    val new_procs' = convert_to_immediate_stores new_procs
@


1.254
log
@Replaced use of BIC with shifts in array lengths.
BIC is hard to translate for the MIPS.
It is still used in one place.
@
text
@d4 5
d950 1
d970 1
d982 2
a983 1
  sharing MirRegisters.MirTypes = MirPrint.MirTypes = Mir_Utils.Mir_Env.MirTypes
d5151 14
a5164 9
      | _ => Sexpr.CONS
	  (code,
	   Sexpr.ATOM
	   (MirTypes.UNARY(MirTypes.MOVE, gc_reg, MirTypes.GP_IMM_INT 0) ::
	    map
	    (fn x =>
	     MirTypes.STOREOP(MirTypes.ST, gc_reg, cl_reg,
			      MirTypes.GP_IMM_ANY(4*(x-1)-1)))
	    (Lists.tl offsets)))
d5690 1
d5777 118
a5894 1
    val new_procs' = new_procs
@


1.253
log
@Fixing problem with intercept code and multiple arguments
@
text
@d4 3
d1622 6
a1627 4
	  val shift_code = case val2 of
	    MirTypes.GP_IMM_INT i =>
	      MirTypes.BINARY(mir_operator,MirTypes.GC_REG result, val1,
			      MirTypes.GP_IMM_ANY i) :: clear_code
d1629 6
a1634 6
	  | _ => 
	      MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
			      val2, MirTypes.GP_IMM_ANY 2) ::
	      MirTypes.BINARY(mir_operator,MirTypes.GC_REG result,val1,
			      MirTypes.GP_GC_REG MirRegisters.global) ::
	      clear_code
d1809 4
a1812 1
                                     MirTypes.GP_GC_REG result,MirTypes.GP_IMM_ANY 4),
d1814 3
a1816 1
                                     MirTypes.GP_GC_REG result,MirTypes.GP_IMM_ANY 3)]),
d1839 4
a1842 1
                                     MirTypes.GP_GC_REG result, MirTypes.GP_IMM_ANY 4),
d1844 3
a1846 1
                                     MirTypes.GP_GC_REG result, MirTypes.GP_IMM_ANY 3)]),
@


1.252
log
@Make continuation offsets for handlers guaranteed tagged integers
@
text
@d4 3
d5275 3
a5277 1
                 | _ => Crash.impossible "Arglist in intercept code"
@


1.251
log
@Make lookup_in_closure return an Option value
Some reformatting and tidying up
This is ongoing work really
@
text
@d4 5
d5498 2
@


1.250
log
@Also array update
@
text
@d4 3
d1096 1
a1096 1
    | bandf_opt(vars, _) = vars
d1104 1
a1104 1
    | do_pos2(pos, (tag, _) :: rest) =
d1208 1
a1208 1
      AugLambda.APP({lexp=AugLambda.BUILTIN(prim,_), ...}, _,_) =>
d1248 1
a1248 1
              NewMap.YES lv => Set.add_member(lv, new)
d1336 1
a1336 1
            val add_members = LambdaTypes.Map.fold (fn (set, x, _) => HashSet.add_member(set, x))
d2772 1
a2772 1
        LambdaTypes.Map.YES x => x
d2838 5
a2842 2
    fun cg_bind({lexp=lexp, size=gc_in_arg}, env, closure, static_offset,
		start_at, funs_in_closure, fn_tag_list,spills,calls) =
d2845 3
a2847 2
	val (regs, the_code,runtime_env,spills,calls) =
	  cg_sub(lexp, env, closure,static_offset, start_at,funs_in_closure, fn_tag_list, false, [],spills,calls)
d2854 1
a2854 1
                   (MirTypes.GC x, [MirTypes.COMMENT"Function argument"])
d2856 1
a2856 1
                   (MirTypes.NON_GC x, [MirTypes.COMMENT"Function argument"])
d2864 1
a2864 2
                                      reg),
                       MirTypes.COMMENT "Function argument"])
d2873 1
a2873 2
                                      reg),
                       MirTypes.COMMENT "Function argument"])
d2877 1
a2877 1
              (MirTypes.FLOAT fp_reg, [MirTypes.COMMENT "Function argument"])
d2881 1
a2881 2
                (MirTypes.GC gc_reg,
                 MirTypes.COMMENT "Function argument" :: more_code)
d2885 1
a2885 4
	 Mir_Utils.combine(the_code,
			   ((Sexpr.ATOM more_code, [], Option.ABSENT,
			     Sexpr.NIL),
			    [], [])),
d2890 1
a2890 1
    and cg_bind_list([], env, _, static_offset, start_at, _, _,spills,calls) =
d2893 2
a2894 1
    | cg_bind_list((lv, le) :: rest, env, closure, static_offset, start_at,funs_in_closure, fn_tag_list,spills,calls) =
d2897 6
a2902 6
	  cg_bind(le, env, closure, static_offset, start_at, funs_in_closure,
		  fn_tag_list,spills,calls)
	val env' = Mir_Env.add_lambda_env((lv, reg), env)
	val (new_code, env, static_offset, start_at,runtime_envs,spills,calls) =
	  cg_bind_list(rest, env', closure, static_offset', start_at',
                       funs_in_closure, fn_tag_list,spills,calls)
d2914 4
a2917 4
    and cg_sub(arg as AugLambda.APP
	       ({lexp=AugLambda.BUILTIN(prim,primTy), ...},
		[{lexp=lexp, size=gc_objects_in_parm}],_), env, closure,
	       static_offset, start_at, funs_in_closure, fn_tag_list, tails,_,spills,calls) =
d2947 2
a2948 1
             cg_sub(lexp, env, closure, static_offset, start_at, funs_in_closure,fn_tag_list, false, [],spills,calls)
d2968 2
a2969 1
                                     env,closure,static_offset, start_at, funs_in_closure,fn_tag_list, false, [],!spills,!calls)
a3018 1
                        closure,
d3020 3
a3022 2
                        start_at + gc_objects_in_parm, funs_in_closure,
                        fn_tag_list, tails, [],!spills,!calls)
d3236 3
a3238 2
             env,closure, static_offset, start_at, funs_in_closure, fn_tag_list,
	     tails, tuple_bindings,spills,calls) =
d3246 6
a3257 6
      (* Code generate the bound expression *)
      val (reg, code, static_offset', start_at', runtime_env,
           spills as (gc_spills,non_gc_spills,fp_spills),calls) =
	cg_bind(lexp2, env, closure, static_offset, start_at, funs_in_closure,
		fn_tag_list,spills,calls)

d3341 2
a3342 2
	cg_sub(lexp1, env', closure, static_offset', start_at',
	       funs_in_closure, fn_tag_list, tails, tuple_bindings,spills,calls)
d3355 3
a3357 2
	     closure, static_offset, start_at, funs_in_closure, fn_tag_list,
	     tails, tuple_bindings,spills,calls) =
d3362 3
a3364 3
				  arg_list,debugger_information), env, closure,
	     static_offset, start_at,
	     funs_in_closure, fn_tag_list, tails, tuple_bindings,spills,calls) =
d3397 2
a3398 2
            (cg_sub(le1, env, closure, static_offset, start_at, funs_in_closure,
                    fn_tag_list, false, [],spills,calls+1),
d3408 2
a3409 4
            cg_sub(le2, env, closure,
                   static_offset + gc_objects_in_call,
                   start_at + gc_objects_in_call, funs_in_closure, fn_tag_list,
                   false, [],spills,calls')
d3441 1
a3441 1
            cg_sub(AugLambda.STRUCT arg_list, env, closure,
d3443 3
a3445 2
                   start_at + gc_objects_in_call, funs_in_closure, fn_tag_list,
                   false, [],spills,calls')
d3475 2
a3476 2
    | cg_sub(arg as AugLambda.STRUCT le_list, env, closure, static_offset, start_at,
	   funs_in_closure, fn_tag_list, _, _,spills,calls) =
d3491 1
a3491 1
	fun make_code([], _,spills,calls) = ([],no_code,[],spills,calls)
d3495 2
a3496 3
		cg_sub(le, env, closure,
		       static_offset + pos, start_at + pos, funs_in_closure,
		       fn_tag_list, false, [],spills,calls)
d3539 3
a3541 2
	     env, closure,
	     static_offset, start_at, funs_in_closure, fn_tag_list, _, _,spills,calls) =
d3551 2
a3552 2
	cg_sub(lexp, env, closure, static_offset,
	       start_at, funs_in_closure, fn_tag_list, false, [],spills,calls)
d3592 2
a3593 2
	     env, closure, static_offset, start_at, funs_in_closure,
	     fn_tag_list, tails, tuple_bindings,spills,calls) =
d3601 1
a3601 1
          (fn (x, (tag, _)) => x + count_gc_tags tag)
d3622 2
a3623 2
                 (AugLambda.IMM_TAG _, _) :: _ => true
               | (AugLambda.VCC_TAG _, _) :: _ => true
d3646 3
a3648 3
                       cg_sub(lexp, env, closure, static_offset, start_at,
                              funs_in_closure, fn_tag_list, tails,
			      tuple_bindings,(slot,non_gc_spills,fp_spills),calls)
d3718 2
a3719 2
	  	   (fn ((nv, ni), (AugLambda.IMM_TAG _, _)) => (nv, ni + 1)
		    |  ((nv, ni), (AugLambda.VCC_TAG _, _)) => (nv + 1, ni)
d3734 3
a3736 3
                             cg_sub(x, env, closure, static_offset + le_offset,
                                    start_at + le_offset, funs_in_closure, fn_tag_list,
                                    tails, tuple_bindings,(slot,non_gc_spills,fp_spills),calls)
d3764 3
a3766 3
                     cg_sub(x, env, closure, static_offset + le_offset,
                            start_at + le_offset, funs_in_closure, fn_tag_list,
                            tails, tuple_bindings,(slot,non_gc_spills,fp_spills),calls)
d3805 1
a3805 1
                   ([(AugLambda.IMM_TAG (_,t1), _, tag)], Option.PRESENT _) =>
d3807 2
a3808 2
                 | ([(AugLambda.IMM_TAG (_,t1), _, tag),
                     (AugLambda.IMM_TAG (_,t2), _, tag')], Option.ABSENT) =>
d3817 1
a3817 1
	     |   get_vcc_tag ((AugLambda.VCC_TAG _, _, tag) :: _) = tag
d3821 1
a3821 1
	     |   get_imm_tag ((AugLambda.IMM_TAG t, _, tag) :: _) = tag
d4014 1
a4014 1
                     | AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, ...},[arg], _) =>
d4016 1
a4016 1
                     | AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, ...},argl, _) =>
d4023 2
a4024 2
                     cg_bind_list(lv_le_list, env, closure, static_offset,
				  start_at, funs_in_closure, fn_tag_list,
d4028 1
a4028 1
                     (lvar, _) :: _ => lvar
d4036 1
a4036 1
                                                  (fn (lvar, _) => {lexp=AugLambda.VAR lvar, size=0})
d4043 2
a4044 2
                     cg_sub(new_test, env', closure, static_offset', start_at',
                            funs_in_closure, fn_tag_list, false, [],spills,calls)
d4071 3
a4073 2
                     cg_sub(lexp, env, closure, static_offset, start_at,
                            funs_in_closure, fn_tag_list, false, [],maximum_spills,maximum_calls)
d4095 3
a4097 3
                     cg_sub(lexp, env, closure, static_offset, start_at,
                            funs_in_closure, fn_tag_list, 
                            false, [],maximum_spills,maximum_calls);
d4100 3
a4102 9
		     Mir_Utils.combine(
		       the_code,
		       ((Sexpr.ATOM [main_branch],
                         [],
                         Option.ABSENT,
                         Sexpr.NIL),
                        [],
                        [])
		       )
d4115 1
a4115 1
             fun make_cgt(MirTypes.GP_IMM_INT _, _, _, _) =
d4117 1
a4117 1
               | make_cgt(MirTypes.GP_IMM_ANY _, _, _, _) =
d4119 1
a4119 1
               | make_cgt(MirTypes.GP_IMM_SYMB _, _, _, _) =
d4141 2
a4142 2
                         | expand ([(_, _, tag)]) = [tag]
                         | expand ((i, _, tag) :: (rest as ((j, _, _) :: _))) =
d4150 1
a4150 1
		     (fn ((_, (_, (_, value, _),_,_,_), _), value') =>
d4156 1
a4156 1
		     (fn ((_, (_, (_, _, proc),_,_,_), _), proc') => proc @@ proc')
d4161 1
a4161 1
                     (fn (_, (regs, ((first, blocks, tag_opt, last), _, _),_,_,_),tag) =>
d4273 1
a4273 1
				    Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag, _, _)] =>
d4314 1
a4314 1
                     Lists.qsort (fn ((i:int, _, _), (i', _, _)) => i < i')
d4335 1
a4335 1
                         fun do_test(reg, i, _, tag) =
d4390 1
a4390 1
			    Lists.qsort (fn ((i:int, _, _, _), (i', _, _, _)) =>
d4416 1
a4416 1
				      (fn (x, _, y, z) => (x, y, z))
d4420 1
a4420 1
			      fun do_test(reg, i, _, tag) =
d4437 1
a4437 1
			    fun to_string(Ident.INT(i, _)) = i
d4444 1
a4444 1
			      (fn ((i, _, _, _), (i', _, _, _)) =>
d4458 1
a4458 1
                                (scon, _, _, _) :: _ => scon
d4462 1
a4462 1
                                (scon, _, _, _) => scon
d4467 6
a4472 5
				  val (reg, the_code) = (case
				    cg_sub(Mir_Utils.convert_long_int high, env,
					   closure, static_offset, start_at,
					   funs_in_closure, fn_tag_list, 
                                           false, [],!spills,!calls) of
d4488 1
a4488 1
			    fun do_test(reg, long_i, _, tag) =
d4492 3
a4494 3
					 closure, static_offset, start_at,
					 funs_in_closure, fn_tag_list, 
                                         false, [],!spills,!calls) of
d4537 1
a4537 1
                        fun do_test(reg, i, _, tag) =
d4561 1
a4561 1
                          (fn (p, (t, _)) =>
d4587 1
a4587 1
                        fun do_test(reg, i, _, tag) =
d4598 2
a4599 2
                                     env, closure, static_offset, start_at,
                                     funs_in_closure, [], false, [],!spills,!calls)
d4644 1
a4644 1
                          (fn (p, (t, _)) =>
d4673 1
a4673 1
                   fun do_test(reg, _, le, tag) =
d4679 2
a4680 2
                         case cg_sub(le, env, closure, static_offset, start_at,
                                     funs_in_closure, [], false, [],!spills,!calls) of
d4791 4
a4794 4
             | (AugLambda.IMM_TAG _, _) :: _ => constructor_code ()
             | (AugLambda.VCC_TAG _, _) :: _ => constructor_code ()
             | (AugLambda.SCON_TAG scon, _) :: rest => scon_code scon
             | (AugLambda.EXP_TAG _, _) :: rest => exp_code ()
d4826 1
a4826 2
    | cg_sub(arg as AugLambda.VAR lvar, env, closure, _, _, funs_in_closure,
	     _, _, _,spills,calls) =
d4840 1
a4840 1
    | cg_sub(arg as AugLambda.INT i, _, _, _, _, _, _, _, _,spills,calls) =
d4852 2
a4853 2
    | cg_sub(arg as AugLambda.SCON scon, e, c, static_offset, start_at,
	     funs_in_closure, fn_tag_list, tails, tuple_bindings,spills,calls) =
d4869 2
a4870 2
	     (cg_sub(Mir_Utils.convert_long_int scon, e, c, static_offset,
		    start_at, funs_in_closure, fn_tag_list, tails, tuple_bindings,spills,calls)
d4885 1
a4885 1
				       (funs_in_closure * 2 - 1)) - 1))],
d4892 2
a4893 2
    | cg_sub(arg as AugLambda.MLVALUE mlvalue, _, _, static_offset, start_at,
	     funs_in_closure, _, _, _,spills,calls) =
d4913 2
a4914 2
	     env, closure, static_offset,
	     start_at, funs_in_closure, fn_tag_list, _, _,spills,calls) =
d4974 3
a4976 5
          cg_sub(lexp,
                 lambda_env,
                 (* All bets for registers are off, barring the arguments *)
                 new_closure, 0, start_at, 1, [tag] (* tag for this function *),
                 true, [],(1,0,0),0)
d5032 2
a5033 2
	     env, closure,
	     static_offset, start_at, funs_in_closure, fn_tag_list, _, _,spills,calls) =
d5059 1
a5059 1
	(fn {lexp=AugLambda.FN(lvl, le, _,_), ...} => (lvl, le)
d5195 2
a5196 2
	     cg_bind_list(bindings, env, new_closure, pos, start_at + pos,
			  funs - (x div 2), tags,(1,0,0),0)
d5216 4
a5219 2
	 (fn (lv, {lexp=AugLambda.SELECT({index = index, ...}, _), ...}) =>
	  (index, Mir_Env.lookup_lambda (lv, env))
d5243 2
a5244 2
                cg_sub(lexp, env, new_closure, static_offset, start_at,
                       funs - x div 2, tags, true, tuple_bindings,spills,calls)
d5256 1
a5256 1
                        MirTypes.GC reg =>
d5296 1
a5296 1
	  fun send (res, _, _, _) =
d5360 1
a5360 1
	(fn ((value, _, _), value') => value @@ value')
d5366 1
a5366 1
	(fn ((_, procs, _), procs') => procs @@ procs')
d5382 3
a5384 4
	cg_sub(lexp, Mir_Env.augment_lambda_env (env, letrec_env), closure,
	       static_offset + gc_objects_within + funs,
	       start_at + gc_objects_within + funs, funs_in_closure,
	       fn_tag_list, false, [],spills,calls)
d5399 2
a5400 2
    | cg_sub(arg as AugLambda.RAISE({lexp=le, ...}), env, closure, static_offset,
	     start_at, funs_in_closure, fn_tag_list, _, _,spills,calls) =
d5403 2
a5404 2
	cg_sub(le, env, closure, static_offset, start_at, funs_in_closure,
	       fn_tag_list, false, [],spills,calls+1)
d5429 2
a5430 2
	       env, closure, static_offset,
	       start_at, funs_in_closure, fn_tag_list, _, _,spills,calls) =
d5450 3
a5452 4
	cg_sub(le', env, closure,
	       static_offset + gc_objects_in_le,
	       start_at + gc_objects_in_le, funs_in_closure, fn_tag_list,
	       false, [],spills,calls)
d5507 2
a5508 2
	cg_sub(le, env, closure, static_offset, start_at, funs_in_closure,
	       fn_tag_list, false, [],spills,calls')
d5533 2
a5534 2
    | cg_sub(AugLambda.BUILTIN(prim,_), env, closure, static_offset,
	     start_at, funs_in_closure, fn_tag_list, _, _,_,_) =
d5545 2
a5546 2
      cg_sub(new_lambda_exp, Mir_Env.empty_lambda_env,
	     Mir_Env.empty_closure_env, 0, 0, 1, [new_tag], false, [],(1,0,0),0)
d5604 1
a5604 1
      | (Option.PRESENT tag, _) =>
d5607 1
a5607 1
      | (Option.ABSENT, _) =>
d5640 1
a5640 1
      fun tag_ref(TBINARY(_, tag_opt, _, _, _)) = get_opt tag_opt
d5644 2
a5645 2
	| tag_ref(TBINARYFP(_, tag_opt, _, _, _)) = get_opt tag_opt
	| tag_ref(TUNARYFP(_, tag_opt, _, _)) = get_opt tag_opt
d5652 1
a5652 1
	| tag_ref(FLOOR(_, tag, _, _)) = [tag]
d5657 2
a5658 2
	| tag_ref(TEST(_, tag, _, _)) = [tag]
	| tag_ref(FTEST(_, tag, _, _)) = [tag]
d5668 1
a5668 1
	| tag_ref(SWITCH(_, _, tag_list)) = tag_list
d5672 1
a5672 1
	| tag_ref(ADR(_, _, tag)) = [tag]
d5693 2
a5694 2
	    Map.YES _ => process_blocks(old_block_map, new_block_map, tag_list)
	  | Map.NO =>
d5696 1
a5696 1
		Map.YES(block as BLOCK(_, opcodes)) =>
d5699 1
a5699 1
	      | Map.NO =>
d5706 1
a5706 1
    fun add_block(map, block as MirTypes.BLOCK(tag, _)) =
@


1.249
log
@Tidying up
@
text
@d4 3
d1661 3
d1724 1
a1724 1
                                             MirTypes.GC_REG MirRegisters.global,
d1731 1
a1731 1
                                                  MirTypes.GC_REG MirRegisters.global,
d1734 2
a1735 2
                                                 MirTypes.GC_REG MirRegisters.global,
                                                 MirTypes.GP_GC_REG MirRegisters.global,
d1745 1
d1750 1
a1750 1
                                                  MirTypes.GC_REG MirRegisters.global,
d1753 2
a1754 2
                                                 MirTypes.GC_REG MirRegisters.global,
                                                 MirTypes.GP_GC_REG MirRegisters.global,
d1762 1
d2130 4
a2133 4
                             if bytearray then
                               let
                                 val address = MirTypes.GC.new ()
                               in
d2145 23
a2167 17
                               end
                             else
                               [MirTypes.COMMENT ((if safe then "" else "Unsafe ") ^ "Array update operation"),
                                MirTypes.BINARY(MirTypes.ADD,
                                                MirTypes.GC_REG MirRegisters.global,new_reg',new_reg),
                                MirTypes.STOREOP(MirTypes.STREF,Mir_Utils.reg_from_gp new_reg'',
                                                 MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9)] @@
                               (if isIntegral then
                                  [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]
                                else
                                  [MirTypes.COMMENT"Do we need to unlink it",
                                   MirTypes.STOREOP(MirTypes.LDREF, forward_reg,
                                                    Mir_Utils.reg_from_gp reg1,
                                                    MirTypes.GP_IMM_ANY 1),
                                   MirTypes.TEST(MirTypes.BEQ, finish_tag, MirTypes.GP_GC_REG forward,
                                                 MirTypes.GP_IMM_INT 0),
                                   MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG unlink_tag)])) ::
a2178 8
                                (*
                                 MirTypes.STOREOP(MirTypes.LDREF, forward_reg,
                                 Mir_Utils.reg_from_gp reg1,
                                 MirTypes.GP_IMM_ANY 1),
                                 MirTypes.STOREOP(MirTypes.LDREF, backward_reg,
                                 Mir_Utils.reg_from_gp reg1,
                                 MirTypes.GP_IMM_ANY 5),
                                 *)
d2472 1
d2483 2
a2484 2
                  MirTypes.UNARY(MirTypes.MOVE,MirTypes.GC_REG MirRegisters.global,MirTypes.GP_IMM_ANY 0),
                  MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG MirRegisters.global, res2,
d2486 1
a2486 1
		  MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
d2488 4
a2491 2
                  MirTypes.STOREOP(MirTypes.STB, MirTypes.GC_REG MirRegisters.global, res2,
                                   MirTypes.GP_IMM_ANY ~1)]), exn_blocks,
d4547 1
a4547 1
				       (MirTypes.LD, MirTypes.GC_REG(MirRegisters.global),
d4554 1
a4554 1
                                        MirTypes.GC_REG(MirRegisters.global),
@


1.248
log
@Remove handler register concept
@
text
@d4 3
d1013 9
d1050 1
a1050 1
  val empty_string_tree = NewMap.empty' String.<
d1055 1
a1055 1
    | AugLambda.LET(_,_,lb,le) => 
d1061 1
a1061 1
	Lists.reducel
d1161 2
a1162 1
          | assign (arg::rest,reg::restregs,acc) = assign (rest,restregs,(arg,reg)::acc)
d1172 28
d1239 1
a1239 1
          Lists.reducel
d1261 1
a1261 1
      (Lists.reducel
d1271 1
a1271 1
	(lv,Option.ABSENT,
d1277 1
a1277 1
	      size=0}, le), size=size})
d1343 1
a1343 1
            (Lists.reducel
d1374 1
a1374 1
	    | _ => Crash.impossible "cg_sub(BUILTIN 0)"
d1399 1
a1399 1
	  | _ => Crash.impossible"cg_sub(BUILTIN 1)"
d1429 1
a1429 1
	    | _ => Crash.impossible"cg_sub(BUILTIN 0)"
d1440 1
a1440 1
	  | _ => Crash.impossible"cg_sub(BUILTIN 1)"
d1457 1
a1457 1
                                 | _ => Crash.impossible"cg_sub(BUILTIN 1)"),
d1476 1
a1476 1
		| _ => Crash.impossible"cg_sub(BUILTIN 1)"),
d1489 1
a1489 1
	    | _ => Crash.impossible"cg_sub(BUILTIN 0)"
d1527 1
a1527 1
	      | _ => Crash.impossible"cg_sub(BUILTIN 0)"
d1580 1
a1580 1
	    | _ => Crash.impossible"cg_sub(binary_calc)"
d1598 1
a1598 1
	    | _ => Crash.impossible"cg_sub(do_shift_operator)"
d2485 1
a2485 1
	  | _ => Crash.impossible"cg_sub(BUILTIN 1)"
d2517 1
a2517 1
	    | _ => Crash.impossible"cg_sub(BUILTIN 0)"
d2586 1
a2586 1
	  | _ => Crash.impossible"cg_sub(BUILTIN 1)"
d2770 1
a2770 1
      (Lists.reducel
d2831 1
a2831 2
	  cg_sub(lexp, env, closure, static_offset, start_at, funs_in_closure,
		 fn_tag_list, false, [],spills,calls)
d2883 1
a2883 2
    | cg_bind_list((lv, le) :: rest, env, closure, static_offset, start_at,
		   funs_in_closure, fn_tag_list,spills,calls) =
d2906 1
a2906 2
	       static_offset, start_at, funs_in_closure, fn_tag_list, tails,
	       _,spills,calls) =
d2936 1
a2936 2
             cg_sub(lexp, env, closure, static_offset, start_at, funs_in_closure,
                    fn_tag_list, false, [],spills,calls)
d2956 1
a2956 4
                                     env,
                                     closure,
                                     static_offset, start_at, funs_in_closure,
                                     fn_tag_list, false, [],!spills,!calls)
d3222 1
a3222 1
    | cg_sub(arg as AugLambda.LET (lvar, info,lexp2, {lexp=lexp1,...}),
d3507 1
a3507 1
	  Lists.reducel
d3583 1
a3583 1
          Lists.reducel (fn (x:int, (_, {size=size, lexp=_})) => x + size)
d3586 1
a3586 1
          Lists.reducel
d3703 1
a3703 1
	         Lists.reducel
d3772 1
a3772 1
                 Lists.reducel 
d3779 1
a3779 1
               Lists.reducel 
d4939 1
a4939 1
        val arg_reg_copies = map (fn (var,reg) => (var,reg,MirTypes.GC.new())) arg_regs
d4948 1
d4952 1
a4952 1
            [MirTypes.ENTER (map (fn (_,reg,_) => MirTypes.GC reg) arg_reg_copies)] @@
d4954 1
a4954 7
             (* "Move the arguments to somewhere safe, and let register colouring deal with allocation" *)
             map
             (fn (_,arg,copy) =>
              MirTypes.UNARY(MirTypes.MOVE, 
                             MirTypes.GC_REG copy,
                             MirTypes.GP_GC_REG arg))
             arg_reg_copies),
d4958 2
a4959 2
          Lists.reducel
          (fn (env,(lvar,reg,copy)) =>
d4961 1
a4961 1
          (Mir_Env.empty_lambda_env,arg_reg_copies)
d5067 1
a5067 1
	Lists.reducel (fn (x, {size=size, lexp=_}) => x+size) (0, fn_bodies)
d5128 1
a5128 1
	  Lists.reducel
d5145 2
a5146 2
        (map (fn (lvar,reg) => (lvar, reg, MirTypes.GC.new())))
        arg_regs_list
d5152 2
a5153 2
         (Lists.reducel
          (fn (env,(lvar, arg, copy)) => Mir_Env.add_lambda_env((lvar, MirTypes.GC copy),env))
a5162 1
          fun makearg (lvar,reg,copy) = MirTypes.GC reg
d5164 1
a5164 1
          ((Sexpr.ATOM(comment_for_name @@ [MirTypes.ENTER (map makearg arginfo)]),
d5168 4
a5171 1
      val entry_code_list = map generate_entry_code (Lists.zip (lambda_names,args_and_copied_callee_arg_list))
d5176 2
a5177 7
	(map
         (* Move the argument to somewhere safe, *)
         (* and let register colouring deal with allocation *)
         (fn (_, reg,copy) =>
          MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG copy,
			 MirTypes.GP_GC_REG reg)))
	args_and_copied_callee_arg_list
d5201 2
d5206 1
a5206 1
	(fn ((_, env, _, _,_,_,_,_), [(_,_,reg)], arg_selects) =>
d5211 1
a5211 1
         | _ => Crash.impossible"Binding not to select")
d5215 1
a5215 1
         | ((_, env, _, _,_,_,_,_), arg_regs,[]) =>
d5217 2
a5218 2
             (Lists.reducel
              (fn ((n,acc),(_,_,reg)) => (n+1,(n,MirTypes.GC reg)::acc))
d5221 1
a5221 1
        (zip3 (code_env_static_start_list,
d5367 1
a5367 1
	Lists.reducel
d5714 1
a5714 1
		    Lists.reducel add_block (MirTypes.Map.empty, block_list)
@


1.247
log
@Abstraction of debug information
@
text
@d4 3
a1029 3
  val handler = MirRegisters.handler
  (* The latest handler pointer *)

d5443 2
a5444 2
	  [MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG handler,
			    handler_frame, MirTypes.GP_IMM_ANY ~1),
a5455 1
	  MirTypes.NEW_HANDLER continue_tag ::
d5458 1
a5458 4
	  (*
	   MirTypes.STOREOP(MirTypes.LD, proc, MirTypes.GC_REG callee_closure,
	   MirTypes.GP_IMM_ANY ~1) ::
	   *)
d5460 2
a5461 2
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG handler,
			  MirTypes.GP_GC_REG handler_frame_reg),
d5642 1
a5642 1
	| tag_ref(NEW_HANDLER tag) = [tag]
@


1.246
log
@Removed explicit use of callee_arg in allocation of
 final result for compilation unit
@
text
@d4 4
d958 1
a958 1
  sharing MirPrint.MirTypes.RuntimeEnv.Option = LambdaPrint.LambdaTypes.Option = 
d963 1
d967 3
a969 3
  sharing type MirPrint.MirTypes.RuntimeEnv.Type = LambdaSub.LT.Type = Types.Datatypes.Type
  sharing type MirPrint.MirTypes.RuntimeEnv.Tyfun = LambdaSub.LT.Tyfun
  sharing type MirPrint.MirTypes.RuntimeEnv.Instance = LambdaSub.LT.Instance = 
d971 1
d998 1
a998 1
  structure RuntimeEnv = MirTypes.RuntimeEnv
d1042 2
a1043 3
      AugLambda.APP(le, lel,_) =>
	Lists.reducel new_frees (new_frees (vars, le), lel)
    | AugLambda.LET(_,lb,le) => 
d1046 1
a1046 2
    | AugLambda.STRUCT le_list =>
	Lists.reducel new_frees	(vars, le_list)
d1058 1
a1058 2
	(bandf_opt
	 (new_frees (vars, le), opt), tag_le_list)
d1061 3
a1063 4
	 if HashSet.is_member(old_set, lv) then
	   HashSet.add_member(new_set, lv)
	 else
	   new_set)
d1065 1
a1065 3
	Lists.reducel
	new_frees
	(vars, le :: le_list)
d1074 3
d1217 3
a1219 2
    val top_closure =
      IntMap.apply
d1223 1
d1230 2
a1231 1
	(Option.SOME1(lv),{lexp=AugLambda.APP
d1235 1
a1235 1
	       MirTypes.Debugger_Types.null_backend_annotation),
d2180 1
a2180 1
                                         MirTypes.Debugger_Types.null_backend_annotation,
d2618 1
a2618 1
    val first_spill : (int,int) Option.option ref list ref Option.opt = 
d2620 1
a2620 1
        Option.PRESENT(ref([ref(Option.SOME1(1))]))
d2644 1
a2644 1
            val spill = [ref(Option.SOME1(1))]
d2677 1
a2677 1
        fn slot =>Option.PRESENT(ref (Option.SOME1(slot)))
d2695 2
a2696 2
                                                                           (Option.SOME1(ref_slot,
                                                                                         "call_code"))))],
d2971 1
a2971 1
                                      MirTypes.Debugger_Types.null_backend_annotation), env',
d3188 1
a3188 1
    | cg_sub(arg as AugLambda.LET (Lvar, lexp2, {lexp=lexp1,...}),
d3199 4
a3202 4
      val (lvar,debug_info) = 
        case Lvar of 
          Option.SOME1(lvar) => (lvar,Option.ABSENT)
        | Option.SOME2(ref(debug_info)) => debug_info
d3215 1
a3215 1
        | Option.PRESENT(name,Ty as ref(ty,_,_),tyvar_slot) => 
d3221 1
a3221 1
                offset := Option.SOME1(value)
d3232 1
a3232 1
                       then (ref (Option.SOME1(slot)),false)
d3239 1
a3239 1
                     MirTypes.GP_IMM_SYMB (MirTypes.GC_SPILL_SLOT (Option.SOME1(ref_slot,name))))], 
d3243 1
a3243 2
                   else Option.PRESENT(name,Ty,
                         Option.PRESENT(ref_slot)))
d3250 1
a3250 1
                       (ref (Option.SOME1(slot)),false)
d3258 2
a3259 1
                                                   MirTypes.GP_IMM_SYMB (MirTypes.NON_GC_SPILL_SLOT (Option.SOME1(ref_slot,name))))], 
d3263 1
a3263 1
                   else Option.PRESENT(name,Ty,Option.PRESENT(ref_slot)))
d3270 1
a3270 1
                       (ref (Option.SOME1(slot)),false)
d3279 2
a3280 1
                                                       MirTypes.GP_IMM_SYMB (MirTypes.FP_SPILL_SLOT (Option.SOME1(ref_slot,name))))], 
d3284 1
a3284 1
                   else Option.PRESENT(name,Ty,Option.PRESENT(ref_slot)))
d3298 1
a3298 1
         RuntimeEnv.LET([(debug_info,runtime_env)], runtime_env')
d3615 3
a3617 2
                                                            (MirTypes.GC_SPILL_SLOT (Option.SOME1(fetch_spill ref_slot,
                                                                                                  "default for switch"))))], 
d3700 4
a3703 3
                                                                 (MirTypes.GC_SPILL_SLOT (Option.SOME1 (fetch_spill ref_slot,
                                                                                                        "switch case " ^ 
                                                                                                        MLWorks.Integer.makestring switch_case))))], 
d3992 1
a3992 1
                        MirTypes.Debugger_Types.null_backend_annotation)
d4562 1
a4562 1
                              Mir_Utils.do_app(MirTypes.Debugger_Types.null_backend_annotation,
d5008 1
a5008 1
        Lists.reducer (fn (Option.PRESENT(x),xs) => (x,RuntimeEnv.EMPTY)::xs
d5010 4
a5013 7
        (map (fn Option.SOME1(lvar) => Option.ABSENT
               | Option.SOME2(ref(lvar,
                            debug_info as Option.PRESENT(name,ty,_))) => 
               (Option.PRESENT(Option.PRESENT
                                           (name,ty,Option.ABSENT)))
               | Option.SOME2(ref(lvar,debug_info as Option.ABSENT)) => 
                  Option.ABSENT) 
d5017 1
a5017 1
      val lv_list = map LambdaTypes.fetch_var lv_list
@


1.245
log
@Reduce handler frame size to four words
by leaving out fp
@
text
@d4 4
d5515 2
a5516 1
	val (reg, new_code) = Mir_Utils.tuple_up_in_reg(sub_regs, callee_arg)
d5518 8
a5525 1
	(MirTypes.GP_GC_REG callee_arg, Sexpr.CONS(last, Sexpr.ATOM new_code))
@


1.244
log
@Machine specific functions is_fun and implicit_references moved to machperv
@
text
@d4 3
a5396 8
(*
      val end_ptr_reg = MirTypes.GC.new()
      val end_ptr = MirTypes.GC_REG end_ptr_reg
      val gp_end_ptr = MirTypes.GP_GC_REG end_ptr_reg
      val proc_reg = MirTypes.GC.new()
      val gp_proc_reg = MirTypes.GP_GC_REG proc_reg
      val proc = MirTypes.GC_REG proc_reg
*)
d5409 1
a5409 1
      val frame_size = (*length frame_setup*)5
d5421 3
a5423 4
      (* 1      frame pointer (for data access) *)
      (* 2      stack pointer (machine stack) *)
      (* 3	handler closure pointer *)
      (* 4	offset from procedure start of continuation point (GC safe) *)
a5434 2
           MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG fp, handler_frame,
                            MirTypes.GP_IMM_ANY 3),
d5436 1
a5436 1
                          MirTypes.GP_IMM_ANY 7),
d5438 1
a5438 7
			    handler_frame, MirTypes.GP_IMM_ANY 11),
(*
           MirTypes.BINARY(MirTypes.SUB, offset, gp_end_ptr, gp_proc_reg),
           MirTypes.COMMENT "Calculate offset of continuation code",
           MirTypes.BINARY(MirTypes.ASL, offset, gp_offset,
                           MirTypes.GP_IMM_ANY 2),
*)
d5440 1
a5440 1
                            MirTypes.GP_IMM_ANY 15)]
@


1.243
log
@More work on multiple arguments
@
text
@d4 3
d907 1
d932 1
d949 2
a950 1
sharing Library.AugLambda.Debugger_Types.Options = Types.Options
d2894 1
a2894 1
             case Pervasives.implicit_references prim
d2939 1
a2939 1
                 case Pervasives.implicit_references Pervasives.EQ
@


1.242
log
@Change count decrement in array and bytearray creation to
be by GP_IMM_INT ~1, as the count is always an ml integer.
@
text
@d4 4
a995 6
  val caller_arg2 = MirRegisters.caller_arg2
  (* The second argument register for all functions *)

  val callee_arg2 = MirRegisters.callee_arg2
  (* The local copy of the second argument register *)

d1127 2
a1128 2
    val caller_arg_regs = [caller_arg, caller_arg2]
    val callee_arg_regs = [callee_arg, callee_arg2]
d2162 1
a2162 1
                                         []),
d3283 2
a3284 2
  (* shouldn't need this case now *)
  (* APP (FN ..) should be eliminated by lambda optimizer *)
d3300 1
a3300 4
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating APP\n",
	LambdaPrint.string_of_lambda arg])
a3301 8
      (* Interceptable code must not have an unpacked argument. *)
      (* Disallow stacking of records when tracing, the value printer can't cope *)
      (* Check on whether tuple "escapes" *)
      val can_stack_parms = (not intercept) andalso
	(case le1 of
           AugLambda.VAR lvar =>
             not (funarg_escapes lvar)
         | _ => false)
d3310 4
d3320 1
a3320 1
               Set.is_member(lvar, prim_lvars) orelse can_stack_parms, 
d3335 55
a3389 4
      val le2 = 
        case arg_list of 
          [{lexp=le2, ...}] => le2 
        | _ => Crash.impossible "Arglist in APP"
d3391 8
a3398 32
      (* Do the argument *)
      val (arg_reg, arg_code,runtime_env',spills,calls') =
	cg_sub(le2, env, closure,
	       static_offset + gc_objects_in_call,
	       start_at + gc_objects_in_call, funs_in_closure, fn_tag_list,
	       false, [],spills,calls')

      (* Punt the complicated stuff to Mir_Utils *)
      val (reg, fn_code, arg_code, call_code) =
	Mir_Utils.new_do_app(debugger_information,
                             fn_reg, fn_code, arg_reg, arg_code,
			     not can_stack_args,
                             Lists.length tuple_bindings > 1,
                             tuple_bindings,
                             is_same_set, loop_tag, pos, funs_in_closure, fn_tag_list,
                             tails, opt_tail_calls, opt_self_calls)

      (* We ought to do better on the has_tupled_arg parameter *)
      (* But it requires more interprocedural analysis *)
      val code as ((first, blocks, tag_opt, last), values, procs_list) = 
        Mir_Utils.combine
        (fn_code,
         Mir_Utils.combine
         (arg_code, make_call_code(calls+1,call_code)))

      val _ = if tails then Diagnostic.output 5 (fn _ => ["Found tail continuation"]) else ()

      val runtime_env =
        if variable_debug then 
          RuntimeEnv.APP(runtime_env,runtime_env',Option.ABSENT)
        else 
          RuntimeEnv.EMPTY
d3400 3
a3402 1
      (reg, code, runtime_env,spills,calls')
d3405 2
d4544 1
a4544 2
                                               no_code,
                                               Lists.hd fn_tag_list, 0, 0, [])
d4953 2
a4954 5
                         MirTypes.PROC_PARAMS {leaf = false, (* Calculated by mir optimiser *)
                                               registers_used = Option.ABSENT,
                                               spill_sizes =  spill_sizes,
                                               stack_allocated = Option.ABSENT,
                                               loop_entry = []},
d5157 1
a5157 1
      val int_reg_list_list =
d5166 8
a5173 3
         (* For multiple arg case this is probably the wrong thing *)
         | (_, arg_regs,[]) => [] (* Crash.impossible "Don't know what to do here" *)
         | (_, arg_regs,_) => Crash.impossible "Arglist in int_reg_list_list")
d5232 1
a5232 1
               int_reg_list_list,
d5288 2
a5289 5
                          MirTypes.PROC_PARAMS {leaf = false,
                                                registers_used = Option.ABSENT,
                                                spill_sizes = spill_sizes,
                                                stack_allocated = Option.ABSENT,
                                                loop_entry = [loop_tag]},
d5551 1
a5551 1
	  Sexpr.ATOM[MirTypes.ENTER [],
d5554 1
a5554 1
	  Sexpr.ATOM[MirTypes.ENTER []]),
d5574 1
a5574 3
		    MirTypes.PROC_PARAMS {leaf = false,
					  registers_used = Option.ABSENT,
					  spill_sizes = 
d5581 1
a5581 2
					  stack_allocated = Option.ABSENT,
                                          loop_entry = []},
@


1.241
log
@Fix for blunder
@
text
@d4 3
d1676 1
a1676 1
                                                 MirTypes.GP_IMM_ANY ~1),
d1694 1
a1694 1
                                                 MirTypes.GP_IMM_ANY ~4),
@


1.240
log
@Fixed a bug with is_integral
@
text
@d4 3
d1233 1
a1233 1
    val new_exp_and_size as {lexp = new_lambda_exp, ... } =
d2736 4
@


1.239
log
@Added support for multiple arguments in lambda and mir representations.
This isn't complete yet, but the old one argument case should be as it was.
Tidied up and rearranged the code a lot.  Not too many functional changes
except for the above.
@
text
@d4 6
d1073 7
a1079 1
  (* The one type utility we need *)
d1081 1
a1081 1
  fun is_integral primTy =
d3025 1
a3025 1
      | Pervasives.BECOMES => do_becomes (is_integral primTy,regs,the_code)
d3116 1
a3116 1
      | Pervasives.UPDATE => update_code (false, true,is_integral primTy,regs,the_code,exn_code_for_prim prim)
d3118 1
a3118 1
      | Pervasives.UNSAFE_UPDATE => update_code (false, false,is_integral primTy,regs,the_code,exn_code_for_prim prim)
d3124 2
a3125 2
      | Pervasives.BYTEARRAY_UPDATE => update_code (true, true,is_integral primTy,regs,the_code,exn_code_for_prim prim)
      | Pervasives.BYTEARRAY_UNSAFE_UPDATE => update_code (true, false,is_integral primTy,regs,the_code,exn_code_for_prim prim)
d3476 2
a3477 2
          (Diagnostic.output 0 
           (fn _ => ["Selecting from literal struct - should have been optimized"]);
@


1.238
log
@Update debugger information production
@
text
@d4 3
d964 1
d970 4
d980 6
d1001 1
a1001 1
  val no_code = ((Sexpr.NIL, [], MirTypes.Option.ABSENT, Sexpr.NIL), [], [])
d1013 2
a1014 2
      AugLambda.APP(le, le',_) =>
	new_frees(new_frees(vars, le), le')
d1016 2
a1017 2
	new_frees(new_frees(vars,lb), le)
    | AugLambda.FN(lv, le,_,_) => new_frees(vars, le)
d1019 2
a1020 4
	Lists.reducel
	(fn (vars, le) => new_frees(vars, le))
	(vars, le_list)
    | AugLambda.SELECT(_, le) => new_frees(vars, le)
d1025 1
a1025 1
	   val vars = new_frees(vars, le)
d1028 1
a1028 1
	     AugLambda.EXP_TAG lexp => new_frees(vars, lexp)
d1032 1
a1032 1
	 (new_frees(vars, le), opt), tag_le_list)
d1047 2
a1048 2
	new_frees(new_frees(vars, le), le')
    | AugLambda.RAISE (le) => new_frees(vars, le)
d1051 1
a1051 1
  and bandf_opt(vars, LambdaTypes.Option.PRESENT le) = new_frees(vars, le)
d1054 1
d1067 1
d1069 5
a1073 15
  fun mir_cg
    error_info
      (Options.OPTIONS {compiler_options =
			  Options.COMPILEROPTIONS {debug,
                                                   debug_variables,
                                                   debug_polyvariables,
                                                   generate_moduler,
                                                   intercept,
						   interrupt,
                                                   opt_self_calls, 
                                                   opt_tail_calls,
                                                   ...},print_options,
                       ...},
     lambda_exp, filename, mapping) =
  let
d1075 1
a1075 59
    val debug_somevariables = debug_variables orelse debug_polyvariables orelse generate_moduler
    (* first spill is used for control transfer determining *)
    val first_spill : (int,int) LambdaTypes.Option.option ref list ref LambdaTypes.Option.opt = 
      if debug_somevariables then 
        LambdaTypes.Option.PRESENT(ref([ref(LambdaTypes.Option.SOME1(1))]))
      else 
        LambdaTypes.Option.ABSENT
    (* Always insert interrupt if the flag is set *)
    val insert_interrupt = interrupt 
    (* Not relevant if no tail optimisation *)
    fun deref_spill() = 
      case first_spill of
        LambdaTypes.Option.ABSENT => Crash.impossible "deref_spill:mir_cg:mir_cg"
      | LambdaTypes.Option.PRESENT(first_spill) => !first_spill
    fun restore_spill() = 
      case first_spill of
        LambdaTypes.Option.ABSENT => (fn _ => ())
      | LambdaTypes.Option.PRESENT(first_spill) => 
          let 
            val spill = !first_spill
          in
            (fn _ => first_spill := spill)
          end
    fun assign_spill() = 
      case first_spill of
        LambdaTypes.Option.ABSENT => LambdaTypes.Option.ABSENT
      | LambdaTypes.Option.PRESENT(first_spill) => 
          let
            val spill = [ref(LambdaTypes.Option.SOME1(1))]
          in
            (first_spill := spill;
             LambdaTypes.Option.PRESENT(spill))
          end
    fun assign_spill' spill = 
      case first_spill of
        LambdaTypes.Option.ABSENT => ()
      | LambdaTypes.Option.PRESENT(first_spill) => 
          (case spill of
             LambdaTypes.Option.ABSENT => Crash.impossible "assign_spill':mir_cg:mir_cg"
           | LambdaTypes.Option.PRESENT(spill) => first_spill := spill)
    fun fetch_spill spill = 
      case spill of 
        LambdaTypes.Option.ABSENT => Crash.impossible "fetch_spill:mir_cg:mir_cg"
      | LambdaTypes.Option.PRESENT(spill) => spill
    fun append_spill spill =
      case first_spill of
        LambdaTypes.Option.ABSENT => ()
      | LambdaTypes.Option.PRESENT(first_spill) => 
          first_spill := 
          (case spill of 
             LambdaTypes.Option.ABSENT => Crash.impossible "append_spill:mir_cg:mir_cg"
           | LambdaTypes.Option.PRESENT(spill) => spill)::(!first_spill)
    fun head_spill [spill] = spill
      | head_spill _ = Crash.impossible "head_spill:mir_cg:mir_cg"
    val new_ref_slot = 
      if debug_somevariables then 
        fn slot =>LambdaTypes.Option.PRESENT(ref (LambdaTypes.Option.SOME1(slot)))
      else
        fn _ =>LambdaTypes.Option.ABSENT
d1077 29
a1105 1
    val name_of_setup_function = "<Setup>[" ^ filename ^ ":1,1]"
d1107 1
a1107 2
    val (prim_to_lambda, prim_lvars, new_lambda_exp) =
      Library.build_external_environment lambda_exp
d1109 4
a1112 7
    val escaping_lvars =
      Lists.reducel
      (fn (new, prim) =>
       (case NewMap.tryApply'(prim_to_lambda, prim) of
	  NewMap.YES lv => Set.add_member(lv, new)
	| _ => new))
      (Set.empty_set, InterProc.escaping_prim_list)
d1114 12
a1125 1
    val prim_lvars = Set.setdiff(prim_lvars, escaping_lvars)
d1127 18
a1144 4
    val fn_bindings =
      Timer.xtime
      ("calculating fn bindings", print_timings,
       fn () => InterProc.binding_list new_lambda_exp)
d1146 18
a1163 4
    val escape_map =
      Timer.xtime
      ("calculating escape map", print_timings,
       fn () => InterProc.escape_map fn_bindings)
d1165 7
a1171 2
    val top_lambdas = LambdaTypes.Map.domain escape_map
    (* Should be the lambda variables representing all the functions *)
d1173 4
a1176 4
    val _ = Diagnostic.output 5
      (fn _ => (["Lambdas representing functions"] @@ 
                (map (fn x => " " ^ LambdaTypes.printLVar x)
                 top_lambdas)))
d1178 2
a1179 7
    val (new_exp_and_size as {size=number_of_gc_objects, lexp=new_lambda_exp},debug_information) =
      Timer.xtime
      ("counting new_lambda", print_timings,
       fn () => AugLambda.count_gc_objects (new_lambda_exp,true
					    (*debug (always collect debug info)*),
                                            mapping,name_of_setup_function,
                                            true))
d1182 2
a1183 2
      Lists.number_from_by_one(Mir_Utils.list_of_tags(number_of_gc_objects+1), 0,
			    ident_fn)
d1196 1
a1196 1
	(LambdaTypes.Option.SOME1(lv),{lexp=AugLambda.APP
d1199 1
a1199 1
	       {lexp=AugLambda.SCON(Ident.STRING string), size=0},
d1209 1
a1209 1
			empty_string_tree, empty_string_tree), new_exp_and_size)
d1230 3
a1232 4
      if needs_transform then
      NewMap.domain ext_tree
    else
      Set.set_to_list(Mir_Utils.get_string new_exp_and_size)
d1244 4
a1248 1
    fun str_order(s, t) = String.<(s, t) 
d1250 21
a1270 139
    val empty_str_order_tree = NewMap.from_list (str_order,op =)
    val ext_string_tree = empty_str_order_tree ext_string_list
    val ext_var_tree = empty_str_order_tree ext_var_list
    val ext_exn_tree = empty_str_order_tree ext_exn_list
    val ext_str_tree = empty_str_order_tree ext_str_list
    val ext_fun_tree = empty_str_order_tree ext_fun_list

    val applied_ext_string_tree =
      NewMap.apply ext_string_tree
    val applied_ext_var_tree =
      NewMap.apply ext_var_tree
    val applied_ext_exn_tree =
      NewMap.apply ext_exn_tree
    val applied_ext_str_tree =
      NewMap.apply ext_str_tree
    val applied_ext_fun_tree =
      NewMap.apply ext_fun_tree

    fun find_ext_string chars =
      applied_ext_string_tree chars
    fun find_ext_var chars =
      applied_ext_var_tree chars
    fun find_ext_exn chars =
      applied_ext_exn_tree chars
    fun find_ext_str chars =
      applied_ext_str_tree chars
    fun find_ext_fun chars =
      applied_ext_fun_tree chars

    val top_lambda_loop_tags =
      LambdaTypes.Map.apply
      (Lists.reducel
       (fn (tree, lv) =>
	LambdaTypes.Map.define(tree, lv, MirTypes.new_tag()))
       (LambdaTypes.Map.empty, top_lambdas))

    val hashset_size = 64

    fun make_call_code(calls,code) = 
      if debug_somevariables then 
        let 
          val reg = MirTypes.GC.new()
          val ref_slot = deref_spill()
        in
          case code of
            ((code,bs,ts,ops),vs,ps) => 
             ((Lists.reducer 
               (fn (ref_slot,code) =>
                 Sexpr.CONS(Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG reg,
                                                 MirTypes.GP_IMM_INT (calls)),
                                  MirTypes.STOREOP(MirTypes.STREF,MirTypes.GC_REG (reg),
                                                   MirTypes.GC_REG fp,
                                                   MirTypes.GP_IMM_SYMB (MirTypes.GC_SPILL_SLOT 
                                                       (LambdaTypes.Option.SOME1(ref_slot,
                                                                              "call_code"))))],
                 code)) (ref_slot,code),bs,ts,ops),vs,ps)
        end
      else
        code

    fun append_runtime_envs(env1,env2) = 
      case !env1 of
        RuntimeEnv.LIST(env) => RuntimeEnv.LIST(env@@[env2])
      | RuntimeEnv.EMPTY => env2
      | env1 => RuntimeEnv.LIST[env1,env2]

    fun cg_bind({lexp=lexp, size=gc_in_arg}, env, closure, static_offset,
		start_at, funs_in_closure, fn_tag_list,spills,calls) =
      let
	val (regs, the_code,runtime_env,spills,calls) =
	  cg_sub(lexp, env, closure, static_offset, start_at, funs_in_closure,
		 fn_tag_list, false, [],spills,calls)
	val (reg, more_code) = case regs of
	  Mir_Utils.ONE(Mir_Utils.INT reg) => (case reg of
			     MirTypes.GP_GC_REG x =>
			       (MirTypes.GC x,
				[MirTypes.COMMENT"Function argument"])
			   | MirTypes.GP_NON_GC_REG x =>
			       (MirTypes.NON_GC x,
				[MirTypes.COMMENT"Function argument"])
			   | MirTypes.GP_IMM_INT _ =>
			       let
				 val new_reg = MirTypes.GC.new()
			       in
				 (MirTypes.GC new_reg,
				  [MirTypes.UNARY(MirTypes.MOVE,
						  MirTypes.GC_REG new_reg,
						  reg),
				   MirTypes.COMMENT"Function argument"])
			       end
			   | MirTypes.GP_IMM_SYMB _ =>
			       let
				 val new_reg = MirTypes.GC.new()
			       in
				 (MirTypes.GC new_reg,
				  [MirTypes.UNARY(MirTypes.MOVE,
						  MirTypes.GC_REG new_reg,
						  reg),
				   MirTypes.COMMENT"Function argument"])
			       end
			   | _ => Crash.impossible"Untagged value to APP(FN)")
	| Mir_Utils.ONE(Mir_Utils.REAL(MirTypes.FP_REG fp_reg)) =>
	    (MirTypes.FLOAT fp_reg, [MirTypes.COMMENT"Function argument"])
	| Mir_Utils.LIST many =>
	    let val (gc_reg, more_code) = Mir_Utils.tuple_up many
	    in
	      (MirTypes.GC gc_reg,
	       MirTypes.COMMENT"Function argument" :: more_code)
	    end
      in
	(reg,
	 Mir_Utils.combine(the_code,
			   ((Sexpr.ATOM more_code, [], MirTypes.Option.ABSENT,
			     Sexpr.NIL),
			    [], [])),
	 static_offset + gc_in_arg, start_at + gc_in_arg,runtime_env,spills,calls)
      end

    and cg_bind_list([], env, _, static_offset, start_at, _, _,spills,calls) =
      (no_code, env, static_offset, start_at,RuntimeEnv.LIST(nil),spills,calls)

    | cg_bind_list((lv, le) :: rest, env, closure, static_offset, start_at,
		   funs_in_closure, fn_tag_list,spills,calls) =
      let
	val (reg, code, static_offset', start_at',runtime_env,spills,calls) =
	  cg_bind(le, env, closure, static_offset, start_at, funs_in_closure,
		  fn_tag_list,spills,calls)
	val env' = Mir_Env.add_lambda_env((lv, reg), env)
	val (new_code, env, static_offset, start_at,runtime_envs,spills,calls) =
	  cg_bind_list(rest, env', closure, static_offset', start_at',
		  funs_in_closure, fn_tag_list,spills,calls)
        val runtime_envs = 
          case runtime_envs of 
            RuntimeEnv.LIST(runtime_envs) => runtime_envs
          | _ => Crash.impossible "cg_bind_list:_mir_cg.sml"
      in
	(Mir_Utils.combine(code, new_code), env, static_offset, start_at,
         RuntimeEnv.LIST(runtime_env::runtime_envs),spills,calls)
      end
d1272 2
a1273 24
    and cg_sub(arg as AugLambda.APP
	       ({lexp=AugLambda.BUILTIN(prim,primTy), ...},
		{lexp=lexp, size=gc_objects_in_parm},_), env, closure,
	       static_offset, start_at, funs_in_closure, fn_tag_list, tails,
	       _,spills,calls) =
      (* env is the local lambda to register environment
       closure is the free lambda to offsets from callee_closure environment
       static_offset is the offset within the closure of the current function
       of static garbage collectable objects (functions and non-integer scons)
       start_at is the offset within the outermost closure of the tags
       for the static garbage collectable objects
       funs_in_closure is the number of functions following callee_closure
       within the current closure
       *)
    let
(*
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating APP(BUILTIN...)\n",
	LambdaPrint.string_of_lambda arg])
*)
    in
    (case prim of
      Pervasives.LOAD_STRING =>
d1280 6
a1285 5
	        ((Sexpr.ATOM[MirTypes.STOREOP(MirTypes.LD,
					      MirTypes.GC_REG new_reg,
		  MirTypes.GC_REG callee_closure,
		  MirTypes.GP_IMM_ANY(~1 + 4*(find_ext_string chars)))],
		  [], MirTypes.Option.ABSENT, Sexpr.NIL), [], []),RuntimeEnv.EMPTY,spills,calls)
d1287 1
a1287 109
	| _ => Crash.impossible"Bad parameter to load_string")
    | Pervasives.LOAD_VAR =>
	(case lexp of
	   AugLambda.SCON(Ident.STRING chars) =>
	     let
	       val new_reg = MirTypes.GC.new()
	     in
	       (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG new_reg)),
	        ((Sexpr.ATOM[MirTypes.STOREOP
			     (MirTypes.LD, MirTypes.GC_REG new_reg,
			      MirTypes.GC_REG callee_closure,
			      MirTypes.GP_IMM_ANY
			      (~1 + 4*(find_ext_var chars)))],
		  [], MirTypes.Option.ABSENT, Sexpr.NIL), [], []),RuntimeEnv.EMPTY,spills,calls)
	     end
	 | _ => Crash.impossible"Bad parameter to load_var")
    | Pervasives.LOAD_EXN =>
	(case lexp of
	   AugLambda.SCON(Ident.STRING chars) =>
	     let
	       val new_reg = MirTypes.GC.new()
	     in
	       (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG new_reg)),
	        ((Sexpr.ATOM[MirTypes.STOREOP
			     (MirTypes.LD, MirTypes.GC_REG new_reg,
			      MirTypes.GC_REG callee_closure,
			      MirTypes.GP_IMM_ANY
			      (~1 + 4*(find_ext_exn chars)))],
		  [], MirTypes.Option.ABSENT, Sexpr.NIL), [], []),RuntimeEnv.EMPTY,spills,calls)
	     end
	 | _ => Crash.impossible"Bad parameter to load_exn")
    | Pervasives.LOAD_STRUCT =>
	(case lexp of
	   AugLambda.SCON(Ident.STRING chars) =>
	     let
	       val new_reg = MirTypes.GC.new()
	     in
	       (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG new_reg)),
	        ((Sexpr.ATOM[MirTypes.STOREOP
			     (MirTypes.LD, MirTypes.GC_REG new_reg,
			      MirTypes.GC_REG callee_closure,
			      MirTypes.GP_IMM_ANY
			      (~1 + 4*(find_ext_str chars)))],
		  [], MirTypes.Option.ABSENT, Sexpr.NIL), [], []),RuntimeEnv.EMPTY,spills,calls)
	     end
	 | _ => Crash.impossible"Bad parameter to load_struct")
    | Pervasives.LOAD_FUNCT =>
	(case lexp of
	   AugLambda.SCON(Ident.STRING chars) =>
	     let
	       val new_reg = MirTypes.GC.new()
	     in
	       (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG new_reg)),
	        ((Sexpr.ATOM[MirTypes.STOREOP
			     (MirTypes.LD, MirTypes.GC_REG new_reg,
			      MirTypes.GC_REG callee_closure,
			      MirTypes.GP_IMM_ANY
			      (~1 + 4*(find_ext_fun chars)))],
		  [], MirTypes.Option.ABSENT, Sexpr.NIL), [], []),RuntimeEnv.EMPTY,spills,calls)
	     end
	 | _ => Crash.impossible"Bad parameter to load_funct")
    | _ =>
    let
      val (regs, the_code,runtime_env',spills,calls') =
	cg_sub(lexp, env, closure, static_offset, start_at, funs_in_closure,
	       fn_tag_list, false, [],spills,calls)

      val calls : int ref = ref(calls')
      val spills : (int * int * int) ref = ref(spills)
      val runtime_env : RuntimeEnv.debugger_env ref = ref(RuntimeEnv.BUILTIN)

      fun exn_code_for_prim prim =
        case Pervasives.implicit_references prim
          of [] => ([], MirTypes.Option.ABSENT)
           | [exception_needed] =>
              let
                val exception_packet =
                  AugLambda.VAR(NewMap.apply'(prim_to_lambda, exception_needed))

                val (exn_f, exn_b, exn_o, exn_l) =
                  case cg_sub(AugLambda.RAISE({lexp=AugLambda.STRUCT
                                               [{lexp=exception_packet, size=0},
                                                {lexp=AugLambda.STRUCT[], size=0}],size=0}), env,
                              closure,
                              static_offset, start_at, funs_in_closure,
                              fn_tag_list, false, [],!spills,!calls)
                    of (_, ((exn_f, exn_b, exn_o, exn_l), [], []),
                        runtime_env',spills',calls') =>
                      (calls := calls';
                       runtime_env := append_runtime_envs(runtime_env,runtime_env');
                       spills := spills';
                       (exn_f, exn_b, exn_o, exn_l))
                     | _ => Crash.impossible"Bad code for RAISE primitive exception"
                         
                val _ = case exn_o
                          of MirTypes.Option.ABSENT => ()
                           | _ => Crash.impossible"Too much raise code"

		val exn_tag = MirTypes.new_tag()
              in
                (MirTypes.BLOCK(exn_tag, Mir_Utils.contract_sexpr exn_f) :: exn_b,
	         MirTypes.Option.PRESENT (exn_tag))
              end
           | _ => 
               Crash.unimplemented
               ("Mir_Cg: Unable to cope with multiple implicit "^
                "exceptions generated from the in-line pervasive "^
                Pervasives.print_pervasive prim)

d1289 1
a1289 1
      fun tagged_binary_calc(prim, opcode) =
d1298 2
a1299 2
	    | _ => Crash.impossible"cg_sub(BUILTIN 0)"
	  val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
d1301 6
a1306 6
	  (Mir_Utils.ONE(Mir_Utils.INT res1), Mir_Utils.combine
	   (the_code,
	    ((Sexpr.ATOM(new_code @@
			 [(MirTypes.TBINARY(opcode,
					    exn_tag_opt, res2, val1, val2))]),
	      exn_blocks, MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d1309 1
a1309 1
      fun unary_negate(prim, opcode) =
d1314 1
a1314 1
	  val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
d1320 3
a1322 3
		 ((Sexpr.ATOM[(MirTypes.TBINARY(opcode, exn_tag_opt, res2,
				    MirTypes.GP_IMM_INT 0, reg))], exn_blocks,
		 MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d1326 1
a1326 1
      fun tagged_binary_fcalc(prim, opcode) =
d1354 1
a1354 1
	  val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
d1359 5
a1363 5
	       Mir_Utils.combine(the_code,
		((Sexpr.ATOM(new_code @@
		  [(MirTypes.TBINARYFP(opcode, exn_tag_opt, result,
						  val1, val2))]),
		  exn_blocks, MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d1367 1
a1367 1
      fun unary_fcalc opcode =
d1373 10
a1382 10
	      (((case regs of
		Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG reg)) =>
		  Sexpr.ATOM[MirTypes.STOREFPOP(MirTypes.FLD, result,
				      MirTypes.GC_REG reg,
				       MirTypes.GP_IMM_ANY real_offset),
		    MirTypes.UNARYFP(opcode, result, result)]
		| Mir_Utils.ONE(Mir_Utils.REAL reg) =>
		    Sexpr.ATOM[MirTypes.UNARYFP(opcode, result, reg)]
		| _ => Crash.impossible"cg_sub(BUILTIN 1)"),
		  [], MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d1385 1
a1385 1
      fun tagged_unary_fcalc(prim, opcode) =
d1388 1
a1388 1
	  val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
d1401 1
a1401 1
		  exn_blocks, MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d1404 1
a1404 1
      fun test opcode =
d1424 1
a1424 1
		       [], MirTypes.Option.PRESENT tag, Sexpr.NIL), [], [])))
d1428 1
a1428 1
      fun ftest(opcode, sense) =
d1463 1
a1463 1
		       [], MirTypes.Option.PRESENT tag, Sexpr.NIL), [], [])))
d1470 1
a1470 1
      fun do_size regs =
d1495 1
a1495 1
      fun binary_calc opcode =
d1510 1
a1510 1
	      [], MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d1513 1
a1513 1
      fun do_shift_operator(mir_operator,need_to_clear_bottom_two_bits) = 
d1544 1
a1544 1
			       [],MirTypes.Option.ABSENT,Sexpr.NIL),[],[])))
d1547 1
a1547 1
      fun array_code bytearray =
d1586 1
a1586 1
	  val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
d1588 2
a1589 2
	    case exn_tag_opt
	    of MirTypes.Option.PRESENT tag => tag
d1681 1
a1681 1
              MirTypes.Option.PRESENT finish_tag, 
d1692 1
a1692 1
      fun length_code bytearray =
d1712 1
a1712 1
                   [], MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d1717 1
a1717 1
      fun vector_length_code _ =
d1737 1
a1737 1
                   [], MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d1742 1
a1742 1
      fun sub_code (bytearray, safe) =
d1779 1
a1779 1
	      val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
d1782 1
a1782 1
	        of MirTypes.Option.PRESENT tag => tag
d1833 1
a1833 1
                  exn_blocks, MirTypes.Option.PRESENT finish_tag, Sexpr.NIL), [], [])))
d1860 1
a1860 1
              [], MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d1863 1
a1863 1
      fun vector_sub_code _ =
d1899 1
a1899 1
	    val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
d1902 1
a1902 1
	      of MirTypes.Option.PRESENT tag => tag
d1943 1
a1943 1
		exn_blocks, MirTypes.Option.PRESENT finish_tag, Sexpr.NIL), [], [])))
d1947 1
a1947 1
      fun update_code (bytearray, safe) =
d1999 1
a1999 1
	  val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
d2005 1
a2005 1
	            of MirTypes.Option.PRESENT tag => tag
a2038 5
          val isIntegral =
            case Types.the_type primTy of
              ty as Datatypes.RECTYPE _ =>
		Type_Utils.is_integral(Types.get_type_from_lab (Ident.LAB(Symbol.find_symbol "3"), ty))
            | _ => false
d2125 1
a2125 1
                 MirTypes.Option.PRESENT finish_tag, 
d2129 1
a2129 6
      val (result, code) =
      case prim of
	Pervasives.IDENT_FN => Crash.impossible"Unexpanded IDENT_FN"
      | Pervasives.ENTUPLE => do_external_prim prim
      | Pervasives.ML_REQUIRE => do_external_prim prim
      | Pervasives.ML_CALL =>
d2134 1
a2134 3
	    val opcodes =
	      Sexpr.ATOM
	      (Mir_Utils.send_to_given_reg(regs, caller_arg))
d2145 2
a2146 1
                                         MirTypes.Debugger_Types.null_backend_annotation),
d2154 26
a2179 1
				 MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d2181 1
a2181 1
      | Pervasives.ML_OFFSET =>
d2183 2
a2184 1
	    val (reg1, reg2, code) = case regs of
d2211 1
a2211 1
				 MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d2213 2
a2214 29
      | Pervasives.LOAD_VAR => do_external_prim prim
      | Pervasives.LOAD_EXN => do_external_prim prim
      | Pervasives.LOAD_STRUCT => do_external_prim prim
      | Pervasives.LOAD_FUNCT => do_external_prim prim
      | Pervasives.REF =>
	  let
            val scratch = MirTypes.GC.new()
            val scratch_reg = MirTypes.GC_REG scratch
	    val (new_reg, code) = Mir_Utils.send_to_reg(regs)
	    val result = MirTypes.GC.new()
	    val res1 = MirTypes.GC_REG result
	    val work1 = MirTypes.GC_REG(MirTypes.GC.new ())
            val work2 = MirTypes.GC_REG(MirTypes.GC.new ())
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
	      Mir_Utils.combine(the_code,
		((Sexpr.ATOM(code @@
		  [MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, MirTypes.GP_IMM_INT 1),
		  MirTypes.COMMENT"Allocate a ref cell",
		  MirTypes.STOREOP(MirTypes.STREF, Mir_Utils.reg_from_gp new_reg, res1,
				   MirTypes.GP_IMM_ANY 9),
		  MirTypes.UNARY(MirTypes.MOVE, work1, MirTypes.GP_IMM_ANY 0),
		  MirTypes.STOREOP(MirTypes.STREF, work1, res1, MirTypes.GP_IMM_ANY 5),
                  MirTypes.UNARY(MirTypes.MOVE, work2, MirTypes.GP_IMM_INT 1),
                  MirTypes.STOREOP(MirTypes.STREF, work2, res1, MirTypes.GP_IMM_ANY 1),
		  MirTypes.COMMENT"Initialise the other pointers"]),
		  [], MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
	  end
      | Pervasives.BECOMES =>
a2237 5
	    val isIntegral =
	      case Types.the_type primTy of
		ty as Datatypes.RECTYPE _ =>
		  Type_Utils.is_integral(Types.get_type_from_lab(Ident.LAB(Symbol.find_symbol "2"), ty))
	      | _ => false
d2294 1
a2294 1
                       MirTypes.Option.PRESENT already_on_ref_chain_tag, 
d2298 2
a2299 1
      | Pervasives.DEREF =>
d2312 1
a2312 1
		  [], MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d2315 2
a2316 45
      | Pervasives.EXABS =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXORD =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXCHR =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXDIV =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXMOD =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXQUOT =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXPROD =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXNEG =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXSUM =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXDIFF =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXFLOOR =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXSQRT =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXEXP =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXLN =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXIO =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXMATCH =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXBIND =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXINTERRUPT =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXRANGE =>
	  Crash.impossible"APP of non-function"
      | Pervasives.MAP => do_external_prim prim
      | Pervasives.REV => do_external_prim prim
      | Pervasives.NOT =>
	  Crash.impossible"Primitive NOT"
      | Pervasives.ABS =>
	  Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.FLOOR =>
d2321 1
a2321 1
	    val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
d2324 1
a2324 1
	      of MirTypes.Option.PRESENT tag => tag
d2343 1
a2343 1
		  exn_blocks, MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d2346 1
a2346 1
      | Pervasives.REAL =>
d2363 1
a2363 1
		  [], MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d2365 2
a2366 7
      | Pervasives.SQRT => tagged_unary_fcalc(prim, MirTypes.FSQRTV)
      | Pervasives.SIN => unary_fcalc MirTypes.FSIN
      | Pervasives.COS => unary_fcalc MirTypes.FCOS
      | Pervasives.ARCTAN => unary_fcalc MirTypes.FATAN
      | Pervasives.EXP => tagged_unary_fcalc(prim, MirTypes.FETOXV)
      | Pervasives.LN => tagged_unary_fcalc(prim, MirTypes.FLOGEV)
      | Pervasives.SIZE =>
d2368 1
a2368 1
	  val (_, result, code) = do_size regs
d2372 1
a2372 1
			     ((Sexpr.ATOM code, [], MirTypes.Option.ABSENT,
d2375 1
a2375 1
      | Pervasives.CHR =>
d2380 1
a2380 1
	  val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
d2383 1
a2383 1
	    of MirTypes.Option.PRESENT tag => tag
d2407 1
a2407 1
		MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d2411 2
a2412 1
      | Pervasives.ORD =>
d2414 1
a2414 1
	  val (the_ptr, the_size, code) = do_size regs
d2418 1
a2418 1
	  val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
d2421 1
a2421 1
	    of MirTypes.Option.PRESENT tag => tag
d2432 1
a2432 1
		     exn_blocks, MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d2434 2
a2435 1
      | Pervasives.ORDOF =>
d2442 1
a2442 1
	  val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
d2445 1
a2445 1
	    of MirTypes.Option.PRESENT tag => tag
d2459 1
a2459 1
		exn_blocks, MirTypes.Option.ABSENT, Sexpr.NIL),
d2463 1
a2463 1
	      do_size(Mir_Utils.ONE(Mir_Utils.INT val1))
d2488 1
a2488 1
	         exn_blocks, MirTypes.Option.ABSENT, Sexpr.NIL), [], [])))
d2491 10
a2500 60
      | Pervasives.EXPLODE => do_external_prim prim
      | Pervasives.IMPLODE => do_external_prim prim
      | Pervasives.FDIV => tagged_binary_fcalc(prim, MirTypes.FDIVV)
      | Pervasives.DIV => tagged_binary_calc(prim, MirTypes.DIVV)
      | Pervasives.MOD => tagged_binary_calc(prim, MirTypes.MODV)
      | Pervasives.PLUS =>
	  Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.STAR =>
	  Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.MINUS =>
	  Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.HAT => do_external_prim prim
      | Pervasives.AT => do_external_prim prim
      | Pervasives.NE => do_external_prim prim
      | Pervasives.LESS =>
	  Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.GREATER =>
	  Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.LESSEQ =>
	  Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.GREATEREQ =>
	  Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.O =>
	  Crash.impossible"Primitive composition"
      | Pervasives.UMINUS =>
	  Crash.impossible"Unresolved overloaded primitive"
      | Pervasives.EQFUN => do_external_prim prim
      (* This shouldn't ever occur *)
      | Pervasives.EQ =>
        let
          val _ = Diagnostic.output 3 (fn _ => ["Mir_Cg: Translating polymorphic equality"])
          val primitive =
            case Pervasives.implicit_references Pervasives.EQ
              of [p] => p
               | _ => 
                 Crash.impossible
                 ("Mir_Cg: I was expecting the implicit reference of EQ " ^
                  "to be a single external thing!")

          val polymorphic_equality =
            AugLambda.VAR(NewMap.apply'(prim_to_lambda, primitive))
	  val (reg, extra_code) = case Mir_Utils.send_to_reg regs of
	    (MirTypes.GP_GC_REG reg, code) => (reg, code)
	  | _ => Crash.impossible"Mir_Utils.send_to_reg doesn't give GP_GC_REG"
	  val extra_code = ((Sexpr.ATOM extra_code, [], MirTypes.Option.ABSENT,
			     Sexpr.NIL), [], [])
	  val lvar = LambdaTypes.new_LVar()
	  val env' = Mir_Env.add_lambda_env((lvar, MirTypes.GC reg), env)
	  val (reg, poly_code,runtime_env',spills',calls') =
	      cg_sub(AugLambda.APP({lexp=polymorphic_equality, size=0},
				   {lexp=AugLambda.VAR lvar, size=0},
                                   MirTypes.Debugger_Types.null_backend_annotation), env',
		     closure,
		     static_offset + gc_objects_in_parm,
		     start_at + gc_objects_in_parm, funs_in_closure,
		     fn_tag_list, tails, [],!spills,!calls)
          val _ = calls := calls'
          val _ = spills := spills'
          val _ = runtime_env := append_runtime_envs(runtime_env,runtime_env')
        in
d2502 15
a2516 1
	    Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] =>
d2518 433
a2950 7
		val good_tag = MirTypes.new_tag()  (* For true *)
		val bad_tag = MirTypes.new_tag()   (* For false *)
		val test_tag = MirTypes.new_tag()  (* For dunno *)
		val final_tag = MirTypes.new_tag() (* Where we end up *)
		val res_reg = MirTypes.GC.new()
		val gc_res_reg = MirTypes.GC_REG res_reg
		val new_code =
d2976 1
a2976 1
		  MirTypes.Option.PRESENT test_tag, Sexpr.NIL)
d2987 1
a2987 1
		       [], MirTypes.Option.PRESENT final_tag,
d2999 91
a3089 21
      | Pervasives.REALPLUS => tagged_binary_fcalc(prim, MirTypes.FADDV)
      | Pervasives.INTPLUS => tagged_binary_calc(prim, MirTypes.ADDV)
      | Pervasives.UNSAFEINTPLUS => binary_calc MirTypes.ADD
      | Pervasives.REALSTAR => tagged_binary_fcalc(prim, MirTypes.FMULV)
      | Pervasives.INTSTAR => tagged_binary_calc(prim, MirTypes.MULV)
      | Pervasives.REALMINUS => tagged_binary_fcalc(prim, MirTypes.FSUBV)
      | Pervasives.INTMINUS => tagged_binary_calc(prim, MirTypes.SUBV)
      | Pervasives.REALUMINUS => tagged_unary_fcalc(prim, MirTypes.FNEGV)
      | Pervasives.INTUMINUS => unary_negate(prim, MirTypes.SUBV)
      | Pervasives.INTLESS => test MirTypes.BLT
      | Pervasives.REALLESS => ftest(MirTypes.FBLT, true)
      | Pervasives.INTGREATER => test MirTypes.BGT
      | Pervasives.REALGREATER => ftest(MirTypes.FBLT, false)
      | Pervasives.INTLESSEQ => test MirTypes.BLE
      | Pervasives.REALLESSEQ => ftest(MirTypes.FBLE, true)
      | Pervasives.INTGREATEREQ => test MirTypes.BGE
      | Pervasives.REALGREATEREQ => ftest(MirTypes.FBLE, false)
      | Pervasives.INTEQ => test MirTypes.BEQ
      | Pervasives.INTNE => test MirTypes.BNE
      | Pervasives.REALEQ => ftest(MirTypes.FBEQ, true)
      | Pervasives.REALNE => ftest(MirTypes.FBNE, true)
d3096 18
a3113 61
      | Pervasives.INTABS =>
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val tag = MirTypes.new_tag()
	  val (exn_blocks, exn_tag_opt) = exn_code_for_prim prim
	  val opcode = MirTypes.SUBV
	in
	  case regs of
	    Mir_Utils.ONE(Mir_Utils.INT reg) =>
	      (Mir_Utils.ONE(Mir_Utils.INT res1), Mir_Utils.combine(the_code,
	        ((Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE, res2, reg),
		  MirTypes.TEST(MirTypes.BGE, tag, reg, MirTypes.GP_IMM_INT 0),
		  MirTypes.TBINARY(opcode, exn_tag_opt, res2,
				   MirTypes.GP_IMM_INT 0, reg),
                   MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag)], exn_blocks,
		MirTypes.Option.PRESENT tag, Sexpr.NIL), [], [])))
	  | _ => Crash.impossible"cg_sub(BUILTIN 1)"
	end
      | Pervasives.REALABS => tagged_unary_fcalc(prim, MirTypes.FABSV)
      | Pervasives.CALL_C =>
	  let
	    val res_reg = MirTypes.GC.new()
	    fun make_args_for_call_c arg =
	      let
		val get_result =
		  [MirTypes.CALL_C,
		   MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
				  MirTypes.GP_GC_REG caller_arg),
		   MirTypes.COMMENT"And acquire result"]
	      in
		case arg of
		  Mir_Utils.ONE (Mir_Utils.INT(reg)) =>
                    MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG caller_arg, reg) ::
                    get_result
                | _ => Crash.impossible "Bad arguments to make_args_for_call_c"
	      end
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG res_reg)),
	     Mir_Utils.combine (the_code, 
		      ((Sexpr.ATOM(make_args_for_call_c regs), [],
			MirTypes.Option.ABSENT, Sexpr.NIL),
		       [], [])))
	  end
      | Pervasives.LOAD_STRING =>
	  Crash.impossible "Impossible load_string"

      | Pervasives.ARRAY_FN => array_code false
      | Pervasives.LENGTH => length_code false
      | Pervasives.SUB => sub_code (false, true)
      | Pervasives.UPDATE => update_code (false, true)
      | Pervasives.UNSAFE_SUB => sub_code (false, false)
      | Pervasives.UNSAFE_UPDATE => update_code (false, false)

      | Pervasives.BYTEARRAY => array_code true
      | Pervasives.BYTEARRAY_LENGTH => length_code true
      | Pervasives.BYTEARRAY_SUB => sub_code (true, true)
      | Pervasives.BYTEARRAY_UNSAFE_SUB => sub_code (true, false)
      | Pervasives.BYTEARRAY_UPDATE => update_code (true, true)
      | Pervasives.BYTEARRAY_UNSAFE_UPDATE => update_code (true, false)
d3115 2
a3116 2
      | Pervasives.VECTOR_LENGTH => vector_length_code()
      | Pervasives.VECTOR_SUB => vector_sub_code()
d3118 2
a3119 5
      | Pervasives.EXSIZE => 	   
	  Crash.impossible"APP of non-function"
      | Pervasives.EXSUBSCRIPT => 
	  Crash.impossible"APP of non-function"

d3121 7
a3127 3
      | Pervasives.ANDB => binary_calc MirTypes.AND
      | Pervasives.ORB => binary_calc MirTypes.OR
      | Pervasives.XORB => binary_calc MirTypes.EOR
d3129 2
a3130 3
      | Pervasives.LSHIFT => do_shift_operator(MirTypes.ASL,false)
      | Pervasives.RSHIFT => do_shift_operator(MirTypes.LSR,true)
      | Pervasives.ARSHIFT => do_shift_operator(MirTypes.ASR,true)
a3131 14
      | Pervasives.NOTB =>
          let
            val (new_reg,code) =
              case regs of 
                (arg as Mir_Utils.ONE(_)) => Mir_Utils.send_to_new_reg arg
              | _ => Crash.impossible "Not applied to more than one argument"
            val result = MirTypes.GC.new()
          in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
             Mir_Utils.combine(the_code,
                     ((Sexpr.ATOM(code @@ [MirTypes.UNARY(MirTypes.NOT,MirTypes.GC_REG result,new_reg)]),
                       [],MirTypes.Option.ABSENT,Sexpr.NIL),
                      [],[])))
          end
d3135 1
a3135 1
         RuntimeEnv.BUILTIN => (code,RuntimeEnv.Option.ABSENT,calls)
d3137 1
a3137 1
               RuntimeEnv.Option.PRESENT(calls'),
d3141 1
a3141 1
       if debug_somevariables then 
d3148 3
a3150 3
    | cg_sub(arg as AugLambda.LET
	     (Lvar, lexp2, {lexp=lexp1,...}), env,
	     closure, static_offset, start_at, funs_in_closure, fn_tag_list,
d3156 1
a3156 1
	(fn i => ["Mir generating APP(FN...)\n",
d3159 1
d3162 4
a3165 2
          LambdaTypes.Option.SOME1(lvar) => (lvar,LambdaTypes.Option.ABSENT)
        | LambdaTypes.Option.SOME2(ref(debug_info)) => debug_info
a3169 7
      fun null_offset(LambdaTypes.Option.ABSENT) = true
        | null_offset _ = false
      fun assign_offset(LambdaTypes.Option.PRESENT(offset)) value = 
        offset := LambdaTypes.Option.SOME1(value)
        | assign_offset _ _ = Crash.impossible "assign_offset:mir_cg"
      fun fetch_offset(LambdaTypes.Option.PRESENT(offset)) = offset 
        | fetch_offset _ = Crash.impossible "assign_offset:mir_cg"
d3171 2
d3175 13
a3187 3
          LambdaTypes.Option.ABSENT => ((code,spills),LambdaTypes.Option.ABSENT)
        | LambdaTypes.Option.PRESENT(name,Ty as ref(ty,_,_),tyvar_slot) => 
            (case reg of
d3192 2
a3193 2
                     if null_offset tyvar_slot then 
                       (ref (LambdaTypes.Option.SOME1(slot)),false)
d3200 2
a3201 2
                     MirTypes.GP_IMM_SYMB (MirTypes.GC_SPILL_SLOT (LambdaTypes.Option.SOME1(ref_slot,name))))], 
		     [],MirTypes.Option.ABSENT, Sexpr.NIL), [], [])),
d3203 3
a3205 3
                   if tyvar_slot then LambdaTypes.Option.ABSENT
                   else LambdaTypes.Option.PRESENT(name,Ty,
                         LambdaTypes.Option.PRESENT(ref_slot)))
d3212 1
a3212 1
                       (ref (LambdaTypes.Option.SOME1(slot)),false)
d3217 8
a3224 9
                    ((Sexpr.ATOM [MirTypes.STOREOP(MirTypes.STREF,MirTypes.NON_GC_REG (reg),
		         MirTypes.GC_REG fp,
                         MirTypes.GP_IMM_SYMB 
                             (MirTypes.NON_GC_SPILL_SLOT (LambdaTypes.Option.SOME1(ref_slot,name))))], 
			 [],MirTypes.Option.ABSENT, Sexpr.NIL), [], [])),
		    	           (gc_spills,slot,fp_spills)),
                   if tyvar_slot then LambdaTypes.Option.ABSENT
                   else LambdaTypes.Option.PRESENT(name,Ty,
                         LambdaTypes.Option.PRESENT(ref_slot)))
d3231 1
a3231 1
                       (ref (LambdaTypes.Option.SOME1(slot)),false)
d3235 10
a3244 10
                   ((Mir_Utils.combine(code,
                    ((Sexpr.ATOM [MirTypes.STOREFPOP(MirTypes.FSTREF,MirTypes.FP_REG (reg),
                            MirTypes.GC_REG fp,
                            MirTypes.GP_IMM_SYMB 
                                 (MirTypes.FP_SPILL_SLOT (LambdaTypes.Option.SOME1(ref_slot,name))))], 
			    [],MirTypes.Option.ABSENT, Sexpr.NIL), [], [])),
		    	            (gc_spills,non_gc_spills,slot)),
                   if tyvar_slot then LambdaTypes.Option.ABSENT
                   else LambdaTypes.Option.PRESENT(name,Ty,
                         LambdaTypes.Option.PRESENT(ref_slot)))
d3246 6
a3251 2
      val env' =
	Mir_Env.add_lambda_env((lvar, reg), env)
d3257 1
a3257 1
       if debug_somevariables then 
d3262 1
d3264 1
d3266 1
a3266 1
	     ({lexp=AugLambda.FN(lvar, {lexp=lexp1, ...},name,_), ...}, lexp2,_), env,
d3271 1
a3271 23
(*
    let
      val _ = output(std_out, "*** Mir generating APP(FN ...)\n")
(*
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating APP(FN...)\n",
	LambdaPrint.string_of_lambda arg])
*)
      val (reg, code, static_offset', start_at',runtime_env,spills,calls') =
	cg_bind(lexp2, env, closure, static_offset, start_at, funs_in_closure,
		fn_tag_list,spills,calls+1)
      val env' =
	Mir_Env.add_lambda_env((lvar, reg), env)
      val (rest_regs, rest_code,runtime_env',spills,calls') =
	cg_sub(lexp1, env', closure, static_offset', start_at',
	       funs_in_closure, fn_tag_list, tails, tuple_bindings,spills,calls')
    in
      (rest_regs, Mir_Utils.combine(code, rest_code),
	RuntimeEnv.APP(RuntimeEnv.FN(name,runtime_env',
               ref(LambdaTypes.Option.SOME1(1))),runtime_env),spills,calls')
    end
*)
d3273 1
a3273 1
				  {lexp=le2, ...},debugger_information), env, closure,
d3286 2
d3290 2
a3291 4
           AugLambda.VAR lv =>
             (case LambdaTypes.Map.tryApply'(escape_map, lv) of
                LambdaTypes.Map.YES ok => not ok
              | _ => false)
d3293 2
a3294 3
      (* Disallow stacking of records when tracing, the value printer can't cope *)
      val ((fn_reg, fn_code,runtime_env,spills,calls'), pos, is_same_set, can_stack_args, tails,
	   loop_tag) =
d3296 2
a3297 1
	  AugLambda.VAR(lvar) =>
d3300 1
a3300 1
		Mir_Utils.cg_lvar(lvar, env, closure, funs_in_closure)
d3303 1
a3303 1
		((Sexpr.ATOM code, [], MirTypes.Option.ABSENT, Sexpr.NIL), [], []),
d3306 6
a3311 6
	        is_same_set, Set.is_member(lvar, prim_lvars) orelse
		can_stack_parms, tails,
		if is_same_set then
		  top_lambda_loop_tags lvar
		else
		  Lists.hd fn_tag_list)
d3314 12
a3325 3
	  (cg_sub(le1, env, closure, static_offset, start_at, funs_in_closure,
		  fn_tag_list, false, [],spills,calls+1),
	   0, false, false, tails, Lists.hd fn_tag_list)
d3327 1
d3334 1
d3339 4
a3342 3
		   Lists.length tuple_bindings > 1, tuple_bindings,
		   is_same_set, loop_tag, pos, funs_in_closure, fn_tag_list,
		   tails, opt_tail_calls, opt_self_calls)
d3351 1
d3354 5
d3360 3
a3362 6
      (reg, code,
       if debug_somevariables then 
         RuntimeEnv.APP(runtime_env,runtime_env',RuntimeEnv.Option.ABSENT)
       else 
         RuntimeEnv.EMPTY,spills,calls')
      end
d3365 1
d3378 1
d3393 2
d3407 1
a3408 4
(*
	  Lists.reducer
	  (fn ((_,code), code') => code @@ code'
*)
d3413 7
d3422 1
a3422 1
	 Mir_Utils.combine(the_code, ((new_code, [], MirTypes.Option.ABSENT,
d3424 1
a3424 4
         if debug_somevariables then 
           RuntimeEnv.STRUCT(runtime_env)
         else 
           RuntimeEnv.EMPTY,spills,calls)
d3426 1
d3453 6
a3458 5
		MirTypes.COMMENT("Destructure tuple")], [], MirTypes.Option.ABSENT,
	      Sexpr.NIL), [], [])),if debug_somevariables then 
                                       RuntimeEnv.SELECT(index,runtime_env)
                                   else
                                     RuntimeEnv.EMPTY,spills,calls)
d3463 13
a3475 11
	  (Mir_Utils.ONE(Lists.nth(index, many)), the_code,
           if debug_somevariables then 
             RuntimeEnv.SELECT(index,runtime_env)
           else
             RuntimeEnv.EMPTY,spills,calls) handle
	  Lists.Nth =>
	    Crash.impossible
	      ("Trying to select item " ^
	       MLWorks.Integer.makestring index ^ " from list size " ^
	       MLWorks.Integer.makestring(Lists.length many) ^
	       " with struct size " ^ MLWorks.Integer.makestring size ^ "\n")
d3477 1
d3484 2
a3485 4
        val list_size =
          Lists.reducel
          (fn (x:int, (_, {size=size, lexp=_})) =>
           x + size)
d3497 4
a3500 3
           AugLambda.INT arg => 
	     Crash.impossible "_mir_cg: AugLambda.INT\n"
         | _ => let
d3504 1
a3504 2
	     val main_tag = MirTypes.new_tag()
	     (* This tag marks the start of the body of the switch. *)
d3506 1
a3506 2
             val main_branch =
		   MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG main_tag)
d3508 5
a3512 22
	     val is_con = case tag_le_list of
	       (AugLambda.IMM_TAG _, _) :: _ => true
	     | (AugLambda.VCC_TAG _, _) :: _ => true
	     | _ => false

             val is_rel = case lexp of
               AugLambda.APP({lexp=AugLambda.BUILTIN(prim,_), ...}, _,_) =>
                 (case prim of
                    Pervasives.INTLESS => true
                  | Pervasives.REALLESS => true
                  | Pervasives.INTGREATER => true
                  | Pervasives.REALGREATER => true
                  | Pervasives.INTLESSEQ => true
                  | Pervasives.REALLESSEQ => true
                  | Pervasives.INTGREATEREQ => true
                  | Pervasives.REALGREATEREQ => true
                  | Pervasives.INTEQ => true
                  | Pervasives.INTNE => true
                  | Pervasives.REALEQ => true
                  | Pervasives.REALNE => true
                  | _ => false)
             | _ => false
d3515 2
a3516 3
               LambdaTypes.Option.ABSENT => false
             | LambdaTypes.Option.PRESENT _ => true

d3524 3
a3526 3
             val end_reg = MirTypes.GC.new()
             (* For the result *)
               
d3529 2
a3530 2
                 LambdaTypes.Option.ABSENT => ([], end_tag, [], [],RuntimeEnv.EMPTY,spills,calls)
               | LambdaTypes.Option.PRESENT{lexp=lexp, size=_} =>
d3532 2
a3533 1
                     val (regs, the_code,runtime_env,spills,calls) =
d3538 39
a3576 44
                     (* This may be a tail, but only if we are in 
			the tail line *)
                     val the_code = 
                       Mir_Utils.combine(
                        if debug_somevariables then 
                         let
                           val new_reg = MirTypes.GC.new()
                         in
                         ((Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG (new_reg),
                                                    MirTypes.GP_IMM_INT 0),
                                     MirTypes.STOREOP(MirTypes.STREF,MirTypes.GC_REG (new_reg),
                                                      MirTypes.GC_REG fp,
                                                      MirTypes.GP_IMM_SYMB 
                                          (MirTypes.GC_SPILL_SLOT 
                                              (LambdaTypes.Option.SOME1(fetch_spill ref_slot,
                                                        "default for switch"))))], 
                         [],MirTypes.Option.ABSENT, Sexpr.NIL), [], [])
                         end
                        else
                          no_code,
                       Mir_Utils.combine(
			 the_code,
                         ((Sexpr.ATOM(
			     MirTypes.COMMENT comment :: 
                               (case regs of
                                  Mir_Utils.ONE(Mir_Utils.INT reg) =>
                                    [MirTypes.UNARY(MirTypes.MOVE,
						    MirTypes.GC_REG end_reg,
						    reg)]
                                | Mir_Utils.ONE(Mir_Utils.REAL reg) =>
                                    Mir_Utils.save_real_to_reg(
				      reg,
				      MirTypes.GC_REG end_reg)
                                | Mir_Utils.LIST many =>
                                    (#2 (Mir_Utils.tuple_up_in_reg(many,
								   end_reg)))
			       ) @@
                               [final_branch]),
                             [],
			     MirTypes.Option.ABSENT,
			     Sexpr.NIL),
			  [],
			  [])
		       ))
d3579 10
d3590 1
a3590 21
                     case the_code of
                       ((first, blocks, MirTypes.Option.ABSENT, last),
			values,
			procs) =>
                         (MirTypes.BLOCK(new_tag, 
			    		 Mir_Utils.contract_sexpr first) ::
			    blocks,
			  new_tag,
			  values,
			  procs,runtime_env,spills,calls)
                     | ((first, blocks, MirTypes.Option.PRESENT tag, last),
			values,
			procs) =>
                         (MirTypes.BLOCK(new_tag,
					 Mir_Utils.contract_sexpr first) ::
                            MirTypes.BLOCK(tag,
					   Mir_Utils.contract_sexpr last) ::
			    blocks,
                          new_tag,
			  values,
			  procs,runtime_env,spills,calls)
d3593 1
a3593 1
             (* Deal with the possible default case *)
d3595 4
a3598 5
               get_blocks_for_dflts(
		 dflt,
                 static_offset + arg_size + list_size + tag_sizes,
                 start_at + arg_size + list_size + tag_sizes,
                 "simple default")
d3600 1
a3600 2
	     (* Count the different types of constructor, if appropriate.
	      *)
d3602 1
a3602 2
	       if not (is_con) then
		 (0, 0)
d3610 1
a3610 11
             fun convert_tag tag =
               case tag of
                 AugLambda.VCC_TAG(tag,_) => RuntimeEnv.CONSTRUCTOR(tag)
               | AugLambda.IMM_TAG(tag,_) => RuntimeEnv.CONSTRUCTOR(tag)
               | AugLambda.SCON_TAG(tag) => 
                   (case tag of
                      Ident.INT(tag,_) => RuntimeEnv.INT(tag)
                    | Ident.REAL(tag,_) => RuntimeEnv.REAL(tag)
                    | Ident.STRING(tag) => RuntimeEnv.STRING(tag))
               | AugLambda.EXP_TAG(_) => RuntimeEnv.DYNAMIC

d3612 33
a3644 28
              if debug_somevariables then
               let
                 val switch_cases = Lists.length(tag_le_list)
               in
               #2(Lists.reducer 
               (fn (((t, {lexp=x, ...}), le_offset),(switch_case,tagged_code)) =>
                let
                  val (reg, code,runtime_env,spills,calls) = 
                    cg_sub(x, env, closure, static_offset + le_offset,
                           start_at + le_offset, funs_in_closure, fn_tag_list,
			   tails, tuple_bindings,(slot,non_gc_spills,fp_spills),calls)
                  (* This may be a tail, but only if we are in the tail line *)
                  val new_reg = MirTypes.GC.new()
                in
                  (switch_case-1,
                   (t, (reg, 
                       Mir_Utils.combine(
                       ((Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG (new_reg),
                                                    MirTypes.GP_IMM_INT switch_case),
                                     MirTypes.STOREOP(MirTypes.STREF,MirTypes.GC_REG (new_reg),
                                                      MirTypes.GC_REG fp,
                                                      MirTypes.GP_IMM_SYMB 
                                          (MirTypes.GC_SPILL_SLOT (LambdaTypes.Option.SOME1(fetch_spill ref_slot,"switch case "^MLWorks.Integer.makestring switch_case))))], 
                       [],MirTypes.Option.ABSENT, Sexpr.NIL), [], []),code),(convert_tag t,runtime_env),
                       spills,calls),MirTypes.new_tag())::tagged_code)
                end)
               (Lists.zip(tag_le_list, positions),(switch_cases,nil)))
                 end
d3647 17
a3663 15
               (fn ((t, {lexp=x, ...}), le_offset) =>
                let
                  val (reg, code,runtime_env,spills,calls) =
                    cg_sub(x, env, closure, static_offset + le_offset,
                           start_at + le_offset, funs_in_closure, fn_tag_list,
			   tails, tuple_bindings,(slot,non_gc_spills,fp_spills),calls)
                  (* This may be a tail, but only if we are in the tail line *)
                in
                  (t, (reg, code, (convert_tag t,runtime_env),
                   spills,calls),MirTypes.new_tag())
                end)
               (Lists.zip(tag_le_list, positions))
               
             val spills = map (fn tuple => #4(#2(tuple))) tagged_code
             val calls = map (fn tuple => #5(#2(tuple))) tagged_code
d3665 5
a3669 5
               infix >
               fun (gc_spills:int, non_gc_spills:int, fp_spills:int) >
                 (gc_spills':int, non_gc_spills':int, fp_spills':int) =
                 gc_spills >= gc_spills' andalso non_gc_spills >= non_gc_spills' 
                 andalso fp_spills >= fp_spills
d3672 4
a3675 3
                 Lists.reducel (fn (max_spill,spill)=> 
                                if max_spill>spill then max_spill
                                else spill) ((0,0,0),(spills'::spills))
d3677 1
d3679 9
a3687 4
               Lists.reducel (fn (max_app,app)=> 
                              if max_app>app then max_app
                              else app) (0,(calls'::calls))
             val runtime_env = (RuntimeEnv.DEFAULT,runtime_env)::map (fn tuple => #3(#2(tuple))) tagged_code
d3691 1
a3691 1
                   ([(AugLambda.IMM_TAG (_,t1), _, tag)], LambdaTypes.Option.PRESENT _) =>
d3694 1
a3694 1
                     (AugLambda.IMM_TAG (_,t2), _, tag')], LambdaTypes.Option.ABSENT) =>
d3700 2
a3701 3
	     (* get_vcc_tag and get_imm_tag are only called when there
		is only one tag of the appropriate type.
	      *)
d3711 7
a3717 7
	       let val offset = ~1
	       in MirTypes.STOREOP(
		    MirTypes.LD,
		    MirTypes.GC_REG to_reg,
		    MirTypes.GC_REG from_reg,
		    MirTypes.GP_IMM_ANY offset
		  )
a3719 1

d3726 75
a3800 66
             fun destructuring_code(regs) = case regs of
               Mir_Utils.ONE(Mir_Utils.INT(gp_op as MirTypes.GP_GC_REG reg)) =>
		 let val (num_vccs, num_imms) =
		       case info of
			 LambdaTypes.Option.ABSENT =>
			   Crash.impossible "Missing switch info"
		       | LambdaTypes.Option.PRESENT{num_imms, num_vccs, ...} =>
			   (num_vccs, num_imms)
		 in
		   if num_imms = 0 then
		     let val tmp_reg = MirTypes.GC.new()
		     in (MirTypes.GP_GC_REG tmp_reg,
		         [MirTypes.COMMENT
			    "select for ONE/INT/GP_GC_REG, 0 IMM_TAG",
		          con_tag_to_reg (reg, tmp_reg),
			  main_branch
		         ],
		         true
		        )
		     end
		   else if num_vccs = 0 then
		     let val tmp_reg = MirTypes.GC.new()
		     in (gp_op,
		         [MirTypes.COMMENT
			    "select for ONE/INT/GP_GC_REG, 0 VCC_TAG",
			  main_branch
		         ],
		         true
		        )
		     end
		   else if num_vccs = 1 then
		     let val vcc_tag =
			   if num_vcc_tags = 1 then 
			     get_vcc_tag tagged_code
			   else if dflt_exists then
			     dflt_tag
			   else Crash.impossible "Missing vcc_tag or default"
		     in
		       (gp_op,
	                MirTypes.COMMENT"select for ONE/INT/GP_GC_REG, 1 VCC" ::
			MirTypes.TEST(MirTypes.BTA,
				      vcc_tag,
				      gp_op,
				      MirTypes.GP_IMM_ANY tag_test_mask) ::
		         (if num_imm_tags = 1 andalso num_imms = 1 then
			    [MirTypes.BRANCH(MirTypes.BRA,
					     MirTypes.TAG (get_imm_tag tagged_code))]
			  else if (*num_imms = 1 orelse *)num_imm_tags = 0 then
			    (* num_imms = 1 => num_imm_tags = 0 here *)
			    let
			      val branch =
				[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG dflt_tag)]
			    in
			      case dflt of
				LambdaTypes.Option.ABSENT =>
				  (* This is the nasty semantically invalid case *)
				  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG end_reg,
						 MirTypes.GP_IMM_INT 0) :: branch
			      | _ => branch
			    end
		         else
		           [main_branch]),
		       num_imms <> 1 andalso num_imm_tags <> 0)
		     end
		   else if num_imms = 1 then
		     let val tmp_reg = MirTypes.GC.new()
d3804 1
a3804 2
			   else if dflt_exists then
			     dflt_tag
d3806 50
a3855 56
		     in (MirTypes.GP_GC_REG tmp_reg,
		         MirTypes.COMMENT
			    "select for ONE/INT/GP_GC_REG, 1 IMM_TAG" ::
			     MirTypes.TEST(MirTypes.BNT,
					   imm_tag,
					   gp_op,
					   MirTypes.GP_IMM_ANY tag_test_mask) ::
			    (if num_vcc_tags = 0 then
		   	       [MirTypes.BRANCH(
			          MirTypes.BRA,
			          MirTypes.TAG dflt_tag
			       )]
			     else
		               [con_tag_to_reg (reg, tmp_reg),
			        main_branch]
			    ),
		         num_vcc_tags <> 0
		        )
		     end
		   else (* num_vccs > 1 andalso num_imms > 1 *)
		     if num_vcc_tags = 0 then
		       (gp_op,
		        [MirTypes.TEST(MirTypes.BTA,
			               dflt_tag,
			               gp_op,
			               MirTypes.GP_IMM_ANY tag_test_mask),
		         main_branch],
			true)
		     else if num_imm_tags = 0 then
	               let val tmp_reg = MirTypes.GC.new()
	               in (MirTypes.GP_GC_REG tmp_reg,
		           [MirTypes.TEST(MirTypes.BNT,
			                  dflt_tag,
			                  gp_op,
			                  MirTypes.GP_IMM_ANY tag_test_mask),
		            con_tag_to_reg (reg, tmp_reg),
		            main_branch],
			   true)
		       end
		     else
	               let val tmp_reg = MirTypes.GC.new()
	               in (MirTypes.GP_GC_REG tmp_reg,
	                   [MirTypes.COMMENT
			      "select for ONE/INT/GP_GC_REG, general case",
	  	            MirTypes.UNARY(MirTypes.MOVE,
	  			           MirTypes.GC_REG tmp_reg,
	  			           gp_op),
                            MirTypes.TEST(MirTypes.BNT,
			                  main_tag,
			                  MirTypes.GP_GC_REG tmp_reg,
			                  MirTypes.GP_IMM_ANY tag_test_mask),
		            con_tag_to_reg (reg, tmp_reg),
		            main_branch
		          ],
		          true)
	               end
d3857 1
a3857 2
	     | Mir_Utils.ONE(Mir_Utils.INT(gp_op)) =>
		 Crash.impossible "_mir_cg: Mir_Utils.INT\n"
d3859 1
a3859 2
             | Mir_Utils.ONE(Mir_Utils.REAL _) =>
		 Crash.impossible "SWITCH(Mir_Utils.ONE(Mir_Utils.REAL))"
d3861 1
d3864 8
a3871 8
		     val extra = (case Lists.nth(index, many) of
		       Mir_Utils.INT gp_op =>
		         MirTypes.UNARY(MirTypes.MOVE,
				        MirTypes.GC_REG tmp_reg,
				        gp_op)
		     | Mir_Utils.REAL fp_op =>
		         Crash.impossible "REAL when decoding list"
		     ) handle
d3873 4
a3876 5
	                 Crash.impossible(
			   "Trying to select constructor tag " ^
			   " from list size " ^
		           MLWorks.Integer.makestring(Lists.length many) ^
			   "\n")
d3880 1
a3880 2
		     true
		    )
d3882 11
a3892 3
                         
             val (regs, the_reg_opt, the_code, test_code, need_main_test,
                  runtime_env',spills,calls) =
d3895 4
a3898 3
                   val (primAndTy, arg, is_struct) = case lexp of
                     AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, ...},
                                   {lexp=AugLambda.STRUCT le_list, ...},_) =>
d3900 5
a3904 5
                   | AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, ...}, 
				   arg,
				   _) =>
                       (primAndTy, [arg], false)
                   | _ => Crash.impossible"Bad rel lexp"
d3906 1
a3906 4
                   val lv_le_list =
                     map
                     (fn le => (LambdaTypes.new_LVar(), le))
                     arg
d3920 6
a3925 7
                       {lexp=(if is_struct then
                                AugLambda.STRUCT(
				  map (fn (lvar, _) => {lexp=AugLambda.VAR lvar,
                                                        size=0})
				      lv_le_list)
                              else AugLambda.VAR lvar),
			size=0},
d3943 1
a3943 1
		       ((Sexpr.ATOM extra, [], MirTypes.Option.ABSENT, Sexpr.NIL),
d3949 1
a3949 1
                   (rest_regs, MirTypes.Option.PRESENT the_reg, code, 
d3953 1
d3956 1
d3960 2
a3961 2
                   val (the_reg, select_code, need_main_test) =
		     destructuring_code (regs)
d3964 4
a3967 9
		     Mir_Utils.combine(
		       the_code,
		       ((Sexpr.ATOM (select_code),
                         [],
                         MirTypes.Option.ABSENT,
                         Sexpr.NIL),
                        [],
                        [])
		    )
d3970 3
a3972 3
		    MirTypes.Option.PRESENT the_reg,
		    block,
		    no_code,
d3976 1
d3979 1
d3989 1
a3989 1
                         MirTypes.Option.ABSENT,
d3995 2
a3996 1
		   (regs, MirTypes.Option.ABSENT, block, no_code, true,runtime_env,spills,calls)
d3998 6
a4003 4
               
             val calls : int ref = ref(calls)
             val spills : (int * int * int) ref = ref(spills)
             val runtime_env' : RuntimeEnv.debugger_env ref = ref(runtime_env')
d4007 1
a4007 1
               Crash.impossible"make_cgt GP_IMM_INT"
d4015 13
a4027 13
                   val (dflt_tag, end_blocks) = case dflt of
                     LambdaTypes.Option.ABSENT =>
                       let val tag1 = MirTypes.new_tag()
                       in (tag1,
                           [MirTypes.BLOCK(
			      tag1,
                              [MirTypes.COMMENT "CGT default",
			       MirTypes.UNARY(MirTypes.MOVE,
                                              MirTypes.GC_REG end_reg,
                                              MirTypes.GP_IMM_ANY 1),
                               final_branch])])
                       end
                   | _ => (dflt_tag, [])
d4034 1
a4034 2
                           tag :: Mir_Utils.list_of(j-i-1, dflt_tag) @@
				    expand rest
d4044 1
d4050 19
a4068 23
		   val body = map
                    (fn (_, (regs, ((first, blocks, tag_opt, last), _, _),_,_,_),
                         tag) =>
                     let
		       val end_code =
			 Mir_Utils.send_to_given_reg(regs, end_reg) @@
			 [MirTypes.COMMENT "end CGT", final_branch]
                     in
                       (case tag_opt of
                          MirTypes.Option.ABSENT =>
                            [MirTypes.BLOCK(
			       tag,
                               Mir_Utils.contract_sexpr(
				 Sexpr.CONS(first, Sexpr.ATOM end_code)))]
                        | MirTypes.Option.PRESENT tag1 =>
                            [MirTypes.BLOCK(tag,
					    Mir_Utils.contract_sexpr first),
                             MirTypes.BLOCK(
			       tag1,
			       Mir_Utils.contract_sexpr(
			         Sexpr.CONS(last, Sexpr.ATOM end_code)))]
                       ) @@ blocks
                     end)
d4071 2
a4072 2
                   ((if is_rel orelse not(need_main_test) then
		       Sexpr.NIL
d4101 1
a4101 1
                     MirTypes.Option.ABSENT,
d4107 2
a4108 2
                 end
               
d4114 2
a4115 1
                        
a4116 1

d4121 1
a4121 1
		    (LambdaTypes.Option.PRESENT _, MirTypes.Option.PRESENT _) =>
d4124 1
a4124 1
		  | (LambdaTypes.Option.PRESENT _, MirTypes.Option.ABSENT) =>
d4126 1
a4126 1
		  | (_, MirTypes.Option.PRESENT _) =>
d4132 1
a4132 1
		    MirTypes.Option.ABSENT,
d4138 10
a4147 10
				  default,
                                  (scon,
				   le,
				   (regs,
				    ((first, blocks, tag_opt, last),
				     values,
				     procs
				   ),_,_,_),
                                   tag) :: rest,
				  test_code) =
d4151 2
a4152 2
		       MirTypes.Option.PRESENT f => f(the_reg, scon, le, tag)
		     | MirTypes.Option.ABSENT => Sexpr.NIL
d4158 1
a4158 1
			  LambdaTypes.Option.ABSENT =>
d4161 1
a4161 1
			       MirTypes.Option.PRESENT _ =>
d4177 1
a4177 1
                       MirTypes.Option.ABSENT =>
d4184 2
a4185 2
                          MirTypes.Option.ABSENT, Sexpr.NIL)
                     | MirTypes.Option.PRESENT tag'=>
d4193 1
a4193 1
                          MirTypes.Option.ABSENT,
d4199 2
a4200 1
               
d4203 1
a4216 2
                   val (low, high) = bounds(i, i, map #1 val_code_tags_list)

d4219 2
a4220 2
		       MirTypes.Option.PRESENT x => x
		     | MirTypes.Option.ABSENT => Crash.impossible "Missing the_reg"
d4222 7
a4228 5
		   if Lists.length val_code_tags_list < 3 then
		     let fun do_test(reg, i, _, tag) =
			     Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag, reg,
                                                      MirTypes.GP_IMM_INT i)]
			 
d4230 13
a4242 13
                           map (fn (i, code, tag) =>
                                 (i, 0, code, tag))
                               val_code_tags_list
		     in ([],
			 do_chained_tests(the_reg,
					  dflt,
					  val_le_tags_list,
                           		  if need_main_test then
					     MirTypes.Option.PRESENT do_test
					  else
					    MirTypes.Option.ABSENT)
			)
		     end
d4244 7
a4250 3
                     let val dflt_code = case dflt of
                           LambdaTypes.Option.ABSENT => []
                         | LambdaTypes.Option.PRESENT _ =>
d4253 4
a4256 4

                         val main =
                           make_cgt(the_reg, low, high, val_code_tags_list)
                     in (dflt_code, main)
d4260 1
a4260 3
             (* Deal with the tagged value list *)
             val (main_default, main_code) = case tag_le_list of
               [] =>
d4263 2
a4264 2
                     LambdaTypes.Option.ABSENT => []
                   | LambdaTypes.Option.PRESENT _ =>
d4269 2
a4270 5
             | (AugLambda.IMM_TAG _, _) :: _ =>
		 constructor_code ()
             | (AugLambda.VCC_TAG _, _) :: _ =>
		 constructor_code ()
             | (AugLambda.SCON_TAG x, _) :: rest =>
d4274 1
a4274 1
                 (case x of
d4285 1
a4285 1
			  | _ => Crash.impossible"Mixed tag type in switch")
d4291 1
a4291 2
			  val (low, high) =
			    bounds(a_value, a_value, map #1 val_le_tags_list)
d4293 1
a4293 1
			  val use_cgt = high+1-low <= 2*len andalso len > 2
d4297 2
a4298 3
			    LambdaTypes.Option.ABSENT =>
			      [MirTypes.COMMENT"No default (strange for scon match)"]
			  | LambdaTypes.Option.PRESENT _ =>
d4319 1
a4319 1
						MirTypes.Option.PRESENT do_test))
d4322 2
a4323 1
			  (* This modification in preparation for long integers *)
d4329 3
a4331 6
			      | to_string _ =
				Crash.impossible"Mixed tag type in switch"
			    fun location_scon(Ident.INT(_, location)) =
			      location
			      | location_scon _ =
				Crash.impossible"Mixed tag type in switch"
d4347 7
a4353 5
			    val low = case val_le_tags_list of
			      (scon, _, _, _) :: _ => scon
			    | _ => Crash.impossible"Empty switch list"
			    val high = case (last val_le_tags_list) of
			      (scon, _, _, _) => scon
d4355 2
a4356 3
			      LambdaTypes.Option.ABSENT =>
				[MirTypes.COMMENT"No default (strange for scon match)"]
			    | LambdaTypes.Option.PRESENT _ =>
d4364 1
a4364 1
				     ((code, [], MirTypes.Option.ABSENT, Sexpr.NIL),
d4386 1
a4386 1
				   ((code, [], MirTypes.Option.ABSENT, Sexpr.NIL),
d4405 1
a4405 1
					      MirTypes.Option.PRESENT do_test))
d4412 2
a4413 2
			  end
		      end
d4415 1
d4422 4
a4425 3
                        val (the_reg, extra) = case regs of
                          Mir_Utils.ONE reg => Mir_Utils.get_real reg
                        | _ => Crash.impossible "struct gives single REAL"
d4432 2
a4433 2
                      in the case of a real or string
                        tag is where to go to on successful comparison *)
d4454 1
a4454 2
                               MirTypes.VALUE(
                                              top_closure (start_at + p + 1),
d4461 3
a4463 3
                         Mir_Utils.combine(((Sexpr.NIL, [], MirTypes.Option.ABSENT, Sexpr.NIL), tags_code, []),
                                           do_chained_tests(the_reg, dflt, val_le_tags_list, MirTypes.Option.PRESENT do_test)))
                      end
d4472 4
a4475 3
                        val the_reg = case regs of
                          Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_GC_REG _)) => arg
                        | _ => Crash.impossible"struct gives single STRING"
d4482 2
a4483 2
                      in the case of a real or string
                        tag is where to go to on successful comparison *)
d4487 1
a4487 2
                              cg_sub(AugLambda.VAR(NewMap.apply'(prim_to_lambda, 
                                                                 Pervasives.STRINGEQ)),
d4503 1
a4503 1
                                              (_, ((app_code, [], MirTypes.Option.ABSENT, last), 
d4518 1
a4518 1
                                                               MirTypes.Option.ABSENT),
d4546 3
a4548 3
                         Mir_Utils.combine(((Sexpr.NIL, [], MirTypes.Option.ABSENT, Sexpr.NIL), tags_code, []),
                                           do_chained_tests(the_reg, dflt, val_le_tags_list, MirTypes.Option.PRESENT do_test)))
                      end)
d4550 1
a4550 1
             | (AugLambda.EXP_TAG _, _) :: rest =>
d4559 4
a4562 3
                   val the_reg = case regs of
                     Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_GC_REG _)) => arg
                   | _ => Crash.impossible"Bad reg for exception"
d4566 2
a4567 2
                      le is the exception expression to match
                      tag is where to go to on successful comparison *)
d4573 1
a4573 1
                            ((code, [], MirTypes.Option.ABSENT, last), [], []),
d4589 1
a4589 1
                   ([], do_chained_tests(the_reg, dflt, val_le_tags_list, MirTypes.Option.PRESENT do_test))
d4591 2
a4592 1
             val the_code =
d4595 1
d4601 1
a4601 1
		   val first' = rev(Mir_Utils.contract_sexpr first)
d4619 2
a4620 2
			  (case tag_opt of MirTypes.Option.ABSENT => "ABSENT"
			| MirTypes.Option.PRESENT tag => MirTypes.print_tag tag) ::
d4656 2
a4657 2
			  (case tag_opt of MirTypes.Option.ABSENT => "ABSENT"
			| MirTypes.Option.PRESENT tag => MirTypes.print_tag tag) ::
d4672 20
d4695 1
a4695 1
		(the_code,
d4697 1
a4697 1
		 (((Sexpr.NIL, [], MirTypes.Option.PRESENT main_tag, Sexpr.ATOM main_default),
d4703 1
a4703 1
		((Sexpr.NIL, dflt_blocks, MirTypes.Option.PRESENT end_tag, Sexpr.NIL),
d4709 4
a4712 5
                   if debug_somevariables then 
                     RuntimeEnv.SWITCH(!runtime_env',fetch_spill ref_slot,
                                       maximum_calls,runtime_env)
                   else 
                     RuntimeEnv.EMPTY,
d4728 1
a4728 1
      (Mir_Utils.ONE reg, ((Sexpr.ATOM code, [], MirTypes.Option.ABSENT,
d4731 1
d4779 1
a4779 1
	      MirTypes.Option.ABSENT, Sexpr.NIL),
d4796 1
a4796 1
         MirTypes.Option.ABSENT, Sexpr.NIL),
d4800 4
a4803 1
    | cg_sub(fcn as AugLambda.FN(lvar, {lexp=lexp, size=gc_objects_within},
d4807 115
a4921 64
    let
(*val _ = output(std_out, "\n"^name_string)*)
      val prev_first_spill = restore_spill()
      val _ = assign_spill()
      val (_, free) =
	 let
	   val Mir_Env.LAMBDA_ENV lambda_env = env
	   val Mir_Env.CLOSURE_ENV closure_env = closure
	   fun add_member (set, x, _) = HashSet.add_member(set, x)
	 in
	   new_frees
	   ((LambdaTypes.Map.fold add_member (LambdaTypes.Map.fold add_member (HashSet.empty_set hashset_size, closure_env), lambda_env),
	     HashSet.empty_set hashset_size),
	    {lexp=fcn, size=0})
	 end
      val free =
	let
	  val free' =
	    if Mir_Utils.needs_prim_stringeq fcn then
	      HashSet.add_member(free, NewMap.apply'(prim_to_lambda, Pervasives.STRINGEQ))
	    else
	      free
	in
	  HashSet.set_to_list
	  (Lists.reducel
	   (fn (free', x) => HashSet.add_member(free', NewMap.apply'(prim_to_lambda, x)))
	   (free', Set.set_to_list(Library.implicit_external_references fcn)))
	end
      val tag =
	top_closure(start_at + gc_objects_within + 1)
      val gc_reg = MirTypes.GC_REG(MirTypes.GC.new())
      val (cl_reg, code, new_closure) =
	case Mir_Utils.make_closure([tag], free, gc_objects_within,
			  static_offset + (funs_in_closure * 2 - 1), env,
			  closure, funs_in_closure) of
	  (reg, code, [new_closure]) =>
	    (reg, Sexpr.CONS(code,
	      Sexpr.ATOM[MirTypes.COMMENT"Copy in function pointer",
	        MirTypes.STOREOP(MirTypes.LD, gc_reg,
				 MirTypes.GC_REG callee_closure,
	        MirTypes.GP_IMM_ANY(4*((funs_in_closure*2-1) + static_offset +
				    gc_objects_within) - 1)),
	        MirTypes.STOREOP(MirTypes.ST, gc_reg, reg,
				 MirTypes.GP_IMM_ANY ~1)]),
	      new_closure)
	| _ => Crash.impossible"Single FN with multiple tags"
      val copied_callee_arg = MirTypes.GC.new()
      val (fn_reg, fn_code,runtime_env,(gc_spills,non_gc_spills,fp_spills),_) =
	cg_sub(lexp,
	       Mir_Env.add_lambda_env((lvar, MirTypes.GC copied_callee_arg ),
				      Mir_Env.empty_lambda_env),
	       (* All bets for registers are off, barring the argument *)
	       new_closure, 0, start_at, 1, [tag] (* tag for this function *),
	       true, [],(1,0,0),0)
      (* No information for untupling, cos function doesn't recurse *)
      val final_code =
	let
	  val result_temporary = MirTypes.GC.new ()
	in
	  Mir_Utils.send_to_given_reg(fn_reg, result_temporary) @@
	  [MirTypes.UNARY(MirTypes.MOVE,
			  MirTypes.GC_REG callee_arg,
			  MirTypes.GP_GC_REG result_temporary)]
	end
a4922 43
      val comment_string =
        if name_string ="" 
          then [] 
        else [MirTypes.COMMENT name_string]

      val entry_code =
	(Sexpr.ATOM
         (comment_string @@
          [MirTypes.ENTER] @@
          (if intercept then [MirTypes.INTERCEPT] else []) @@
          [(* "Move the argument to somewhere safe, and let register colouring deal with allocation" *)
           MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG copied_callee_arg,
                          MirTypes.GP_GC_REG callee_arg)]),
	  [], MirTypes.Option.ABSENT, Sexpr.NIL)
      val exit_code =
	(Sexpr.ATOM(final_code @@
	  [MirTypes.RTS]),
	  [], MirTypes.Option.ABSENT, Sexpr.NIL)
      val ((first, blocks, tag_opt, last), values, procs) =
	Mir_Utils.combine((entry_code, [], []), Mir_Utils.combine(make_call_code(0,fn_code), (exit_code, [], [])))
      val the_fn =
	[MirTypes.PROC(name_string,
                       tag,
		       MirTypes.PROC_PARAMS
		       {leaf = false, (* Calculated by mir optimiser *)
			registers_used = MirTypes.Option.ABSENT,
			spill_sizes = if debug_somevariables then 
                                            MirTypes.Option.PRESENT{gc = gc_spills+1, 
						non_gc = non_gc_spills+1,fp = fp_spills+1}
                                      else 
                                        MirTypes.Option.ABSENT,
			stack_allocated = MirTypes.Option.ABSENT,
                        loop_entry = MirTypes.Option.ABSENT},
		       MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr first) ::
		       blocks @@
	(case tag_opt of
	  MirTypes.Option.ABSENT => []
	| MirTypes.Option.PRESENT tag =>
	    [MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr last)]),
           if debug_somevariables then 
             RuntimeEnv.FN(name_string,runtime_env,head_spill(deref_spill()),instances)
           else
             RuntimeEnv.EMPTY)]
d4924 9
a4932 5
    in
      (Mir_Utils.ONE(Mir_Utils.INT(Mir_Utils.gp_from_reg cl_reg)), ((code, [], MirTypes.Option.ABSENT, Sexpr.NIL), values,
				      the_fn :: procs),
	RuntimeEnv.EMPTY,spills,calls)
    end
d4944 1
d4946 9
a4954 9
        Lists.reducer (fn (LambdaTypes.Option.PRESENT(x),xs) => (x,RuntimeEnv.EMPTY)::xs
                        | (LambdaTypes.Option.ABSENT,xs) => xs)
        (map (fn LambdaTypes.Option.SOME1(lvar) => LambdaTypes.Option.ABSENT
               | LambdaTypes.Option.SOME2(ref(lvar,
                            debug_info as LambdaTypes.Option.PRESENT(name,ty,_))) => 
               (LambdaTypes.Option.PRESENT(LambdaTypes.Option.PRESENT
                                           (name,ty,LambdaTypes.Option.ABSENT)))
               | LambdaTypes.Option.SOME2(ref(lvar,debug_info as LambdaTypes.Option.ABSENT)) => 
                  LambdaTypes.Option.ABSENT) 
d4957 1
d4964 2
a4965 2
	(fn {lexp=AugLambda.FN(lv, le, _,_), ...} => (lv, le)
        | _ => Crash.impossible"non-FN in LETREC")
d4967 1
d4974 1
a4974 1
      val (fn_args, le_list'') = Lists.unzip fn_args_and_bodies
d4976 1
a4977 25
      val (_, free) =
	 let
	   val Mir_Env.LAMBDA_ENV lambda_env = env
	   val Mir_Env.CLOSURE_ENV closure_env = closure
	   fun add_member (set, x, _) = HashSet.add_member(set, x)
	 in
	   new_frees
	   ((LambdaTypes.Map.fold add_member (LambdaTypes.Map.fold add_member (HashSet.empty_set hashset_size, closure_env), lambda_env),
	     HashSet.empty_set hashset_size),
	    {lexp=AugLambda.STRUCT le_list'', size=0})
	 end
      val free =
	let
	  val free' =
	    if Mir_Utils.lneeds_prim_stringeq le_list'' then
	      HashSet.add_member(free, NewMap.apply'(prim_to_lambda, Pervasives.STRINGEQ))
	    else
	      free
	in
	  HashSet.set_to_list
	  (Lists.reducel
	   (fn (free', x) => HashSet.add_member(free', NewMap.apply'(prim_to_lambda, x)))
	   (free', Set.set_to_list(Library.implicit_external_references (AugLambda.STRUCT le_list))))
	(* Put the functions into a STRUCT for ease of code *)
	end
d4979 2
a4980 2
	Lists.reducel (fn (x, {size=size, lexp=_}) => x+size) (0, le_list'')
      val positions = do_pos3(0, le_list'')
d4982 1
a4982 1
	map #2 (#1 (Lists.number_from(Mir_Utils.list_of(funs, 0), 0, 2, ident_fn)))
d4984 1
d4986 1
a4986 3
	map (fn x =>
	     top_closure(start_at + gc_objects_within + (x div 2) + 1)
	     )
d4988 1
d4990 1
d4993 5
a4997 4
		     static_offset + (2 * funs_in_closure - 1), env, closure,
		     funs_in_closure)
      val new_reg_list =
	map (fn x => (x, MirTypes.GC.new())) offsets
d5006 2
a5007 16
      (* Calculate the new bindings for registers to lambdas in lv_list *)
      val letrec_env =
	Lists.reducel
	(fn (env, (lv, (_, reg))) =>
	  Mir_Env.add_lambda_env((lv, MirTypes.GC reg), env))
	(Mir_Env.empty_lambda_env, Lists.zip(lv_list, new_reg_list))
      (* Calculate the closures for the code generation of the functions *)
      val new_closure_list =
	map (fn (closure, offset) =>
	  Lists.reducel
	  (fn (clos, (lv, off)) => Mir_Env.add_closure_env((lv, off), clos))
	  (closure, #1 (Lists.number_from(lv_list, 0 - offset, 2, fn x=> x))))
	(Lists.zip(new_closure_list, offsets))
      
      (* Add the lambdas for the functions themselves *)
      (* Changed above to alow for interspersed zeroes in closures *)
d5011 1
a5011 1
	  Sexpr.ATOM[MirTypes.COMMENT"Copy in function pointers"] :: (map
d5014 5
a5018 5
			      MirTypes.GC_REG callee_closure,
	      MirTypes.GP_IMM_ANY(4*((funs_in_closure*2-1) + static_offset +
				  gc_objects_within + (x div 2)) - 1)),
	      MirTypes.STOREOP(MirTypes.ST, gc_reg, cl_reg,
			      MirTypes.GP_IMM_ANY(4*x-1))])
d5020 2
d5034 1
d5036 9
d5047 2
d5050 5
a5054 1
      val (arg_select_list, le_list''') = Lists.unzip select_rest_list
d5056 5
a5060 1
	map (fn lvar => (lvar, MirTypes.GC.new())) fn_args
d5063 4
a5066 3
	(fn (lvar, reg) =>
	 Mir_Env.add_lambda_env((lvar, MirTypes.GC reg),
				Mir_Env.empty_lambda_env))
d5068 15
d5084 1
a5084 1
      val initial_copy_list =
d5086 6
a5091 6
	(fn (_, reg) =>
	 [(* "Move the argument to somewhere safe, *)
	 (* and let register colouring deal with allocation" *)
	  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG reg,
			 MirTypes.GP_GC_REG callee_arg)]
	 )
d5096 1
d5099 1
a5099 1
	(fn (((((arg_copy, bindings), env), new_closure), pos), x) =>
d5105 1
d5107 1
a5107 3
	   (make_call_code(0,Mir_Utils.combine
	    (((Sexpr.ATOM arg_copy, [], MirTypes.Option.ABSENT, Sexpr.NIL), [], []),
	     code)), env, static, start,runtime_env,spills,calls,firstspill)
d5109 8
a5116 8
	(Lists.zip(
		   Lists.zip(
			     Lists.zip(Lists.zip(Lists.zip(initial_copy_list,
							   arg_select_list),
						 initial_env_list),
				       new_closure_list),
			     positions),
		   offsets))
d5119 1
a5119 1
	(fn ((_, env, _, _,_,_,_,_), ((_, reg), arg_selects)) =>
d5123 1
a5123 1
	  (index, Mir_Env.lookup_lambda(lv, env))
d5125 8
a5132 4
	 arg_selects)
	 (Lists.zip(code_env_static_start_list,
		    Lists.zip(args_and_copied_callee_arg_list,
			      arg_select_list)))
d5135 3
a5137 3
	(fn ((((((lexp, (code, env, static_offset, start_at,runtime_env,
                         spills,calls,firstspill)), 
                 new_closure),x), lvar), tuple_bindings), fn_arg) =>
d5140 2
a5141 1
	   val (regs, code',runtime_env',spills,calls) =
d5143 4
a5146 3
		    funs - x div 2, tags, true, tuple_bindings,spills,calls)
           val loop_tag =
             top_lambda_loop_tags lvar
d5150 1
a5150 1
               MirTypes.Option.PRESENT loop_tag, 
d5152 15
a5166 12
                 case (Mir_Env.lookup_lambda (fn_arg, env)) of
                   MirTypes.GC reg =>
                     Sexpr.ATOM
                     ((if insert_interrupt then [MirTypes.INTERRUPT] else []) @@
                      [MirTypes.UNARY(MirTypes.MOVE,
                                      MirTypes.GC_REG callee_arg,
                                      MirTypes.GP_GC_REG reg),
                       MirTypes.INTERCEPT,
                       MirTypes.UNARY(MirTypes.MOVE,
                                      MirTypes.GC_REG callee_arg,
                                      MirTypes.GP_GC_REG reg)])
                 | _ => Crash.impossible "fn_arg not GC register"
d5173 4
a5176 1
	 (* Leave a point at which tail recursion can re-enter *)
d5178 2
a5179 6
	   (regs, Mir_Utils.combine(Mir_Utils.combine(code, end_block),code'),
            (case runtime_env of 
               RuntimeEnv.LIST(runtime_envs) => 
                 RuntimeEnv.LIST(runtime_envs@@[runtime_env'])
             | _ => Crash.impossible 
                 "fn_reg_code_list:LETREC:_mir_cg.sml",spills,firstspill),
d5182 7
a5188 10
         (Lists.zip
          (Lists.zip
           (Lists.zip
            (Lists.zip
             (Lists.zip(Lists.zip(le_list''', code_env_static_start_list),
                        new_closure_list),
              offsets),
             lv_list),
            int_reg_list_list),
           fn_args))
d5192 1
d5195 1
a5195 1
	  fun send ((x, _, _, _), new_closure) =
d5199 1
a5199 1
	     Mir_Utils.send_to_given_reg(x, result_temporary) @@
d5205 1
a5205 1
	  map send (Lists.zip(fn_reg_code_list, new_closure_list))
a5207 12
      fun generate_entry_code name = 
        let
          val comment_for_name =
            if name=""
              then []
            else [MirTypes.COMMENT name]
        in
	((Sexpr.ATOM(comment_for_name @@
		     [MirTypes.ENTER]),
	[], MirTypes.Option.ABSENT, Sexpr.NIL), [], [])
        end

d5210 2
a5211 2
	     ((Sexpr.CONS(Sexpr.ATOM final_code, Sexpr.ATOM[MirTypes.RTS]),
	      [], MirTypes.Option.ABSENT, Sexpr.NIL), [], []))
d5213 1
d5216 2
a5217 2
	(fn (((_, fn_code, env_spills, loop_tag), exit_code),(name,_)) =>
	  (Mir_Utils.combine(generate_entry_code name, Mir_Utils.combine(fn_code, exit_code)),
d5220 2
a5221 1
	(Lists.zip(Lists.zip(fn_reg_code_list, exit_code_list),lambda_names))
d5224 4
a5227 3
	(fn ((tag, (((first, blocks, tag_opt, last), vals, procs),
                    (runtime_env, (gc_spills, non_gc_spills, fp_spills), first_spill),
                    loop_tag)),
d5229 32
a5260 31
	     (vals, procs,
	       MirTypes.PROC(name,
                             tag,
			     MirTypes.PROC_PARAMS
			     {leaf = false,
			      registers_used = MirTypes.Option.ABSENT,
			      spill_sizes = 
                              if debug_somevariables then 
                                MirTypes.Option.PRESENT{gc = gc_spills+1, 
						non_gc = non_gc_spills+1,fp = fp_spills+1}
                              else 
                                MirTypes.Option.ABSENT,
			      stack_allocated = MirTypes.Option.ABSENT,
                              loop_entry = MirTypes.Option.PRESENT loop_tag},
			     MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr
					    first) :: blocks @@
	(case tag_opt of
	  MirTypes.Option.ABSENT => []
	| MirTypes.Option.PRESENT tag =>
	    [MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr last)]),
           if debug_somevariables then 
             RuntimeEnv.FN(name,runtime_env,head_spill(fetch_spill first_spill),instances)
           else
             RuntimeEnv.EMPTY)))
	(Lists.zip(Lists.zip(tags, fn_list),lambda_names))
      val (regs, ((first, blocks, tag_opt, last), vals, procs),runtime_env,spills,calls) =
	cg_sub(lexp, Mir_Env.augment_lambda_env(env, letrec_env), closure,
	       static_offset + gc_objects_within + funs,
	       start_at + gc_objects_within + funs, funs_in_closure,
	       fn_tag_list, false, [],spills,calls)
      val val_list =
d5264 2
d5270 23
a5292 1
      val this_proc_list = map #3 fn_val_procs_proc_list
d5294 4
a5297 7
      (regs, ((Sexpr.CONS(code, first), blocks , tag_opt, last),
	      vals @@ val_list,
	      this_proc_list :: procs @@ proc_list),
       if debug_somevariables then 
         RuntimeEnv.LET(runtime_lets,runtime_env)
       else 
         RuntimeEnv.EMPTY,
d5300 2
d5319 1
a5319 1
                                              ((Sexpr.ATOM final_code, [], MirTypes.Option.ABSENT,
d5323 1
a5323 1
       if debug_somevariables then 
d5328 2
d5411 1
a5411 1
				  MirTypes.Option.ABSENT) ::
d5427 1
a5427 1
		((Sexpr.ATOM frame_setup, [exn_end], MirTypes.Option.ABSENT,
d5447 1
a5447 1
		((Sexpr.ATOM main_end, [], MirTypes.Option.PRESENT end_tag,
d5453 1
a5453 1
       if debug_somevariables then 
d5473 2
a5474 1
    val (reg, last') = case regs of
d5509 1
a5509 1
	  Sexpr.ATOM[MirTypes.ENTER,
d5512 1
a5512 1
	  Sexpr.ATOM[MirTypes.ENTER]),
d5520 2
a5521 2
	(MirTypes.Option.ABSENT, []) => (Sexpr.CONS(entry, last''), blocks)
      | (MirTypes.Option.PRESENT tag, _) =>
d5524 1
a5524 1
      | (MirTypes.Option.ABSENT, _) =>
d5533 1
a5533 1
					  registers_used = MirTypes.Option.ABSENT,
d5535 4
a5538 3
                                          if debug_somevariables then 
                                            MirTypes.Option.PRESENT{gc = gc_spills+1, 
						non_gc = non_gc_spills+1,fp = fp_spills+1}
d5540 3
a5542 3
                                            MirTypes.Option.ABSENT,
					  stack_allocated = MirTypes.Option.ABSENT,
                                          loop_entry = MirTypes.Option.ABSENT},
d5545 1
a5545 1
                    if debug_somevariables then 
d5579 1
a5579 1
	| tag_ref(BRANCH_AND_LINK(_, bl_dest, _)) =
d5583 1
a5583 1
	| tag_ref(TAIL_CALL(_, bl_dest)) =
d5595 1
a5595 1
	| tag_ref ENTER = []
d5634 2
a5635 2
	    MirTypes.Option.ABSENT => blocks
	  | MirTypes.Option.PRESENT exit_block =>
@


1.237
log
@New runtime directory structure.
@
text
@d4 3
d1167 2
a1168 1
       fn () => AugLambda.count_gc_objects (new_lambda_exp,debug,
@


1.236
log
@Added code to remove unreferenced blocks
@
text
@d4 3
d880 1
a880 1
require "../rts/implicit";
@


1.235
log
@Passing out the loop entry tag for _mirvariable.
@
text
@d4 3
d5393 75
d5476 8
a5483 1
		Mir_Utils.append_small_exit(exit_block, blocks)
@


1.234
log
@Change handler to use LEO instead of LEA
@
text
@d4 3
d4781 2
a4782 1
			stack_allocated = MirTypes.Option.ABSENT},
d5000 2
d5003 19
a5021 20
	     let
	       val loop_tag =
		 top_lambda_loop_tags lvar
	     in
	       ((Sexpr.ATOM [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)],
                 [],
                 MirTypes.Option.PRESENT loop_tag, 
                 if intercept then
                   case (Mir_Env.lookup_lambda (fn_arg, env)) of
                     MirTypes.GC reg =>
                       Sexpr.ATOM
                       ((if insert_interrupt then [MirTypes.INTERRUPT] else []) @@
                        [MirTypes.UNARY(MirTypes.MOVE,
                                        MirTypes.GC_REG callee_arg,
                                        MirTypes.GP_GC_REG reg),
                         MirTypes.INTERCEPT,
                         MirTypes.UNARY(MirTypes.MOVE,
                                        MirTypes.GC_REG callee_arg,
                                        MirTypes.GP_GC_REG reg)])
                   | _ => Crash.impossible "fn_arg not GC register"
d5023 2
a5024 6
                   if insert_interrupt then
		     Sexpr.ATOM[MirTypes.INTERRUPT]
		   else
		     Sexpr.NIL),
                [], [])
	     end
d5028 6
a5033 5
		(case runtime_env of 
                   RuntimeEnv.LIST(runtime_envs) => 
                     RuntimeEnv.LIST(runtime_envs@@[runtime_env'])
                 | _ => Crash.impossible 
                     "fn_reg_code_list:LETREC:_mir_cg.sml",spills,firstspill))
d5050 1
a5050 1
	  fun send ((x, _,_), new_closure) =
d5082 1
a5082 1
	(fn (((_, fn_code,env_spills), exit_code),(name,_)) =>
d5084 2
a5085 1
	   env_spills))
d5089 4
a5092 1
	(fn ((tag, (((first, blocks, tag_opt, last), vals, procs),(runtime_env,(gc_spills,non_gc_spills,fp_spills),first_spill))),(name,instances)) =>
d5105 2
a5106 1
			      stack_allocated = MirTypes.Option.ABSENT},
d5377 2
a5378 1
					  stack_allocated = MirTypes.Option.ABSENT},
@


1.233
log
@Changes for automatic_callee mechanism removal
and moving machspec from machine to main
@
text
@d4 4
d5177 1
d5184 1
d5212 10
a5221 10
      (* 4	offset from above of continuation point } GC safe *)
      val frame_setup =
        let
          val offset_reg = MirTypes.GC.new()
          val offset = MirTypes.GC_REG offset_reg
          val gp_offset = MirTypes.GP_GC_REG offset_reg
	  val exn_result_reg = case exn_result_reg of
	    Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG reg)) => MirTypes.GC_REG reg
	  | _ => Crash.impossible"Exn_result_reg"
        in
d5230 1
d5235 1
d5238 16
d5255 1
a5255 13
      val frame_setup =
	MirTypes.ALLOCATE_STACK(MirTypes.ALLOC,
				handler_frame,
				frame_size,
				MirTypes.Option.ABSENT) ::
	MirTypes.NEW_HANDLER continue_tag ::
	MirTypes.ADR(MirTypes.LEA, end_ptr, continue_tag) ::
	MirTypes.STOREOP(MirTypes.LD, proc, MirTypes.GC_REG callee_closure,
		    MirTypes.GP_IMM_ANY ~1) ::
	frame_setup @@
	[MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG handler,
			MirTypes.GP_GC_REG handler_frame_reg),
	 MirTypes.COMMENT"Set up new handler pointer"]
@


1.232
log
@Improved Control Transfer determining in HANDLEs.
@
text
@d4 3
d868 1
a868 1
require "../machine/machspec";
d4739 1
a4739 5
			  MirTypes.GC_REG
			  (if MirRegisters.automatic_callee then
			     callee_arg
			   else
			     caller_arg),
a4752 6
          (if MirRegisters.automatic_callee then [] else
             [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_closure,
                             MirTypes.GP_GC_REG caller_closure),
              MirTypes.COMMENT"Copy closure pointer to local copy (callee save)",
              MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_arg,
                             MirTypes.GP_GC_REG caller_arg)]) @@
d5050 1
a5050 5
			     MirTypes.GC_REG
			     (if MirRegisters.automatic_callee then
				callee_arg
			      else
				caller_arg),
d5065 1
a5065 9
          (if MirRegisters.automatic_callee then
	    [MirTypes.ENTER]
	  else
	    [MirTypes.ENTER,
	     MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_closure,
			    MirTypes.GP_GC_REG caller_closure),
	     MirTypes.COMMENT"Callee save closure pointer",
	     MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_arg,
			    MirTypes.GP_GC_REG caller_arg)])),
@


1.231
log
@Always insert interrupt if flag is set.
@
text
@d4 3
d912 1
d914 1
a914 1
    Types.Datatypes.instance
d1042 1
d1052 1
a1052 1
    val debug_variables = debug_variables orelse debug_polyvariables
d1054 3
a1056 3
    val first_spill : (int,int) LambdaTypes.Option.option ref ref LambdaTypes.Option.opt = 
      if debug_variables then 
        LambdaTypes.Option.PRESENT(ref(ref(LambdaTypes.Option.SOME1(1))))
d1080 1
a1080 1
            val spill = ref(LambdaTypes.Option.SOME1(1))
d1096 16
d1258 1
a1258 1
      if debug_variables then 
d1265 3
a1267 1
             ((Sexpr.CONS(Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG reg,
d1274 1
a1274 1
             code),bs,ts,ops),vs,ps)
d3016 1
a3016 1
       if debug_variables then 
d3053 1
a3053 1
        | LambdaTypes.Option.PRESENT(name,Ty as ref(ty,_),tyvar_slot) => 
d3121 1
a3121 1
       if debug_variables then 
d3227 1
a3227 1
       if debug_variables then 
d3285 1
a3285 1
         if debug_variables then 
d3317 1
a3317 1
	      Sexpr.NIL), [], [])),if debug_variables then 
d3326 1
a3326 1
           if debug_variables then 
d3355 1
a3355 5
        val ref_slot = 
          if debug_variables then 
            LambdaTypes.Option.PRESENT(ref (LambdaTypes.Option.SOME1(slot)))
          else
            LambdaTypes.Option.ABSENT
d3421 1
a3421 1
                        if debug_variables then 
d3519 1
a3519 1
              if debug_variables then
d4580 1
a4580 1
                   if debug_variables then 
d4676 1
d4776 1
a4776 1
			spill_sizes = if debug_variables then 
d4788 2
a4789 2
           if debug_variables then 
             RuntimeEnv.FN(name_string,runtime_env,deref_spill(),instances)
d5109 1
a5109 1
                              if debug_variables then 
d5121 2
a5122 2
           if debug_variables then 
             RuntimeEnv.FN(name,runtime_env,fetch_spill first_spill,instances)
d5144 1
a5144 1
       if debug_variables then 
d5171 1
a5171 1
       if debug_variables then 
d5201 1
a5201 5
      val ref_slot = 
        if debug_variables then 
          LambdaTypes.Option.PRESENT(ref (LambdaTypes.Option.SOME1(slot)))
        else
          LambdaTypes.Option.ABSENT
a5208 18
      val exn_code = 
       if debug_variables then
        let 
          val new_reg = MirTypes.GC.new()
        in
          Mir_Utils.combine(
               ((Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG (new_reg),
                                            MirTypes.GP_IMM_INT 2),
                             MirTypes.STOREOP(MirTypes.STREF,MirTypes.GC_REG (new_reg),
                               MirTypes.GC_REG fp,
                               MirTypes.GP_IMM_SYMB 
                                 (MirTypes.GC_SPILL_SLOT 
                                  (LambdaTypes.Option.SOME1(fetch_spill ref_slot,
                                                            "exception code"))))], 
               [],MirTypes.Option.ABSENT, Sexpr.NIL), [], []),exn_code)
        end
       else 
          exn_code
d5267 2
d5272 1
a5272 18
      val main_code = 
       if debug_variables then
        let 
          val new_reg = MirTypes.GC.new()
        in
          Mir_Utils.combine(
               ((Sexpr.ATOM [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG (new_reg),
                                            MirTypes.GP_IMM_INT 1),
                             MirTypes.STOREOP(MirTypes.STREF,MirTypes.GC_REG (new_reg),
                               MirTypes.GC_REG fp,
                               MirTypes.GP_IMM_SYMB 
                                 (MirTypes.GC_SPILL_SLOT 
                                  (LambdaTypes.Option.SOME1(fetch_spill ref_slot,
                                                            "main code"))))], 
               [],MirTypes.Option.ABSENT, Sexpr.NIL), [], []),main_code)
        end
       else
         main_code
d5291 2
a5292 2
       if debug_variables then 
         RuntimeEnv.HANDLE(runtime_env',fetch_spill ref_slot,calls',runtime_env)
d5372 1
a5372 1
                                          if debug_variables then 
d5380 1
a5380 1
                    if debug_variables then 
d5383 1
a5383 1
                                     deref_spill(),Datatypes.Option.ABSENT))
@


1.230
log
@Added ConvertInt exception to MirUtils
@
text
@d5 3
d1054 2
a1055 1
    val insert_interrupt = interrupt andalso opt_tail_calls
d4991 8
a4998 7
                       [MirTypes.UNARY(MirTypes.MOVE,
                                       MirTypes.GC_REG callee_arg,
                                       MirTypes.GP_GC_REG reg),
                        MirTypes.INTERCEPT,
                        MirTypes.UNARY(MirTypes.MOVE,
                                       MirTypes.GC_REG callee_arg,
                                       MirTypes.GP_GC_REG reg)]
d5001 1
a5001 1
		   if insert_interrupt then
@


1.229
log
@Removed unnecessary exceptions from closures.
@
text
@d4 6
d4192 1
a4192 1
			end handle Prod =>
d4607 2
a4608 7
		 (Mir_Utils.convert_int i
	       (*handle Prod => 
		 Info.error' 
		 error_info
		 (Info.FATAL,location,
		 "Integer too big : " ^ i)*)))),
	       no_code,RuntimeEnv.EMPTY,spills,calls) handle Prod =>
@


1.228
log
@Added extra indirection required to get fp values from the closure
for pattern matching
@
text
@d4 4
d1433 1
a1433 1
      fun exn_code_for_prim(prim, exn_tag) =
d1435 1
a1435 1
          of [] => []
d1459 2
d1462 2
a1463 1
                MirTypes.BLOCK(exn_tag, Mir_Utils.contract_sexpr exn_f) :: exn_b
d1482 1
a1482 2
	  val exn_tag = MirTypes.new_tag()
	  val exn_blocks = exn_code_for_prim(prim, exn_tag)
d1488 1
a1488 1
					    exn_tag, res2, val1, val2))]),
d1497 1
a1497 2
	  val exn_tag = MirTypes.new_tag()
	  val exn_blocks = exn_code_for_prim(prim, exn_tag)
d1503 1
a1503 1
		 ((Sexpr.ATOM[(MirTypes.TBINARY(opcode, exn_tag, res2,
d1537 1
a1537 2
	  val exn_tag = MirTypes.new_tag()
	  val exn_blocks = exn_code_for_prim(prim, exn_tag)
d1544 1
a1544 1
		  [(MirTypes.TBINARYFP(opcode, exn_tag, result,
d1571 1
a1571 2
	  val exn_tag = MirTypes.new_tag()
	  val exn_blocks = exn_code_for_prim(prim, exn_tag)
d1580 1
a1580 1
		    MirTypes.TUNARYFP(opcode, exn_tag, result, result)]
d1582 1
a1582 1
		    Sexpr.ATOM[MirTypes.TUNARYFP(opcode, exn_tag, result, reg)]
d1769 5
a1773 2
          val exn_tag = MirTypes.new_tag()
          val exn_blocks = exn_code_for_prim(prim, exn_tag)
d1962 5
a1966 2
              val exn_tag = MirTypes.new_tag()
              val exn_blocks = exn_code_for_prim(prim, exn_tag)
d2082 5
a2086 2
	    val exn_tag = MirTypes.new_tag()
	    val exn_blocks = exn_code_for_prim(prim, exn_tag)
a2179 2
          val exn_tag = MirTypes.new_tag()
          val exn_blocks = exn_code_for_prim(prim, exn_tag)
d2182 39
d2232 1
a2232 26
              (code @@ code' @@ code'' @@
               (if safe then
                  [MirTypes.COMMENT "Check the subscript range"] @@
                  (if constantp then
                     if constant_value < 0 then
                       [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
                     else
                       []
                   else
                     [MirTypes.TEST(MirTypes.BLT, exn_tag, new_reg, MirTypes.GP_IMM_INT 0)]) @@
                  [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG MirRegisters.global,
                                    Mir_Utils.reg_from_gp new_reg',
                                    MirTypes.GP_IMM_ANY ~3),
                   MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
                                   MirTypes.GP_GC_REG MirRegisters.global,
                                   MirTypes.GP_IMM_ANY 4),
                   MirTypes.BINARY(MirTypes.SUB,MirTypes.GC_REG MirRegisters.global,
                                   MirTypes.GP_GC_REG MirRegisters.global,
                                   new_reg),
                   MirTypes.TEST(MirTypes.BGE, main_tag,
				 MirTypes.GP_GC_REG MirRegisters.global,
				 MirTypes.GP_IMM_ANY 5),
		   (* Note that the 5 includes the left over bit of secondary tag *)
                   MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
                else
                  [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG main_tag)])),
d2563 5
a2567 2
	    val exn_tag = MirTypes.new_tag()
	    val exn_blocks = exn_code_for_prim(prim, exn_tag)
d2627 5
a2631 2
	  val exn_tag = MirTypes.new_tag()
	  val exn_blocks = exn_code_for_prim(prim, exn_tag)
d2664 5
a2668 2
	  val exn_tag = MirTypes.new_tag()
	  val exn_blocks = exn_code_for_prim(prim, exn_tag)
d2687 5
a2691 2
	  val exn_tag = MirTypes.new_tag()
	  val exn_blocks = exn_code_for_prim(prim, exn_tag)
d2887 1
a2887 2
	  val exn_tag = MirTypes.new_tag()
	  val exn_blocks = exn_code_for_prim(prim, exn_tag)
d2895 1
a2895 1
		  MirTypes.TBINARY(opcode, exn_tag, res2,
@


1.227
log
@Added code generation of INTERRUPT instruction
@
text
@d4 3
d4266 7
a4272 1
                            Sexpr.ATOM[MirTypes.STOREFPOP
d4274 2
a4275 4
                                        MirTypes.GC_REG callee_closure,
                                        MirTypes.GP_IMM_ANY(4*(static_offset + i +
                                                               (funs_in_closure * 2 - 1)) +
                                                            real_offset)),
@


1.226
log
@Merged in bug fix.
@
text
@d4 3
d1023 1
d1038 2
d4953 4
a4956 1
                   Sexpr.NIL),
@


1.225
log
@Merged in bug fix.
@
text
@d4 3
d10 5
d1802 11
a1812 4
                                [MirTypes.UNARY(MirTypes.MOVE,
                                                MirTypes.GC_REG MirRegisters.global,
                                                MirTypes.GP_GC_REG result),
                                MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)]) ::
d1815 2
a1816 1
                                [MirTypes.STOREOP(MirTypes.STB, Mir_Utils.reg_from_gp new_reg,
d1829 2
@


1.224
log
@Polymorphic debugger.
@
text
@d4 9
d4162 1
a4162 1
				  val (reg, the_code) = case
d4170 6
a4175 1
				  | _ => Crash.impossible"Bad code for big int"
d4184 1
a4184 1
				val (reg', the_code) = case
d4192 6
a4197 1
				  | _ => Crash.impossible"Bad code for big int"
d4542 6
a4547 2
	     cg_sub(Mir_Utils.convert_long_int scon, e, c, static_offset,
		    start_at, funs_in_closure, fn_tag_list, tails, tuple_bindings,spills,calls))
@


1.223
log
@Added missing intercept instruction after function entry in the simple
case.
@
text
@d4 4
d867 1
d873 2
a874 1
  sharing type MirPrint.MirTypes.RuntimeEnv.spill = int
d944 1
a944 1
    | AugLambda.FN(lv, le,_) => new_frees(vars, le)
d995 1
d1001 1
d1005 1
a1005 1
                                                   ...},
d1010 2
d2933 1
a2933 5
        | LambdaTypes.Option.SOME2(ref(lvar,
                                       debug_info as LambdaTypes.Option.PRESENT(name,_))) => 
            (lvar,debug_info)
        | LambdaTypes.Option.SOME2(ref(lvar,debug_info as LambdaTypes.Option.ABSENT)) => 
            (lvar,debug_info)
d2938 8
d2949 1
a2949 1
        | LambdaTypes.Option.PRESENT(name,Ty as ref ty) => 
d2954 5
a2958 1
                   val ref_slot = ref (LambdaTypes.Option.SOME1(slot))
d2966 2
a2967 1
                   LambdaTypes.Option.PRESENT(name,Ty,
d2973 5
a2977 1
                   val ref_slot = ref (LambdaTypes.Option.SOME1(slot))
d2986 3
a2988 1
                   LambdaTypes.Option.PRESENT(name,Ty,LambdaTypes.Option.PRESENT(ref_slot)))
d2993 5
a2997 1
                   val ref_slot = ref (LambdaTypes.Option.SOME1(slot))
d3006 3
a3008 1
                   LambdaTypes.Option.PRESENT(name,Ty,LambdaTypes.Option.PRESENT(ref_slot)))
d3024 1
a3024 1
	     ({lexp=AugLambda.FN(lvar, {lexp=lexp1, ...},name), ...}, lexp2,_), env,
d4559 1
a4559 1
				 name_string),
d4675 1
a4675 1
             RuntimeEnv.FN(name_string,runtime_env,deref_spill())
d4700 1
a4700 1
                            debug_info as LambdaTypes.Option.PRESENT(name,ty))) => 
d4713 1
a4713 1
	(fn {lexp=AugLambda.FN(lv, le, _), ...} => (lv, le)
d4718 1
a4718 1
	(fn {lexp=AugLambda.FN(_,_,name), ...} => name
d4977 1
a4977 1
	(fn (((_, fn_code,env_spills), exit_code),name) =>
d4983 1
a4983 1
	(fn ((tag, (((first, blocks, tag_opt, last), vals, procs),(runtime_env,(gc_spills,non_gc_spills,fp_spills),first_spill))),name) =>
d5004 1
a5004 1
             RuntimeEnv.FN(name,runtime_env,fetch_spill first_spill)
d5302 1
a5302 1
                                     deref_spill()))
@


1.223.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.223  1993/08/23  14:42:17  richard
Added missing intercept instruction after function entry in the simple
case.

@


1.223.1.2
log
@Handled Bignum.Unrepresentable where necessary.
@
text
@a3 3
Revision 1.223.1.1  1993/08/23  14:42:17  jont
Fork for bug fixing

d4126 1
a4126 1
				  val (reg, the_code) = (case
d4134 1
a4134 6
				  | _ => Crash.impossible"Bad code for big int")
			          handle BigNum.Unrepresentable =>
				    Info.error' 
				      error_info
				      (Info.FATAL, location_scon high,
				       "Integer too big : " ^ to_string high)
d4143 1
a4143 1
				val (reg', the_code) = (case
d4151 1
a4151 6
				  | _ => Crash.impossible"Bad code for big int")
			          handle BigNum.Unrepresentable =>
				    Info.error' 
				      error_info
				      (Info.FATAL, location_scon long_i,
				       "Integer too big : " ^ to_string long_i)
d4496 2
a4497 6
	     (cg_sub(Mir_Utils.convert_long_int scon, e, c, static_offset,
		    start_at, funs_in_closure, fn_tag_list, tails, tuple_bindings,spills,calls)
	      handle BigNum.Unrepresentable =>
	        Info.error' 
	          error_info
		  (Info.FATAL, location, "Integer too big : " ^ i)))
@


1.223.1.3
log
@The initial value to a bytearray must be untagged before being assigned to
the bytearray.  The register must be cleaned immediately after, to avoid
GC problems.
@
text
@a3 3
Revision 1.223.1.2  1993/09/28  14:53:12  daveb
Handled Bignum.Unrepresentable where necessary.

d1782 4
a1785 11
			     (if bytearray then
				[MirTypes.BINARY(MirTypes.LSR,
						 Mir_Utils.reg_from_gp new_reg,
						 new_reg,
						 MirTypes.GP_IMM_ANY 2)]
			      else
				[]) @@
                             [MirTypes.UNARY(MirTypes.MOVE,
                                             MirTypes.GC_REG MirRegisters.global,
                                             MirTypes.GP_GC_REG result),
                              MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)]) ::
d1788 1
a1788 2
                                [MirTypes.STOREOP(MirTypes.STB,
						  Mir_Utils.reg_from_gp new_reg,
a1800 2
				 MirTypes.NULLARY(MirTypes.CLEAN, 
						Mir_Utils.reg_from_gp new_reg),
@


1.222
log
@Moved a few more functions into mir_utils
@
text
@d4 3
d4607 4
a4610 5
          (if MirRegisters.automatic_callee then
	    [MirTypes.ENTER]
           else
             [MirTypes.ENTER,
              MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_closure,
@


1.221
log
@Fixed problem of require statements getting inside handlers etc
due to lambda optimisation.
@
text
@d4 4
a926 5
  fun unions((reqs, vars, exns, strs, funs),
	     (reqs', vars', exns', strs', funs')) =
    (Set.union(reqs, reqs'), Set.union(vars, vars'), Set.union(exns, exns'),
     Set.union(strs, strs'), Set.union(funs, funs'))

a928 266
  fun find_var(trees as (var_tree, exn_tree, str_tree, fun_tree, string_tree), string) =
    case NewMap.tryApply'(var_tree, string) of
      NewMap.YES lv => (trees, lv)
    | _ =>
	let
	  val lv = LambdaTypes.new_LVar()
	in
	  ((NewMap.define(var_tree, string, lv), exn_tree, str_tree, fun_tree, string_tree),
	   lv)
	end

  fun find_exn(trees as (var_tree, exn_tree, str_tree, fun_tree, string_tree), string) =
    case NewMap.tryApply'(exn_tree, string) of
      NewMap.YES lv => (trees, lv)
    | _ =>
	let
	  val lv = LambdaTypes.new_LVar()
	in
	  ((var_tree, NewMap.define(exn_tree, string, lv), str_tree, fun_tree, string_tree),
	   lv)
	end

  fun find_str(trees as (var_tree, exn_tree, str_tree, fun_tree, string_tree), string) =
    case NewMap.tryApply'(str_tree, string) of
      NewMap.YES lv => (trees, lv)
    | _ =>
	let
	  val lv = LambdaTypes.new_LVar()
	in
	  ((var_tree, exn_tree, NewMap.define(str_tree, string, lv), fun_tree, string_tree),
	   lv)
	end

  fun find_fun(trees as (var_tree, exn_tree, str_tree, fun_tree, string_tree), string) =
    case NewMap.tryApply'(fun_tree, string) of
      NewMap.YES lv => (trees, lv)
    | _ =>
	let
	  val lv = LambdaTypes.new_LVar()
	in
	  ((var_tree, exn_tree, str_tree, NewMap.define(fun_tree, string, lv), string_tree),
	   lv)
	end

  fun find_ext(trees as (var_tree, exn_tree, str_tree, fun_tree, string_tree), string) =
    case NewMap.tryApply'(string_tree, string) of
      NewMap.YES lv => (trees, lv)
    | _ =>
	let
	  val lv = LambdaTypes.new_LVar()
	in
	  ((var_tree, exn_tree, str_tree, fun_tree, NewMap.define(string_tree, string, lv)),
	   lv)
	end

  fun lift_externals(arg as (trees, {lexp=AugLambda.APP
				     ({lexp=AugLambda.BUILTIN(prim,_), ...},
				      {lexp=AugLambda.SCON(Ident.STRING chars),
				       ...},_), ...})) =
    (case prim of
       Pervasives.LOAD_VAR =>
	 let
	   val (trees, lv) = find_var(trees, chars)
	 in
	   (trees, {lexp=AugLambda.VAR lv, size=0})
	 end
     | Pervasives.LOAD_EXN =>
	 let
	   val (trees, lv) = find_exn(trees, chars)
	 in
	   (trees, {lexp=AugLambda.VAR lv, size=0})
	 end
     | Pervasives.LOAD_STRUCT =>
	 let
	   val (trees, lv) = find_str(trees, chars)
	 in
	   (trees, {lexp=AugLambda.VAR lv, size=0})
	 end
     | Pervasives.LOAD_FUNCT =>
	 let
	   val (trees, lv) = find_fun(trees, chars)
	 in
	   (trees, {lexp=AugLambda.VAR lv, size=0})
	 end
     | Pervasives.LOAD_STRING =>
	 let
	   val (trees, lv) = find_ext(trees, chars)
	 in
	   (trees, {lexp=AugLambda.VAR lv, size=0})
	 end
     | _ => arg)
    | lift_externals(trees, {lexp=AugLambda.APP(le, le',debug), size=size}) =
      let
	val (trees, le) = lift_externals(trees, le)
	val (trees, le') = lift_externals(trees, le')
      in
	(trees, {lexp=AugLambda.APP(le, le',debug), size=size})
      end
    | lift_externals(trees, {lexp=AugLambda.LET(lv, lb, le), size=size}) =
      let
	val (trees, lb) = lift_externals(trees, lb)
	val (trees, le) = lift_externals(trees, le)
      in
	(trees, {lexp=AugLambda.LET(lv,lb,le), size=size})
      end
    | lift_externals(trees, {lexp=AugLambda.FN(lv, le, name), size=size}) =
      let
	val (trees, le) = lift_externals(trees, le)
      in
	(trees, {lexp=AugLambda.FN(lv, le, name), size=size})
      end
    | lift_externals(trees, {lexp=AugLambda.STRUCT le_list, size=size}) =
      let
	val (trees, le_list) = lift_externals_list(trees, [], le_list)
      in
	(trees, {lexp=AugLambda.STRUCT le_list, size=size})
      end
    | lift_externals(trees, {lexp=AugLambda.SELECT(field, le), size=size}) =
      let
	val (trees, le) = lift_externals(trees, le)
      in
	(trees, {lexp=AugLambda.SELECT(field, le), size=size})
      end
    | lift_externals(trees, {lexp=AugLambda.SWITCH(le, info, tag_le_list, opt),
			     size=size}) =
      let
	val (trees, opt) = case opt of
	  LambdaTypes.Option.PRESENT le =>
	    let
	      val (trees, le) = lift_externals(trees, le)
	    in
	      (trees, LambdaTypes.Option.PRESENT le)
	    end
	| _ => (trees, opt)
	val (trees, le) = lift_externals(trees, le)
	val (trees, tag_le_list) =
	  lift_externals_tag_le_list(trees, [], tag_le_list)
      in
	(trees, {lexp=AugLambda.SWITCH(le, info, tag_le_list, opt),
		 size=size})
      end
    | lift_externals(arg as (_, {lexp=AugLambda.VAR _, ...})) =
      arg
    | lift_externals(trees, {lexp=AugLambda.LETREC(lv_list, le_list, le),
			     size=size}) =
      let
	val (trees, le) = lift_externals(trees, le)
	val (trees, le_list) = lift_externals_list(trees, [], le_list)
      in
	(trees, {lexp=AugLambda.LETREC(lv_list, le_list, le), size=size})
      end
    | lift_externals(arg as (_, {lexp=AugLambda.INT _, ...})) = arg
    | lift_externals(arg as (_, {lexp=AugLambda.SCON _, ...})) = arg
    | lift_externals(arg as (_, {lexp=AugLambda.MLVALUE _, ...})) = arg
    | lift_externals(trees, {lexp=AugLambda.HANDLE(le, le'), size=size}) =
      let
	val (trees, le) = lift_externals(trees, le)
	val (trees, le') = lift_externals(trees, le')
      in
	(trees, {lexp=AugLambda.HANDLE(le, le'), size=size})
      end
    | lift_externals(trees, {lexp=AugLambda.RAISE (le), size=size}) =
      let
	val (trees, le) = lift_externals(trees, le)
      in
	(trees, {lexp=AugLambda.RAISE (le), size=size})
      end
    | lift_externals(arg as (_, {lexp=AugLambda.BUILTIN _, ...})) = arg

  and lift_externals_list(trees, acc, []) = (trees, rev acc)
    | lift_externals_list(trees, acc, x :: xs) =
      let
	val (trees, x) = lift_externals(trees, x)
      in
	lift_externals_list(trees, x :: acc, xs)
      end

  and lift_externals_tag_le_list(trees, acc, []) = (trees, rev acc)
    | lift_externals_tag_le_list(trees, acc, (tag, le) :: rest) =
    let
      val (trees, tag) = case tag of
	AugLambda.EXP_TAG le =>
	  let
	    val (trees, le) = lift_externals(trees, le)
	  in
	    (trees, AugLambda.EXP_TAG le)
	  end
      | _ => (trees, tag)
      val (trees, le) = lift_externals(trees, le)
    in
      lift_externals_tag_le_list(trees, (tag, le) :: acc, rest)
    end


    fun get_string{lexp=AugLambda.APP
		   ({lexp=AugLambda.BUILTIN(prim,_), ...},
		    {lexp=AugLambda.SCON(Ident.STRING chars), ...},_), ...} =
      if prim = Pervasives.LOAD_STRING then Set.singleton chars
      else Set.empty_set
    | get_string{lexp=AugLambda.APP(le, le',_), ...} =
      Set.union(get_string le, get_string le')
    | get_string{lexp=AugLambda.LET(_,lb,le),...} = 
      Set.union(get_string lb, get_string le)
    | get_string{lexp=AugLambda.FN(_, le,_), ...} = get_string le
    | get_string{lexp=AugLambda.STRUCT le_list, ...} =
      Lists.reducel
      (fn (set, le) => Set.union(set, get_string le))
      (Set.empty_set, le_list)
    | get_string{lexp=AugLambda.SELECT(_, le), ...} = get_string le
    | get_string{lexp=AugLambda.SWITCH _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.VAR _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.LETREC _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.INT _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.SCON _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.MLVALUE _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.HANDLE _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.RAISE _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.BUILTIN _, ...} = Set.empty_set

  (* See if we must lift out any references in the tree *)
    fun transform_needed(bad, {lexp=AugLambda.APP
			 ({lexp=AugLambda.BUILTIN(prim,_), ...}, _, _), ...}) =
      (case prim of
	 Pervasives.LOAD_STRING => bad
       | Pervasives.LOAD_VAR => true
       | Pervasives.LOAD_EXN => true
       | Pervasives.LOAD_FUNCT => true
       | Pervasives.LOAD_STRUCT => true
       | _ => false)
    | transform_needed(bad, {lexp=AugLambda.APP(le, le',_), ...}) =
      transform_needed(bad, le) orelse transform_needed(bad, le')
    | transform_needed(bad, {lexp=AugLambda.LET(_,lb,le),...}) = 
      transform_needed(bad, lb) orelse transform_needed(bad, le)
    | transform_needed(_, {lexp=AugLambda.FN(_, le,_), ...}) = transform_needed(true, le)
    | transform_needed(bad, {lexp=AugLambda.STRUCT le_list, ...}) =
      Lists.exists
      (fn le => transform_needed(bad, le))
      le_list
    | transform_needed(bad, {lexp=AugLambda.SELECT(_, le), ...}) = transform_needed(bad, le)
    | transform_needed(_, {lexp=AugLambda.SWITCH(le, _, tag_le_list, le_opt),
			     ...}) =
      transform_needed(true, le) orelse
      Lists.exists
      (fn (tag, le) =>
       transform_needed(true, le) orelse
       (case tag of
	  AugLambda.EXP_TAG le => transform_needed(true, le)
	| _ => false))
      tag_le_list orelse
      (case le_opt of
	 LambdaTypes.Option.PRESENT le => transform_needed(true, le)
       | _ => false)
    | transform_needed(_, {lexp=AugLambda.VAR _, ...}) = false
    | transform_needed(_, {lexp=AugLambda.LETREC(_, le_list, le), ...}) =
      Lists.exists
      (fn le => transform_needed(true, le))
      (le :: le_list)
    | transform_needed(_, {lexp=AugLambda.INT _, ...}) = false
    | transform_needed(_, {lexp=AugLambda.SCON _, ...}) = false
    | transform_needed(_, {lexp=AugLambda.MLVALUE _, ...}) = false
    | transform_needed(_, {lexp=AugLambda.HANDLE(le, le'), ...}) =
      transform_needed(true, le) orelse transform_needed(true, le')
    | transform_needed(_, {lexp=AugLambda.RAISE le, ...}) =
      transform_needed(true, le)
    | transform_needed(_, {lexp=AugLambda.BUILTIN _, ...}) = false

a985 44
  fun needs_prim_stringeq(AugLambda.VAR _) = false
  | needs_prim_stringeq(AugLambda.FN(_, {lexp=lexp, ...}, _)) =
    needs_prim_stringeq lexp
  | needs_prim_stringeq(AugLambda.LET(_, {lexp=bind,...}, {lexp=expr,...})) =
    needs_prim_stringeq bind orelse needs_prim_stringeq expr
  | needs_prim_stringeq(AugLambda.LETREC(_, le_list, {lexp=le, ...})) =
    needs_prim_stringeq le orelse
    Lists.exists
    (fn {lexp=lexp, size=_} => needs_prim_stringeq lexp)
    le_list
  | needs_prim_stringeq(AugLambda.APP({lexp=le, ...}, {lexp=le', ...},_)) =
    needs_prim_stringeq le orelse needs_prim_stringeq le'
  | needs_prim_stringeq(AugLambda.SCON _) = false
  | needs_prim_stringeq(AugLambda.MLVALUE _) = false
  | needs_prim_stringeq(AugLambda.INT _) = false
  | needs_prim_stringeq(AugLambda.SWITCH({lexp=le, ...}, _, tag_le_list, opt)) =
    needs_prim_stringeq le orelse
    needs_prim_stringeq_opt opt orelse
    Lists.exists needs_prim_stringeq_tag tag_le_list
  | needs_prim_stringeq(AugLambda.STRUCT le_list) =
    Lists.exists
    (fn {lexp=lexp, size=_} => needs_prim_stringeq lexp)
    le_list
  | needs_prim_stringeq(AugLambda.SELECT(_, {lexp=lexp, ...})) =
    needs_prim_stringeq lexp
  | needs_prim_stringeq(AugLambda.RAISE({lexp=lexp, ...})) =
    needs_prim_stringeq lexp
  | needs_prim_stringeq(AugLambda.HANDLE({lexp=le, ...}, {lexp=le', ...})) =
    needs_prim_stringeq le orelse
    needs_prim_stringeq le'
  | needs_prim_stringeq(AugLambda.BUILTIN _) = false

  and needs_prim_stringeq_opt(LambdaTypes.Option.PRESENT{lexp=lexp, size=_}) =
    needs_prim_stringeq lexp
  | needs_prim_stringeq_opt LambdaTypes.Option.ABSENT = false

  and needs_prim_stringeq_tag(tag, {lexp=lexp, size=_}) =
    case tag of
      AugLambda.SCON_TAG(Ident.STRING _) => true
    | _ => needs_prim_stringeq lexp

  fun lneeds_prim_stringeq le_list =
    Lists.exists (fn {lexp=lexp, size=_} => needs_prim_stringeq lexp) le_list

d1101 1
a1101 1
    val needs_transform = transform_needed(false, new_exp_and_size)
d1105 1
a1105 1
	lift_externals((empty_string_tree, empty_string_tree, empty_string_tree,
d1130 1
a1130 1
      Set.set_to_list(get_string new_exp_and_size)
d4545 1
a4545 1
	    if needs_prim_stringeq fcn then
d4706 1
a4706 1
	    if lneeds_prim_stringeq le_list'' then
@


1.220
log
@Local and Closure variable inspection in the debugger;
new compiler option debug_variables;
values of these variables are spilled unto the stack;
call recording to determine control transfer.
@
text
@d4 6
d930 1
a930 1
  fun find_var(trees as (var_tree, exn_tree, str_tree, fun_tree), string) =
d937 1
a937 1
	  ((NewMap.define(var_tree, string, lv), exn_tree, str_tree, fun_tree),
d941 1
a941 1
  fun find_exn(trees as (var_tree, exn_tree, str_tree, fun_tree), string) =
d948 1
a948 1
	  ((var_tree, NewMap.define(exn_tree, string, lv), str_tree, fun_tree),
d952 1
a952 1
  fun find_str(trees as (var_tree, exn_tree, str_tree, fun_tree), string) =
d959 1
a959 1
	  ((var_tree, exn_tree, NewMap.define(str_tree, string, lv), fun_tree),
d963 1
a963 1
  fun find_fun(trees as (var_tree, exn_tree, str_tree, fun_tree), string) =
d970 1
a970 1
	  ((var_tree, exn_tree, str_tree, NewMap.define(fun_tree, string, lv)),
d974 11
d1014 6
d1149 46
a1194 41
    fun new_frees(vars as (old_set, new_set), {lexp=lexp, size=_}) =
      case lexp of
        AugLambda.APP(le, le',_) =>
          new_frees(new_frees(vars, le), le')
      | AugLambda.LET(_,lb,le) => 
          new_frees(new_frees(vars,lb), le)
      | AugLambda.FN(lv, le,_) => new_frees(vars, le)
      | AugLambda.STRUCT le_list =>
          Lists.reducel
          (fn (vars, le) => new_frees(vars, le))
          (vars, le_list)
      | AugLambda.SELECT(_, le) => new_frees(vars, le)
      | AugLambda.SWITCH(le, info, tag_le_list, opt) =>
            Lists.reducel
            (fn (vars, (tag, le)) =>
             let
               val vars = new_frees(vars, le)
             in
               case tag of
                 AugLambda.EXP_TAG lexp => new_frees(vars, lexp)
               | _ => vars
             end)
            (bandf_opt
             (new_frees(vars, le), opt), tag_le_list)
       | AugLambda.VAR lv =>
                   (old_set,
                    if HashSet.is_member(old_set, lv) then
                      HashSet.add_member(new_set, lv)
                    else
                      new_set)
       | AugLambda.LETREC(lv_list, le_list, le) =>
                   Lists.reducel
                   new_frees
                   (vars, le :: le_list)
       | AugLambda.INT _ => vars
       | AugLambda.SCON _ => vars
       | AugLambda.MLVALUE _ => vars
       | AugLambda.HANDLE(le, le') =>
                   new_frees(new_frees(vars, le), le')
       | AugLambda.RAISE (le) => new_frees(vars, le)
       | AugLambda.BUILTIN _ => vars
d1196 41
a1236 2
    and bandf_opt(vars, LambdaTypes.Option.PRESENT le) = new_frees(vars, le)
      | bandf_opt(vars, _) = vars
d1238 3
d1412 10
a1421 3
    val ((var_tree, exn_tree, str_tree, fun_tree), new_exp_and_size) =
      lift_externals((empty_string_tree, empty_string_tree, empty_string_tree,
		      empty_string_tree), new_exp_and_size)
d1427 9
a1435 5
      wrap_tree_bindings
      (var_tree, Pervasives.LOAD_VAR, wrap_tree_bindings
       (exn_tree, Pervasives.LOAD_EXN, wrap_tree_bindings
	(str_tree, Pervasives.LOAD_STRUCT, wrap_tree_bindings
	 (fun_tree, Pervasives.LOAD_FUNCT, new_exp_and_size))))
d1437 5
a1441 1
    val ext_strings = Set.set_to_list(get_string new_exp_and_size)
@


1.219
log
@Better version of do_shift
@
text
@d4 3
d848 2
d854 2
d882 1
d909 1
a909 1
  val no_code = ((Sexpr.NIL, [], MirTypes.ABSENT, Sexpr.NIL), [], [])
d1034 1
a1034 1
	  LambdaTypes.PRESENT le =>
d1038 1
a1038 1
	      (trees, LambdaTypes.PRESENT le)
d1068 1
a1068 1
    | lift_externals(trees, {lexp=AugLambda.RAISE le, size=size}) =
d1072 1
a1072 1
	(trees, {lexp=AugLambda.RAISE le, size=size})
d1126 41
a1166 42
  fun new_frees(vars as (old_set, new_set), {lexp=lexp, size=_}) =
    case lexp of
      AugLambda.APP(le, le',_) =>
	new_frees(new_frees(vars, le), le')
    | AugLambda.LET(_,lb,le) => 
	new_frees(new_frees(vars,lb), le)
    | AugLambda.FN(lv, le,_) =>
	new_frees(vars, le)
    | AugLambda.STRUCT le_list =>
      Lists.reducel
      (fn (vars, le) => new_frees(vars, le))
      (vars, le_list)
    | AugLambda.SELECT(_, le) => new_frees(vars, le)
    | AugLambda.SWITCH(le, info, tag_le_list, opt) =>
	Lists.reducel
	(fn (vars, (tag, le)) =>
	 let
	   val vars = new_frees(vars, le)
	 in
	   case tag of
	     AugLambda.EXP_TAG lexp => new_frees(vars, lexp)
	   | _ => vars
	 end)
	(bandf_opt
	  (new_frees(vars, le), opt), tag_le_list)
    | AugLambda.VAR lv =>
	(old_set,
	 if HashSet.is_member(old_set, lv) then
	   HashSet.add_member(new_set, lv)
	 else
	   new_set)
    | AugLambda.LETREC(lv_list, le_list, le) =>
	Lists.reducel
	new_frees
	(vars, le :: le_list)
    | AugLambda.INT _ => vars
    | AugLambda.SCON _ => vars
    | AugLambda.MLVALUE _ => vars
    | AugLambda.HANDLE(le, le') =>
	new_frees(new_frees(vars, le), le')
    | AugLambda.RAISE le => new_frees(vars, le)
    | AugLambda.BUILTIN _ => vars
d1168 2
a1169 2
  and bandf_opt(vars, LambdaTypes.PRESENT le) = new_frees(vars, le)
    | bandf_opt(vars, _) = vars
d1208 1
a1208 1
  | needs_prim_stringeq(AugLambda.RAISE{lexp=lexp, ...}) =
d1215 1
a1215 1
  and needs_prim_stringeq_opt(LambdaTypes.PRESENT{lexp=lexp, size=_}) =
d1217 1
a1217 1
  | needs_prim_stringeq_opt LambdaTypes.ABSENT = false
d1231 1
d1240 39
d1334 1
a1334 1
	(lv, {lexp=AugLambda.APP
d1409 26
d1436 1
a1436 1
		start_at, funs_in_closure, fn_tag_list) =
d1438 1
a1438 1
	val (regs, the_code) =
d1440 1
a1440 1
		 fn_tag_list, false, [])
d1481 1
a1481 1
			   ((Sexpr.ATOM more_code, [], MirTypes.ABSENT,
d1484 1
a1484 1
	 static_offset + gc_in_arg, start_at + gc_in_arg)
d1487 2
a1488 2
    and cg_bind_list([], env, _, static_offset, start_at, _, _) =
      (no_code, env, static_offset, start_at)
d1491 1
a1491 1
		   funs_in_closure, fn_tag_list) =
d1493 1
a1493 1
	val (reg, code, static_offset', start_at') =
d1495 1
a1495 1
		  fn_tag_list)
d1497 1
a1497 1
	val (new_code, env, static_offset, start_at) =
d1499 5
a1503 1
		  funs_in_closure, fn_tag_list)
d1505 2
a1506 1
	(Mir_Utils.combine(code, new_code), env, static_offset, start_at)
d1513 1
a1513 1
	       _) =
d1543 1
a1543 1
		  [], MirTypes.ABSENT, Sexpr.NIL), [], []))
d1558 1
a1558 1
		  [], MirTypes.ABSENT, Sexpr.NIL), [], []))
d1573 1
a1573 1
		  [], MirTypes.ABSENT, Sexpr.NIL), [], []))
d1588 1
a1588 1
		  [], MirTypes.ABSENT, Sexpr.NIL), [], []))
d1603 1
a1603 1
		  [], MirTypes.ABSENT, Sexpr.NIL), [], []))
d1608 1
a1608 1
      val (regs, the_code) =
d1610 1
a1610 1
	       fn_tag_list, false, [])
d1612 4
d1625 12
a1636 9
                  case cg_sub(AugLambda.RAISE
				{lexp=AugLambda.STRUCT
					[{lexp=exception_packet, size=0},
					 {lexp=AugLambda.STRUCT[], size=0}],
				 size=0},
			      env, closure, static_offset, start_at,
			      funs_in_closure, fn_tag_list, false, [])
                    of (_, ((exn_f, exn_b, exn_o, exn_l), [], [])) =>
                      (exn_f, exn_b, exn_o, exn_l)
d1640 1
a1640 1
                          of MirTypes.ABSENT => ()
d1670 1
a1670 1
	      exn_blocks, MirTypes.ABSENT, Sexpr.NIL), [], [])))
d1687 1
a1687 1
		 MirTypes.ABSENT, Sexpr.NIL), [], [])))
d1729 1
a1729 1
		  exn_blocks, MirTypes.ABSENT, Sexpr.NIL), [], [])))
d1748 1
a1748 1
		  [], MirTypes.ABSENT, Sexpr.NIL), [], [])))
d1768 1
a1768 1
		  exn_blocks, MirTypes.ABSENT, Sexpr.NIL), [], [])))
d1791 1
a1791 1
		       [], MirTypes.PRESENT tag, Sexpr.NIL), [], [])))
d1830 1
a1830 1
		       [], MirTypes.PRESENT tag, Sexpr.NIL), [], [])))
d1877 1
a1877 1
	      [], MirTypes.ABSENT, Sexpr.NIL), [], [])))
d1911 1
a1911 1
			       [],MirTypes.ABSENT,Sexpr.NIL),[],[])))
d2035 1
a2035 1
              MirTypes.PRESENT finish_tag, 
d2048 1
a2048 1
           Mir_Utils.ONE array =>
d2060 7
a2066 7
                     MirTypes.STOREOP(MirTypes.LDREF, res1, Mir_Utils.reg_from_gp new_reg,
                                      MirTypes.GP_IMM_ANY(~3)),
                     MirTypes.BINARY(MirTypes.LSR, res1,
                                     MirTypes.GP_GC_REG result, MirTypes.GP_IMM_ANY 4),
                     MirTypes.BINARY(MirTypes.BIC, res1,
                                     MirTypes.GP_GC_REG result, MirTypes.GP_IMM_ANY 3)]),
                   [], MirTypes.ABSENT, Sexpr.NIL), [], [])))
d2091 1
a2091 1
                   [], MirTypes.ABSENT, Sexpr.NIL), [], [])))
d2153 1
a2153 1
                                        MirTypes.GP_IMM_ANY(~3)),
d2184 1
a2184 1
                  exn_blocks, MirTypes.PRESENT finish_tag, Sexpr.NIL), [], [])))
d2211 1
a2211 1
              [], MirTypes.ABSENT, Sexpr.NIL), [], [])))
d2291 1
a2291 1
		exn_blocks, MirTypes.PRESENT finish_tag, Sexpr.NIL), [], [])))
d2311 1
a2311 1
            | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
d2316 1
a2316 1
		 in
d2372 1
a2372 1
                                    MirTypes.GP_IMM_ANY(~3)),
d2466 1
a2466 1
                 MirTypes.PRESENT finish_tag, 
d2501 1
a2501 1
				 MirTypes.ABSENT, Sexpr.NIL), [], [])))
d2532 1
a2532 1
				 MirTypes.ABSENT, Sexpr.NIL), [], [])))
d2560 1
a2560 1
		  [], MirTypes.ABSENT, Sexpr.NIL), [], [])))
d2647 1
a2647 1
                       MirTypes.PRESENT already_on_ref_chain_tag, 
d2664 1
a2664 1
		  [], MirTypes.ABSENT, Sexpr.NIL), [], [])))
d2735 1
a2735 1
		  exn_blocks, MirTypes.ABSENT, Sexpr.NIL), [], [])))
d2755 1
a2755 1
		  [], MirTypes.ABSENT, Sexpr.NIL), [], [])))
d2769 1
a2769 1
			     ((Sexpr.ATOM code, [], MirTypes.ABSENT,
d2801 1
a2801 1
		MirTypes.ABSENT, Sexpr.NIL), [], [])))
d2822 1
a2822 1
		     exn_blocks, MirTypes.ABSENT, Sexpr.NIL), [], [])))
d2828 2
a2829 4
	      Mir_Utils.ONE(Mir_Utils.INT reg) =>
		Mir_Utils.destruct_2_tuple reg
	    | Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] =>
		(reg1, reg2, [])
d2845 1
a2845 1
		exn_blocks, MirTypes.ABSENT, Sexpr.NIL),
d2874 1
a2874 1
	         exn_blocks, MirTypes.ABSENT, Sexpr.NIL), [], [])))
d2921 1
a2921 1
	  val extra_code = ((Sexpr.ATOM extra_code, [], MirTypes.ABSENT,
d2925 1
a2925 1
	  val (reg, poly_code) =
d2932 4
a2935 1
		     fn_tag_list, tails, [])
d2972 1
a2972 1
		  MirTypes.PRESENT test_tag, Sexpr.NIL)
d2983 1
a2983 1
		       [], MirTypes.PRESENT final_tag,
d3040 1
a3040 1
		MirTypes.PRESENT tag, Sexpr.NIL), [], [])))
d3065 1
a3065 1
			MirTypes.ABSENT, Sexpr.NIL),
d3113 1
a3113 1
                       [],MirTypes.ABSENT,Sexpr.NIL),
d3116 7
d3124 6
a3129 1
      (result, code)
d3133 1
a3133 1
	     (lvar, lexp2, {lexp=lexp1,...}), env,
d3135 1
a3135 1
	     tails, tuple_bindings) =
d3143 10
a3152 1
      val (reg, code, static_offset', start_at') =
d3154 48
a3201 1
		fn_tag_list)
d3204 1
a3204 1
      val (rest_regs, rest_code) =
d3206 1
a3206 1
	       funs_in_closure, fn_tag_list, tails, tuple_bindings)
d3208 5
a3212 1
      (rest_regs, Mir_Utils.combine(code, rest_code))
d3216 1
a3216 1
	     ({lexp=AugLambda.FN(lvar, {lexp=lexp1, ...},_), ...}, lexp2,_), env,
d3218 4
a3221 1
	     tails, tuple_bindings) =
d3230 1
a3230 1
      val (reg, code, static_offset', start_at') =
d3232 1
a3232 1
		fn_tag_list)
d3235 1
a3235 1
      val (rest_regs, rest_code) =
d3237 1
a3237 1
	       funs_in_closure, fn_tag_list, tails, tuple_bindings)
d3239 3
a3241 1
      (rest_regs, Mir_Utils.combine(code, rest_code))
d3243 1
d3247 1
a3247 1
	     funs_in_closure, fn_tag_list, tails, tuple_bindings) =
d3260 7
a3266 7
	   AugLambda.VAR lv =>
	     (case LambdaTypes.Map.tryApply'(escape_map, lv) of
		LambdaTypes.Map.YES ok => not ok
	      | _ => false)
	 | _ => false)
      (* Disallow stcking of records when tracing, the value printer can't cope *)
      val ((fn_reg, fn_code), pos, is_same_set, can_stack_args, tails,
d3269 1
a3269 1
	  AugLambda.VAR lvar =>
d3275 2
a3276 1
		((Sexpr.ATOM code, [], MirTypes.ABSENT, Sexpr.NIL), [], [])),
d3287 1
a3287 1
		  fn_tag_list, false, []),
d3289 2
a3290 1
      val (arg_reg, arg_code) =
d3294 1
a3294 1
	       false, [])
d3296 1
a3296 1
      val (reg, code as ((first, blocks, tag_opt, last), values, procs_list)) =
d3303 1
d3306 5
d3314 6
a3319 2
      (reg, code)
    end
d3321 1
a3321 1
	   funs_in_closure, fn_tag_list, _, _) =
d3323 2
a3324 1
      [] => (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_IMM_INT 0)), no_code)
d3333 3
a3335 2
	fun make_code([], _) = []
	  | make_code({lexp=le, size=size} :: rest, pos) =
d3337 1
a3337 1
	      val reg_code =
d3340 3
a3342 1
		       fn_tag_list, false, [])
d3344 2
a3345 1
	      reg_code :: make_code(rest, pos+size)
d3347 2
a3348 6
        val reg_code_list = make_code(le_list, 0)
	val the_code =
	  Lists.reducer
	  (fn ((_, code), code') => Mir_Utils.combine(code, code'))
	  (reg_code_list, no_code)
	val new_reg_code_list =
d3350 1
a3350 1
	  (fn (Mir_Utils.ONE reg, _) =>
d3352 1
a3352 1
	  | (Mir_Utils.LIST regs, _) =>
d3359 1
a3359 1
	  reg_code_list
d3363 1
a3363 1
	  (fn ((_, code), code') => code @@ code'
d3366 3
a3368 2
	  (fn (code', (_, code)) => Sexpr.CONS(code', Sexpr.ATOM code))
	  (Sexpr.NIL, new_reg_code_list)
d3370 7
a3376 3
	(Mir_Utils.LIST(map #1 new_reg_code_list),
	 Mir_Utils.combine(the_code, ((new_code, [], MirTypes.ABSENT,
				       Sexpr.NIL), [], [])))
d3380 1
a3380 1
	     static_offset, start_at, funs_in_closure, fn_tag_list, _, _) =
d3388 2
a3389 1
      val (regs, the_code) =
d3391 1
a3391 1
	       start_at, funs_in_closure, fn_tag_list, false, [])
d3393 1
d3404 5
a3408 2
		MirTypes.COMMENT("Destructure tuple")], [], MirTypes.ABSENT,
	      Sexpr.NIL), [], [])))
d3413 5
a3417 1
	  (Mir_Utils.ONE(Lists.nth(index, many)), the_code) handle
d3428 1
a3428 1
	     fn_tag_list, tails, tuple_bindings) =
d3441 7
d3486 2
a3487 2
               LambdaTypes.ABSENT => false
             | LambdaTypes.PRESENT _ => true
d3501 2
a3502 2
                 LambdaTypes.ABSENT => ([], end_tag, [], [])
               | LambdaTypes.PRESENT{lexp=lexp, size=_} =>
d3504 1
a3504 1
                     val (regs, the_code) =
d3507 1
a3507 1
			      tuple_bindings)
d3513 17
d3548 1
a3548 1
			     MirTypes.ABSENT,
d3552 1
a3552 1
		       )
d3557 1
a3557 1
                       ((first, blocks, MirTypes.ABSENT, last),
d3565 2
a3566 2
			  procs)
                     | ((first, blocks, MirTypes.PRESENT tag, last),
d3576 1
a3576 1
			  procs)
d3580 1
a3580 1
             val (dflt_blocks, dflt_tag, dflt_values, dflt_procs) =
d3599 42
a3640 1
             val tagged_code = map
d3643 1
a3643 1
                  val (reg, code) =
d3646 1
a3646 1
			   tails, tuple_bindings)
d3649 2
a3650 1
                  (t, (reg, code), MirTypes.new_tag())
d3654 19
d3676 1
a3676 1
                   ([(AugLambda.IMM_TAG t1, _, tag)], LambdaTypes.PRESENT _) =>
d3678 2
a3679 2
                 | ([(AugLambda.IMM_TAG t1, _, tag),
                     (AugLambda.IMM_TAG t2, _, tag')], LambdaTypes.ABSENT) =>
d3689 1
a3689 1
	     |   get_vcc_tag ((AugLambda.VCC_TAG t, _, tag) :: _) = tag
d3717 1
a3717 1
			 LambdaTypes.ABSENT =>
d3719 1
a3719 1
		       | LambdaTypes.PRESENT{num_imms, num_vccs, ...} =>
d3767 1
a3767 1
				LambdaTypes.ABSENT =>
d3871 2
a3872 1
             val (regs, the_reg_opt, the_code, test_code, need_main_test) =
d3890 1
a3890 1
                   val (code, env', static_offset', start_at') =
d3892 2
a3893 1
				  start_at, funs_in_closure, fn_tag_list)
d3909 1
a3909 2
                        MirTypes.Debugger_Types.null_backend_annotation
		     )
d3911 1
a3911 1
                   val (rest_regs, rest_code) =
d3913 7
a3919 1
                            funs_in_closure, fn_tag_list, false, [])
d3926 1
a3926 1
		       ((Sexpr.ATOM extra, [], MirTypes.ABSENT, Sexpr.NIL),
d3932 2
a3933 1
                   (rest_regs, MirTypes.PRESENT the_reg, code, rest_code, false)
d3937 1
a3937 1
                   val (regs, the_code) =
d3939 1
a3939 1
                            funs_in_closure, fn_tag_list, false, [])
d3949 1
a3949 1
                         MirTypes.ABSENT,
d3956 1
a3956 1
		    MirTypes.PRESENT the_reg,
d3959 1
a3959 1
		    need_main_test)
d3963 1
a3963 1
                   val (regs, the_code) =
d3965 2
a3966 1
                            funs_in_closure, fn_tag_list, false, [])
d3973 1
a3973 1
                         MirTypes.ABSENT,
d3979 1
a3979 1
		   (regs, MirTypes.ABSENT, block, no_code, true)
d3981 4
d3997 1
a3997 1
                     LambdaTypes.ABSENT =>
d4023 1
a4023 1
		     (fn ((_, (_, (_, value, _)), _), value') =>
d4028 1
a4028 1
		     (fn ((_, (_, (_, _, proc)), _), proc') => proc @@ proc')
d4032 1
a4032 1
                    (fn (_, (regs, ((first, blocks, tag_opt, last), _, _)),
d4040 1
a4040 1
                          MirTypes.ABSENT =>
d4045 1
a4045 1
                        | MirTypes.PRESENT tag1 =>
d4086 1
a4086 1
                     MirTypes.ABSENT,
d4101 1
d4106 1
a4106 1
		    (LambdaTypes.PRESENT _, MirTypes.PRESENT _) =>
d4109 1
a4109 1
		  | (LambdaTypes.PRESENT _, MirTypes.ABSENT) =>
d4111 1
a4111 1
		  | (_, MirTypes.PRESENT _) =>
d4117 1
a4117 1
		    MirTypes.ABSENT,
d4130 1
a4130 1
				   )),
d4136 2
a4137 2
		       MirTypes.PRESENT f => f(the_reg, scon, le, tag)
		     | MirTypes.ABSENT => Sexpr.NIL
d4143 1
a4143 1
			  LambdaTypes.ABSENT =>
d4146 1
a4146 1
			       MirTypes.PRESENT _ =>
d4162 1
a4162 1
                       MirTypes.ABSENT =>
d4169 2
a4170 2
                          MirTypes.ABSENT, Sexpr.NIL)
                     | MirTypes.PRESENT tag'=>
d4178 1
a4178 1
                          MirTypes.ABSENT,
d4190 2
a4191 2
                      (fn (AugLambda.IMM_TAG i, le, tag) => (i, le, tag)
                       |  (AugLambda.VCC_TAG i, le, tag) => (i, le, tag)
d4195 1
a4195 1
                   val (i, (result_reg, code), first_tag) =
d4204 2
a4205 2
		       MirTypes.PRESENT x => x
		     | MirTypes.ABSENT => Crash.impossible "Missing the_reg"
d4221 1
a4221 1
					     MirTypes.PRESENT do_test
d4223 1
a4223 1
					    MirTypes.ABSENT)
d4228 2
a4229 2
                           LambdaTypes.ABSENT => []
                         | LambdaTypes.PRESENT _ =>
d4244 2
a4245 2
                     LambdaTypes.ABSENT => []
                   | LambdaTypes.PRESENT _ =>
d4282 1
a4282 1
			    LambdaTypes.ABSENT =>
d4284 1
a4284 1
			  | LambdaTypes.PRESENT _ =>
d4305 1
a4305 1
						MirTypes.PRESENT do_test))
d4341 1
a4341 1
			      LambdaTypes.ABSENT =>
d4343 1
a4343 1
			    | LambdaTypes.PRESENT _ =>
d4348 2
a4349 1
					   funs_in_closure, fn_tag_list, false, []) of
d4351 2
a4352 2
				     ((code, [], MirTypes.ABSENT, Sexpr.NIL),
				      [], [])) => (r, code)
d4365 2
a4366 1
					 funs_in_closure, fn_tag_list, false, []) of
d4368 2
a4369 2
				   ((code, [], MirTypes.ABSENT, Sexpr.NIL),
				    [], [])) => (r, code)
d4382 1
a4382 1
					      MirTypes.PRESENT do_test))
d4433 2
a4434 2
                         Mir_Utils.combine(((Sexpr.NIL, [], MirTypes.ABSENT, Sexpr.NIL), tags_code, []),
                                           do_chained_tests(the_reg, dflt, val_le_tags_list, MirTypes.PRESENT do_test)))
d4457 3
a4459 2
                            val (regs', the_code') =
                              cg_sub(AugLambda.VAR(NewMap.apply'(prim_to_lambda, Pervasives.STRINGEQ)),
d4461 7
a4467 2
                                     funs_in_closure, [], false, [])
                            val app_code = case
d4470 2
a4471 1
                                               Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG caller_arg)),
d4475 2
a4476 1
                                               (_, ((app_code, [], MirTypes.ABSENT, last), [], [])) =>
d4490 1
a4490 1
                                                               MirTypes.ABSENT),
d4518 2
a4519 2
                         Mir_Utils.combine(((Sexpr.NIL, [], MirTypes.ABSENT, Sexpr.NIL), tags_code, []),
                                           do_chained_tests(the_reg, dflt, val_le_tags_list, MirTypes.PRESENT do_test)))
d4542 1
a4542 1
                                     funs_in_closure, [], false, []) of
d4544 8
a4551 4
                            ((code, [], MirTypes.ABSENT, last), [], [])) =>
                           (case Mir_Utils.contract_sexpr last of
                              [] => (reg, code)
                            | _ => Crash.impossible"Bad result from cg(exception)")
d4560 1
a4560 1
                   ([], do_chained_tests(the_reg, dflt, val_le_tags_list, MirTypes.PRESENT do_test))
d4588 2
a4589 2
			  (case tag_opt of MirTypes.ABSENT => "ABSENT"
			| MirTypes.PRESENT tag => MirTypes.print_tag tag) ::
d4625 2
a4626 2
			  (case tag_opt of MirTypes.ABSENT => "ABSENT"
			| MirTypes.PRESENT tag => MirTypes.print_tag tag) ::
d4646 1
a4646 1
		 (((Sexpr.NIL, [], MirTypes.PRESENT main_tag, Sexpr.ATOM main_default),
d4652 1
a4652 1
		((Sexpr.NIL, dflt_blocks, MirTypes.PRESENT end_tag, Sexpr.NIL),
d4657 7
a4663 1
		  (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG end_reg)), result_code)
d4668 1
a4668 1
	     _, _, _) =
d4678 2
a4679 2
      (Mir_Utils.ONE reg, ((Sexpr.ATOM code, [], MirTypes.ABSENT,
			    Sexpr.NIL), [], []))
d4681 1
a4681 1
    | cg_sub(arg as AugLambda.INT i, _, _, _, _, _, _, _, _) =
d4690 2
a4691 1
	(Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_IMM_INT i)), no_code)
d4694 1
a4694 1
	     funs_in_closure, fn_tag_list, tails, tuple_bindings) =
d4714 1
a4714 1
	       no_code) handle Prod =>
d4716 1
a4716 1
		    start_at, funs_in_closure, fn_tag_list, tails, tuple_bindings))
d4728 5
a4732 5
		[],
		MirTypes.ABSENT, Sexpr.NIL),
		[MirTypes.VALUE(new_tag, MirTypes.SCON scon)],
		[]))
	     end)
d4735 1
a4735 1
	     funs_in_closure, _, _, _) =
d4746 1
a4746 1
         MirTypes.ABSENT, Sexpr.NIL),
d4748 1
a4748 1
         []))
d4753 1
a4753 1
	     start_at, funs_in_closure, fn_tag_list, _, _) =
d4755 2
d4800 1
a4800 1
      val (fn_reg, fn_code) =
d4806 1
a4806 1
	       true, [])
d4842 1
a4842 1
	  [], MirTypes.ABSENT, Sexpr.NIL)
d4846 1
a4846 1
	  [], MirTypes.ABSENT, Sexpr.NIL)
d4848 1
a4848 1
	Mir_Utils.combine((entry_code, [], []), Mir_Utils.combine(fn_code, (exit_code, [], [])))
d4854 7
a4860 3
			registers_used = MirTypes.ABSENT,
			spill_sizes = MirTypes.ABSENT,
			stack_allocated = MirTypes.ABSENT},
d4864 8
a4871 3
	  MirTypes.ABSENT => []
	| MirTypes.PRESENT tag =>
	    [MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr last)]))]
d4873 3
a4875 2
      (Mir_Utils.ONE(Mir_Utils.INT(Mir_Utils.gp_from_reg cl_reg)), ((code, [], MirTypes.ABSENT, Sexpr.NIL), values,
				      the_fn :: procs))
d4879 1
a4879 1
	     static_offset, start_at, funs_in_closure, fn_tag_list, _, _) =
d4887 14
d4902 1
d4914 1
d4916 2
d4982 1
d5032 3
d5039 2
a5040 1
	   val (code, env, static, start) = 
d5042 1
a5042 1
			  funs - (x div 2), tags)
d5044 3
a5046 3
	   (Mir_Utils.combine
	    (((Sexpr.ATOM arg_copy, [], MirTypes.ABSENT, Sexpr.NIL), [], []),
	     code), env, static, start)
d5058 1
a5058 1
	(fn ((_, env, _, _), ((_, reg), arg_selects)) =>
d5070 3
a5072 2
	(fn ((((((lexp, (code, env, static_offset, start_at)), new_closure),
		 x), lvar), tuple_bindings), fn_arg) =>
d5074 4
a5077 3
	   val (regs, code') =
	     cg_sub(lexp, env, new_closure, static_offset, start_at,
		    funs - x div 2, tags, true, tuple_bindings)
d5085 1
a5085 1
                 MirTypes.PRESENT loop_tag, 
d5087 1
a5087 1
                   case Mir_Env.lookup_lambda (fn_arg, env) of
d5104 6
a5109 1
	   (regs, Mir_Utils.combine(Mir_Utils.combine(code, end_block), code'))
d5111 10
a5120 10
	(Lists.zip
	 (Lists.zip
	  (Lists.zip
	   (Lists.zip
	    (Lists.zip(Lists.zip(le_list''', code_env_static_start_list),
		       new_closure_list),
	     offsets),
	    lv_list),
	   int_reg_list_list),
	  fn_args))
d5122 2
d5126 1
a5126 1
	  fun send ((x, _), new_closure) =
d5160 1
a5160 1
	[], MirTypes.ABSENT, Sexpr.NIL), [], [])
d5166 1
a5166 1
	      [], MirTypes.ABSENT, Sexpr.NIL), [], []))
d5170 3
a5172 2
	(fn (((_, fn_code), exit_code),name) =>
	  Mir_Utils.combine(generate_entry_code name, Mir_Utils.combine(fn_code, exit_code)))
d5176 1
a5176 1
	(fn ((tag, ((first, blocks, tag_opt, last), vals, procs)),name) =>
d5182 8
a5189 3
			      registers_used = MirTypes.ABSENT,
			      spill_sizes = MirTypes.ABSENT,
			      stack_allocated = MirTypes.ABSENT},
d5193 7
a5199 3
	  MirTypes.ABSENT => []
	| MirTypes.PRESENT tag =>
	    [MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr last)]))))
d5201 1
a5201 1
      val (regs, ((first, blocks, tag_opt, last), vals, procs)) =
d5205 1
a5205 1
	       fn_tag_list, false, [])
d5218 6
a5223 1
	      this_proc_list :: procs @@ proc_list))
d5225 2
a5226 2
    | cg_sub(arg as AugLambda.RAISE{lexp=le, ...}, env, closure, static_offset,
	     start_at, funs_in_closure, fn_tag_list, _, _) =
d5228 1
a5228 1
      val (reg, code) =
d5230 1
a5230 1
	       fn_tag_list, false, [])
d5239 5
a5243 3
      val total_code =
	Mir_Utils.combine(code, ((Sexpr.ATOM final_code, [], MirTypes.ABSENT,
				  Sexpr.NIL), [], []))
d5245 5
a5249 1
      (reg, total_code)
d5254 1
a5254 1
	       start_at, funs_in_closure, fn_tag_list, _, _) =
d5273 8
d5282 2
a5283 1
	   exn_code as ((exn_f, exn_b, exn_o, exn_l), exn_vals, exn_procs)) =
d5287 19
a5305 1
	       false, [])
d5351 1
a5351 1
				MirTypes.ABSENT) ::
d5362 1
a5362 1
		((Sexpr.ATOM frame_setup, [exn_end], MirTypes.ABSENT,
d5364 1
a5364 1
      val (main_reg, main_code) =
d5366 19
a5384 1
	       fn_tag_list, false, [])
d5397 1
a5397 1
		((Sexpr.ATOM main_end, [], MirTypes.PRESENT end_tag,
d5402 5
a5406 1
      (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result_reg)), total_code)
d5409 1
a5409 1
	     start_at, funs_in_closure, fn_tag_list, _, _) =
d5417 1
d5419 1
a5419 1
    val (regs, ((first, blocks, tag_opt, last), values, proc_lists)) =
d5421 1
a5421 1
	     Mir_Env.empty_closure_env, 0, 0, 1, [new_tag], false, [])
d5469 2
a5470 2
	(MirTypes.ABSENT, []) => (Sexpr.CONS(entry, last''), blocks)
      | (MirTypes.PRESENT tag, _) =>
d5473 1
a5473 1
      | (MirTypes.ABSENT, _) =>
d5482 8
a5489 3
					  registers_used = MirTypes.ABSENT,
					  spill_sizes = MirTypes.ABSENT,
					  stack_allocated = MirTypes.ABSENT},
d5491 7
a5497 1
				   Mir_Utils.contract_sexpr first) :: blocks)
d5501 1
a5501 1
    fun sort_out_small_exit_blocks(MirTypes.PROC(name,tag, params, blocks)) =
d5506 2
a5507 2
	    MirTypes.ABSENT => blocks
	  | MirTypes.PRESENT exit_block =>
d5513 1
a5513 1
	MirTypes.PROC(name,tag, params, block_list)
@


1.218
log
@Added support for unsafeintplus, and redid some of the bitwise operations
Dealt with the case of overlarge integers in special constants, both in
matches and atomic values using shifts and adds at runtime
@
text
@d4 5
d1795 1
a1795 4
      val do_logical_operator = binary_calc

(*
      fun do_logical_operator mir_operator = 
d1797 4
a1800 1
	  val ((new_reg, code),(new_reg', code')) =
d1802 20
a1821 22
	      Mir_Utils.LIST[ x,y] => 
		(Mir_Utils.send_to_new_reg(Mir_Utils.ONE(x)),
		 Mir_Utils.send_to_new_reg(Mir_Utils.ONE(y)))
	    | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
		(let
		   val new_reg = MirTypes.GC.new()
		   val new_reg' = MirTypes.GC.new()
		 in
		   ((MirTypes.GP_GC_REG new_reg,
		     [MirTypes.STOREOP(MirTypes.LD,
				       MirTypes.GC_REG new_reg,
				       Mir_Utils.reg_from_gp reg,
				       MirTypes.GP_IMM_ANY ~1)]),
		    (MirTypes.GP_GC_REG new_reg',
		     [MirTypes.STOREOP(MirTypes.LD,
				       MirTypes.GC_REG new_reg',
				       Mir_Utils.reg_from_gp reg,
				       MirTypes.GP_IMM_ANY 3)]))
		 end)
	    | _ => Crash.impossible "_mir_cg : do_logical_operator can't code generate arguments "

            val result = MirTypes.GC.new()
d1825 1
a1825 3
			     ((Sexpr.ATOM(code @@ code' @@
					  [MirTypes.BINARY(mir_operator,MirTypes.GC_REG result,
							   new_reg,new_reg')]),
a1827 1
*)
a1828 41
      fun do_shift_operator(mir_operator,need_to_clear_bottom_two_bits) = 
	let
	  val ((new_reg, code),(new_reg', code')) =
	    case regs of
	      Mir_Utils.LIST[ x,y ] => 
		(Mir_Utils.send_to_new_reg(Mir_Utils.ONE(x)),
		 Mir_Utils.send_to_new_reg(Mir_Utils.ONE(y)))
	    | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
		(let
		   val new_reg = MirTypes.GC.new()
		   val new_reg' = MirTypes.GC.new()
		 in
		   ((MirTypes.GP_GC_REG new_reg,
		     [MirTypes.STOREOP(MirTypes.LD,
				       MirTypes.GC_REG new_reg,
				       Mir_Utils.reg_from_gp reg,
				       MirTypes.GP_IMM_ANY ~1)]),
		    (MirTypes.GP_GC_REG new_reg',
		     [MirTypes.STOREOP(MirTypes.LD,
				       MirTypes.GC_REG new_reg',
				       Mir_Utils.reg_from_gp reg,
				       MirTypes.GP_IMM_ANY 3)]))
		 end)
	    | _ => Crash.impossible "_mir_cg : do_shift_operator can't code generate arguments "
	  val result = MirTypes.GC.new()
	in
	  (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
	   Mir_Utils.combine(the_code,
			     ((Sexpr.ATOM(code @@ code' @@
					  [MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
							   new_reg',MirTypes.GP_IMM_ANY 2),
					   MirTypes.BINARY(mir_operator,MirTypes.GC_REG result,new_reg,
							   MirTypes.GP_GC_REG MirRegisters.global)] @@
					  (if need_to_clear_bottom_two_bits
					     then [MirTypes.BINARY(MirTypes.BIC,MirTypes.GC_REG result,MirTypes.GP_GC_REG result,
								   MirTypes.GP_IMM_ANY 3)]
					   else [])),
			     [],MirTypes.ABSENT,Sexpr.NIL),[],[])))
	end


d3008 3
a3010 3
      | Pervasives.ANDB => do_logical_operator MirTypes.AND
      | Pervasives.ORB => do_logical_operator MirTypes.OR
      | Pervasives.XORB => do_logical_operator MirTypes.EOR
@


1.217
log
@Made primitive operations refer to exception values instead of exception
names - we have to build them explicitly as a result of the recent changes
to exception environments.
@
text
@d4 5
d791 1
d815 1
d835 1
a835 1
  sharing Library.AugLambda = Tail.AugLambda
a1582 18
      fun binary_calc opcode =
	let
	  val result = MirTypes.GC.new()
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val (val1, val2, new_code) =
	    case regs of
	      Mir_Utils.ONE(Mir_Utils.INT reg) => Mir_Utils.destruct_2_tuple reg
	    | Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] => (reg1, reg2, [])
	    | _ => Crash.impossible"cg_sub(BUILTIN 0)"
	in
	  (Mir_Utils.ONE(Mir_Utils.INT res1), Mir_Utils.combine
	   (the_code,
	    ((Sexpr.ATOM(new_code @@
	     [(MirTypes.BINARY(opcode, res2, val1, val2))]),
	      [], MirTypes.ABSENT, Sexpr.NIL), [], [])))
	end

d1772 21
d1794 24
a1817 22
          let
	    val ((new_reg, code),(new_reg', code')) =
              case regs of
                Mir_Utils.LIST[ x,y ] => 
                  (Mir_Utils.send_to_new_reg(Mir_Utils.ONE(x)),
                   Mir_Utils.send_to_new_reg(Mir_Utils.ONE(y)))
              | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                  (let
                    val new_reg = MirTypes.GC.new()
                    val new_reg' = MirTypes.GC.new()
                  in
                     ((MirTypes.GP_GC_REG new_reg,[MirTypes.STOREOP(MirTypes.LD,
                                                                    MirTypes.GC_REG new_reg,
                                                                    Mir_Utils.reg_from_gp reg,
                                                                    MirTypes.GP_IMM_ANY ~1)]),
                     (MirTypes.GP_GC_REG new_reg',[MirTypes.STOREOP(MirTypes.LD,
                                                                    MirTypes.GC_REG new_reg',
                                                                    Mir_Utils.reg_from_gp reg,
                                                                    MirTypes.GP_IMM_ANY 3)]))
                  end)
              | _ => Crash.impossible "_mir_cg : do_logical_operator can't code generate arguments "
                  
d1819 9
a1827 9
          in
            (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
             Mir_Utils.combine(the_code,
                               ((Sexpr.ATOM(code @@ code' @@
                                            [MirTypes.BINARY(mir_operator,MirTypes.GC_REG result,
                                                             new_reg,new_reg')]),
                                [],MirTypes.ABSENT,Sexpr.NIL),[],[])))
            
          end
d1830 38
a1867 37
          let
	    val ((new_reg, code),(new_reg', code')) =
              case regs of
                Mir_Utils.LIST[ x,y ] => 
                  (Mir_Utils.send_to_new_reg(Mir_Utils.ONE(x)),
                   Mir_Utils.send_to_new_reg(Mir_Utils.ONE(y)))
              | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                  (let
                    val new_reg = MirTypes.GC.new()
                    val new_reg' = MirTypes.GC.new()
                  in
                     ((MirTypes.GP_GC_REG new_reg,[MirTypes.STOREOP(MirTypes.LD,
                                                                    MirTypes.GC_REG new_reg,
                                                                    Mir_Utils.reg_from_gp reg,
                                                                    MirTypes.GP_IMM_ANY ~1)]),
                     (MirTypes.GP_GC_REG new_reg',[MirTypes.STOREOP(MirTypes.LD,
                                                                    MirTypes.GC_REG new_reg',
                                                                    Mir_Utils.reg_from_gp reg,
                                                                    MirTypes.GP_IMM_ANY 3)]))
                  end)
              | _ => Crash.impossible "_mir_cg : do_shift_operator can't code generate arguments "
                  
            val result = MirTypes.GC.new()
          in
            (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
             Mir_Utils.combine(the_code,
                               ((Sexpr.ATOM(code @@ code' @@
                                            [MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
                                                             new_reg',MirTypes.GP_IMM_ANY 2),
                                             MirTypes.BINARY(mir_operator,MirTypes.GC_REG result,new_reg,
                                                             MirTypes.GP_GC_REG MirRegisters.global)] @@
                                 (if need_to_clear_bottom_two_bits
                                    then [MirTypes.BINARY(MirTypes.BIC,MirTypes.GC_REG result,MirTypes.GP_GC_REG result,
                                                          MirTypes.GP_IMM_ANY 3)]
                                  else [])),
                               [],MirTypes.ABSENT,Sexpr.NIL),[],[])))
          end
d2952 1
d3722 1
a3722 1
                            funs_in_closure, fn_tag_list, false, []);
d4011 20
a4030 23
                      let
                        val val_le_tags_list =
                          Lists.qsort (fn ((i:int, _, _, _), (i', _, _, _)) =>
                                       i < i')
                          (map (fn (AugLambda.SCON_TAG(Ident.INT (i,location)), code, tag) =>
                                (Mir_Utils.convert_int i
                                 handle Prod => 
                                   Info.error' 
                                   error_info
                                   (Info.FATAL,location,
                                    "Integer too big : " ^ i), 
                                   0, code, tag)
                        | _ => Crash.impossible"Mixed tag type in switch")
                          tagged_code)
                        (* Patch for Jont *)
                        val a_value = case val_le_tags_list of
                          {1=i, ...} :: _ => i
                        | _ => Crash.impossible"empty val_le_tags_list"
                        val (low, high) =
			  bounds(a_value, a_value, map #1 val_le_tags_list)
                        val len = Lists.length val_le_tags_list
                        val use_cgt = high+1-low <= 2*len andalso len > 2
                        (* Not too many holes, but a bigger than two list *)
d4032 97
a4128 23
                        val (the_reg, extra) = Mir_Utils.send_to_reg(regs)
                        val dflt_code = case dflt of
                          LambdaTypes.ABSENT =>
                            [MirTypes.COMMENT"No default (strange for scon match)"]
                        | LambdaTypes.PRESENT _ =>
                            [MirTypes.COMMENT "Default",
                             MirTypes.TEST(MirTypes.BGT, dflt_tag, the_reg,
                                           MirTypes.GP_IMM_INT high)]
                      in
                        if use_cgt then
                          (extra @@ dflt_code,
                           make_cgt(the_reg, low, high,
                                    map
				    (fn x => (#1 x, #3 x, #4 x))
				    val_le_tags_list))
                        else
                          let
                            fun do_test(reg, i, _, tag) =
                              Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag, reg,
                                                       MirTypes.GP_IMM_INT i)]
                          in
                            (extra,
                             do_chained_tests(the_reg,
d4132 8
a4139 2
                          end
                      end
d4423 2
a4424 2
    | cg_sub(arg as AugLambda.SCON scon, _, _, static_offset, start_at,
	     funs_in_closure, _, _, _) =
d4433 24
a4456 22
      (case scon of
	Ident.INT(i,location) =>
	  (Mir_Utils.ONE
           (Mir_Utils.INT
            (MirTypes.GP_IMM_INT
             (Mir_Utils.convert_int i
              handle Prod => 
                Info.error' 
                error_info
                (Info.FATAL,location,
                 "Integer too big : " ^ i)))),
           no_code)
      | _ =>
	let
	  val new_reg = MirTypes.GC.new()
	  val new_tag =
	    top_closure(start_at + 1)
	in
	  (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG new_reg)),
	    ((Sexpr.ATOM[MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
	      MirTypes.GC_REG callee_closure,
		MirTypes.GP_IMM_ANY(4*(static_offset +
d4458 5
a4462 5
	      [],
	      MirTypes.ABSENT, Sexpr.NIL),
	      [MirTypes.VALUE(new_tag, MirTypes.SCON scon)],
	      []))
	end)
@


1.216
log
@Removed Primitives structure.
Removed exception environments, and therefore references to EX*VAL.
@
text
@d4 4
d1531 7
a1537 4
                  case cg_sub(AugLambda.RAISE{lexp=exception_packet,size=0}, env,
                              closure,
                              static_offset, start_at, funs_in_closure,
                              fn_tag_list, false, [])
@


1.215
log
@Fixed a couple of problems which show up when compiling unoptimised lambda
code as required for the debugger. These caused references to undefined registers
and blocks without unconditional control transfers at the end.
@
text
@d4 5
a788 1
require "../main/primitives";
a804 1
  structure Primitives : PRIMITIVES
d819 3
a821 3
  sharing LambdaSub.LT = Primitives.EnvironTypes.LambdaTypes =
    LambdaPrint.LambdaTypes = Library.AugLambda.LambdaTypes = InterProc.LambdaTypes =
    Mir_Utils.Mir_Env.LambdaTypes
d825 2
a826 1
  sharing Mir_Utils.Mir_Env.MirTypes.Debugger_Types = Library.AugLambda.Debugger_Types
a846 1
  structure EnvironTypes = Primitives.EnvironTypes
d1213 1
a1213 1
     lambda_exp, top_env, filename, mapping) =
a2640 38
      | Pervasives.EXABSVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXORDVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXCHRVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXDIVVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXMODVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXQUOTVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXPRODVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXNEGVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXSUMVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXDIFFVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXFLOORVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXSQRTVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXEXPVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXLNVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXIOVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXMATCHVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXBINDVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXINTERRUPTVAL =>
	  Crash.impossible"APP of non-function"
      | Pervasives.EXRANGEVAL =>
	  Crash.impossible"APP of non-function"
a3023 4

      | Pervasives.EXSIZEVAL => 	   
	  Crash.impossible"APP of non-function"

a3026 2
      | Pervasives.EXSUBSCRIPTVAL => 
	  Crash.impossible"APP of non-function"
@


1.214
log
@The debug_warning compatability option is no more (it has ceased to be).
Replaced Integer.makestring with MLWorks.Integer.makestring and removed
the Integer structure.
@
text
@d4 5
d3537 21
a3557 16
	                [MirTypes.COMMENT
		           "select for ONE/INT/GP_GC_REG, 1 VCC",
                            MirTypes.TEST(MirTypes.BTA,
			                  vcc_tag,
			                  gp_op,
			                  MirTypes.GP_IMM_ANY tag_test_mask),
		         if num_imm_tags = 1 andalso num_imms = 1 then
		   	   MirTypes.BRANCH(
			      MirTypes.BRA,
			      MirTypes.TAG (get_imm_tag tagged_code)
			   )
			 else if num_imms = 1 orelse num_imm_tags = 0 then
		   	   MirTypes.BRANCH(
			      MirTypes.BRA,
			      MirTypes.TAG dflt_tag
			   )
d3559 1
a3559 2
		           main_branch
		       ],
d3627 6
a3632 6
               | Mir_Utils.ONE(Mir_Utils.INT(gp_op)) =>
		   Crash.impossible "_mir_cg: Mir_Utils.INT\n"
		 (* Do we need to handle GP_NON_GC_REG? *)
             |   Mir_Utils.ONE(Mir_Utils.REAL _) =>
	           Crash.impossible "SWITCH(Mir_Utils.ONE(Mir_Utils.REAL))"
             |   Mir_Utils.LIST many =>
d3753 1
a3753 1
		    );
d3873 21
a3893 16
               ((case (default, test_code) of
		   (* This should never be called without a default,
		      but it's worth being on the safe side.
		    *)
		   (LambdaTypes.PRESENT _, MirTypes.PRESENT _) =>
		     Sexpr.ATOM[MirTypes.BRANCH(MirTypes.BRA,
						MirTypes.TAG dflt_tag),
                            MirTypes.COMMENT "default or end"]
		 | _ => Sexpr.NIL,
		 [],
		 MirTypes.ABSENT,
                 Sexpr.NIL),
		[],
		[]
	       )
             |   do_chained_tests(the_reg,
d3905 1
a3905 1
                   val the_test = 
d3910 17
d4250 86
a4335 8
	    val first' = rev(Mir_Utils.contract_sexpr first)
	    val last_branch = case first' of
	      MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag) ::
	      (move_inst as
	       MirTypes.UNARY(MirTypes.MOVE, rn, MirTypes.GP_IMM_INT i)) ::
	      xs =>
		let
		  val new_tag = if i = 1 then true_tag else false_tag
d4337 2
a4338 79
		  MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG new_tag)
                (* Remove the setup true/false in register *)
		end
	    | _ => Crash.impossible
		(implode
		 ("Bad relational expression code in\n" ::
		  "blocks =\n" ::
		  (map (fn x => MirPrint.block x ^ "\n") blocks) @@
		  ("Tag_opt = " ::
		   (case tag_opt of MirTypes.ABSENT => "ABSENT"
                 | MirTypes.PRESENT tag => MirTypes.print_tag tag) ::
		      "\nfirst =\n" ::
		      (map (fn x => MirPrint.opcode x ^ "\n")
		       (Mir_Utils.contract_sexpr first)) @@
		      ("last =\n" ::
		       (map (fn x => MirPrint.opcode x ^ "\n")
			(Mir_Utils.contract_sexpr last))))))
                
	    val first' = Lists.tl(Lists.tl first')
	    val prev_branch = case first' of
	      MirTypes.TEST(cond_branch, tag, e1, e2) ::
	      (move_inst as
	       MirTypes.UNARY(MirTypes.MOVE, rn, MirTypes.GP_IMM_INT i)) ::
	      xs =>
		let
		  val new_tag = if i = 1 then true_tag else false_tag
		in
		  MirTypes.TEST(cond_branch, new_tag, e1, e2)
                (* Remove the setup true/false in register *)
		end
	    | MirTypes.FTEST(cond_branch, tag, e1, e2) ::
	      (move_inst as
	       MirTypes.UNARY(MirTypes.MOVE, rn, MirTypes.GP_IMM_INT i)) ::
	      xs =>
		let
		  val new_tag = if i = 1 then true_tag else false_tag
		in
		  MirTypes.FTEST(cond_branch, new_tag, e1, e2)
		  (* Remove the setup true/false in register *)
		end
	    | _ => Crash.impossible
		(implode
		 ("Bad relational expression code in\n" ::
		  "blocks =\n" ::
		  (map (fn x => MirPrint.block x ^ "\n") blocks) @@
		  ("Tag_opt = " ::
		   (case tag_opt of MirTypes.ABSENT => "ABSENT"
		      | MirTypes.PRESENT tag => MirTypes.print_tag tag) ::
		      "\nfirst =\n" ::
		      (map (fn x => MirPrint.opcode x ^ "\n")
		       (Mir_Utils.contract_sexpr first)) @@
		      ("last =\n" ::
		       (map (fn x => MirPrint.opcode x ^ "\n")
			(Mir_Utils.contract_sexpr last))))))
	    val new_first = rev(last_branch :: prev_branch ::
				(Lists.tl(Lists.tl first')))
	  in
	    Mir_Utils.combine(the_code, ((Sexpr.ATOM new_first, [], tag_opt,
					  last), values, procs))
	  end
	else Mir_Utils.combine(the_code, test_code)
        val result_code =
          Mir_Utils.combine(
	    Mir_Utils.combine(
	      the_code,
	      Mir_Utils.combine(
	        ((Sexpr.NIL, [], MirTypes.PRESENT main_tag, Sexpr.ATOM main_default),
	         [],
	         []),
	        main_code
	      )
	    ),
	    ((Sexpr.NIL, dflt_blocks, MirTypes.PRESENT end_tag, Sexpr.NIL),
	    dflt_values,
	    dflt_procs)
	  )
        in
          (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG end_reg)), result_code)
        end)
a5064 23
(*
    val value_tags =
      map (fn MirTypes.VALUE(tag, _) => tag) values
    val proc_tags =
      Lists.reducer
      op @@
      (map
       (fn proc_set =>
	map (fn MirTypes.PROC{2=tag, ...} => tag) proc_set)
       new_procs, [])
    val all_tags = value_tags @@ proc_tags
    val _ =
      if Lists.length all_tags = Lists.length(Lists.filter all_tags) then ()
      else
	(Print.print"all_tags contains repeats\nsorted list is:-\n";
	 let
	   val ordered_tags = Lists.qsort MirTypes.order_tag all_tags
	 in
	   Lists.iterate
	   (fn tag => Print.print(MirTypes.print_tag tag ^ "\n"))
	   ordered_tags
	 end)
*)
@


1.213
log
@Added a move instruction to put the argument register back in the
right place after a return from an INTERCEPT.
@
text
@d4 4
a767 1
require "../utils/integer";
a794 1
  structure Integer : INTEGER
d1198 6
a1203 6
    (Options.OPTIONS {compiler_options = Options.COMPILEROPTIONS {debug,
                                                                  intercept,
                                                                  debug_warnings,
                                                                  opt_self_calls, 
                                                                  opt_tail_calls,
                                                                  ...},
d1246 1
a1246 1
                                            not (debug_warnings)))
d3284 5
a3288 5
	    Crash.impossible("Trying to select item " ^
			     Integer.makestring index ^ " from list size " ^
			     Integer.makestring(Lists.length many) ^
			     " with struct size " ^ Integer.makestring size ^
			     "\n")
d3638 1
a3638 1
		           Integer.makestring(Lists.length many) ^
d4316 1
a4316 1
	LambdaPrint.string_of_lambda arg, " funs_in_closure = " ^ Integer.makestring funs_in_closure ^ "\n"])
@


1.212
log
@Changed name of setup function again.
@
text
@d4 3
d4693 4
a4696 1
                        MirTypes.INTERCEPT]
@


1.211
log
@Unified profiling and tracing options into `intercept'.
The argument is always in the argument register before an
INTERCEPT instruction.
Changed PROFILE instruction to INTERCEPT.
@
text
@d4 6
d1203 1
a1203 1
    val name_of_setup_function = "Setup procedure [" ^ filename ^ ":1,1]"
@


1.210
log
@Changed format of debug_info strings.
@
text
@d4 3
d1187 2
a1188 3
    (Options.OPTIONS {compiler_options = Options.COMPILEROPTIONS {trace, 
                                                                  debug,
                                                                  profile, 
d3138 2
a3139 1
      val can_stack_parms = (not trace) andalso
d4454 14
a4467 16
	(Sexpr.ATOM(comment_string @@
         (if MirRegisters.automatic_callee then
	   [MirTypes.ENTER]
	 else
	   [MirTypes.ENTER,
	    MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_closure,
			   MirTypes.GP_GC_REG caller_closure),
	    MirTypes.COMMENT"Copy closure pointer to local copy (callee save)",
	    MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_arg,
			   MirTypes.GP_GC_REG caller_arg)]) @@
            [(* "Move the argument to somewhere safe, and let register colouring deal with allocation" *)
             MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG copied_callee_arg,
                            MirTypes.GP_GC_REG callee_arg)] @@
            (if profile orelse trace
               then [MirTypes.PROFILER(MirTypes.GC_REG(MirTypes.GC.new()))]
             else nil)),
d4674 15
a4688 6
	       ((Sexpr.ATOM
		 [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)], [],
		 MirTypes.PRESENT loop_tag, 
                 if profile
                   then Sexpr.ATOM[MirTypes.PROFILER(MirTypes.GC_REG(MirTypes.GC.new()))]
                 else Sexpr.NIL), [], [])
d4967 1
a4967 1
      ((if profile then
d4969 1
a4969 1
		     MirTypes.PROFILER (MirTypes.GC_REG(MirTypes.GC.new()))]
@


1.209
log
@Removed handler chain restore code, now generated in _mach_cg from OLD_HANDLER
@
text
@d4 3
d1195 1
a1195 1
    val name_of_setup_function = "Setup procedure for " ^ filename ^ ":1,1"
@


1.208
log
@Ensured that the results of unsafe sub for byte array are tagged as integer
@
text
@d4 3
d4891 1
d4894 1
@


1.207
log
@Added vector primitives and changed bytearray implementation to use ref tags
@
text
@d4 3
d2104 4
a2107 2
                                MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG MirRegisters.global,
                                                MirTypes.GP_GC_REG MirRegisters.global, new_reg'),
d2109 5
a2113 1
                                                 MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY ~1)]
@


1.206
log
@Fixed problems in ByteArray.{length,sub,update} to do with loading from
the wrong offset to get the header length, and also not tagging the result
from sub.
@
text
@d4 5
d1912 1
a1912 1
                                                  MirTypes.GP_IMM_ANY ~1),
d1954 1
a1954 1
           Mir_Utils.ONE(array) =>
d1956 1
a1956 1
               val (new_reg, code) = Mir_Utils.send_to_reg(Mir_Utils.ONE array)
d1967 1
a1967 1
                                      MirTypes.GP_IMM_ANY(if bytearray then ~5 else ~3)),
d1977 25
d2059 1
a2059 1
                                        MirTypes.GP_IMM_ANY(if bytearray then ~5 else ~3)),
d2079 1
a2079 1
                                                     MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY ~1),
d2114 81
d2272 1
a2272 1
                                    MirTypes.GP_IMM_ANY(if bytearray then ~5 else ~3)),
d2299 1
a2299 1
                                                   MirTypes.GC_REG address, MirTypes.GP_IMM_ANY ~1),
d3021 3
@


1.205
log
@Modified Array.sub and Array.update to use MirRegisters.global when bounds
checking to avoid leaving dirty values in the registers
@
text
@d4 4
d1961 6
a1966 6
                     MirTypes.STOREOP(MirTypes.LDREF,res1,Mir_Utils.reg_from_gp new_reg,
                                      MirTypes.GP_IMM_ANY (if bytearray then ~1 else ~3)),
                     MirTypes.BINARY(MirTypes.LSR,res1,
                                     MirTypes.GP_GC_REG result,MirTypes.GP_IMM_ANY 4),
                     MirTypes.BINARY(MirTypes.BIC,res1,
                                     MirTypes.GP_GC_REG result,MirTypes.GP_IMM_ANY 3)]),
d2005 1
d2014 1
a2014 1
              (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
d2029 1
a2029 1
                                        MirTypes.GP_IMM_ANY ~3),
d2036 4
a2039 1
                      MirTypes.TEST(MirTypes.BGE, main_tag, MirTypes.GP_GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 5),
d2050 2
d2063 1
a2063 1
            (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
d2105 1
a2105 1
                in
d2161 1
a2161 1
                                    MirTypes.GP_IMM_ANY ~3),
d2168 4
a2171 1
                   MirTypes.TEST(MirTypes.BGE, main_tag, MirTypes.GP_GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 5),
@


1.204
log
@Signature revisions
@
text
@d4 3
a2003 1
              val checksize = MirTypes.GC.new()
d2022 1
a2022 1
                      [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG checksize,
d2025 2
a2026 2
                      MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG checksize,
                                      MirTypes.GP_GC_REG checksize,
d2028 2
a2029 2
                      MirTypes.BINARY(MirTypes.SUB,MirTypes.GC_REG checksize,
                                      MirTypes.GP_GC_REG checksize,
d2031 1
a2031 1
                      MirTypes.TEST(MirTypes.BGE, main_tag, MirTypes.GP_GC_REG checksize, MirTypes.GP_IMM_ANY 5),
a2123 1
          val checksize = MirTypes.GC.new()
d2149 1
a2149 1
                  [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG checksize,
d2152 2
a2153 2
                   MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG checksize,
                                   MirTypes.GP_GC_REG checksize,
d2155 2
a2156 2
                   MirTypes.BINARY(MirTypes.SUB,MirTypes.GC_REG checksize,
                                   MirTypes.GP_GC_REG checksize,
d2158 1
a2158 1
                   MirTypes.TEST(MirTypes.BGE, main_tag, MirTypes.GP_GC_REG checksize, MirTypes.GP_IMM_ANY 5),
d4322 1
a4322 1
            (if profile
@


1.203
log
@Added code for dealing with builtin string relationals
@
text
@d4 3
d779 1
a779 2
  sharing Type_Utils.DataTypes = LambdaSub.LT.Datatypes = Types.Datatypes =
    MirPrint.MirTypes.Debugger_Types.Datatypes
d783 5
d798 1
a798 1
  structure Datatypes = LambdaTypes.Datatypes
d1163 8
a1170 1
    (Options.COMPILEROPTIONS {trace, debug, profile, debug_warnings,opt_self_calls, opt_tail_calls, ...},
d2130 1
a2130 1
              ty as LambdaTypes.Datatypes.RECTYPE _ =>
d2363 1
a2363 1
		ty as LambdaTypes.Datatypes.RECTYPE _ =>
d3973 3
a3975 4
                                                 if Mir_Utils.contract_sexpr last = [] then
                                                   app_code
                                                 else
                                                   Crash.impossible"Bad result for STRINGEQ"
d4041 3
a4043 4
                           if Mir_Utils.contract_sexpr last = [] then
                             (reg, code)
                           else
                             Crash.impossible"Bad result from cg(exception)"
@


1.202
log
@Options & Info changes
@
text
@d4 3
d2815 4
@


1.201
log
@Removed LVar_eq in favour of polymorphic equality
@
text
@d4 3
d730 1
d752 1
d769 1
a769 2
  sharing Types.Datatypes.Ident.Location = Library.AugLambda.Info.Location
  sharing Library.AugLambda.Info = MirPrint.MirTypes.Debugger_Types.Info
d804 2
a805 1
  structure Info = AugLambda.Info
d1152 3
a1154 6
	info_opts
	(options as
	   MirTypes.OPTIONS {trace, debug, profile, debug_warnings,
			     opt_self_calls, opt_tail_calls, ...},
	 lambda_exp, top_env, filename, mapping
	) =
d1193 3
a1195 3
       fn () => AugLambda.count_gc_objects info_opts (new_lambda_exp,debug,
                                                      mapping,name_of_setup_function,
                                                      not (debug_warnings)))
d3829 4
a3832 8
                                   let
                                     val MirTypes.OPTIONS{info_opts,...} = options 
                                   in
                                     Info.error' 
                                     info_opts 
                                     (Info.FATAL,location,
                                      "Integer too big : " ^ i)
                                   end, 
d4175 4
a4178 8
                let
                  val MirTypes.OPTIONS{info_opts,...} = options 
                in
                  Info.error' 
                  info_opts 
                  (Info.FATAL,location,
                   "Integer too big : " ^ i)
                end))), 
@


1.200
log
@Rationalised use of Mapping structure
Change of Jon's for polyeq
@
text
@d4 4
d795 1
a795 1
    val eq = LambdaTypes.LVar_eq
@


1.199
log
@Added MLVALUE lambda exp
This is handled just like a string SCON
@
text
@d4 4
a782 1
  structure Map = Datatypes.Mapping
d2107 2
a2108 2
              LambdaTypes.Datatypes.RECTYPE map =>
		Type_Utils.is_integral(Map.lookup(Ident.LAB(Symbol.find_symbol "3"), map))
d2340 2
a2341 2
		LambdaTypes.Datatypes.RECTYPE map =>
		  Type_Utils.is_integral(Map.lookup(Ident.LAB(Symbol.find_symbol "2"), map))
a2742 9
(*
		    MirTypes.TEST(MirTypes.BNE, bad_tag,
				  MirTypes.GP_GC_REG(MirRegisters.global),
				  MirTypes.GP_IMM_ANY 1),
		    (* Is first one an ordinary pointer *)
		    MirTypes.BINARY(MirTypes.AND,
				    MirTypes.GC_REG(MirRegisters.global),
				    reg2, MirTypes.GP_IMM_ANY 3),
*)
d2744 1
a2744 1
				    MirTypes.GC_REG MirRegisters.global, reg1,
@


1.198
log
@Modified to use new variable size hashsets
@
text
@d4 3
d971 1
d1032 1
d1074 1
d1108 1
d3913 2
a3914 2
                                              top_closure (start_at + p + 1)
                                              , scon)
d3991 2
a3992 2
                                              top_closure(start_at + p + 1)
                                              , scon)
d4201 1
a4201 1
	      [MirTypes.VALUE(new_tag, scon)],
d4204 16
@


1.197
log
@Added check that argument to ordof is non-negative.
Also removed some commented-out code.
@
text
@d4 4
d1135 1
a1135 1
	   MirTypes.OPTIONS {debug, profile, debug_warnings,
d1269 2
d2965 8
a2972 6
      val can_stack_parms = case le1 of
	AugLambda.VAR lv =>
	  (case LambdaTypes.Map.tryApply'(escape_map, lv) of
	     LambdaTypes.Map.YES ok => not ok
	   | _ => false)
      | _ => false
d4210 2
a4211 2
	   ((LambdaTypes.Map.fold add_member (LambdaTypes.Map.fold add_member (HashSet.empty_set(), closure_env), lambda_env),
	     HashSet.empty_set()),
d4345 2
a4346 2
	   ((LambdaTypes.Map.fold add_member (LambdaTypes.Map.fold add_member (HashSet.empty_set(), closure_env), lambda_env),
	     HashSet.empty_set()),
@


1.196
log
@Changed int and real scons to carry a location around
@
text
@d4 3
d760 1
a760 1
    ) : MIR_CG =
d2602 4
a2605 2
	      Mir_Utils.ONE(Mir_Utils.INT reg) => Mir_Utils.destruct_2_tuple reg
	    | Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] => (reg1, reg2, [])
d2607 2
a2608 2
	  val (the_ptr, the_size, code) =
	    do_size(Mir_Utils.ONE(Mir_Utils.INT val1))
d2612 4
a2615 15
	  val exn_tag = MirTypes.new_tag()
	  val exn_blocks = exn_code_for_prim(prim, exn_tag)
	  val final_instructions = case val2 of
	    MirTypes.GP_IMM_INT i =>
	      [MirTypes.STOREOP(MirTypes.LDB, res1, the_ptr,
				MirTypes.GP_IMM_ANY(i-1)),
	       MirTypes.BINARY(MirTypes.ASL, res1,res2, MirTypes.GP_IMM_ANY 2)]
	  | reg as MirTypes.GP_GC_REG _ =>
	      [MirTypes.BINARY(MirTypes.LSR, res1, reg, MirTypes.GP_IMM_ANY 2),
	       MirTypes.BINARY(MirTypes.ADD, res1, res2,
			       Mir_Utils.gp_from_reg the_ptr),
	       MirTypes.STOREOP(MirTypes.LDB, res1, res1,
				MirTypes.GP_IMM_ANY ~1),
	       MirTypes.BINARY(MirTypes.ASL, res1,res2, MirTypes.GP_IMM_ANY 2)]
	  | _ => Crash.impossible"Bad args for ordof"
d2617 35
a2651 6
	  (Mir_Utils.ONE(Mir_Utils.INT res2),
	   Mir_Utils.combine(the_code,
		   ((Sexpr.ATOM(new_code @@ code @@
		     (MirTypes.TEST(MirTypes.BLE, exn_tag, the_size,
				    val2) :: final_instructions)),
		     exn_blocks, MirTypes.ABSENT, Sexpr.NIL), [], [])))
a3115 2
	     (* We know the value to be switched on, so look it up
		at compile time *)
a3116 30
	     (*
             let
               fun find_in_tagged ([],_) = 
                 (case dflt of
                    LambdaTypes.PRESENT {lexp,size} => 
                      cg_sub(lexp,env,closure,
                             static_offset + arg_size + list_size + tag_sizes,
                             start_at + arg_size + list_size + tag_sizes,
                             funs_in_closure,fn_tag_list,false,[])
                  | _ => Crash.impossible "Problem in optimising in _mir_cg")
               |   find_in_tagged ((AugLambda.IMM_TAG x,{lexp,size})::rest,
				   le_offset::rest_pos) =
                 if x = arg then
		   cg_sub(lexp, env, closure, static_offset + le_offset,
                          start_at + le_offset, funs_in_closure, fn_tag_list,
			  tails, tuple_bindings)
                 else find_in_tagged (rest,rest_pos)
               |   find_in_tagged ((AugLambda.VCC_TAG x,{lexp,size})::rest,
				   le_offset::rest_pos) =
                 if x = arg then
		   cg_sub(lexp, env, closure, static_offset + le_offset,
                          start_at + le_offset, funs_in_closure, fn_tag_list,
			  tails, tuple_bindings)
                 else find_in_tagged (rest,rest_pos)
               |   find_in_tagged _ =
		 Crash.impossible "Problem in optimising switch"
             in
               find_in_tagged (tag_le_list,positions)
             end
	     *)
a3426 18
		   (*
		   (* We have to put this integer into a register,
		      or the code generator complains.  Seems odd;
		      couldn't we use this information for optimisation?
		    *)
         	   let val tmp_reg = MirTypes.GC.new()
         	   in
           	     (MirTypes.GP_GC_REG tmp_reg,
            	     [MirTypes.COMMENT "no tag test needed for ONE/IMM_",
		      MirTypes.UNARY(MirTypes.MOVE,
				     MirTypes.GC_REG tmp_reg,
				     gp_op),
		       main_branch],
		      true
		     )
		   end
		   *)

@


1.195
log
@Raised Info.errors for overflow of constants during code generation
@
text
@d4 3
d746 1
d3838 1
a3838 1
                          (map (fn (AugLambda.SCON_TAG(Ident.INT i), code, tag) =>
d3846 1
a3846 1
                                     (Info.FATAL,Info.Location.UNKNOWN,
d4185 1
a4185 1
	Ident.INT i =>
d4196 1
a4196 1
                  (Info.FATAL,Info.Location.UNKNOWN,
@


1.194
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d3835 11
a3845 1
                                (Mir_Utils.convert_int i, 0, code, tag)
d4182 14
a4195 1
	  (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_IMM_INT(Mir_Utils.convert_int i))), no_code)
@


1.193
log
@Changes to propagate compiler options as parameters instead of references.
@
text
@d4 3
a712 1
require "../main/info";
d740 1
a740 1
  sharing Library.AugLambda.Info = MirPrint.MirTypes.Info
@


1.192
log
@Modified to use new improved hashset signature
@
text
@d4 3
d738 1
d756 1
a756 1
  structure MirTypes = Mir_Env.MirTypes
d773 1
a777 5
  val generate_profiling = ref(false)
  val generate_tail_optimisation = Mir_Utils.do_tail_optimisation
  val generate_self_call_optimisation = Mir_Utils.do_self_call_optimisation
  val generate_debug_inhibit_warnings = ref(true)

d1116 7
a1122 1
  fun mir_cg info_opts (lambda_exp, top_env,filename,mapping,generate_debug_information) =
d1161 1
a1161 1
       fn () => AugLambda.count_gc_objects info_opts (new_lambda_exp,generate_debug_information,
d1163 1
a1163 1
                                                      !generate_debug_inhibit_warnings))
d2960 1
d2967 1
a2967 1
		   tails)
d3945 2
a3946 2
                                               no_code, false,
                                               Lists.hd fn_tag_list, 0, 0, [], false, true)
d4274 1
a4274 1
            (if ! generate_profiling
d4486 1
a4486 1
                 if ! generate_profiling
d4765 1
a4765 1
      ((if ! generate_profiling then
@


1.191
log
@Removed a large number of unnecessary map operations
@
text
@d4 3
d1043 2
a1044 2
	 if HashSet.is_member(lv, old_set) then
	   HashSet.add_member(lv, new_set)
d4187 1
a4187 1
	   fun add_member (set, x, _) = HashSet.add_member(x, set)
d4198 1
a4198 1
	      HashSet.add_member(NewMap.apply'(prim_to_lambda, Pervasives.STRINGEQ), free)
d4204 1
a4204 1
	   (fn (free', x) => HashSet.add_member(NewMap.apply'(prim_to_lambda, x), free'))
d4322 1
a4322 1
	   fun add_member (set, x, _) = HashSet.add_member(x, set)
d4333 1
a4333 1
	      HashSet.add_member(NewMap.apply'(prim_to_lambda, Pervasives.STRINGEQ), free)
d4339 1
a4339 1
	   (fn (free', x) => HashSet.add_member(NewMap.apply'(prim_to_lambda, x), free'))
@


1.190
log
@Fixed misleading typo in generated Mir comment.
Also deleted redefinition of append.
@
text
@d4 4
d1001 2
a1002 2
      Set.union
      (Set.empty_set, map get_string le_list)
d2990 2
a2991 2
	  Mir_Utils.combine
	  (map #2 reg_code_list, no_code)
d2993 19
a3011 10
	  map (fn Mir_Utils.ONE reg => (reg, [MirTypes.COMMENT("Argument to tuple")])
	  | Mir_Utils.LIST regs =>
	    let
	      val (reg, code) = Mir_Utils.tuple_up(regs)
	    in
	      (Mir_Utils.INT(MirTypes.GP_GC_REG reg),
	        MirTypes.COMMENT("Argument to tuple") :: code)
	    end)
	  (map #1 reg_code_list)
	val new_code = Lists.reducer op @@ (map #2 new_reg_code_list, [])
d3014 2
a3015 2
	 Mir_Utils.combine(the_code, ((Sexpr.ATOM new_code, [],
				       MirTypes.ABSENT, Sexpr.NIL), [], [])))
d3237 1
a3237 1
             val tagged_code =	map
d3600 4
a3603 1
                     Lists.reducer op @@ (map (#2 o #2 o #2) val_code_tag_list, [])
d3605 3
a3607 1
                     Lists.reducer op @@ (map (#3 o #2 o #2) val_code_tag_list, [])
d3612 4
a3615 3
                     let val end_code =
                           Mir_Utils.send_to_given_reg(regs, end_reg) @@
			     [MirTypes.COMMENT "end CGT", final_branch]
d3827 2
a3828 1
                        val (low, high) = bounds(a_value, a_value, map #1 val_le_tags_list)
d3845 3
a3847 1
                                    map (fn x => (#1 x, #3 x, #4 x)) val_le_tags_list))
d4409 3
a4411 3
      val arg_select_list = map #1 select_rest_list
      val copied_callee_arg_list =
	map (fn _ => MirTypes.GC.new()) fn_args
d4417 1
a4417 1
	(Lists.zip(fn_args, copied_callee_arg_list))
d4421 1
a4421 1
	(fn reg =>
d4427 1
a4427 1
	copied_callee_arg_list
a4447 1
      val le_list''' = map #2 select_rest_list
d4450 1
a4450 1
	(fn ((_, env, _, _), (reg, arg_selects)) =>
d4458 2
a4459 1
		    Lists.zip(copied_callee_arg_list, arg_select_list)))
d4536 1
a4536 2
	     ((Sexpr.ATOM(final_code @@
	      [MirTypes.RTS]),
d4568 3
a4570 2
	Lists.reducer op @@
	(map #1 fn_val_procs_proc_list, [])
d4572 3
a4574 2
	Lists.reducer op @@
	(map #2 fn_val_procs_proc_list, [])
d4807 1
d4829 1
@


1.189
log
@Commented out the code dealing with switches on integers, as the lambda
optimiser should deal with these.  Also stopped do_chained_tests from
generating unnecessary code in the case of an exhaustive switch without
a default (althought the lambda optimiser should catch this case too).
@
text
@d4 6
a765 11
  fun rev_app([], x) = x
    | rev_app(x :: xs, y) = rev_app(xs, x :: y)

  fun rev x = rev_app(x, [])

  fun app(x, []) = x
    | app([], x) = x
    | app(x, y) = rev_app(rev x, y)

  val op@@ = app

d3301 1
a3301 1
			    "select for ONE/INT/GP_GC_REG, 0 IMM_TAG",
@


1.188
log
@Changed Error structure to Info
@
text
@d4 3
d3068 2
d3098 1
d3408 2
d3425 1
d3664 8
a3671 4
             fun do_chained_tests(_, def_tag, [], test_code) =
               ((case test_code of
		   MirTypes.PRESENT _ =>
		     Sexpr.ATOM[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG def_tag),
d3673 1
a3673 1
		 | MirTypes.ABSENT => Sexpr.NIL,
d3681 1
a3681 1
				  def_tag,
d3723 1
a3723 1
                      do_chained_tests(the_reg, def_tag, rest, test_code))
d3759 1
a3759 1
					  dflt_tag,
d3839 1
a3839 1
					      dflt_tag,
d3887 1
a3887 1
                                           do_chained_tests(the_reg, dflt_tag, val_le_tags_list, MirTypes.PRESENT do_test)))
d3965 1
a3965 1
                                           do_chained_tests(the_reg, dflt_tag, val_le_tags_list, MirTypes.PRESENT do_test)))
d4003 1
a4003 1
                   ([], do_chained_tests(the_reg, dflt_tag, val_le_tags_list, MirTypes.PRESENT do_test))
@


1.187
log
@Removed curry_reduce. Changed top_tags map to use intnewmap
@
text
@d4 3
d691 1
d753 1
d1111 1
a1111 1
  fun mir_cg(lambda_exp, top_env,filename,mapping,generate_debug_information) =
d1150 3
a1152 3
       fn () => AugLambda.count_gc_objects (new_lambda_exp,generate_debug_information,
                                            mapping,name_of_setup_function,
                                            !generate_debug_inhibit_warnings))
@


1.186
log
@Switches now have both value-carrying and immediate constructors in the
same switch.  Much fancy code to optimise special cases.
@
text
@d4 4
d677 1
a681 1
require "../lambda/curry_reduce";
d700 1
a706 1
  structure Curry_Reduce : CURRY_REDUCE
d717 1
a717 1
    Mir_Utils.Mir_Env.LambdaTypes = Curry_Reduce.LambdaTypes
a1123 26
(*
    val _ = Diagnostic.output 2
            (fn i => (Print.print "Uncurrying..."; []))

    val new_lambda_exp = Curry.uncurry_exp new_lambda_exp
    val _ = Diagnostic.output 2
             (fn i => (Print.print"done\n"; []))
*)

    val _ =
      Diagnostic.output 2
      (fn i => 
       (Print.print "The uncurried lambda code\n";
	LambdaPrint.print_lambda new_lambda_exp;
	[]))

    val new_lambda_exp = Curry_Reduce.reduce_curry new_lambda_exp

    val _ =
      Diagnostic.output 2
      (fn i => 
       (Print.print "The curry-reduced lambda code\n";
	LambdaPrint.print_lambda new_lambda_exp;
	[]))


a1152 2
    fun relation(i:int, i') = i < i' 
      
d1154 1
a1154 1
      NewMap.apply
d1156 2
a1157 2
       (fn (x, (t, i)) => NewMap.define(x, i, t))
       (NewMap.empty (relation,op =), top_tags_list))
d1231 1
a1231 1
      NewMap.apply
d1234 2
a1235 2
	NewMap.define(tree, lv, MirTypes.new_tag()))
       (NewMap.empty (LambdaTypes.LVar_order,LambdaTypes.LVar_eq), top_lambdas))
a2931 5
(*
		  handle NewMap.Undefined =>
		    Crash.impossible("Lambda " ^ LambdaTypes.printLVar lvar ^
				     " has no loop entry tag")
*)
a4436 6
(*
		  handle NewMap.Undefined =>
		    Crash.impossible("Lambda " ^
				     LambdaTypes.printLVar lvar ^
				     " has no loop entry tag")
*)
@


1.185
log
@Changed to use LambdaTypes.Map and MirTypes.Map
@
text
@d4 3
d908 2
a909 2
    | lift_externals(trees, {lexp=AugLambda.SWITCH(le, tag_le_list, opt1,
						   opt2), size=size}) =
d911 1
a911 9
	val (trees, opt1) = case opt1 of
	  LambdaTypes.PRESENT le =>
	    let
	      val (trees, le) = lift_externals(trees, le)
	    in
	      (trees, LambdaTypes.PRESENT le)
	    end
	| _ => (trees, opt1)
	val (trees, opt2) = case opt2 of
d918 1
a918 1
	| _ => (trees, opt2)
d923 1
a923 1
	(trees, {lexp=AugLambda.SWITCH(le, tag_le_list, opt1, opt2),
d1015 1
a1015 1
    | AugLambda.SWITCH(le, tag_le_list, opt1, opt2) =>
d1026 1
a1026 2
	 (bandf_opt
	  (new_frees(vars, le), opt1), opt2), tag_le_list)
d1073 1
a1073 2
  | needs_prim_stringeq(AugLambda.SWITCH({lexp=le, ...}, tag_le_list, opt1,
					 opt2)) =
d1075 1
a1075 2
    needs_prim_stringeq_opt opt1 orelse
    needs_prim_stringeq_opt opt2 orelse
d3069 3
a3071 4
	     ({lexp=lexp,size=arg_size},
	      tag_le_list, def1, def2), env, closure,
	     static_offset, start_at, funs_in_closure, fn_tag_list, tails,
	     tuple_bindings) =
d3083 1
d3087 2
d3091 1
a3091 1
                 (case def1 of
d3098 16
a3113 9
                 | find_in_tagged ((AugLambda.CON_TAG x,{lexp,size})::rest,le_offset::rest_pos) =
                   if x = arg
                     then 
                       cg_sub(lexp, env, closure, static_offset + le_offset,
                              start_at + le_offset, funs_in_closure, fn_tag_list, tails,
                              tuple_bindings)

                   else find_in_tagged (rest,rest_pos)
                 | find_in_tagged _ = Crash.impossible "Problem in optimising switch"
d3120 6
d3127 5
d3149 6
a3154 49
             val def1_size = case def1 of
               LambdaTypes.ABSENT => 0
             | LambdaTypes.PRESENT{size=size, ...} => size
             val def2_size = case def2 of
               LambdaTypes.ABSENT => 0
             | LambdaTypes.PRESENT{size=size, ...} => size
             val (regs, the_code, test_code) =
               if is_rel then
                 let
                   val (primAndTy, arg, is_struct) = case lexp of
                     AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, ...},
                                   {lexp=AugLambda.STRUCT le_list, ...},_) =>
                     (primAndTy, le_list, true)
                                 | AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, ...}, arg,_) =>
                                     (primAndTy, [arg], false)
                                 | _ => Crash.impossible"Bad rel lexp"
                   val lv_le_list =
                     map
                     (fn le => (LambdaTypes.new_LVar(), le))
                     arg
                   val (code, env', static_offset', start_at') =
                     cg_bind_list(lv_le_list, env, closure, static_offset, start_at,
                                  funs_in_closure, fn_tag_list)
                   val lvar = case lv_le_list of
                     (lvar, _) :: _ => lvar
                   | _ => Crash.impossible"Empty arg to relation"
                   val new_test =
                     AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, size=0},
                                   {lexp=(if is_struct then
                                            AugLambda.STRUCT(map (fn (lvar, _) =>
                                                                  {lexp=AugLambda.VAR lvar,
                                                                   size=0}) lv_le_list)
                                          else
                                            AugLambda.VAR lvar), size=0},
                                   MirTypes.Debugger_Types.null_backend_annotation)
                   val (rest_regs, rest_code) =
                     cg_sub(new_test, env', closure, static_offset', start_at',
                            funs_in_closure, fn_tag_list, false, [])
                 in
                   (rest_regs, code, rest_code)
                 end
               else
                 let
                   val (regs, the_code) =
                     cg_sub(lexp, env, closure, static_offset, start_at,
                            funs_in_closure, fn_tag_list, false, [])
                 in
                   (regs, the_code, no_code)
                 end
d3157 4
a3160 1
             val final_branch = MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG end_tag)
d3164 2
a3165 2
             fun get_blocks_for_defs(def, static_offset, start_at, comment) =
               case def of
d3171 5
a3175 2
                              funs_in_closure, fn_tag_list, tails, tuple_bindings)
                     (* This may be a tail, but only if we are in  the tail line *)
d3177 25
a3201 12
                       Mir_Utils.combine
                       (the_code,
                        ((Sexpr.ATOM(MirTypes.COMMENT comment :: 
                                     (case regs of
                                        Mir_Utils.ONE(Mir_Utils.INT reg) =>
                                          [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG end_reg, reg)]
                                      | Mir_Utils.ONE(Mir_Utils.REAL reg) =>
                                          Mir_Utils.save_real_to_reg(reg, MirTypes.GC_REG end_reg)
                                      | Mir_Utils.LIST many =>
                                          (#2 (Mir_Utils.tuple_up_in_reg(many, end_reg)))) @@
                                        [final_branch]),
                        [], MirTypes.ABSENT, Sexpr.NIL), [], []))
d3205 20
a3224 8
                       ((first, blocks, MirTypes.ABSENT, last), values, procs) =>
                         (MirTypes.BLOCK(new_tag, Mir_Utils.contract_sexpr first) ::
                          blocks, new_tag, values, procs)
                     | ((first, blocks, MirTypes.PRESENT tag, last), values, procs) =>
                         (MirTypes.BLOCK(new_tag, Mir_Utils.contract_sexpr first) ::
                          MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr last) :: blocks,
                          new_tag, values, procs)
                         
d3227 7
a3233 12
             (* Deal with the two possible default cases *)
             val (blocks1, tag1, values1, procs1) =
               get_blocks_for_defs (def1,
                                   static_offset + arg_size + list_size + tag_sizes,
                                   start_at + arg_size + list_size + tag_sizes,
                                   "simple default")
             val (blocks2, tag2, values2, procs2) =
               get_blocks_for_defs(def2,
                                   static_offset + arg_size + list_size + tag_sizes +
                                   def1_size,
                                   start_at + arg_size + list_size + tag_sizes +
                                   def1_size, "Value carrying default for datatypes")
d3235 12
a3246 21
             (* Generate code for spotting the vcc default case *)
             val ptr_code = case def2 of
               LambdaTypes.ABSENT => [MirTypes.COMMENT"No vcc default"]
             | LambdaTypes.PRESENT _ =>
                 let
                   val (source, code) = case regs of
                     Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)) => (reg, [])
                   | Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_IMM_INT _)) =>
                       Crash.impossible"Vcc default for non-structured value 1" 
                   | Mir_Utils.ONE _ =>
                       Crash.impossible"Vcc default for non-structured value"
                   | Mir_Utils.LIST many =>
                       let
                         val (gc_reg, code) = Mir_Utils.tuple_up many
                       in
                         (MirTypes.GP_GC_REG gc_reg, code)
                       end
                 in
                   MirTypes.COMMENT"Vcc default" :: code @@
                   [MirTypes.TEST(MirTypes.BTA, tag2, source, MirTypes.GP_IMM_ANY 3)]
                 end
d3252 3
a3254 3
                           start_at + le_offset, funs_in_closure, fn_tag_list, tails,
                           tuple_bindings)
                (* This may be a tail, but only if we are in the tail line *)
d3262 309
a3570 8
                 case (tagged_code, def1) of
                   ([(AugLambda.CON_TAG t1, _, tag)], LambdaTypes.PRESENT _) =>
                     if t1 = 1 then (tag, tag1) else (tag1, tag)
               | ([(AugLambda.CON_TAG t1, _, tag1),
                   (AugLambda.CON_TAG t2, _, tag2)], LambdaTypes.ABSENT) =>
                 if t1 = 1 then (tag1, tag2) else (tag2, tag1)
                 | _ => Crash.impossible"Relational expression with bad CON_TAGs"
               else (tag1, tag1) (* Rubbish values *)
d3573 1
a3573 1
               Crash.impossible"make_cgt immediate"
d3575 1
a3575 1
                 Crash.impossible"make_cgt immediate"
d3577 1
a3577 1
                 Crash.impossible"make_cgt immediate"
d3581 1
a3581 1
                   val (tag1, end_blocks) = case def1 of
d3583 9
a3591 9
                       let
                         val tag1 = MirTypes.new_tag()
                       in
                         (tag1,
                          [MirTypes.BLOCK(tag1,
                                          [MirTypes.UNARY(MirTypes.MOVE,
                                                          MirTypes.GC_REG end_reg,
                                                          MirTypes.GP_IMM_ANY 1),
                                           final_branch])])
d3593 2
a3594 1
                   | _ => (tag1, [])
d3600 2
a3601 1
                           tag :: Mir_Utils.list_of(j-i-1, tag1) @@ expand rest
d3605 1
d3610 2
a3611 17
                 in
                   ((Sexpr.ATOM(if low = 0 then
                                  [MirTypes.SWITCH(MirTypes.CGT, reg_op, full_tag_list)]
                                else
                                  let
                                    val new_reg_op = MirTypes.GC.new()
                                  in
                                    [MirTypes.TEST(MirTypes.BLT, tag1, gp_operand,
                                                   MirTypes.GP_IMM_INT low),
                                     MirTypes.BINARY(MirTypes.SUB, MirTypes.GC_REG new_reg_op,
                                                     gp_operand, MirTypes.GP_IMM_INT low),
                                     MirTypes.SWITCH(MirTypes.CGT, MirTypes.GC_REG new_reg_op,
                                                     full_tag_list),
                                     MirTypes.COMMENT"Switch relative to lowest tag"]
                                  end),
                   Lists.reducer op @@
                   (end_blocks :: map
d3614 3
a3616 3
                     let
                       val end_code =
                         Mir_Utils.send_to_given_reg(regs, end_reg) @@ [final_branch]
d3620 5
d3626 6
a3631 7
                                            Mir_Utils.contract_sexpr
                                            (Sexpr.CONS(first, Sexpr.ATOM end_code)))]
                        | MirTypes.PRESENT tag1 =>
                            [MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr first),
                             MirTypes.BLOCK(tag1, Mir_Utils.contract_sexpr
                                            (Sexpr.CONS(last, Sexpr.ATOM end_code)))]
                            ) @@ blocks
d3633 38
a3670 2
                    val_code_tag_list, []),
                   MirTypes.ABSENT, Sexpr.NIL), values, procs)
d3677 1
a3677 1
                      else bounds(low, high, xs)
d3679 23
a3701 7
             fun do_chained_tests(_, def_tag, [], _) =
               ((Sexpr.ATOM[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG def_tag),
                            MirTypes.COMMENT"Default or end"], [], MirTypes.ABSENT,
                 Sexpr.NIL), [], [])
               | do_chained_tests(the_reg, def_tag,
                                  (scon, le, (regs, ((first, blocks, tag_opt, last), values, procs)),
                                   tag) :: rest, test_code) =
d3703 5
a3707 1
                   val the_test = test_code(the_reg, scon, le, tag)
d3709 3
a3711 1
                     Mir_Utils.send_to_given_reg(regs, end_reg) @@ [final_branch]
d3719 2
a3720 2
                                                     Sexpr.ATOM
                                                     end_code))) :: blocks,
d3732 3
a3734 3
                 in
                   Mir_Utils.combine((result, values, procs),
                                     do_chained_tests(the_reg, def_tag, rest, test_code))
d3737 1
a3737 13
             (* Deal with the tagged value list *)
             val (main_def, main_code) = case tag_le_list of
               [] =>
                 let
                   val def_code = case def1 of
                     LambdaTypes.ABSENT => []
                   | LambdaTypes.PRESENT _ =>
		[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag1)]
                 in
                   (def_code, no_code)
                 end
             | (AugLambda.CON_TAG _, _) :: rest =>
                 (* From a datatype value constructor match, use a computed goto *)
d3742 3
a3744 2
                      (fn (AugLambda.CON_TAG i, le, tag) => (i, le, tag)
                    | _ => Crash.impossible"Mixed tag type in switch")
d3746 6
a3751 3
                   val (i, (result_reg, code), first_tag) = case val_code_tags_list of
                     x :: _ => x
                   | _ => Crash.impossible"Empty datatype list"
d3753 5
a3757 1
                   val (the_reg, extra) = Mir_Utils.send_to_reg regs
d3759 19
a3777 21
                   if low = high then
                     (* Single element list, we should be able to do better here *)
                     let
                       val def_code = case def1 of
                         LambdaTypes.ABSENT => []
                       | LambdaTypes.PRESENT _ =>
                           [MirTypes.TEST(MirTypes.BNE, tag1, the_reg,
                                          MirTypes.GP_IMM_INT high)]
                       val end_code = Mir_Utils.send_to_given_reg(result_reg, end_reg) @@
                         [final_branch]
                       val main =
                         Mir_Utils.combine
                         (Mir_Utils.combine
                          (((Sexpr.ATOM[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG first_tag)],
                             [], MirTypes.PRESENT first_tag, Sexpr.NIL), [], []), code),
                          ((Sexpr.ATOM end_code, [], MirTypes.ABSENT, Sexpr.NIL),
                           [], []))
                         
                     in
                       (extra @@ def_code, main)
                     end
d3779 9
a3787 10
                     let
                       val def_code = case def1 of
                         LambdaTypes.ABSENT => []
                       | LambdaTypes.PRESENT _ =>
                           [MirTypes.TEST(MirTypes.BGT, tag1, the_reg,
                                          MirTypes.GP_IMM_INT high)]
                       val main as ((f, b, _, l), v, p) =
                         make_cgt(the_reg, low, high, val_code_tags_list)
                     in
                       (extra @@ def_code, main)
d3790 16
d3807 3
a3809 3
                 (* From a special constant match, use a computed goto
                  for ints in a suitably small range, and multiple tests and branches
                  for other int cases, and reals and strings. *)
d3828 1
d3830 1
a3830 1
                        val def_code = case def1 of
d3834 2
a3835 2
                            [MirTypes.COMMENT"Default",
                             MirTypes.TEST(MirTypes.BGT, tag1, the_reg,
d3839 1
a3839 1
                          (extra @@ def_code,
d3849 4
a3852 1
                             do_chained_tests(the_reg, tag1, val_le_tags_list, do_test))
d3864 1
a3864 1
                        | _ => Crash.impossible"struct gives single REAL"
d3898 1
a3898 1
                                           do_chained_tests(the_reg, tag1, val_le_tags_list, do_test)))
d3976 1
a3976 1
                                           do_chained_tests(the_reg, tag1, val_le_tags_list, do_test)))
d4014 1
a4014 1
                   ([], do_chained_tests(the_reg, tag1, val_le_tags_list, do_test))
d4094 18
a4111 13
      val result_code as ((f, b, _, l), v, p) =
        Mir_Utils.combine(
	  Mir_Utils.combine(
	    Mir_Utils.combine(the_code,
	      ((Sexpr.ATOM(ptr_code @@ main_def), [], MirTypes.ABSENT,
		Sexpr.NIL), [], [])),
		main_code),
	        ((Sexpr.NIL, blocks1 @@ blocks2, MirTypes.PRESENT end_tag,
		  Sexpr.NIL),
		  values1 @@ values2, procs1 @@ procs2))
           in
             (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG end_reg)), result_code)
           end)
d4719 1
@


1.184
log
@Removed dependence on environ in favour of environtypes
@
text
@d4 3
d1164 1
a1164 1
    val top_lambdas = NewMap.domain escape_map
d2945 2
a2946 2
	  (case NewMap.tryApply'(escape_map, lv) of
	     NewMap.YES ok => not ok
d3826 1
a3826 1
	   ((NewMap.fold add_member (NewMap.fold add_member (HashSet.empty_set(), closure_env), lambda_env),
d3961 1
a3961 1
	   ((NewMap.fold add_member (NewMap.fold add_member (HashSet.empty_set(), closure_env), lambda_env),
@


1.183
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
a666 1
require "../lambda/environ";
a691 1
  structure Environ : ENVIRON
a709 1
  sharing Environ.EnvironTypes = Primitives.EnvironTypes
d729 1
a729 1
  structure EnvironTypes = Environ.EnvironTypes
@


1.182
log
@Removed the curry module, it wasn't doing anything
@
text
@d4 3
d1180 1
a1180 6
    fun relation(i:int, i') =
      if i < i' then NewMap.LESS
      else
	if i = i' then NewMap.EQUAL
	else
	  NewMap.GREATER
d1186 1
a1186 1
       (NewMap.empty relation, top_tags_list))
d1228 1
a1228 8
    fun str_order(s, t) =
      if s = t then
	NewMap.EQUAL
      else
	if String.<(s, t) then
	  NewMap.LESS
	else
	  NewMap.GREATER
d1230 1
a1230 1
    val empty_str_order_tree = NewMap.from_list str_order
a1258 9
    fun lv_order x =
      if LambdaTypes.LVar_eq x then
	NewMap.EQUAL
      else
	if LambdaTypes.LVar_order x then
	  NewMap.LESS
	else
	  NewMap.GREATER

d1264 1
a1264 1
       (NewMap.empty lv_order, top_lambdas))
@


1.181
log
@Added flag to switch off warning messages in generating recipes
@
text
@d4 3
a665 1
require "../lambda/curry";
a691 1
  structure Curry : CURRY
d703 1
a703 1
    Curry.LambdaTypes = Mir_Utils.Mir_Env.LambdaTypes = Curry_Reduce.LambdaTypes
d1122 1
d1129 1
@


1.180
log
@Added switches for self call optimisation
@
text
@d4 3
d752 1
d1167 2
a1168 1
                                            mapping,name_of_setup_function))
@


1.179
log
@Removed some redundant structures and sharing
@
text
@d4 3
d748 1
a3087 186
    let
      (* Initial set up *)
(*
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating SWITCH\n",
	LambdaPrint.string_of_lambda arg])
*)
      val is_rel = case lexp of
	AugLambda.APP({lexp=AugLambda.BUILTIN(prim,_), ...}, _,_) =>
	  (case prim of
	    Pervasives.INTLESS => true
	  | Pervasives.REALLESS => true
	  | Pervasives.INTGREATER => true
	  | Pervasives.REALGREATER => true
	  | Pervasives.INTLESSEQ => true
	  | Pervasives.REALLESSEQ => true
	  | Pervasives.INTGREATEREQ => true
	  | Pervasives.REALGREATEREQ => true
	  | Pervasives.INTEQ => true
	  | Pervasives.INTNE => true
	  | Pervasives.REALEQ => true
	  | Pervasives.REALNE => true
	  | _ => false)
      | _ => false
      val positions = do_pos1(arg_size, tag_le_list)
      val list_size =
	Lists.reducel
	(fn (x:int, (_, {size=size, lexp=_})) =>
	 x + size)
	(0, tag_le_list)
      val tag_sizes =
	Lists.reducel
	(fn (x, (tag, _)) => x + count_gc_tags tag)
	(0, tag_le_list)
      val tag_positions = do_pos2(arg_size + list_size, tag_le_list)
      val def1_size = case def1 of
	LambdaTypes.ABSENT => 0
      | LambdaTypes.PRESENT{size=size, ...} => size
      val def2_size = case def2 of
	LambdaTypes.ABSENT => 0
      | LambdaTypes.PRESENT{size=size, ...} => size
      val (regs, the_code, test_code) =
	if is_rel then
	  let
	    val (primAndTy, arg, is_struct) = case lexp of
	      AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, ...},
			    {lexp=AugLambda.STRUCT le_list, ...},_) =>
		(primAndTy, le_list, true)
	    | AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, ...}, arg,_) =>
		(primAndTy, [arg], false)
	    | _ => Crash.impossible"Bad rel lexp"
	    val lv_le_list =
	      map
	      (fn le => (LambdaTypes.new_LVar(), le))
	      arg
	    val (code, env', static_offset', start_at') =
	      cg_bind_list(lv_le_list, env, closure, static_offset, start_at,
		      funs_in_closure, fn_tag_list)
	    val lvar = case lv_le_list of
	      (lvar, _) :: _ => lvar
	    | _ => Crash.impossible"Empty arg to relation"
	    val new_test =
	      AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, size=0},
			    {lexp=(if is_struct then
				AugLambda.STRUCT(map (fn (lvar, _) =>
						      {lexp=AugLambda.VAR lvar,
						       size=0}) lv_le_list)
			      else
				AugLambda.VAR lvar), size=0},
                            MirTypes.Debugger_Types.null_backend_annotation)
	    val (rest_regs, rest_code) =
	      cg_sub(new_test, env', closure, static_offset', start_at',
		     funs_in_closure, fn_tag_list, false, [])
	  in
	    (rest_regs, code, rest_code)
	  end
	else
	  let
	    val (regs, the_code) =
	      cg_sub(lexp, env, closure, static_offset, start_at,
		     funs_in_closure, fn_tag_list, false, [])
	  in
	    (regs, the_code, no_code)
	  end
      val end_tag = MirTypes.new_tag()
      (* For the end of switch *)
      val final_branch = MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG end_tag)
      val end_reg = MirTypes.GC.new()
      (* For the result *)

      fun get_blocks_for_defs(def, static_offset, start_at, comment) =
	case def of
	LambdaTypes.ABSENT => ([], end_tag, [], [])
      | LambdaTypes.PRESENT{lexp=lexp, size=_} =>
	let
	  val (regs, the_code) =
	    cg_sub(lexp, env, closure, static_offset, start_at,
		   funs_in_closure, fn_tag_list, tails, tuple_bindings)
	  (* This may be a tail, but only if we are in  the tail line *)
	  val the_code = Mir_Utils.combine(the_code,
	    ((Sexpr.ATOM(MirTypes.COMMENT comment :: (case regs of
	      Mir_Utils.ONE(Mir_Utils.INT reg) =>
		[MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG end_reg, reg)]
	    | Mir_Utils.ONE(Mir_Utils.REAL reg) =>
		Mir_Utils.save_real_to_reg(reg, MirTypes.GC_REG end_reg)
	    | Mir_Utils.LIST many =>
	      (#2 (Mir_Utils.tuple_up_in_reg(many, end_reg)))) @@
	      [final_branch]),
	      [], MirTypes.ABSENT, Sexpr.NIL), [], []))
	  val new_tag =  MirTypes.new_tag()
	in
	  case the_code of
	    ((first, blocks, MirTypes.ABSENT, last), values, procs) =>
	      (MirTypes.BLOCK(new_tag, Mir_Utils.contract_sexpr first) ::
	       blocks, new_tag, values, procs)
	  | ((first, blocks, MirTypes.PRESENT tag, last), values, procs) =>
	      (MirTypes.BLOCK(new_tag, Mir_Utils.contract_sexpr first) ::
	        MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr last) :: blocks,
	          new_tag, values, procs)

	end

      (* Deal with the two possible default cases *)
      val (blocks1, tag1, values1, procs1) =
	get_blocks_for_defs(def1,
			    static_offset + arg_size + list_size + tag_sizes,
			    start_at + arg_size + list_size + tag_sizes,
			    "simple default")
      val (blocks2, tag2, values2, procs2) =
	get_blocks_for_defs(def2,
			    static_offset + arg_size + list_size + tag_sizes +
			    def1_size,
			    start_at + arg_size + list_size + tag_sizes +
			    def1_size, "Value carrying default for datatypes")

      (* Generate code for spotting the vcc default case *)
      val ptr_code = case def2 of
	LambdaTypes.ABSENT => [MirTypes.COMMENT"No vcc default"]
      | LambdaTypes.PRESENT _ =>
	let
	  val (source, code) = case regs of
	    Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)) => (reg, [])
	  | Mir_Utils.ONE _ =>
	    Crash.impossible"Vcc default for non-structured value"
	  | Mir_Utils.LIST many =>
	    let
	      val (gc_reg, code) = Mir_Utils.tuple_up many
	    in
	      (MirTypes.GP_GC_REG gc_reg, code)
	    end
	in
	  MirTypes.COMMENT"Vcc default" :: code @@
	  [MirTypes.TEST(MirTypes.BTA, tag2, source, MirTypes.GP_IMM_ANY 3)]
	end
      val tagged_code =	map
	(fn ((t, {lexp=x, ...}), le_offset) =>
	  let
	    val (reg, code) =
	      cg_sub(x, env, closure, static_offset + le_offset,
		     start_at + le_offset, funs_in_closure, fn_tag_list, tails,
		     tuple_bindings)
	  (* This may be a tail, but only if we are in the tail line *)
	  in
	    (t, (reg, code), MirTypes.new_tag())
	  end)
	(Lists.zip(tag_le_list, positions))

      val (true_tag, false_tag) =
	if is_rel then
	  case (tagged_code, def1) of
	    ([(AugLambda.CON_TAG t1, _, tag)], LambdaTypes.PRESENT _) =>
	      if t1 = 1 then (tag, tag1) else (tag1, tag)
	  | ([(AugLambda.CON_TAG t1, _, tag1),
	      (AugLambda.CON_TAG t2, _, tag2)], LambdaTypes.ABSENT) =>
	    if t1 = 1 then (tag1, tag2) else (tag2, tag1)
	  | _ => Crash.impossible"Relational expression with bad CON_TAGs"
	else (tag1, tag1) (* Rubbish values *)
      (* Handle the case of using computed gotos *)
      fun make_cgt(MirTypes.GP_IMM_INT _, _, _, _) =
	Crash.impossible"make_cgt immediate"
      | make_cgt(MirTypes.GP_IMM_ANY _, _, _, _) =
	Crash.impossible"make_cgt immediate"
      | make_cgt(MirTypes.GP_IMM_SYMB _, _, _, _) =
	Crash.impossible"make_cgt immediate"
      | make_cgt(gp_operand, low, high, val_code_tag_list) =
d3089 10
a3098 27
	val reg_op = Mir_Utils.reg_from_gp gp_operand
	val (tag1, end_blocks) = case def1 of
	  LambdaTypes.ABSENT =>
	    let
	      val tag1 = MirTypes.new_tag()
	    in
	      (tag1,
	       [MirTypes.BLOCK(tag1,
			       [MirTypes.UNARY(MirTypes.MOVE,
					       MirTypes.GC_REG end_reg,
					       MirTypes.GP_IMM_ANY 1),
				final_branch])])
	    end
	| _ => (tag1, [])
	val full_tag_list =
	  let
	    fun expand [] = []
	    | expand ([(_, _, tag)]) = [tag]
	    | expand ((i, _, tag) :: (rest as ((j, _, _) :: _))) =
		tag :: Mir_Utils.list_of(j-i-1, tag1) @@ expand rest
	  in
	    expand val_code_tag_list
	  end
	val values =
	  Lists.reducer op @@ (map (#2 o #2 o #2) val_code_tag_list, [])
	val procs =
	  Lists.reducer op @@ (map (#3 o #2 o #2) val_code_tag_list, [])
d3100 17
a3116 36
	((Sexpr.ATOM(if low = 0 then
	  [MirTypes.SWITCH(MirTypes.CGT, reg_op, full_tag_list)]
	  else
	    let
	      val new_reg_op = MirTypes.GC.new()
	    in
	      [MirTypes.TEST(MirTypes.BLT, tag1, gp_operand,
			     MirTypes.GP_IMM_INT low),
	       MirTypes.BINARY(MirTypes.SUB, MirTypes.GC_REG new_reg_op,
			       gp_operand, MirTypes.GP_IMM_INT low),
	        MirTypes.SWITCH(MirTypes.CGT, MirTypes.GC_REG new_reg_op,
				full_tag_list),
		MirTypes.COMMENT"Switch relative to lowest tag"]
	    end),
	  Lists.reducer op @@
	  (end_blocks :: map
	   (fn (_, (regs, ((first, blocks, tag_opt, last), _, _)),
	       tag) =>
	    let
	      val end_code =
		Mir_Utils.send_to_given_reg(regs, end_reg) @@ [final_branch]
	    in
	      (case tag_opt of
		MirTypes.ABSENT =>
		  [MirTypes.BLOCK(tag,
				  Mir_Utils.contract_sexpr
				  (Sexpr.CONS(first, Sexpr.ATOM end_code)))]
	      | MirTypes.PRESENT tag1 =>
		[MirTypes.BLOCK(tag, Mir_Utils.contract_sexpr first),
		  MirTypes.BLOCK(tag1, Mir_Utils.contract_sexpr
				 (Sexpr.CONS(last, Sexpr.ATOM end_code)))]
		 ) @@ blocks
	    end)
	  val_code_tag_list, []),
	  MirTypes.ABSENT, Sexpr.NIL), values, procs)
      end
d3118 296
a3413 49
      fun bounds(low:int, high, []) = (low, high)
      | bounds(low, high, i :: xs) =
	if (i < low) then bounds(i, high, xs)
	else if (i > high) then bounds(low, i, xs)
	     else bounds(low, high, xs)

      fun do_chained_tests(_, def_tag, [], _) =
	((Sexpr.ATOM[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG def_tag),
		     MirTypes.COMMENT"Default or end"], [], MirTypes.ABSENT,
	  Sexpr.NIL), [], [])
      | do_chained_tests(the_reg, def_tag,
	  (scon, le, (regs, ((first, blocks, tag_opt, last), values, procs)),
	   tag) :: rest, test_code) =
	let
	  val the_test = test_code(the_reg, scon, le, tag)
	  val end_code =
	    Mir_Utils.send_to_given_reg(regs, end_reg) @@ [final_branch]
	  val result =
	    case tag_opt of
	      MirTypes.ABSENT =>
		(the_test,
		 MirTypes.BLOCK(tag,
				Mir_Utils.contract_sexpr
				(Sexpr.CONS(first,
					    Sexpr.ATOM
					    end_code))) :: blocks,
		 MirTypes.ABSENT, Sexpr.NIL)
	    | MirTypes.PRESENT tag'=>
		(the_test,
		 MirTypes.BLOCK(tag,
				Mir_Utils.contract_sexpr first) :: blocks @@
		 [MirTypes.BLOCK(tag', Mir_Utils.contract_sexpr
				 (Sexpr.CONS(last,
					     Sexpr.ATOM
					     end_code)))],
				 MirTypes.ABSENT,
		 Sexpr.NIL)
	in
	  Mir_Utils.combine((result, values, procs),
		  do_chained_tests(the_reg, def_tag, rest, test_code))
	end

      (* Deal with the tagged value list *)
      val (main_def, main_code) = case tag_le_list of
	[] =>
	  let
	    val def_code = case def1 of
	      LambdaTypes.ABSENT => []
	    | LambdaTypes.PRESENT _ =>
d3415 107
a3521 107
	  in
	    (def_code, no_code)
	  end
      | (AugLambda.CON_TAG _, _) :: rest =>
      (* From a datatype value constructor match, use a computed goto *)
	let
	  val val_code_tags_list =
	    Lists.qsort (fn ((i:int, _, _), (i', _, _)) => i < i')
	    (map
	    (fn (AugLambda.CON_TAG i, le, tag) => (i, le, tag)
	    | _ => Crash.impossible"Mixed tag type in switch")
	    tagged_code)
	  val (i, (result_reg, code), first_tag) = case val_code_tags_list of
	    x :: _ => x
	  | _ => Crash.impossible"Empty datatype list"
	  val (low, high) = bounds(i, i, map #1 val_code_tags_list)
	  val (the_reg, extra) = Mir_Utils.send_to_reg regs
	in
	  if low = high then
	    (* Single element list, we should be able to do better here *)
	    let
	      val def_code = case def1 of
		LambdaTypes.ABSENT => []
	      | LambdaTypes.PRESENT _ =>
		  [MirTypes.TEST(MirTypes.BNE, tag1, the_reg,
				 MirTypes.GP_IMM_INT high)]
	      val end_code = Mir_Utils.send_to_given_reg(result_reg, end_reg) @@
		[final_branch]
	      val main =
		Mir_Utils.combine
		(Mir_Utils.combine
		 (((Sexpr.ATOM[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG first_tag)],
		    [], MirTypes.PRESENT first_tag, Sexpr.NIL), [], []), code),
		 ((Sexpr.ATOM end_code, [], MirTypes.ABSENT, Sexpr.NIL),
		  [], []))
		 
	    in
	      (extra @@ def_code, main)
	    end
	  else
	    let
	      val def_code = case def1 of
		LambdaTypes.ABSENT => []
	      | LambdaTypes.PRESENT _ =>
		  [MirTypes.TEST(MirTypes.BGT, tag1, the_reg,
				 MirTypes.GP_IMM_INT high)]
	      val main as ((f, b, _, l), v, p) =
		make_cgt(the_reg, low, high, val_code_tags_list)
	    in
	      (extra @@ def_code, main)
	    end
	end
      | (AugLambda.SCON_TAG x, _) :: rest =>
      (* From a special constant match, use a computed goto
       for ints in a suitably small range, and multiple tests and branches
       for other int cases, and reals and strings. *)
	(case x of
	  Ident.INT _ =>
	  let
	    val val_le_tags_list =
	      Lists.qsort (fn ((i:int, _, _, _), (i', _, _, _)) =>
				 i < i')
	      (map (fn (AugLambda.SCON_TAG(Ident.INT i), code, tag) =>
		    (Mir_Utils.convert_int i, 0, code, tag)
	      | _ => Crash.impossible"Mixed tag type in switch")
	        tagged_code)
	    (* Patch for Jont *)
	    val a_value = case val_le_tags_list of
	      {1=i, ...} :: _ => i
	    | _ => Crash.impossible"empty val_le_tags_list"
	    val (low, high) = bounds(a_value, a_value, map #1 val_le_tags_list)
	    val len = Lists.length val_le_tags_list
	    val use_cgt = high+1-low <= 2*len andalso len > 2
	    (* Not too many holes, but a bigger than two list *)
	    val (the_reg, extra) = Mir_Utils.send_to_reg(regs)
	    val def_code = case def1 of
	      LambdaTypes.ABSENT =>
		[MirTypes.COMMENT"No default (strange for scon match)"]
	    | LambdaTypes.PRESENT _ =>
		[MirTypes.COMMENT"Default",
		  MirTypes.TEST(MirTypes.BGT, tag1, the_reg,
				MirTypes.GP_IMM_INT high)]
	  in
	    if use_cgt then
	      (extra @@ def_code,
	        make_cgt(the_reg, low, high,
			 map (fn x => (#1 x, #3 x, #4 x)) val_le_tags_list))
	    else
	      let
		fun do_test(reg, i, _, tag) =
		  Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag, reg,
					   MirTypes.GP_IMM_INT i)]
	      in
		(extra,
		 do_chained_tests(the_reg, tag1, val_le_tags_list, do_test))
	      end
	  end
	| Ident.REAL _ =>
	  let
	    val val_le_tags_list =
	      map (fn ((AugLambda.SCON_TAG(Ident.REAL _), code, tag), p) =>
		   (p, 0, code, tag)
	      | _ => Crash.impossible"Mixed tag type in switch")
	      (Lists.zip(tagged_code, tag_positions))
	    val (the_reg, extra) = case regs of
	      Mir_Utils.ONE reg => Mir_Utils.get_real reg
	    | _ => Crash.impossible"struct gives single REAL"
d3523 119
a3641 118
	    fun do_test(reg, i, _, tag) =
	      (* reg is the value input,
	       i is the immediate constant (in the case of an int)
	       or the position in the closure for this function,
	       relative to static_offset + funs_in_closure
	       in the case of a real or string
	       tag is where to go to on successful comparison *)
	    let
	      val fp_op = MirTypes.FP_REG(MirTypes.FP.new())
	    in
	      Sexpr.ATOM[MirTypes.STOREFPOP(MirTypes.FLD, fp_op,
		MirTypes.GC_REG callee_closure,
		MirTypes.GP_IMM_ANY(4*(static_offset + i +
				       (funs_in_closure * 2 - 1)) +
				    real_offset)),
	        MirTypes.FTEST(MirTypes.FBEQ, tag, fp_op, reg)]
	    end
	    val tags_code =
	      map
	      (fn (p, (t, _)) =>
	        case t of
		  AugLambda.SCON_TAG(scon as Ident.REAL _) =>
		    MirTypes.VALUE(
				   top_closure (start_at + p + 1)
				   , scon)
		| _ => Crash.impossible"non-REAL in REAL switch"
		    )
	      (Lists.zip(tag_positions, tag_le_list))
	  in
	    (extra,
	      Mir_Utils.combine(((Sexpr.NIL, [], MirTypes.ABSENT, Sexpr.NIL), tags_code, []),
		do_chained_tests(the_reg, tag1, val_le_tags_list, do_test)))
	  end
	| Ident.STRING _ =>
	  let
	    val val_le_tags_list =
	      map
	      (fn ((AugLambda.SCON_TAG(Ident.STRING _), code, tag), p) =>
	        (p, 0, code, tag)
	      | _ => Crash.impossible"Mixed tag type in switch")
	      (Lists.zip(tagged_code, tag_positions))
	    val the_reg = case regs of
	      Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_GC_REG _)) => arg
	    | _ => Crash.impossible"struct gives single STRING"

	    fun do_test(reg, i, _, tag) =
	      (* reg is the value input,
	       i is the immediate constant (in the case of an int)
	       or the position in the closure for this function,
	       relative to static_offset + funs_in_closure
	       in the case of a real or string
	       tag is where to go to on successful comparison *)
	    let
	      val scon_reg = MirTypes.GC_REG(MirTypes.GC.new())
	      val (regs', the_code') =
		cg_sub(AugLambda.VAR(NewMap.apply'(prim_to_lambda, Pervasives.STRINGEQ)),
		       env, closure, static_offset, start_at,
		       funs_in_closure, [], false, [])
	      val app_code = case
		Mir_Utils.do_app(MirTypes.Debugger_Types.null_backend_annotation,
                                 regs', the_code',
		       Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG caller_arg)),
		       no_code, false,
		       Lists.hd fn_tag_list, 0, 0, [], false, true)
		of
		  (_, ((app_code, [], MirTypes.ABSENT, last), [], [])) =>
		    if Mir_Utils.contract_sexpr last = [] then
		      app_code
		    else
		      Crash.impossible"Bad result for STRINGEQ"
	      | _ => Crash.impossible"Bad result for STRINGEQ"
	    in
	      Sexpr.CONS(
	      Sexpr.ATOM[MirTypes.STOREOP(MirTypes.LD, scon_reg,
				MirTypes.GC_REG callee_closure,
		MirTypes.GP_IMM_ANY(4*(static_offset + i +
				       (2*funs_in_closure-1)) - 1)),
	        MirTypes.ALLOCATE_STACK(MirTypes.ALLOC,
					MirTypes.GC_REG caller_arg,
					2,
					MirTypes.ABSENT),
		MirTypes.STOREOP(MirTypes.ST, Mir_Utils.reg_from_gp the_reg,
				 MirTypes.GC_REG caller_arg,
				 MirTypes.GP_IMM_ANY ~1),
		MirTypes.STOREOP(MirTypes.ST, scon_reg,
				 MirTypes.GC_REG caller_arg,
				 MirTypes.GP_IMM_ANY 3),
		MirTypes.COMMENT"Call external STRINGEQ"],
	      Sexpr.CONS
	      (app_code,
	      Sexpr.ATOM[MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, 2),
	       MirTypes.TEST(MirTypes.BEQ, tag,
			     MirTypes.GP_GC_REG caller_arg,
			     MirTypes.GP_IMM_INT 1)]))
	    end
	    val tags_code =
	      map
	      (fn (p, (t, _)) =>
	       case t of
		 AugLambda.SCON_TAG(scon as Ident.STRING _) =>
		   MirTypes.VALUE(
				  top_closure(start_at + p + 1)
				  , scon)
	       | _ =>
		   Crash.impossible"non-STRING in STRING switch")
	      (Lists.zip(tag_positions, tag_le_list))
	  in
	    ([],
	      Mir_Utils.combine(((Sexpr.NIL, [], MirTypes.ABSENT, Sexpr.NIL), tags_code, []),
	        do_chained_tests(the_reg, tag1, val_le_tags_list, do_test)))
	  end)

      | (AugLambda.EXP_TAG _, _) :: rest =>
      (* From an exception constructor match, use tests and branches *)
	let
	  val val_le_tags_list =
	    map
	    (fn (AugLambda.EXP_TAG{lexp=le, ...}, code, tag) =>
d3643 38
a3680 38
	    | _ => Crash.impossible"Mixed tag type in switch")
	    tagged_code
	  val the_reg = case regs of
	    Mir_Utils.ONE(Mir_Utils.INT(arg as MirTypes.GP_GC_REG _)) => arg
	  | _ => Crash.impossible"Bad reg for exception"

	  fun do_test(reg, _, le, tag) =
	    (* reg is the value input,
	     le is the exception expression to match
	     tag is where to go to on successful comparison *)
	  let
	    val (regs, the_code) =
	      case cg_sub(le, env, closure, static_offset, start_at,
			  funs_in_closure, [], false, []) of
		(Mir_Utils.ONE(Mir_Utils.INT(reg as MirTypes.GP_GC_REG _)),
		  ((code, [], MirTypes.ABSENT, last), [], [])) =>
		if Mir_Utils.contract_sexpr last = [] then
		  (reg, code)
		else
		  Crash.impossible"Bad result from cg(exception)"
	      | _ =>
		Crash.impossible"Bad result from cg(exception)"
	  (* Get the value to test against *)
	  in
	    Sexpr.CONS(the_code,
		       Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, tag, reg, regs)])
	  end
	in
	  ([], do_chained_tests(the_reg, tag1, val_le_tags_list, do_test))
	end
      val the_code =
	if is_rel then
	  (* Attempt to apply branch destination substitution *)
	  let
	    val ((first, blocks, tag_opt, last), values, procs) = test_code
	    val _ = case blocks of
	      [] => ()
	    | _ => Crash.impossible"Test code for relation has blocks"
d3691 1
a3691 1
		  (* Remove the setup true/false in register *)
d3700 1
a3700 1
		      | MirTypes.PRESENT tag => MirTypes.print_tag tag) ::
d3707 1
a3707 1

d3718 1
a3718 1
		  (* Remove the setup true/false in register *)
d3761 5
a3765 3
    in
      (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG end_reg)), result_code)
    end
@


1.178
log
@Corrected bug in known escaping functions
@
text
@d4 3
d694 5
a698 4
  sharing LambdaSub.LT = Primitives.LambdaTypes =
    LambdaPrint.LambdaTypes = Library.LambdaTypes = InterProc.LambdaTypes =
    Curry.LambdaTypes = Mir_Utils.LambdaTypes = Curry_Reduce.LambdaTypes
  sharing Type_Utils.DataTypes = LambdaSub.LT.Datatypes = Types.Datatypes
d700 1
a700 4
  sharing MirRegisters.MirTypes = MirPrint.MirTypes = Mir_Utils.MirTypes
  sharing LambdaSub.LT.Ident = Environ.Ident = LambdaSub.LT.Datatypes.Ident
  sharing LambdaSub.Set = Primitives.Set = Library.Set
  sharing LambdaSub.LT.Datatypes.NewMap = Library.NewMap
d702 1
a702 1
  sharing Mir_Utils.MirTypes.Debugger_Types = Library.AugLambda.Debugger_Types
d707 2
a708 1
  structure Set = LambdaSub.Set
d712 3
a714 2
  structure MirTypes = Mir_Utils.MirTypes
  structure Ident = MirTypes.Ident
d716 2
a717 3
  structure Map = LambdaSub.LT.Datatypes.Mapping
  structure LambdaTypes = LambdaSub.LT
  structure NewMap = LambdaTypes.Datatypes.NewMap
a719 1
  structure MirTypes = MirTypes
@


1.177
log
@Added unsafe update and bytearray primitives.
@
text
@d4 3
d2948 1
a2948 1
	     NewMap.YES ok => ok
@


1.176
log
@Ensured not all primitives are regarded as escaping
@
text
@d4 3
d1771 159
a1929 1
      fun sub_code safe =
d1996 16
a2011 6
                                 [MirTypes.COMMENT "Array subscript operation",
                                  MirTypes.BINARY(MirTypes.ADD,
                                                  MirTypes.GC_REG MirRegisters.global,new_reg', new_reg),
                                  MirTypes.STOREOP(MirTypes.LDREF, res1,
                                                   MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9),
                                  MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]) ::
d2019 14
a2032 5
                           [MirTypes.COMMENT "Unsafe array subscript operation",
                            MirTypes.BINARY(MirTypes.ADD,
                                            MirTypes.GC_REG MirRegisters.global, new_reg', new_reg),
                            MirTypes.STOREOP(MirTypes.LDREF, res1,
                                             MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9)]),
d2036 1
a2036 1
      fun update_code safe =
a2073 1

d2126 32
a2157 15
                             [MirTypes.COMMENT ((if safe then "A" else "Unsafe a") ^ "rray update operation"),
                              MirTypes.BINARY(MirTypes.ADD,
                                              MirTypes.GC_REG MirRegisters.global,new_reg',new_reg),
                              MirTypes.STOREOP(MirTypes.STREF,Mir_Utils.reg_from_gp new_reg'',
                                               MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9)] @@
                             (if isIntegral then
                                [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]
                              else
                                [MirTypes.COMMENT"Do we need to unlink it",
                                 MirTypes.STOREOP(MirTypes.LDREF, forward_reg,
                                                  Mir_Utils.reg_from_gp reg1,
                                                  MirTypes.GP_IMM_ANY 1),
                                 MirTypes.TEST(MirTypes.BEQ, finish_tag, MirTypes.GP_GC_REG forward,
                                               MirTypes.GP_IMM_INT 0),
                                 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG unlink_tag)])) ::
d2442 2
d2480 2
d2831 13
a2843 129
      | Pervasives.ARRAY_FN =>
	  let
            val (constantp,constant_value) =
              (case regs of
                 Mir_Utils.LIST[ Mir_Utils.INT(size), initial ] => 
                   (case size of
                      MirTypes.GP_IMM_INT v => (true,v )
                    | _ => (false,0))
               | _ => (false,0))

	    val ((new_reg, code),(new_reg', code')) =
              case regs of
                Mir_Utils.LIST[ Mir_Utils.INT(size), initial ] => 
                  (Mir_Utils.send_to_new_reg(Mir_Utils.ONE(initial)),
                   Mir_Utils.send_to_new_reg(Mir_Utils.ONE(Mir_Utils.INT size)))
              | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                  (let
                    val new_reg = MirTypes.GC.new()
                    val new_reg' = MirTypes.GC.new()
                  in
                    ((MirTypes.GP_GC_REG new_reg,[MirTypes.STOREOP(MirTypes.LD,
                                      MirTypes.GC_REG new_reg,
                                      Mir_Utils.reg_from_gp reg,
                                      MirTypes.GP_IMM_ANY 3)]),
                    (MirTypes.GP_GC_REG new_reg',[MirTypes.STOREOP(MirTypes.LD,
                                                MirTypes.GC_REG new_reg',
                                                Mir_Utils.reg_from_gp reg,
                                                MirTypes.GP_IMM_ANY ~1)]))
                    end)
              | _ => Crash.impossible "_mir_cg : array_fn can't code generate arguments "
	
	    val result = MirTypes.GC.new()
	    val res1 = MirTypes.GC_REG result
	    val work1 = MirTypes.GC_REG(MirTypes.GC.new())
	    val work2 = MirTypes.GC_REG(MirTypes.GC.new())
	    val count =  MirTypes.GC.new()
	    val main_tag = MirTypes.new_tag()
	    val loop_tag = MirTypes.new_tag()
	    val finish_tag = MirTypes.new_tag()
            val exn_tag = MirTypes.new_tag()
            val exn_blocks = exn_code_for_prim(prim, exn_tag)
            val after_alignment = MirTypes.new_tag()
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
             Mir_Utils.combine(the_code,
                     ((Sexpr.ATOM(code @@ code' @@
                       (if constantp then
                            (if constant_value >= 0
                            then
                               [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG main_tag)]
                             else
                               [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)])
                        else
                       [MirTypes.TEST(MirTypes.BGE, main_tag, new_reg', MirTypes.GP_IMM_INT 0),
                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)])),
                          MirTypes.BLOCK(main_tag,
                                         (if constantp
                                            then 
                                              [MirTypes.UNARY(MirTypes.MOVE,
                                                              Mir_Utils.reg_from_gp new_reg',
                                                              MirTypes.GP_IMM_INT constant_value)]
                                          else
                                            []) @@
                                            [MirTypes.COMMENT"Array creation operation",
                                             MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, 
                                                               (if constantp
                                                                  then MirTypes.GP_IMM_INT constant_value
                                                                else new_reg'))] @@
                                            [MirTypes.COMMENT"Initialise all of the values"] @@
                                      (if constantp
                                         then 
                                           [MirTypes.UNARY(MirTypes.MOVE, 
                                                           MirTypes.GC_REG count,
                                                           MirTypes.GP_IMM_INT constant_value)]
                                       else
                                         [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG count,new_reg')]) @@
                                         [MirTypes.UNARY(MirTypes.MOVE,
                                                          MirTypes.GC_REG MirRegisters.global,
                                                          MirTypes.GP_GC_REG result),
                                          MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)]) ::
                       MirTypes.BLOCK(loop_tag,
                                      [MirTypes.STOREOP(MirTypes.STREF, Mir_Utils.reg_from_gp new_reg,
                                                        MirTypes.GC_REG MirRegisters.global,
							MirTypes.GP_IMM_ANY 9),
                                                        MirTypes.BINARY(MirTypes.ADD, 
                                                       MirTypes.GC_REG MirRegisters.global,
                                                       MirTypes.GP_GC_REG MirRegisters.global,
                                                       MirTypes.GP_IMM_ANY 4)] @@
                                      [MirTypes.BINARY(MirTypes.ADD, 
                                                       MirTypes.GC_REG count,
                                                       MirTypes.GP_GC_REG count,
                                                       MirTypes.GP_IMM_ANY ~4)] @@
                                      [MirTypes.TEST(MirTypes.BGT, loop_tag, MirTypes.GP_GC_REG count, 
                                                     MirTypes.GP_IMM_ANY 0),
                                       MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]) ::
                       exn_blocks,
                       MirTypes.PRESENT finish_tag, 
                       Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE, work1, MirTypes.GP_IMM_ANY 0),
                        MirTypes.STOREOP(MirTypes.STREF, work1, res1, MirTypes.GP_IMM_ANY 5),
                        MirTypes.UNARY(MirTypes.MOVE, work2, MirTypes.GP_IMM_INT 1),
                        MirTypes.STOREOP(MirTypes.STREF, work2, res1, MirTypes.GP_IMM_ANY 1)]), [], [])))
	  end

      | Pervasives.LENGTH =>
	  (case regs of
	    Mir_Utils.ONE(array) =>
	  let
	    val (new_reg, code) = Mir_Utils.send_to_reg(Mir_Utils.ONE array)
	    val result = MirTypes.GC.new()
	    val res1 = MirTypes.GC_REG result
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
	      Mir_Utils.combine(the_code,
		      ((Sexpr.ATOM(code @@
			[MirTypes.COMMENT"Array length operation",
			 MirTypes.STOREOP(MirTypes.LDREF,res1,Mir_Utils.reg_from_gp new_reg, MirTypes.GP_IMM_ANY ~3),
                         MirTypes.BINARY(MirTypes.LSR,res1,
                                         MirTypes.GP_GC_REG result,MirTypes.GP_IMM_ANY 4),
                         MirTypes.BINARY(MirTypes.BIC,res1,
                                         MirTypes.GP_GC_REG result,MirTypes.GP_IMM_ANY 3)]),
			[], MirTypes.ABSENT, Sexpr.NIL), [], [])))
	  end
	  | _ =>
	      Crash.impossible "Array.length called with only one argument")

      | Pervasives.SUB => sub_code true
      | Pervasives.UPDATE => update_code true
      | Pervasives.UNSAFE_SUB => sub_code false
      | Pervasives.UNSAFE_UPDATE => update_code false
@


1.175
log
@Mir_Env now uses NewMap instead of Map.
@
text
@d4 3
d693 1
a693 1
  sharing LambdaSub.LT.Datatypes.NewMap = Library.NewMap = InterProc.NewMap
d708 2
a709 1
  structure NewMap = InterProc.NewMap
a710 1
  structure LambdaTypes = LambdaSub.LT
d778 9
a786 8
    (trees, NewMap.apply'(var_tree, string))
    handle NewMap.Undefined =>
      let
	val lv = LambdaTypes.new_LVar()
      in
	((NewMap.define(var_tree, string, lv), exn_tree, str_tree, fun_tree),
	 lv)
      end
d789 9
a797 8
    (trees, NewMap.apply'(exn_tree, string))
    handle NewMap.Undefined =>
      let
	val lv = LambdaTypes.new_LVar()
      in
	((var_tree, NewMap.define(exn_tree, string, lv), str_tree, fun_tree),
	 lv)
      end
d800 9
a808 8
    (trees, NewMap.apply'(str_tree, string))
    handle NewMap.Undefined =>
      let
	val lv = LambdaTypes.new_LVar()
      in
	((var_tree, exn_tree, NewMap.define(str_tree, string, lv), fun_tree),
	 lv)
      end
d811 9
a819 8
    (trees, NewMap.apply'(fun_tree, string))
    handle NewMap.Undefined =>
      let
	val lv = LambdaTypes.new_LVar()
      in
	((var_tree, exn_tree, str_tree, NewMap.define(fun_tree, string, lv)),
	 lv)
      end
d1096 10
d1239 1
a1239 2
      (applied_ext_string_tree chars) handle
      NewMap.Undefined => Crash.impossible"string missing"
d1241 1
a1241 2
      (applied_ext_var_tree chars) handle
      NewMap.Undefined => Crash.impossible"string missing"
d1243 1
a1243 2
      (applied_ext_exn_tree chars) handle
      NewMap.Undefined => Crash.impossible"string missing"
d1245 1
a1245 2
      (applied_ext_str_tree chars) handle
      NewMap.Undefined => Crash.impossible"string missing"
d1247 1
a1247 2
      (applied_ext_fun_tree chars) handle
      NewMap.Undefined => Crash.impossible"string missing"
d1260 4
a1263 2
      (NewMap.from_list lv_order
       (map (fn lv => (lv, MirTypes.new_tag())) top_lambdas))
d2860 3
a2862 1
	  (not(NewMap.apply'(escape_map, lv)) handle NewMap.Undefined => false)
d2879 1
d2883 1
d3997 2
a3998 1
		 (top_lambda_loop_tags lvar
d4002 2
a4003 1
				     " has no loop entry tag"))
@


1.174
log
@Added code to do UNSAFE_UPDATE and UNSAFE_SUB.
@
text
@d4 3
d684 1
a684 1
    (*Tail.LambdaTypes =*) Curry.LambdaTypes = Mir_Utils.LambdaTypes = Curry_Reduce.LambdaTypes
d688 1
a688 2
  sharing LambdaSub.LT.Ident = Environ.Ident =
    LambdaSub.LT.Datatypes.Ident
d690 1
a690 1
  sharing Mir_Utils.Mir_Env.Map = Library.Map = (*Type_Utils.Map = *)LambdaSub.LT.Datatypes.Mapping
d704 1
a704 1
  structure Map = Library.Map
d1429 2
a1430 7
                  AugLambda.VAR(Map.lookup(exception_needed, prim_to_lambda))
                  handle Map.Lookup =>
                    Crash.impossible
                    ("Couldn't find a lambda variable for the exception " ^
                     Pervasives.print_pervasive exception_needed ^ " which was " ^
                     "raised by " ^ Pervasives.print_pervasive prim)
                    
d1902 1
a1902 2
                ((Type_Utils.is_integral (Map.lookup(Ident.LAB(Symbol.find_symbol "3"), map)))
                 handle Map.Lookup => Crash.impossible"UPDATE argument has wrong record type")
d2118 1
a2118 2
		  ((Type_Utils.is_integral (Map.lookup(Ident.LAB(Symbol.find_symbol "2"), map)))
		   handle Map.Lookup => Crash.impossible"BECOMES argument has wrong record type")
a2120 3
(*
	    if isIntegral then output(std_out, "\nDid BECOMES optimisation") else ();
*)
d2462 1
a2462 5
            AugLambda.VAR(Map.lookup(primitive, prim_to_lambda))
            handle Map.Lookup =>
              Crash.impossible
              ("Mir_Cg: Couldn't find a lambda variable for the polymorphic" ^
               " equality function.")
d3443 1
a3443 2
		cg_sub(AugLambda.VAR(Map.lookup(Pervasives.STRINGEQ,
						  prim_to_lambda)),
a3687 6
(*
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating FN\n",
		  LambdaPrint.string_of_lambda fcn])
*)
d3692 1
d3694 4
a3697 5
	   new_frees((HashSet.add_list
		      (Map.domain lambda_env,
		       HashSet.list_to_set(Map.domain closure_env)),
		      HashSet.empty_set()),
		     {lexp=fcn, size=0})
d3703 1
a3703 2
	      HashSet.add_member(Map.lookup(Pervasives.STRINGEQ,
					    prim_to_lambda), free)
d3709 1
a3709 2
	   (fn (free', x) =>
	    HashSet.add_member(Map.lookup(x, prim_to_lambda), free'))
d3827 1
d3829 4
a3832 5
	   new_frees((HashSet.add_list
		      (Map.domain lambda_env,
		       HashSet.list_to_set(Map.domain closure_env)),
		      HashSet.empty_set()),
		     {lexp=AugLambda.STRUCT le_list'', size=0})
d3838 1
a3838 2
	      HashSet.add_member(Map.lookup(Pervasives.STRINGEQ,
					    prim_to_lambda), free)
d3844 2
a3845 4
	   (fn (free', x) =>
	    HashSet.add_member(Map.lookup(x, prim_to_lambda), free'))
	   (free', Set.set_to_list(Library.implicit_external_references
				   (AugLambda.STRUCT le_list))))
d3849 1
a3849 3
	Lists.reducel
	(fn (x, {size=size, lexp=_}) => x+size)
	(0, le_list'')
d3865 1
a3865 3
	map
	(fn x => (x, MirTypes.GC.new()))
	offsets
a4094 6
(*
      val _ =
	Diagnostic.output 4
	(fn i => ["Mir generating RAISE\n",
		  LambdaPrint.string_of_lambda arg])
*)
@


1.173
log
@Fixed an inexhaustive match
@
text
@d4 3
d1422 32
a1453 9
	let
	  val exception_needed =
	    case Pervasives.implicit_references prim
	      of [e] => e
	       | _ =>
		 Crash.unimplemented
		 ("Mir_Cg: Unable to cope with multiple implicit "^
		  "exceptions generated from the in-line pervasive "^
                  Pervasives.print_pervasive prim)
a1454 23
          val exception_packet =
            AugLambda.VAR(Map.lookup(exception_needed, prim_to_lambda))
            handle Map.Lookup =>
              Crash.impossible
              ("Couldn't find a lambda variable for the exception " ^
               Pervasives.print_pervasive exception_needed ^ " which was " ^
               "raised by " ^ Pervasives.print_pervasive prim)

	  val (exn_f, exn_b, exn_o, exn_l) =
	    case cg_sub(AugLambda.RAISE{lexp=exception_packet,size=0}, env,
			closure,
			static_offset, start_at, funs_in_closure,
			fn_tag_list, false, [])
              of (_, ((exn_f, exn_b, exn_o, exn_l), [], [])) =>
		 (exn_f, exn_b, exn_o, exn_l)
               | _ => Crash.impossible"Bad code for RAISE primitive exception"

	  val _ = case exn_o
                    of MirTypes.ABSENT => ()
                     | _ => Crash.impossible"Too much raise code"
	in
	  MirTypes.BLOCK(exn_tag, Mir_Utils.contract_sexpr exn_f) :: exn_b
	end
d1757 246
d2754 4
a2757 218
      | Pervasives.SUB =>

	  let
            val (constantp,constant_value) =
              case regs of
                Mir_Utils.LIST[array,offset] =>
                  (case offset of
                     Mir_Utils.INT(MirTypes.GP_IMM_INT v) => (true,v)
                   | _ => (false,0))
              | _ => (false,0)

	    val ((new_reg, code),(new_reg', code')) =
              case regs of
                Mir_Utils.LIST[array,offset] =>
                  (Mir_Utils.send_to_new_reg(Mir_Utils.ONE offset),
                   Mir_Utils.send_to_new_reg(Mir_Utils.ONE array))
              | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                  (let
                    val new_reg = MirTypes.GC.new()
                    val new_reg' = MirTypes.GC.new()
                  in
                    ((MirTypes.GP_GC_REG new_reg,[MirTypes.STOREOP(MirTypes.LD,
                                      MirTypes.GC_REG new_reg,
                                      Mir_Utils.reg_from_gp reg,
                                      MirTypes.GP_IMM_ANY 3)]),
                    (MirTypes.GP_GC_REG new_reg',[MirTypes.STOREOP(MirTypes.LD,
                                                MirTypes.GC_REG new_reg',
                                                Mir_Utils.reg_from_gp reg,
                                                MirTypes.GP_IMM_ANY ~1)]))
                    end)
              | _ => Crash.impossible "can't code generate the argument given to Array.sub in _mir_cg" 

	    val result = MirTypes.GC.new()
	    val res1 = MirTypes.GC_REG result
            val checksize = MirTypes.GC.new()
            val exn_tag = MirTypes.new_tag()
            val exn_blocks = exn_code_for_prim(prim, exn_tag)
            val main_tag = MirTypes.new_tag()
            val finish_tag = MirTypes.new_tag()
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
	      Mir_Utils.combine(the_code,
		      ((Sexpr.ATOM(code @@ code' @@
                        [MirTypes.COMMENT "Check the subscript range"] @@
				   (if constantp andalso constant_value < 0
                           then
                             [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
                         else
                           if constantp
                             then []
                           else
                             [MirTypes.TEST(MirTypes.BLT, exn_tag, new_reg, MirTypes.GP_IMM_INT 0)]) @@
                         [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG checksize,
                                          Mir_Utils.reg_from_gp new_reg',
                                          MirTypes.GP_IMM_ANY ~3),
                         MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG checksize,MirTypes.GP_GC_REG checksize,
                                         MirTypes.GP_IMM_ANY 4),
                         MirTypes.BINARY(MirTypes.SUB,MirTypes.GC_REG checksize,MirTypes.GP_GC_REG checksize,
                                         new_reg),
                         MirTypes.TEST(MirTypes.BGE, main_tag, MirTypes.GP_GC_REG checksize, MirTypes.GP_IMM_ANY 5),
                         MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]),
                        MirTypes.BLOCK(main_tag,[MirTypes.COMMENT"Array subscript operation",
			 MirTypes.BINARY(MirTypes.ADD,
					 MirTypes.GC_REG MirRegisters.global,new_reg', new_reg),
			 MirTypes.STOREOP(MirTypes.LDREF,res1,
					  MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9),
                         MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]) ::
			exn_blocks, MirTypes.PRESENT finish_tag, Sexpr.NIL), [], [])))
	  end

      | Pervasives.UPDATE =>
	  let
            val (constantp,constant_value) =
              case regs of
                Mir_Utils.LIST[array,offset,value] =>
                  (case offset of
                     Mir_Utils.INT(MirTypes.GP_IMM_INT v) => (true,v)
                   | _ => (false,0))
              | _ => (false,0)

	    val ((new_reg, code),(new_reg', code'),(new_reg'', code'')) =
              case regs of
                Mir_Utils.LIST[array,offset,value] =>
                  (Mir_Utils.send_to_new_reg(Mir_Utils.ONE offset),
                   Mir_Utils.send_to_new_reg(Mir_Utils.ONE array),
                   Mir_Utils.send_to_new_reg(Mir_Utils.ONE value))
              | Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
                  (let
		     val new_reg = MirTypes.GC.new()
		     val new_reg' = MirTypes.GC.new()
		     val new_reg'' = MirTypes.GC.new()
                  in
		     ((MirTypes.GP_GC_REG new_reg,
		       [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
					 Mir_Utils.reg_from_gp reg,
					 MirTypes.GP_IMM_ANY 3)]),
		      (MirTypes.GP_GC_REG new_reg',
		       [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg',
					 Mir_Utils.reg_from_gp reg,
					 MirTypes.GP_IMM_ANY ~1)]),
		      (MirTypes.GP_GC_REG new_reg'',
		       [MirTypes.STOREOP(MirTypes.LD,
					 MirTypes.GC_REG new_reg'',
					 Mir_Utils.reg_from_gp reg,
					 MirTypes.GP_IMM_ANY 7)]))
		   end)
              | _ => Crash.impossible "_mir_cg : update can't code generate arguments "


	    val result = MirTypes.GC.new()
	    val res1 = MirTypes.GC_REG result
	    val reg1 = new_reg'
            val scratch = MirTypes.GC.new()
            val scratch_reg = MirTypes.GC_REG scratch
            val forward = MirTypes.GC.new()
            val forward_reg = MirTypes.GC_REG forward
            val backward = MirTypes.GC.new()
            val backward_reg = MirTypes.GC_REG backward
	    val unlink_tag = MirTypes.new_tag()
	    val modified_tag = MirTypes.new_tag()

            val checksize = MirTypes.GC.new()
            val exn_tag = MirTypes.new_tag()
            val exn_blocks = exn_code_for_prim(prim, exn_tag)
            val main_tag = MirTypes.new_tag()
            val finish_tag = MirTypes.new_tag()

	    val isIntegral =
	      case Types.the_type primTy of
		LambdaTypes.Datatypes.RECTYPE map =>
		  ((Type_Utils.is_integral (Map.lookup(Ident.LAB(Symbol.find_symbol "3"), map)))
		   handle Map.Lookup => Crash.impossible"UPDATE argument has wrong record type")
	      | _ => false
	  in
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG result)),
	      Mir_Utils.combine(the_code,
		      ((Sexpr.ATOM(code @@ code' @@ code'' @@
			[MirTypes.COMMENT "Check the subscript range"] @@
                        (if constantp andalso constant_value < 0
                           then 
                             [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]
                         else
                           if constantp 
                             then []
                           else
                             [MirTypes.TEST(MirTypes.BLT, exn_tag, new_reg, MirTypes.GP_IMM_INT 0)]) @@
                           [MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG checksize,
                                             Mir_Utils.reg_from_gp new_reg',
                                             MirTypes.GP_IMM_ANY ~3),
                         MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG checksize,MirTypes.GP_GC_REG checksize,
                                         MirTypes.GP_IMM_ANY 4),
                         MirTypes.BINARY(MirTypes.SUB,MirTypes.GC_REG checksize,MirTypes.GP_GC_REG checksize,
                                         new_reg),
                         MirTypes.TEST(MirTypes.BGE, main_tag, MirTypes.GP_GC_REG checksize, MirTypes.GP_IMM_ANY 5),
                         MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]),
                        MirTypes.BLOCK(main_tag,
                                       [MirTypes.COMMENT"Array update operation",
                                        MirTypes.BINARY(MirTypes.ADD,
                                                        MirTypes.GC_REG MirRegisters.global,new_reg',new_reg),
                                        MirTypes.STOREOP(MirTypes.STREF,Mir_Utils.reg_from_gp new_reg'',
                                                         MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9)] @@
				       (if isIntegral then
					  [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]
					else
                                        [MirTypes.COMMENT"Do we need to unlink it",
					 MirTypes.STOREOP(MirTypes.LDREF, forward_reg,
							  Mir_Utils.reg_from_gp reg1,
							  MirTypes.GP_IMM_ANY 1),
					 MirTypes.TEST(MirTypes.BEQ, finish_tag, MirTypes.GP_GC_REG forward,
						       MirTypes.GP_IMM_INT 0),
					 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG unlink_tag)])) ::
			(if isIntegral then exn_blocks else
			   MirTypes.BLOCK(unlink_tag,
					  [MirTypes.STOREOP(MirTypes.LDREF, backward_reg,
							    Mir_Utils.reg_from_gp reg1,
							    MirTypes.GP_IMM_ANY 5),
					   MirTypes.TEST(MirTypes.BEQ, modified_tag, 
							 MirTypes.GP_GC_REG backward,
							 MirTypes.GP_IMM_INT 0),
					   MirTypes.COMMENT "Unlink the cell",
					   (*
					    MirTypes.STOREOP(MirTypes.LDREF, forward_reg,
					    Mir_Utils.reg_from_gp reg1,
					    MirTypes.GP_IMM_ANY 1),
					    MirTypes.STOREOP(MirTypes.LDREF, backward_reg,
					    Mir_Utils.reg_from_gp reg1,
					    MirTypes.GP_IMM_ANY 5),
					    *)
					   MirTypes.STOREOP(MirTypes.STREF, backward_reg,
							    forward_reg,
							    MirTypes.GP_IMM_ANY 8),
					   MirTypes.STOREOP(MirTypes.STREF, forward_reg,
							    backward_reg,
							    MirTypes.GP_IMM_ANY 4),
					   MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG modified_tag)]) ::
			   MirTypes.BLOCK(modified_tag,
					  [MirTypes.UNARY(MirTypes.MOVE, scratch_reg, MirTypes.GP_IMM_INT 0),
					   MirTypes.STOREOP(MirTypes.STREF, 
							    scratch_reg,
							    Mir_Utils.reg_from_gp reg1,
							    MirTypes.GP_IMM_ANY 1),
					   MirTypes.STOREOP(MirTypes.LDREF, scratch_reg,
							    MirTypes.GC_REG MirRegisters.implicit,
							    MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain),
					   MirTypes.STOREOP(MirTypes.STREF, scratch_reg,
							    Mir_Utils.reg_from_gp reg1,
							    MirTypes.GP_IMM_ANY 5),
					   MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG MirRegisters.global,
							   reg1,
							   MirTypes.GP_IMM_ANY ~3),
					   MirTypes.STOREOP(MirTypes.STREF, 
							    MirTypes.GC_REG MirRegisters.global,
							    MirTypes.GC_REG MirRegisters.implicit,
							    MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain),
					   MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]) ::
                        exn_blocks), MirTypes.PRESENT finish_tag, 
                        Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE, res1, MirTypes.GP_IMM_INT 0)]), [], [])))
	  end
@


1.172
log
@Added inline ordof
@
text
@d4 3
d2172 1
@


1.171
log
@String structure is now pervasive.
@
text
@d4 3
d2143 34
d2589 3
a2591 3
                    val new_reg = MirTypes.GC.new()
                    val new_reg' = MirTypes.GC.new()
                    val new_reg'' = MirTypes.GC.new()
d2593 14
a2606 12
                    ((MirTypes.GP_GC_REG new_reg,[MirTypes.STOREOP(MirTypes.LD,
                                                                   MirTypes.GC_REG new_reg,
                                                                   Mir_Utils.reg_from_gp reg,
                                                                   MirTypes.GP_IMM_ANY 3)]),
                    (MirTypes.GP_GC_REG new_reg',[MirTypes.STOREOP(MirTypes.LD,
                                                                   MirTypes.GC_REG new_reg',
                                                                   Mir_Utils.reg_from_gp reg,
                                                                   MirTypes.GP_IMM_ANY ~1)]),
		    (MirTypes.GP_GC_REG new_reg'',[MirTypes.STOREOP(MirTypes.LD,
                                                                    MirTypes.GC_REG new_reg'',
                                                                    Mir_Utils.reg_from_gp reg, MirTypes.GP_IMM_ANY 7)]))
                  end)
a2634 3
(*
	    if isIntegral then output(std_out, "\nDid UPDATE optimisation") else ();
*)
@


1.170
log
@Added a flag to turn off tail-call optimisation
@
text
@d4 3
a627 1
require "../utils/string";
a651 1
  structure String : STRING
@


1.169
log
@Fixed a sharing constraint problem
@
text
@d5 3
d722 1
@


1.168
log
@Removed some structures and sharing
@
text
@d4 6
d673 1
a673 1
    Type_Utils.Ident = LambdaSub.LT.Datatypes.Ident
d675 1
a675 1
  sharing Mir_Utils.Mir_Env.Map = Library.Map = Type_Utils.Map = LambdaSub.LT.Datatypes.Mapping
@


1.167
log
@Improved polymorphic equality by anding the tags before testing
@
text
@d4 3
d660 1
a660 1
  sharing LambdaSub.LT = Environ.LambdaTypes = Primitives.LambdaTypes =
d666 1
a666 1
  sharing Library.AugLambda.Ident = LambdaSub.LT.Ident = Environ.Ident =
@


1.166
log
@Removed various uses of NewMap.to_list in favour of fold and union
@
text
@d4 3
d1857 1
d1859 1
d2204 1
d2212 4
d2582 1
d2584 1
@


1.165
log
@Removed various redundant structure arguments. Added UPDATE and BECOMES optimisation.
Fixed bug causing bad code to be compiled in the interpreter.
@
text
@d4 4
a924 4
(*
  val empty_sets =
    (Set.empty_set, Set.empty_set, Set.empty_set, Set.empty_set,
     Set.empty_set)
a925 64
  fun get_externals{lexp=AugLambda.APP
		 ({lexp=AugLambda.BUILTIN(prim,_), ...},
		  {lexp=AugLambda.SCON(Ident.STRING chars), ...}), ...} =
    (case prim of
       Pervasives.LOAD_STRING =>
	 (Set.singleton chars, Set.empty_set, Set.empty_set, Set.empty_set,
	  Set.empty_set)
     | Pervasives.LOAD_VAR =>
	 (Set.empty_set, Set.singleton chars, Set.empty_set, Set.empty_set,
	  Set.empty_set)
     | Pervasives.LOAD_EXN =>
	 (Set.empty_set, Set.empty_set, Set.singleton chars, Set.empty_set,
	  Set.empty_set)
     | Pervasives.LOAD_STRUCT =>
	 (Set.empty_set, Set.empty_set, Set.empty_set, Set.singleton chars,
	  Set.empty_set)
     | Pervasives.LOAD_FUNCT =>
	 (Set.empty_set, Set.empty_set, Set.empty_set, Set.empty_set,
	  Set.singleton chars)
     | _ => empty_sets)
    | get_externals{lexp=AugLambda.APP(le, le'), ...} =
      unions(get_externals le, get_externals le')
    | get_externals{lexp=AugLambda.FN(_, le,_), ...} = get_externals le
    | get_externals{lexp=AugLambda.STRUCT le_list, ...} =
      Lists.reducel
      unions
      (empty_sets, map get_externals le_list)
    | get_externals{lexp=AugLambda.SELECT(_, le), ...} = get_externals le
    | get_externals{lexp=AugLambda.SWITCH(le, tag_le_list, opt1, opt2),
		    ...} =
      let
	val s1 = case opt1 of
	  LambdaTypes.PRESENT le => get_externals le
	| _ => empty_sets
	val s2 = case opt2 of
	  LambdaTypes.PRESENT le => get_externals le
	| _ => empty_sets
      in
	Lists.reducel
	unions
	(get_externals le, s1 :: s2 :: map get_externals_tag_le tag_le_list)
      end
    | get_externals{lexp=AugLambda.VAR _, ...} = empty_sets
    | get_externals{lexp=AugLambda.LETREC(_, le_list, le), ...} =
      Lists.reducel
      unions
      (get_externals le, map get_externals le_list)
    | get_externals{lexp=AugLambda.INT _, ...} = empty_sets
    | get_externals{lexp=AugLambda.SCON _, ...} = empty_sets
    | get_externals{lexp=AugLambda.HANDLE(le, le'), ...} =
      unions(get_externals le, get_externals le')
    | get_externals{lexp=AugLambda.RAISE le, ...} = get_externals le
    | get_externals{lexp=AugLambda.BUILTIN _, ...} = empty_sets

  and get_externals_tag_le(tag, le) =
    let
      val s = case tag of
	AugLambda.EXP_TAG le => get_externals le
      | _ => empty_sets
    in
      unions(s, get_externals le)
    end
*)

d1127 11
a1137 23
      let
	val tree_list = NewMap.to_list tree
      in
	(* Theoretically the wrong order, but there is no dependence *)
	Lists.reducel
	(fn (le as {size=size, ...}, (string, lv)) =>
	 {lexp=AugLambda.LET(lv,
	     {lexp=AugLambda.APP(
	        {lexp=AugLambda.BUILTIN(prim,LambdaTypes.null_type_annotation),
		 size=0},
		{lexp=AugLambda.SCON(Ident.STRING string), size=0},
		MirTypes.Debugger_Types.null_backend_annotation), 
	      size=0}, le), size=size}) (le,tree_list)
 
(*	 {lexp=AugLambda.APP
	  ({lexp=AugLambda.FN(lv, le, "bind " ^ string), size=size},
	   {lexp=AugLambda.APP({lexp=AugLambda.BUILTIN primAndTy, size=0},
			       {lexp=AugLambda.SCON(Ident.STRING string),
				size=0},
                               MirTypes.Debugger_Types.null_backend_annotation), size=0},
           MirTypes.Debugger_Types.null_backend_annotation), size=size})
	(le, tree_list)  *)
      end
a1882 8
(*
                                       MirTypes.STOREOP(MirTypes.LDREF, forward_reg,
                                                        Mir_Utils.reg_from_gp reg1,
					 MirTypes.GP_IMM_ANY 1),
                                        MirTypes.STOREOP(MirTypes.LDREF, backward_reg,
                                                         Mir_Utils.reg_from_gp reg1,
                                                         MirTypes.GP_IMM_ANY 5),
*)
a2757 4
(*
	  Map.domain_member(lv, escape_map) andalso
	  not(Map.lookup(lv, escape_map))
*)
a2772 4
(*
		  Lists.assoc(lvar, top_lambda_loop_tags)
		  handle Lists.Assoc =>
*)
d3906 1
a3906 6
		 (
(*
		  Lists.assoc(lvar, top_lambda_loop_tags)
		  handle Lists.Assoc =>
*)
		  top_lambda_loop_tags lvar
@


1.164
log
@Fixed bug in ftest usage
@
text
@d4 3
a600 5
require "../utils/array";
require "../utils/sexpr";
require "../utils/newmap";
require "../utils/set";
require "../utils/map";
a606 4
require "../basics/ident";
require "../basics/symbol";
require "../lambda/lambdatypes";
require "../lambda/environtypes";
d614 2
a615 1
require "../lambda/auglambda";
a616 1
require "../main/pervasives";
a619 1
require "mirtypes";
a620 1
require "mir_env";
a625 2
  structure Sexpr : SEXPR
  structure NewMap : NEWMAP
a626 3
  structure Array : ARRAY
  structure Set : SET
  structure Map : MAP
a632 2
  structure Ident : IDENT
  structure Symbol : SYMBOL
a633 1
  structure Pervasives : PERVASIVES
a634 2
  structure LambdaTypes : LAMBDATYPES
  structure EnvironTypes : ENVIRONTYPES
a641 1
  structure MirTypes : MIRTYPES
a643 1
  structure Mir_Env : MIR_ENV
d647 2
a648 1
  structure AugLambda : AUGLAMBDA
d650 1
a650 4
  sharing AugLambda.Debugger_Types = MirTypes.Debugger_Types
  sharing NewMap = InterProc.NewMap
  sharing EnvironTypes.LambdaTypes = LambdaTypes = Mir_Env.LambdaTypes =
    LambdaSub.LT = Environ.LambdaTypes = Primitives.LambdaTypes =
d653 11
a663 15
    = AugLambda.LambdaTypes
  sharing Environ.EnvironTypes = Primitives.EnvironTypes = EnvironTypes
  sharing Mir_Env.MirTypes = MirTypes = MirRegisters.MirTypes =
    MirPrint.MirTypes = Mir_Utils.MirTypes
  sharing MirTypes.Ident = LambdaTypes.Ident = Ident = Environ.Ident
    = AugLambda.Ident
  sharing Set = LambdaSub.Set = Primitives.Set = Library.Set
  sharing Map = Mir_Env.Map = Library.Map
  sharing Symbol = Ident.Symbol
  sharing Pervasives = Mir_Utils.Pervasives
  sharing Mir_Env = Mir_Utils.Mir_Env
  sharing AugLambda = Library.AugLambda = Tail.AugLambda
  sharing Mir_Utils.Sexpr = Sexpr
  sharing type Pervasives.pervasive = LambdaTypes.Primitive
) : MIR_CG =
d665 10
d676 2
a677 2
  structure LambdaTypes = LambdaTypes
  structure EnvironTypes = EnvironTypes
a680 1
    structure Array = Array
d783 1
a783 1
				     ({lexp=AugLambda.BUILTIN prim, ...},
d927 1
a927 1
		 ({lexp=AugLambda.BUILTIN prim, ...},
d991 1
a991 1
		   ({lexp=AugLambda.BUILTIN prim, ...},
d1198 5
a1202 4
	     {lexp=AugLambda.APP({lexp=AugLambda.BUILTIN prim, size=0},
				 {lexp=AugLambda.SCON(Ident.STRING string),
				  size=0},
				 MirTypes.Debugger_Types.null_backend_annotation), 
d1207 1
a1207 1
	   {lexp=AugLambda.APP({lexp=AugLambda.BUILTIN prim, size=0},
d1222 1
a1222 1
    val new_exp_and_size =
d1369 1
a1369 1
	       ({lexp=AugLambda.BUILTIN prim, ...},
d1923 6
d1930 1
d1938 14
a1951 10
					 MirTypes.GP_IMM_ANY 9),
                        MirTypes.COMMENT"Do we need to unlink it",
                        MirTypes.STOREOP(MirTypes.LDREF, forward_reg,
					 Mir_Utils.reg_from_gp reg1,
					 MirTypes.GP_IMM_ANY 1),
                        MirTypes.TEST(MirTypes.BEQ, already_on_ref_chain_tag, 
                                      MirTypes.GP_GC_REG forward,
                                      MirTypes.GP_IMM_INT 0),
                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG unlink_tag)]),
		       [MirTypes.BLOCK(unlink_tag,
d1974 1
a1974 1
                       MirTypes.BLOCK(modified_tag,
d1993 1
a1993 1
                                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG already_on_ref_chain_tag)])],
d1995 1
a1995 2
                       Sexpr.ATOM[MirTypes.UNARY(MirTypes.MOVE, res2,
				       MirTypes.GP_IMM_INT 0),
d2649 6
d2656 1
d2683 56
a2738 52
                                                         MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9),
                                        MirTypes.COMMENT"Do we need to unlink it",
                                        MirTypes.STOREOP(MirTypes.LDREF, forward_reg,
                                                         Mir_Utils.reg_from_gp reg1,
                                                         MirTypes.GP_IMM_ANY 1),
                                        MirTypes.TEST(MirTypes.BEQ, finish_tag, MirTypes.GP_GC_REG forward,
                                                      MirTypes.GP_IMM_INT 0),
                                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG unlink_tag)]) ::
                        MirTypes.BLOCK(unlink_tag,
                                       [MirTypes.STOREOP(MirTypes.LDREF, backward_reg,
                                                         Mir_Utils.reg_from_gp reg1,
                                                         MirTypes.GP_IMM_ANY 5),
                                       MirTypes.TEST(MirTypes.BEQ, modified_tag, 
                                                     MirTypes.GP_GC_REG backward,
                                                     MirTypes.GP_IMM_INT 0),
                                       MirTypes.COMMENT "Unlink the cell",
(*
                                       MirTypes.STOREOP(MirTypes.LDREF, forward_reg,
                                                        Mir_Utils.reg_from_gp reg1,
                                                        MirTypes.GP_IMM_ANY 1),
                                       MirTypes.STOREOP(MirTypes.LDREF, backward_reg,
                                                        Mir_Utils.reg_from_gp reg1,
                                                        MirTypes.GP_IMM_ANY 5),
*)
                                       MirTypes.STOREOP(MirTypes.STREF, backward_reg,
                                                        forward_reg,
                                                        MirTypes.GP_IMM_ANY 8),
                                       MirTypes.STOREOP(MirTypes.STREF, forward_reg,
                                                        backward_reg,
                                                        MirTypes.GP_IMM_ANY 4),
                                       MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG modified_tag)]) ::
                        MirTypes.BLOCK(modified_tag,
                                       [MirTypes.UNARY(MirTypes.MOVE, scratch_reg, MirTypes.GP_IMM_INT 0),
                                        MirTypes.STOREOP(MirTypes.STREF, 
                                                         scratch_reg,
                                                         Mir_Utils.reg_from_gp reg1,
                                                         MirTypes.GP_IMM_ANY 1),
                                        MirTypes.STOREOP(MirTypes.LDREF, scratch_reg,
                                                         MirTypes.GC_REG MirRegisters.implicit,
                                                         MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain),
                                        MirTypes.STOREOP(MirTypes.STREF, scratch_reg,
                                                         Mir_Utils.reg_from_gp reg1,
                                                         MirTypes.GP_IMM_ANY 5),
                                        MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG MirRegisters.global,
                                                        reg1,
                                                        MirTypes.GP_IMM_ANY ~3),
                                        MirTypes.STOREOP(MirTypes.STREF, 
                                                         MirTypes.GC_REG MirRegisters.global,
                                                         MirTypes.GC_REG MirRegisters.implicit,
                                                         MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain),
                                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]) ::
                        exn_blocks, MirTypes.PRESENT finish_tag, 
d2990 1
a2990 1
	AugLambda.APP({lexp=AugLambda.BUILTIN prim, ...}, _,_) =>
d3026 2
a3027 2
	    val (prim, arg, is_struct) = case lexp of
	      AugLambda.APP({lexp=AugLambda.BUILTIN prim, ...},
d3029 3
a3031 3
		(prim, le_list, true)
	    | AugLambda.APP({lexp=AugLambda.BUILTIN prim, ...}, arg,_) =>
		(prim, [arg], false)
d3044 1
a3044 1
	      AugLambda.APP({lexp=AugLambda.BUILTIN prim, size=0},
d4248 1
a4248 1
    | cg_sub(AugLambda.BUILTIN prim, env, closure, static_offset,
d4251 3
a4253 3
	val _ =
	  Print.print("The bad primitive\n" ^
		      LambdaPrint.string_of_lambda(LambdaTypes.BUILTIN prim))
@


1.163
log
@Changed calls to C to pass a single argument.
@
text
@d4 3
d1949 1
a1949 1
                        MirTypes.STOREOP(MirTypes.LDREF, scratch_reg,
d1953 1
a1953 1
                                      MirTypes.GP_GC_REG scratch,
d1957 1
a1957 1
                                       [MirTypes.STOREOP(MirTypes.LDREF, scratch_reg,
d1961 1
a1961 1
                                                     MirTypes.GP_GC_REG scratch,
d1964 1
d1971 1
d2345 1
a2345 1
      | Pervasives.REALGREATER => ftest(MirTypes.FBLE, false)
d2349 1
a2349 1
      | Pervasives.REALGREATEREQ => ftest(MirTypes.FBLT, false)
d2353 1
a2353 1
      | Pervasives.REALNE => ftest(MirTypes.FBEQ, false)
d2684 1
a2684 1
                                        MirTypes.STOREOP(MirTypes.LDREF, scratch_reg,
d2687 1
a2687 1
                                        MirTypes.TEST(MirTypes.BEQ, finish_tag, MirTypes.GP_GC_REG scratch,
d2691 1
a2691 1
                                       [MirTypes.STOREOP(MirTypes.LDREF, scratch_reg,
d2695 1
a2695 1
                                                     MirTypes.GP_GC_REG scratch,
d2698 1
d2705 1
@


1.162
log
@Used BIC to clear the bottom two bits when calculating array length
@
text
@d4 3
d2385 4
a2388 20
		  Mir_Utils.ONE(Mir_Utils.INT(reg)) =>
		    MirTypes.STOREOP(MirTypes.LD,
				     MirTypes.GC_REG MirRegisters.caller_arg,
				     Mir_Utils.reg_from_gp reg,
				     MirTypes.GP_IMM_ANY ~1) ::
		    MirTypes.STOREOP(MirTypes.LD,
				     MirTypes.GC_REG
				     MirRegisters.caller_closure,
				     Mir_Utils.reg_from_gp reg, MirTypes.GP_IMM_ANY 3) ::
		    get_result
	      | Mir_Utils.LIST[Mir_Utils.INT reg1, Mir_Utils.INT reg2] =>
		  MirTypes.UNARY(MirTypes.MOVE,
				 MirTypes.GC_REG MirRegisters.caller_arg,
				 reg1) ::
		  MirTypes.UNARY(MirTypes.MOVE,
				 MirTypes.GC_REG MirRegisters.caller_closure,
				 reg2) ::
		  get_result
	      | _ =>
		  Crash.impossible "Bad arguments to make_args_for_call_c"
@


1.161
log
@Added jont's curry_reduce
@
text
@d4 3
d2531 2
a2532 2
                         MirTypes.BINARY(MirTypes.EOR,res1,
                                         MirTypes.GP_GC_REG result,MirTypes.GP_IMM_ANY 1)]),
@


1.160
log
@Setup procedure name needs to be passed to count_gc_objects
@
text
@d4 3
d610 1
d650 1
d665 1
a665 1
    (*Tail.LambdaTypes =*) Curry.LambdaTypes = Mir_Utils.LambdaTypes
d1146 10
@


1.159
log
@Jont fix to get more tail calling
@
text
@d4 3
d1122 3
d1164 1
a1164 1
                                            mapping))
d4300 1
a4300 1
      MirTypes.PROC("Setup procedure for " ^ filename ^ ":1,1",
@


1.158
log
@Added call point information
@
text
@d4 3
d2852 1
a2852 1
	   0, false, false, false, Lists.hd fn_tag_list)
@


1.157
log
@Added LET constructor and new slot to APP.
Added diagnostic level control on curry message.
@
text
@d4 4
d675 1
a699 2
  val generate_debug_information = ref(false)
  val print_generated_debug_information = ref(false)
d1114 1
a1114 1
  fun mir_cg(lambda_exp, top_env,filename) =
d1154 2
a1155 1
       fn () => AugLambda.count_gc_objects (new_lambda_exp,! generate_debug_information, ! print_generated_debug_information))
@


1.156
log
@Turned off automatic printing of various timings
@
text
@d4 3
d813 7
d991 2
d1012 2
d1069 2
d1116 3
a1118 1
    val _ = Print.print"Uncurrying..."
d1120 2
a1121 1
    val _ = Print.print"done\n"
d1177 8
a1184 1
	 {lexp=AugLambda.APP
d1191 1
a1191 1
	(le, tree_list)
d2750 23
d2778 1
@


1.155
log
@Added type annotation information at application points
@
text
@d4 3
d678 2
d1113 1
a1113 1
      ("calculating fn bindings", true,
d1118 1
a1118 1
      ("calculating escape map", true,
d1131 1
a1131 1
      ("counting new_lambda", true,
@


1.154
log
@Changed ml_call to return the result instead of the code!
@
text
@d4 3
d638 2
d771 1
a771 1
				       ...}), ...})) =
d798 1
a798 1
    | lift_externals(trees, {lexp=AugLambda.APP(le, le'), size=size}) =
d803 1
a803 1
	(trees, {lexp=AugLambda.APP(le, le'), size=size})
d971 1
a971 1
		    {lexp=AugLambda.SCON(Ident.STRING chars), ...}), ...} =
d974 1
a974 1
    | get_string{lexp=AugLambda.APP(le, le'), ...} =
d993 1
a993 1
      AugLambda.APP(le, le') =>
d1055 1
a1055 1
  | needs_prim_stringeq(AugLambda.APP({lexp=le, ...}, {lexp=le', ...})) =
d1157 3
a1159 1
				size=0}), size=0}), size=size})
d1318 1
a1318 1
		{lexp=lexp, size=gc_objects_in_parm}), env, closure,
d1777 2
a1778 1
					 MirTypes.REG scratch_reg),
d2195 2
a2196 1
				   {lexp=AugLambda.VAR lvar, size=0}), env',
d2720 1
a2720 1
	     ({lexp=AugLambda.FN(lvar, {lexp=lexp1, ...},_), ...}, lexp2), env,
d2742 1
a2742 1
				  {lexp=le2, ...}), env, closure,
d2797 2
a2798 1
	Mir_Utils.new_do_app(fn_reg, fn_code, arg_reg, arg_code,
d2905 1
a2905 1
	AugLambda.APP({lexp=AugLambda.BUILTIN prim, ...}, _) =>
d2943 1
a2943 1
			    {lexp=AugLambda.STRUCT le_list, ...}) =>
d2945 1
a2945 1
	    | AugLambda.APP({lexp=AugLambda.BUILTIN prim, ...}, arg) =>
d2965 2
a2966 1
				AugLambda.VAR lvar), size=0})
d3366 2
a3367 1
		Mir_Utils.do_app(regs', the_code',
@


1.153
log
@Added ML_REQUIRE builtin for interpreter to get builtin library
@
text
@d4 3
d1756 1
d1770 4
a1773 1
					 MirTypes.REG scratch_reg)])
d1775 1
a1775 1
	    (Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG scratch)),
@


1.152
log
@Added parameter to RAISE once again, and some stuff that jont asked
me to put in.
@
text
@d4 4
d1749 1
@


1.151
log
@Added code to deal with externals from interpretive environment
@
text
@d4 3
d1768 31
d4020 7
a4026 3
	Mir_Utils.send_to_given_reg(reg, caller_arg) @@
	[MirTypes.RAISE,
	 MirTypes.COMMENT"Call the exception handler, so we can backtrace"]
@


1.150
log
@Added code to handle externals defined by the interpreter
@
text
@d4 3
d711 175
d952 1
d954 22
d1131 14
a1144 12
    val (requires, vars, exns, strs, funs) =
      get_externals new_exp_and_size
    val ext_strings =
      Set.set_to_list requires
    val ext_vars =
      Set.set_to_list vars
    val ext_exns =
      Set.set_to_list exns
    val ext_strs =
      Set.set_to_list strs
    val ext_funs =
      Set.set_to_list funs
d1146 16
d1742 23
a1764 1
      | Pervasives.ML_CALL => do_external_prim prim
@


1.149
log
@Coded load_var etc as unimplemented at present
@
text
@d4 6
d703 33
a735 9
    fun get_string{lexp=AugLambda.APP
		   ({lexp=AugLambda.BUILTIN prim, ...},
		    {lexp=AugLambda.SCON(Ident.STRING chars), ...}), ...} =
      if prim = Pervasives.LOAD_STRING then Set.singleton chars
      else Set.empty_set
    | get_string{lexp=AugLambda.APP(le, le'), ...} =
      Set.union(get_string le, get_string le')
    | get_string{lexp=AugLambda.FN(_, le,_), ...} = get_string le
    | get_string{lexp=AugLambda.STRUCT le_list, ...} =
d737 28
a764 11
      Set.union
      (Set.empty_set, map get_string le_list)
    | get_string{lexp=AugLambda.SELECT(_, le), ...} = get_string le
    | get_string{lexp=AugLambda.SWITCH _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.VAR _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.LETREC _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.INT _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.SCON _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.HANDLE _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.RAISE _, ...} = Set.empty_set
    | get_string{lexp=AugLambda.BUILTIN _, ...} = Set.empty_set
d766 9
d930 2
d933 9
a941 1
      Set.set_to_list(get_string new_exp_and_size)
d945 8
d963 6
a968 2
    val ext_string_tree =
      NewMap.from_list str_order ext_string_list
d970 11
d982 1
a982 1
      (NewMap.apply ext_string_tree chars) handle
d984 12
d1110 2
a1111 1
	        ((Sexpr.ATOM[MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
d1117 60
a1176 4
    | Pervasives.LOAD_VAR => Crash.unimplemented"LOAD_VAR"
    | Pervasives.LOAD_EXN => Crash.unimplemented"LOAD_EXN"
    | Pervasives.LOAD_STRUCT => Crash.unimplemented"LOAD_STRUCT"
    | Pervasives.LOAD_FUNCT => Crash.unimplemented"LOAD_FUNCT"
a3927 2
    val ext_refs = ext_string_list

d3983 6
a3988 1
    (MirTypes.CODE(MirTypes.REFS(loc_refs, ext_refs),
@


1.148
log
@Changed flag so that debug information generation is off by default
@
text
@d4 3
d1015 4
d1363 8
a1370 1
	Pervasives.REF =>
@


1.147
log
@Changes for the recording of FNexp type information
@
text
@d4 3
d660 1
a660 1
  val generate_debug_information = ref(true)
@


1.146
log
@Some minor sharing changes
@
text
@d4 3
d657 2
d846 1
a846 1
    val new_exp_and_size as {size=number_of_gc_objects, lexp=new_lambda_exp} =
d849 1
a849 1
       fn () => AugLambda.count_gc_objects new_lambda_exp)
d3810 3
a3812 2
    MirTypes.CODE(MirTypes.REFS(loc_refs, ext_refs),
		  values, new_procs')
@


1.145
log
@Modified to use newmap
@
text
@d4 3
d618 2
a619 3
  sharing Set = LambdaSub.Set = Environ.Set = Primitives.Set = Library.Set
  sharing EnvironTypes.Map = Map = Mir_Env.Map = Environ.Map = Library.Map(* =
    InterProc.Map*)
@


1.144
log
@Added some comments in the poly eq case
@
text
@d4 3
d604 1
d616 2
a617 2
  sharing EnvironTypes.Map = Map = Mir_Env.Map = Environ.Map = Library.Map =
    InterProc.Map
a705 48
(*
  fun bounds_and_frees(sets as (bound_set, free_set), {lexp=lexp, size=_}) =
    case lexp of
      AugLambda.APP(le, le') =>
	bounds_and_frees(bounds_and_frees(sets, le), le')
    | AugLambda.FN(lv, le,_) =>
	bounds_and_frees((Set.add_member(lv, bound_set), free_set), le)
    | AugLambda.STRUCT le_list =>
      Lists.reducel
      (fn (sets, le) => bounds_and_frees(sets, le))
      (sets, le_list)
    | AugLambda.SELECT(_, le) => bounds_and_frees(sets, le)
    | AugLambda.SWITCH(le, tag_le_list, opt1, opt2) =>
	Lists.reducel
	(fn (sets, (tag, le)) =>
	 let
	   val sets = bounds_and_frees(sets, le)
	 in
	   case tag of
	     AugLambda.EXP_TAG lexp => bounds_and_frees(sets, lexp)
	   | _ => sets
	 end)
	(bandf_opt
	 (bandf_opt
	  (bounds_and_frees(sets, le), opt1), opt2), tag_le_list)
    | AugLambda.VAR lv =>
	if Set.is_member(lv, bound_set) then sets
	else
	  (bound_set, Set.add_member(lv, free_set))
    | AugLambda.LETREC(lv_list, le_list, le) =>
	Lists.reducel
	bounds_and_frees
	(bounds_and_frees((Set.union(Set.list_to_set lv_list, bound_set),
			   free_set), le), le_list)
    | AugLambda.INT _ => sets
    | AugLambda.SCON _ => sets
    | AugLambda.HANDLE(le, le') =>
	bounds_and_frees(bounds_and_frees(sets, le), le')
    | AugLambda.RAISE le => bounds_and_frees(sets, le)
    | AugLambda.BUILTIN _ => sets

  and bandf_opt(sets, LambdaTypes.PRESENT le) = bounds_and_frees(sets, le)
    | bandf_opt(sets, _) = sets

  val bounds_and_frees =
    fn lexp => bounds_and_frees((Set.empty_set, Set.empty_set), lexp)
*)

a804 40
(*
  fun makes_calls(AugLambda.VAR _) = false
    | makes_calls(AugLambda.APP({lexp=AugLambda.FN(lv, {lexp=le, ...},_), ...},
				{lexp=le', ...})) =
      makes_calls le orelse makes_calls le'
    | makes_calls(AugLambda.APP({lexp=AugLambda.BUILTIN _, ...},
				{lexp=AugLambda.STRUCT le_list, ...})) =
      Lists.exists (fn {lexp=lexp, size=_} => makes_calls lexp) le_list
    | makes_calls(AugLambda.APP({lexp=AugLambda.BUILTIN _, ...},
				{lexp=le, ...})) =
      makes_calls le
    | makes_calls(AugLambda.APP _) = true
    | makes_calls(AugLambda.FN _) = true
    | makes_calls(AugLambda.LETREC _) = true
    | makes_calls(AugLambda.SWITCH({lexp=le, ...},
				   tag_le_list, le1_opt, le2_opt)) =
      let
	fun makes_calls_tag(tag, {lexp=le, size=_}) =
	  makes_calls le orelse
	  (case tag of
	     AugLambda.EXP_TAG{lexp=lexp, ...} => makes_calls lexp
	   | AugLambda.SCON_TAG(Ident.STRING _) => true
	   | _ => false)
	fun makes_calls_le_opt LambdaTypes.ABSENT = false
	| makes_calls_le_opt(LambdaTypes.PRESENT{lexp=le, size=_}) =
	  makes_calls le
      in
	makes_calls le orelse
	makes_calls_le_opt le1_opt orelse makes_calls_le_opt le2_opt orelse
	Lists.exists makes_calls_tag tag_le_list
      end
    | makes_calls(AugLambda.STRUCT _) = true
    | makes_calls(AugLambda.SELECT(_, {lexp=le, ...})) = makes_calls le
    | makes_calls(AugLambda.RAISE l_) = true
    | makes_calls(AugLambda.HANDLE _) = true
    | makes_calls(AugLambda.SCON _) = false
    | makes_calls(AugLambda.INT _) = false
    | makes_calls(AugLambda.BUILTIN _) = false
*)

d831 1
a831 1
    val top_lambdas = Map.domain escape_map
d837 1
a837 1
                 (Map.domain escape_map))))
a838 9
(*
    val number_of_gc_objects = Mir_Utils.count_gc_objects new_lambda_exp
*)

(*
    val _ = Print.print"Final exp =\n"
    val _ = Print.print(LambdaPrint.string_of_lambda new_lambda_exp)
    val _ = Print.print"\n"
*)
a843 8
(*
    val _ =
      if n' = number_of_gc_objects then
	Print.print"Counts agree\n"
      else
	Crash.impossible"Counts do not agree"
*)

d848 7
d856 4
a859 3
      Lists.reducel
      (fn (x, (t, i)) => Map.add((i, t), x, (op <): int * int -> bool))
      (Map.empty_map, top_tags_list)
d883 9
d893 3
a895 1
      map (fn lv => (lv, MirTypes.new_tag())) top_lambdas
a899 3
(*
	val gc_in_arg = Mir_Utils.count_gc_objects lexp
*)
a1693 3
(*
	  val gc_objects_in_parm = Mir_Utils.count_gc_objects lexp
*)
d2278 2
d2282 1
a2283 3
(*
      val gc_objects_in_call = Mir_Utils.count_gc_objects le1
*)
d2298 1
d2301 3
a2325 21
(*
      val _ =
	Print.print
	(implode
	 ("Code produced\n" ::
	  "blocks =\n" ::
	  (map (fn x => MirPrint.block x ^ "\n") blocks) @@
	  ("Tag_opt = " ::
	   (case tag_opt of MirTypes.ABSENT => "ABSENT"
	 | MirTypes.PRESENT tag => MirTypes.print_tag tag) ::
	      "\nfirst =\n" ::
	      (map (fn x => MirPrint.opcode x ^ "\n") first) @@
	      ("last =\n" ::
	       (map (fn x => MirPrint.opcode x ^ "\n") last))) @@
	  ("procedures\n" ::
	   Lists.reducer
	   op @@
	   (map
	    (fn x => map (fn proc => MirPrint.procedure proc ^ "\n") x)
	    procs_list, []))))
*)
a2342 3
(*
	val positions = Mir_Utils.gc_list_positions(0, Mir_Utils.count_gc_objects, le_list, [])
*)
a2353 8
(*
	val reg_code_list =
	  map (fn (le, pos) =>
	       cg_sub(le, env, closure,
		      static_offset + pos, start_at + pos, funs_in_closure,
		      fn_tag_list, false, []))
	  (Lists.zip(le_list, positions))
*)
a2441 3
(*
      val arg_size = Mir_Utils.count_gc_objects lexp
*)
a2442 3
(*
	Mir_Utils.gc_list_positions(arg_size, Mir_Utils.count_gc_objects o #2, tag_le_list, [])
*)
a2452 4
(*
	Mir_Utils.gc_list_positions(arg_size + list_size, Mir_Utils.count_gc_tags o #1,
			  tag_le_list, [])
*)
a2475 4
(*
	    val env' =
	      Mir_Env.add_lambda_env((lvar, reg), env)
*)
d2848 3
a2850 2
		    MirTypes.VALUE(Map.lookup(start_at + p + 1, top_closure),
				   scon)
d2926 3
a2928 2
		   MirTypes.VALUE(Map.lookup(start_at + p + 1, top_closure),
				  scon)
d3107 2
a3108 1
	  val new_tag = Map.lookup(start_at + 1, top_closure)
a3131 1
(*
a3132 5
	Timer.xtime
	("old bounds_and_frees", true,
	 fn () => bounds_and_frees{lexp=fcn, size=0})
*)
      val (_, free) =
a3142 13
(*
      val free' = Set.list_to_set(HashSet.set_to_list free')

      val _ =
	if Set.seteq(free, free') then ()
	else
	  (Print.print
	   ("Old frees =\n" ^ Set.set_print(free, LambdaTypes.printLVar) ^
	    "New frees =\n" ^ Set.set_print(free', LambdaTypes.printLVar) ^
	    "\n");
	   Crash.impossible"old and new frees not the same on fcn")

*)
d3158 2
a3159 4
(*
      val gc_objects_within = Mir_Utils.count_gc_objects lexp
*)
      val tag = Map.lookup(start_at + gc_objects_within + 1, top_closure)
a3256 7
      val le_list' =
(* These are all eta abstracted during counting
	map
	(fn (lexp as AugLambda.FN _) => lexp
	 | lexp => LambdaSub.eta_abstract (lexp,""))
*)
	le_list
d3262 1
a3262 1
	le_list'
d3267 1
a3267 1
	le_list'
a3268 10
(*
      val free =
	Timer.xtime
	("old bounds_and_frees", true,
	 fn () => Lists.reducel Set.union
	 (Set.empty_set,
	  map (fn x => Set.setdiff(#2 (bounds_and_frees x),
				   Set.list_to_set lv_list))
	  le_list))
*)
a3279 13
(*
      val free' = Set.list_to_set(HashSet.set_to_list free')

      val _ =
	if Set.seteq(free, free') then ()
	else
	  (Print.print
	   ("Old frees =\n" ^ Set.set_print(free, LambdaTypes.printLVar) ^
	    "New frees =\n" ^ Set.set_print(free', LambdaTypes.printLVar) ^
	    "\n");
	   Crash.impossible"old and new frees not the same on letrec")
*)

a3301 3
(*
 Mir_Utils.gc_list_positions(0, Mir_Utils.count_gc_objects, le_list'', [])
*)
d3306 3
a3308 2
	map (fn x => Map.lookup(start_at + gc_objects_within + (x div 2) + 1,
				top_closure))
d3432 3
a3434 1
		 (Lists.assoc(lvar, top_lambda_loop_tags)
d3436 3
d3687 1
a3687 2
    val clos_range = Map.range top_closure
    val new_tag = Lists.hd clos_range
d3712 7
d3744 1
a3744 2
    val (loc_refs, next) =
      Lists.number_from_by_one(clos_range, 0, ident_fn)
d3746 1
a3746 2
    val (ext_refs, next) =
      Lists.number_from_by_one(ext_strings, next, ident_fn)
@


1.143
log
@Added arithmetic right shift
@
text
@d4 3
d1822 2
a1823 1
		  (Sexpr.ATOM[MirTypes.TEST(MirTypes.BEQ, good_tag, reg1,
d1862 3
a1864 1
		       [], MirTypes.PRESENT final_tag, Sexpr.NIL), [], []))))
@


1.142
log
@Added the Bits structure
@
text
@d4 3
d2303 1
@


1.141
log
@Changed to use lambda code augmented by number of static gc objects within
at each stage, rather than calculating every time. This produced a big win
on pathological cases like long manifest lists. Also changed the
bounds_and_frees implementation for one which calculates those lambdas
which could be free which are actually required, thus avoiding producing
huge bound variable sets which are of little use.
@
text
@d4 8
d1350 73
d2294 21
d2904 5
a2908 1
	    val (low, high) = bounds(0, 0, map #1 val_le_tags_list)
a3255 3
	Timer.xtime
	("new_frees", true,
	 fn () =>
d3265 1
a3265 1
	 end)
a3424 3
	Timer.xtime
	("new_frees", true,
	 fn () =>
d3434 1
a3434 1
	 end)
@


1.140
log
@Added profiling to the setup procedure
@
text
@d4 3
d518 4
a521 1
require "../utils/balancedtree";
a550 1
require "mir_data";
d554 2
a555 1
  structure BalancedTree : BALANCEDTREE
d557 1
a583 1
  structure Mir_Data : MIR_DATA
d594 1
a594 1
    MirPrint.MirTypes = Mir_Utils.MirTypes = Mir_Data.MirTypes
d604 1
d612 9
d658 1
a658 1
  val no_code = (([], [], MirTypes.ABSENT, []), [], [])
d688 1
d734 1
d736 44
d948 1
a948 1
	BalancedTree.EQ
d951 1
a951 1
	  BalancedTree.LT
d953 1
a953 1
	  BalancedTree.GT
d956 1
a956 1
      BalancedTree.from_alist str_order ext_string_list
d959 2
a960 3
      case BalancedTree.lookup(ext_string_tree, chars) of
	BalancedTree.YES i => i
      | _ => Crash.impossible"string missing"
d1013 4
a1016 2
	 Mir_Utils.combine(the_code, ((more_code, [], MirTypes.ABSENT, []),
				      [], [])),
d1067 1
a1067 1
	        (([MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
d1070 1
a1070 1
		  [], MirTypes.ABSENT, []), [], []))
d1111 1
a1111 1
	  MirTypes.BLOCK(exn_tag, exn_f) :: exn_b
d1129 4
a1132 4
	    ((new_code @@
	      [(MirTypes.TBINARY(opcode,
				 exn_tag, res2, val1, val2))],
	      exn_blocks, MirTypes.ABSENT, []), [], [])))
d1148 3
a1150 3
	    ((new_code @@
	      [(MirTypes.BINARY(opcode, res2, val1, val2))],
	      [], MirTypes.ABSENT, []), [], [])))
d1163 3
a1165 2
	      (Mir_Utils.ONE(Mir_Utils.INT res1), Mir_Utils.combine(the_code,
	        (([(MirTypes.TBINARY(opcode, exn_tag, res2,
d1167 1
a1167 1
		 MirTypes.ABSENT, []), [], [])))
d1204 6
a1209 4
	      (Mir_Utils.ONE(Mir_Utils.REAL result), Mir_Utils.combine(the_code,
		((new_code @@
		  [(MirTypes.TBINARYFP(opcode, exn_tag, result, val1, val2))],
		  exn_blocks, MirTypes.ABSENT, []), [], [])))
d1221 1
a1221 1
		  [MirTypes.STOREFPOP(MirTypes.FLD, result,
d1226 1
a1226 1
		    [MirTypes.UNARYFP(opcode, result, reg)]
d1228 1
a1228 1
		  [], MirTypes.ABSENT, []), [], [])))
d1241 1
a1241 1
		  [MirTypes.STOREFPOP(MirTypes.FLD, result,
d1246 1
a1246 1
		    [MirTypes.TUNARYFP(opcode, exn_tag, result, reg)]
d1248 1
a1248 1
		  exn_blocks, MirTypes.ABSENT, []), [], [])))
d1264 2
a1265 2
		      ((new_code @@
		       [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
d1270 2
a1271 2
			MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag)],
		       [], MirTypes.PRESENT tag, []), [], [])))
d1303 2
a1304 2
		      ((new_code @@
		       [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
d1309 2
a1310 2
			MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag)],
		       [], MirTypes.PRESENT tag, []), [], [])))
d1356 1
a1356 1
		((code @@
d1365 2
a1366 2
		  MirTypes.COMMENT"Initialise the other pointers"],
		  [], MirTypes.ABSENT, []), [], [])))
d1395 1
a1395 1
		     ((new_code @@
d1408 1
a1408 1
                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG unlink_tag)],
d1451 1
a1451 1
                       [MirTypes.UNARY(MirTypes.MOVE, res2,
d1464 1
a1464 1
		    (([MirTypes.STOREOP(MirTypes.LDREF, res1,
d1468 1
a1468 1
		  [], MirTypes.ABSENT, []), [], [])))
d1564 1
a1564 1
		      [MirTypes.STOREFPOP(MirTypes.FLD, fp_op,
d1571 1
a1571 1
		    [MirTypes.FLOOR(MirTypes.FTOI, exn_tag, result_reg, reg)]
d1573 1
a1573 1
		  exn_blocks, MirTypes.ABSENT, []), [], [])))
d1584 1
a1584 1
		   [MirTypes.REAL(MirTypes.ITOF, result,
d1587 1
a1587 1
		   [MirTypes.REAL(MirTypes.ITOF, result,
d1590 1
a1590 1
		   [MirTypes.REAL(MirTypes.ITOF, result,
d1593 1
a1593 1
		  [], MirTypes.ABSENT, []), [], [])))
d1606 3
a1608 1
	   Mir_Utils.combine(the_code, ((code, [], MirTypes.ABSENT, []), [], [])))
d1624 1
a1624 1
		((code @@
d1638 2
a1639 2
                                   MirTypes.GP_IMM_ANY ~1)], exn_blocks,
		MirTypes.ABSENT, []), [], [])))
d1654 1
a1654 1
		   ((code @@
d1659 2
a1660 2
                      MirTypes.BINARY(MirTypes.ASL, res1,res2, MirTypes.GP_IMM_ANY 2)],
		     exn_blocks, MirTypes.ABSENT, []), [], [])))
d1713 2
a1714 1
	  val extra_code = ((extra_code, [], MirTypes.ABSENT, []), [], [])
d1735 2
a1736 1
		  ([MirTypes.TEST(MirTypes.BEQ, good_tag, reg1, reg2),
d1763 1
a1763 1
		  MirTypes.PRESENT test_tag, [])
d1771 4
a1774 3
		     ((Mir_Utils.send_to_given_reg(reg, res_reg) @@
		       [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG final_tag)],
		       [], MirTypes.PRESENT final_tag, []), [], []))))
d1819 1
a1819 1
	        (([MirTypes.UNARY(MirTypes.MOVE, res2, reg),
d1824 1
a1824 1
		MirTypes.PRESENT tag, []), [], [])))
d1864 2
a1865 1
		      ((make_args_for_call_c regs, [], MirTypes.ABSENT, []),
d1916 2
a1917 3
                     ((code @@ code' @@
                       (if constantp
                          then
d1925 1
a1925 1
                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)]),
d1968 1
a1968 1
                       [MirTypes.UNARY(MirTypes.MOVE, work1, MirTypes.GP_IMM_ANY 0),
d1984 1
a1984 1
		      ((code @@
d1990 2
a1991 2
                                         MirTypes.GP_GC_REG result,MirTypes.GP_IMM_ANY 1)],
			[], MirTypes.ABSENT, []), [], [])))
d2038 1
a2038 1
		      ((code @@ code' @@
d2040 1
a2040 1
                        (if constantp andalso constant_value < 0
d2056 1
a2056 1
                         MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)],
d2063 1
a2063 1
			exn_blocks, MirTypes.PRESENT finish_tag, []), [], [])))
d2124 1
a2124 1
		      ((code @@ code' @@ code'' @@
d2142 1
a2142 1
                         MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)],
d2198 1
a2198 1
                        [MirTypes.UNARY(MirTypes.MOVE, res1, MirTypes.GP_IMM_INT 0)]), [], [])))
d2268 3
a2270 1
	      ((Mir_Utils.ONE reg, ((code, [], MirTypes.ABSENT, []), [], [])), pos,
d2375 2
a2376 1
	 Mir_Utils.combine(the_code, ((new_code, [], MirTypes.ABSENT, []), [], [])))
d2399 1
a2399 1
	      (([MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
d2403 1
a2403 1
	      []), [], [])))
d2535 1
a2535 1
	    ((MirTypes.COMMENT comment :: (case regs of
d2542 2
a2543 2
	      [final_branch],
	      [], MirTypes.ABSENT, []), [], []))
d2548 2
a2549 1
	      (MirTypes.BLOCK(new_tag, first) :: blocks, new_tag, values, procs)
d2551 2
a2552 2
	      (MirTypes.BLOCK(new_tag, first) ::
	        MirTypes.BLOCK(tag, last) :: blocks,
d2649 1
a2649 1
	(((if low = 0 then
d2672 4
a2675 1
		MirTypes.ABSENT => [MirTypes.BLOCK(tag, first @@ end_code)]
d2677 3
a2679 2
		[MirTypes.BLOCK(tag, first),
		  MirTypes.BLOCK(tag1, last @@ end_code)]
d2683 1
a2683 1
	  MirTypes.ABSENT, []), values, procs)
d2693 3
a2695 2
	(([MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG def_tag),
	  MirTypes.COMMENT"Default or end"], [], MirTypes.ABSENT, []), [], [])
d2706 7
a2712 2
		(the_test, MirTypes.BLOCK(tag, first @@ end_code) :: blocks,
		  MirTypes.ABSENT, [])
d2714 9
a2722 2
		(the_test, MirTypes.BLOCK(tag, first) :: blocks @@
		  [MirTypes.BLOCK(tag', last @@ end_code)], MirTypes.ABSENT, [])
d2767 4
a2770 3
		 ((([MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG first_tag)],
		    [], MirTypes.PRESENT first_tag, []), [], []), code),
		 ((end_code, [], MirTypes.ABSENT, []), [], []))
d2822 2
a2823 2
		  [MirTypes.TEST(MirTypes.BEQ, tag, reg,
				 MirTypes.GP_IMM_INT i)]
d2850 1
a2850 1
	      [MirTypes.STOREFPOP(MirTypes.FLD, fp_op,
d2869 1
a2869 1
	      Mir_Utils.combine((([], [], MirTypes.ABSENT, []), tags_code, []),
d2901 1
a2901 1
		       (([], [], MirTypes.ABSENT, []), [], []), false,
d2904 5
a2908 2
		  (_, ((app_code, [], MirTypes.ABSENT, []), [], [])) =>
		    app_code
d2911 2
a2912 1
	      [MirTypes.STOREOP(MirTypes.LD, scon_reg,
d2926 4
a2929 3
		MirTypes.COMMENT"Call external STRINGEQ"] @@
	      app_code @@
	      [MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, 2),
d2932 1
a2932 1
			     MirTypes.GP_IMM_INT 1)]
d2946 1
a2946 1
	      Mir_Utils.combine((([], [], MirTypes.ABSENT, []), tags_code, []),
d2972 5
a2976 1
		  ((code, [], MirTypes.ABSENT, []), [], [])) => (reg, code)
d2981 2
a2982 1
	    the_code @@ [MirTypes.TEST(MirTypes.BEQ, tag, reg, regs)]
d2995 1
a2995 1
	    val first' = rev first
d3016 2
a3017 1
		      (map (fn x => MirPrint.opcode x ^ "\n") first) @@
d3019 2
a3020 1
		       (map (fn x => MirPrint.opcode x ^ "\n") last)))))
d3053 2
a3054 1
		      (map (fn x => MirPrint.opcode x ^ "\n") first) @@
d3056 2
a3057 1
		       (map (fn x => MirPrint.opcode x ^ "\n") last)))))
d3061 2
a3062 1
	    Mir_Utils.combine(the_code, ((new_first, [], tag_opt, last), values, procs))
d3069 2
a3070 1
	      ((ptr_code @@ main_def, [], MirTypes.ABSENT, []), [], [])),
d3072 2
a3073 1
	        (([], blocks1 @@ blocks2, MirTypes.PRESENT end_tag, []),
d3089 2
a3090 1
      (Mir_Utils.ONE reg, ((code, [], MirTypes.ABSENT, []), [], []))
d3122 1
a3122 1
	    (([MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
d3127 1
a3127 1
	      MirTypes.ABSENT, []),
d3143 33
a3175 1
      val (_, free) = (*LambdaSub.*)bounds_and_frees{lexp=fcn, size=0}
d3180 2
a3181 2
	      Set.add_member(Map.lookup(Pervasives.STRINGEQ, prim_to_lambda),
			     free)
d3185 5
a3189 3
	  Set.union(free',
		    Set.map (fn x => Map.lookup(x, prim_to_lambda))
		    (Library.implicit_external_references fcn))
d3201 2
a3202 2
	    (reg, code @@
	      [MirTypes.COMMENT"Copy in function pointer",
d3208 1
a3208 1
				 MirTypes.GP_IMM_ANY ~1)],
d3240 1
a3240 1
	(comment_string @@
d3255 2
a3256 2
             else nil),
	  [], MirTypes.ABSENT, [])
d3258 3
a3260 3
	(final_code @@
	  [MirTypes.RTS],
	  [], MirTypes.ABSENT, [])
d3271 2
a3272 1
		       MirTypes.BLOCK(tag, first) :: blocks @@
d3275 2
a3276 1
	| MirTypes.PRESENT tag => [MirTypes.BLOCK(tag, last)]))]
d3278 1
a3278 1
      (Mir_Utils.ONE(Mir_Utils.INT(Mir_Utils.gp_from_reg cl_reg)), ((code, [], MirTypes.ABSENT, []), values,
d3311 1
a3311 5
      val free = Lists.reducel Set.union
	(Set.empty_set,
	map (fn x => Set.setdiff(#2 ((*LambdaSub.*)bounds_and_frees x),
				 Set.list_to_set lv_list))
	le_list)
d3313 36
d3350 1
a3350 1
	  val lambdas_required =
d3352 2
a3353 1
	      Set.singleton(Map.lookup(Pervasives.STRINGEQ, prim_to_lambda))
d3355 1
a3355 1
	      Set.empty_set
d3357 6
a3362 5
	  Set.union(Set.union(lambdas_required, free),
		    Set.map
		    (fn x => Map.lookup(x, prim_to_lambda))
		    (Library.implicit_external_references(AugLambda.STRUCT
							  le_list)))
d3412 4
a3415 3
      val code = Lists.reducer op @@
	((code @@ new_closure_code) ::
	  [MirTypes.COMMENT"Copy in function pointers"] :: (map
d3417 1
a3417 1
	    [MirTypes.STOREOP(MirTypes.LD, gc_reg,
d3423 1
a3423 1
	  offsets), [])
d3427 9
a3435 7
      | _ => code @@
	  (MirTypes.UNARY(MirTypes.MOVE, gc_reg, MirTypes.GP_IMM_INT 0) ::
	  map
	  (fn x =>
	   MirTypes.STOREOP(MirTypes.ST, gc_reg, cl_reg,
			    MirTypes.GP_IMM_ANY(4*(x-1)-1)))
	  (Lists.tl offsets))
d3468 1
a3468 1
	    (((arg_copy, [], MirTypes.ABSENT, []), [], []),
d3508 2
a3509 1
	       (([MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)], [],
d3512 2
a3513 2
                   then [MirTypes.PROFILER(MirTypes.GC_REG(MirTypes.GC.new()))]
                 else nil), [], [])
d3556 1
a3556 1
	((comment_for_name @@
d3565 2
a3566 2
			    MirTypes.GP_GC_REG caller_arg)]),
	[], MirTypes.ABSENT, []), [], [])
d3571 3
a3573 3
	     ((final_code @@
	      [MirTypes.RTS],
	      [], MirTypes.ABSENT, []), [], []))
d3591 2
a3592 1
			     MirTypes.BLOCK(tag, first) :: blocks @@
d3595 2
a3596 1
	| MirTypes.PRESENT tag => [MirTypes.BLOCK(tag, last)]))))
d3611 1
a3611 1
      (regs, ((code @@ first, blocks , tag_opt, last),
d3632 2
a3633 1
	Mir_Utils.combine(code, ((final_code, [], MirTypes.ABSENT, []), [], []))
d3721 2
a3722 1
		((frame_setup, [exn_end], MirTypes.ABSENT, []), [], []))
d3736 2
a3737 1
		((main_end, [], MirTypes.PRESENT end_tag, []), [], []))
d3762 1
a3762 1
	(MirTypes.GP_GC_REG callee_arg, last @@ new_code)
d3767 4
a3770 2
	 last @@ [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_arg,
				arg)])
d3774 4
a3777 2
	 last @@ [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_arg,
				MirTypes.GP_IMM_INT 0)])
d3780 1
a3780 1
    val last'' = last' @@ [MirTypes.RTS]
d3783 10
a3792 8
      (if ! generate_profiling
         then
           [MirTypes.ENTER,
            MirTypes.PROFILER (MirTypes.GC_REG(MirTypes.GC.new()))]
       else
         [MirTypes.ENTER]) @@
      (MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_closure,
                      MirTypes.GP_GC_REG callee_arg) :: first)
d3795 2
a3796 2
      case (tag_opt, last) of
	(MirTypes.ABSENT, []) => (entry @@ last'', blocks)
d3798 2
a3799 1
	  (entry, MirTypes.BLOCK(tag, last'') :: blocks)
d3816 2
a3817 1
		    MirTypes.BLOCK(new_tag, first) :: blocks)
a3862 5
(*
      Timer.xtime
      ("register reduction", true,
       fn () => Mir_Data.reduce_registers new_procs)
*)
@


1.139
log
@Rewritten to use augmented lambda calculus to avoid recalculating
number of static garbage collectable objects within lambda expressions
Also fixed superfluous ALLOCs during integer relational operations
@
text
@d4 5
d3589 8
a3596 3
      MirTypes.ENTER ::
      MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG callee_closure,
		     MirTypes.GP_GC_REG callee_arg) :: first
@


1.138
log
@Arrays no longer have their size stored as one of the elements
@
text
@d4 3
d510 1
d529 1
d544 1
d575 1
a575 1

d579 2
a580 1
    Tail.LambdaTypes = Curry.LambdaTypes = Mir_Utils.LambdaTypes
d585 1
d592 1
d641 167
d824 19
d844 1
d846 18
d874 1
a874 1
      Set.set_to_list(Mir_Utils.get_string new_lambda_exp)
d879 8
a886 8
    fun find_ext_string chars =
      let
	fun find_sub(chars, []) = Crash.impossible"string missing"
	| find_sub(chars, (x, y) :: xs) =
	  if chars = x then y else find_sub(chars, xs)
      in
	find_sub(chars, ext_string_list)
      end
d888 2
a889 17
    val (fn_bindings, escape_map) =
      Timer.xtime
      ("calculating escape map", true,
       fn () =>
       let
	 val fn_bindings = InterProc.binding_list new_lambda_exp
       in
	 (fn_bindings, InterProc.escape_map fn_bindings)
       end)
(*
    val _ = Print.print"Calculating escape map..."
    val fn_bindings = InterProc.binding_list new_lambda_exp
    val escape_map = InterProc.escape_map fn_bindings
    val _ = Print.print"done\n"
*)
    val top_lambdas = Map.domain escape_map
    (* Should be the lambda variables representing all the functions *)
d891 4
a894 4
    val _ = Diagnostic.output 5
      (fn _ => (["Lambdas representing functions"] @@ 
                (map (fn x => " " ^ LambdaTypes.printLVar x)
                 (Map.domain escape_map))))
d899 2
a900 2
    fun cg_bind(lexp, env, closure, static_offset, start_at, funs_in_closure,
		fn_tag_list) =
d902 1
d904 1
d947 2
a948 1
	 Mir_Utils.combine(the_code, ((more_code, [], MirTypes.ABSENT, []), [], [])),
d956 1
a956 1
		     funs_in_closure, fn_tag_list) =
d969 3
a971 1
    and cg_sub(arg as LambdaTypes.APP(LambdaTypes.BUILTIN prim, lexp), env, closure,
d984 1
d989 1
d994 1
a994 1
	  LambdaTypes.SCON(Ident.STRING chars) =>
d1023 1
a1023 1
            LambdaTypes.VAR(Map.lookup(exception_needed, prim_to_lambda))
d1031 4
a1034 3
	    case cg_sub(LambdaTypes.RAISE(exception_packet), env, closure,
                         static_offset, start_at, funs_in_closure,
                         fn_tag_list, false, [])
d1619 1
d1621 1
d1632 1
a1632 1
            LambdaTypes.VAR(Map.lookup(primitive, prim_to_lambda))
d1644 3
a1646 2
	      cg_sub(LambdaTypes.APP(polymorphic_equality,
	      LambdaTypes.VAR lvar), env', closure,
d2141 4
a2144 3
    | cg_sub(arg as LambdaTypes.APP(LambdaTypes.FN(lvar, lexp1,_), lexp2), env, closure,
	     static_offset, start_at, funs_in_closure, fn_tag_list, tails,
	     tuple_bindings) =
d2146 1
d2151 1
d2163 3
a2165 1
    | cg_sub(arg as LambdaTypes.APP(le1, le2), env, closure, static_offset, start_at,
d2170 1
d2175 1
d2177 1
a2177 1
	LambdaTypes.VAR lv =>
d2181 1
d2183 1
d2187 1
a2187 1
	  LambdaTypes.VAR lvar =>
a2211 6
(*
      val _ =
	Diagnostic.output 0
	(fn i => ["Mir generating APP\n",
	LambdaPrint.string_of_lambda arg])
*)
d2213 2
a2214 1
	Mir_Utils.new_do_app(fn_reg, fn_code, arg_reg, arg_code, not can_stack_args,
d2246 1
a2246 1
    | cg_sub(arg as LambdaTypes.STRUCT le_list, env, closure, static_offset, start_at,
d2252 1
d2257 2
d2260 13
d2279 1
d2281 2
a2282 1
	  Lists.reducer Mir_Utils.combine
d2299 2
a2300 1
    | cg_sub(arg as LambdaTypes.SELECT({index, size}, lexp), env, closure,
d2303 1
d2308 1
d2329 7
a2335 1
	  (Mir_Utils.ONE(Lists.nth(index, many)), the_code)
d2337 3
a2339 1
    | cg_sub(arg as LambdaTypes.SWITCH(lexp, tag_le_list, def1, def2), env, closure,
d2344 1
d2349 1
d2351 1
a2351 1
	LambdaTypes.APP(LambdaTypes.BUILTIN prim, _) =>
d2367 1
d2369 3
a2371 1
      val positions =
d2373 12
a2384 5
      val list_size = Lists.reducel op+
	(0, map (fn (_, x) => Mir_Utils.count_gc_objects x) tag_le_list)
      val tag_sizes = Lists.reducel op+
	(0, map (Mir_Utils.count_gc_tags o #1) tag_le_list)
      val tag_positions = 
d2387 1
d2390 1
a2390 1
      | LambdaTypes.PRESENT le => Mir_Utils.count_gc_objects le
d2393 1
a2393 1
      | LambdaTypes.PRESENT le => Mir_Utils.count_gc_objects le
d2397 6
a2402 2
	    val (prim, arg) = case lexp of
	      LambdaTypes.APP(LambdaTypes.BUILTIN prim, arg) => (prim, arg)
d2404 6
a2409 3
	    val lvar = LambdaTypes.new_LVar()
	    val (reg, code, static_offset', start_at') =
	      cg_bind(arg, env, closure, static_offset, start_at,
d2411 1
d2414 12
a2425 2
	    val new_test = LambdaTypes.APP(LambdaTypes.BUILTIN prim,
					   LambdaTypes.VAR lvar)
d2449 1
a2449 1
      | LambdaTypes.PRESENT lexp =>
d2510 1
a2510 1
	(fn ((t, x), le_offset) =>
d2525 1
a2525 1
	    ([(LambdaTypes.CON_TAG t1, _, tag)], LambdaTypes.PRESENT _) =>
d2527 2
a2528 2
	  | ([(LambdaTypes.CON_TAG t1, _, tag1),
	      (LambdaTypes.CON_TAG t2, _, tag2)], LambdaTypes.ABSENT) =>
d2642 1
a2642 1
      | (LambdaTypes.CON_TAG _, _) :: rest =>
d2648 1
a2648 1
	    (fn (LambdaTypes.CON_TAG i, le, tag) => (i, le, tag)
d2690 1
a2690 1
      | (LambdaTypes.SCON_TAG x, _) :: rest =>
d2700 1
a2700 1
	      (map (fn (LambdaTypes.SCON_TAG(Ident.INT i), code, tag) =>
d2734 1
a2734 1
	      map (fn ((LambdaTypes.SCON_TAG(Ident.REAL _), code, tag), p) =>
d2763 1
a2763 1
		  LambdaTypes.SCON_TAG(scon as Ident.REAL _) =>
d2778 1
a2778 1
	      (fn ((LambdaTypes.SCON_TAG(Ident.STRING _), code, tag), p) =>
d2796 1
a2796 1
		cg_sub(LambdaTypes.VAR(Map.lookup(Pervasives.STRINGEQ,
d2835 1
a2835 1
		 LambdaTypes.SCON_TAG(scon as Ident.STRING _) =>
d2847 1
a2847 1
      | (LambdaTypes.EXP_TAG _, _) :: rest =>
d2852 1
a2852 1
	    (fn (LambdaTypes.EXP_TAG le, code, tag) =>
d2963 1
a2963 1
    | cg_sub(arg as LambdaTypes.VAR lvar, env, closure, _, _, funs_in_closure,
d2966 1
d2971 1
d2976 1
a2976 1
    | cg_sub(arg as LambdaTypes.INT i, _, _, _, _, _, _, _, _) =
d2978 1
d2983 1
d2987 1
a2987 1
    | cg_sub(arg as LambdaTypes.SCON scon, _, _, static_offset, start_at,
d2990 1
d2995 1
d3016 4
a3019 2
    | cg_sub(fcn as LambdaTypes.FN(lvar, lexp,name_string), env, closure, static_offset,
	   start_at, funs_in_closure, fn_tag_list, _, _) =
d3021 1
d3026 2
a3027 1
      val (_, free) = LambdaSub.bounds_and_frees fcn
d3030 4
a3033 3
	  val lambdas_required =
	    if Mir_Utils.needs_prim(Pervasives.STRINGEQ, fcn) then
	      Set.singleton(Map.lookup(Pervasives.STRINGEQ, prim_to_lambda))
d3035 1
a3035 1
	      Set.empty_set
d3037 1
a3037 1
	  Set.union(Set.union(lambdas_required, free),
d3041 1
d3043 1
d3117 1
a3117 1
		       {leaf = not (Mir_Utils.makes_calls lexp),
d3129 2
a3130 1
    | cg_sub(exp as LambdaTypes.LETREC(lv_list, le_list, lexp), env, closure,
d3133 1
d3138 1
d3141 1
d3143 1
a3143 1
	(fn (lexp as LambdaTypes.FN _) => lexp
d3145 1
d3150 1
a3150 1
	(fn LambdaTypes.FN(lv, le,_) => (lv, le)
d3155 1
a3155 1
	(fn LambdaTypes.FN(_,_,name) => name
d3161 1
a3161 1
	map (fn x => Set.setdiff(#2 (LambdaSub.bounds_and_frees x),
d3167 1
a3167 1
	    if Mir_Utils.lneeds_prim(Pervasives.STRINGEQ, le_list'') then
d3175 1
a3175 1
		    (Library.implicit_external_references(LambdaTypes.STRUCT
d3180 7
a3186 2
	Lists.reducel op+ (0, map Mir_Utils.count_gc_objects le_list'')
      val positions = Mir_Utils.gc_list_positions(0, Mir_Utils.count_gc_objects, le_list'', [])
d3296 1
a3296 1
	 (fn (lv, LambdaTypes.SELECT({index = index, ...}, _)) =>
d3423 1
a3423 1
    | cg_sub(arg as LambdaTypes.RAISE le, env, closure, static_offset,
d3426 1
d3431 1
d3444 4
a3447 2
    | cg_sub(hand as LambdaTypes.HANDLE(le, le'), env, closure, static_offset,
	     start_at, funs_in_closure, fn_tag_list, _, _) =
d3449 1
d3455 1
d3468 1
a3468 1
	cg_sub(LambdaSub.eta_abstract (le',"Handler in _mir_cg"), env, closure,
d3548 1
a3548 1
    | cg_sub(prim as LambdaTypes.BUILTIN _, env, closure, static_offset,
d3552 2
a3553 1
	  (Print.print ("The bad primitive\n" ^ LambdaPrint.string_of_lambda prim))
d3654 2
a3655 1
    val new_procs' =
d3659 1
@


1.137
log
@Added code to reduce number of registers used per block
@
text
@d4 3
d1586 1
a1586 1
            val (constantp,constant_value,real_constant_value) =
d1590 3
a1592 4
                      (* Make it double-word aligned *)
                      MirTypes.GP_IMM_INT v => (true,v+1,v )
                    | _ => (false,0,0))
               | _ => (false,0,0))
d1594 1
a1594 1
	    val ((new_reg, code),(new_reg', code'),(new_reg'',code'')) =
d1598 1
a1598 2
                   Mir_Utils.send_to_new_reg(Mir_Utils.ONE(Mir_Utils.INT size)),
                   Mir_Utils.send_to_reg(Mir_Utils.ONE(Mir_Utils.INT(size))))
a1602 1
                    val new_reg'' = MirTypes.GC.new()
d1611 1
a1611 4
                                                MirTypes.GP_IMM_ANY ~1)]),
		    (MirTypes.GP_GC_REG new_reg'',[MirTypes.STOREOP(MirTypes.LD,
                                                 MirTypes.GC_REG new_reg'',
                                                 Mir_Utils.reg_from_gp reg, MirTypes.GP_IMM_ANY ~1)]))
d1629 1
a1629 1
                     ((code @@ code' @@ code'' @@
d1632 1
a1632 1
                            (if real_constant_value >= 0
d1640 14
a1653 29
                       MirTypes.BLOCK(main_tag,
                                      (if constantp
                                          then 
                                            [MirTypes.UNARY(MirTypes.MOVE,
                                                            Mir_Utils.reg_from_gp new_reg',
                                                            MirTypes.GP_IMM_INT constant_value)]
                                        else
                                          [MirTypes.BINARY(MirTypes.ADD, 
                                                           Mir_Utils.reg_from_gp new_reg',
                                                           new_reg',MirTypes.GP_IMM_ANY 4),
                                          MirTypes.BINARY(MirTypes.AND, 
                                                           MirTypes.GC_REG MirRegisters.global,
                                                           new_reg',MirTypes.GP_IMM_ANY 4),
                                          MirTypes.TEST(MirTypes.BGT, after_alignment,               
                                                        MirTypes.GP_GC_REG MirRegisters.global,
                                                        MirTypes.GP_IMM_INT 0),
                                          MirTypes.BINARY(MirTypes.ADD, 
                                                          Mir_Utils.reg_from_gp new_reg', new_reg',MirTypes.GP_IMM_ANY 4)]) @@
                                      [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG after_alignment)]) ::
                       MirTypes.BLOCK(after_alignment,
                                      [MirTypes.COMMENT"Array creation operation",
                                       MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, 
                                                         (if constantp
                                                            then MirTypes.GP_IMM_INT constant_value
                                                          else new_reg'))] @@
                                      [MirTypes.STOREOP(MirTypes.STREF, Mir_Utils.reg_from_gp new_reg'',
                                                             res1,
                                                             MirTypes.GP_IMM_ANY 9)] @@
                                         [MirTypes.COMMENT"Initialise all of the values"] @@
d1668 1
a1668 1
							MirTypes.GP_IMM_ANY 13),
d1700 5
a1704 1
			 MirTypes.STOREOP(MirTypes.LD,res1,Mir_Utils.reg_from_gp new_reg, MirTypes.GP_IMM_ANY 9)],
d1764 6
a1769 2
                                          MirTypes.GP_IMM_ANY 9),
                         MirTypes.TEST(MirTypes.BGE, main_tag, MirTypes.GP_GC_REG checksize, new_reg),
d1775 1
a1775 1
					  MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 13),
d1850 7
a1856 3
                                             MirTypes.GP_IMM_ANY 9),
                           MirTypes.TEST(MirTypes.BGT, main_tag, MirTypes.GP_GC_REG checksize, new_reg),
                           MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)],
d1862 1
a1862 1
                                                         MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 13),
d3299 1
a3299 1
      MirTypes.PROC("Setup procedure for " ^ filename ^ ":1:1",
@


1.136
log
@First version of the profiler
@
text
@d4 3
d509 1
d526 1
d532 1
d541 1
d563 1
d565 1
d573 1
a573 1
    MirPrint.MirTypes = Mir_Utils.MirTypes
d589 11
d671 10
d685 1
d1409 1
d1425 12
a1436 4
	  val poly_code as (reg, code) =
	      cg_sub(LambdaTypes.APP(polymorphic_equality, lexp), env, closure,
		     static_offset, start_at, funs_in_closure, fn_tag_list,
		     tails, [])
d1482 1
a1482 1
		    (code,
d1487 2
a1488 4
		(Mir_Utils.ONE(Mir_Utils.INT(MirTypes.GP_GC_REG res_reg)), new_code)
(*
		poly_code
*)
d1491 3
a1493 1
	      poly_code
d2027 1
a2027 1
	   Lists.reducel
d2029 1
a2029 1
	   ([], map
d2031 1
a2031 1
	    procs_list))))
d2056 2
a2057 2
	  Lists.reducel Mir_Utils.combine
	  (no_code, map #2 reg_code_list)
d2068 1
a2068 1
	val new_code = Lists.reducel op @@ ([], map #2 new_reg_code_list)
d2297 1
a2297 1
	  Lists.reducel op @@ ([], map (#2 o #2 o #2) val_code_tag_list)
d2299 1
a2299 1
	  Lists.reducel op @@ ([], map (#3 o #2 o #2) val_code_tag_list)
d2315 3
a2317 3
	  Lists.reducel op @@
	  (end_blocks, map
	  (fn (_, (regs, ((first, blocks, tag_opt, last), _, _)),
d2330 1
a2330 1
	  val_code_tag_list),
d2935 2
a2936 2
      val code = Lists.reducel op @@
	(code @@ new_closure_code,
d2945 1
a2945 1
	  offsets))
d3121 2
a3122 2
	Lists.reducel op @@
	([], map #1 fn_val_procs_proc_list)
d3124 2
a3125 2
	Lists.reducel op @@
	([], map #2 fn_val_procs_proc_list)
d3337 1
a3337 1
      Lists.reducel
d3339 1
a3339 1
      ([], map
d3342 1
a3342 1
       new_procs)
d3356 4
d3362 1
a3362 1
		  values, new_procs)
@


1.135
log
@Split out utility functions into separate file. Recoded do_app for
better reliability
@
text
@d4 4
d580 1
d609 1
a609 1
  fun mir_cg(lambda_exp, top_env) =
d1897 1
a1897 1
    | cg_sub(arg as LambdaTypes.APP(LambdaTypes.FN(lvar, lexp1), lexp2), env, closure,
d2702 1
a2702 1
    | cg_sub(fcn as LambdaTypes.FN(lvar, lexp), env, closure, static_offset,
d2763 5
d2769 2
a2770 1
	((if MirRegisters.automatic_callee then
d2781 4
a2784 1
                            MirTypes.GP_GC_REG callee_arg)],
d2793 2
a2794 1
	[MirTypes.PROC(tag,
d2819 1
a2819 1
	 | lexp => LambdaSub.eta_abstract lexp)
d2824 1
a2824 1
	(fn LambdaTypes.FN(lv, le) => (lv, le)
d2827 5
d2989 4
a2992 1
		 MirTypes.PRESENT loop_tag, []), [], [])
d3028 9
a3036 2
      val entry_code = 
	((if MirRegisters.automatic_callee then
d3044 1
a3044 1
			    MirTypes.GP_GC_REG caller_arg)],
d3046 2
d3056 3
a3058 3
	(fn ((_, fn_code), exit_code) =>
	  Mir_Utils.combine(entry_code, Mir_Utils.combine(fn_code, exit_code)))
	(Lists.zip(fn_reg_code_list, exit_code_list))
d3061 1
a3061 1
	(fn (tag, ((first, blocks, tag_opt, last), vals, procs)) =>
d3063 2
a3064 1
	       MirTypes.PROC(tag,
d3074 1
a3074 1
	(Lists.zip(tags, fn_list))
d3131 1
a3131 1
	cg_sub(LambdaSub.eta_abstract le', env, closure,
d3265 2
a3266 1
      MirTypes.PROC(new_tag,
d3275 1
a3275 1
    fun sort_out_small_exit_blocks(MirTypes.PROC(tag, params, blocks)) =
d3287 1
a3287 1
	MirTypes.PROC(tag, params, block_list)
d3301 1
a3301 1
	map (fn MirTypes.PROC{1=tag, ...} => tag) proc_set)
@


1.134
log
@Fixed precedence problem in source between @@ and ::
@
text
@d4 3
d521 2
a523 1
require "mirprint";
d551 1
d557 1
a557 1
    Tail.LambdaTypes = Curry.LambdaTypes
d560 1
a560 1
    MirPrint.MirTypes
d566 2
a575 2
  fun rev_app([], result) = result
  | rev_app(x :: xs, result) = rev_app(xs, x :: result)
a576 13
  fun rev x = rev_app(x, [])

  fun app([], result) = result
  | app(result, []) = result
  | app(x, result) = rev_app(rev x, result)

  fun rev_fold_append([], result) = result
  | rev_fold_append(x :: xs, result) =
    rev_fold_append(xs, app(x, result))

  fun fold_append(head, the_list) =
    rev_fold_append(rev_app(the_list, [head]), [])

a601 487
  fun needs_prim(prim, le) =
    Set.is_member(prim, Library.external_references le)
  (* Used for spotting implicit requirements such as STRINGEQ for SWITCH *)

  fun lneeds_prim(prim, le_list) =
    let
      fun lneeds [] = false
      | lneeds(le :: rest) = needs_prim(prim, le) orelse lneeds rest
    in
      lneeds le_list
    end

  fun makes_calls(LambdaTypes.VAR _) = false
    | makes_calls(LambdaTypes.APP(LambdaTypes.FN(lv, le), le')) =
      makes_calls le orelse makes_calls le'
    | makes_calls(LambdaTypes.APP(LambdaTypes.BUILTIN _,
				  LambdaTypes.STRUCT le_list)) =
      makes_calls_list le_list
    | makes_calls(LambdaTypes.APP(LambdaTypes.BUILTIN _, le)) =
      makes_calls le
    | makes_calls(LambdaTypes.APP(le, le')) = true
    | makes_calls(LambdaTypes.FN(lv, lexp)) = true
    | makes_calls(LambdaTypes.LETREC(lv_list, le_list, lexp)) = true
    | makes_calls(LambdaTypes.SWITCH(le, tag_le_list, le1_opt, le2_opt)) =
      let fun count_tag_list [] = false
	| count_tag_list((tag, le) :: rest) =
	  (case tag of
	    LambdaTypes.EXP_TAG lexp => makes_calls lexp
	  | _ => false) orelse makes_calls le orelse count_tag_list rest
	fun count_le_opt LambdaTypes.ABSENT = false
	| count_le_opt(LambdaTypes.PRESENT le) = makes_calls le
      in
	makes_calls le orelse count_tag_list tag_le_list orelse
	count_le_opt le1_opt orelse count_le_opt le2_opt
      end
    | makes_calls(LambdaTypes.STRUCT le_list) = true
    | makes_calls(LambdaTypes.SELECT(_, le)) = makes_calls le
    | makes_calls(LambdaTypes.RAISE le) = true
    | makes_calls(LambdaTypes.HANDLE(le, le')) = true
    | makes_calls(LambdaTypes.SCON _) = false
    | makes_calls(LambdaTypes.INT _) = false
    | makes_calls(LambdaTypes.BUILTIN _) = false

  and makes_calls_list [] = false
    | makes_calls_list (x :: xs) = makes_calls x orelse makes_calls_list xs

(*
  fun count_gc_osub(n, LambdaTypes.VAR _) = n
    | count_gc_osub(n, LambdaTypes.APP(LambdaTypes.FN(lv, le), le')) =
      count_gc_osub(count_gc_osub(n, le'), le)
    | count_gc_osub(n, LambdaTypes.APP(LambdaTypes.BUILTIN prim, le')) =
      if prim = Pervasives.LOAD_STRING then n else count_gc_osub(n, le')
    | count_gc_osub(n, LambdaTypes.APP(le, le')) =
      count_gc_osub(count_gc_osub(n, le'), le)
    | count_gc_osub(n, LambdaTypes.FN(lv, lexp)) = count_gc_osub(n + 1, lexp)
    | count_gc_osub(n, LambdaTypes.LETREC(lv_list, le_list, lexp)) =
      Lists.reducel op +
      (count_gc_osub(n, lexp),
       map (fn x => count_gc_osub(0, LambdaSub.eta_abstract x)) le_list)
    | count_gc_osub(n, LambdaTypes.SCON scon) =
	(case scon of
	  Ident.INT _ => n
	| _ => n + 1)
    | count_gc_osub(n, LambdaTypes.INT _) = n
    | count_gc_osub(n, LambdaTypes.SWITCH(le, tag_le_list, le1_opt, le2_opt)) =
      let
	fun count_tag_list(n, []) = n
	| count_tag_list(n, (tag, le) :: rest) =
	  count_tag_list(count_gc_osub(n + (case tag of
	    LambdaTypes.EXP_TAG lexp =>
	      let
		val count = count_gc_osub(0, lexp)
		val _ =
		  if count <> 0 then
		    Crash.impossible"EXP_TAG contains static gc"
		  else ()
	      in
		count
	      end
	  | LambdaTypes.SCON_TAG(Ident.REAL _) => 1
	  | LambdaTypes.SCON_TAG(Ident.STRING _) => 1
	  | _ => 0), le), rest)
	fun count_le_opt LambdaTypes.ABSENT = 0
	| count_le_opt(LambdaTypes.PRESENT le) = count_gc_osub(0, le)
      in
	count_tag_list
	(count_gc_osub(n + count_le_opt le1_opt + count_le_opt le2_opt, le),
	 tag_le_list)
      end
    | count_gc_osub(n, LambdaTypes.STRUCT le_list) =
      Lists.reducel op + (n, map (fn x => count_gc_osub(0, x)) le_list)
    | count_gc_osub(n, LambdaTypes.SELECT(_, le)) = count_gc_osub(n, le)
    | count_gc_osub(n, LambdaTypes.RAISE le) = count_gc_osub(n, le)
    | count_gc_osub(n, LambdaTypes.HANDLE(le, le' as LambdaTypes.FN _)) =
      count_gc_osub(count_gc_osub(n, le'), le)
    | count_gc_osub(n, LambdaTypes.HANDLE(le, le')) =
      count_gc_osub(count_gc_osub(n, LambdaSub.eta_abstract le'), le)
    | count_gc_osub(n, LambdaTypes.BUILTIN _) = n

  fun count_gc_objects le = count_gc_osub(0, le)
*)

  fun count_gc_objects(LambdaTypes.VAR _) = 0
    | count_gc_objects(LambdaTypes.APP(LambdaTypes.FN(lv, le), le')) =
      count_gc_objects le + count_gc_objects le'
    | count_gc_objects(LambdaTypes.APP(LambdaTypes.BUILTIN prim, le')) =
      if prim = Pervasives.LOAD_STRING then 0 else count_gc_objects le'
    | count_gc_objects(LambdaTypes.APP(le, le')) =
      count_gc_objects le + count_gc_objects le'
    | count_gc_objects(LambdaTypes.FN(lv, lexp)) = 1 + count_gc_objects lexp
    | count_gc_objects(LambdaTypes.LETREC(lv_list, le_list, lexp)) =
      Lists.reducel op +
      (count_gc_objects lexp,
       map (count_gc_objects o LambdaSub.eta_abstract) le_list)
    | count_gc_objects(LambdaTypes.SCON scon) =
	(case scon of
	  Ident.INT _ => 0
	| _ => 1)
    | count_gc_objects(LambdaTypes.INT _) = 0
    | count_gc_objects(LambdaTypes.SWITCH(le, tag_le_list, le1_opt, le2_opt)) =
      let fun count_tag_list [] = 0
	| count_tag_list((tag, le) :: rest) =
	  (case tag of
	    LambdaTypes.EXP_TAG lexp =>
	      if count_gc_objects lexp <> 0 then
		Crash.impossible"EXP_TAG contains static gc"
	      else 0
	  | LambdaTypes.SCON_TAG(Ident.REAL _) => 1
	  | LambdaTypes.SCON_TAG(Ident.STRING _) => 1
	  | _ => 0) + count_gc_objects le + count_tag_list rest
	fun count_le_opt LambdaTypes.ABSENT = 0
	| count_le_opt(LambdaTypes.PRESENT le) = count_gc_objects le
      in
	count_gc_objects le + count_tag_list tag_le_list +
	count_le_opt le1_opt + count_le_opt le2_opt
      end
    | count_gc_objects(LambdaTypes.STRUCT le_list) =
      Lists.reducel op + (0, map count_gc_objects le_list)
    | count_gc_objects(LambdaTypes.SELECT(_, le)) = count_gc_objects le
    | count_gc_objects(LambdaTypes.RAISE le) = count_gc_objects le
    | count_gc_objects(LambdaTypes.HANDLE(le, le' as LambdaTypes.FN _)) =
      count_gc_objects le + count_gc_objects le'
    | count_gc_objects(LambdaTypes.HANDLE(le, le')) =
      count_gc_objects le + count_gc_objects(LambdaSub.eta_abstract le')
    | count_gc_objects(LambdaTypes.BUILTIN _) = 0

  fun count_gc_tags(LambdaTypes.SCON_TAG(Ident.REAL _)) = 1
    | count_gc_tags(LambdaTypes.SCON_TAG(Ident.STRING _)) = 1
    | count_gc_tags _ = 0

  fun gp_from_reg(MirTypes.GC_REG x) = MirTypes.GP_GC_REG x
  | gp_from_reg(MirTypes.NON_GC_REG x) = MirTypes.GP_NON_GC_REG x

  fun reg_from_gp(MirTypes.GP_GC_REG x) = MirTypes.GC_REG x
  | reg_from_gp(MirTypes.GP_NON_GC_REG x) = MirTypes.NON_GC_REG x
  | reg_from_gp _ = Crash.impossible"reg_from_gp(IMM)"

  datatype reg_result =
    INT of MirTypes.gp_operand |
    REAL of MirTypes.fp_operand

  fun get_real(REAL fp_op) = (fp_op, [])
  | get_real(INT(MirTypes.GP_GC_REG reg_op)) =
    let
      val fp_op = MirTypes.FP_REG(MirTypes.FP.new())
    in
      (fp_op,
        [MirTypes.STOREFPOP(MirTypes.FLD, fp_op, MirTypes.GC_REG reg_op,
			    MirTypes.GP_IMM_ANY real_offset)])
    end
  | get_real _ = Crash.impossible"get_real bad value"

  fun save_real_to_reg(fp_op, reg) =
    (* Store as to a pointer (tag 1) *)
    [MirTypes.ALLOCATE(MirTypes.ALLOC_REAL, reg, MirTypes.GP_IMM_INT 0),
     MirTypes.STOREFPOP(MirTypes.FST, fp_op, reg,
			MirTypes.GP_IMM_ANY real_offset)]

  fun save_real(fp_op) =
    let
      val new_reg = MirTypes.GC.new()
      val new_r = MirTypes.GC_REG new_reg
    in
      (new_reg, save_real_to_reg(fp_op, new_r))
    end

  fun tuple_up_in_reg(reg_list, new_reg) =
  let
    val len = Lists.length reg_list
    (* Get the offset right for the pointer type used *)
    val alloc_op =
      MirTypes.ALLOCATE(MirTypes.ALLOC, MirTypes.GC_REG new_reg, MirTypes.GP_IMM_INT len)
    val reg_code_list =
      map
      (fn (REAL fp_op) =>
       let
	 val (reg, code) = save_real(fp_op)
       in
	 (INT(MirTypes.GP_GC_REG reg), code)
       end
       | reg => (reg, []))
      reg_list
    val reg_list = map #1 reg_code_list
    val start_code =
      Lists.reducel
      (fn (x, (y, z)) => x @@ z)
      ([], reg_code_list)
    val (number_list, _) =
      Lists.number_from(reg_list, ~1, 4, MirTypes.GP_IMM_ANY)
  in
    (new_reg, Lists.reducel op @@
      (start_code @@ [alloc_op],
        map (fn (INT(MirTypes.GP_GC_REG reg), imm) =>
	     [MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG reg,
			  MirTypes.GC_REG new_reg, imm)]
	     | (INT(MirTypes.GP_NON_GC_REG reg), imm) =>
	       [MirTypes.STOREOP(MirTypes.ST, MirTypes.NON_GC_REG reg,
		 MirTypes.GC_REG new_reg, imm)]
	     | (INT(i as MirTypes.GP_IMM_INT _), imm) =>
	       let
		 val new_reg' = MirTypes.GC.new()
	       in
		 [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg', i),
		   MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg',
		   MirTypes.GC_REG new_reg, imm)]
	       end
	     | (INT(i as MirTypes.GP_IMM_SYMB _), imm) =>
	       let
		 val new_reg' = MirTypes.GC.new()
	       in
		 [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg', i),
		   MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg',
		   MirTypes.GC_REG new_reg, imm)]
	       end
	     | (REAL _, _) =>
		 Crash.impossible"tuple_up_in_reg of unhandled REAL"
	     | _ => Crash.impossible"Tuple_up_in_reg untagged value")
      number_list))
  end

  fun stack_tuple_up_in_reg(reg_list, new_reg) =
  let
    val len = Lists.length reg_list
    val alloc_op =
      MirTypes.ALLOCATE_STACK(MirTypes.ALLOC, MirTypes.GC_REG new_reg, len,
			      MirTypes.ABSENT)
    val (number_list, _) =
      Lists.number_from(reg_list, ~1, 4, MirTypes.GP_IMM_ANY)
  in
    (new_reg, Lists.reducel op @@
      ([alloc_op],
        map (fn (INT(MirTypes.GP_GC_REG reg), imm) =>
	     [MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG reg,
			  MirTypes.GC_REG new_reg, imm)]
	     | (INT(MirTypes.GP_NON_GC_REG reg), imm) =>
	       [MirTypes.STOREOP(MirTypes.ST, MirTypes.NON_GC_REG reg,
		 MirTypes.GC_REG new_reg, imm)]
	     | (INT(i as MirTypes.GP_IMM_INT _), imm) =>
	       let
		 val new_reg' = MirTypes.GC.new()
	       in
		 [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg', i),
		   MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg',
		   MirTypes.GC_REG new_reg, imm)]
	       end
	     | (INT(i as MirTypes.GP_IMM_SYMB _), imm) =>
	       let
		 val new_reg' = MirTypes.GC.new()
	       in
		 [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg', i),
		   MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg',
		   MirTypes.GC_REG new_reg, imm)]
	       end
	     | (REAL fp_op, imm) =>
	       let
		 val (new_reg', code) = save_real(fp_op)
	       in
		 code @@
		 [MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg',
				   MirTypes.GC_REG new_reg,
				   imm)]
	       end
	     | _ => Crash.impossible"Tuple_up untagged value")
      number_list))
  end

  fun tuple_up reg_list =
    tuple_up_in_reg(reg_list, MirTypes.GC.new())

  fun convert_int chars =
  let
    val char_size = size chars
    fun convert(ptr, value) =
      if ptr >= char_size then value
      else
	convert(ptr+1, 10 * value + (ord(String.substring(chars, ptr, 1)) -
				     ord"0"))
  in
    case String.substring(chars, 0, 1) of
      "~" => 0 - convert(1, 0)
    | _ => convert(0, 0)
  end

  datatype cg_result =
    ONE of reg_result |
    LIST of reg_result list

  fun get_any_register(INT(MirTypes.GP_GC_REG reg)) = MirTypes.GC reg
  | get_any_register(INT(MirTypes.GP_NON_GC_REG reg)) = MirTypes.NON_GC reg
  | get_any_register(REAL(MirTypes.FP_REG reg)) = MirTypes.FLOAT reg
  | get_any_register _ =
    Crash.impossible"Bad value to get_any_register"

  fun cg_lvar(lvar, env, closure, funs_in_closure) =
    let
      val (offset, is_same_set, found) =
	if Mir_Env.is_in_closure(lvar, closure) then
	  let
	    val offset_in_closure = Mir_Env.lookup_in_closure(lvar, closure)
(*
	    val _ = Print.print("Looking up " ^ LambdaTypes.printLVar lvar ^
				" in closure gives " ^
				Integer.makestring offset_in_closure ^ "\n")
*)
	  in
	    (offset_in_closure, offset_in_closure < funs_in_closure * 2 - 1,
	     true)
	  end
	else (0, false, false)
    in
      if Mir_Env.is_in_lambda_env(lvar, env) then
	(((case Mir_Env.lookup_lambda(lvar, env) of
	     MirTypes.GC reg => INT(MirTypes.GP_GC_REG reg)
	   | MirTypes.NON_GC reg =>
	       INT(MirTypes.GP_NON_GC_REG reg)
	   | MirTypes.FLOAT reg => REAL(MirTypes.FP_REG reg)),
	     []), offset, is_same_set)
      else
	if found then
	  let
	    val new_reg = MirTypes.GC.new()
	  in
	    ((INT(MirTypes.GP_GC_REG new_reg),
	      [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
				MirTypes.GC_REG callee_closure,
				MirTypes.GP_IMM_ANY(~1 + 4*offset))]),
	     offset div 2, is_same_set)
	  (* Because the function pointers in a closure are interspersed *)
	  (* with zeroes, we must halve offset_in_closure above *)
	  end
	else
	  Crash.impossible("cg_lvar: Lambda variable " ^
			   LambdaTypes.printLVar lvar ^
			   " is neither in the closure nor the local bindings")
    end

  fun cg_lvar_fn(lvar, env, closure, funs_in_closure) =
    let
      val ((reg, code), pos, is_same_set) =
	cg_lvar(lvar, env, closure, funs_in_closure)
    in
      if is_same_set then
	let
	  val new_reg = MirTypes.GC.new()
	in
	  ((INT(MirTypes.GP_GC_REG new_reg),
	    [MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG new_reg,
			     MirTypes.GP_GC_REG callee_closure,
			     MirTypes.GP_IMM_INT (pos*2))]))
	(* Note use of recursive call info for dynamic access *)
	end
      else
	(reg, code)
    end

  fun list_of(i, v) =
    let
      fun list_sub(i, done) =
	if i <= 0 then done
	else list_sub(i-1, v :: done)
    in
      list_sub(i, [])
    end

  fun list_of_tags n =
    let
      fun list_sub(n, done) =
	if n <= 0 then done
	else list_sub(n-1, MirTypes.new_tag() :: done)
    in
      list_sub(n, [])
    end

  fun destruct_2_tuple(MirTypes.GP_GC_REG gc_reg) =
    let
      val reg1 = MirTypes.GC.new()
      val reg2 = MirTypes.GC.new() (* reasonable assumption *)
    in
      (MirTypes.GP_GC_REG reg1,
       MirTypes.GP_GC_REG reg2,
       [MirTypes.STOREOP(MirTypes.LD,
			 MirTypes.GC_REG reg1, MirTypes.GC_REG gc_reg,
			 MirTypes.GP_IMM_ANY ~1),
	MirTypes.STOREOP(MirTypes.LD,
			 MirTypes.GC_REG reg2, MirTypes.GC_REG gc_reg,
			 MirTypes.GP_IMM_ANY 3)])
    end
  | destruct_2_tuple _ = Crash.impossible"destruct_2_tuple"

  fun combine(((first, blocks, tag, last), values, set),
	      ((first', blocks', tag', last'), values', set')) =
    ((case tag of
      MirTypes.ABSENT => (case last of
	[] => (first @@ first', blocks @@ blocks', tag', last')
      | _ => Crash.impossible"non-empty last with no tag")
    | MirTypes.PRESENT tag_val => (case tag' of
        MirTypes.ABSENT => (case last' of
	  [] => (first, blocks @@ blocks', tag, last @@ first')
	| _ => Crash.impossible"non-empty last' with no tag")
      | MirTypes.PRESENT tag_val' =>
	(first, MirTypes.BLOCK(tag_val, last @@ first') :: blocks @@ blocks',
	 tag', last'))), values @@ values', set @@ set')

  fun send_to_given_reg(cg_res, gc_reg) =
    case cg_res of
      ONE reg =>
	(case reg of
	  INT(arg as MirTypes.GP_IMM_INT _) =>
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG gc_reg, arg)]
	| INT(arg as MirTypes.GP_IMM_SYMB _) =>
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG gc_reg, arg)]
	| INT(MirTypes.GP_IMM_ANY _) =>
	  Crash.impossible"GP_IMM_ANY"
	| INT(arg as MirTypes.GP_GC_REG gc_reg') =>
	    if (gc_reg' = gc_reg) then []
	    else [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG gc_reg, arg)]
	| INT(arg as MirTypes.GP_NON_GC_REG non_gc_reg) =>
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG gc_reg, arg)]
	| REAL fp_op =>
	    save_real_to_reg(fp_op, MirTypes.GC_REG gc_reg))
    | LIST many => #2 (tuple_up_in_reg(many, gc_reg))

  fun send_to_new_reg x =
    let
      val new_reg = MirTypes.GC.new()
    in
      (MirTypes.GP_GC_REG new_reg,send_to_given_reg(x, new_reg))
    end

  fun send_to_reg(ONE reg) =
    (case reg of
       INT(arg as MirTypes.GP_IMM_INT _) =>
	 let val new_reg = MirTypes.GC.new()
	 in
	   (MirTypes.GP_GC_REG new_reg,
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg, arg)])
	 end
     | INT(arg as MirTypes.GP_IMM_SYMB _) =>
	 let val new_reg = MirTypes.GC.new()
	 in
	   (MirTypes.GP_GC_REG new_reg,
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg, arg)])
	 end
     | INT(MirTypes.GP_IMM_ANY _) =>
	 Crash.impossible"GP_IMM_ANY"
     | INT x => (x, [])
     | REAL fp_op =>
	 let
	   val (reg, code) = save_real(fp_op)
	 in
	   (MirTypes.GP_GC_REG reg, code)
	 end)
  | send_to_reg(LIST many) =
    let val (gc_reg, code) = tuple_up(many)
    in
      (MirTypes.GP_GC_REG gc_reg, code)
    end

  fun gc_list_positions(_, _, [], done) = rev done
    | gc_list_positions(prev_total:int, size_fn, le :: rest, done) =
      let
	val this_size = size_fn le
      in
	gc_list_positions(prev_total + this_size, size_fn, rest,
			  prev_total :: done)
      end

a603 285
  fun make_closure(tags, free, statics, offset, env, closure,
		   funs_in_closure) =
    (* tags, the function tags this closure is for
     free, the set of free variables.
     statics, how many static gc objects to allow for in this closure.
     offset, where these live in the surrounding closure.
     env, the old env.
     closure, the old closure. *)
    let
      (* This is being changed to interlace code pointers in the closure *)
      (* with zeroes, in order to preserve the double word alignment *)
      val funs = 2 * Lists.length tags - 1
      (* Changed above n => 2*n-1 *)
      val free_list = Set.set_to_list free
      val free_size = Lists.length free_list
      val (tags, _) =
	Lists.number_from(tags, 0, 2, ident_fn)
      (* Changed above (1 for 2) *)
      val lambda_offset_list_list =
	map
	(fn (_, n) => #1 (Lists.number_from_by_one(free_list, statics+funs-n,
						ident_fn)))
	tags
      (* This produces numberings of the free variables assuming the pointer
       (caller_closure) is some distance before the first free variable, as required
       for common closures for mutually recursive functions and functions
       containing static gc objects within them *)
      (* Pointer to newly created closure *)
      val reg_operand = MirTypes.GC_REG(MirTypes.GC.new())
      val cl_code_list =
	map
	(fn lv => cg_lvar_fn(lv, env, closure, funs_in_closure))
	free_list
      val (num_cl_code, _) =
	Lists.number_from_by_one(cl_code_list, funs + statics, ident_fn)
      val closure_size = funs + statics + free_size
      val start = ~1
      val copy_dynamics =
 	Lists.reducel op @@
	([MirTypes.COMMENT"Dynamic closure elements"],
	  map (fn ((reg, code), i) => code @@
	  (case reg of INT reg =>
	    [MirTypes.STOREOP(MirTypes.ST, reg_from_gp reg,
			      reg_operand, MirTypes.GP_IMM_ANY(start + 4*i))]
	  | REAL _ =>
	      let
		val (reg', code) = send_to_reg(ONE reg)
	      in
		code @@ [MirTypes.STOREOP(MirTypes.ST, reg_from_gp reg',
					 reg_operand,
					 MirTypes.GP_IMM_ANY(start + 4*i))]
	      end))
	  num_cl_code)
      val copy_statics =
	let
	  val new_reg = MirTypes.GC.new()
	  fun copy_n(how_many, from, to) =
	  if how_many <= 0 then []
	  else
	    MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
	      MirTypes.GC_REG callee_closure,
			      MirTypes.GP_IMM_ANY(start + 4*from)) ::
	      MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg,
			       reg_operand,
			       MirTypes.GP_IMM_ANY(start + 4*to)) ::
	    copy_n(how_many-1, from+1, to+1)
	in
	  MirTypes.COMMENT"Static closure elements" ::
	  copy_n(statics, offset, funs)
	end
      val closure_env_list (* as Mir_Env.CLOSURE_ENV map_map :: _ *) =
	map
	(fn x =>
	 Lists.reducel
	 (fn (x, y) => Mir_Env.add_closure_env(y, x))
	 (Mir_Env.empty_closure_env, x))
	lambda_offset_list_list
    in
      (reg_operand,
        MirTypes.ALLOCATE(MirTypes.ALLOC, reg_operand,
			  MirTypes.GP_IMM_INT closure_size) ::
	copy_dynamics @@ copy_statics,
	closure_env_list)
    end

  fun do_app(regs, the_code as ((first, blocks, opt, last), values, procs),
	     regs', the_code' as ((first', blocks', opt', last'), values',
				  procs'),
	     is_same_set, loop_tag, pos, funs_in_closure, tag_list, do_tail,
	     args_dont_escape) =
    let
      (* First code generate to evaluate which function should be called, *)
      (* then evaluate the argument, then call the function *)

      val is_same_fn = pos = 0
      val _ = Diagnostic.output 5
        (fn _ => ["pos = " ^ Integer.makestring pos])
      val _ = Diagnostic.output 5
        (fn _ => [if is_same_fn then "Same fn" else "Not same fn"])

      val (fn_reg, fn_code) =
	case (regs, the_code) of
	  (ONE(INT(reg as MirTypes.GP_GC_REG _)),
	    ((first, blocks, opt, last), values, procs)) =>
	    (reg,
	      ((MirTypes.COMMENT("Evaluate function to be called") :: first,
	        blocks, opt, last), values, procs))
	| _ => Crash.impossible"STRUCT or NON_GC as FN"
      val arg_code =
	((MirTypes.COMMENT("Evaluate function argument") :: first',
	  blocks', opt', last'), values', procs')
      val use_callee_registers =
	MirRegisters.automatic_callee andalso do_tail
      val (real_arg_reg, real_closure_reg) =
	if use_callee_registers then (callee_arg, callee_closure)
	else (caller_arg, caller_closure)
      val extra_code = send_to_given_reg(regs', real_arg_reg)
      val fn_reg_op = reg_from_gp fn_reg
      val res_reg = MirTypes.GC.new()
      val call_code =
	if is_same_set then
	  if is_same_fn andalso do_tail andalso args_dont_escape then
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG real_closure_reg,
			    MirTypes.GP_GC_REG callee_closure),
	     MirTypes.COMMENT("Set up new closure pointer"),
	     MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)]
	  else
	    [MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG real_closure_reg,
			     MirTypes.GP_GC_REG callee_closure,
			     MirTypes.GP_IMM_INT(pos*2)),
	     MirTypes.COMMENT("Set up new closure pointer"),
	     let
	       val dest = MirTypes.TAG(Lists.nth(Lists.length tag_list + pos -
						 funs_in_closure, tag_list))
	     in
	       if do_tail then
		 MirTypes.TAIL_CALL(MirTypes.TAIL, dest)
	       else
		 MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest)
	     end,
	     MirTypes.COMMENT(if do_tail then
				"Tail to the function"
			      else "Call the function"),
	     MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
			    MirTypes.GP_GC_REG caller_arg),
	     MirTypes.COMMENT"And acquire result"]
	else
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG real_closure_reg,
			  fn_reg),
	   MirTypes.COMMENT("Set up new closure pointer"),
	   MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG MirRegisters.global,
			    MirTypes.GC_REG real_closure_reg,
			    MirTypes.GP_IMM_ANY ~1),
	   MirTypes.COMMENT("Get address of code"),
	   let
	     val dest = MirTypes.REG(MirTypes.GC_REG MirRegisters.global)
	   in
	     if do_tail then
	       MirTypes.TAIL_CALL(MirTypes.TAIL, dest)
	     else
	       MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest)
	   end,
	   MirTypes.COMMENT(if do_tail then
			      "Tail to the function"
			    else "Call the function"),
	   MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
			   MirTypes.GP_GC_REG caller_arg),
	   MirTypes.COMMENT("And acquire result")]
    in
      (ONE(INT(MirTypes.GP_GC_REG res_reg)),
        combine(fn_code,
	  combine(arg_code,
	    ((extra_code @@ call_code, [], MirTypes.ABSENT, []), [], []))))
    end

    fun build_args_for_tail(int_reg_list, regs) =
    (* Build up a tupled arg for a tail recursion *)
      let
	val (gc_regs, code) = case regs of
	  LIST regs =>
	    let
	      val cleaned_regs_and_code =
		map
		(fn reg =>
		 let
		   val new_reg = MirTypes.GC.new()
		   val code = send_to_given_reg(ONE reg, new_reg)
		 in
		   (INT(MirTypes.GP_GC_REG new_reg), code)
		 end)
		regs
	      val code =
		Lists.reducel
		(fn (x, (_, y)) => x @@ y)
		([], cleaned_regs_and_code)
	    in
	      (map #1 cleaned_regs_and_code, code)
	    end
	| ONE reg =>
	    (case int_reg_list of
	      [] => ([reg], [])
	    | _ =>
		(* Need to detuple here before we can use the value *)
		let
		  val (ok_reg, ok_code) = send_to_reg regs
		  val ok_reg = reg_from_gp ok_reg
		  val new_regs_and_code =
		    map
		    (fn (i, _) =>
		     let
		       val new_reg = MirTypes.GC.new()
		       val code =
			 MirTypes.STOREOP(MirTypes.LD,
					  MirTypes.GC_REG new_reg, ok_reg,
					  MirTypes.GP_IMM_ANY(i * 4 - 1))
		     in
		       (INT(MirTypes.GP_GC_REG new_reg), code)
		     end)
		    int_reg_list
		  val code = ok_code @@ (map #2 new_regs_and_code)
		in
		  (map #1 new_regs_and_code, code)
		end)
      in
	case int_reg_list of
	  [] => send_to_given_reg(regs, caller_arg)
	| _ =>
	    Lists.reducel
	    op @@
	    (code,
	     map
	     (fn (i, MirTypes.GC r) =>
	      send_to_given_reg(ONE(Lists.nth(i, gc_regs)), r)
	     | _ => Crash.impossible"build_args_for_tail gets non-gc reg")
	     int_reg_list)
      end

    fun exit_block [] = MirTypes.ABSENT
    | exit_block((block as MirTypes.BLOCK(tag, opcode_list)) :: rest) =
      if Lists.exists
	(fn MirTypes.RTS => true | _ => false)
	opcode_list
	then MirTypes.PRESENT block
      else exit_block rest

    fun small_exit_block(MirTypes.BLOCK(_, opcode_list)) =
      Lists.filter_length
      (fn (MirTypes.COMMENT _) => false | _ => true)
      opcode_list
      <= 3

    fun append_small_exit(MirTypes.BLOCK(tag, opcode_list), block_list) =
      let
	fun do_block(block as MirTypes.BLOCK(tag', opc_list)) =
	  if Lists.exists
	    (fn (MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG t)) => tag = t
	    | _ => false)
	    opc_list then
	    (* Difficult case. Append the exit block onto the block *)
	    (* branching to it, and remove the branch and tag *)
	    let
	      val opc' = rev opc_list
	      fun get_new_opc_list((comm as MirTypes.COMMENT _) :: rest) =
		comm :: get_new_opc_list rest
	      | get_new_opc_list(MirTypes.BRANCH(MirTypes.BRA,
						 MirTypes.TAG t) ::
				 rest) =
		if t = tag then rest
		else
		  Crash.impossible"get_new_opc fails to find proper branch"
	      | get_new_opc_list _ =
		Crash.impossible"get_new_opc fails to find proper branch"
	      val new_opc = get_new_opc_list opc'
	      fun rev_app([], x) = x
	      | rev_app(y, []) = y
	      | rev_app(y :: ys, x) = rev_app(ys, y :: x)
	    in
	      MirTypes.BLOCK(tag', rev_app(new_opc, opcode_list))
	    end
	  else
	    block
      in
	map do_block block_list
      end

d620 1
a620 1
    val number_of_gc_objects = count_gc_objects new_lambda_exp
d623 1
a623 1
      Lists.number_from_by_one(list_of_tags(number_of_gc_objects+1), 0,
d632 1
a632 24
      let
	fun get_string(LambdaTypes.APP(LambdaTypes.BUILTIN prim,
				       LambdaTypes.SCON(Ident.STRING chars))) =
	  if prim = Pervasives.LOAD_STRING then Set.singleton chars
	  else Set.empty_set
	| get_string(LambdaTypes.APP(le, le')) =
	  Set.union(get_string le, get_string le')
	| get_string(LambdaTypes.FN(_, le)) = get_string le
	| get_string(LambdaTypes.STRUCT le_list) =
	  Lists.reducel
	  Set.union
	  (Set.empty_set, map get_string le_list)
	| get_string(LambdaTypes.SELECT(_, le)) = get_string le
	| get_string(LambdaTypes.SWITCH _) = Set.empty_set
	| get_string(LambdaTypes.VAR _) = Set.empty_set
	| get_string(LambdaTypes.LETREC _) = Set.empty_set
	| get_string(LambdaTypes.INT _) = Set.empty_set
	| get_string(LambdaTypes.SCON _) = Set.empty_set
	| get_string(LambdaTypes.HANDLE _) = Set.empty_set
	| get_string(LambdaTypes.RAISE _) = Set.empty_set
	| get_string(LambdaTypes.BUILTIN _) = Set.empty_set
      in
	Set.set_to_list(get_string new_lambda_exp)
      end
d664 1
a664 1
	val gc_in_arg = count_gc_objects lexp
d669 1
a669 1
	  ONE(INT reg) => (case reg of
d697 1
a697 1
	| ONE(REAL(MirTypes.FP_REG fp_reg)) =>
d699 2
a700 2
	| LIST many =>
	    let val (gc_reg, more_code) = tuple_up many
d707 1
a707 1
	 combine(the_code, ((more_code, [], MirTypes.ABSENT, []), [], [])),
d725 1
a725 1
	(combine(code, new_code), env, static_offset, start_at)
d753 1
a753 1
	      (ONE(INT(MirTypes.GP_GC_REG new_reg)),
d807 2
a808 2
	      ONE(INT reg) => destruct_2_tuple reg
	    | LIST[INT reg1, INT reg2] => (reg1, reg2, [])
d813 1
a813 1
	  (ONE(INT res1), combine
d828 2
a829 2
	      ONE(INT reg) => destruct_2_tuple reg
	    | LIST[INT reg1, INT reg2] => (reg1, reg2, [])
d832 1
a832 1
	  (ONE(INT res1), combine
d848 2
a849 2
	    ONE(INT reg) =>
	      (ONE(INT res1), combine(the_code,
d861 1
a861 1
	      ONE(INT reg) =>
d863 1
a863 1
		  val (reg1, reg2, new_code) = destruct_2_tuple reg
d867 1
a867 1
		  (LIST[REAL freg1, REAL freg2],
d871 1
a871 1
		     reg_from_gp reg1, MirTypes.GP_IMM_ANY real_offset),
d874 1
a874 1
		     reg_from_gp reg2, MirTypes.GP_IMM_ANY real_offset)])
d876 1
a876 1
	    | LIST[val1, val2] =>
d878 2
a879 2
		  val (fp_op1, code1) = get_real val1
		  val (fp_op2, code2) = get_real val2
d881 1
a881 1
		  (LIST[REAL fp_op1, REAL fp_op2], code1 @@ code2)
d888 2
a889 2
	    LIST[REAL val1, REAL val2] =>
	      (ONE(REAL result), combine(the_code,
d900 2
a901 2
	  (ONE(REAL result),
	    combine(the_code,
d903 1
a903 1
		ONE(INT(MirTypes.GP_GC_REG reg)) =>
d908 1
a908 1
		| ONE(REAL reg) =>
d920 2
a921 2
	  (ONE(REAL result),
	    combine(the_code,
d923 1
a923 1
		ONE(INT(MirTypes.GP_GC_REG reg)) =>
d928 1
a928 1
		| ONE(REAL reg) =>
d941 2
a942 2
	      ONE(INT(reg as MirTypes.GP_GC_REG _)) => destruct_2_tuple reg
	    | LIST[INT reg1, INT reg2] => (reg1, reg2, [])
d945 2
a946 2
	    (ONE(INT(MirTypes.GP_GC_REG res_reg)),
	      combine(the_code,
d966 1
a966 1
		ONE(INT(reg as MirTypes.GP_GC_REG _)) =>
d968 3
a970 3
		    val (reg1, reg2, des_code) = destruct_2_tuple reg
		    val (fp1, code1) = get_real (INT reg1)
		    val (fp2, code2) = get_real (INT reg2)
d974 1
a974 1
	      | LIST[reg1, reg2] =>
d976 2
a977 2
		    val (fp1, code1) = get_real reg1
		    val (fp2, code2) = get_real reg2
d984 2
a985 2
	    (ONE(INT(MirTypes.GP_GC_REG res_reg)),
	      combine(the_code,
d1003 1
a1003 1
	    ONE(INT(MirTypes.GP_GC_REG reg)) => MirTypes.GC_REG reg
d1031 1
a1031 1
	    val (new_reg, code) = send_to_reg(regs)
d1037 2
a1038 2
	    (ONE(INT(MirTypes.GP_GC_REG result)),
	      combine(the_code,
d1042 1
a1042 1
		  MirTypes.STOREOP(MirTypes.STREF, reg_from_gp new_reg, res1,
d1067 2
a1068 2
		ONE(INT reg) => destruct_2_tuple reg
	      | LIST[INT reg1, arg] =>
d1070 1
a1070 1
		    val (new_reg, code) = send_to_reg(ONE arg)
d1076 2
a1077 2
	    (ONE(INT res1),
	     combine(the_code,
d1081 2
a1082 2
					 reg_from_gp arg,
                                         reg_from_gp reg1,
d1086 1
a1086 1
					 reg_from_gp reg1,
d1094 1
a1094 1
                                                         reg_from_gp reg1,
d1101 1
a1101 1
                                                        reg_from_gp reg1,
d1104 1
a1104 1
                                                         reg_from_gp reg1,
d1117 1
a1117 1
                                                        reg_from_gp reg1,
d1123 1
a1123 1
                                                        reg_from_gp reg1,
d1140 1
a1140 1
	    ONE(INT(MirTypes.GP_GC_REG reg)) =>
d1145 2
a1146 2
		(ONE(INT(MirTypes.GP_GC_REG result)),
		  combine(the_code,
d1240 2
a1241 2
	    (ONE(INT result_gp),
	      combine(the_code,
d1243 1
a1243 1
		  ONE(INT(MirTypes.GP_GC_REG reg)) =>
d1253 1
a1253 1
		| ONE(REAL reg) =>
d1263 2
a1264 2
	    (ONE(REAL result),
	     combine(the_code,
d1266 1
a1266 1
		 ONE(INT(arg as MirTypes.GP_GC_REG _)) =>
d1269 1
a1269 1
	       | ONE(INT(arg as MirTypes.GP_IMM_INT _)) =>
d1272 1
a1272 1
	       | ONE(INT(arg as MirTypes.GP_IMM_SYMB _)) =>
d1288 2
a1289 2
	  (ONE(INT result),
	   combine(the_code, ((code, [], MirTypes.ABSENT, []), [], [])))
d1300 1
a1300 1
	    ONE(INT reg) =>
d1302 1
a1302 1
	      val (new_reg, code) = send_to_reg(regs)
d1304 1
a1304 1
	      (ONE(INT res1), combine(the_code,
d1333 2
a1334 2
	  (ONE(INT res2),
	   combine(the_code,
d1394 1
a1394 1
	    LIST[INT reg1, INT reg2] =>
d1432 1
a1432 1
		  combine
d1434 1
a1434 1
		   combine
d1436 1
a1436 1
		    combine
d1438 1
a1438 1
		     ((send_to_given_reg(reg, res_reg) @@
d1442 1
a1442 1
		(ONE(INT(MirTypes.GP_GC_REG res_reg)), new_code)
d1483 2
a1484 2
	    ONE(INT reg) =>
	      (ONE(INT res1), combine(the_code,
d1506 1
a1506 1
		  ONE(INT(reg)) =>
d1509 1
a1509 1
				     reg_from_gp reg,
d1514 1
a1514 1
				     reg_from_gp reg, MirTypes.GP_IMM_ANY 3) ::
d1516 1
a1516 1
	      | LIST[INT reg1, INT reg2] =>
d1528 2
a1529 2
	    (ONE(INT(MirTypes.GP_GC_REG res_reg)),
	     combine (the_code, 
d1540 1
a1540 1
                 LIST[ INT(size), initial ] => 
d1549 5
a1553 5
                LIST[ INT(size), initial ] => 
                  (send_to_new_reg(ONE(initial)),
                   send_to_new_reg(ONE(INT size)),
                   send_to_reg(ONE(INT(size))))
              | ONE(INT(reg)) =>
d1561 1
a1561 1
                                      reg_from_gp reg,
d1565 1
a1565 1
                                                reg_from_gp reg,
d1569 1
a1569 1
                                                 reg_from_gp reg, MirTypes.GP_IMM_ANY ~1)]))
d1585 2
a1586 2
	    (ONE(INT(MirTypes.GP_GC_REG result)),
             combine(the_code,
d1602 1
a1602 1
                                                            reg_from_gp new_reg',
d1606 1
a1606 1
                                                           reg_from_gp new_reg',
d1615 1
a1615 1
                                                          reg_from_gp new_reg', new_reg',MirTypes.GP_IMM_ANY 4)]) @@
d1623 1
a1623 1
                                      [MirTypes.STOREOP(MirTypes.STREF, reg_from_gp new_reg'',
d1639 1
a1639 1
                                      [MirTypes.STOREOP(MirTypes.STREF, reg_from_gp new_reg,
d1663 1
a1663 1
	    ONE(array) =>
d1665 1
a1665 1
	    val (new_reg, code) = send_to_reg(ONE array)
d1669 2
a1670 2
	    (ONE(INT(MirTypes.GP_GC_REG result)),
	      combine(the_code,
d1673 1
a1673 1
			 MirTypes.STOREOP(MirTypes.LD,res1,reg_from_gp new_reg, MirTypes.GP_IMM_ANY 9)],
d1684 1
a1684 1
                LIST[array,offset] =>
d1686 1
a1686 1
                     INT(MirTypes.GP_IMM_INT v) => (true,v)
d1692 4
a1695 4
                LIST[array,offset] =>
                  (send_to_new_reg(ONE offset),
                   send_to_new_reg(ONE array))
              | ONE(INT(reg)) =>
d1702 1
a1702 1
                                      reg_from_gp reg,
d1706 1
a1706 1
                                                reg_from_gp reg,
d1719 2
a1720 2
	    (ONE(INT(MirTypes.GP_GC_REG result)),
	      combine(the_code,
d1732 1
a1732 1
                                          reg_from_gp new_reg',
d1749 1
a1749 1
                LIST[array,offset,value] =>
d1751 1
a1751 1
                     INT(MirTypes.GP_IMM_INT v) => (true,v)
d1757 5
a1761 5
                LIST[array,offset,value] =>
                  (send_to_new_reg(ONE offset),
                   send_to_new_reg(ONE array),
                   send_to_new_reg(ONE value))
              | ONE(INT(reg)) =>
d1769 1
a1769 1
                                                                   reg_from_gp reg,
d1773 1
a1773 1
                                                                   reg_from_gp reg,
d1777 1
a1777 1
                                                                    reg_from_gp reg, MirTypes.GP_IMM_ANY 7)]))
d1801 2
a1802 2
	    (ONE(INT(MirTypes.GP_GC_REG result)),
	      combine(the_code,
d1814 1
a1814 1
                                             reg_from_gp new_reg',
d1822 1
a1822 1
                                        MirTypes.STOREOP(MirTypes.STREF,reg_from_gp new_reg'',
d1826 1
a1826 1
                                                         reg_from_gp reg1,
d1833 1
a1833 1
                                                         reg_from_gp reg1,
d1840 1
a1840 1
                                                        reg_from_gp reg1,
d1843 1
a1843 1
                                                        reg_from_gp reg1,
d1856 1
a1856 1
                                                         reg_from_gp reg1,
d1862 1
a1862 1
                                                         reg_from_gp reg1,
d1909 1
a1909 1
      (rest_regs, combine(code, rest_code))
d1925 1
a1925 1
      val gc_objects_in_call = count_gc_objects le1
d1932 1
a1932 1
		cg_lvar(lvar, env, closure, funs_in_closure)
d1934 1
a1934 1
	      ((ONE reg, ((code, [], MirTypes.ABSENT, []), [], [])), pos,
a1953 12
      val (is_tupled_arg, tuple_bindings', fn_arg) = case tuple_bindings of
	[] => (false, [], MirTypes.GC(MirTypes.GC.new()))
      | [(_, reg)] => (false, [], reg)
      | (_, reg) :: xs => (true, xs, reg)
      val reg = case fn_arg of
	MirTypes.GC reg => reg
      | _ => Crash.impossible"Bad register for arg to tail call"
      val (arg_reg', arg_code, unstack, loop_tag) =
	if is_same_set andalso pos = 0 andalso
	  tails andalso can_stack_args then
	  if is_tupled_arg then
	    let
d1955 4
a1958 1
	      val _ = Print.print"Tail to multi-arg function\n"
d1960 7
a1966 12
	      val extra_code = build_args_for_tail(tuple_bindings', arg_reg)
	    in
	      (ONE(INT(MirTypes.GP_GC_REG
		       (if MirRegisters.automatic_callee then callee_arg
			else caller_arg))),
	       combine(arg_code,
		       ((extra_code, [], MirTypes.ABSENT, []), [], [])),
	       [], loop_tag)
	    end
	  else
	    let
	      (* Tail to single arg function *)
d1968 19
a1986 1
	      val _ = Print.print"Tail to single arg function\n"
a1987 47
	      val extra_code = send_to_given_reg(arg_reg, reg)
	    in
	      (ONE(INT(MirTypes.GP_GC_REG
		       (if MirRegisters.automatic_callee then callee_arg
			else caller_arg))),
	       combine(arg_code,
		       ((extra_code, [], MirTypes.ABSENT, []), [], [])),
	       [], loop_tag)
	    end
	else
(*
	  (Print.print("Non-tail\ncan_stack_args = " ^
		       (if can_stack_args then "true" else "false") ^
			 ", tails = " ^ (if tails then "true" else "false") ^
			 "\n");
*)	  case (arg_reg, can_stack_args andalso not tails) of
	    (LIST args, true) =>
	      (Diagnostic.output 5 (fn _ => ["Non-tail to multi-arg (stacking) function"]);
	       (ONE(INT(MirTypes.GP_GC_REG caller_arg)),
	       combine(arg_code,
		       ((#2 (stack_tuple_up_in_reg(args, caller_arg)),
			 [], MirTypes.ABSENT, []), [], [])),
	       [MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, Lists.length args)],
	       loop_tag))
	  | _ =>
	      (Diagnostic.output 5 (fn _ => [(if tails then "T" else "Non-t") ^ "ail to function"]);
	       (* Either non-LIST, or tail, or can't stack args *)
	       let
		 val extra_code =
		   if tails andalso is_same_set andalso pos = 0 then
		     send_to_given_reg(arg_reg, reg)
		   else
		     []
	       in
		 (arg_reg,
		  combine(arg_code,
			  ((extra_code, [], MirTypes.ABSENT, []), [], [])), [],
		  loop_tag)
	       end)
(*
	      )
*)
      val (reg, code) =
	do_app(fn_reg, fn_code, arg_reg', arg_code, is_same_set, loop_tag, pos,
	       funs_in_closure, fn_tag_list, tails,
	       can_stack_args orelse not is_tupled_arg)

d1991 1
a1991 1
      (reg, combine(code, ((unstack, [], MirTypes.ABSENT, []), [], [])))
d1996 1
a1996 1
      [] => (ONE(INT(MirTypes.GP_IMM_INT 0)), no_code)
d2003 1
a2003 1
	val positions = gc_list_positions(0, count_gc_objects, le_list, [])
d2011 1
a2011 1
	  Lists.reducel combine
d2014 2
a2015 2
	  map (fn ONE reg => (reg, [MirTypes.COMMENT("Argument to tuple")])
	  | LIST regs =>
d2017 1
a2017 1
	      val (reg, code) = tuple_up(regs)
d2019 1
a2019 1
	      (INT(MirTypes.GP_GC_REG reg),
d2025 2
a2026 2
	(LIST(map #1 new_reg_code_list),
	 combine(the_code, ((new_code, [], MirTypes.ABSENT, []), [], [])))
d2041 1
a2041 1
	ONE(INT(MirTypes.GP_GC_REG reg)) =>
d2045 1
a2045 1
	    (ONE(INT(MirTypes.GP_GC_REG new_reg)), combine(the_code,
d2053 3
a2055 3
      | ONE _ => Crash.impossible"SELECT(ONE(bad value))"
      | LIST many =>
	  (ONE(Lists.nth(index, many)), the_code)
d2083 1
a2083 1
      val arg_size = count_gc_objects lexp
d2085 1
a2085 1
	gc_list_positions(arg_size, count_gc_objects o #2, tag_le_list, [])
d2087 1
a2087 1
	(0, map (fn (_, x) => count_gc_objects x) tag_le_list)
d2089 1
a2089 1
	(0, map (count_gc_tags o #1) tag_le_list)
d2091 1
a2091 1
	gc_list_positions(arg_size + list_size, count_gc_tags o #1,
d2095 1
a2095 1
      | LambdaTypes.PRESENT le => count_gc_objects le
d2098 1
a2098 1
      | LambdaTypes.PRESENT le => count_gc_objects le
a2126 9
(*
      val offset =
	case (is_rel, the_code) of
	  (false, _) => 0
	| (true, ((first, blocks, MirTypes.PRESENT _, _), _, _)) =>
	    Lists.length first - 1
	| _ => Crash.impossible
	    "Switch expression on relation with bad blocks or tag"
*)
d2142 1
a2142 1
	  val the_code = combine(the_code,
d2144 1
a2144 1
	      ONE(INT reg) =>
d2146 4
a2149 4
	    | ONE(REAL reg) =>
		save_real_to_reg(reg, MirTypes.GC_REG end_reg)
	    | LIST many =>
	      (#2 (tuple_up_in_reg(many, end_reg)))) @@
d2183 2
a2184 2
	    ONE(INT(reg as MirTypes.GP_GC_REG _)) => (reg, [])
	  | ONE _ =>
d2186 1
a2186 1
	  | LIST many =>
d2188 1
a2188 1
	      val (gc_reg, code) = tuple_up many
a2198 9
(*
	    val _ =
	      (Print.print "The tagged_code\n";
	       LambdaPrint.string_of_lambda x)
	    val _ = case x of
	      LambdaTypes.APP(LambdaTypes.BUILTIN _, _) =>
		Print.print"Is APP(BUILTIN...)\n"
	    | _ => Print.print"Isn't APP(BUILTIN...)\n"
*)
a2218 7
(*
      val _ =
	if is_rel then
	  Print.print(implode["True tag = ", MirTypes.print_tag true_tag,
			", false tag = ", MirTypes.print_tag false_tag])
	else ()
*)
d2228 1
a2228 1
	val reg_op = reg_from_gp gp_operand
d2247 1
a2247 1
		tag :: list_of(j-i-1, tag1) @@ expand rest
d2276 1
a2276 11
		send_to_given_reg(regs, end_reg) @@ [final_branch]
(*
		(case regs of
	        ONE(INT reg) => [MirTypes.UNARY(MirTypes.MOVE,
					   MirTypes.GC_REG end_reg, reg)]
	      | ONE(REAL fp_op) =>
		save_real_to_reg(fp_op, MirTypes.GC_REG end_reg)
	      | LIST many =>
		#2 (tuple_up_in_reg(many, end_reg))) @@
		[final_branch]
*)
d2304 1
a2304 11
	    send_to_given_reg(regs, end_reg) @@ [final_branch]
(*
	    (case regs of
	    ONE(INT reg) => [MirTypes.UNARY(MirTypes.MOVE,
	      MirTypes.GC_REG end_reg, reg)]
	  | ONE(REAL fp_op) =>
	      save_real_to_reg(fp_op, MirTypes.GC_REG end_reg)
	  | LIST many =>
	      #2 (tuple_up_in_reg(many, end_reg))) @@
	    [final_branch]
*)
d2314 1
a2314 1
	  combine((result, values, procs),
d2342 1
a2342 1
	  val (the_reg, extra) = send_to_reg regs
a2346 4
(*
	      val _ =
	        Print.print"Handling single constructor tag case specially\n"
*)
d2352 1
a2352 1
	      val end_code = send_to_given_reg(result_reg, end_reg) @@
d2355 2
a2356 2
		combine
		(combine
d2388 1
a2388 1
		    (convert_int i, 0, code, tag)
d2395 1
a2395 1
	    val (the_reg, extra) = send_to_reg(regs)
d2426 1
a2426 1
	      ONE reg => get_real reg
a2437 6
(*
	      val _ = Print.print("Handling SCON_TAG with static_offset = " ^
				  Integer.makestring static_offset ^
				  " and funs_in_closure = " ^
				  Integer.makestring funs_in_closure ^ "\n")
*)
d2458 1
a2458 1
	      combine((([], [], MirTypes.ABSENT, []), tags_code, []),
d2470 1
a2470 1
	      ONE(INT(arg as MirTypes.GP_GC_REG _)) => arg
d2488 2
a2489 2
		do_app(regs', the_code',
		       ONE(INT(MirTypes.GP_GC_REG caller_arg)),
d2505 1
a2505 1
		MirTypes.STOREOP(MirTypes.ST, reg_from_gp the_reg,
d2530 1
a2530 1
	      combine((([], [], MirTypes.ABSENT, []), tags_code, []),
d2544 1
a2544 1
	    ONE(INT(arg as MirTypes.GP_GC_REG _)) => arg
d2555 1
a2555 1
		(ONE(INT(reg as MirTypes.GP_GC_REG _)),
d2636 1
a2636 1
	    combine(the_code, ((new_first, [], tag_opt, last), values, procs))
d2638 1
a2638 1
	else combine(the_code, test_code)
d2640 3
a2642 3
        combine(
	  combine(
	    combine(the_code,
d2648 1
a2648 1
      (ONE(INT(MirTypes.GP_GC_REG end_reg)), result_code)
d2657 1
a2657 1
      val (reg, code) = cg_lvar_fn(lvar, env, closure, funs_in_closure)
d2659 1
a2659 1
      (ONE reg, ((code, [], MirTypes.ABSENT, []), [], []))
d2668 1
a2668 1
	(ONE(INT(MirTypes.GP_IMM_INT i)), no_code)
d2680 1
a2680 1
	  (ONE(INT(MirTypes.GP_IMM_INT(convert_int i))), no_code)
a2684 6
(*
	  val _ = Print.print("Handling SCON with static_offset = " ^
			      Integer.makestring static_offset ^
			      " and funs_in_closure = " ^
			      Integer.makestring funs_in_closure ^ "\n")
*)
d2686 1
a2686 1
	  (ONE(INT(MirTypes.GP_GC_REG new_reg)),
d2708 1
a2708 1
	    if needs_prim(Pervasives.STRINGEQ, fcn) then
d2717 1
a2717 1
      val gc_objects_within = count_gc_objects lexp
a2719 6
(*
      val _ = Print.print("Copying in function pointer from" ^
			  Integer.makestring
			  (4*((funs_in_closure*2-1) + static_offset +
			      gc_objects_within) - 1) ^ "\n")
*)
d2721 1
a2721 1
	case make_closure([tag], free, gc_objects_within,
d2748 1
a2748 1
	  send_to_given_reg(fn_reg, result_temporary) @@
d2777 1
a2777 1
	combine((entry_code, [], []), combine(fn_code, (exit_code, [], [])))
d2781 1
a2781 1
		       {leaf = not (makes_calls lexp),
d2790 1
a2790 1
      (ONE(INT(gp_from_reg cl_reg)), ((code, [], MirTypes.ABSENT, []), values,
d2821 1
a2821 1
	    if lneeds_prim(Pervasives.STRINGEQ, le_list'') then
d2834 2
a2835 2
	Lists.reducel op+ (0, map count_gc_objects le_list'')
      val positions = gc_list_positions(0, count_gc_objects, le_list'', [])
d2837 1
a2837 1
	map #2 (#1 (Lists.number_from(list_of(funs, 0), 0, 2, ident_fn)))
d2845 1
a2845 1
	make_closure(tags, free, gc_objects_within,
d2855 1
a2855 1
                                       gp_from_reg cl_reg)
d2857 1
a2857 1
					gp_from_reg cl_reg,
a2874 6
(*
      val _ = Print.print("Copying in function pointers from" ^
			  Integer.makestring
			  (4*((funs_in_closure*2-1) + static_offset +
			      gc_objects_within) - 1) ^ "\n")
*)
a2899 8
      val new_fns =
	map
	(fn (x, y) => LambdaSub.wrap_lets(y, x))
	select_rest_list
      val new_fns =
	map
	(fn (lv, le) => LambdaTypes.FN(lv, le))
	(Lists.zip(fn_args, new_fns))
d2927 1
a2927 1
	   (combine
d2973 1
a2973 1
	   (regs, combine(combine(code, end_block), code'))
d2992 1
a2992 1
	     send_to_given_reg(x, result_temporary) @@
d3025 1
a3025 1
	  combine(entry_code, combine(fn_code, exit_code)))
d3070 1
a3070 1
	send_to_given_reg(reg, caller_arg) @@
d3074 1
a3074 1
	combine(code, ((final_code, [], MirTypes.ABSENT, []), [], []))
d3085 1
a3085 1
      val gc_objects_in_le = count_gc_objects le
d3109 1
a3109 1
	 send_to_given_reg(ONE(INT(MirTypes.GP_GC_REG caller_arg)),
d3125 1
a3125 1
	    ONE(INT(MirTypes.GP_GC_REG reg)) => MirTypes.GC_REG reg
d3157 1
a3157 1
	combine(exn_code,
d3163 1
a3163 1
	send_to_given_reg(main_reg, result_reg) @@
d3171 1
a3171 1
	combine(main_code,
d3174 1
a3174 1
	combine(exn_whole, main_whole)
d3176 1
a3176 1
      (ONE(INT(MirTypes.GP_GC_REG result_reg)), total_code)
d3192 1
a3192 1
      LIST sub_regs =>
d3194 1
a3194 1
	val (reg, new_code) = tuple_up_in_reg(sub_regs, callee_arg)
d3198 1
a3198 1
    | ONE(INT(arg as MirTypes.GP_GC_REG _)) =>
d3203 1
a3203 1
    | ONE(INT(MirTypes.GP_IMM_INT 0)) =>
d3243 1
a3243 1
	val exit_block = exit_block blocks
d3248 2
a3249 2
	      if small_exit_block exit_block then
		append_small_exit(exit_block, blocks)
@


1.133
log
@Fixed a problem with self tail recursive functions with
escaping arguments
@
text
@d4 4
d3809 1
a3809 1
	  MirTypes.UNARY(MirTypes.MOVE, gc_reg, MirTypes.GP_IMM_INT 0) ::
d3814 1
a3814 1
	  (Lists.tl offsets)
@


1.132
log
@Removed references to pervasive hd and length
@
text
@d4 3
d1183 2
a1184 1
	     is_same_set, loop_tag, pos, funs_in_closure, tag_list, do_tail) =
d1216 1
a1216 1
	  if is_same_fn andalso do_tail then
d2826 3
a2828 2
	do_app(fn_reg, fn_code, arg_reg', arg_code, is_same_set,
	       loop_tag, pos, funs_in_closure, fn_tag_list, tails)
d3166 1
a3166 1
      fun bounds(low, high, []) = (low, high)
d3388 1
a3388 1
		       Lists.hd fn_tag_list, 0, 0, [], false)
a3494 2
	    fun tl [] = Crash.impossible"tl nil"
	    | tl(_ :: xs) = xs
d3496 1
a3496 1
	    val first' = tl(tl first')
d3530 2
a3531 1
	    val new_first = rev(last_branch :: prev_branch :: (tl(tl first')))
d3810 1
a3810 1
	  (tl offsets)
@


1.131
log
@Fixed problem with if code short circuiting for more complicated tests.
Removed bug in code generation of LETREC final expression, whereby
func_in_closure was set to the number of funs generated in the LETREC,
rather than funs_in_closure of the enclosing function.
@
text
@d4 6
d791 1
a791 1
    val len = length reg_list
d845 1
a845 1
    val len = length reg_list
d1103 1
a1103 1
      val funs = 2 * length tags - 1
d1106 1
a1106 1
      val free_size = length free_list
d2738 1
a2738 1
		  hd fn_tag_list)
d2743 1
a2743 1
	   0, false, false, false, hd fn_tag_list)
d2801 1
a2801 1
	       [MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, length args)],
d2969 1
a2969 1
	    length first - 1
d3278 1
a3278 1
	    val len = length val_le_tags_list
d3383 1
a3383 1
		       hd fn_tag_list, 0, 0, [], false)
d3705 1
a3705 1
      val funs = length lv_list
d4106 1
a4106 1
    val new_tag = hd clos_range
@


1.130
log
@Fixed a problem with finding the function pointers when the enclosing
function is one of a set (more than one element) of mutually recursive
functions. All down the the damn zeroes. Fixed the same problem
potentially in two other places as well.
@
text
@d4 6
d506 1
d531 1
d541 2
a542 1
  sharing Mir_Env.MirTypes = MirTypes = MirRegisters.MirTypes
d916 5
d2930 29
a2958 3
      val (regs, the_code) =
	cg_sub(lexp, env, closure, static_offset, start_at, funs_in_closure,
	       fn_tag_list, false, [])
d2966 1
d3052 1
a3052 1
	  (* This may be a tail, but only if we are in  the tail line *)
d3131 4
a3134 1
	      val end_code = (case regs of
d3142 1
d3169 4
a3172 1
	  val end_code = (case regs of
d3180 1
d3208 1
a3208 1
	  val val_le_tags_list =
d3214 2
a3215 2
	  val i = case val_le_tags_list of
	    (i, _, _) :: rest => i
d3217 1
a3217 1
	  val (low, high) = bounds(i, i, map #1 val_le_tags_list)
a3218 7
	  val def_code = case def1 of
	    LambdaTypes.ABSENT => []
	  | LambdaTypes.PRESENT _ =>
	    [MirTypes.TEST(MirTypes.BGT, tag1, the_reg,
			   MirTypes.GP_IMM_INT high)]
	  val main as ((f, b, _, l), v, p) =
	    make_cgt(the_reg, low, high, val_le_tags_list)
d3220 36
a3255 1
	  (extra @@ def_code, main)
d3456 4
a3459 1
	    val ((first, blocks, tag_opt, last), values, procs) = the_code
d3472 15
a3486 1
	    | _ => Crash.impossible"Bad relational expression code"
d3509 13
a3521 2
	    | _ => Crash.impossible"Bad relational expression code"
	    val first = rev(last_branch :: prev_branch :: (tl(tl first')))
d3523 1
a3523 1
	    ((first, blocks, tag_opt, last), values, procs)
d3525 1
a3525 1
	else the_code
d3613 6
d3774 6
d3958 1
a3958 1
	       start_at + gc_objects_within + funs, funs,
@


1.129
log
@Fixed problems whereby static gc objects weren't being correctly picked
up from the surrounding closure when that closure was for more than one
function.
@
text
@d4 5
d712 3
a714 8
	      let val count = count_gc_objects lexp
		val _ =
		  if count <> 0 then
		    Crash.impossible"EXP_TAG contains static gc"
		  else ()
	      in
		count
	      end
d1508 2
a1509 2
       static_offset is the offset within the closure of static garbage
       collectable objects (functions and non-integer scons)
d3309 1
a3309 1
				       funs_in_closure) - 1)),
d3517 1
a3517 1
	        MirTypes.GP_IMM_ANY(4*(funs_in_closure + static_offset +
d3669 1
a3669 1
	      MirTypes.GP_IMM_ANY(4*(funs_in_closure + static_offset +
d3721 1
a3721 1
			  funs - x, tags)
d4056 21
@


1.128
log
@Ensured the correct closure pointer is made available when tail calling
a function in the same recursive set but not the same one
@
text
@d4 4
d3241 6
d3251 2
a3252 1
					 funs_in_closure) + real_offset)),
d3467 6
d3477 2
a3478 1
		MirTypes.GP_IMM_ANY(4*(static_offset + funs_in_closure) - 1))],
d3510 2
a3511 2
			  static_offset + funs_in_closure, env, closure,
			  funs_in_closure) of
d3626 1
a3626 1
      (* Changed above to alow for interspersed zeroes in closures *)
d3634 1
a3634 1
		     static_offset + funs_in_closure, env, closure,
@


1.127
log
@Fixed problem of single argument tail-recursive functions with
escaping arguments where the argument wasn't set up properly
on the tail call
@
text
@d4 5
d1156 1
a1156 1
	     is_same_set, is_same_fn, loop_tag, pos, tag_list, do_tail) =
d1161 1
d1194 3
a1196 2
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG real_closure_reg,
			    MirTypes.GP_GC_REG callee_closure),
d1199 2
a1200 1
	       val dest = MirTypes.TAG(Lists.nth(pos, tag_list))
d2798 2
a2799 3
	do_app(fn_reg, fn_code, arg_reg', arg_code, is_same_set, pos = 0,
	       loop_tag, length fn_tag_list + pos - funs_in_closure,
	       fn_tag_list, tails)
d3288 2
a3289 2
		       (([], [], MirTypes.ABSENT, []), [], []), false, false,
		       hd fn_tag_list, 0, [], false)
@


1.126
log
@Switch staements for characters did not assume a tagged stack alloc
@
text
@d4 3
d2721 3
a2746 3
	      val reg = case fn_arg of
		MirTypes.GC reg => reg
	      | _ => Crash.impossible"Bad register for arg to tail call"
d2757 6
a2762 1
	  case (arg_reg, can_stack_args andalso not tails) of
d2773 16
a2788 1
	       (arg_reg, arg_code, [], loop_tag))
d3938 1
a3938 1
			  MirTypes.GC_REG handler, MirTypes.GP_IMM_ANY 12),
@


1.125
log
@On code to take off the modified list, code here assumed backward and forward
were tagged
@
text
@d4 4
d3275 1
a3275 1
				 MirTypes.GP_IMM_ANY 0),
d3278 1
a3278 1
				 MirTypes.GP_IMM_ANY 4),
@


1.124
log
@Fixed problem with argument register overwrite in recursive procedures
Fixed incorrect size generated for strings by CHR
Fixed incorrect offset used to find string size by size and ord
Added some inline equality testing before invoking full polymorphic
equality
Fixed problem whereby one argument tail recursive procedures were not
putting the argument in the right register
@
text
@d4 9
d1864 1
a1864 1
                                                         MirTypes.GP_IMM_ANY 5),
d1867 1
a1867 1
                                                         MirTypes.GP_IMM_ANY 1),
d2603 1
a2603 1
                                                        MirTypes.GP_IMM_ANY 5),
d2606 1
a2606 1
                                                        MirTypes.GP_IMM_ANY 1),
@


1.123
log
@Added missing case for Pervasives.EQFUN and lowered the diagnostic level
of the message about polymorphic equality.
@
text
@d4 4
d1756 2
a1757 1
			      MirTypes.GP_IMM_ANY ~1),
d2058 2
a2059 1
		  MirTypes.ALLOCATE(MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT 1),
d2117 1
d2135 4
d2140 56
a2195 3
          cg_sub(LambdaTypes.APP(polymorphic_equality, lexp), env, closure,
                 static_offset, start_at, funs_in_closure, fn_tag_list,
                 tails, [])
d2701 4
a2704 3
      val is_tupled_arg = case tuple_bindings of
	[] => false
      | _ => true
d2706 1
a2706 1
	if is_tupled_arg andalso is_same_set andalso pos = 0 andalso
d2708 2
a2709 1
	  let
d2711 1
a2711 1
	    val _ = Print.print"Tail to multi-arg function"
d2713 27
a2739 9
	    val extra_code = build_args_for_tail(tuple_bindings, arg_reg)
	  in
	    (ONE(INT(MirTypes.GP_GC_REG
		     (if MirRegisters.automatic_callee then callee_arg
		     else caller_arg))),
	     combine(arg_code,
		     ((extra_code, [], MirTypes.ABSENT, []), [], [])),
	     [], loop_tag)
	  end
a3634 6
(*
      val _ =
	Print.print("Reordered LETREC\n" ^
	      LambdaPrint.string_of_lambda(LambdaTypes.LETREC(lv_list, new_fns,
							      lexp)))
*)
d3636 2
d3640 4
a3643 3
	(fn lvar => Mir_Env.add_lambda_env((lvar, MirTypes.GC callee_arg),
					   Mir_Env.empty_lambda_env))
	fn_args
d3645 9
d3656 10
a3665 3
	(fn ((((binding, env), new_closure), pos), x) =>
	 cg_bind_list(binding, env, new_closure, pos, start_at + pos, funs - x,
		      tags))
d3668 2
a3669 1
			     Lists.zip(Lists.zip(arg_select_list,
d3677 2
a3678 1
	(fn ((_, env, _, _), arg_selects) =>
d3684 2
a3685 1
	 (Lists.zip(code_env_static_start_list, arg_select_list))
d3689 1
a3689 1
		x), lvar), tuple_bindings), fn_arg) =>
d3696 6
a3701 4
	       val loop_tag = Lists.assoc(lvar, top_lambda_loop_tags)
		 handle Lists.Assoc =>
		   Crash.impossible("Lambda " ^ LambdaTypes.printLVar lvar ^
				    " has no loop entry tag")
a3720 14
(*
      val fn_reg_code_list' =
	map
	(fn ((((env, lexp), new_closure), pos), x) =>
	  cg_sub(lexp, env, new_closure, pos, start_at + pos, funs - x div 2,
		 tags, true))
	(Lists.zip(
		   Lists.zip(
			     Lists.zip(Lists.zip(initial_env_list, le_list''),
				       new_closure_list),
			     positions),
		   offsets))
*)

@


1.122
log
@Made Pervasives.EQ an inline operation.  At the moment it just calls
Pervasives.EQFUN, but soon will do some tests in inline.
@
text
@d4 4
d2110 1
d2113 1
a2113 1
          val _ = Diagnostic.output 0 (fn _ => ["Equality rules!"])
@


1.121
log
@Changed the way virtual registers are handled.  See MirTypes.
@
text
@d4 3
d2106 22
a2127 1
      | Pervasives.EQ => do_external_prim prim
@


1.120
log
@In chr, stb was used but the word into which we store needs to be zeroed first,
otherwise the strings are not null terminated and so confuse C
@
text
@d4 4
d716 1
a716 1
      val fp_op = MirTypes.FP_REG(MirTypes.new_fp_register())
d732 1
a732 1
      val new_reg = MirTypes.new_gc_register()
d772 1
a772 1
		 val new_reg' = MirTypes.new_gc_register()
d780 1
a780 1
		 val new_reg' = MirTypes.new_gc_register()
d811 1
a811 1
		 val new_reg' = MirTypes.new_gc_register()
d819 1
a819 1
		 val new_reg' = MirTypes.new_gc_register()
d839 1
a839 1
    tuple_up_in_reg(reg_list, MirTypes.new_gc_register())
d887 1
a887 1
	    val new_reg = MirTypes.new_gc_register()
d910 1
a910 1
	  val new_reg = MirTypes.new_gc_register()
d942 2
a943 2
      val reg1 = MirTypes.new_gc_register()
      val reg2 = MirTypes.new_gc_register() (* reasonable assumption *)
d991 1
a991 1
      val new_reg = MirTypes.new_gc_register()
d999 1
a999 1
	 let val new_reg = MirTypes.new_gc_register()
d1005 1
a1005 1
	 let val new_reg = MirTypes.new_gc_register()
d1064 1
a1064 1
      val reg_operand = MirTypes.GC_REG(MirTypes.new_gc_register())
d1091 1
a1091 1
	  val new_reg = MirTypes.new_gc_register()
d1152 1
a1152 1
      val res_reg = MirTypes.new_gc_register()
d1217 1
a1217 1
		   val new_reg = MirTypes.new_gc_register()
d1242 1
a1242 1
		       val new_reg = MirTypes.new_gc_register()
d1414 1
a1414 1
				 val new_reg = MirTypes.new_gc_register()
d1424 1
a1424 1
				 val new_reg = MirTypes.new_gc_register()
d1487 1
a1487 1
	      val new_reg = MirTypes.new_gc_register()
d1538 1
a1538 1
	  val result = MirTypes.new_gc_register()
d1559 1
a1559 1
	  val result = MirTypes.new_gc_register()
d1577 1
a1577 1
	  val result = MirTypes.new_gc_register()
d1594 1
a1594 1
	  val result = MirTypes.FP_REG(MirTypes.new_fp_register())
d1600 2
a1601 2
		  val freg1 = MirTypes.FP_REG(MirTypes.new_fp_register())
		  val freg2 = MirTypes.FP_REG(MirTypes.new_fp_register())
d1634 1
a1634 1
	  val result = MirTypes.FP_REG(MirTypes.new_fp_register())
d1652 1
a1652 1
	  val result = MirTypes.FP_REG(MirTypes.new_fp_register())
d1672 1
a1672 1
	  val res_reg = MirTypes.new_gc_register()
d1696 1
a1696 1
	  val res_reg = MirTypes.new_gc_register()
d1741 1
a1741 1
	  val res_reg = MirTypes.new_gc_register()
d1764 1
a1764 1
            val scratch = MirTypes.new_gc_register()
d1767 1
a1767 1
	    val result = MirTypes.new_gc_register()
d1769 2
a1770 2
	    val work1 = MirTypes.GC_REG(MirTypes.new_gc_register ())
            val work2 = MirTypes.GC_REG(MirTypes.new_gc_register ())
d1788 1
a1788 1
            val scratch = MirTypes.new_gc_register()
d1790 1
a1790 1
            val forward = MirTypes.new_gc_register()
d1792 1
a1792 1
            val backward = MirTypes.new_gc_register()
d1797 1
a1797 1
            val result = MirTypes.new_gc_register()
d1877 1
a1877 1
		val result = MirTypes.new_gc_register()
d1969 1
a1969 1
	    val result = MirTypes.new_gc_register()
d1980 1
a1980 1
		      val fp_op = MirTypes.FP_REG(MirTypes.new_fp_register())
d1996 1
a1996 1
	    val result = MirTypes.FP_REG(MirTypes.new_fp_register())
d2028 1
a2028 1
	  val result = MirTypes.new_gc_register()
d2061 1
a2061 1
	  val result = MirTypes.new_gc_register()
d2128 1
a2128 1
	  val result = MirTypes.new_gc_register()
d2150 1
a2150 1
	    val res_reg = MirTypes.new_gc_register()
d2209 3
a2211 3
                    val new_reg = MirTypes.new_gc_register()
                    val new_reg' = MirTypes.new_gc_register()
                    val new_reg'' = MirTypes.new_gc_register()
d2227 1
a2227 1
	    val result = MirTypes.new_gc_register()
d2229 3
a2231 3
	    val work1 = MirTypes.GC_REG(MirTypes.new_gc_register())
	    val work2 = MirTypes.GC_REG(MirTypes.new_gc_register())
	    val count =  MirTypes.new_gc_register()
d2320 1
a2320 1
	    val result = MirTypes.new_gc_register()
d2351 2
a2352 2
                    val new_reg = MirTypes.new_gc_register()
                    val new_reg' = MirTypes.new_gc_register()
d2365 1
a2365 1
	    val result = MirTypes.new_gc_register()
d2367 1
a2367 1
            val checksize = MirTypes.new_gc_register()
d2417 3
a2419 3
                    val new_reg = MirTypes.new_gc_register()
                    val new_reg' = MirTypes.new_gc_register()
                    val new_reg'' = MirTypes.new_gc_register()
d2436 1
a2436 1
	    val result = MirTypes.new_gc_register()
d2439 1
a2439 1
            val scratch = MirTypes.new_gc_register()
d2441 1
a2441 1
            val forward = MirTypes.new_gc_register()
d2443 1
a2443 1
            val backward = MirTypes.new_gc_register()
d2448 1
a2448 1
            val checksize = MirTypes.new_gc_register()
d2700 1
a2700 1
	    val new_reg = MirTypes.new_gc_register()
d2769 1
a2769 1
      val end_reg = MirTypes.new_gc_register()
d2915 1
a2915 1
	      val new_reg_op = MirTypes.new_gc_register()
d3080 1
a3080 1
	      val fp_op = MirTypes.FP_REG(MirTypes.new_fp_register())
d3123 1
a3123 1
	      val scon_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
d3298 1
a3298 1
	  val new_reg = MirTypes.new_gc_register()
d3333 1
a3333 1
      val gc_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
d3349 1
a3349 1
      val copied_callee_arg = MirTypes.new_gc_register()
d3360 1
a3360 1
	  val result_temporary = MirTypes.new_gc_register ()
d3457 1
a3457 1
      val gc_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
d3464 1
a3464 1
	(fn x => (x, MirTypes.new_gc_register()))
d3608 1
a3608 1
	     val result_temporary = MirTypes.new_gc_register ()
d3706 1
a3706 1
      val handler_frame_reg = MirTypes.new_gc_register()
d3708 1
a3708 1
      val end_ptr_reg = MirTypes.new_gc_register()
d3711 1
a3711 1
      val proc_reg = MirTypes.new_gc_register()
d3720 1
a3720 1
      val result_reg = MirTypes.new_gc_register()
d3739 1
a3739 1
          val offset_reg = MirTypes.new_gc_register()
@


1.119
log
@Chr and Ord did not deal with tagging of integers
@
text
@d4 3
d2042 8
a2049 5
		  MirTypes.ALLOCATE(MirTypes.ALLOC_STRING, res2, MirTypes.GP_IMM_INT 1)] @@
		  [MirTypes.BINARY(MirTypes.LSR,MirTypes.GC_REG MirRegisters.global,
                                   new_reg,MirTypes.GP_IMM_ANY 2),
                   MirTypes.STOREOP(MirTypes.STB, MirTypes.GC_REG MirRegisters.global, res2,
				    MirTypes.GP_IMM_ANY ~1)], exn_blocks,
@


1.118
log
@Added some more diagnostics
@
text
@d2036 1
a2036 1
		  MirTypes.TEST(MirTypes.BGT, exn_tag, new_reg,
d2040 3
a2042 1
		  [MirTypes.STOREOP(MirTypes.STB, reg_from_gp new_reg, res2,
d2063 2
a2064 1
				       MirTypes.GP_IMM_ANY ~1)],
@


1.117
log
@Bug in ARRAY_FN - fixed
@
text
@d4 3
a507 4
(*
  val op@@ = app
*)

d1121 6
a1126 4
(*
      val _ = Print.print("pos = " ^ Integer.makestring pos)
      val _ = Print.print(if is_same_fn then "Same fn" else "Not same fn")
*)
d1314 1
a1314 5
(*
    val _ =
      (Print.print "The new lambda code\n";
       LambdaPrint.print_lambda new_lambda_exp)
*)
d1318 1
a1318 1
(**)
d1325 1
a1325 1
(**)
d1381 6
a1386 5
(*
    val _ = (Print.print"Lambdas representing functions";
	     Lists.iterate (Print.print o LambdaTypes.printLVar)
	     (Map.domain escape_map))
*)
d2617 1
a2617 3
(*
	      (Print.print"Non-tail to multi-arg (stacking) function";
*)
d2623 1
a2623 4
	       loop_tag)
(*
	      )
*)
d2625 2
a2626 7
(*
	      (Print.print((if tails then "T" else "Non-t") ^ "ail to function");
*)
	       (arg_reg, arg_code, [], loop_tag)
(*
	      )
*)
d2631 3
a2633 4
(*
      val _ = if tails then Print.print"Found tail continuation" else ()
      val _ = Print.print"Done function appl."
*)
@


1.116
log
@In the previous change, the link fiedls were set as (0,1) instead
of (1,0) - (1,0) represents points to older object, (0,1) represents
"on the modified list"
@
text
@d4 5
d2205 1
a2205 1
                                      MirTypes.GP_IMM_ANY ~1)]),
d2212 1
a2212 1
                                                 reg_from_gp reg, MirTypes.GP_IMM_ANY 3)]))
@


1.115
log
@Changed the code for allocation of REF cells and arrays so
that they are no longer placed on any modified list.  They _cannot_
point at younger data, after all!
@
text
@d4 5
d1770 1
a1770 1
		  MirTypes.STOREOP(MirTypes.STREF, work1, res1, MirTypes.GP_IMM_ANY 1),
d1772 1
a1772 1
                  MirTypes.STOREOP(MirTypes.STREF, work2, res1, MirTypes.GP_IMM_ANY 5),
d2294 1
a2294 1
                        MirTypes.STOREOP(MirTypes.STREF, work1, res1, MirTypes.GP_IMM_ANY 1),
d2296 1
a2296 1
                        MirTypes.STOREOP(MirTypes.STREF, work2, res1, MirTypes.GP_IMM_ANY 5)]), [], [])))
@


1.114
log
@Arrays of size zero were not allowed - I fixed this (we often need placeholders
- see the lexer for an example)
@
text
@d4 4
d1754 2
a1755 1
	    val spare = MirTypes.GC_REG(MirTypes.new_gc_register())
d1764 4
a1767 15
		  MirTypes.UNARY(MirTypes.MOVE, spare, MirTypes.GP_IMM_INT 0),
		  MirTypes.STOREOP(MirTypes.STREF, spare, res1,
				   MirTypes.GP_IMM_ANY 1),
                  MirTypes.STOREOP(MirTypes.LDREF, scratch_reg,
                                   MirTypes.GC_REG MirRegisters.implicit,
                                   MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain),
                  MirTypes.STOREOP(MirTypes.STREF, scratch_reg,
                                   MirTypes.GC_REG result,
                                   MirTypes.GP_IMM_ANY 5),
                  MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG MirRegisters.global,
                                  MirTypes.GP_GC_REG result,
                                  MirTypes.GP_IMM_ANY ~3),
                  MirTypes.STOREOP(MirTypes.STREF, MirTypes.GC_REG MirRegisters.global,
                                   MirTypes.GC_REG MirRegisters.implicit,
                                   MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain),
d2208 2
a2209 1
	    val spare = MirTypes.GC_REG(MirTypes.new_gc_register())
d2288 4
a2291 15
                       [MirTypes.STOREOP(MirTypes.LDREF, spare,
                                         MirTypes.GC_REG MirRegisters.implicit,
                                         MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain),
                       MirTypes.STOREOP(MirTypes.STREF, spare,
                                        res1,
                                        MirTypes.GP_IMM_ANY 5),
                       MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG MirRegisters.global,
                                       MirTypes.GP_GC_REG result,
                                       MirTypes.GP_IMM_ANY ~3),
                       MirTypes.STOREOP(MirTypes.STREF, MirTypes.GC_REG MirRegisters.global,
                                        MirTypes.GC_REG MirRegisters.implicit,
                                        MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain),
                       MirTypes.UNARY(MirTypes.MOVE, spare, MirTypes.GP_IMM_INT 0),
                       MirTypes.STOREOP(MirTypes.STREF, spare, res1,
                                        MirTypes.GP_IMM_ANY 1)]), [], [])))
@


1.113
log
@Didn't handle the (0,0) case in the modified ref chain
@
text
@d4 3
d2234 1
a2234 1
                       [MirTypes.TEST(MirTypes.BGT, main_tag, new_reg', MirTypes.GP_IMM_INT 0),
@


1.112
log
@Making a letrec closure was fetching at twice the offset
@
text
@d4 3
d1810 3
a1812 2
					 MirTypes.GP_IMM_ANY 5),
                        MirTypes.TEST(MirTypes.BGT, unlink_tag, MirTypes.GP_GC_REG scratch,
d1814 1
a1814 1
                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG modified_tag)],
d1818 2
a1819 2
                                                         MirTypes.GP_IMM_ANY 1),
                                       MirTypes.TEST(MirTypes.BEQ, already_on_ref_chain_tag, 
d2473 2
a2474 2
                                                         MirTypes.GP_IMM_ANY 5),
                                        MirTypes.TEST(MirTypes.BGT, unlink_tag, MirTypes.GP_GC_REG scratch,
d2476 1
a2476 1
                                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG modified_tag)]) ::
d2480 2
a2481 2
                                                         MirTypes.GP_IMM_ANY 1),
                                       MirTypes.TEST(MirTypes.BEQ, finish_tag, 
@


1.111
log
@Fixed cg_lvar so that when code generating lambdas representing functions
in the current recursive set, where we are not using this to call,
returns an offset from the current closure, rather than a pointer to
the code
@
text
@d4 6
d3495 1
a3495 1
				  gc_objects_within + x) - 1)),
@


1.110
log
@Reworking of the pervasive library
@
text
@d4 3
d871 19
d1004 2
a1005 1
  fun make_closure(tags, free, statics, offset, env, closure) =
d1034 3
a1036 2
	map (fn lv => #1 (cg_lvar(lv, env, closure, 0))) free_list
	(* Note recursion information irrelevant here *)
a2592 15
(*
 case (arg_reg, tuple_bindings) of
	  (LIST _, _ :: _) => true
	| (LIST _, _) =>
	    if tails then
	      (Print.print"Strange (?) tupling up arg with no tuple bindings";
	       (* Actually, this isn't necessarily strange *)
	       (* Eg fun f x = f(0 :: x) *)
	       true)
	     else false
	| _ => false
*)
      (* This isn't quite correct, really we need to know *)
      (* from the typechecker whether the function takes a tuple *)
      (* Better now we have the bindings *)
d3258 2
a3259 1
    | cg_sub(arg as LambdaTypes.VAR lvar, env, closure, _, _, _, _, _, _) =
d3264 2
a3265 3
	LambdaPrint.string_of_lambda arg])
      val (reg, code) = #1 (cg_lvar(lvar, env, closure, 0))
    (* Note recursive function call information irrelevant here *)
d3329 2
a3330 1
			  static_offset + funs_in_closure, env, closure) of
d3453 2
a3454 1
		     static_offset + funs_in_closure, env, closure)
@


1.109
log
@Fixed bug in SELECT(LIST...) whereby offset rather than index was
used to index the list.
@
text
@d4 4
a2051 12
      | Pervasives.STD_IN =>
	  Crash.impossible"APP of non-function"
      | Pervasives.STD_OUT =>
	  Crash.impossible"APP of non-function"
      | Pervasives.OPEN_IN => do_external_prim prim
      | Pervasives.OPEN_OUT => do_external_prim prim
      | Pervasives.INPUT => do_external_prim prim
      | Pervasives.LOOKAHEAD => do_external_prim prim
      | Pervasives.CLOSE_IN => do_external_prim prim
      | Pervasives.END_OF_STREAM => do_external_prim prim
      | Pervasives.OUTPUT => do_external_prim prim
      | Pervasives.CLOSE_OUT => do_external_prim prim
a2136 5
      | Pervasives.SYSTEM => 
	  Crash.impossible "Impossible System"
      | Pervasives.SUBSTRING => do_external_prim prim
      | Pervasives.ARRAY =>
	  	  Crash.impossible "Impossible Array"
a2272 3
      | Pervasives.ARRAY_OF_LIST =>
	  Crash.impossible "Not written yet - do it in mir_cg"

a2355 3

      | Pervasives.TABULATE =>
	  Crash.impossible "Not written yet - do it in mir_cg"
@


1.108
log
@Added check to cg_lvar to ensure that variables code generated
really were defined
@
text
@d4 4
d2715 1
a2715 1
	  (ONE(Lists.nth(offset, many)), the_code)
@


1.107
log
@Abolished PREVIOUS_ENVIRONMENT and PRESERVE_ALL_REGS.
@
text
@d4 3
d824 1
a824 1
      val (offset, is_same_set) =
d829 2
a830 1
	    (offset_in_closure, offset_in_closure < funs_in_closure * 2 - 1)
d832 1
a832 1
	else (0, false)
d842 16
a857 11
	let
	  val new_reg = MirTypes.new_gc_register()
	in
	  ((INT(MirTypes.GP_GC_REG new_reg),
	    [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
			      MirTypes.GC_REG callee_closure,
			      MirTypes.GP_IMM_ANY(~1 + 4*offset))]),
	   offset div 2, is_same_set)
	(* Because the function pointers in a closure are interspersed *)
	(* with zeroes, we must halve offset_in_closure above *)
	end
a858 1

@


1.106
log
@Arrays expected all arguments to be present - they didn't expect a single tuple argument
That is now fixed
@
text
@d4 4
a3676 1
	MirTypes.PRESERVE_ALL_REGS ::
@


1.105
log
@Fixed up ordering of stack allocation and handler declaration,
and added handler removal to continuation point after handler called
@
text
@d4 4
a2135 2
	  (case regs of
	    LIST[ INT(size), initial ] =>
d2138 34
a2171 10
              case size of
                (* Make it double-word aligned *)
                MirTypes.GP_IMM_INT v => (true,v+1,v )
              | _ => (false,0,0)
	    val (new_reg, code) = 
              send_to_new_reg(ONE(initial))
	    val (new_reg', code') = 
              send_to_new_reg(ONE(INT size))
            val (new_reg'',code'') = 
              send_to_reg(ONE(INT(size)))
a2268 2
	  | _ =>
	      Crash.impossible "Array.array called with only one argument or non-integer size")
d2292 1
a2292 2
	  (case regs of
	    LIST[array,offset] =>
d2295 5
a2299 2
              case offset of
                INT(MirTypes.GP_IMM_INT v) => (true,v)
d2301 22
a2322 4
	    val (new_reg, code) = 
              send_to_new_reg(ONE offset)
	    val (new_reg', code') = 
              send_to_new_reg(ONE array)
a2355 2
	  | _ =>
	      Crash.impossible "Array.sub called with only one argument")
a2360 2
	  (case regs of
	    LIST[array,offset,value] =>
d2363 5
a2367 2
              case offset of
                INT(MirTypes.GP_IMM_INT v) => (true,v)
d2369 28
a2396 6
	    val (new_reg, code) = 
              send_to_new_reg(ONE offset)
	    val (new_reg', code') = 
              send_to_new_reg(ONE array)
	    val (new_reg'', code'') = 
              send_to_new_reg(ONE value)
a2489 2
	  | _ =>
	      Crash.impossible "Array.update called with only one argument")
d3786 1
a3786 2
	  (Print.print "The bad primitive\n";
	   LambdaPrint.string_of_lambda prim)
@


1.104
log
@Fixed problem whereby impossible values in make_cgt went to the
continuation point. They need to define the result first
@
text
@d4 4
d382 1
d409 1
d457 4
d539 56
d648 2
a649 3
  fun gp_from_reg reg = case reg of
    MirTypes.GC_REG x => MirTypes.GP_GC_REG x
  | MirTypes.NON_GC_REG x => MirTypes.GP_NON_GC_REG x
d651 3
a653 4
  fun reg_from_gp gp = case gp of
    MirTypes.GP_GC_REG x => MirTypes.GC_REG x
  | MirTypes.GP_NON_GC_REG x => MirTypes.NON_GC_REG x
  | _ => Crash.impossible"reg_from_gp(IMM)"
d656 2
a657 1
    INT of MirTypes.gp_operand | REAL of MirTypes.fp_operand
d784 1
a784 1
  fun tuple_up(reg_list) =
d788 7
a794 3
  let val st_chars = explode chars
    fun convert([], value) = value
    | convert(x :: xs, value) = convert(xs, 10 * value + ord x - ord "0")
d796 3
a798 4
    if hd st_chars = "~" then
      0 - convert(tl st_chars, 0)
    else
      convert(st_chars, 0)
a816 7
(*
	    val _ =
	      Print.print("cg_lvar: offset_in_closure = " ^
		    Integer.makestring offset_in_closure ^
		    "\nfuns_in_closure = " ^
		    Integer.makestring funs_in_closure)
*)
a842 1
  fun list_of(i, v) = if i <= 0 then [] else v :: list_of(i-1, v)
d844 9
d854 7
a860 1
    if n <= 0 then [] else MirTypes.new_tag() :: list_of_tags(n-1)
d911 1
a911 1
  fun send_to_new_reg(x) =
d915 1
a915 1
      (MirTypes.GP_GC_REG new_reg,send_to_given_reg(x,new_reg))
d947 4
a950 3
  fun gc_list_positions(_, _, []) = []
    | gc_list_positions(prev_total:int, size_fn, le :: rest) =
      let val this_size = size_fn le
d952 2
a953 1
	prev_total :: gc_list_positions(prev_total + this_size, size_fn, rest)
d956 2
d973 1
a973 1
	Lists.number_from(tags, 0, 2, fn x => x)
d978 1
a978 1
						fn x => x)))
d990 1
a990 1
	Lists.number_from_by_one(cl_code_list, funs + statics, fn x => x)
d1001 2
a1002 1
	      let val (reg', code) = send_to_reg(ONE reg)
d1004 3
a1006 3
		[MirTypes.STOREOP(MirTypes.ST, reg_from_gp reg',
				  reg_operand,
				  MirTypes.GP_IMM_ANY(start + 4*i))]
d1015 1
a1015 1
	    [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
d1017 1
a1017 1
			      MirTypes.GP_IMM_ANY(start + 4*from)),
d1020 1
a1020 1
			       MirTypes.GP_IMM_ANY(start + 4*to))] @@
a1032 9

(*
      val _ =
	(Print.print"Closure produced";
	 map
	 (fn (lv, i) =>
	  Print.print(LambdaTypes.printLVar lv ^ ", " ^ Integer.makestring i))
	 (Map.assoc map_map))
*)
d1035 2
a1036 1
        MirTypes.ALLOCATE(MirTypes.ALLOC, reg_operand, MirTypes.GP_IMM_INT closure_size) ::
a1073 3
(*
	    (Print.print"Handling tail to same fn";
*)
a1077 3
(*
	    )
*)
a1078 3
(*
	    (Print.print"Handling tail to different fn in same set or not tail";
*)
a1095 3
(*
	    )
*)
a1096 3
(*
	  (Print.print"Handling call to different set";
*)
a1117 3
(*
	    )
*)
d1195 5
a1199 9
    fun small_exit_block(MirTypes.BLOCK(tag, opcode_list)) =
      let
	val list_without_comments =
	  Lists.filterp
	  (fn (MirTypes.COMMENT _) => false | _ => true)
	  opcode_list
      in
	length list_without_comments <= 3
      end
d1244 1
d1246 1
d1259 1
a1259 1
			    fn x => x)
d1293 1
a1293 1
      Lists.number_from_by_one(ext_strings, next, fn x => x)
d1303 2
d1307 1
d2584 1
a2584 1
	val positions = gc_list_positions(0, count_gc_objects, le_list)
d2666 1
a2666 1
	gc_list_positions(arg_size, count_gc_objects o #2, tag_le_list)
d2672 2
a2673 1
	gc_list_positions(arg_size + list_size, count_gc_tags o #1, tag_le_list)
d3372 1
a3372 1
      val positions = gc_list_positions(0, count_gc_objects, le_list'')
d3374 1
a3374 1
	map #2 (#1 (Lists.number_from(list_of(funs, 0), 0, 2, fn x => x)))
d3644 1
d3648 2
a3683 1
      val frame_size = (*length frame_setup*)5
d3685 4
a3692 4
	MirTypes.ALLOCATE_STACK(MirTypes.ALLOC,
				handler_frame,
				frame_size,
				MirTypes.ABSENT) ::
d3768 1
a3768 1
      Lists.number_from_by_one(clos_range, 0, fn x => x)
d3771 1
a3771 1
      Lists.number_from_by_one(ext_strings, next, fn x => x)
@


1.103
log
@Allowed handler to be a variable (may occur by CSE)
@
text
@d4 3
d442 16
d575 1
a575 2
      (Print.print"Non-function in handler";
       count_gc_objects le + count_gc_objects(LambdaSub.eta_abstract le'))
d2694 2
a2695 1
	    let val (gc_reg, code) = tuple_up(many)
d2750 15
a2764 1
      let val reg_op = reg_from_gp gp_operand
d2794 1
a2794 1
	  ([], map
a3747 3
(*
		  [set_up_proc] :: proc_lists)
*)
@


1.102
log
@Modified some of the ref_chain code, and added a copy of the callee_argument
to a new virtual register to the enter section of a lambda
@
text
@d4 4
d556 2
a557 1
      Crash.impossible"Non-function in handler"
d3550 2
a3551 1
	cg_sub(le', env, closure, static_offset + gc_objects_in_le,
@


1.101
log
@Added array linkage to the ref_chain (for the garbage collector)
@
text
@d4 3
d1712 3
d1716 1
a1716 1
                                                        reg_from_gp reg1,
d2288 1
a2288 5
                            MirTypes.BINARY(MirTypes.ADD,
                                            MirTypes.GC_REG checksize,
                                            MirTypes.GP_GC_REG checksize,
                                            MirTypes.GP_IMM_INT ~1),
                           MirTypes.TEST(MirTypes.BGE, main_tag, MirTypes.GP_GC_REG checksize, new_reg),
d2336 3
d2340 1
a2340 1
                                                         reg_from_gp reg1,
d3178 1
d3181 1
a3181 1
	       Mir_Env.add_lambda_env((lvar, MirTypes.GC callee_arg),
d3202 1
a3202 1
	(if MirRegisters.automatic_callee then
d3210 4
a3213 1
			   MirTypes.GP_GC_REG caller_arg)],
@


1.100
log
@Added EXSIZEVAL and EXSUBSCRIPTVAL
@
text
@d4 3
d2143 15
a2157 5
                       [MirTypes.UNARY(MirTypes.MOVE, spare, MirTypes.GP_IMM_INT 0),
                        MirTypes.STOREOP(MirTypes.STREF, spare, res1,
                                         MirTypes.GP_IMM_ANY 5),
                        MirTypes.STOREOP(MirTypes.STREF, spare, res1,
                                         MirTypes.GP_IMM_ANY 1)]), [], [])))
d2250 9
d2288 2
a2289 1
                        MirTypes.BLOCK(main_tag,[MirTypes.COMMENT"Array update operation",
d2294 44
a2337 1
                                        MirTypes.UNARY(MirTypes.MOVE, res1, MirTypes.GP_IMM_INT 0),
d2339 2
a2340 1
			exn_blocks, MirTypes.PRESENT finish_tag, []), [], [])))
@


1.99
log
@Fixed some errors in references
@
text
@d4 3
d2075 1
a2075 1
                            (if constant_value >= 0
d2081 1
a2081 1
                       [MirTypes.TEST(MirTypes.BGE, main_tag, new_reg', MirTypes.GP_IMM_INT 0),
d2281 3
d2285 3
@


1.98
log
@Arrays almost work now
@
text
@d4 3
d1621 4
a1624 1
                  MirTypes.STOREOP(MirTypes.STREF, MirTypes.GC_REG result,
d1659 1
a1659 1
                        MirTypes.STOREOP(MirTypes.STREF, reg_from_gp reg1,
d1661 1
d1665 1
a1665 1
					 reg_from_gp arg,
d1672 8
a1679 1
					 reg_from_gp arg,
a1680 7
                                        MirTypes.TEST(MirTypes.BEQ, already_on_ref_chain_tag, 
                                                      MirTypes.GP_GC_REG scratch,
                                                      MirTypes.GP_IMM_INT 0),
                                        MirTypes.COMMENT "Unlink the cell",
                                        MirTypes.STOREOP(MirTypes.LDREF, forward_reg,
					 reg_from_gp arg,
					 MirTypes.GP_IMM_ANY 1),
d1682 1
a1682 1
                                                         reg_from_gp arg,
d1695 1
a1695 1
                                                        reg_from_gp arg,
d1701 1
a1701 1
                                                        reg_from_gp arg,
d1703 2
a1704 1
                                       MirTypes.STOREOP(MirTypes.STREF, reg_from_gp arg,
d1706 2
a1707 1
                                                        MirTypes.GP_IMM_ANY Implicit_Vector.ref_chain)])],
@


1.97
log
@More MIR for arrays
@
text
@d4 3
d372 1
d402 1
d801 7
d1595 2
a1610 2
				   MirTypes.GP_IMM_ANY 5),
		  MirTypes.STOREOP(MirTypes.STREF, spare, res1,
d1612 9
d1626 10
a1635 1
	    val result = MirTypes.new_gc_register()
d1652 2
a1653 1
		       [MirTypes.STOREOP(MirTypes.STREF, reg_from_gp reg1,
d1656 45
a1700 2
			MirTypes.COMMENT"Update a reference cell",
			MirTypes.UNARY(MirTypes.MOVE, res2,
d1702 1
a1702 2
			MirTypes.COMMENT"Dummy result"],
		       [], MirTypes.ABSENT, []), [], [])))
d1980 1
a1980 1
		  MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag)], exn_blocks,
d2036 11
a2046 2
	    val (new_reg, code) = send_to_reg(ONE(initial))
	    val (new_reg', code') = send_to_reg(ONE(INT size))
d2059 54
a2112 6
	      combine(the_code,
		      ((code @@ code' @@
                        [MirTypes.TEST(MirTypes.BGE, main_tag, new_reg', MirTypes.GP_IMM_INT 0),
                         MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)],
                        MirTypes.BLOCK(main_tag,
                                       [MirTypes.BINARY(MirTypes.AND, 
d2114 19
a2132 41
                                                        new_reg',MirTypes.GP_IMM_ANY 4),
                                       MirTypes.TEST(MirTypes.BGT, after_alignment,               
                                                     MirTypes.GP_GC_REG MirRegisters.global,
                                                     MirTypes.GP_IMM_INT 0),
                                       MirTypes.BINARY(MirTypes.ADD, 
                                                       reg_from_gp new_reg', new_reg',MirTypes.GP_IMM_ANY 4),
                                       MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG after_alignment)]) ::
			MirTypes.BLOCK(after_alignment,
                                       [MirTypes.COMMENT"Array creation operation",
                                        MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, size),
                                        MirTypes.STOREOP(MirTypes.STREF, reg_from_gp new_reg, res1,
                                                         MirTypes.GP_IMM_ANY 9),
                                        MirTypes.COMMENT"Initialise all of the values",
                                        MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG count,new_reg'),
                                        MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG MirRegisters.global,new_reg),
                                        MirTypes.BINARY(MirTypes.ADD, 
                                                        MirTypes.GC_REG MirRegisters.global,
                                                        MirTypes.GP_GC_REG MirRegisters.global,
                                                        MirTypes.GP_GC_REG result),
                                        MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)]) ::
                        MirTypes.BLOCK(loop_tag,
				       [MirTypes.STOREOP(MirTypes.STREF, reg_from_gp new_reg,
							 MirTypes.GC_REG MirRegisters.global,
							MirTypes.GP_IMM_ANY 5),
					MirTypes.BINARY(MirTypes.ADD, 
							MirTypes.GC_REG MirRegisters.global,
							MirTypes.GP_GC_REG MirRegisters.global,
							MirTypes.GP_IMM_ANY 4),
					MirTypes.BINARY(MirTypes.ADD, 
							reg_from_gp new_reg',
							new_reg',
							MirTypes.GP_IMM_ANY ~4),
					MirTypes.TEST(MirTypes.BGE, loop_tag, new_reg', MirTypes.GP_IMM_ANY 1),
					MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG finish_tag)]) ::
                        exn_blocks,
			MirTypes.PRESENT finish_tag, 
                        [MirTypes.UNARY(MirTypes.MOVE, spare, MirTypes.GP_IMM_INT 0),
					MirTypes.STOREOP(MirTypes.STREF, spare, res1,
							 MirTypes.GP_IMM_ANY 5),
					MirTypes.STOREOP(MirTypes.STREF, spare, res1,
							 MirTypes.GP_IMM_ANY 1)]), [], [])))
d2152 1
a2152 5
			 MirTypes.STOREOP(MirTypes.LD,res1,reg_from_gp new_reg, MirTypes.GP_IMM_ANY ~3),
			 MirTypes.BINARY(MirTypes.LSR, res1,MirTypes.GP_GC_REG result,
					 MirTypes.GP_IMM_ANY 6),
			 MirTypes.BINARY(MirTypes.ASL, res1,MirTypes.GP_GC_REG result,
					 MirTypes.GP_IMM_ANY 2)],
d2162 8
a2169 2
	    val (new_reg, code) = send_to_reg(ONE offset)
	    val (new_reg', code') = send_to_reg(ONE array)
d2181 10
a2190 2
			[MirTypes.COMMENT "Check the subscript range",
                         MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG checksize,
d2192 1
a2192 4
                                          MirTypes.GP_IMM_ANY ~3),
			 MirTypes.BINARY(MirTypes.LSR, MirTypes.GC_REG checksize, 
                                         MirTypes.GP_GC_REG checksize,
					 MirTypes.GP_IMM_ANY 4),
d2199 1
a2199 1
					  MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9),
d2213 10
a2222 3
	    val (new_reg, code) = send_to_reg(ONE offset)
	    val (new_reg', code') = send_to_reg(ONE array)
	    val (new_reg'', code'') = send_to_reg(ONE value)
d2236 18
a2253 9
			[MirTypes.COMMENT "Check the subscript range",
                         MirTypes.STOREOP(MirTypes.LDREF, MirTypes.GC_REG checksize,
                                          reg_from_gp new_reg',
                                          MirTypes.GP_IMM_ANY ~3),
			 MirTypes.BINARY(MirTypes.LSR, MirTypes.GC_REG checksize, 
                                         MirTypes.GP_GC_REG checksize,
					 MirTypes.GP_IMM_ANY 4),
                         MirTypes.TEST(MirTypes.BGE, main_tag, MirTypes.GP_GC_REG checksize, new_reg),
                         MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG exn_tag)],
d2258 1
a2258 1
                                                         MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9),
@


1.96
log
@Added some inlineable code for arrays - not quite working yet
@
text
@d4 3
d1969 1
d1972 3
d1979 26
a2004 13
			[MirTypes.COMMENT"Array creation operation",
			 MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, size),
			 MirTypes.STOREOP(MirTypes.STREF, reg_from_gp new_reg, res1,
					  MirTypes.GP_IMM_ANY 9),
			 MirTypes.COMMENT"Initialise all of the values",
			 MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG count,new_reg'),
			 MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG MirRegisters.global,new_reg),
			 MirTypes.BINARY(MirTypes.ADD, 
					 MirTypes.GC_REG MirRegisters.global,
					 MirTypes.GP_GC_REG MirRegisters.global,
					 MirTypes.GP_GC_REG result),
			 MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)],
			MirTypes.BLOCK(loop_tag,
d2007 1
a2007 1
							MirTypes.GP_IMM_ANY 9),
d2016 1
a2016 1
					MirTypes.TEST(MirTypes.BGE, loop_tag, new_reg', MirTypes.GP_IMM_INT 0),
d2018 3
a2020 2
			MirTypes.BLOCK(finish_tag,
				       [MirTypes.UNARY(MirTypes.MOVE, spare, MirTypes.GP_IMM_INT 0),
d2024 1
a2024 2
							 MirTypes.GP_IMM_ANY 1)])::[],
			MirTypes.ABSENT, []), [], [])))
d2047 1
a2047 1
			 MirTypes.BINARY(MirTypes.ASR, res1,MirTypes.GP_GC_REG result,
d2062 5
d2071 10
a2080 1
			[MirTypes.COMMENT"Array subscript operation",
d2084 3
a2086 2
					  MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9)],
			[], MirTypes.ABSENT, []), [], [])))
d2103 7
d2114 17
a2130 8
			[MirTypes.COMMENT"Array update operation",
			 MirTypes.BINARY(MirTypes.ADD,
					 MirTypes.GC_REG MirRegisters.global,new_reg',new_reg),
			 MirTypes.STOREOP(MirTypes.STREF,reg_from_gp new_reg'',
					  MirTypes.GC_REG MirRegisters.global, MirTypes.GP_IMM_ANY 9),
			 MirTypes.UNARY(MirTypes.MOVE, res1, MirTypes.GP_IMM_INT 0)
			],
			[], MirTypes.ABSENT, []), [], [])))
@


1.95
log
@Changed raise and handle to new form using implicit vector
@
text
@d4 3
d564 1
a564 1
    [MirTypes.ALLOCATE(MirTypes.ALLOC_REAL, reg, 0),
d581 1
a581 1
      MirTypes.ALLOCATE(MirTypes.ALLOC, MirTypes.GC_REG new_reg, len)
d914 1
a914 1
        MirTypes.ALLOCATE(MirTypes.ALLOC, reg_operand, closure_size) ::
d1147 5
a1151 2
      (Print.print "The uncurried lambda code\n";
       LambdaPrint.print_lambda new_lambda_exp)
d1588 1
a1588 1
		  [MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, 0),
d1591 1
a1591 1
				   MirTypes.GP_IMM_ANY 1),
d1596 1
a1596 1
				   MirTypes.GP_IMM_ANY 9),
d1621 1
a1621 1
					 MirTypes.GP_IMM_ANY 1),
d1639 1
a1639 1
					MirTypes.GP_IMM_ANY 1),
d1801 1
a1801 1
		  MirTypes.ALLOCATE(MirTypes.ALLOC_STRING, res2, 1)] @@
d1953 137
@


1.94
log
@Prevented unnecessary ADD 0 instructions being generated when look at
closures.  Added a fix to LETREC generation.
@
text
@d4 4
d343 1
d369 1
d407 1
d526 1
a526 1
    | count_gc_objects(LambdaTypes.HANDLE(le, LambdaTypes.FN(_, le'))) =
a1286 1
(*
d1288 3
a1290 3
	(Print.print "Mir generating APP(BUILTIN...)\n";
	 LambdaPrint.print_lambda arg)
*)
a1954 1
(*
d1956 3
a1958 3
	(Print.print "Mir generating APP(FN...)\n";
	 LambdaPrint.print_lambda arg)
*)
a1974 1
(*
d1976 3
a1978 3
	(Print.print "Mir generating APP\n";
	 LambdaPrint.print_lambda arg)
*)
d2087 4
a2090 5
(*
	val _ =
	 (Print.print "Mir generating STRUCT\n";
	  LambdaPrint.print_lambda arg)
*)
a2118 1
(*
d2120 3
a2122 3
	(Print.print "Mir generating SELECT\n";
	 LambdaPrint.print_lambda arg)
*)
a2149 1
(*
d2151 3
a2153 3
	(Print.print "Mir generating SWITCH\n";
	 LambdaPrint.print_lambda arg)
*)
d2270 1
a2270 1
	       LambdaPrint.print_lambda x)
a2681 1
(*
d2683 3
a2685 3
	(Print.print "Mir generating VAR\n";
	 LambdaPrint.print_lambda arg)
*)
a2692 1
(*
d2694 3
a2696 3
	(Print.print "Mir generating INT\n";
	 LambdaPrint.print_lambda arg)
*)
d2703 4
a2706 5
(*
      val _ =
	(Print.print "Mir generating SCON\n";
	 LambdaPrint.print_lambda arg)
*)
a2728 1
(*
d2730 3
a2732 3
	(Print.print "Mir generating FN\n";
	 LambdaPrint.print_lambda fcn)
*)
a2819 1
(*
d2821 3
a2823 3
	(Print.print "Mir generating LETREC\n";
	 LambdaPrint.print_lambda exp)
*)
d3086 2
a3087 2
    | cg_sub(arg as LambdaTypes.RAISE le, env, closure, static_offset, start_at,
	     funs_in_closure, fn_tag_list, _, _) =
a3088 1
(*
d3090 3
a3092 3
	(Print.print "Mir generating RAISE\n";
	 LambdaPrint.print_lambda arg)
*)
a3095 6
      val temp1 = MirTypes.new_gc_register()
      val temp_reg1 = MirTypes.GC_REG temp1
      val gp_temp_reg1 = MirTypes.GP_GC_REG temp1
      val temp2 = MirTypes.new_gc_register()
      val temp_reg2 = MirTypes.GC_REG temp2
      val gp_temp_reg2 = MirTypes.GP_GC_REG temp2
a3097 7
	MirTypes.STOREOP(MirTypes.LD, temp_reg1, MirTypes.GC_REG handler,
			  MirTypes.GP_IMM_ANY ~1) ::
	MirTypes.STOREOP(MirTypes.LD, temp_reg2, MirTypes.GC_REG handler,
			  MirTypes.GP_IMM_ANY 3) ::
        MirTypes.BINARY(MirTypes.LSR, temp_reg2, gp_temp_reg2,
                        MirTypes.GP_IMM_ANY 2) ::
        MirTypes.BINARY(MirTypes.ADD, temp_reg1, gp_temp_reg1, gp_temp_reg2) ::
d3099 1
a3099 1
	[MirTypes.RAISE(temp_reg1),
a3108 1
(*
d3110 3
a3112 3
	(Print.print "Mir generating HANDLE\n";
	 LambdaPrint.print_lambda hand)
*)
a3113 1
      val handler_tag = MirTypes.new_tag()
d3115 1
d3118 18
a3135 3
      val handler_ptr_reg = MirTypes.new_gc_register()
      val handler_ptr =	MirTypes.GC_REG handler_ptr_reg
      val gp_handler_ptr = MirTypes.GP_GC_REG handler_ptr_reg
d3138 5
a3142 6
      (* 0      pointer to procedure of handler   } GC safe *)
      (* 1	offset from above of handler code }         *)
      (* 2      frame pointer (for data access) *)
      (* 3      stack pointer (machine stack) *)
      (* 4      previous handler record *)
      (* 5	closure pointer *)
d3148 3
d3152 10
a3161 8
          [MirTypes.STOREOP(MirTypes.LD, offset,
                            MirTypes.GC_REG callee_closure,
                            MirTypes.GP_IMM_ANY ~1),
           MirTypes.COMMENT "Fetch address of this procedure",
           MirTypes.STOREOP(MirTypes.ST, offset, handler_frame,
                            MirTypes.GP_IMM_ANY ~1),
           MirTypes.BINARY(MirTypes.SUB, offset, gp_handler_ptr, gp_offset),
           MirTypes.COMMENT "Calculate offset of handler code in procedure",
d3165 1
a3165 9
                            MirTypes.GP_IMM_ANY 3),
           MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG fp, handler_frame,
                            MirTypes.GP_IMM_ANY 7),
           MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG sp, handler_frame,
                          MirTypes.GP_IMM_ANY 11),
           MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG handler, handler_frame,
                            MirTypes.GP_IMM_ANY 15),
           MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG callee_closure,
                            handler_frame, MirTypes.GP_IMM_ANY 19)]
d3167 1
a3167 1
      val frame_size = length frame_setup
d3169 8
a3176 6
	[MirTypes.ALLOCATE_STACK(MirTypes.ALLOC,
				 handler_frame,
				 frame_size,
				 MirTypes.ABSENT),
	 MirTypes.NEW_HANDLER handler_tag,
	 MirTypes.ADR(MirTypes.LEA, handler_ptr, handler_tag)] @@
d3181 3
a3183 1
      val result_reg = MirTypes.new_gc_register()
d3196 2
a3197 58
	combine(((frame_setup, [], MirTypes.ABSENT, []), [], []),
	  combine(main_code, ((main_end, [], MirTypes.PRESENT end_tag, []), [], [])))
      val (lv, lexp) = case le' of
	LambdaTypes.FN(lv, lexp) => (lv, lexp)
      | _ => Crash.impossible"Handler is not a function"
      val exn_reg = MirTypes.new_gc_register()
      val env' = Mir_Env.add_lambda_env((lv, MirTypes.GC exn_reg), env)
      (* The environment in which to generate the handler *)
      val temp_sp = MirTypes.GC_REG(MirRegisters.global)
      val exn_setup =
	[MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG fp,
			  MirTypes.GC_REG handler, MirTypes.GP_IMM_ANY 7),
	  MirTypes.COMMENT"Get correct fp",
	  MirTypes.STOREOP(MirTypes.LD, temp_sp,
			   MirTypes.GC_REG handler, MirTypes.GP_IMM_ANY 11),
	  MirTypes.COMMENT"Remember previous sp",
	  MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG handler,
			   MirTypes.GC_REG handler, MirTypes.GP_IMM_ANY 15),
	  MirTypes.OLD_HANDLER,
	  MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG callee_closure,
			   MirTypes.GC_REG handler, MirTypes.GP_IMM_ANY 19),
	  MirTypes.COMMENT"Restore previous closure",
	  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG exn_reg,
			 MirTypes.GP_GC_REG caller_arg),
	  MirTypes.COMMENT"Get exception"]
      val (exn_result_reg,
	   ((exn_f, exn_b, exn_o, exn_l), exn_vals, exn_procs)) =
	cg_sub(lexp, env', closure, static_offset + gc_objects_in_le,
	       start_at + gc_objects_in_le, funs_in_closure, fn_tag_list,
	       false, [])
      val restore_tag1 = MirTypes.new_tag()
      val restore_tag2 = MirTypes.new_tag()
      val restore_block1 =
	MirTypes.BLOCK(restore_tag1,
	  [MirTypes.PREVIOUS_ENVIRONMENT,
	   MirTypes.COMMENT"Restore up one level",
	   MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG restore_tag2)])
      val restore_block2 =
	MirTypes.BLOCK(restore_tag2,
	  [MirTypes.TEST(MirTypes.BNE, restore_tag1, gp_from_reg temp_sp,
			 MirTypes.GP_GC_REG sp),
	    MirTypes.COMMENT"Are we there yet",
	    MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG end_tag)])
      val exn_end =
	send_to_given_reg(exn_result_reg, result_reg) @@
	[MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG restore_tag2)]
      val exn_start = exn_setup @@ exn_f @@
	(case exn_o of
	  MirTypes.ABSENT => exn_end
	| _ => [])
      val exn_blocks =
	[MirTypes.BLOCK(handler_tag, exn_start), restore_block1,
	  restore_block2] @@ exn_b @@
	(case exn_o of
	  MirTypes.ABSENT => []
	| MirTypes.PRESENT tag => [MirTypes.BLOCK(tag, exn_l @@ exn_end)])
      val exn_whole = (([], exn_blocks, MirTypes.ABSENT, []), exn_vals,
		       exn_procs)
d3199 1
a3199 1
	combine(main_whole, exn_whole)
d3208 1
a3208 1
	   LambdaPrint.print_lambda prim)
@


1.93
log
@Added a SUBSTRING pervasive as a temporary measure so that the same code
can be compiled under under both New Jersey and MLWorks.
@
text
@d4 4
d2881 3
a2883 1
	(fn (x, reg) => MirTypes.BINARY(MirTypes.ADD, MirTypes.GC_REG reg,
d3075 2
a3076 1
	       gc_objects_within, start_at + gc_objects_within + funs, funs,
@


1.92
log
@Used curried function application optimisation
@
text
@d4 3
d1936 1
@


1.91
log
@Removed the raw spill size field from function closures.
@
text
@d4 3
d347 1
d375 1
d383 1
a383 1
    Tail.LambdaTypes
d1127 6
@


1.90
log
@Fixed bug whereby APP(BUILTIN...) demanded empty tuple_binding list,
which isn't necessarily the case
@
text
@d4 4
d840 1
a840 2
      val closure_size = funs + statics + free_size + 1
      (* Extra location for non-gc-spill area size for gc benefit *)
a873 9
      val set_spill_size =
	let
	  val new_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
	in
	  [MirTypes.UNARY(MirTypes.MOVE, new_reg,
			  MirTypes.GP_IMM_SYMB MirTypes.NON_GC_SPILL_SIZE),
	    MirTypes.STOREOP(MirTypes.ST, new_reg, reg_operand,
			     MirTypes.GP_IMM_ANY(start + 4*(closure_size-1)))]
	end
d893 1
a893 1
	copy_dynamics @@ copy_statics @@ set_spill_size,
@


1.89
log
@Changed use of InterProc to fit new interface
@
text
@d4 3
d330 1
d353 1
d682 1
a682 1
	      print("cg_lvar: offset_in_closure = " ^
d890 1
a890 1
	(print"Closure produced";
d893 1
a893 1
	  print(LambdaTypes.printLVar lv ^ ", " ^ Integer.makestring i))
d911 2
a912 2
      val _ = print("pos = " ^ Integer.makestring pos)
      val _ = print(if is_same_fn then "Same fn" else "Not same fn")
d937 1
a937 1
	    (print"Handling tail to same fn";
d948 1
a948 1
	    (print"Handling tail to different fn in same set or not tail";
d972 1
a972 1
	  (print"Handling call to different set";
d1123 5
a1127 1

d1181 2
a1182 2
    val _ = (print"Lambdas representing functions";
	     Lists.iterate (print o LambdaTypes.printLVar)
d1255 1
a1255 1
    and cg_sub(LambdaTypes.APP(LambdaTypes.BUILTIN prim, lexp), env, closure,
d1257 1
a1257 1
	       []) =
d1267 7
a1526 25
(*
	(* Treat it as APP(le, le') *)
	let
	  val (regs', the_code') =
	    cg_sub(LambdaTypes.BUILTIN prim, env, closure, static_offset,
		   start_at, funs_in_closure, fn_tag_list, false, [])
	  (* Later this should consider stacking arguments *)
(*
	  val (regs, code, unstack) = case regs of
	    LISTS args =>
	      (ONE(MirTypes.GP_GC_REG caller_arg),
	       stack_tuple_up_in_reg(args, caller_arg),
	       [MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, length args)])
	  | _ => (regs, code, [])
	  val appcode =
	    do_app(regs', the_code', regs, the_code, false, false,
		   hd fn_tag_list, 0,
		   fn_tag_list, case regs' of LIST _ => false | _ => tails)
*)
	in
	  do_app(regs', the_code', regs, the_code, false, false,
		 hd fn_tag_list, 0,
		 fn_tag_list, case regs' of LIST _ => false | _ => tails)
	end
*)
d1931 2
a1932 1
    | cg_sub(LambdaTypes.APP(LambdaTypes.FN(lvar, lexp1), lexp2), env, closure,
d1936 5
d1952 1
a1952 1
    | cg_sub(LambdaTypes.APP(le1, le2), env, closure, static_offset, start_at,
d1957 5
d2004 1
a2004 1
	      (print"Strange (?) tupling up arg with no tuple bindings";
d2019 1
a2019 1
	    val _ = print"Tail to multi-arg function"
d2034 1
a2034 1
	      (print"Non-tail to multi-arg (stacking) function";
d2047 1
a2047 1
	      (print((if tails then "T" else "Non-t") ^ "ail to function");
d2058 2
a2059 2
      val _ = if tails then print"Found tail continuation" else ()
      val _ = print"Done function appl."
d2064 1
a2064 1
    | cg_sub(LambdaTypes.STRUCT le_list, env, closure, static_offset, start_at,
d2070 5
d2100 1
a2100 1
    | cg_sub(LambdaTypes.SELECT({index, size}, lexp), env, closure,
d2103 5
d2130 1
a2130 1
    | cg_sub(LambdaTypes.SWITCH(lexp, tag_le_list, def1, def2), env, closure,
d2135 5
d2253 9
d2285 1
a2285 1
	  print(implode["True tag = ", MirTypes.print_tag true_tag,
d2410 1
a2410 1
	  val (the_reg, extra) = send_to_reg(regs)
d2666 1
a2666 1
    | cg_sub(LambdaTypes.VAR lvar, env, closure, _, _, _, _, _, _) =
d2668 5
d2678 11
a2688 3
    | cg_sub(LambdaTypes.INT i, _, _, _, _, _, _, _, _) =
      (ONE(INT(MirTypes.GP_IMM_INT i)), no_code)
    | cg_sub(LambdaTypes.SCON scon, _, _, static_offset, start_at,
d2690 7
d2714 1
a2714 1

d2718 5
d2810 5
d2922 1
a2922 1
	print("Reordered LETREC\n" ^
d3074 1
a3074 1
    | cg_sub(LambdaTypes.RAISE le, env, closure, static_offset, start_at,
d3077 5
d3111 5
d3247 9
a3255 3
    | cg_sub(LambdaTypes.BUILTIN prim, env, closure, static_offset, start_at,
	     funs_in_closure, fn_tag_list, _, _) =
      Crash.impossible"cg_sub(BUILTIN) (should have been translated)"
d3268 5
@


1.88
log
@Ensured result of CALL_C moved away from caller_arg to avoid overwriting
@
text
@d4 3
d1167 2
a1168 2

    val escape_map = InterProc.escape_map new_lambda_exp
@


1.87
log
@Changed the format of handler records so that the garbage collector can deal
with them.  They now contain a pointer to a procedure (a GC object) and an offet
rather than a pointer into arbitrary code.
@
text
@d3 6
a8 1
$Log:	_mir_cg.sml,v $
d1893 31
a1923 21
	    fun make_args_for_call_c (ONE(INT(reg))) =
	      [MirTypes.STOREOP(MirTypes.LD,
				MirTypes.GC_REG MirRegisters.caller_arg,
				reg_from_gp reg, MirTypes.GP_IMM_ANY ~1),
	       MirTypes.STOREOP(MirTypes.LD,
				MirTypes.GC_REG MirRegisters.caller_closure,
				reg_from_gp reg, MirTypes.GP_IMM_ANY 3),
	       MirTypes.CALL_C]

	      | make_args_for_call_c (LIST[INT reg1, INT reg2]) =

		[MirTypes.UNARY(MirTypes.MOVE,
				MirTypes.GC_REG MirRegisters.caller_arg,
				reg1),
		 MirTypes.UNARY(MirTypes.MOVE,
				MirTypes.GC_REG MirRegisters.caller_closure,
				reg2),
		 MirTypes.CALL_C]

	      | make_args_for_call_c _ =
		Crash.impossible "Bad arguments to make_args_for_call_c"
d1925 1
a1925 1
	    (ONE(INT(MirTypes.GP_GC_REG MirRegisters.caller_arg)),
@


1.86
log
@Added EXxxxVAL exception values to some matches to make them complete.
Corrected the offsets used to load and store the exception record.
Changed raise of built-in exceptions to use the values rather than
reconstructing the packets each time.
@
text
@d4 6
d1283 1
a1283 1
            handle Lists.Assoc =>
d3006 6
a3011 1
      val temp_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
d3014 1
a3014 1
	MirTypes.STOREOP(MirTypes.LD, temp_reg, MirTypes.GC_REG handler,
d3016 5
d3022 1
a3022 1
	[MirTypes.RAISE(temp_reg),
d3037 4
a3040 2
      val handler_ptr =	MirTypes.GC_REG(MirTypes.new_gc_register())
      (* Handler layout *)
d3042 6
a3047 5
      (* 0      code pointer *)
      (* 1      frame pointer (for data access) *)
      (* 2      stack pointer (machine stack) *)
      (* 3      previous handler *)
      (* 4	closure pointer *)
d3049 26
a3074 10
	[MirTypes.STOREOP(MirTypes.ST, handler_ptr, handler_frame,
			   MirTypes.GP_IMM_ANY ~1),
	  MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG fp, handler_frame,
			   MirTypes.GP_IMM_ANY 3),
	  MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG sp, handler_frame,
			   MirTypes.GP_IMM_ANY 7),
	  MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG handler, handler_frame,
			   MirTypes.GP_IMM_ANY 11),
	  MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG callee_closure,
			   handler_frame, MirTypes.GP_IMM_ANY 15)]
d3111 1
a3111 1
			  MirTypes.GC_REG handler, MirTypes.GP_IMM_ANY 4),
d3114 1
a3114 1
			   MirTypes.GC_REG handler, MirTypes.GP_IMM_ANY 8),
d3117 1
a3117 1
			   MirTypes.GC_REG handler, MirTypes.GP_IMM_ANY 12),
d3120 1
a3120 1
			   MirTypes.GC_REG handler, MirTypes.GP_IMM_ANY 16),
@


1.85
log
@Fixed bugs in ORD and SIZE
@
text
@d4 3
d1272 2
a1273 1
		  "exceptions generated from a single in-line pervasive.")
d1275 8
d1284 10
a1293 16
	    case (cg_sub(LambdaTypes.RAISE(LambdaTypes.STRUCT
	      [LambdaTypes.VAR(Map.lookup(exception_needed,
					  prim_to_lambda)),
	        LambdaTypes.STRUCT[]]), env, closure,
		  static_offset, start_at, funs_in_closure,
		  fn_tag_list, false, [])
	    handle Lists.Assoc =>
	      Crash.impossible
	      ("Assoc fail on " ^ Pervasives.print_pervasive prim)) of
	      (_, ((exn_f, exn_b, exn_o, exn_l), [], [])) =>
		(exn_f, exn_b, exn_o, exn_l)
	    | _ => Crash.impossible"Bad code for RAISE primitive exception"
	  val _ =
	    case exn_o of
	      MirTypes.ABSENT => ()
	    | _ => Crash.impossible"Too much raise code"
d1651 36
d3004 1
a3004 1
			  MirTypes.GP_IMM_ANY 0) ::
d3031 1
a3031 1
			   MirTypes.GP_IMM_ANY 0),
d3033 1
a3033 1
			   MirTypes.GP_IMM_ANY 4),
d3035 1
a3035 1
			   MirTypes.GP_IMM_ANY 8),
d3037 1
a3037 1
			   MirTypes.GP_IMM_ANY 12),
d3039 1
a3039 1
			   handler_frame, MirTypes.GP_IMM_ANY 16)]
@


1.84
log
@Tidied up in tail recursion/continuation
@
text
@d4 3
d921 3
d945 3
d973 3
d1154 5
d1490 2
d1515 1
d1707 2
a1708 1
	  (ONE(INT result), ((code, [], MirTypes.ABSENT, []), [], []))
d1747 7
a1753 6
	    ((code @@
	      [MirTypes.TEST(MirTypes.BLE, exn_tag, the_size,
			     MirTypes.GP_IMM_INT 0),
	        MirTypes.STOREOP(MirTypes.LDB, res1, the_ptr,
				 MirTypes.GP_IMM_ANY ~1)],
	      exn_blocks, MirTypes.ABSENT, []), [], []))
a1906 9
(*
	      val _ =
		print("Getting is_same_set from cg_lvar\npos = " ^
		      Integer.makestring pos ^
		      "\nfuns_in_closure = " ^
		      Integer.makestring funs_in_closure ^
		      "\nLambda = " ^
		      LambdaTypes.printLVar lvar)
*)
d1950 1
d1952 1
d1965 1
d1967 1
d1973 4
a1976 1
	       loop_tag))
d1978 1
d1980 5
a1984 1
	       (arg_reg, arg_code, [], loop_tag))
d1991 1
d2705 1
a2705 2
      val le_list'' = map #2 fn_args_and_bodies
      val fn_args = map #1 fn_args_and_bodies
d2798 1
d2803 1
@


1.83
log
@More work on tail continuations and recursions
@
text
@d4 3
d778 7
a784 68

  fun mir_cg(lambda_exp, top_env) =
  let
    val (prim_to_lambda, prim_lvars, new_lambda_exp) =
      Library.build_external_environment lambda_exp

    val number_of_gc_objects = count_gc_objects new_lambda_exp

    val (top_tags_list, next) =
      Lists.number_from_by_one(list_of_tags(number_of_gc_objects+1), 0,
			    fn x => x)

    val top_closure =
      Lists.reducel
      (fn (x, (t, i)) => Map.add((i, t), x, (op <): int * int -> bool))
      (Map.empty_map, top_tags_list)

    val ext_strings =
      let
	fun get_string(LambdaTypes.APP(LambdaTypes.BUILTIN prim,
				       LambdaTypes.SCON(Ident.STRING chars))) =
	  if prim = Pervasives.LOAD_STRING then Set.singleton chars
	  else Set.empty_set
	| get_string(LambdaTypes.APP(le, le')) =
	  Set.union(get_string le, get_string le')
	| get_string(LambdaTypes.FN(_, le)) = get_string le
	| get_string(LambdaTypes.STRUCT le_list) =
	  Lists.reducel
	  Set.union
	  (Set.empty_set, map get_string le_list)
	| get_string(LambdaTypes.SELECT(_, le)) = get_string le
	| get_string(LambdaTypes.SWITCH _) = Set.empty_set
	| get_string(LambdaTypes.VAR _) = Set.empty_set
	| get_string(LambdaTypes.LETREC _) = Set.empty_set
	| get_string(LambdaTypes.INT _) = Set.empty_set
	| get_string(LambdaTypes.SCON _) = Set.empty_set
	| get_string(LambdaTypes.HANDLE _) = Set.empty_set
	| get_string(LambdaTypes.RAISE _) = Set.empty_set
	| get_string(LambdaTypes.BUILTIN _) = Set.empty_set
      in
	Set.set_to_list(get_string new_lambda_exp)
      end

    val (ext_string_list, next) =
      Lists.number_from_by_one(ext_strings, next, fn x => x)

    fun find_ext_string chars =
      let
	fun find_sub(chars, []) = Crash.impossible"string missing"
	| find_sub(chars, (x, y) :: xs) =
	  if chars = x then y else find_sub(chars, xs)
      in
	find_sub(chars, ext_string_list)
      end

    val escape_map = InterProc.escape_map new_lambda_exp
    val top_lambdas = Map.domain escape_map
    (* Should be the lambda variables representing all the functions *)
    val top_lambda_loop_tags =
      map (fn lv => (lv, MirTypes.new_tag())) top_lambdas

    fun make_closure(tags, free, statics, offset, env, closure) =
      (* tags, the function tags this closure is for
       free, the set of free variables.
       statics, how many static gc objects to allow for in this closure.
       offset, where these live in the surrounding closure.
       env, the old env.
       closure, the old closure. *)
d878 4
a881 4
    fun do_app(regs, the_code as ((first, blocks, opt, last), values, procs),
	       regs', the_code' as ((first', blocks', opt', last'), values',
				    procs'),
	       is_same_set, is_same_fn, loop_tag, pos, tag_list, do_tail) =
d883 1
a883 1
      (* First code generate to evaluate which function should be called,*)
d1033 13
a1045 4
      fun exit_block [] = MirTypes.ABSENT
      | exit_block((block as MirTypes.BLOCK(tag, opcode_list)) :: rest) =
	if Lists.exists
	  (fn MirTypes.RTS => true | _ => false)
d1047 3
a1049 2
	  then MirTypes.PRESENT block
	else exit_block rest
d1051 18
a1068 30
      fun small_exit_block(MirTypes.BLOCK(tag, opcode_list)) =
	let
	  val list_without_comments =
	    Lists.filterp
	    (fn (MirTypes.COMMENT _) => false | _ => true)
	    opcode_list
	in
	  length list_without_comments <= 3
	end

      fun append_small_exit(MirTypes.BLOCK(tag, opcode_list), block_list) =
	let
	  fun do_block(block as MirTypes.BLOCK(tag', opc_list)) =
	    if Lists.exists
	      (fn (MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG t)) => tag = t
	      | _ => false)
	      opc_list then
	      (* Difficult case. Append the exit block onto the block *)
	      (* branching to it, and remove the branch and tag *)
	      let
		val opc' = rev opc_list
		fun get_new_opc_list((comm as MirTypes.COMMENT _) :: rest) =
		  comm :: get_new_opc_list rest
		| get_new_opc_list(MirTypes.BRANCH(MirTypes.BRA,
						   MirTypes.TAG t) ::
				   rest) =
		  if t = tag then rest
		  else
		    Crash.impossible"get_new_opc fails to find proper branch"
		| get_new_opc_list _ =
d1070 14
a1083 12
		val new_opc = get_new_opc_list opc'
		fun rev_app([], x) = x
		| rev_app(y, []) = y
		| rev_app(y :: ys, x) = rev_app(ys, y :: x)
	      in
		MirTypes.BLOCK(tag', rev_app(new_opc, opcode_list))
	      end
	    else
	      block
	in
	  map do_block block_list
	end
d1085 60
d1933 1
a1933 1
      val (arg_reg', arg_code, unstack, do_tail, loop_tag) =
d1945 1
a1945 1
	     [], true, loop_tag)
d1948 1
a1948 1
	  case (arg_reg, can_stack_args) of
d1955 1
a1955 1
	       [MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, length args)], false,
d1959 1
a1959 9
	       (arg_reg, arg_code, [], tails, loop_tag))
(*
	  | (LIST args, _) => (arg_reg, arg_code, [], tails, loop_tag)
		  if is_same_set andalso pos <> 0 then
		    Lists.nth(length fn_tag_list + pos - funs_in_closure,
			      fn_tag_list)
		  else
		    loop_tag)
*)
d1963 1
a1963 1
	       fn_tag_list, do_tail)
d2764 1
a2764 35
      val bind_rest_list = map LambdaSub.unwrap_lets le_list''
      val can_select_off_arg =
	map
	(fn (lvar, (bindings, _)) =>
	 Lists.exists
	 (fn (_, LambdaTypes.SELECT(_, LambdaTypes.VAR lv)) => lvar = lv
	  | _ => false)
	 bindings)
	(Lists.zip(fn_args, bind_rest_list))
      val _ =
	map
	(fn (lv, x) => print(LambdaTypes.printLVar lv ^ " can" ^
			     (if x then "" else "'t") ^ " detuple arg"))
	(Lists.zip(lv_list, can_select_off_arg))
      val select_rest_list =
	map
	(fn ((x, ok), fn_arg) =>
	 if ok then
	   let
	     val unwrapped as (bindings, rest) = Tail.get_simple_selects x
	     val arg_refs = LambdaSub.occurrences(fn_arg, lexp)
	   in
	     if arg_refs = 0 then unwrapped
	     else
	       (if arg_refs <> 0 then
		  print("More argument references to " ^
			LambdaTypes.printLVar fn_arg ^ " in function body\n" ^
			LambdaPrint.string_of_lambda lexp ^
			"\nNot tail tuple recursing")
		else ();
		  ([], #2 x))
	   end
	 else ([], #2 x))
	(Lists.zip(Lists.zip(fn_args_and_bodies, can_select_off_arg), fn_args))

a3139 1

@


1.82
log
@Tidied up tail recursion, fixed some bugs and did exit block appending
where relevant.
@
text
@d4 4
d913 1
a913 1
      val closure_env_list as Mir_Env.CLOSURE_ENV map_map :: _ =
d1935 1
d1948 2
a1949 1
	      (ONE(INT(MirTypes.GP_GC_REG caller_arg)),
d1954 4
a1957 2
	       loop_tag)
	  | _ => (arg_reg, arg_code, [], tails, loop_tag)
d2770 35
a2804 1
      val select_rest_list = map Tail.get_simple_selects fn_args_and_bodies
a2850 4
	   val arg_refs = LambdaSub.occurrences(fn_arg, lexp)
	   val _ = if arg_refs <> 0 then
	     print("More argument references to " ^ LambdaTypes.printLVar lvar ^ " in function body\n" ^ LambdaPrint.string_of_lambda lexp ^ "\nNot tail recursing")
		   else ()
d2853 1
a2853 1
		    funs - x div 2, tags, arg_refs = 0, tuple_bindings)
@


1.81
log
@Added tail calling for multi argument functions to self in the case where
the argument doesn't escape.
@
text
@d4 4
d937 2
a938 3
      (* First code generate to evaluate which function should be called,
       then evaluate the argument, then call the function
	 *)
d1087 52
d1909 6
a1914 3
      val is_tupled_arg =
	case (arg_reg, tuple_bindings) of
	  (_, _ :: _) => true
d1917 3
a1919 1
	      (print"Strange tupling up arg with no tuple bindings";
d1923 1
d1933 3
a1935 1
	    (ONE(INT(MirTypes.GP_GC_REG caller_arg)),
d1949 4
a1952 2
	  | _ => (arg_reg, arg_code, [], tails,
		  if is_same_set then
d1957 1
d2806 2
a2807 2
	(fn (((((lexp, (code, env, static_offset, start_at)), new_closure), x),
	      lvar), tuple_bindings) =>
d2809 4
d2815 1
a2815 1
		    funs - x div 2, tags, true, tuple_bindings)
d2833 7
a2839 5
	   (Lists.zip(Lists.zip(le_list''', code_env_static_start_list),
		      new_closure_list),
	    offsets),
	   lv_list),
	  int_reg_list_list))
d3111 23
d3136 2
a3137 1
		  values,
d3139 1
d3142 1
@


1.80
log
@Added tail recursion for two (of the six possible) cases. Added hooks
for two others, involving recursion to self rather than continuation
@
text
@d4 4
d644 7
d652 1
a652 1
	    (offset_in_closure, offset_in_closure < funs_in_closure)
d671 3
a673 1
	   offset, is_same_set)
d823 4
d905 16
d925 1
a925 6
	map
	(fn x =>
	  Lists.reducel
	  (fn (x, y) => Mir_Env.add_closure_env(y, x))
	  (Mir_Env.empty_closure_env, x))
	lambda_offset_list_list)
d929 3
a931 2
      regs', the_code' as ((first', blocks', opt', last'), values', procs'),
			   is_same_set, pos, tag_list, tail_app, tupled_arg) =
d936 4
a950 2
      val do_tail = tail_app andalso not tupled_arg
      (* Later this may expand to deal with more cases *)
d956 1
a956 2
      val extra_code =
	send_to_given_reg(regs',real_arg_reg)
d961 29
a989 17
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG real_closure_reg,
			  MirTypes.GP_GC_REG callee_closure),
	   MirTypes.COMMENT("Set up new closure pointer"),
	   let
	     val dest = MirTypes.TAG(Lists.nth(pos, tag_list))
	   in
	     if do_tail then
	       MirTypes.TAIL_CALL(MirTypes.TAIL, dest)
	     else
	       MirTypes.BRANCH_AND_LINK(MirTypes.BLR, dest)
	   end,
	   MirTypes.COMMENT(if do_tail then
			      "Tail to the function"
			    else "Call the function"),
	   MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
			  MirTypes.GP_GC_REG caller_arg),
	   MirTypes.COMMENT"And acquire result"]
d991 3
d998 1
a998 1
			    MirTypes.GC_REG caller_closure,
d1022 62
d1090 1
a1090 1
		 fn_tag_list, false)
d1152 2
a1153 1
	       static_offset, start_at, funs_in_closure, fn_tag_list, tails) =
d1181 1
a1181 1
	       fn_tag_list, false)
d1199 1
a1199 1
		  fn_tag_list, false)
d1416 14
a1429 1
		   start_at, funs_in_closure, fn_tag_list, false)
d1431 3
a1433 2
	  do_app(regs', the_code', regs, the_code, false, 0, fn_tag_list,
		 tails, case regs' of LIST _ => true | _ => false)
d1792 2
a1793 1
	     static_offset, start_at, funs_in_closure, fn_tag_list, tails) =
d1802 1
a1802 1
	       funs_in_closure, fn_tag_list, tails)
d1807 1
a1807 1
	     funs_in_closure, fn_tag_list, tails) =
d1817 2
a1818 1
      val ((fn_reg, fn_code), pos, is_same_set, can_stack_args, tails) =
d1824 9
d1836 8
a1843 1
		can_stack_parms, tails)
d1847 2
a1848 2
		  fn_tag_list, false),
	    0, false, false, false)
d1853 39
a1891 10
	       false)
      val (arg_reg', arg_code, unstack) = case (arg_reg, can_stack_args) of
	(LIST args, true) =>
	  (ONE(INT(MirTypes.GP_GC_REG caller_arg)),
	   combine(arg_code,
		   ((#2 (stack_tuple_up_in_reg(args, caller_arg)),
		     [], MirTypes.ABSENT, []), [], [])),
	   [MirTypes.DEALLOCATE_STACK(MirTypes.ALLOC, length args)])
      | _ => (arg_reg, arg_code, [])

d1893 4
a1896 3
	do_app(fn_reg, fn_code, arg_reg', arg_code, is_same_set,
	       length fn_tag_list + pos - funs_in_closure, fn_tag_list, tails,
	       case arg_reg of LIST _ => true | _ => false)
d1898 1
d1903 1
a1903 1
	   funs_in_closure, fn_tag_list, _) =
d1913 1
a1913 1
		      fn_tag_list, false))
d1934 1
a1934 1
	     static_offset, start_at, funs_in_closure, fn_tag_list, _) =
d1938 1
a1938 1
	       start_at, funs_in_closure, fn_tag_list, false)
d1959 2
a1960 1
	   static_offset, start_at, funs_in_closure, fn_tag_list, tails) =
d1997 1
a1997 1
	       fn_tag_list, false)
d2018 1
a2018 1
		   funs_in_closure, fn_tag_list, tails)
d2078 2
a2079 1
		     start_at + le_offset, funs_in_closure, fn_tag_list, tails)
d2343 1
a2343 1
		       funs_in_closure, [], false)
d2347 2
a2348 2
		       (([], [], MirTypes.ABSENT, []), [], []), false, 0, [],
		       false, false)
d2411 1
a2411 1
			  funs_in_closure, [], false) of
d2480 1
a2480 1
    | cg_sub(LambdaTypes.VAR lvar, env, closure, _, _, _, _, _) =
d2487 1
a2487 1
    | cg_sub(LambdaTypes.INT i, _, _, _, _, _, _, _) =
d2490 1
a2490 1
	     funs_in_closure, _, _) =
d2510 1
a2510 1
	   start_at, funs_in_closure, fn_tag_list, _) =
d2548 2
a2549 1
	       true)
d2597 1
a2597 1
	     static_offset, start_at, funs_in_closure, fn_tag_list, _) =
a2612 10
      (* see if any tail recursers *)
      val _ =
	map
	(fn x as (lv, le) =>
	 print("Lvar " ^ LambdaTypes.printLVar lv ^ " " ^
	       (if Tail.is_tail x then "allows" else "does not allow") ^
		  " tail recursion")
	 )
	(Lists.zip(lv_list, le_list''))
      val loop_entry_tags = map (fn x => MirTypes.new_tag()) lv_list
d2696 2
a2697 2
      val let_body_list = map LambdaSub.unwrap_lets le_list''
      val arg_select_other_select_list =
d2699 11
a2709 12
	(fn (lvar, let_list) =>
	 let
	   fun arg_select(_, LambdaTypes.SELECT(_, LambdaTypes.VAR lv)) =
	     lvar = lv
	   | arg_select _ = false
	 in
	   (Lists.filterp arg_select let_list,
	    Lists.filterp (not o arg_select) let_list)
	 end)
	(Lists.zip(fn_args, map #1 let_body_list))
      val arg_select_list = map #1 arg_select_other_select_list
      val other_select_list = map #2 arg_select_other_select_list
a2715 8
      val _ =
	map
	(fn (x, y) => print("Lambda "  ^ LambdaTypes.printLVar x ^
			    (case y of [] =>
			       " has no argument selects"
			  | y => " has " ^ Integer.makestring(length y) ^
			       " argument selects")))
	(Lists.zip(fn_args, arg_select_list))
d2728 2
a2729 1
      val le_list''' =
d2731 7
a2737 2
	(fn (x, (_, lexp)) => LambdaSub.wrap_lets(lexp, x))
	(Lists.zip(other_select_list, let_body_list))
d2740 2
a2741 2
	(fn ((((lexp, (code, env, static_offset, start_at)), new_closure), x),
	      loop_tag) =>
d2744 2
a2745 2
	     cg_sub(lexp, env, new_closure, static_offset, start_at, funs - x,
		    tags, true)
d2747 10
a2756 2
	     (([MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG loop_tag)], [],
	       MirTypes.PRESENT loop_tag, []), [], [])
d2760 8
a2767 7
	(Lists.zip(
		   Lists.zip(
			     Lists.zip(Lists.zip(le_list''',
						 code_env_static_start_list),
				       new_closure_list),
			     offsets),
		   loop_entry_tags))
d2769 1
d2773 2
a2774 2
	  cg_sub(lexp, env, new_closure, pos, start_at + pos, funs - x, tags,
		 true))
d2781 1
d2841 2
a2842 2
	       gc_objects_within,
	       start_at + gc_objects_within + funs, funs, fn_tag_list, false)
d2856 1
a2856 1
	     funs_in_closure, fn_tag_list, _) =
d2860 1
a2860 1
	       fn_tag_list, false)
d2875 1
a2875 1
	     start_at, funs_in_closure, fn_tag_list, _) =
d2916 1
a2916 1
	       fn_tag_list, false)
d2955 1
a2955 1
	       false)
d2990 1
a2990 1
	     funs_in_closure, fn_tag_list, _) =
d2996 1
a2996 1
	     Mir_Env.empty_closure_env, 0, 0, 1, [new_tag], false)
@


1.79
log
@Added tail detection. Ensured that stack allocated stuff is deallocated.
Added parameter for detecting tail thread of control
@
text
@d4 4
a385 7
  fun prims_required([], _) = Set.empty_set
  | prims_required(prim :: rest, le_list) =
    Set.union(if lneeds_prim(prim, le_list) then
		Set.singleton prim
	      else Set.empty_set,
		prims_required(rest, le_list))

d902 1
a902 1
			   is_same_set, pos, tag_list) =
d918 9
a926 1
      val extra_code = send_to_given_reg(regs', caller_arg)
d931 1
a931 1
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG caller_closure,
d933 15
a947 7
	    MirTypes.COMMENT("Set up new closure pointer"),
	    MirTypes.BRANCH_AND_LINK(MirTypes.BSR,
			  MirTypes.TAG(Lists.nth(pos, tag_list))),
	    MirTypes.COMMENT"Call the function",
	    MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
			   MirTypes.GP_GC_REG caller_arg),
	    MirTypes.COMMENT"And acquire result"]
d949 19
a967 10
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG caller_closure, fn_reg),
	    MirTypes.COMMENT("Set up new closure pointer"),
	    MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG res_reg,
			     MirTypes.GC_REG caller_closure,
			     MirTypes.GP_IMM_ANY ~1),
	    MirTypes.COMMENT("Get address of code"),
	    MirTypes.BRANCH_AND_LINK(MirTypes.BLR,
				     MirTypes.REG(MirTypes.GC_REG res_reg)),
	    MirTypes.COMMENT("Call the function"),
	    MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
d969 1
a969 1
	    MirTypes.COMMENT("And acquire result")]
d977 69
a1045 2
    fun cg_sub(LambdaTypes.APP(LambdaTypes.BUILTIN prim, lexp), env, closure,
	       static_offset, start_at, funs_in_closure, fn_tag_list, _) =
d1310 2
a1311 1
	  do_app(regs', the_code', regs, the_code, false, 0, fn_tag_list)
d1672 3
a1674 35
      val gc_in_arg = count_gc_objects lexp2
      val (regs, the_code) =
	cg_sub(lexp2, env, closure, static_offset, start_at, funs_in_closure,
	       fn_tag_list, false)
      val (reg, more_code) = case regs of
	ONE(INT reg) => (case reg of
	  MirTypes.GP_GC_REG x =>
	    (MirTypes.GC x, [MirTypes.COMMENT"Function argument"])
	| MirTypes.GP_NON_GC_REG x =>
	    (MirTypes.NON_GC x, [MirTypes.COMMENT"Function argument"])
	| MirTypes.GP_IMM_INT _ =>
	  let
	    val new_reg = MirTypes.new_gc_register()
	  in
	    (MirTypes.GC new_reg,
	      [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg, reg),
	        MirTypes.COMMENT"Function argument"])
	  end
	| MirTypes.GP_IMM_SYMB _ =>
	  let
	    val new_reg = MirTypes.new_gc_register()
	  in
	    (MirTypes.GC new_reg,
	      [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg, reg),
	        MirTypes.COMMENT"Function argument"])
	  end
	| _ => Crash.impossible"Untagged value to APP(FN)")
      | ONE(REAL(MirTypes.FP_REG fp_reg)) =>
	  (MirTypes.FLOAT fp_reg, [MirTypes.COMMENT"Function argument"])
      | LIST many =>
	let val (gc_reg, more_code) = tuple_up(many)
	in
	  (MirTypes.GC gc_reg,
	    MirTypes.COMMENT"Function argument" :: more_code)
	end
d1678 2
a1679 2
	cg_sub(lexp1, env', closure, static_offset + gc_in_arg,
	       start_at + gc_in_arg, funs_in_closure, fn_tag_list, tails)
d1681 1
a1681 3
      (rest_regs, combine(
	combine(the_code,
	  ((more_code, [], MirTypes.ABSENT, []), [], [])), rest_code))
d1714 1
a1714 1
      val (arg_reg, arg_code, unstack) = case (arg_reg, can_stack_args) of
d1724 3
a1726 2
	do_app(fn_reg, fn_code, arg_reg, arg_code, is_same_set,
	       length fn_tag_list + pos - funs_in_closure, fn_tag_list)
d1794 13
a1806 13
	     Pervasives.INTLESS => true
	   | Pervasives.REALLESS => true
	   | Pervasives.INTGREATER => true
	   | Pervasives.REALGREATER => true
	   | Pervasives.INTLESSEQ => true
	   | Pervasives.REALLESSEQ => true
	   | Pervasives.INTGREATEREQ => true
	   | Pervasives.REALGREATEREQ => true
	   | Pervasives.INTEQ => true
	   | Pervasives.INTNE => true
	   | Pervasives.REALEQ => true
	   | Pervasives.REALNE => true
	   | _ => false)
a1832 6
(*
      val _ =
	if is_rel then
	  print(implode["Offset in block ", Integer.makestring offset])
	else ()
*)
d2172 4
a2175 2
		do_app(regs', the_code', ONE(INT(MirTypes.GP_GC_REG caller_arg)),
		       (([], [], MirTypes.ABSENT, []), [], []), false, 0, [])
d2256 1
a2256 1
	    val last_two = case first' of
d2264 2
a2265 2
		  [MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG new_tag),
		   move_inst]
d2269 1
a2269 1
	    val prev_two = case first' of
d2277 2
a2278 2
		  [MirTypes.TEST(cond_branch, new_tag, e1, e2),
		   move_inst]
d2287 2
a2288 2
		  [MirTypes.FTEST(cond_branch, new_tag, e1, e2),
		   move_inst]
d2291 1
a2291 1
	    val first = rev(last_two @@ prev_two @@ (tl(tl first')))
d2343 4
a2346 3
	    Set.map
	    (fn x => Map.lookup(x, prim_to_lambda))
	    (prims_required([Pervasives.STRINGEQ, Pervasives.CALL_C], [fcn]))
d2426 5
a2430 1
      val le_list' = map LambdaSub.eta_abstract le_list
d2432 1
a2432 1
      val le_list'' =
d2434 2
a2435 2
	(fn (LambdaTypes.FN(_, le)) => le
	| _ => Crash.impossible"non-FN in LETREC")
d2437 2
d2448 1
a2453 4
      val lambdas_required =
	Set.map
	(fn x => Map.lookup(x, prim_to_lambda))
	(prims_required([Pervasives.STRINGEQ, Pervasives.CALL_C], le_list))
d2455 14
a2468 5
	Set.union(Set.union(lambdas_required, free),
	    Set.map
	    (fn x => Map.lookup(x, prim_to_lambda))
	    (Library.implicit_external_references(LambdaTypes.STRUCT le_list)))
      (* Put the functions into a STRUCT for ease of code *)
d2529 48
d2579 12
a2590 6
	(fn (((LambdaTypes.FN(lvar, lexp), new_closure), pos), x) =>
	  cg_sub(lexp, Mir_Env.add_lambda_env((lvar, MirTypes.GC callee_arg),
					      Mir_Env.empty_lambda_env),
		 (* All bets for registers are off, barring the argument *)
		 new_closure, pos, start_at + pos, funs - x, tags, true)
	  | _ => Crash.impossible"non-FN in LETREC")
d2592 17
a2608 2
	    Lists.zip(
	      Lists.zip(le_list', new_closure_list), positions),
@


1.78
log
@Changed the calls to the Library module to reflect the changes there.
@
text
@d4 3
d296 1
d322 1
d329 2
a330 1
    LambdaPrint.LambdaTypes = Library.LambdaTypes = InterProc.LambdaTypes
d956 1
a956 1
	       static_offset, start_at, funs_in_closure, fn_tag_list) =
d984 1
a984 1
	       fn_tag_list)
d1002 1
a1002 1
		  fn_tag_list)
d1219 1
a1219 1
		   start_at, funs_in_closure, fn_tag_list)
d1579 2
a1580 2
    | cg_sub(LambdaTypes.APP(LambdaTypes.FN(lvar, lexp1), lexp2), env,
	     closure, static_offset, start_at, funs_in_closure, fn_tag_list) =
d1585 1
a1585 1
	       fn_tag_list)
d1621 1
a1621 1
	       start_at + gc_in_arg, funs_in_closure, fn_tag_list)
d1628 1
a1628 1
	     funs_in_closure, fn_tag_list) =
d1634 2
a1635 5
	  let
	  in
	    Map.domain_member(lv, escape_map) andalso
	    not(Map.lookup(lv, escape_map))
	  end
d1638 1
a1638 1
      val ((fn_reg, fn_code), pos, is_same_set, can_stack_args) =
d1647 1
a1647 1
		can_stack_parms)
d1651 2
a1652 2
		  fn_tag_list),
	    0, false, false)
d1656 3
a1658 2
	       start_at + gc_objects_in_call, funs_in_closure, fn_tag_list)
      val (arg_reg, arg_code) = case (arg_reg, can_stack_args) of
d1663 3
a1665 2
		     [], MirTypes.ABSENT, []), [], [])))
      | _ => (arg_reg, arg_code)
d1670 1
d1672 1
a1672 1
      (reg, code)
d1675 1
a1675 1
	   funs_in_closure, fn_tag_list) =
d1685 1
a1685 1
		      fn_tag_list))
d1706 1
a1706 1
	     static_offset, start_at, funs_in_closure, fn_tag_list) =
d1710 1
a1710 1
	       start_at, funs_in_closure, fn_tag_list)
d1731 1
a1731 1
	   static_offset, start_at, funs_in_closure, fn_tag_list) =
d1768 1
a1768 1
	       fn_tag_list)
d1795 2
a1796 1
		   funs_in_closure, fn_tag_list)
d1855 2
a1856 1
		     start_at + le_offset, funs_in_closure, fn_tag_list)
d2119 1
a2119 1
		       funs_in_closure, [])
d2185 1
a2185 1
			  funs_in_closure, []) of
d2254 1
a2254 1
    | cg_sub(LambdaTypes.VAR lvar, env, closure, _, _, _, _) =
d2261 1
a2261 1
    | cg_sub(LambdaTypes.INT i, _, _, _, _, _, _) =
d2264 1
a2264 1
	     funs_in_closure, _) =
d2284 1
a2284 1
	   start_at, funs_in_closure, fn_tag_list) =
d2320 2
a2321 1
	       new_closure, 0, start_at, 1, [tag] (* tag for this function *))
d2369 1
a2369 1
	     static_offset, start_at, funs_in_closure, fn_tag_list) =
d2379 9
d2469 1
a2469 1
		 new_closure, pos, start_at + pos, funs - x, tags)
d2535 1
a2535 1
	       start_at + gc_objects_within + funs, funs, fn_tag_list)
d2549 1
a2549 1
	     funs_in_closure, fn_tag_list) =
d2553 1
a2553 1
	       fn_tag_list)
d2568 1
a2568 1
	     start_at, funs_in_closure, fn_tag_list) =
d2609 1
a2609 1
	       fn_tag_list)
d2647 2
a2648 1
	       start_at + gc_objects_in_le, funs_in_closure, fn_tag_list)
d2683 1
a2683 1
	     funs_in_closure, fn_tag_list) =
d2689 1
a2689 1
	     Mir_Env.empty_closure_env, 0, 0, 1, [new_tag])
@


1.77
log
@Removed some spurious debugging messages
@
text
@d4 3
d365 1
a365 1
    Set.is_member(prim, Library.builtin_external_set le)
d421 1
a421 1
      if prim = Library.load_string then 0 else count_gc_objects le'
d754 2
a755 2
    val (prim_to_lambda, lambda_to_prim, bindings) =
      Library.get_env_and_bindings lambda_exp
a756 3
    val new_lambda_exp =
      Library.add_pervasive_refs(lambda_exp, prim_to_lambda, bindings)

d772 1
a772 1
	  if prim = Library.load_string then Set.singleton chars
d982 8
d992 1
a992 1
	      [LambdaTypes.VAR(Map.lookup(Library.prim_to_exn prim,
a1492 1
      | Pervasives.MAKE_NEW_UNIQUE => do_external_prim prim
d1643 1
a1643 1
	        is_same_set, Map.domain_member(lvar, lambda_to_prim) orelse
d2288 1
a2288 1
		    (Library.builtin_implicit_set fcn))
d2383 1
a2383 1
	    (Library.builtin_implicit_set(LambdaTypes.STRUCT le_list)))
@


1.76
log
@Changed Match_Utils.Qsort for Lists.qsort
@
text
@d4 3
d1721 1
a1721 1
      val (is_rel, _) = case lexp of
d1724 14
a1737 19
	     Pervasives.INTLESS => (true, print"Builtin relation INTLESS")
	   | Pervasives.REALLESS => (true, print"Builtin relation REALLESS")
	   | Pervasives.INTGREATER =>
	       (true, print"Builtin relation INTGREATER")
	   | Pervasives.REALGREATER =>
	       (true, print"Builtin relation REALGREATER")
	   | Pervasives.INTLESSEQ => (true, print"Builtin relation INTLESSEQ")
	   | Pervasives.REALLESSEQ =>
	       (true, print"Builtin relation REALLESSEQ")
	   | Pervasives.INTGREATEREQ =>
	       (true, print"Builtin relation INTGREATEREQ")
	   | Pervasives.REALGREATEREQ =>
	       (true, print"Builtin relation REALGREATEREQ")
	   | Pervasives.INTEQ => (true, print"Builtin relation INTEQ")
	   | Pervasives.INTNE => (true, print"Builtin relation INTNE")
	   | Pervasives.REALEQ => (true, print"Builtin relation REALEQ")
	   | Pervasives.REALNE => (true, print"Builtin relation REALNE")
	   | _ => (false, print"Switch not on builtin relation"))
      | _ => (false, print"Switch not on builtin relation")
d1763 1
d1768 1
d1857 1
a1857 1

d1863 1
@


1.75
log
@Fixed bug whereby tupled up updates of refs failed.
@
text
@d4 3
a280 1
require "../match/match_utils";
a302 1
  structure Match_Utils : MATCH_UTILS
d1975 1
a1975 1
	    Match_Utils.Qsort (fn ((i:int, _, _), (i', _, _)) => i < i')
d2003 1
a2003 1
	      Match_Utils.Qsort (fn ((i:int, _, _, _), (i', _, _, _)) =>
@


1.74
log
@Added some brackets to keep njml 0.75 happy
@
text
@d4 3
d1255 27
a1281 20
	  (case regs of
	    LIST[INT(MirTypes.GP_GC_REG reg), arg] =>
	      let
		val (new_reg, code) = send_to_reg(ONE arg)
		val result = MirTypes.new_gc_register()
		val res1 = MirTypes.GC_REG result
	      in
		(ONE(INT(MirTypes.GP_GC_REG result)),
		 combine(the_code,
		   ((code @@
		     [MirTypes.STOREOP(MirTypes.STREF, reg_from_gp new_reg,
				       MirTypes.GC_REG reg,
				       MirTypes.GP_IMM_ANY 1),
		       MirTypes.COMMENT"Update a reference cell",
		       MirTypes.UNARY(MirTypes.MOVE, res1,
				      MirTypes.GP_IMM_INT 0),
		       MirTypes.COMMENT"Dummy result"],
			 [], MirTypes.ABSENT, []), [], [])))
	      end
	  | _ => Crash.impossible"BECOMES of bad parms")
@


1.73
log
@Changed to use exception generating versions of fp opcodes
@
text
@d4 3
d2333 1
a2333 1
	case tag_opt of
d2335 1
a2335 1
	| MirTypes.PRESENT tag => [MirTypes.BLOCK(tag, last)])]
d2628 1
a2628 1
	case exn_o of
d2630 1
a2630 1
	| _ => []
d2634 1
a2634 1
	case exn_o of
d2636 1
a2636 1
	| MirTypes.PRESENT tag => [MirTypes.BLOCK(tag, exn_l @@ exn_end)]
@


1.72
log
@Fixed the in-line code for CALL_C.  Generated lambda expression will
pervasive references filled in before making the top level tags and
counting the garbage collectible objects.
@
text
@d4 5
a369 8
(*
  fun eta_abstract le =
    let val lvar = LambdaTypes.new_LVar()
    in
      LambdaTypes.FN(lvar, LambdaTypes.APP(le, LambdaTypes.VAR lvar))
    end
*)

a543 10
(*
	       let
		 val (new_reg', code) = save_real(fp_op)
	       in
		 code @@
		 [MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg',
				   MirTypes.GC_REG new_reg,
				   imm)]
	       end
*)
d1049 1
a1049 1
      fun binary_fcalc opcode =
d1077 2
d1084 2
a1085 2
		  [(MirTypes.BINARYFP(opcode, result, val1, val2))],
		  [], MirTypes.ABSENT, []), [], [])))
d1107 19
d1329 5
a1333 1
	    val result = MirTypes.GP_GC_REG(MirTypes.new_gc_register())
d1335 1
a1335 1
	    (ONE(INT result),
d1345 2
a1346 1
		        MirTypes.CONVOP(MirTypes.FTOI, fp_op, result)]
d1349 1
a1349 1
		    [MirTypes.CONVOP(MirTypes.FTOI, reg, result)]
d1351 1
a1351 1
		  [], MirTypes.ABSENT, []), [], [])))
d1362 2
a1363 2
		   [MirTypes.CONVOP(MirTypes.ITOF, result,
				    arg)]
d1365 1
a1365 1
		   [MirTypes.CONVOP(MirTypes.ITOF, result,
d1368 1
a1368 1
		   [MirTypes.CONVOP(MirTypes.ITOF, result,
d1373 1
a1373 1
      | Pervasives.SQRT => unary_fcalc MirTypes.FSQRT
d1377 2
a1378 2
      | Pervasives.EXP => unary_fcalc MirTypes.FETOX
      | Pervasives.LN => unary_fcalc MirTypes.FLOGE
d1431 1
a1431 1
      | Pervasives.FDIV => binary_fcalc MirTypes.FDIV
d1469 1
a1469 1
      | Pervasives.REALPLUS => binary_fcalc MirTypes.FADD
d1471 1
a1471 1
      | Pervasives.REALSTAR => binary_fcalc MirTypes.FMUL
d1473 1
a1473 1
      | Pervasives.REALMINUS => binary_fcalc MirTypes.FSUB
d1475 1
a1475 1
      | Pervasives.REALUMINUS => unary_fcalc MirTypes.FNEG
d1512 1
a1512 1
      | Pervasives.REALABS => unary_fcalc MirTypes.FABS
a1604 12
(*
	    val _ = print"Compiling APP(VAR _, _)"
	    val _ =
	      print(
		    if Map.domain_member(lv, escape_map) then
		      if Map.lookup(lv, escape_map) then
			"Known escaping function"
		      else
			"Known non-escaping function"
		    else
		      "Escape status unknown for " ^ LambdaTypes.printLVar lv)
*)
d1609 1
a1609 8
      | _ =>
	  let
(*
	    val _ = print"Compiling APP(_, _)"
*)
	  in
	    false
	  end
a2256 5
(*
      val _ = print("Compiling function with " ^
		    (if InterProc.escapes(lvar, lexp) then "" else "non-") ^
		       "escaping argument")
*)
a2347 9
(*
      val _ =
	map
	(fn (LambdaTypes.FN(lvar, lexp)) =>
	     print("Compiling functions with " ^
		   (if InterProc.escapes(lvar, lexp) then "" else "non-") ^
		      "escaping argument"))
	le_list'
*)
a2637 5
(*
	  combine(((frame_setup, [], MirTypes.ABSENT, []), [], []),
	    combine(main_code,
	      ((main_end, [], MirTypes.PRESENT end_tag, []), [], []))),
*)
@


1.71
log
@Replaced eta_abstract with reference to LambdaSub
@
text
@d4 3
a753 1
    val number_of_gc_objects = count_gc_objects lambda_exp
d757 5
a770 3
    val new_lambda_exp =
      Library.add_pervasive_refs(lambda_exp, prim_to_lambda, bindings)

d1525 3
a1527 2
	     ((make_args_for_call_c regs, [], MirTypes.ABSENT, []),
	      [], []))
@


1.70
log
@Added code generation for CALL_C pervasive.  This seems to produce
incorrect code at the moment.
@
text
@d4 4
d362 1
d368 1
d414 2
a415 1
      (count_gc_objects lexp, map (count_gc_objects o eta_abstract) le_list)
d2347 1
a2347 1
      val le_list' = map eta_abstract le_list
@


1.69
log
@Fixed redundant match problem
@
text
@d4 3
d1489 28
a1516 1
      | Pervasives.CALL_C => do_external_prim prim
d1518 3
a1520 1
	  raise (Crash.impossible"Impossible load_string")
@


1.68
log
@Fixed bug whereby an allocation could happen before the fields of
the previous one had been written. Occurred when tupling up a list
contain FP registers, eg in val x = sqrt 1.0
@
text
@d4 5
d634 1
a634 2
	   | MirTypes.FLOAT reg => REAL(MirTypes.FP_REG reg)
	   | _ => Crash.impossible"lookup_lambda returns const"),
d971 2
a972 2
	  val (_, ((exn_f, exn_b, exn_o, exn_l), [], [])) =
	    cg_sub(LambdaTypes.RAISE(LambdaTypes.STRUCT
d980 4
a983 1
	      ("Assoc fail on " ^ Pervasives.print_pervasive prim)
@


1.67
log
@Added case spotting code to handle if relation and avoid doubled tests
@
text
@d4 3
d485 15
d504 1
a504 1
      ([alloc_op],
d527 3
a529 1
	     | (REAL fp_op, imm) =>
d538 2
a539 1
	     | _ => Crash.impossible"Tuple_up untagged value")
@


1.66
log
@Corrected writing of stack tuples to assume correctly tagged pointers
@
text
@d4 3
d1520 1
d1531 1
d1538 1
d1540 1
d1638 22
d1678 11
d1767 16
d2101 46
d2191 1
d2195 1
d2287 1
d2295 1
@


1.65
log
@Added stack allocation of arguments in the instance where the referenced
function does not allow its argument to escape
@
text
@d4 4
d526 1
a526 1
      Lists.number_from(reg_list, 0, 4, MirTypes.GP_IMM_ANY)
@


1.64
log
@Added use of InterProc for determining procedures which don't return
their arguments
@
text
@d4 4
d286 2
a287 1
  sharing EnvironTypes.Map = Map = Mir_Env.Map = Environ.Map = Library.Map
d296 1
a296 1
  val silly_val = ~100
d451 1
a451 1
			    MirTypes.GP_IMM_ANY ~1)])
d458 2
a459 1
     MirTypes.STOREFPOP(MirTypes.FST, fp_op, reg, MirTypes.GP_IMM_ANY ~1)]
d763 2
d1028 1
a1028 1
		     reg_from_gp reg1, MirTypes.GP_IMM_ANY ~1),
d1031 1
a1031 1
		     reg_from_gp reg2, MirTypes.GP_IMM_ANY ~1)])
d1061 1
a1061 1
				       MirTypes.GP_IMM_ANY ~1),
d1283 1
a1283 1
					  MirTypes.GP_IMM_ANY ~1),
d1508 25
a1532 3
      (* First code generate to evaluate which function should be called,
         then evaluate the argument, then call the function
       *)
d1542 2
a1543 1
	        is_same_set, Map.domain_member(lvar, lambda_to_prim))
d1920 1
a1920 1
					 funs_in_closure) - 1)),
d2208 1
a2208 1
	map (fn x => Map.lookup(start_at + gc_objects_within + x + 1,
@


1.63
log
@Modified mutually recursive closures to have holes in them to get
code pointer alignment correct
@
text
@d4 4
d244 1
d270 1
d277 1
a277 1
    LambdaPrint.LambdaTypes = Library.LambdaTypes
d1166 1
d1171 2
a1172 2
		  [MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, 0)] @@
		  [MirTypes.COMMENT"Allocate a ref cell",
d1174 7
a1180 1
				   MirTypes.GP_IMM_ANY ~3)],
d1196 1
a1196 1
				       MirTypes.GP_IMM_ANY ~3),
d1199 2
a1200 1
				      MirTypes.GP_IMM_INT 0)],
d1215 1
a1215 1
					MirTypes.GP_IMM_ANY ~3),
d2054 3
d2147 7
@


1.62
log
@Fixed code determining whether a procedure is a leaf procedure or not.
@
text
@d4 3
d759 4
a762 1
      val funs = length tags
d766 2
a767 1
	Lists.number_from_by_one(tags, 0, fn x => x)
d2150 2
a2151 1
	map #2 (#1 (Lists.number_from_by_one(list_of(funs, 0), 0, fn x => x)))
d2181 1
a2181 1
	  (closure, #1 (Lists.number_from_by_one(lv_list, 0 - offset, fn x=> x))))
d2184 1
d2196 10
@


1.61
log
@Modified instruction order on a raise to allow better scheduling
@
text
@d4 3
d355 1
a355 1
    | makes_calls(LambdaTypes.STRUCT le_list) = makes_calls_list le_list
d364 1
a364 1
    | makes_calls_list(x :: xs) = makes_calls x orelse makes_calls_list xs
d2080 1
a2080 3
(*
      val makes_calls = count_real_apps lexp <> 0
*)
d2455 1
a2455 1
		    MirTypes.PROC_PARAMS {leaf = true,
@


1.60
log
@Changed the form of the ALLOCATE and DEALLOCATE instructions yet again.
@
text
@d4 3
d329 13
a341 13
  fun count_real_apps(LambdaTypes.VAR _) = 0
    | count_real_apps(LambdaTypes.APP(LambdaTypes.FN(lv, le), le')) =
      count_real_apps le + count_real_apps le'
    | count_real_apps(LambdaTypes.APP(LambdaTypes.BUILTIN _, le)) =
      count_real_apps le
    | count_real_apps(LambdaTypes.APP(le, le')) =
      1 + count_real_apps le + count_real_apps le'
    | count_real_apps(LambdaTypes.FN(lv, lexp)) = count_real_apps lexp
    | count_real_apps(LambdaTypes.LETREC(lv_list, le_list, lexp)) =
      Lists.reducel op +
      (count_real_apps lexp, map (count_real_apps o eta_abstract) le_list)
    | count_real_apps(LambdaTypes.SWITCH(le, tag_le_list, le1_opt, le2_opt)) =
      let fun count_tag_list [] = 0
d344 4
a347 4
	    LambdaTypes.EXP_TAG lexp => count_real_apps lexp
	  | _ => 0) + count_real_apps le + count_tag_list rest
	fun count_le_opt LambdaTypes.ABSENT = 0
	| count_le_opt(LambdaTypes.PRESENT le) = count_real_apps le
d349 2
a350 2
	count_real_apps le + count_tag_list tag_le_list +
	count_le_opt le1_opt + count_le_opt le2_opt
d352 7
a358 9
    | count_real_apps(LambdaTypes.STRUCT le_list) =
      Lists.reducel op + (0, map count_real_apps le_list)
    | count_real_apps(LambdaTypes.SELECT(_, le)) = count_real_apps le
    | count_real_apps(LambdaTypes.RAISE le) = count_real_apps le
    | count_real_apps(LambdaTypes.HANDLE(le, le')) =
      count_real_apps le + count_real_apps le'
    | count_real_apps(LambdaTypes.SCON _) = 0
    | count_real_apps(LambdaTypes.INT _) = 0
    | count_real_apps(LambdaTypes.BUILTIN _) = 0
d360 3
d497 46
d692 2
a693 1
    val (prim_to_lambda, bindings) = Library.get_env_and_bindings lambda_exp
d1480 1
a1480 1
      val ((fn_reg, fn_code), pos, is_same_set) =
d1488 1
a1488 1
	        is_same_set)
d1493 1
a1493 1
	    0, false)
d1498 8
d2077 1
d2079 1
d2100 1
a2100 1
		       {leaf = not makes_calls,
d2280 2
d2283 1
a2283 3
	[MirTypes.STOREOP(MirTypes.LD, temp_reg, MirTypes.GC_REG handler,
			  MirTypes.GP_IMM_ANY 0),
	 MirTypes.RAISE(temp_reg),
@


1.59
log
@Changed type of destruct_2_tuple to avoid a lot of the inexhaustive
bindings that were around in this functor. Fixed a bug where an
absent tag was mistakenly flagged as an impossible condition.
@
text
@d4 5
d1862 4
a1865 3
	        MirTypes.ALLOCATE(MirTypes.ALLOC_STACK,
				  MirTypes.GC_REG caller_arg,
				  2),
d1874 1
a1874 1
	      [MirTypes.DEALLOCATE(MirTypes.DEALLOC_STACK, 2),
d2258 4
a2261 1
	[MirTypes.ALLOCATE(MirTypes.ALLOC_STACK, handler_frame, frame_size),
d2275 1
a2275 1
	 MirTypes.DEALLOCATE(MirTypes.DEALLOC_STACK, frame_size),
@


1.58
log
@The ALLOCATE opcode doesn't need a scratch register or a way of
referencing callc so the extra arguments required to pass this
information around have been completely removed.
@
text
@d4 5
d553 8
a560 8
      (LIST[INT(MirTypes.GP_GC_REG reg1),
	INT(MirTypes.GP_GC_REG reg2)],
        [MirTypes.STOREOP(MirTypes.LD,
	  MirTypes.GC_REG reg1, MirTypes.GC_REG gc_reg,
			  MirTypes.GP_IMM_ANY ~1),
	  MirTypes.STOREOP(MirTypes.LD,
	    MirTypes.GC_REG reg2, MirTypes.GC_REG gc_reg,
			  MirTypes.GP_IMM_ANY 3)])
d882 1
a882 1
	  val (regs, new_code) =
d885 1
a885 1
	    | LIST[INT reg1, INT reg2] => (regs, [])
d890 6
a895 8
	  case regs of
	    LIST[INT val1, INT val2] =>
	      (ONE(INT res1), combine(the_code,
		((new_code @@
		  [(MirTypes.TBINARY(opcode,
		    exn_tag, res2, val1, val2))],
		  exn_blocks, MirTypes.ABSENT, []), [], [])))
	  | _ => Crash.impossible"cg_sub(BUILTIN 1)"
d903 1
a903 1
	  val (regs, new_code) =
d906 1
a906 1
	    | LIST[INT reg1, INT reg2] => (regs, [])
d909 5
a913 7
	  case regs of
	    LIST[INT val1, INT val2] =>
	      (ONE(INT res1), combine(the_code,
		((new_code @@
		  [(MirTypes.BINARY(opcode, res2, val1, val2))],
		  [], MirTypes.ABSENT, []), [], [])))
	  | _ => Crash.impossible"cg_sub(BUILTIN 1)"
d940 1
a940 1
		  val (LIST regs, new_code) = destruct_2_tuple reg
d944 8
a951 10
		  case regs of
		    [INT reg1, INT reg2] =>
		      (LIST[REAL freg1, REAL freg2],
		        new_code @@
		        [MirTypes.STOREFPOP(MirTypes.FLD, freg1,
			  reg_from_gp reg1, MirTypes.GP_IMM_ANY ~1),
		          MirTypes.STOREFPOP(MirTypes.FLD, freg2,
			  reg_from_gp reg2, MirTypes.GP_IMM_ANY ~1)])
	          | _ =>
		      Crash.impossible"destruct_2_tuple fails to give INTs"
d996 1
a996 1
	    val (LIST[INT val1, INT val2], new_code) = case regs of
d998 1
a998 1
	    | LIST[INT reg1, INT reg2] => (regs, [])
d1020 18
a1037 17
	    val (LIST[REAL val1, REAL val2], new_code) = case regs of
	      ONE(INT(reg as MirTypes.GP_GC_REG _)) =>
		let
		  val (LIST[reg1, reg2], des_code) = destruct_2_tuple reg
		  val (fp1, code1) = get_real reg1
		  val (fp2, code2) = get_real reg2
		in
		  (LIST[REAL fp1, REAL fp2], des_code @@ code1 @@ code2)
		end
	    | LIST[reg1, reg2] =>
		let
		  val (fp1, code1) = get_real reg1
		  val (fp2, code2) = get_real reg2
		in
		  (LIST[REAL fp1, REAL fp2], code1 @@ code2)
		end
	    | _ => Crash.impossible"cg_sub(BUILTIN 0)"
d2347 1
a2347 1
    val (reg, last) = case regs of
d2360 3
a2362 1
    val last = last @@ [MirTypes.RTS]
d2367 1
d2369 6
a2374 4
      case (tag_opt, blocks) of
	(MirTypes.ABSENT, []) => (entry @@ last, [])
      | (MirTypes.PRESENT tag, blocks) =>
	  (entry, MirTypes.BLOCK(tag, last) :: blocks)
d2376 3
a2378 1
    val (loc_refs, next) = Lists.number_from_by_one(clos_range, 0, fn x => x)
d2381 1
@


1.57
log
@Allowed () as a final result for programs like
val _ = output(std_out, "Hello world") (which are obviously
very important!)
@
text
@d4 5
d424 4
a427 8
  fun save_real_to_reg(fp_op, reg, call_to_c) =
    let
      val temp_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
    in
      MirTypes.ALLOCATE(MirTypes.ALLOC_REAL, reg, 0, temp_reg, call_to_c) ::
      [MirTypes.STOREFPOP(MirTypes.FST, fp_op, reg, MirTypes.GP_IMM_ANY ~1)]
(* Store as to a pointer (tag 1) *)
    end
d429 1
a429 1
  fun save_real(fp_op, offset) =
d434 1
a434 1
      (new_reg, save_real_to_reg(fp_op, new_r, offset))
d437 1
a437 1
  fun tuple_up_in_reg(reg_list, new_reg, call_to_c) =
a440 1
    val temp_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
d442 1
a442 2
      MirTypes.ALLOCATE(MirTypes.ALLOC, MirTypes.GC_REG new_reg, len, temp_reg,
			call_to_c)
d472 1
a472 1
		 val (new_reg', code) = save_real(fp_op, call_to_c)
d483 2
a484 2
  fun tuple_up(reg_list, offset) =
    tuple_up_in_reg(reg_list, MirTypes.new_gc_register(), offset)
d573 1
a573 1
  fun send_to_given_reg(cg_res, gc_reg, offset) =
d589 2
a590 2
	    save_real_to_reg(fp_op, MirTypes.GC_REG gc_reg, offset))
    | LIST many => #2 (tuple_up_in_reg(many, gc_reg, offset))
d592 1
a592 1
  fun send_to_reg(ONE reg, offset) =
d611 1
a611 1
	   val (reg, code) = save_real(fp_op, offset)
d615 2
a616 2
  | send_to_reg(LIST many, offset) =
    let val (gc_reg, code) = tuple_up(many, offset)
a632 2
    val call_c_lambda = Map.lookup(Pervasives.CALL_C, prim_to_lambda)
    val call_c_reg = ref(MirTypes.GC caller_arg)
a633 13
    fun call_c_code(env, closure) =
      if Mir_Env.is_in_closure(call_c_lambda, closure) then
	MirTypes.CLOSURE_REF
	(MirTypes.GC_REG callee_closure,
	 (Mir_Env.lookup_in_closure(call_c_lambda, closure)))
      else
	if Mir_Env.is_in_lambda_env(call_c_lambda, env) then
	  MirTypes.REG_REF(case Mir_Env.lookup_lambda(call_c_lambda, env) of
	    MirTypes.GC reg => MirTypes.GC_REG reg
	  | _ => Crash.impossible"call_c_lambda not a gc regsiter")
	else
	  MirTypes.REG_REF(MirTypes.GC_REG callee_arg)

d684 1
a684 1
    fun make_closure(tags, free, statics, offset, env, closure, call_to_c) =
d724 1
a724 1
	      let val (reg', code) = send_to_reg(ONE reg, call_to_c)
a756 1
      val temp_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
d759 1
a759 2
        MirTypes.ALLOCATE(MirTypes.ALLOC, reg_operand, closure_size, temp_reg,
			  call_to_c) ::
d771 1
a771 1
			   is_same_set, pos, tag_list, call_to_c) =
d787 1
a787 1
      val extra_code = send_to_given_reg(regs', caller_arg, call_to_c)
d1060 1
a1060 2
	  do_app(regs', the_code', regs, the_code, false, 0, fn_tag_list,
		 call_c_code(env, closure))
d1091 1
a1091 1
	    val (new_reg, code) = send_to_reg(regs, call_c_code(env, closure))
a1093 1
	    val temp_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
d1098 1
a1098 2
		  [MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, 0, temp_reg,
				     call_c_code(env, closure))] @@
d1108 1
a1108 2
		val (new_reg, code) = send_to_reg(ONE arg,
						  call_c_code(env, closure))
d1246 1
a1246 3
	      val (new_reg, code) = send_to_reg(regs,
						call_c_code(env, closure))
	      val temp_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
d1255 1
a1255 2
		  MirTypes.ALLOCATE(MirTypes.ALLOC_STRING, res2, 1, temp_reg,
				    call_c_code(env, closure))] @@
d1402 1
a1402 1
	let val (gc_reg, more_code) = tuple_up(many, call_c_code(env, closure))
a1406 4
      val _ =
	if lvar = call_c_lambda then
	  call_c_reg := reg
	else ()
d1444 1
a1444 2
	       length fn_tag_list + pos - funs_in_closure, fn_tag_list,
	       call_c_code(env, closure))
d1468 1
a1468 1
	      val (reg, code) = tuple_up(regs, call_c_code(env, closure))
d1545 1
a1545 2
		save_real_to_reg(reg, MirTypes.GC_REG end_reg,
				 call_c_code(env, closure))
d1547 1
a1547 2
	      (#2 (tuple_up_in_reg(many, end_reg,
				   call_c_code(env, closure))))) @@
d1585 1
a1585 1
	    let val (gc_reg, code) = tuple_up(many, call_c_code(env, closure))
d1650 1
a1650 2
		save_real_to_reg(fp_op, MirTypes.GC_REG end_reg,
				 call_c_code(env, closure))
d1652 1
a1652 2
		#2 (tuple_up_in_reg(many, end_reg,
				    call_c_code(env, closure)))) @@
d1684 1
a1684 2
	      save_real_to_reg(fp_op, MirTypes.GC_REG end_reg,
			       call_c_code(env, closure))
d1686 1
a1686 1
	      #2 (tuple_up_in_reg(many, end_reg, call_c_code(env, closure)))) @@
d1725 1
a1725 1
	  val (the_reg, extra) = send_to_reg(regs, call_c_code(env, closure))
d1754 1
a1754 1
	    val (the_reg, extra) = send_to_reg(regs, call_c_code(env, closure))
d1847 1
a1847 2
		       (([], [], MirTypes.ABSENT, []), [], []), false, 0, [],
		       call_c_code(env, closure))
a1851 1
	      val temp_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
d1859 1
a1859 1
				  2, temp_reg, call_c_code(env, closure)),
d1981 1
a1981 2
			  static_offset + funs_in_closure, env, closure,
			  call_c_code(env, closure)) of
d2003 1
a2003 3
	  send_to_given_reg(fn_reg, result_temporary,
			    call_c_code(Mir_Env.empty_lambda_env,
					new_closure)) @@
d2083 1
a2083 2
		     static_offset + funs_in_closure, env, closure,
		     call_c_code(env, closure))
d2138 1
a2138 3
	     send_to_given_reg(x, result_temporary,
			       call_c_code(Mir_Env.empty_lambda_env,
					   new_closure)) @@
d2213 1
a2213 1
	send_to_given_reg(reg, caller_arg, call_c_code(env, closure)) @@
a2250 1
      val temp_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
d2252 7
a2258 8
	[MirTypes.ALLOCATE(MirTypes.ALLOC_STACK, handler_frame, frame_size,
			   temp_reg, call_c_code(env, closure)),
	  MirTypes.NEW_HANDLER handler_tag,
	  MirTypes.ADR(MirTypes.LEA, handler_ptr, handler_tag)] @@
	  frame_setup @@
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG handler,
			  MirTypes.GP_GC_REG handler_frame_reg),
	    MirTypes.COMMENT"Set up new handler pointer"]
d2264 1
a2264 1
	send_to_given_reg(main_reg, result_reg, call_c_code(env, closure)) @@
d2315 1
a2315 2
	send_to_given_reg(exn_result_reg, result_reg,
			  call_c_code(env, closure)) @@
a2346 1
    val call_to_c = MirTypes.REG_REF(MirTypes.any_to_reg(!call_c_reg))
d2350 1
a2350 2
	val (reg, new_code) = tuple_up_in_reg(sub_regs, callee_arg,
					      call_to_c)
@


1.56
log
@Fixed bug whereby call_c was being generated from wrong closure during
function and letrec generation
@
text
@d4 4
d2402 5
@


1.55
log
@Added BTA and BNT for tagged value testing
Allowed multiple top level blocks for handlers
@
text
@d4 4
d2038 2
a2039 1
			    call_c_code(env, closure)) @@
d2171 1
a2171 1
	  fun send (x,_) =
d2176 2
a2177 1
			       call_c_code(env, closure)) @@
d2187 1
a2187 1
	  map send fn_reg_code_list
@


1.54
log
@Took out some old printing functions which used NewJersey print.
Put in a Crash.impossible instead of raise ...
@
text
@d4 4
d1603 1
a1603 1
	let val new_reg = MirTypes.new_non_gc_register()
d1615 1
a1615 4
	  [MirTypes.BINARY(MirTypes.AND, MirTypes.NON_GC_REG new_reg, source,
			   MirTypes.GP_IMM_ANY 3),
	   MirTypes.TEST(MirTypes.BNE, tag2, MirTypes.GP_NON_GC_REG new_reg,
			  MirTypes.GP_IMM_INT 0)]
d2394 1
a2394 1
    val first =
d2397 7
a2403 4
		     MirTypes.GP_GC_REG callee_arg) ::
      case (tag_opt, blocks)
	of (MirTypes.ABSENT, []) => first @@ last
	 | _ => Crash.impossible"Multiple blocks in top level"
d2413 1
a2413 1
		    [MirTypes.BLOCK(new_tag, first)])
@


1.53
log
@The structure LambdaSub.LambdaTypes is now called LambdaSub.LT
@
text
@d4 3
a549 5
(*
let
val _ = print("Combine: first value length: " ^ Integer.makestring(length values) ^ " second value length: " ^ Integer.makestring(length values'))
in
*)
a560 3
(*
end
*)
d637 1
a637 8
(*
    val _ = print(Integer.makestring(length bindings) ^ " bindings\n" ^
		  Integer.makestring(length(Map.assoc prim_to_lambda)) ^
		  " lambdas")
    val _ = print(Integer.makestring number_of_gc_objects ^ " gc objects")
    val _ = print"Pervasive bindings"
    val _ = map (print o Pervasives.print_pervasive o #1) (Map.assoc prim_to_lambda)
*)
d641 1
a641 3
(*
    val _ = print"Got top_tags_list"
*)
a646 3
(*
    val _ = print"Got top_closure"
*)
a649 3
    val _ = print"New lambda exp"
    val _ = LambdaPrint.print_lambda new_lambda_exp

d868 2
a869 2
	      (print("Assoc fail on " ^ Pervasives.print_pervasive prim);
	       raise Lists.Assoc)
a1446 6
(*
	      val _ =
		print(if is_same_set then
			"Is same recursive function set"
		      else "Isn't same recursive function set")
*)
a1621 8
(*
	    val _ = case code of
	      ([], [], _, []) => print"No first, no blocks, no last"
	    | (_, [], _, []) => print"First, no blocks, no last"
	    | ([], _, _, []) => print"No first, blocks, no last"
	    | ([], [], _, _) => print"No first, no blocks, last"
	    | _ => print"Something else"
*)
a1730 1
	    val _ = print"Empty switch list"
a1758 3
(*
	  val _ = print("make_cgt gives f length " ^ Integer.makestring(length f) ^ " plus b length " ^ Integer.makestring(length b) ^ " l length " ^ Integer.makestring(length l))
*)
a1956 3
(*
      val _ = print("result_code gives f length " ^ Integer.makestring(length f) ^ " plus b length " ^ Integer.makestring(length b) ^ " l length " ^ Integer.makestring(length l))
*)
a1977 3
(*
	  val _ = print"Generating value element"
*)
a2381 1
    val _ = print"Doing final tuple up"
@


1.52
log
@Modified local and external reference production.
@
text
@d4 3
d231 1
a231 1
    LambdaSub.LambdaTypes = Environ.LambdaTypes = Primitives.LambdaTypes =
@


1.51
log
@Sorted out returned value from top level procedure
Fixed bug whereby values were being lost in combine
@
text
@d4 4
d1684 2
a1685 1
	    let val new_reg_op = MirTypes.new_gc_register()
d1687 3
a1689 1
	      [MirTypes.BINARY(MirTypes.SUB, MirTypes.GC_REG new_reg_op,
d1779 4
a1782 1
	  val (low, high) = bounds(0, 0, map #1 val_le_tags_list)
d2419 1
d2422 1
a2422 1
	     Mir_Env.empty_closure_env, 0, 0, 1, [hd clos_range])
d2442 3
a2444 1
    val new_tag = hd clos_range
d2453 1
a2453 1
    MirTypes.CODE(MirTypes.REFS(clos_range, ext_strings),
@


1.50
log
@Modified ALLOC stuff again, hopefully code generation possible this time
@
text
@d4 3
d393 1
a393 1
			    MirTypes.GP_IMM_INT ~1)])
d402 1
a402 1
      [MirTypes.STOREFPOP(MirTypes.FST, fp_op, reg, MirTypes.GP_IMM_INT ~1)]
d423 1
a423 1
      Lists.number_from(reg_list, ~1, 4, MirTypes.GP_IMM_INT)
d512 1
a512 1
			      MirTypes.GP_IMM_INT(~1 + 4*offset))]),
d531 1
a531 1
			  MirTypes.GP_IMM_INT ~1),
d534 1
a534 1
			  MirTypes.GP_IMM_INT 3)])
d538 7
a544 2
  fun combine(((first, blocks, tag, last), set, values),
	      ((first', blocks', tag', last'), set', values')) =
d555 4
a558 1
	 tag', last'))), set @@ set, values @@ values')
d739 1
a739 1
			      reg_operand, MirTypes.GP_IMM_INT(start + 4*i))]
d745 1
a745 1
				  MirTypes.GP_IMM_INT(start + 4*i))]
d756 1
a756 1
			      MirTypes.GP_IMM_INT(start + 4*from)),
d759 1
a759 1
			       MirTypes.GP_IMM_INT(start + 4*to))] @@
d772 1
a772 1
			     MirTypes.GP_IMM_INT(start + 4*(closure_size-1)))]
d825 1
a825 1
			     MirTypes.GP_IMM_INT ~1),
d861 1
a861 1
		  MirTypes.GP_IMM_INT(~1 + 4*(find_ext_string chars)))],
d967 1
a967 1
			  reg_from_gp reg1, MirTypes.GP_IMM_INT ~1),
d969 1
a969 1
			  reg_from_gp reg2, MirTypes.GP_IMM_INT ~1)])
d1001 1
a1001 1
				       MirTypes.GP_IMM_INT ~1),
d1092 13
a1104 2
			      MirTypes.GP_IMM_INT ~1),
	      MirTypes.COMMENT"Acquire size not yet decided"])
d1123 1
a1123 1
				   MirTypes.GP_IMM_INT ~3)],
d1140 1
a1140 1
				       MirTypes.GP_IMM_INT ~3),
d1158 1
a1158 1
					MirTypes.GP_IMM_INT ~3),
d1218 1
a1218 1
					  MirTypes.GP_IMM_INT ~1),
d1283 1
a1283 1
				    MirTypes.GP_IMM_INT ~1)], exn_blocks,
d1302 1
a1302 1
				 MirTypes.GP_IMM_INT ~1)],
d1498 2
a1499 1
	val the_code = Lists.reducel combine
d1504 2
a1505 1
	    let val (reg, code) = tuple_up(regs, call_c_code(env, closure))
d1532 1
a1532 1
		  MirTypes.GP_IMM_INT offset),
d1631 1
a1631 1
			   MirTypes.GP_IMM_INT 3),
d1851 1
a1851 1
		MirTypes.GP_IMM_INT(4*(static_offset + i +
d1908 1
a1908 1
		MirTypes.GP_IMM_INT(4*(static_offset + i +
d1915 1
a1915 1
				 MirTypes.GP_IMM_INT 0),
d1918 1
a1918 1
				 MirTypes.GP_IMM_INT 4),
d2006 3
d2013 1
a2013 1
		MirTypes.GP_IMM_INT(4*(static_offset + funs_in_closure) - 1))],
d2047 1
a2047 1
	        MirTypes.GP_IMM_INT(4*(funs_in_closure + static_offset +
d2050 1
a2050 1
				 MirTypes.GP_IMM_INT ~1)],
d2176 1
a2176 1
	      MirTypes.GP_IMM_INT(4*(funs_in_closure + static_offset +
d2179 1
a2179 1
			      MirTypes.GP_IMM_INT(4*x-1))])
d2278 1
a2278 1
			  MirTypes.GP_IMM_INT 0),
d2304 1
a2304 1
			   MirTypes.GP_IMM_INT 0),
d2306 1
a2306 1
			   MirTypes.GP_IMM_INT 4),
d2308 1
a2308 1
			   MirTypes.GP_IMM_INT 8),
d2310 1
a2310 1
			   MirTypes.GP_IMM_INT 12),
d2312 1
a2312 1
			   handler_frame, MirTypes.GP_IMM_INT 16)]
d2333 1
a2333 1
			  MirTypes.GC_REG handler, MirTypes.GP_IMM_INT 12),
d2348 1
a2348 1
			  MirTypes.GC_REG handler, MirTypes.GP_IMM_INT 4),
d2351 1
a2351 1
			   MirTypes.GC_REG handler, MirTypes.GP_IMM_INT 8),
d2354 1
a2354 1
			   MirTypes.GC_REG handler, MirTypes.GP_IMM_INT 12),
d2357 1
a2357 1
			   MirTypes.GC_REG handler, MirTypes.GP_IMM_INT 16),
a2413 5
(*
      call_c_code(Mir_Env.add_lambda_env((call_c_lambda, !call_c_reg),
					 Mir_Env.empty_lambda_env),
		  Mir_Env.empty_closure_env)
*)
d2417 1
a2417 1
	val (reg, new_code) = tuple_up_in_reg(sub_regs, caller_arg,
d2420 1
a2420 1
	(MirTypes.GP_GC_REG caller_arg, last @@ new_code)
d2426 2
@


1.49
log
@Added determination of implicit call_c requirements
@
text
@d4 3
d394 8
a401 5
  fun save_real_to_reg(fp_op, reg, offset) =
    [MirTypes.ALLOCATE(MirTypes.ALLOC_REAL, reg, 0, silly_val),
      MirTypes.STOREFPOP(MirTypes.FST, fp_op, reg,
			 MirTypes.GP_IMM_INT ~1)]
  (* Store as to a pointer (tag 1) *)
d411 1
a411 1
  fun tuple_up_in_reg(reg_list, new_reg, offset) =
d415 1
d417 2
a418 1
      MirTypes.ALLOCATE(MirTypes.ALLOC, MirTypes.GC_REG new_reg, len, silly_val)
d422 2
a423 2
    (new_reg, alloc_op :: Lists.reducel op @@
      ([],
d448 1
a448 1
		 val (new_reg', code) = save_real(fp_op, offset)
d609 2
d612 12
a623 9
    fun lvar_offset(lvar, closure) =
      if Mir_Env.is_in_closure(lvar, closure) then
	Mir_Env.lookup_in_closure(lvar, closure)
      else Crash.impossible"lvar_offset not found"

    fun call_c_offset closure =
      lvar_offset(Map.lookup(Pervasives.CALL_C,
			     prim_to_lambda), closure)

d690 1
a690 2
    fun make_closure(tags, free, statics, offset, env, closure,
		     call_c_offset) =
d730 1
a730 1
	      let val (reg', code) = send_to_reg(ONE reg, call_c_offset)
d763 1
d766 2
a767 1
        MirTypes.ALLOCATE(MirTypes.ALLOC, reg_operand, closure_size, silly_val) ::
d779 1
a779 1
			   is_same_set, pos, tag_list, call_c_offset) =
d795 1
a795 1
      val extra_code = send_to_given_reg(regs', caller_arg, call_c_offset)
d1069 1
a1069 1
		 call_c_offset closure)
d1089 1
a1089 1
	    val (new_reg, code) = send_to_reg(regs, call_c_offset closure)
d1092 1
d1096 4
a1099 2
		((code @@ [MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, 0, silly_val),
		  MirTypes.COMMENT"Allocate a ref cell",
d1109 1
a1109 1
						  call_c_offset closure)
d1247 3
a1249 1
	      val (new_reg, code) = send_to_reg(regs, call_c_offset closure)
d1258 4
a1261 3
		  MirTypes.ALLOCATE(MirTypes.ALLOC_STRING, res2, 1, silly_val),
		  MirTypes.STOREOP(MirTypes.STB, reg_from_gp new_reg, res2,
				   MirTypes.GP_IMM_INT ~1)], exn_blocks,
d1406 1
a1406 1
	let val (gc_reg, more_code) = tuple_up(many, call_c_offset closure)
d1411 4
d1459 1
a1459 1
	       call_c_offset closure)
a1469 13
(*
	fun iterate_over_struct([], reg_code_list) =
	  rev reg_code_list
	| iterate_over_struct((le, pos) :: rest, reg_code_list) =
	  let
	    val (reg, code) =
	      cg_sub(le, env, closure,
		     static_offset + pos, start_at + pos, funs_in_closure,
		     fn_tag_list)
	  in
	    iterate_over_struct(rest, (reg, code) :: reg_code_list)
	  end
*)
a1475 3
(*
	  iterate_over_struct((Lists.zip(le_list, positions)), [])
*)
d1481 1
a1481 1
	    let val (reg, code) = tuple_up(regs, call_c_offset closure)
d1559 1
a1559 1
				 call_c_offset closure)
d1561 2
a1562 1
	      (#2 (tuple_up_in_reg(many, end_reg, call_c_offset closure)))) @@
d1600 1
a1600 1
	    let val (gc_reg, code) = tuple_up(many, call_c_offset closure)
d1674 1
a1674 1
				 call_c_offset closure)
d1676 2
a1677 1
		#2 (tuple_up_in_reg(many, end_reg, call_c_offset closure))) @@
d1710 1
a1710 1
			       call_c_offset closure)
d1712 1
a1712 1
	      #2 (tuple_up_in_reg(many, end_reg, call_c_offset closure))) @@
d1749 1
a1749 1
	  val (the_reg, extra) = send_to_reg(regs, call_c_offset closure)
d1781 1
a1781 1
	    val (the_reg, extra) = send_to_reg(regs, call_c_offset closure)
d1875 1
a1875 1
		       call_c_offset closure)
d1880 1
d1888 1
a1888 1
				  2, silly_val),
a1995 1
      val _ = print"Doing FN"
d2014 1
a2014 1
			  call_c_offset closure) of
d2036 2
a2037 1
	  send_to_given_reg(fn_reg, result_temporary, call_c_offset closure) @@
a2074 1
      val _ = print"Done FN"
a2081 1
      val _ = print"Doing LETREC"
d2118 1
a2118 1
		     call_c_offset closure)
d2173 2
a2174 1
	     send_to_given_reg(x, result_temporary, call_c_offset closure) @@
a2234 1
      val _ = print"Done LETREC"
d2249 1
a2249 1
	send_to_given_reg(reg, caller_arg, call_c_offset closure) @@
d2287 1
d2289 2
a2290 1
	[MirTypes.ALLOCATE(MirTypes.ALLOC_STACK, handler_frame, frame_size, silly_val),
d2302 1
a2302 1
	send_to_given_reg(main_reg, result_reg, call_c_offset closure) @@
d2353 2
a2354 1
	send_to_given_reg(exn_result_reg, result_reg, call_c_offset closure) @@
d2386 6
d2395 2
a2396 6
	val offset =
	  case Lists.assoc(Map.lookup(Pervasives.CALL_C, prim_to_lambda),
			   bindings) of
	    LambdaTypes.SELECT({index = i, ...}, _) => i
	  | _ => Crash.impossible"Binding is not select"
	val (reg, new_code) = tuple_up_in_reg(sub_regs, caller_arg, offset)
a2406 3
(*
 (first, [MirTypes.BLOCK(tag_val, last)])
*)
@


1.47
log
@Fixed up pointer offsets. Still to add CALL_C stuff for GC
@
text
@d4 7
d233 2
d270 7
d391 2
a392 2
  fun save_real_to_reg(fp_op, reg) =
    [MirTypes.ALLOCATE(MirTypes.ALLOC_REAL, reg, 0),
d397 1
a397 1
  fun save_real fp_op =
d402 1
a402 1
      (new_reg, save_real_to_reg(fp_op, new_r))
d405 1
a405 1
  fun tuple_up_in_reg(reg_list, new_reg) =
d410 1
a410 1
      MirTypes.ALLOCATE(MirTypes.ALLOC, MirTypes.GC_REG new_reg, len)
d440 1
a440 1
		 val (new_reg', code) = save_real fp_op
d451 2
a452 2
  fun tuple_up reg_list =
    (tuple_up_in_reg(reg_list, MirTypes.new_gc_register()))
d541 1
a541 1
  fun send_to_given_reg(cg_res, gc_reg) =
d556 3
a558 2
	| REAL fp_op => save_real_to_reg(fp_op, MirTypes.GC_REG gc_reg))
    | LIST many => #2 (tuple_up_in_reg(many, gc_reg))
d560 1
a560 1
  fun send_to_reg(ONE reg) =
d579 1
a579 1
	   val (reg, code) = save_real fp_op
d583 2
a584 2
  | send_to_reg(LIST many) =
    let val (gc_reg, code) = tuple_up many
d601 10
d677 2
a678 1
    fun make_closure(tags, free, statics, offset, env, closure) =
d718 1
a718 1
	      let val (reg', code) = send_to_reg(ONE reg)
d753 1
a753 1
        MirTypes.ALLOCATE(MirTypes.ALLOC, reg_operand, closure_size) ::
d765 1
a765 1
			   is_same_set, pos, tag_list) =
d781 1
a781 1
      val extra_code = send_to_given_reg(regs', caller_arg)
a865 1

d1054 2
a1055 1
	  do_app(regs', the_code', regs, the_code, false, 0, fn_tag_list)
d1075 1
a1075 1
	    val (new_reg, code) = send_to_reg regs
d1081 1
a1081 1
		((code @@ [MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, 0),
d1091 2
a1092 1
		val (new_reg, code) = send_to_reg(ONE arg)
d1230 1
a1230 1
	      val (new_reg, code) = send_to_reg regs
d1239 1
a1239 1
		  MirTypes.ALLOCATE(MirTypes.ALLOC_STRING, res2, 1),
d1386 1
a1386 1
	let val (gc_reg, more_code) = tuple_up many
d1434 2
a1435 1
	       length fn_tag_list + pos - funs_in_closure, fn_tag_list)
d1473 1
a1473 1
	    let val (reg, code) = tuple_up regs
d1549 3
a1551 1
	    | ONE(REAL reg) => save_real_to_reg(reg, MirTypes.GC_REG end_reg)
d1553 1
a1553 1
	      (#2 (tuple_up_in_reg(many, end_reg)))) @@
d1591 1
a1591 1
	    let val (gc_reg, code) = tuple_up many
d1664 2
a1665 1
		save_real_to_reg(fp_op, MirTypes.GC_REG end_reg)
d1667 1
a1667 1
		#2 (tuple_up_in_reg(many, end_reg))) @@
d1697 1
a1697 1
					    MirTypes.GC_REG end_reg, reg)]
d1699 2
a1700 1
			    save_real_to_reg(fp_op, MirTypes.GC_REG end_reg)
d1702 1
a1702 1
	      #2 (tuple_up_in_reg(many, end_reg))) @@
d1739 1
a1739 1
	  val (the_reg, extra) = send_to_reg regs
d1771 1
a1771 1
	    val (the_reg, extra) = send_to_reg regs
d1864 2
a1865 1
		       (([], [], MirTypes.ABSENT, []), [], []), false, 0, [])
d1877 1
a1877 1
				  2),
d1985 1
d1988 10
a1997 9
	Set.union(
		  if needs_prim(Pervasives.STRINGEQ, fcn)
		    then
		      Set.add_member(Map.lookup(Pervasives.STRINGEQ,
						prim_to_lambda), free)
		  else free,
		    Set.list_to_set(
		    map (fn x => Map.lookup(x, prim_to_lambda))
		    (Set.set_to_list(Library.builtin_implicit_set fcn))))
d2003 2
a2004 1
			  static_offset + funs_in_closure, env, closure) of
d2026 1
a2026 1
	  send_to_given_reg(fn_reg, result_temporary) @@
d2064 1
d2072 1
d2086 4
d2091 2
a2092 8
	if lneeds_prim(Pervasives.STRINGEQ, le_list)
	then
	  Set.add_member(Map.lookup(Pervasives.STRINGEQ, prim_to_lambda), free)
	else free
      val free =
	Set.union(free,
	  Set.list_to_set(
	    map
d2094 1
a2094 3
	    (Set.set_to_list(Library.builtin_implicit_set(LambdaTypes.STRUCT
							  le_list)))
			  ))
d2108 2
a2109 1
		     static_offset + funs_in_closure, env, closure)
d2164 1
a2164 1
	     send_to_given_reg(x, result_temporary) @@
d2225 1
d2239 2
a2240 1
	MirTypes.PRESERVE_ALL_REGS :: send_to_given_reg(reg, caller_arg) @@
d2279 1
a2279 1
	[MirTypes.ALLOCATE(MirTypes.ALLOC_STACK, handler_frame, frame_size),
d2290 2
a2291 1
      val main_end = send_to_given_reg(main_reg, result_reg) @@
d2341 2
a2342 1
      val exn_end = send_to_given_reg(exn_result_reg, result_reg) @@
d2373 1
a2374 9
(* Do not remove, this might be necessary!
      ONE(INT reg) => (MirTypes.GP_GC_REG caller_arg, last @@
		  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG caller_arg, reg)])
    | ONE(REAL fp_op) =>
	let
	  val
	in
	end
*)
d2377 6
a2382 1
	val (reg, new_code) = tuple_up_in_reg(sub_regs, caller_arg)
a2395 1
    val refs_tag = MirTypes.new_tag()
d2405 1
a2405 2
    MirTypes.CODE(MirTypes.FN_CALL(new_tag, refs_tag),
		  MirTypes.REFS(refs_tag, clos_range, ext_strings),
d2407 1
a2407 2
		  proc_lists,
		  set_up_proc)
@


1.46
log
@Added use of DEALLOC_STACK where possible. Fixed problem with
use of callee_arg as temporary register.
@
text
@d4 4
d371 1
a371 1
			    MirTypes.GP_IMM_INT 0)])
d378 2
a379 1
			 MirTypes.GP_IMM_INT 0)]
d391 4
a394 2
    val alloc_op = MirTypes.ALLOCATE(MirTypes.ALLOC, MirTypes.GC_REG new_reg,
				     length reg_list)
d396 1
a396 1
      Lists.number_from_by_one(reg_list, 0, MirTypes.GP_IMM_INT)
d485 1
a485 1
			      MirTypes.GP_IMM_INT offset)]),
d504 1
a504 1
			  MirTypes.GP_IMM_INT 0),
d507 1
a507 1
			  MirTypes.GP_IMM_INT 1)])
d679 3
d688 1
a688 1
			      reg_operand, MirTypes.GP_IMM_INT i)]
d693 2
a694 1
				  reg_operand, MirTypes.GP_IMM_INT i)]
d704 2
a705 1
	      MirTypes.GC_REG callee_closure, MirTypes.GP_IMM_INT from),
d707 2
a708 1
			       reg_operand, MirTypes.GP_IMM_INT to)] @@
a713 2
      val closure_size = funs + statics + free_size + 1
      (* Extra location for non-gc-spill area size for gc benefit *)
d721 1
a721 1
			     MirTypes.GP_IMM_INT(closure_size - 1))]
d771 2
a772 1
			     MirTypes.GC_REG caller_closure, MirTypes.GP_IMM_INT 0),
d808 1
a808 1
		  MirTypes.GP_IMM_INT(find_ext_string chars))],
d915 1
a915 1
			  reg_from_gp reg1, MirTypes.GP_IMM_INT 0),
d917 1
a917 1
			  reg_from_gp reg2, MirTypes.GP_IMM_INT 0)])
d949 1
a949 1
				       MirTypes.GP_IMM_INT 0),
d1056 1
a1056 1
				   MirTypes.GP_IMM_INT 0)],
d1072 1
a1072 1
				       MirTypes.GP_IMM_INT 0),
d1088 3
a1090 2
		    (([MirTypes.STOREOP(MirTypes.LDREF, res1, MirTypes.GC_REG reg,
				       MirTypes.GP_IMM_INT 0),
d1150 1
a1150 1
					  MirTypes.GP_IMM_INT 0),
d1210 1
a1210 1
		  MirTypes.ALLOCATE(MirTypes.ALLOC_STRING,res2, 1),
d1212 1
a1212 1
				   MirTypes.GP_IMM_INT 0)], exn_blocks,
d1231 1
a1231 1
				 MirTypes.GP_IMM_INT 0)],
d1318 1
d1460 1
a1460 2
      val offset =
	(index * 4) - (if size = 2 then 1 else 3)
d1783 2
a1784 1
		MirTypes.GP_IMM_INT(static_offset + i + funs_in_closure)),
d1836 4
a1839 2
	      [MirTypes.STOREOP(MirTypes.LD, scon_reg, MirTypes.GC_REG callee_closure,
		MirTypes.GP_IMM_INT(static_offset + i + funs_in_closure)),
d1848 1
a1848 1
				 MirTypes.GP_IMM_INT 1),
d1940 1
a1940 1
		MirTypes.GP_IMM_INT(static_offset + funs_in_closure))],
d1970 4
a1973 3
	        MirTypes.STOREOP(MirTypes.LD, gc_reg, MirTypes.GC_REG callee_closure,
	        MirTypes.GP_IMM_INT(funs_in_closure + static_offset +
				    gc_objects_within)),
d1975 1
a1975 1
				 MirTypes.GP_IMM_INT 0)],
d2101 4
a2104 3
	    [MirTypes.STOREOP(MirTypes.LD, gc_reg, MirTypes.GC_REG callee_closure,
	      MirTypes.GP_IMM_INT(funs_in_closure + static_offset +
				  gc_objects_within + x)),
d2106 1
a2106 1
			      MirTypes.GP_IMM_INT x)])
d2231 1
a2231 1
			   MirTypes.GP_IMM_INT 1),
d2233 1
a2233 1
			   MirTypes.GP_IMM_INT 2),
d2235 1
a2235 1
			   MirTypes.GP_IMM_INT 3),
d2237 1
a2237 1
			   handler_frame, MirTypes.GP_IMM_INT 4)]
d2255 1
a2255 1
			  MirTypes.GC_REG handler, MirTypes.GP_IMM_INT 3),
d2270 1
a2270 1
			  MirTypes.GC_REG handler, MirTypes.GP_IMM_INT 1),
d2273 1
a2273 1
			   MirTypes.GC_REG handler, MirTypes.GP_IMM_INT 2),
d2276 1
a2276 1
			   MirTypes.GC_REG handler, MirTypes.GP_IMM_INT 3),
d2279 1
a2279 1
			   MirTypes.GC_REG handler, MirTypes.GP_IMM_INT 4),
@


1.45
log
@Slight alterations to cope with new MirTypes.
@
text
@d4 3
d1824 2
a1825 1
	        MirTypes.ALLOCATE(MirTypes.ALLOC_STACK, MirTypes.GC_REG caller_arg,
d1835 3
a1837 1
	      [MirTypes.TEST(MirTypes.BEQ, tag, MirTypes.GP_GC_REG caller_arg,
d1968 12
a1979 5
	send_to_given_reg(fn_reg,
			  if MirRegisters.automatic_callee then
			    callee_arg
			  else
			    caller_arg)
d2102 1
d2104 18
a2121 4
	if MirRegisters.automatic_callee then
	  map (fn (x, _) => send_to_given_reg(x, callee_arg)) fn_reg_code_list
	else
	  map (fn (x, _) => send_to_given_reg(x, caller_arg)) fn_reg_code_list
d2208 1
d2220 1
d2222 1
a2222 2
	[MirTypes.ALLOCATE(MirTypes.ALLOC_STACK, handler_frame,
			   length frame_setup),
d2235 2
a2236 1
	  MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG handler,
d2238 2
a2239 2
	  MirTypes.COMMENT"Restore previous handler",
	  MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG end_tag)]
@


1.44
log
@Added ENTER and RTS to final block, making it into a bona fide
proceedure.
@
text
@d4 4
d1970 1
a1970 1
	   [MirTypes.ENTER {leaf = not makes_calls}]
d1972 1
a1972 1
	   [MirTypes.ENTER {leaf = not makes_calls},
d1985 8
a1992 1
      val the_fn = [MirTypes.PROC(tag, MirTypes.BLOCK(tag, first) :: blocks @@
d2096 1
a2096 1
	    [MirTypes.ENTER {leaf = false}]
d2098 1
a2098 1
	    [MirTypes.ENTER {leaf = false},
d2120 7
a2126 1
	       MirTypes.PROC(tag, MirTypes.BLOCK(tag, first) :: blocks @@
d2303 1
a2303 1
      (MirTypes.ENTER {leaf = true}) ::
d2312 7
d2324 1
a2324 1
		  MirTypes.BLOCK(new_tag, first))
@


1.43
log
@Changed register use to implement register windows on machines that
have them. Removed RESTORE_REGS and PRESERVE_REGS and replaced with
parameters on the ENTER instruction. Changed raise from an ordinary
BSR to a parameterized RAISE instruction.
@
text
@d4 6
d2284 6
a2289 5
    val last = last @@ [MirTypes.END]
    val first = case (tag_opt, blocks) of
      (MirTypes.ABSENT, []) => first @@ last
    | _ =>
	Crash.impossible"Multiple blocks in top level"
@


1.42
log
@Mended SELECT
@
text
@d4 3
d209 1
a209 1
  val fn_arg = MirRegisters.caller_arg
d212 4
a215 1
  val cl_arg = MirRegisters.caller_closure
d218 2
a219 3
  val cl_arg' = MirRegisters.callee_closure
  (* The closure pointer within all functions *)
  (* Note that this is copied during function prologue from cl_arg *)
d464 1
a464 1
			      MirTypes.GC_REG cl_arg',
d649 1
a649 1
       (cl_arg) is some distance before the first free variable, as required
d680 1
a680 1
	      MirTypes.GC_REG cl_arg', MirTypes.GP_IMM_INT from),
d729 1
a729 1
      val extra_code = send_to_given_reg(regs', fn_arg)
d734 2
a735 2
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG cl_arg,
			  MirTypes.GP_GC_REG cl_arg'),
d741 1
a741 1
			   MirTypes.GP_GC_REG fn_arg),
d744 1
a744 1
	  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG cl_arg, fn_reg),
d747 1
a747 1
			     MirTypes.GC_REG cl_arg, MirTypes.GP_IMM_INT 0),
d753 1
a753 1
			   MirTypes.GP_GC_REG fn_arg),
d765 1
a765 1
       closure is the free lambda to offsets from cl_arg' environment
d770 1
a770 1
       funs_in_closure is the number of functions following cl_arg'
d782 1
a782 1
		  MirTypes.GC_REG cl_arg',
d1756 1
a1756 1
		MirTypes.GC_REG cl_arg',
d1802 1
a1802 1
		do_app(regs', the_code', ONE(INT(MirTypes.GP_GC_REG fn_arg)),
d1809 1
a1809 1
	      [MirTypes.STOREOP(MirTypes.LD, scon_reg, MirTypes.GC_REG cl_arg',
d1811 1
a1811 1
	        MirTypes.ALLOCATE(MirTypes.ALLOC_STACK, MirTypes.GC_REG fn_arg,
d1814 1
a1814 1
				 MirTypes.GC_REG fn_arg,
d1817 1
a1817 1
				 MirTypes.GC_REG fn_arg,
d1821 1
a1821 1
	      [MirTypes.TEST(MirTypes.BEQ, tag, MirTypes.GP_GC_REG fn_arg,
d1907 1
a1907 1
	      MirTypes.GC_REG cl_arg',
d1938 1
a1938 1
	        MirTypes.STOREOP(MirTypes.LD, gc_reg, MirTypes.GC_REG cl_arg',
a1944 1
      val arg_reg = MirRegisters.callee_arg
d1947 1
a1947 1
	       Mir_Env.add_lambda_env((lvar, MirTypes.GC arg_reg),
d1951 6
a1956 1
      val final_code = send_to_given_reg(fn_reg, fn_arg)
d1960 1
a1960 2
	   [MirTypes.ENTER, MirTypes.PRESERVE_REGS([], []),
	    MirTypes.COMMENT(if makes_calls then "Non-leaf" else "Leaf")]
d1962 3
a1964 4
	   [MirTypes.ENTER, MirTypes.PRESERVE_REGS([], []),
	    MirTypes.COMMENT(if makes_calls then "Non-leaf" else "Leaf"),
	    MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG cl_arg',
			   MirTypes.GP_GC_REG cl_arg),
d1966 2
a1967 2
	    MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG arg_reg,
			   MirTypes.GP_GC_REG fn_arg)],
d1971 1
a1971 1
	  [MirTypes.RESTORE_REGS([], []), MirTypes.RTS],
d2054 1
a2054 1
	    [MirTypes.STOREOP(MirTypes.LD, gc_reg, MirTypes.GC_REG cl_arg',
a2059 1
      val arg_reg = MirTypes.new_gc_register()
d2063 1
a2063 1
	  cg_sub(lexp, Mir_Env.add_lambda_env((lvar, MirTypes.GC arg_reg),
d2073 4
a2076 1
	map (fn (x, _) => send_to_given_reg(x, fn_arg)) fn_reg_code_list
d2078 9
a2086 7
	(([MirTypes.ENTER, MirTypes.PRESERVE_REGS([], []),
	  MirTypes.COMMENT"Non-leaf",
	  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG cl_arg',
			 MirTypes.GP_GC_REG cl_arg),
	  MirTypes.COMMENT"Copy closure pointer to local copy (callee save)",
	  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG arg_reg,
			 MirTypes.GP_GC_REG fn_arg)],
d2091 1
a2091 1
	      [MirTypes.RESTORE_REGS([], []), MirTypes.RTS],
d2132 1
a2132 1
	MirTypes.PRESERVE_ALL_REGS :: send_to_given_reg(reg, fn_arg) @@
d2135 2
a2136 3
	  MirTypes.BRANCH_AND_LINK(MirTypes.BSR, MirTypes.REG temp_reg),
	  MirTypes.COMMENT"Call the exception handler, so we can backtrace",
	  MirTypes.RAISE]
d2165 3
a2167 1
			   MirTypes.GP_IMM_INT 3)]
d2207 3
d2211 1
a2211 1
			 MirTypes.GP_GC_REG fn_arg),
d2221 3
a2223 3
	  [MirTypes.RESTORE_REGS([], []),
	    MirTypes.COMMENT"Restore up one level",
	    MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG restore_tag2)])
d2263 2
a2264 2
      ONE(INT reg) => (MirTypes.GP_GC_REG fn_arg, last @@
		  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG fn_arg, reg)])
d2273 1
a2273 1
	val (reg, new_code) = tuple_up_in_reg(sub_regs, fn_arg)
d2275 1
a2275 1
	(MirTypes.GP_GC_REG fn_arg, last @@ new_code)
@


1.41
log
@Made changes to generate code for selections from pairs properly
@
text
@d4 3
d1446 1
a1446 1
	  (ONE(Lists.nth(field, many)), the_code)
@


1.40
log
@Modified to generate a different procedure entry routine for those
machines with register windows.
@
text
@d4 4
d1419 2
a1420 2
    | cg_sub(LambdaTypes.SELECT(field, lexp), env, closure, static_offset,
	   start_at, funs_in_closure, fn_tag_list) =
d1425 2
a1426 1
      val field = LambdaTypes.fromField field
d1436 1
a1436 1
		  MirTypes.GP_IMM_INT field),
@


1.39
log
@Replaced raise Lambdatypes.impossible with Crash.impossible
@
text
@d4 3
d199 1
a199 1
  val fn_arg = MirRegisters.fn_arg
d202 1
a202 1
  val cl_arg = MirRegisters.cl_arg
d205 1
a205 1
  val cl_arg' = MirRegisters.cl_arg'
d1932 1
a1932 1
      val arg_reg = MirTypes.new_gc_register()
d1942 11
a1952 7
	([MirTypes.ENTER, MirTypes.PRESERVE_REGS([], []),
	  MirTypes.COMMENT(if makes_calls then "Non-leaf" else "Leaf"),
	  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG cl_arg',
			 MirTypes.GP_GC_REG cl_arg),
	  MirTypes.COMMENT"Copy closure pointer to local copy (callee save)",
	  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG arg_reg,
			 MirTypes.GP_GC_REG fn_arg)],
@


1.38
log
@Changed handler code to use global register when traversing the stack.
@
text
@d4 3
d292 1
a292 1
		    raise(LambdaTypes.impossible"EXP_TAG contains static gc")
d313 1
a313 1
      raise(LambdaTypes.impossible"Non-function in handler")
d327 1
a327 1
  | _ => raise(LambdaTypes.impossible"reg_from_gp(IMM)")
d341 1
a341 1
  | get_real _ = raise(LambdaTypes.impossible"get_real bad value")
d396 1
a396 1
	     | _ => raise(LambdaTypes.impossible"Tuple_up untagged value"))
d422 1
a422 1
    raise(LambdaTypes.impossible"Bad value to get_any_register")
d441 1
a441 1
	   | _ => raise(LambdaTypes.impossible"lookup_lambda returns const")),
d474 1
a474 1
  | destruct_2_tuple _ = raise(LambdaTypes.impossible"destruct_2_tuple")
d481 1
a481 1
      | _ => raise(LambdaTypes.impossible"non-empty last with no tag"))
d485 1
a485 1
	| _ => raise(LambdaTypes.impossible"non-empty last' with no tag"))
d499 1
a499 1
	  raise(LambdaTypes.impossible"GP_IMM_ANY")
d523 1
a523 1
	 raise(LambdaTypes.impossible"GP_IMM_ANY")
d608 1
a608 1
	fun find_sub(chars, []) = raise(LambdaTypes.impossible"string missing")
d710 1
a710 1
	| _ => raise(LambdaTypes.impossible"STRUCT or NON_GC as FN")
d771 1
a771 1
	| _ => raise(LambdaTypes.impossible"Bad parameter to load_string"))
d793 1
a793 1
	    | _ => raise(LambdaTypes.impossible"Too much raise code")
d808 1
a808 1
	    | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 0)")
d819 1
a819 1
	  | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 1)")
d831 1
a831 1
	    | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 0)")
d839 1
a839 1
	  | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 1)")
d856 1
a856 1
	  | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 1)")
d879 1
a879 2
		      raise(LambdaTypes.impossible
			    "destruct_2_tuple fails to give INTs")
d888 1
a888 1
	    | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 0)")
d896 1
a896 1
	  | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 1)")
d913 1
a913 1
		| _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 1)")),
d927 1
a927 1
	    | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 0)")
d964 1
a964 1
	    | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 0)")
d994 1
a994 1
	  | _ => raise(LambdaTypes.impossible"Bad string pointer")
d1038 1
a1038 1
	  | _ => raise(LambdaTypes.impossible"BECOMES of bad parms"))
d1053 1
a1053 1
          | _ => raise(LambdaTypes.impossible"DEREF of non-gc"))
d1055 1
a1055 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1057 1
a1057 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1059 1
a1059 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1061 1
a1061 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1063 1
a1063 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1065 1
a1065 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1067 1
a1067 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1069 1
a1069 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1071 1
a1071 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1073 1
a1073 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1075 1
a1075 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1077 1
a1077 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1079 1
a1079 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1081 1
a1081 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1083 1
a1083 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1085 1
a1085 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1087 1
a1087 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1089 1
a1089 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1093 1
a1093 1
	  raise(LambdaTypes.impossible"Primitive NOT")
d1095 1
a1095 1
	  raise(LambdaTypes.impossible"Unresolved overloaded primitive")
d1114 1
a1114 1
		| _ => raise(LambdaTypes.impossible"FLOOR bad value")),
d1134 1
a1134 1
	       | _ => raise(LambdaTypes.impossible"convert of non-gc")),
d1174 1
a1174 1
	  | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 1)")
d1199 1
a1199 1
	  raise(LambdaTypes.impossible"Unresolved overloaded primitive")
d1201 1
a1201 1
	  raise(LambdaTypes.impossible"Unresolved overloaded primitive")
d1203 1
a1203 1
	  raise(LambdaTypes.impossible"Unresolved overloaded primitive")
d1208 1
a1208 1
	  raise(LambdaTypes.impossible"Unresolved overloaded primitive")
d1210 1
a1210 1
	  raise(LambdaTypes.impossible"Unresolved overloaded primitive")
d1212 1
a1212 1
	  raise(LambdaTypes.impossible"Unresolved overloaded primitive")
d1214 1
a1214 1
	  raise(LambdaTypes.impossible"Unresolved overloaded primitive")
d1216 1
a1216 1
	  raise(LambdaTypes.impossible"Primitive composition")
d1218 1
a1218 1
	  raise(LambdaTypes.impossible"Unresolved overloaded primitive")
d1221 1
a1221 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1223 1
a1223 1
	  raise(LambdaTypes.impossible"APP of non-function")
d1274 1
a1274 1
	  | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 1)")
d1278 1
a1278 1
	  raise (LambdaTypes.impossible"Impossible load_string")
d1311 1
a1311 1
	| _ => raise(LambdaTypes.impossible"Untagged value to APP(FN)"))
d1433 1
a1433 1
      | ONE _ => raise(LambdaTypes.impossible"SELECT(ONE(bad value))")
d1515 1
a1515 1
	    raise(LambdaTypes.impossible"Vcc default for non-structured value")
d1549 1
a1549 1
	raise(LambdaTypes.impossible"make_cgt immediate")
d1551 1
a1551 1
	raise(LambdaTypes.impossible"make_cgt immediate")
d1553 1
a1553 1
	raise(LambdaTypes.impossible"make_cgt immediate")
d1660 1
a1660 1
	    | _ => raise(LambdaTypes.impossible"Mixed tag type in switch"))
d1689 1
a1689 1
	      | _ => raise(LambdaTypes.impossible"Mixed tag type in switch"))
d1723 1
a1723 1
	      | _ => raise(LambdaTypes.impossible"Mixed tag type in switch"))
d1727 1
a1727 1
	    | _ => raise(LambdaTypes.impossible"struct gives single REAL")
d1751 1
a1751 1
		| _ => raise(LambdaTypes.impossible"non-REAL in REAL switch")
d1765 1
a1765 1
	      | _ => raise(LambdaTypes.impossible"Mixed tag type in switch"))
d1769 1
a1769 1
	    | _ => raise(LambdaTypes.impossible"struct gives single STRING")
d1791 1
a1791 1
	      | _ => raise(LambdaTypes.impossible"Bad result for STRINGEQ")
d1816 1
a1816 1
		   raise(LambdaTypes.impossible"non-STRING in STRING switch"))
d1831 1
a1831 1
	    | _ => raise(LambdaTypes.impossible"Mixed tag type in switch"))
d1835 1
a1835 1
	  | _ => raise(LambdaTypes.impossible"Bad reg for exception")
d1848 1
a1848 1
		raise(LambdaTypes.impossible"Bad result from cg(exception)")
d1928 1
a1928 1
	| _ => raise(LambdaTypes.impossible"Single FN with multiple tags")
d1970 1
a1970 1
	| _ => raise(LambdaTypes.impossible"non-FN in LETREC"))
d2046 1
a2046 1
	  | _ => raise(LambdaTypes.impossible"non-FN in LETREC"))
d2165 1
a2165 1
      | _ => raise(LambdaTypes.impossible"Handler is not a function")
d2226 1
a2226 2
      raise(LambdaTypes.impossible
	    "cg_sub(BUILTIN) (should have been translated)")
d2247 1
a2247 1
    | _ => raise(LambdaTypes.impossible"Non-struct final result??")
@


1.37
log
@Replaced lambdasub.number_from by lists.number_from_by_one
@
text
@d4 3
d2167 1
a2167 1
      val temp_sp = MirTypes.GC_REG(MirTypes.new_gc_register())
@


1.36
log
@Changed to use new PROC type for bundling up procedures
@
text
@d4 3
d355 1
a355 1
      LambdaSub.number_from(reg_list, 0, MirTypes.GP_IMM_INT)
d552 1
a552 1
      LambdaSub.number_from(list_of_tags(number_of_gc_objects+1), 0,
d598 1
a598 1
      LambdaSub.number_from(ext_strings, next, fn x => x)
d621 1
a621 1
	LambdaSub.number_from(tags, 0, fn x => x)
d624 1
a624 1
	(fn (_, n) => #1 (LambdaSub.number_from(free_list, statics+funs-n,
d637 1
a637 1
	LambdaSub.number_from(cl_code_list, funs + statics, fn x => x)
d1990 1
a1990 1
	map #2 (#1 (LambdaSub.number_from(list_of(funs, 0), 0, fn x => x)))
d2020 1
a2020 1
	  (closure, #1 (LambdaSub.number_from(lv_list, 0 - offset, fn x=> x))))
@


1.35
log
@Sorted out values from procedures
@
text
@d4 3
d1945 1
a1945 1
      val the_fn = MirTypes.BLOCK(tag, first) :: blocks @@
d1948 1
a1948 1
	| MirTypes.PRESENT tag => [MirTypes.BLOCK(tag, last)]
d1951 1
a1951 1
				      procs @@ [the_fn]))
d2065 1
a2065 1
      val fn_val_block_list_list =
d2068 2
a2069 1
	     (vals, procs @@ [MirTypes.BLOCK(tag, first) :: blocks @@
d2072 1
a2072 1
	| MirTypes.PRESENT tag => [MirTypes.BLOCK(tag, last)])]))
d2080 5
a2084 1
	([], map #1 fn_val_block_list_list)
d2086 3
a2088 2
      (regs, ((code @@ first, blocks , tag_opt, last), vals @@ val_list,
        (Lists.reducel op @@ ([], map #2 fn_val_block_list_list)) @@ procs))
d2221 1
a2221 1
    val (regs, ((first, blocks, tag_opt, last), values, block_lists)) =
d2255 1
a2255 1
		  block_lists,
@


1.34
log
@Removed real register options, these are being done elsewhere
@
text
@d4 3
d130 1
d151 1
d203 1
a203 1
  val no_code = ([], [], MirTypes.ABSENT, [])
d464 3
a466 2
  fun combine((first, blocks, tag, last), (first', blocks', tag', last')) =
    case tag of
d476 1
a476 1
	  tag', last'))
d684 3
a686 3
    fun do_app(regs, the_code as (first, blocks, opt, last),
	       regs', the_code' as (first', blocks', opt', last'),
	       is_same_set, pos, tag_list) =
d694 1
a694 1
	    (first, blocks, opt, last)) =>
d696 2
a697 2
	      (MirTypes.COMMENT("Evaluate function to be called") :: first,
	        blocks, opt, last))
d700 2
a701 2
	(MirTypes.COMMENT("Evaluate function argument") :: first',
	  blocks', opt', last')
d731 2
a732 2
		combine(arg_code,
			(extra_code @@ call_code, [], MirTypes.ABSENT, []))))
d754 1
a754 1
	        ([MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
d757 1
a757 1
		  [], MirTypes.ABSENT, []))
d768 1
a768 1
	  val (_, (exn_f, exn_b, exn_o, exn_l)) =
d803 1
a803 1
		(new_code @@
d806 1
a806 1
		  exn_blocks, MirTypes.ABSENT, [])))
d824 1
a824 1
		(new_code @@
d826 1
a826 1
		  [], MirTypes.ABSENT, [])))
d841 1
a841 1
	        ([(MirTypes.TBINARY(opcode, exn_tag, res2,
d843 1
a843 1
		 MirTypes.ABSENT, [])))
d882 1
a882 1
		(new_code @@
d884 1
a884 1
		  [], MirTypes.ABSENT, [])))
d894 1
a894 1
	      ((case regs of
d903 1
a903 1
		  [], MirTypes.ABSENT, [])))
d920 1
a920 1
		      (new_code @@
d927 1
a927 1
		       [], MirTypes.PRESENT tag, [])))
d958 1
a958 1
		      (new_code @@
d965 1
a965 1
		       [], MirTypes.PRESENT tag, [])))
d1002 1
a1002 1
		(code @@ [MirTypes.ALLOCATE(MirTypes.ALLOC_REF, res1, 0),
d1006 1
a1006 1
		  [], MirTypes.ABSENT, [])))
d1018 1
a1018 1
		   (code @@
d1025 1
a1025 1
			 [], MirTypes.ABSENT, [])))
d1037 1
a1037 1
		    ([MirTypes.STOREOP(MirTypes.LDREF, res1, MirTypes.GC_REG reg,
d1040 1
a1040 1
		  [], MirTypes.ABSENT, [])))
d1091 1
a1091 1
		((case regs of
d1104 1
a1104 1
		  [], MirTypes.ABSENT, [])))
d1113 1
a1113 1
	       ((case regs of
d1124 1
a1124 1
		  [], MirTypes.ABSENT, [])))
d1136 1
a1136 1
	  (ONE(INT result), (code, [], MirTypes.ABSENT, []))
d1152 1
a1152 1
		(code @@
d1161 1
a1161 1
		MirTypes.ABSENT, [])))
d1175 1
a1175 1
	    (code @@
d1180 1
a1180 1
	      exn_blocks, MirTypes.ABSENT, []))
d1257 1
a1257 1
	        ([MirTypes.UNARY(MirTypes.MOVE, res2, reg),
d1262 1
a1262 1
		MirTypes.PRESENT tag, [])))
d1316 2
a1317 1
	combine(the_code, (more_code, [], MirTypes.ABSENT, [])), rest_code))
d1339 2
a1340 1
	      ((ONE reg, (code, [], MirTypes.ABSENT, [])), pos, is_same_set)
d1399 1
a1399 1
	 combine(the_code, (new_code, [], MirTypes.ABSENT, [])))
d1415 1
a1415 1
	      ([MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
d1419 1
a1419 1
	      [])))
d1456 1
a1456 1
	LambdaTypes.ABSENT => ([], end_tag)
d1463 1
a1463 1
	    (MirTypes.COMMENT comment :: (case regs of
d1470 1
a1470 1
	      [], MirTypes.ABSENT, []))
d1473 7
a1479 7
	  ((case the_code of
	    (first, blocks, MirTypes.ABSENT, last) =>
	      MirTypes.BLOCK(new_tag, first) :: blocks
	  | (first, blocks, MirTypes.PRESENT tag, last) =>
	      MirTypes.BLOCK(new_tag, first) ::
	        MirTypes.BLOCK(tag, last) :: blocks),
	          new_tag)
d1484 1
a1484 1
      val (blocks1, tag1) =
d1489 1
a1489 1
      val (blocks2, tag2) =
d1546 12
a1557 7
	let fun expand [] = []
	  | expand ([(_, _, tag)]) = [tag]
	  | expand ((i, _, tag) :: (rest as ((j, _, _) :: _))) =
	    tag :: list_of(j-i-1, tag1) @@ expand rest
	in
	  expand val_code_tag_list
	end
d1559 1
a1559 1
	((if low = 0 then
d1572 2
a1573 1
	  (fn (_, (regs, (first, blocks, tag_opt, last)), tag) =>
d1592 1
a1592 1
	  MirTypes.ABSENT, [])
d1602 2
a1603 2
	([MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG def_tag),
	  MirTypes.COMMENT"Default or end"], [], MirTypes.ABSENT, [])
d1605 2
a1606 2
	  (scon, le, (regs, (first, blocks, tag_opt, last)), tag) :: rest,
			 test_code) =
d1626 1
a1626 1
	  combine(result,
d1658 1
a1658 1
	  val main as (f, b, _, l) =
d1738 2
a1739 2
		    MirTypes.BLOCK(Map.lookup(start_at + p + 1, top_closure),
				   [MirTypes.VALUE scon])
d1745 1
a1745 1
	      combine(([], tags_code, MirTypes.ABSENT, []),
d1776 4
a1779 2
		       ([], [], MirTypes.ABSENT, []), false, 0, []) of
		(_, (app_code, [], MirTypes.ABSENT, [])) => app_code
d1802 2
a1803 2
		   MirTypes.BLOCK(Map.lookup(start_at + p + 1, top_closure),
				  [MirTypes.VALUE scon])
d1809 1
a1809 1
	      combine(([], tags_code, MirTypes.ABSENT, []),
d1835 1
a1835 1
		  (code, [], MirTypes.ABSENT, [])) => (reg, code)
a1841 15


(*
	  val tags_code =
	    map
	    (fn (p, (t, _)) =>
	     case t of
	       LambdaTypes.SCON_TAG(scon as Ident.STRING _) =>
		 MirTypes.BLOCK(Map.lookup(start_at + p + 1, top_closure),
				[MirTypes.VALUE scon])
	     | _ =>
		 raise(LambdaTypes.impossible"non-STRING in STRING switch"))
	    (Lists.zip(tag_positions, tag_le_list))
*)

d1845 1
a1845 1
      val result_code as (f, b, _, l) =
d1848 5
a1852 3
	    combine(the_code, (ptr_code @@ main_def, [], MirTypes.ABSENT, [])),
	      main_code),
	        ([], blocks1 @@ blocks2, MirTypes.PRESENT end_tag, []))
d1864 1
a1864 1
      (ONE reg, (code, [], MirTypes.ABSENT, []))
d1879 1
a1879 1
	    ([MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
d1882 4
a1885 2
	      [MirTypes.BLOCK(new_tag, [MirTypes.VALUE scon])],
	      MirTypes.ABSENT, []))
d1940 2
a1941 2
      val (first, blocks, tag_opt, last) =
	combine(entry_code, combine(fn_code, exit_code))
d1947 2
a1948 1
      (ONE(INT(gp_from_reg cl_reg)), (code, the_fn, MirTypes.ABSENT, []))
d2043 1
a2043 1
	([MirTypes.ENTER, MirTypes.PRESERVE_REGS([], []),
d2050 1
a2050 1
	[], MirTypes.ABSENT, [])
d2053 1
a2053 1
	     (final_code @@
d2055 1
a2055 1
	      [], MirTypes.ABSENT, []))
d2062 5
a2066 6
      val fn_block_list =
	Lists.reducel op @@
	([], map
	(fn (tag, (first, blocks, tag_opt, last)) =>
	     MirTypes.BLOCK(tag, first) :: blocks @@
	case tag_opt of
d2068 3
a2070 3
	| MirTypes.PRESENT tag => [MirTypes.BLOCK(tag, last)])
	(Lists.zip(tags, fn_list)))
      val (regs, (first, blocks, tag_opt, last)) =
d2074 3
d2078 2
a2079 1
      (regs, (code @@ first, blocks @@ fn_block_list, tag_opt, last))
d2096 1
a2096 1
	combine(code, (final_code, [], MirTypes.ABSENT, []))
d2144 2
a2145 2
	combine((frame_setup, [], MirTypes.ABSENT, []),
	  combine(main_code, (main_end, [], MirTypes.ABSENT, [])))
d2166 2
a2167 1
      val (exn_result_reg, (exn_f, exn_b, exn_o, exn_l)) =
d2195 2
a2196 1
      val exn_whole = ([], exn_blocks, MirTypes.ABSENT, [])
d2198 6
a2203 4
	combine(
	  combine((frame_setup, [], MirTypes.ABSENT, []),
	    combine(main_code, (main_end, [], MirTypes.PRESENT end_tag, []))),
	      exn_whole)
d2212 1
a2212 1
    val (regs, (first, blocks, tag_opt, last)) =
d2233 7
a2239 3
    val (first, block) = case tag_opt of
      MirTypes.ABSENT => (first @@ last, [])
    | MirTypes.PRESENT tag_val => (first, [MirTypes.BLOCK(tag_val, last)])
a2240 2
    val refs =
      (refs_tag, [MirTypes.LOC_REF clos_range, MirTypes.EXT_REF ext_strings])
a2241 1
    val loc_fn_tag = MirTypes.new_tag()
d2243 5
a2247 4
    MirTypes.CODE(MirTypes.BLOCK(new_tag, first) :: block @@ blocks @@
		  [MirTypes.BLOCK refs,
		    MirTypes.BLOCK(loc_fn_tag,
				   [MirTypes.FN_CALL(new_tag, refs_tag)])])
@


1.33
log
@Reversed the order of the RAISE and BSR instructions when raising an
exception. This makes dead code elimination easier.
@
text
@d4 4
d318 1
a318 1
      val fp_op = MirTypes.FP_REG(MirTypes.new_fp_register(), MirTypes.ABSENT)
d333 1
a333 1
      val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d341 1
a341 2
    val alloc_op = MirTypes.ALLOCATE(MirTypes.ALLOC,
				     MirTypes.GC_REG(new_reg, MirTypes.ABSENT),
d350 1
a350 1
			  MirTypes.GC_REG(new_reg, MirTypes.ABSENT), imm)]
d353 1
a353 1
		 MirTypes.GC_REG(new_reg, MirTypes.ABSENT), imm)]
d356 1
a356 1
		 val new_reg' = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d360 1
a360 1
		   MirTypes.GC_REG(new_reg, MirTypes.ABSENT), imm)]
d364 1
a364 1
		 val new_reg' = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d368 1
a368 1
		   MirTypes.GC_REG(new_reg, MirTypes.ABSENT), imm)]
d376 1
a376 1
				   MirTypes.GC_REG(new_reg, MirTypes.ABSENT),
d401 3
a403 3
  fun get_any_register(INT(MirTypes.GP_GC_REG(reg, _))) = MirTypes.GC reg
  | get_any_register(INT(MirTypes.GP_NON_GC_REG(reg, _))) = MirTypes.NON_GC reg
  | get_any_register(REAL(MirTypes.FP_REG(reg, _))) = MirTypes.FLOAT reg
d420 1
a420 1
	     MirTypes.GC reg => INT(MirTypes.GP_GC_REG(reg, MirTypes.ABSENT))
d422 2
a423 2
	       INT(MirTypes.GP_NON_GC_REG(reg, MirTypes.ABSENT))
	   | MirTypes.FLOAT reg => REAL(MirTypes.FP_REG(reg, MirTypes.ABSENT))
d428 1
a428 1
	  val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d443 1
a443 1
  fun destruct_2_tuple(MirTypes.GP_GC_REG(gc_reg, opt)) =
d448 2
a449 2
      (LIST[INT(MirTypes.GP_GC_REG(reg1, MirTypes.ABSENT)),
	INT(MirTypes.GP_GC_REG(reg2, MirTypes.ABSENT))],
d451 1
a451 1
	  MirTypes.GC_REG(reg1, MirTypes.ABSENT), MirTypes.GC_REG(gc_reg, opt),
d454 1
a454 1
	    MirTypes.GC_REG(reg2, MirTypes.ABSENT), MirTypes.GC_REG(gc_reg, opt),
d488 1
a488 1
    | LIST many => #2 (tuple_up_in_reg(many, #1 gc_reg))
d493 1
a493 2
	 let val new_reg =
	   (MirTypes.new_gc_register(), MirTypes.ABSENT)
d499 1
a499 2
	 let val new_reg =
	   (MirTypes.new_gc_register(), MirTypes.ABSENT)
d516 1
a516 1
      (MirTypes.GP_GC_REG(gc_reg, MirTypes.ABSENT), code)
d620 1
a620 2
      val reg_operand =
	MirTypes.GC_REG(MirTypes.new_gc_register(), MirTypes.ABSENT)
d642 1
a642 1
	  val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d659 1
a659 2
	  val new_reg =
	    MirTypes.GC_REG(MirTypes.new_gc_register(), MirTypes.ABSENT)
d698 1
a698 1
      val res_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d745 1
a745 1
	      val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d783 1
a783 1
	  val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d806 1
a806 1
	  val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d826 1
a826 1
	  val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d843 1
a843 2
	  val result =
	    MirTypes.FP_REG(MirTypes.new_fp_register(), MirTypes.ABSENT)
d849 2
a850 6
		  val freg1 =
		    MirTypes.FP_REG(MirTypes.new_fp_register(),
				    MirTypes.ABSENT)
		  val freg2 =
		    MirTypes.FP_REG(MirTypes.new_fp_register(),
				    MirTypes.ABSENT)
d884 1
a884 2
	  val result =
	    MirTypes.FP_REG(MirTypes.new_fp_register(), MirTypes.ABSENT)
d903 1
a903 1
	  val res_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d927 1
a927 1
	  val res_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d978 1
a978 1
	  val res_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d991 1
a991 1
	    val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1007 1
a1007 1
		val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1026 1
a1026 1
		val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1081 1
a1081 2
	    val result =
	      MirTypes.GP_GC_REG(MirTypes.new_gc_register(), MirTypes.ABSENT)
d1088 1
a1088 3
		      val fp_op =
			MirTypes.FP_REG(MirTypes.new_fp_register(),
					MirTypes.ABSENT)
d1103 1
a1103 2
	    val result =
	      MirTypes.FP_REG(MirTypes.new_fp_register(), MirTypes.ABSENT)
d1134 1
a1134 1
	  val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1162 1
a1162 1
	  val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1240 1
a1240 1
	  val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1274 1
a1274 1
	  MirTypes.GP_GC_REG(x, _) =>
d1276 1
a1276 1
	| MirTypes.GP_NON_GC_REG(x, _) =>
d1283 1
a1283 2
	      [MirTypes.UNARY(MirTypes.MOVE,
			      MirTypes.GC_REG(new_reg, MirTypes.ABSENT), reg),
d1291 1
a1291 2
	      [MirTypes.UNARY(MirTypes.MOVE,
			      MirTypes.GC_REG(new_reg, MirTypes.ABSENT), reg),
d1295 1
a1295 1
      | ONE(REAL(MirTypes.FP_REG(fp_reg, _))) =>
d1384 1
a1384 1
	      (INT(MirTypes.GP_GC_REG(reg, MirTypes.ABSENT)),
d1404 1
a1404 1
	    val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1443 1
a1443 1
      val end_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1460 1
a1460 1
	      (#2 (tuple_up_in_reg(many, #1 end_reg)))) @@
d1492 1
a1492 1
	let val new_reg = (MirTypes.new_non_gc_register(), MirTypes.ABSENT)
d1500 1
a1500 1
	      (MirTypes.GP_GC_REG(gc_reg, MirTypes.ABSENT), code)
d1549 1
a1549 1
	    let val new_reg_op = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1567 1
a1567 1
		#2 (tuple_up_in_reg(many, #1 end_reg))) @@
d1589 1
a1589 1
	  MirTypes.COMMENT"Default or end"],[], MirTypes.ABSENT, [])
d1601 1
a1601 1
	      #2 (tuple_up_in_reg(many, #1 end_reg))) @@
d1712 1
a1712 2
	      val fp_op =
		MirTypes.FP_REG(MirTypes.new_fp_register(), MirTypes.ABSENT)
d1754 1
a1754 2
	      val scon_reg =
		MirTypes.GC_REG(MirTypes.new_gc_register(), MirTypes.ABSENT)
d1872 1
a1872 1
	  val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1899 1
a1899 1
      val gc_reg = MirTypes.GC_REG(MirTypes.new_gc_register(), MirTypes.ABSENT)
d1913 1
a1913 1
      val arg_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1916 1
a1916 1
	       Mir_Env.add_lambda_env((lvar, MirTypes.GC(#1 arg_reg)),
d1983 1
a1983 1
      val gc_reg = MirTypes.GC_REG(MirTypes.new_gc_register(), MirTypes.ABSENT)
d1989 1
a1989 1
	(fn x => (x, (MirTypes.new_gc_register(), MirTypes.ABSENT)))
d2001 1
a2001 1
	  Mir_Env.add_lambda_env((lv, MirTypes.GC(#1 reg)), env))
d2021 1
a2021 1
      val arg_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d2025 1
a2025 1
	  cg_sub(lexp, Mir_Env.add_lambda_env((lvar, MirTypes.GC(#1 arg_reg)),
d2078 1
a2078 2
      val temp_reg =
	MirTypes.GC_REG(MirTypes.new_gc_register(), MirTypes.ABSENT)
d2097 1
a2097 1
      val handler_frame_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d2099 1
a2099 2
      val handler_ptr =
	MirTypes.GC_REG(MirTypes.new_gc_register(), MirTypes.ABSENT)
d2124 1
a2124 2
      val result_reg =
	(MirTypes.new_gc_register(), MirTypes.ABSENT)
d2140 2
a2141 2
      val exn_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
      val env' = Mir_Env.add_lambda_env((lv, MirTypes.GC(#1 exn_reg)), env)
d2143 1
a2143 2
      val temp_sp =
	MirTypes.GC_REG(MirTypes.new_gc_register(), MirTypes.ABSENT)
d2214 1
a2214 1
	val (reg, new_code) = tuple_up_in_reg(sub_regs, #1 fn_arg)
@


1.32
log
@Fixed bug whereby blocks were getting lost during HANDLE clauses
Fixed up all exception generating instructions automatically
@
text
@d4 4
a2098 1
	  MirTypes.RAISE,
d2100 2
a2101 1
	  MirTypes.COMMENT"Call the exception handler, so we can backtrace"]
@


1.31
log
@Added implicit exception handling (eg fro ADDV)
@
text
@d4 3
d537 3
d545 3
a591 24
    val binaries_and_tags =
      #1 (LambdaSub.number_from(
	   [MirTypes.ADDV, MirTypes.SUBV, MirTypes.MULV, MirTypes.DIVV,
	     MirTypes.MODV],
				0, fn x => MirTypes.new_tag()))
    val prim_tags =
      #1 (LambdaSub.number_from(
	   [Pervasives.CHR, Pervasives.ORD, Pervasives.INTUMINUS,
	     Pervasives.INTABS],
				0, fn x => MirTypes.new_tag()))
    fun get_exception_tag(op_tag_list, operation) =
      let
	fun sub_fun [] = raise(LambdaTypes.impossible"overflow tag missing")
	| sub_fun((x, y) :: xs) = if operation = x then y else sub_fun xs
      in
	sub_fun op_tag_list
      end

    fun get_overflow_tag opcode =
      get_exception_tag(binaries_and_tags, opcode)

    fun get_prim_ex_tag prim =
      get_exception_tag(prim_tags, prim)

d748 1
a748 1
		  [], MirTypes.ABSENT, []), Mir_Env.empty_lambda_env)
d753 1
a753 1
      val (regs, the_code, extra_env) =
a755 7
(*
      fun get_exn_from_prim prim =
	case Set.set_to_list(Library.builtin_implicit_set(LambdaTypes.APP(
	  LambdaTypes.BUILTIN prim, LambdaTypes.STRUCT[]))) of
	  [ex] => ex
        | _ => raise(LambdaTypes.impossible"Missing implicit exception")
*)
d757 1
a757 1
      fun tagged_binary_calc(prim, opcode) =
d759 1
a759 9
	  val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	  val (regs, new_code) =
	    case regs of
	      ONE(INT reg) => destruct_2_tuple reg
	    | LIST[INT reg1, INT reg2] => (regs, [])
	    | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 0)")
	  val (_, (exn_f, exn_b, exn_o, exn_l), _) =
d766 3
a768 2
	  val exn_tag = MirTypes.new_tag()
	  val exn_blocks = MirTypes.BLOCK(exn_tag, exn_f) :: exn_b
d774 17
d821 1
a821 1
      fun unary_negate opcode =
d826 2
d832 2
a833 3
	        ([(MirTypes.TBINARY(opcode,
				    get_prim_ex_tag Pervasives.INTUMINUS, res2,
				    MirTypes.GP_IMM_INT 0, reg))], [],
d969 1
a969 1
	  val (regs', the_code', _) =
d1144 2
a1145 1
	  val tag = get_prim_ex_tag Pervasives.CHR
d1154 1
a1154 1
		  [MirTypes.TEST(MirTypes.BLT, tag, new_reg,
d1156 1
a1156 1
		  MirTypes.TEST(MirTypes.BGT, tag, new_reg,
d1161 1
a1161 1
				   MirTypes.GP_IMM_INT 0)], [],
d1172 2
a1173 1
	  val tag = get_prim_ex_tag Pervasives.ORD
d1177 1
a1177 1
	      [MirTypes.TEST(MirTypes.BLE, tag, the_size,
d1181 1
a1181 2
	      [], MirTypes.ABSENT, []))

d1230 1
a1230 1
      | Pervasives.INTUMINUS => unary_negate MirTypes.SUBV
d1251 2
d1260 1
a1260 2
		  MirTypes.TBINARY(opcode,
				   get_prim_ex_tag Pervasives.INTABS, res2,
d1262 1
a1262 1
		  MirTypes.BRANCH(MirTypes.BRA, MirTypes.TAG tag)], [],
d1270 1
a1270 1
      (result, code, extra_env)
d1276 1
a1276 1
      val (regs, the_code, extra_env) =
d1313 2
a1314 3
	Mir_Env.augment_lambda_env(Mir_Env.add_lambda_env((lvar, reg), env),
				   extra_env)
      val (rest_regs, rest_code, extra_env') =
d1319 1
a1319 2
	combine(the_code, (more_code, [], MirTypes.ABSENT, [])), rest_code),
          Mir_Env.augment_lambda_env(extra_env, extra_env'))
d1328 1
a1328 1
      val ((fn_reg, fn_code, extra_env), pos, is_same_set) =
d1341 1
a1341 4
	      ((ONE reg, (code, [], MirTypes.ABSENT, []),
		Mir_Env.add_lambda_env((lvar, get_any_register reg),
				       Mir_Env.empty_lambda_env)),
	        pos, is_same_set)
d1347 2
a1348 2
      val (arg_reg, arg_code, extra_env') =
	cg_sub(le2, Mir_Env.augment_lambda_env(env, extra_env), closure,
d1355 1
a1355 1
      (reg, code, Mir_Env.augment_lambda_env(extra_env, extra_env'))
d1360 1
a1360 2
      [] => (ONE(INT(MirTypes.GP_IMM_INT 0)), no_code,
	     Mir_Env.empty_lambda_env)
d1364 4
a1367 3
	fun iterate_over_struct([], reg_code_list, extra_env) =
	  (rev reg_code_list, extra_env)
	| iterate_over_struct((le, pos) :: rest, reg_code_list, extra_env) =
d1369 2
a1370 2
	    val (reg, code, extra_env') =
	      cg_sub(le, Mir_Env.augment_lambda_env(env, extra_env), closure,
d1374 1
a1374 2
	    iterate_over_struct(rest, (reg, code) :: reg_code_list,
	      Mir_Env.augment_lambda_env(extra_env, extra_env'))
d1376 10
a1385 3
	val (reg_code_list, extra_env) =
	  iterate_over_struct((Lists.zip(le_list, positions)), [],
			      Mir_Env.empty_lambda_env)
d1400 1
a1400 1
	 combine(the_code, (new_code, [], MirTypes.ABSENT, [])), extra_env)
d1405 1
a1405 1
      val (regs, the_code, extra_env) =
d1420 1
a1420 1
	      [])), extra_env)
d1425 1
a1425 1
	  (ONE(Lists.nth(field, many)), the_code, extra_env)
d1446 1
a1446 1
      val (regs, the_code, extra_env) =
a1448 1
      val env = Mir_Env.augment_lambda_env(env, extra_env)
d1460 1
a1460 1
	  val (regs, the_code, _) =
a1462 1
	  (* extra_env not usable in arms of switch *)
d1521 1
a1521 1
	    val (reg, code, _) =
d1524 8
a1531 1
	  (* extra_env not usable in arms of switch *)
d1766 1
a1766 1
	      val (regs', the_code', extra_env) =
d1830 1
a1830 1
		  (code, [], MirTypes.ABSENT, []), _) => (reg, code)
d1837 15
d1865 1
a1865 9
      (ONE(INT(MirTypes.GP_GC_REG end_reg)), result_code,
(*
        combine(
	  combine(
	    combine(the_code, (ptr_code @@ main_def, [], MirTypes.ABSENT, [])),
	      main_code),
	        ([], blocks1 @@ blocks2, MirTypes.PRESENT end_tag, [])),
*)
	extra_env)
d1872 1
a1872 3
      (ONE reg, (code, [], MirTypes.ABSENT, []),
        Mir_Env.add_lambda_env((lvar, get_any_register reg),
			       Mir_Env.empty_lambda_env))
d1875 1
a1875 1
      (ONE(INT(MirTypes.GP_IMM_INT i)), no_code, Mir_Env.empty_lambda_env)
d1880 1
a1880 2
	  (ONE(INT(MirTypes.GP_IMM_INT(convert_int i))), no_code,
	    Mir_Env.empty_lambda_env)
d1891 1
a1891 1
	      MirTypes.ABSENT, []), Mir_Env.empty_lambda_env)
d1925 1
a1925 1
      val (fn_reg, fn_code, _) =
d1953 1
a1953 2
      (ONE(INT(gp_from_reg cl_reg)), (code, the_fn, MirTypes.ABSENT, []),
        Mir_Env.empty_lambda_env)
d2046 1
a2046 1
	map (fn (x, _, _) => send_to_given_reg(x, fn_arg)) fn_reg_code_list
d2064 1
a2064 1
	(fn ((_, fn_code, _), exit_code) =>
d2076 1
a2076 6
(*
      val first_closure = case new_closure_list of
	closure :: _ => closure
      | _ => raise(LambdaTypes.impossible"No functions in LETREC")
*)
      val (regs, (first, blocks, tag_opt, last), extra_env) =
d2081 1
a2081 2
      (regs, (code @@ first, blocks @@ fn_block_list, tag_opt, last),
        Mir_Env.augment_lambda_env(letrec_env, extra_env))
d2086 1
a2086 1
      val (reg, code, _) =
d2101 1
a2101 1
      (reg, total_code, Mir_Env.empty_lambda_env)
d2139 1
a2139 1
      val (main_reg, main_code, _) =
d2168 1
a2168 1
	  MirTypes.COMMENT"Restore previous handler",
d2172 1
a2172 1
      val (exn_result_reg, (exn_f, exn_b, exn_o, exn_l), _) =
d2196 1
a2196 1
	  restore_block2] @@
d2207 1
a2207 2
      (ONE(INT(MirTypes.GP_GC_REG result_reg)), total_code,
        Mir_Env.empty_lambda_env)
a2212 1

d2214 1
a2214 1
    val (regs, (first, blocks, tag_opt, last), _) =
@


1.30
log
@Added PRESERVE_ALL_REGS for benefit of RAISE/HANDLE
Started work on impicitly used exceptions (eg ADDV)
@
text
@d4 4
a188 20
  val prims_to_exns =
    [(Pervasives.INTPLUS, Pervasives.EXSUM),
      (Pervasives.INTSTAR, Pervasives.EXPROD),
      (Pervasives.INTMINUS, Pervasives.EXDIFF),
      (Pervasives.INTUMINUS, Pervasives.EXNEG),
      (Pervasives.DIV, Pervasives.EXQUOT),
      (Pervasives.MOD, Pervasives.EXPROD),
      (Pervasives.INTABS, Pervasives.EXABS),
      (Pervasives.REALPLUS, Pervasives.EXSUM),
      (Pervasives.REALSTAR, Pervasives.EXPROD),
      (Pervasives.REALMINUS, Pervasives.EXDIFF),
      (Pervasives.REALUMINUS, Pervasives.EXNEG),
      (Pervasives.DIV, Pervasives.EXQUOT),
      (Pervasives.MOD, Pervasives.EXPROD),
      (Pervasives.REALABS, Pervasives.EXABS),
      (Pervasives.FLOOR, Pervasives.EXFLOOR),
      (Pervasives.SQRT, Pervasives.EXSQRT),
      (Pervasives.EXP, Pervasives.EXEXP),
      (Pervasives.LN, Pervasives.EXLN )]

d771 9
a779 1
      fun tagged_binary_calc opcode =
d789 13
d808 2
a809 2
		    get_overflow_tag opcode, res2, val1, val2))],
		  [], MirTypes.ABSENT, [])))
d1196 2
a1197 2
      | Pervasives.DIV => tagged_binary_calc MirTypes.DIVV
      | Pervasives.MOD => tagged_binary_calc MirTypes.MODV
d1234 1
a1234 1
      | Pervasives.INTPLUS => tagged_binary_calc MirTypes.ADDV
d1236 1
a1236 1
      | Pervasives.INTSTAR => tagged_binary_calc MirTypes.MULV
d1238 1
a1238 1
      | Pervasives.INTMINUS => tagged_binary_calc MirTypes.SUBV
d1898 9
a1906 4
	if needs_prim(Pervasives.STRINGEQ, fcn)
	then
	  Set.add_member(Map.lookup(Pervasives.STRINGEQ, prim_to_lambda), free)
	else free
d1955 1
a1955 1
    | cg_sub(LambdaTypes.LETREC(lv_list, le_list, lexp), env, closure,
d1976 9
d2101 1
a2108 3
(*
      raise(LambdaTypes.not_done_yet"cg_sub(RAISE)")
*)
d2137 1
d2149 2
a2150 1
	[MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG handler,
@


1.29
log
@Fixed bugs in LETREC and default cases in SWITCH.
Added code for SWITCH into empty list, as this can occur
Also added exception tag for MODV, newly created
@
text
@d4 5
a182 3
  val temp_sp = MirRegisters.temp_sp
  (* The temporary stack pointer used during function entry *)

d185 20
d1923 1
a1923 1
	([MirTypes.ENTER, MirTypes.PRESERVE_REGS,
d1933 1
a1933 1
	  [MirTypes.RESTORE_REGS, MirTypes.RTS],
d2029 1
a2029 1
	([MirTypes.ENTER, MirTypes.PRESERVE_REGS,
d2040 1
a2040 1
	      [MirTypes.RESTORE_REGS, MirTypes.RTS],
d2078 2
a2079 1
      val final_code = send_to_given_reg(reg, fn_arg) @@
d2082 2
a2083 1
	  MirTypes.BRANCH(MirTypes.BRA, MirTypes.REG temp_reg)]
d2166 1
a2166 1
	  [MirTypes.RESTORE_REGS,
@


1.28
log
@Fixed bug in HANDLE causing empty blocks, and removed
fn_arg etc to separate module for better external structure
@
text
@d4 4
d579 2
a580 1
	   [MirTypes.ADDV, MirTypes.SUBV, MirTypes.MULV, MirTypes.DIVV],
d669 1
a669 1
	    MirTypes.STOREOP(MirTypes.ST, new_reg, MirTypes.GC_REG cl_arg',
d1170 1
a1170 1
      | Pervasives.MOD => binary_calc MirTypes.MODS
d1442 1
a1442 1
	  val (regs, the_code, extra_env) =
d1445 1
d1447 1
a1447 1
	    ((case regs of
d1452 1
a1452 2
	      MirTypes.COMMENT comment :: (#2 (
		  tuple_up_in_reg(many, #1 end_reg))) @@
d1454 1
a1454 1
	      [], MirTypes.ABSENT, [])))
d1457 1
a1457 1
	  (case the_code of
d1459 1
a1459 1
	      [MirTypes.BLOCK(new_tag, first @@ [final_branch])]
d1461 2
a1462 2
	      [MirTypes.BLOCK(new_tag, first),
	        MirTypes.BLOCK(tag, last @@ [final_branch])],
d1603 10
a1612 1
	[] => raise(LambdaTypes.impossible"Empty switch list")
d1629 5
d1635 1
a1635 2
	  (extra @@ def_code,
	    make_cgt(the_reg, low, high, val_le_tags_list))
d1816 9
d1826 2
a1827 1
      (ONE(INT(MirTypes.GP_GC_REG end_reg)),
d1833 1
d1957 17
d1982 2
a1983 1
	(code, [MirTypes.COMMENT"Copy in function pointers"] :: (map
d2035 1
d2039 1
d2041 2
a2042 1
	cg_sub(lexp, env, first_closure, gc_objects_within,
d2046 1
a2046 1
        extra_env)
@


1.27
log
@Added raise and handle
@
text
@d4 3
d115 1
d136 1
d143 1
a143 1
  sharing Mir_Env.MirTypes = MirTypes
d155 1
a155 1
  val fn_arg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d158 1
a158 1
  val cl_arg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d161 1
a161 1
  val cl_arg' = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d165 1
a165 1
  val fp = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d168 1
a168 1
  val sp = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d171 1
a171 1
  val handler = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d174 3
d513 1
d520 1
d1313 1
d1318 1
d1341 26
a1366 22
    let
      val positions = gc_list_positions(0, count_gc_objects, le_list)
      fun iterate_over_struct([], reg_code_list, extra_env) =
	(rev reg_code_list, extra_env)
      | iterate_over_struct((le, pos) :: rest, reg_code_list, extra_env) =
	let
	  val (reg, code, extra_env') =
	    cg_sub(le, Mir_Env.augment_lambda_env(env, extra_env), closure,
		   static_offset + pos, start_at + pos, funs_in_closure,
		   fn_tag_list)
	in
	  iterate_over_struct(rest, (reg, code) :: reg_code_list,
	    Mir_Env.augment_lambda_env(extra_env, extra_env'))
	end
      val (reg_code_list, extra_env) =
	iterate_over_struct((Lists.zip(le_list, positions)), [],
			    Mir_Env.empty_lambda_env)
      val the_code = Lists.reducel combine
	(no_code, map #2 reg_code_list)
      val new_reg_code_list =
	map (fn ONE reg => (reg, [MirTypes.COMMENT("Argument to tuple")])
          | LIST regs =>
d1373 5
a1377 5
      val new_code = Lists.reducel op @@ ([], map #2 new_reg_code_list)
    in
      (LIST(map #1 new_reg_code_list),
        combine(the_code, (new_code, [], MirTypes.ABSENT, [])), extra_env)
    end
d2035 1
a2035 2
	[MirTypes.ADR(MirTypes.LEA, handler_ptr, handler_tag),
	  MirTypes.STOREOP(MirTypes.ST, handler_ptr, handler_frame,
d2045 2
a2046 1
			   length frame_setup)] @@
d2061 3
d2085 1
a2085 1
      val (exn_result_reg, exn_code, _) =
d2103 11
a2113 8
      val (exn_entry, exn_blocks, tag, exn_exit) =
	combine(
	  combine((exn_setup, [], MirTypes.ABSENT, []), exn_code),
	    (exn_end, [restore_block1, restore_block2], MirTypes.ABSENT, []))
      val exn_whole = ([],
		       MirTypes.BLOCK(handler_tag, exn_entry) :: exn_blocks,
		       tag,
		       exn_exit)
a2118 3
(*
      val _ = print"Handle(exp, exp') not yet complete"
*)
@


1.26
log
@Started on HANDLE
@
text
@d4 3
d264 2
d267 1
a267 1
      count_gc_objects le + count_gc_objects le'
a504 1
(*
a510 1
*)
d892 1
a892 1
			MirTypes.BRANCH(MirTypes.BRA, tag)],
d930 1
a930 1
			MirTypes.BRANCH(MirTypes.BRA, tag)],
d1229 1
a1229 1
		  MirTypes.BRANCH(MirTypes.BRA, tag)], [],
d1412 1
a1412 1
      val final_branch = MirTypes.BRANCH(MirTypes.BRA, end_tag)
d1552 1
a1552 1
	([MirTypes.BRANCH(MirTypes.BRA, def_tag),
d1690 1
a1690 1
	      (fn ((LambdaTypes.EXP_TAG le, code, tag), p) =>
d1721 1
a1721 1
	        MirTypes.ALLOCATE(MirTypes.ALLOC, MirTypes.GC_REG fn_arg,
d1866 1
a1866 1
	  [MirTypes.RESTORE_REGS, MirTypes.EXIT],
d1955 1
a1955 1
	      [MirTypes.RESTORE_REGS, MirTypes.EXIT],
d1984 16
d2001 1
d2005 92
a2096 7
      val (_, free) = LambdaSub.bounds_and_frees hand
      val free =
	if needs_prim(Pervasives.STRINGEQ, hand)
	then
	  Set.add_member(Map.lookup(Pervasives.STRINGEQ, prim_to_lambda), free)
	else free
      val gc_objects_within = count_gc_objects hand
d2098 1
a2098 43
      val tag = Map.lookup(start_at + gc_objects_within + 1, top_closure)
      val gc_reg = MirTypes.GC_REG(MirTypes.new_gc_register(), MirTypes.ABSENT)
      val (cl_reg, code, new_closure) =
	case make_closure([tag], free, gc_objects_within,
			  static_offset + funs_in_closure, env, closure) of
	  (reg, code, [new_closure]) =>
	    (reg, code @@
	      [MirTypes.COMMENT"Copy in function pointer",
	        MirTypes.STOREOP(MirTypes.LD, gc_reg, MirTypes.GC_REG cl_arg',
	        MirTypes.GP_IMM_INT(funs_in_closure + static_offset +
				    gc_objects_within)),
	        MirTypes.STOREOP(MirTypes.ST, gc_reg, reg,
				 MirTypes.GP_IMM_INT 0)],
	      new_closure)
	| _ => raise(LambdaTypes.impossible"Single FN with multiple tags")
      val arg_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
      val (fn_reg, fn_code, _) =
	cg_sub(lexp,
	       Mir_Env.add_lambda_env((lvar, MirTypes.GC(#1 arg_reg)),
				      Mir_Env.empty_lambda_env),
	       (* All bets for registers are off, barring the argument *)
	       new_closure, 0, start_at, 1, [tag] (* tag for this function *))
      val final_code = send_to_given_reg(fn_reg, fn_arg)
      val makes_calls = count_real_apps lexp <> 0
      val entry_code =
	([MirTypes.ENTER, MirTypes.PRESERVE_REGS,
	  MirTypes.COMMENT(if makes_calls then "Non-leaf" else "Leaf"),
	  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG cl_arg',
			 MirTypes.GP_GC_REG cl_arg),
	  MirTypes.COMMENT"Copy closure pointer to local copy (callee save)",
	  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG arg_reg,
			 MirTypes.GP_GC_REG fn_arg)],
	  [], MirTypes.ABSENT, [])
      val exit_code =
	(final_code @@
	  [MirTypes.RESTORE_REGS, MirTypes.EXIT],
	  [], MirTypes.ABSENT, [])
      val (first, blocks, tag_opt, last) =
	combine(entry_code, combine(fn_code, exit_code))
      val the_fn = MirTypes.BLOCK(tag, first) :: blocks @@
	case tag_opt of
	  MirTypes.ABSENT => []
	| MirTypes.PRESENT tag => [MirTypes.BLOCK(tag, last)]
a2099 1
      val _ = print"Handle(exp, exp') not yet complete"
d2101 1
a2101 3
      raise(LambdaTypes.not_done_yet"cg_sub(HANDLE)")
(*
      (ONE(INT(gp_from_reg cl_reg)), (code, the_fn, MirTypes.ABSENT, []),
a2102 1
*)
@


1.25
log
@Added use of NON_GC_SPILL_SIZE to closure production
@
text
@d4 3
d157 9
d595 1
a595 1
	LambdaSub.number_from(list_of_tags funs, 0, fn x => x)
d1187 1
a1187 1
      | Pervasives.MAKE_NEW_UNQIUE => do_external_prim prim
d1982 1
a1982 1
    | cg_sub(LambdaTypes.HANDLE(le, le'), env, closure, static_offset,
d1984 55
d2040 5
@


1.24
log
@Added slot in closure for non-gc spill area size
@
text
@d4 3
d317 8
d433 2
d454 7
d637 2
a638 1
	  [MirTypes.UNARY(MirTypes.MOVE, new_reg, MirTypes.GP_IMM_INT 0),
d1075 3
d1237 1
a1237 1
	| MirTypes.GP_IMM_INT i =>
d1246 9
d1481 2
@


1.23
log
@Added code generation of switches against exception values,
and augmenting of lambda -> register environment following code
generation of certain expressions
@
text
@d4 5
d180 1
a180 1
      LambdaSub.reduce_left op +
d195 1
a195 1
      LambdaSub.reduce_left op + (0, map count_real_apps le_list)
d213 1
a213 1
      LambdaSub.reduce_left op +
d243 1
a243 1
      LambdaSub.reduce_left op + (0, map count_gc_objects le_list)
d298 1
a298 1
    (new_reg, alloc_op :: LambdaSub.reduce_left op @@
d480 1
a480 1
      LambdaSub.reduce_left
d500 1
a500 1
	  LambdaSub.reduce_left
d582 1
a582 1
 	LambdaSub.reduce_left op @@
d610 11
d623 2
a624 2
        MirTypes.ALLOCATE(MirTypes.ALLOC, reg_operand, funs + statics + free_size) ::
	copy_dynamics @@ copy_statics,
d627 1
a627 1
	  LambdaSub.reduce_left
d660 1
a660 1
			  MirTypes.TAG(LambdaSub.nth(pos, tag_list))),
d1298 1
a1298 1
      val the_code = LambdaSub.reduce_left combine
d1309 1
a1309 1
      val new_code = LambdaSub.reduce_left op @@ ([], map #2 new_reg_code_list)
d1337 1
a1337 1
	  (ONE(LambdaSub.nth(field, many)), the_code, extra_env)
d1346 1
a1346 1
      val list_size = LambdaSub.reduce_left op+
d1348 1
a1348 1
      val tag_sizes = LambdaSub.reduce_left op+
d1471 1
a1471 1
	  LambdaSub.reduce_left op @@
d1839 1
a1839 1
      val free = LambdaSub.reduce_left Set.union
d1850 1
a1850 1
	LambdaSub.reduce_left op+ (0, map count_gc_objects le_list'')
d1864 1
a1864 1
	  LambdaSub.reduce_left
d1869 1
a1869 1
      val code = LambdaSub.reduce_left op @@
d1914 1
a1914 1
	LambdaSub.reduce_left op @@
@


1.22
log
@Added ord, chr, size. Sorted out STRINGEQ calling.
Removed bug in subst_ext_prims.
@
text
@d4 4
d96 1
d111 1
d122 1
a122 1
    LambdaPrint.LambdaTypes
d126 2
a127 2
  sharing Set = LambdaSub.Set = Environ.Set = Primitives.Set
  sharing EnvironTypes.Map = Map = Mir_Env.Map = Environ.Map
d148 2
a149 141
  val load_string =
    case Environ.lookup_valid(Ident.VAR(Symbol.find_symbol"_load_string"),
					Primitives.initial_env) of
      EnvironTypes.PRIM prim => prim
    | _ => raise(LambdaTypes.impossible"_load_string not prim")

  fun prim_order(a, b) =
    Symbol.symbol_order(Symbol.find_symbol(Pervasives.print_pervasive a),
			Symbol.find_symbol(Pervasives.print_pervasive b))

  fun is_inline Pervasives.REF = true
  | is_inline Pervasives.EXABS = true
  | is_inline Pervasives.EXORD = true
  | is_inline Pervasives.EXCHR = true
  | is_inline Pervasives.EXDIV = true
  | is_inline Pervasives.EXMOD = true
  | is_inline Pervasives.EXQUOT = true
  | is_inline Pervasives.EXPROD = true
  | is_inline Pervasives.EXNEG = true
  | is_inline Pervasives.EXSUM = true
  | is_inline Pervasives.EXDIFF = true
  | is_inline Pervasives.EXFLOOR = true
  | is_inline Pervasives.EXSQRT = true
  | is_inline Pervasives.EXEXP = true
  | is_inline Pervasives.EXLN = true
  | is_inline Pervasives.EXIO = true
  | is_inline Pervasives.EXMATCH = true
  | is_inline Pervasives.EXBIND = true
  | is_inline Pervasives.EXINTERRUPT = true
  | is_inline Pervasives.MAP = false
  | is_inline Pervasives.REV = false
  | is_inline Pervasives.NOT = true
  | is_inline Pervasives.ABS = true
  | is_inline Pervasives.FLOOR = true
  | is_inline Pervasives.REAL = true
  | is_inline Pervasives.SQRT = true
  | is_inline Pervasives.SIN = true
  | is_inline Pervasives.COS = true
  | is_inline Pervasives.ARCTAN = true
  | is_inline Pervasives.EXP = true
  | is_inline Pervasives.LN = true
  | is_inline Pervasives.SIZE = true
  | is_inline Pervasives.CHR = true
  | is_inline Pervasives.ORD = true
  | is_inline Pervasives.EXPLODE = false
  | is_inline Pervasives.IMPLODE = false
  | is_inline Pervasives.DEREF = true
  | is_inline Pervasives.FDIV = true
  | is_inline Pervasives.DIV = true
  | is_inline Pervasives.MOD = true
  | is_inline Pervasives.PLUS = false
  | is_inline Pervasives.STAR = false
  | is_inline Pervasives.MINUS = false
  | is_inline Pervasives.HAT = false
  | is_inline Pervasives.AT = false
  | is_inline Pervasives.NE = false
  | is_inline Pervasives.LESS = false
  | is_inline Pervasives.GREATER = false
  | is_inline Pervasives.LESSEQ = false
  | is_inline Pervasives.GREATEREQ = false
  | is_inline Pervasives.BECOMES = true
  | is_inline Pervasives.O = true
  | is_inline Pervasives.UMINUS = false
  | is_inline Pervasives.EQ = false
  | is_inline Pervasives.STD_IN = true
  | is_inline Pervasives.STD_OUT = true
  | is_inline Pervasives.OPEN_IN = false
  | is_inline Pervasives.OPEN_OUT = false
  | is_inline Pervasives.INPUT = false
  | is_inline Pervasives.LOOKAHEAD = false
  | is_inline Pervasives.CLOSE_IN = false
  | is_inline Pervasives.END_OF_STREAM = false
  | is_inline Pervasives.OUTPUT = false
  | is_inline Pervasives.CLOSE_OUT = false
  | is_inline Pervasives.MAKE_NEW_UNQIUE = false
  | is_inline Pervasives.LOAD_STRING = true
  | is_inline Pervasives.REALPLUS = true
  | is_inline Pervasives.INTPLUS = true
  | is_inline Pervasives.REALSTAR = true
  | is_inline Pervasives.INTSTAR = true
  | is_inline Pervasives.REALMINUS = true
  | is_inline Pervasives.INTMINUS = true
  | is_inline Pervasives.REALUMINUS = true
  | is_inline Pervasives.INTUMINUS = true
  | is_inline Pervasives.INTLESS = true
  | is_inline Pervasives.REALLESS = true
  | is_inline Pervasives.INTGREATER = true
  | is_inline Pervasives.REALGREATER = true
  | is_inline Pervasives.INTLESSEQ = true
  | is_inline Pervasives.REALLESSEQ = true
  | is_inline Pervasives.INTGREATEREQ = true
  | is_inline Pervasives.REALGREATEREQ = true
  | is_inline Pervasives.INTEQ = true
  | is_inline Pervasives.INTNE = true
  | is_inline Pervasives.REALEQ = true
  | is_inline Pervasives.REALNE = true
  | is_inline Pervasives.STRINGEQ = false
  | is_inline Pervasives.STRINGNE = false
  | is_inline Pervasives.INTABS = true
  | is_inline Pervasives.REALABS = true

  fun builtin_external_set(LambdaTypes.APP(LambdaTypes.BUILTIN prim, le)) =
    Set.union(if is_inline prim
		then Set.empty_set
	      else
		Set.singleton prim, builtin_external_set le)
  | builtin_external_set(LambdaTypes.BUILTIN prim) = Set.singleton prim
  | builtin_external_set(LambdaTypes.APP(le, le')) =
    Set.union(builtin_external_set le, builtin_external_set le')
  | builtin_external_set(LambdaTypes.FN(_, le)) = builtin_external_set le
  | builtin_external_set(LambdaTypes.SELECT(_, le)) = builtin_external_set le
  | builtin_external_set(LambdaTypes.RAISE le) = builtin_external_set le
  | builtin_external_set(LambdaTypes.HANDLE(le, le')) =
    Set.union(builtin_external_set le, builtin_external_set le')
  | builtin_external_set(LambdaTypes.STRUCT le_list) =
    LambdaSub.reduce_left
    Set.union
    (Set.empty_set, map builtin_external_set le_list)
  | builtin_external_set(LambdaTypes.SWITCH(le, tag_le_list, opt1, opt2)) =
    let
      fun b_e_sub(LambdaTypes.EXP_TAG le, le') =
	Set.union(builtin_external_set le, builtin_external_set le')
      | b_e_sub(LambdaTypes.SCON_TAG(Ident.STRING _), le) =
	Set.add_member(Pervasives.STRINGEQ, builtin_external_set le)
      | b_e_sub(_, le) = builtin_external_set le
      fun b_e_opt(LambdaTypes.PRESENT le) = builtin_external_set le
      | b_e_opt LambdaTypes.ABSENT = Set.empty_set
    in
      LambdaSub.reduce_left
      Set.union
      (Set.union(builtin_external_set le,
	Set.union(b_e_opt opt1, b_e_opt opt2)), map b_e_sub tag_le_list)
    end
  | builtin_external_set(LambdaTypes.LETREC(_, le_list, le)) =
    LambdaSub.reduce_left Set.union
    (builtin_external_set le, map builtin_external_set le_list)
  | builtin_external_set(LambdaTypes.SCON _) = Set.empty_set
  | builtin_external_set(LambdaTypes.INT _) = Set.empty_set
  | builtin_external_set(LambdaTypes.VAR _) = Set.empty_set

  fun needs_prim(prim, le) = Set.is_member(prim, builtin_external_set le)
a159 61
  fun prims_in_le le =
    Set.setdiff(builtin_external_set le, Set.singleton load_string)

  fun get_env_and_bindings le =
  let
    val prims = prims_in_le le
    val _ = print(Integer.makestring(length(Set.set_to_list prims)) ^ " primitives")
    val _ = map (print o Pervasives.print_pervasive) (Set.set_to_list prims)
    val prims' = Set.list_to_set(map EnvironTypes.PRIM (Set.set_to_list prims))
    val EnvironTypes.ENV(initial_env_map, _, _) = Primitives.initial_env
    val initial_domain = Map.domain initial_env_map
    val new_domain =
      Set.set_to_list(
      LambdaSub.reduce_left
      Set.union
      (Set.empty_set,
        map
	(fn x =>
	  if Set.is_member(Environ.lookup_valid(x, Primitives.initial_env),
			   prims') then
	    Set.singleton x
	  else Set.empty_set)
	initial_domain))
    val (numbered_env, _) =
      LambdaSub.number_from(initial_domain, 0,
			    EnvironTypes.FIELD o LambdaTypes.toField)
    val field_map =
      LambdaSub.reduce_left
      (fn (x, y) => Environ.add_valid_env(y, x))
      (Environ.empty_env, numbered_env)
    val prim_field_list =
      map
      (fn x => (Environ.lookup_valid(x, Primitives.initial_env),
		Environ.lookup_valid(x, field_map)))
      new_domain
    val fields_to_lambdas =
      map (fn (_, x) => (x, LambdaTypes.new_LVar()))
      prim_field_list
    val prims_to_lambdas =
      map (fn ((x, y), (z, t)) => if (y = z) then (x, t)
	   else raise(LambdaTypes.impossible"prims_to_lambdas"))
      (Lists.zip(prim_field_list, fields_to_lambdas))
    val outer_lambda = LambdaTypes.new_LVar()
    val selects =
      map
      (fn (EnvironTypes.FIELD x, y) =>
        (y,
	  LambdaTypes.SELECT(x, LambdaTypes.VAR outer_lambda))
      | _ => raise(LambdaTypes.impossible"non_field in fields_to_lambdas"))
      fields_to_lambdas
  in
    (LambdaSub.reduce_left
      (fn (x, (EnvironTypes.PRIM y, z)) =>
        Map.add((y, z), x, prim_order)
      | _ => raise(LambdaTypes.impossible"Non-prim in initial_field_env"))
      (Map.empty_map, prims_to_lambdas),
    (outer_lambda,
      LambdaTypes.APP(LambdaTypes.BUILTIN load_string,
		      LambdaTypes.SCON(Ident.STRING"/library"))) :: selects)
  end

d203 1
a203 1
      if prim = load_string then 0 else count_gc_objects le'
d340 6
d347 29
a375 19
    if Mir_Env.is_in_closure(lvar, closure) then
      let
	val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
	val offset_in_closure = Mir_Env.lookup_in_closure(lvar, closure)
      in
	((INT(MirTypes.GP_GC_REG new_reg),
	  [MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
	    MirTypes.GC_REG cl_arg',
	      MirTypes.GP_IMM_INT offset_in_closure)]),
	 offset_in_closure, offset_in_closure < funs_in_closure)
      end
    else
      (((case Mir_Env.lookup_lambda(lvar, env) of
	MirTypes.GC reg => INT(MirTypes.GP_GC_REG(reg, MirTypes.ABSENT))
      | MirTypes.NON_GC reg =>
	  INT(MirTypes.GP_NON_GC_REG(reg, MirTypes.ABSENT))
      | MirTypes.FLOAT reg => REAL(MirTypes.FP_REG(reg, MirTypes.ABSENT))
      | _ => raise(LambdaTypes.impossible"lookup_lambda returns const")),
	  []), 0, false)
a397 12
(*
  fun destruct_1_tuple(MirTypes.GP_GC_REG(gc_reg, opt)) =
    let val reg = MirTypes.new_gc_register() (* reasonable assumption *)
    in
      (LIST[MirTypes.GP_GC_REG(reg, MirTypes.ABSENT)],
        [MirTypes.STOREOP(MirTypes.LD,
	  MirTypes.GC_REG(reg, MirTypes.ABSENT), MirTypes.GC_REG(gc_reg, opt),
			  MirTypes.GP_IMM_INT 0)])
    end
  | destruct_1_tuple _ = raise(LambdaTypes.impossible"destruct_1_tuple")
*)

d462 2
a463 1
    val (prim_to_lambda, bindings) = get_env_and_bindings lambda_exp
a467 1
(*
a478 2
    val _ = print"got top closure"

d480 1
a480 31
      if length bindings <= 1 then lambda_exp
      else
      let
	fun subst_ext_prims(le as
			    LambdaTypes.APP(LambdaTypes.BUILTIN prim, le')) =
	  if is_inline prim
	    then
	      let val _ = print("subst_ext_prims(APP(" ^ Pervasives.print_pervasive prim ^ ", _)")
	      in
		LambdaTypes.APP(LambdaTypes.BUILTIN prim,
				LambdaSub.apply_one_level subst_ext_prims le')
	      end
	  else
	      (LambdaTypes.APP(LambdaTypes.VAR(Map.lookup(prim,
							 prim_to_lambda)),
			       LambdaSub.apply_one_level subst_ext_prims le')
	       handle exn as Map.Lookup =>
	      (print("Lookup failure (1) on " ^ Pervasives.print_pervasive prim);
	        raise exn))
	| subst_ext_prims(LambdaTypes.BUILTIN prim) =
	      let val _ = print("subst_ext_prims(PRIM" ^ Pervasives.print_pervasive prim)
	      in
	  (LambdaTypes.VAR(Map.lookup(prim, prim_to_lambda))
	    handle exn as Map.Lookup =>
	      (print("Lookup failure (2) on " ^ Pervasives.print_pervasive prim);
	        raise exn))
	      end
	| subst_ext_prims le = LambdaSub.apply_one_level subst_ext_prims le
      in
	LambdaSub.wrap_lets(subst_ext_prims lambda_exp, bindings)
      end
d489 1
a489 1
	  if prim = load_string then Set.singleton chars
d690 1
a690 1
		  [], MirTypes.ABSENT, []))
d695 1
a695 1
      val (regs, the_code) =
d886 1
a886 1
	  val (regs', the_code') =
d906 1
a906 1
    in
d918 1
a918 1
		  MirTypes.STOREOP(MirTypes.ST, reg_from_gp new_reg, res1,
d933 1
a933 1
		     [MirTypes.STOREOP(MirTypes.ST, reg_from_gp new_reg,
d951 1
a951 1
		    ([MirTypes.STOREOP(MirTypes.LD, res1, MirTypes.GC_REG reg,
a1177 3



d1180 3
a1182 1
	    raise (LambdaTypes.impossible"Impossible load_string")
d1188 1
a1188 1
      val (regs, the_code) =
d1215 4
a1218 2
      val env' = Mir_Env.add_lambda_env((lvar, reg), env)
      val (rest_regs, rest_code) =
d1223 2
a1224 1
	combine(the_code, (more_code, [], MirTypes.ABSENT, [])), rest_code))
d1233 1
a1233 1
      val ((fn_reg, fn_code), pos, is_same_set) =
d1244 4
a1247 1
	      ((ONE reg, (code, [], MirTypes.ABSENT, [])), pos, is_same_set)
d1253 3
a1255 2
      val (arg_reg, arg_code) =
	cg_sub(le2, env, closure, static_offset + gc_objects_in_call,
d1257 3
d1261 1
a1261 2
      do_app(fn_reg, fn_code, arg_reg, arg_code, is_same_set,
	     length fn_tag_list + pos - funs_in_closure, fn_tag_list)
d1267 15
a1281 4
      val reg_code_list = map
	(fn (x, y) => cg_sub(x, env, closure, static_offset + y, start_at + y,
			     funs_in_closure, fn_tag_list))
	(Lists.zip(le_list, positions))
d1296 1
a1296 1
        combine(the_code, (new_code, [], MirTypes.ABSENT, [])))
d1301 3
a1303 2
      val (regs, the_code) = cg_sub(lexp, env, closure, static_offset,
				    start_at, funs_in_closure, fn_tag_list)
d1316 1
a1316 1
	      [])))
d1321 1
a1321 1
	  (ONE(LambdaSub.nth(field, many)), the_code)
d1342 1
a1342 1
      val (regs, the_code) =
d1345 1
d1357 1
a1357 1
	  val (regs, the_code) =
d1418 8
a1425 2
	 (t, cg_sub(x, env, closure, static_offset + le_offset,
	   start_at + le_offset, funs_in_closure, fn_tag_list), MirTypes.new_tag()))
d1480 1
a1480 1
      | bounds(low, high, (i, _, _) :: xs) =
d1485 29
d1526 1
a1526 1
	  val (low, high) = bounds(0, 0, val_le_tags_list)
d1541 2
a1542 7
	let
	  fun do_chained_tests(_, def_tag, [], _) =
	    ([MirTypes.BRANCH(MirTypes.BRA, def_tag),
	       MirTypes.COMMENT"Default or end"],[], MirTypes.ABSENT, [])
	  | do_chained_tests(the_reg, def_tag,
	    (scon, (regs, (first, blocks, tag_opt, last)), tag) :: rest,
			     test_code) =
d1544 19
a1562 17
	    val the_test = test_code(the_reg, scon, tag)
	    val end_code = (case regs of
	        ONE(INT reg) => [MirTypes.UNARY(MirTypes.MOVE,
					   MirTypes.GC_REG end_reg, reg)]
	      | ONE(REAL fp_op) =>
		save_real_to_reg(fp_op, MirTypes.GC_REG end_reg)
	      | LIST many =>
		#2 (tuple_up_in_reg(many, #1 end_reg))) @@
		[final_branch]
	    val result =
	      case tag_opt of
		MirTypes.ABSENT =>
		(the_test, MirTypes.BLOCK(tag, first @@ end_code) :: blocks,
		  MirTypes.ABSENT, [])
	      | MirTypes.PRESENT tag'=>
		(the_test, MirTypes.BLOCK(tag, first) :: blocks @@
		  [MirTypes.BLOCK(tag', last @@ end_code)], MirTypes.ABSENT, [])
d1564 13
a1576 1
	    combine(result, do_chained_tests(the_reg, def_tag, rest, test_code))
d1578 18
a1595 3
	in
	  (case x of
	    Ident.INT _ =>
d1597 2
a1598 18
	      val val_le_tags_list =
		Match_Utils.Qsort (fn ((i:int, _, _), (i', _, _)) => i < i')
		(map (fn (LambdaTypes.SCON_TAG(Ident.INT i), code, tag) =>
		      (convert_int i, code, tag)
	        | _ => raise(LambdaTypes.impossible"Mixed tag type in switch"))
		  tagged_code)
	      val (low, high) = bounds(0, 0, val_le_tags_list)
	      val len = length val_le_tags_list
	      val use_cgt = high+1-low <= 2*len andalso len > 2
	      (* Not too many holes, but a bigger than two list *)
	      val (the_reg, extra) = send_to_reg regs
	      val def_code = case def1 of
		LambdaTypes.ABSENT =>
		  [MirTypes.COMMENT"No default (strange for scon match)"]
	      | LambdaTypes.PRESENT _ =>
		  [MirTypes.COMMENT"Default",
		    MirTypes.TEST(MirTypes.BGT, tag1, the_reg,
				  MirTypes.GP_IMM_INT high)]
d1600 4
a1603 12
	      if use_cgt then
		(extra @@ def_code,
		  make_cgt(the_reg, low, high, val_le_tags_list))
	      else
		let
		  fun do_test(reg, i, tag) =
		    [MirTypes.TEST(MirTypes.BEQ, tag, reg,
				   MirTypes.GP_IMM_INT i)]
		in
		  (extra,
		    do_chained_tests(the_reg, tag1, val_le_tags_list, do_test))
		end
d1605 34
a1638 1
	  | Ident.REAL _ =>
d1640 12
a1651 35
	      val val_le_tags_list =
		map (fn ((LambdaTypes.SCON_TAG(Ident.REAL _), code, tag), p) =>
		      (p, code, tag)
	        | _ => raise(LambdaTypes.impossible"Mixed tag type in switch"))
		  (Lists.zip(tagged_code, tag_positions))
	      val (the_reg, extra) = case regs of
		ONE reg => get_real reg
	      | _ => raise(LambdaTypes.impossible"struct gives single REAL")

	      fun do_test(reg, i, tag) =
		(* reg is the value input,
		 i is the immediate constant (in the case of an int)
		 or the position in the closure for this function,
		 relative to static_offset + funs_in_closure
	         in the case of a real or string
	         tag is where to go to on successful comparison *)
	      let
		val fp_op =
		  MirTypes.FP_REG(MirTypes.new_fp_register(), MirTypes.ABSENT)
	      in
		[MirTypes.STOREFPOP(MirTypes.FLD, fp_op,
		  MirTypes.GC_REG cl_arg',
		  MirTypes.GP_IMM_INT(static_offset + i + funs_in_closure)),
		  MirTypes.FTEST(MirTypes.FBEQ, tag, fp_op, reg)]
	      end
	      val tags_code =
		map
		(fn (p, (t, _)) =>
		  case t of
		    LambdaTypes.SCON_TAG(scon as Ident.REAL _) =>
		      MirTypes.BLOCK(Map.lookup(start_at + p + 1, top_closure),
				     [MirTypes.VALUE scon])
		  | _ => raise(LambdaTypes.impossible"non-REAL in REAL switch")
		      )
		(Lists.zip(tag_positions, tag_le_list))
d1653 14
a1666 3
	      (extra,
	        combine(([], tags_code, MirTypes.ABSENT, []),
		  do_chained_tests(the_reg, tag1, val_le_tags_list, do_test)))
d1668 15
a1682 11
	  | Ident.STRING _ =>
	    let
	      val val_le_tags_list =
		map
		(fn ((LambdaTypes.SCON_TAG(Ident.STRING _), code, tag), p) =>
		      (p, code, tag)
	        | _ => raise(LambdaTypes.impossible"Mixed tag type in switch"))
		  (Lists.zip(tagged_code, tag_positions))
	      val the_reg = case regs of
		ONE(INT(arg as MirTypes.GP_GC_REG _)) => arg
	      | _ => raise(LambdaTypes.impossible"struct gives single STRING")
d1684 12
a1695 52
	      fun do_test(reg, i, tag) =
		(* reg is the value input,
		 i is the immediate constant (in the case of an int)
		 or the position in the closure for this function,
		 relative to static_offset + funs_in_closure
	         in the case of a real or string
	         tag is where to go to on successful comparison *)
	      let
		val scon_reg =
		  MirTypes.GC_REG(MirTypes.new_gc_register(), MirTypes.ABSENT)
		val (regs', the_code') =
		  cg_sub(LambdaTypes.VAR(Map.lookup(Pervasives.STRINGEQ,
						    prim_to_lambda)),
			 env, closure, static_offset, start_at,
			 funs_in_closure, [])
		val app_code = case
		  do_app(regs', the_code', ONE(INT(MirTypes.GP_GC_REG fn_arg)),
			 ([], [], MirTypes.ABSENT, []), false, 0, []) of
		  (_, (app_code, [], MirTypes.ABSENT, [])) => app_code
		| _ => raise(LambdaTypes.impossible"Bad result for STRINGEQ")
	      in
		[MirTypes.STOREOP(MirTypes.LD, scon_reg,
				  MirTypes.GC_REG cl_arg',
		  MirTypes.GP_IMM_INT(static_offset + i + funs_in_closure)),
		  MirTypes.ALLOCATE(MirTypes.ALLOC, MirTypes.GC_REG fn_arg,
				    2),
		  MirTypes.STOREOP(MirTypes.ST, reg_from_gp the_reg,
				   MirTypes.GC_REG fn_arg,
				   MirTypes.GP_IMM_INT 0),
		  MirTypes.STOREOP(MirTypes.ST, scon_reg,
				   MirTypes.GC_REG fn_arg,
				   MirTypes.GP_IMM_INT 1),
		  MirTypes.COMMENT"Call external STRINGEQ"] @@
		app_code @@
		[MirTypes.TEST(MirTypes.BEQ, tag, MirTypes.GP_GC_REG fn_arg,
				MirTypes.GP_IMM_INT 1)]
	      end
	      val tags_code =
		map
		(fn (p, (t, _)) =>
		  case t of
		    LambdaTypes.SCON_TAG(scon as Ident.STRING _) =>
		      MirTypes.BLOCK(Map.lookup(start_at + p + 1, top_closure),
				     [MirTypes.VALUE scon])
		  | _ =>
		    raise(LambdaTypes.impossible"non-STRING in STRING switch"))
		(Lists.zip(tag_positions, tag_le_list))
	    in
	      ([],
	        combine(([], tags_code, MirTypes.ABSENT, []),
		  do_chained_tests(the_reg, tag1, val_le_tags_list, do_test)))
	    end)
d1697 18
a1715 3
      | (LambdaTypes.EXP_TAG _, _) :: rest =>
      (* From an exception constructor match, use tests and branches *)
	raise(LambdaTypes.not_done_yet"EXP_TAG")
d1722 2
a1723 1
	        ([], blocks1 @@ blocks2, MirTypes.PRESENT end_tag, [])))
d1726 2
a1727 1
    let val (reg, code) = #1 (cg_lvar(lvar, env, closure, 0))
d1730 3
a1732 1
      (ONE reg, (code, [], MirTypes.ABSENT, []))
d1735 1
a1735 1
      (ONE(INT(MirTypes.GP_IMM_INT i)), no_code)
d1740 2
a1741 1
	  (ONE(INT(MirTypes.GP_IMM_INT(convert_int i))), no_code)
d1752 1
a1752 1
	      MirTypes.ABSENT, []))
d1781 1
a1781 1
      val (fn_reg, fn_code) =
d1809 2
a1810 1
      (ONE(INT(gp_from_reg cl_reg)), (code, the_fn, MirTypes.ABSENT, []))
d1876 6
a1881 9
	map (fn (x, _) => send_to_given_reg(x, fn_arg)) fn_reg_code_list
      val makes_calls_list = map (fn lexp => count_real_apps lexp <> 0) le_list
      val entry_code_list =
	map
	(fn makes_calls =>
	  ([MirTypes.ENTER, MirTypes.PRESERVE_REGS,
	    MirTypes.COMMENT(if makes_calls then "Non-leaf" else "Leaf"),
	    MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG cl_arg',
			   MirTypes.GP_GC_REG cl_arg),
d1885 1
a1885 2
	  [], MirTypes.ABSENT, []))
	makes_calls_list
d1887 5
a1891 6
	map
	(fn (makes_calls, final_code) =>
	(final_code @@
	  [MirTypes.RESTORE_REGS, MirTypes.EXIT],
	  [], MirTypes.ABSENT, []))
	(Lists.zip(makes_calls_list, final_code_list))
d1894 1
a1894 1
	(fn ((entry_code, (_, fn_code)), exit_code) =>
d1896 1
a1896 2
	(Lists.zip(Lists.zip(entry_code_list, fn_reg_code_list),
		   exit_code_list))
d1909 1
a1909 1
      val (regs, (first, blocks, tag_opt, last)) =
d1913 2
a1914 1
      (regs, (code @@ first, blocks @@ fn_block_list, tag_opt, last))
d1924 2
a1925 1
      raise(LambdaTypes.impossible"cg_sub(BUILTIN)")
d1928 1
a1928 1
    val (regs, (first, blocks, tag_opt, last)) =
@


1.21
log
@Added STRING match (almost)
@
text
@d4 3
d282 11
d300 1
d657 1
d660 1
d669 2
d678 6
a683 1
	    then le
d685 1
a685 1
	      LambdaTypes.APP(LambdaTypes.VAR(Map.lookup(prim,
d687 4
a690 1
			      le')
d692 8
a699 2
	  LambdaTypes.VAR(Map.lookup(prim, prim_to_lambda))
	| subst_ext_prims le = le
d701 1
a701 2
	LambdaSub.wrap_lets(LambdaSub.apply_outermost
			    subst_ext_prims lambda_exp, bindings)
a744 3
    val tagged_binaries =
      [MirTypes.ADDV, MirTypes.SUBV, MirTypes.MULV, MirTypes.DIVV]
    val overflow_tags = list_of_tags(length tagged_binaries)
d746 9
a754 2
      Lists.zip(tagged_binaries, overflow_tags)
    fun get_overflow_tag opcode =
d757 1
a757 1
	| sub_fun((x, y) :: xs) = if opcode = x then y else sub_fun xs
d759 1
a759 1
	sub_fun binaries_and_tags
d762 6
d971 1
a971 1
				    get_overflow_tag opcode, res2,
d1115 1
a1115 1
      fun temp_external_prim prim =
d1117 4
a1120 2
	  val _ = print("Incomplete implementation of "
			^ Pervasives.print_pervasive prim)
d1122 4
a1125 1
	  do_external_prim prim
d1269 49
a1317 3
      | Pervasives.SIZE => temp_external_prim prim
      | Pervasives.CHR => temp_external_prim prim
      | Pervasives.ORD => temp_external_prim prim
d1394 1
a1394 1
				   get_overflow_tag opcode, res2,
d1856 4
a1859 3
				   MirTypes.GP_IMM_INT 0),
		  MirTypes.COMMENT"Call external STRINGEQ",
		  MirTypes.TEST(MirTypes.BEQ, tag, MirTypes.GP_GC_REG fn_arg,
d1920 5
d1988 5
@


1.20
log
@Added SWITCH on REAL and recursive function call to arbitrary member
of same recursive set.
@
text
@d4 4
d235 2
a236 2
  | is_inline Pervasives.STRINGEQ = true
  | is_inline Pervasives.STRINGNE = true
d261 2
d642 2
d1174 42
a1215 2
      | Pervasives.FLOOR => temp_external_prim prim
      | Pervasives.REAL => temp_external_prim prim
d1285 25
a1309 3
      | Pervasives.STRINGEQ => temp_external_prim prim
      | Pervasives.STRINGNE => temp_external_prim prim
      | Pervasives.INTABS => temp_external_prim prim
d1688 1
a1688 9
(*
	      val def_code = case def1 of
		LambdaTypes.ABSENT =>
		  [MirTypes.COMMENT"No default (strange for scon match)"]
	      | LambdaTypes.PRESENT _ =>
		  [MirTypes.COMMENT"Default",
		    MirTypes.TEST(MirTypes.BGT, tag1, the_reg,
				  MirTypes.GP_IMM_INT high)]
*)
d1722 46
d1779 3
a1781 2
	      ([], ([], tags_code, MirTypes.ABSENT, []));
	      raise(LambdaTypes.not_done_yet"SCON_TAG STRING")
@


1.19
log
@Removed translations from primitives to HARP
@
text
@d4 3
d513 1
a513 1
  fun cg_lvar(lvar, env, closure) =
d522 2
a523 1
	      MirTypes.GP_IMM_INT offset_in_closure)]), offset_in_closure = 0)
d532 1
a532 1
	  []), false)
d744 2
a745 1
	map (fn lv => #1 (cg_lvar(lv, env, closure))) free_list
d771 1
a771 1
			       reg_operand, MirTypes.GP_IMM_INT from)] @@
d774 1
a774 1
	  MirTypes.COMMENT"Dynamic closure elements" ::
d791 1
a791 1
	       is_same_fn, tag) =
d811 1
a811 1
	if is_same_fn then
d816 2
a817 2
				     MirTypes.TAG tag),
	    MirTypes.COMMENT("Call the function"),
d820 1
a820 1
	    MirTypes.COMMENT("And acquire result")]
d841 1
a841 1
	       static_offset, start_at, funs_in_closure, fn_tag) =
d869 1
a869 1
	       fn_tag)
d1060 1
a1060 1
		   start_at, funs_in_closure, fn_tag)
d1062 1
a1062 1
	  do_app(regs', the_code', regs, the_code, false, fn_tag)
d1245 1
a1245 1
	     closure, static_offset, start_at, funs_in_closure, fn_tag) =
d1250 1
a1250 1
	       fn_tag)
d1278 1
a1278 1
	       start_at + gc_in_arg, funs_in_closure, fn_tag)
d1284 1
a1284 1
	     funs_in_closure, fn_tag) =
d1290 1
a1290 1
      val ((fn_reg, fn_code), is_same_fn) =
d1294 6
a1299 2
	      val ((reg, code), is_same_fn) = cg_lvar(lvar, env, closure)
	      val _ = print(if is_same_fn then "Is same function" else "Isn't same function")
d1301 1
a1301 1
	      ((ONE reg, (code, [], MirTypes.ABSENT, [])), is_same_fn)
d1305 2
a1306 2
		  fn_tag),
	    false)
d1309 1
a1309 1
	       start_at + gc_objects_in_call, funs_in_closure, fn_tag)
d1311 2
a1312 1
      do_app(fn_reg, fn_code, arg_reg, arg_code, is_same_fn, fn_tag)
d1315 1
a1315 1
	   funs_in_closure, fn_tag) =
d1320 1
a1320 1
			     funs_in_closure, fn_tag))
d1339 1
a1339 1
	   start_at, funs_in_closure, fn_tag) =
d1342 1
a1342 1
				    start_at, funs_in_closure, fn_tag)
d1363 1
a1363 1
	   static_offset, start_at, funs_in_closure, fn_tag) =
d1383 1
a1383 1
	       fn_tag)
d1397 1
a1397 1
		   funs_in_closure, fn_tag)
d1457 1
a1457 1
	   start_at + le_offset, funs_in_closure, fn_tag), MirTypes.new_tag()))
d1494 2
a1495 2
	      | ONE(REAL _) =>
		raise(LambdaTypes.not_done_yet"REAL end_code")
d1556 2
a1557 2
	      | ONE(REAL _) =>
		raise(LambdaTypes.not_done_yet"REAL end_code")
d1588 2
a1589 1
		LambdaTypes.ABSENT => [MirTypes.COMMENT"No default"]
d1610 17
a1626 1
(******************problems with code generating the constants
d1628 6
d1635 1
a1635 1
		val (fp_op, code) = get_real 
d1638 4
a1641 1
		[MirTypes.FTEST()]
d1643 10
a1652 1
*)
d1654 3
a1656 1
	      raise(LambdaTypes.not_done_yet"SCON_TAG REAL")
d1659 16
a1674 1
	    raise(LambdaTypes.not_done_yet"SCON_TAG STRING"))
d1688 2
a1689 1
    let val (reg, code) = #1 (cg_lvar(lvar, env, closure))
d1714 1
a1714 1
	   start_at, funs_in_closure, fn_tag) =
d1721 2
a1722 2
	case make_closure([tag], free, gc_objects_within, static_offset, env,
			  closure) of
d1739 1
a1739 1
	       new_closure, 0, start_at, 1, tag (*tag for this function *))
d1743 2
a1744 1
	([if makes_calls then MirTypes.ENTER else MirTypes.ENTER_NO_CALLS,
d1753 1
a1753 1
	  [(if makes_calls then MirTypes.EXIT else MirTypes.EXIT_NO_CALLS)],
d1765 1
a1765 1
	     static_offset, start_at, funs_in_closure, fn_tag) =
d1791 2
a1792 2
	make_closure(tags, free, gc_objects_within, static_offset, env,
		     closure)
d1812 1
a1812 1
	(fn ((((LambdaTypes.FN(lvar, lexp), new_closure), pos), x), tag) =>
d1816 1
a1816 1
		 new_closure, pos, start_at + pos, funs - x, tag)
a1818 1
	  Lists.zip(
d1821 1
a1821 1
		   offsets), tags))
d1828 4
a1831 3
	  ([if makes_calls then MirTypes.ENTER else MirTypes.ENTER_NO_CALLS,
	  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG cl_arg',
			 MirTypes.GP_GC_REG cl_arg),
d1841 1
a1841 1
	  [(if makes_calls then MirTypes.EXIT else MirTypes.EXIT_NO_CALLS)],
d1864 1
a1864 1
	       start_at + gc_objects_within + funs, funs, fn_tag)
d1869 1
a1869 1
	     funs_in_closure, fn_tag) =
d1872 1
a1872 1
	     start_at, funs_in_closure, fn_tag) =
d1875 1
a1875 1
	     funs_in_closure, fn_tag) =
d1881 1
a1881 1
	     Mir_Env.empty_closure_env, 0, 0, 1, hd clos_range)
d1909 4
a1912 4
    MirTypes.CODE(MirTypes.BLOCK(loc_fn_tag,
				 [MirTypes.FN_CALL(new_tag, refs_tag)]) ::
		  MirTypes.BLOCK(new_tag, first) :: block @@ blocks @@
		  [MirTypes.BLOCK refs])
@


1.18
log
@Added floating point ops, and reorganised cg_result to allow for
fp results
@
text
@d4 4
d431 24
d481 1
a481 2
		 val new_reg' =
		   MirTypes.GC_REG(MirTypes.new_gc_register(), MirTypes.ABSENT)
d483 4
a486 6
		 [MirTypes.ALLOCATE(MirTypes.ALLOC_REAL, new_reg', 0),
		   MirTypes.STOREFPOP(MirTypes.FST, fp_op, new_reg',
				      MirTypes.GP_IMM_INT 0),
		   MirTypes.STOREOP(MirTypes.ST, new_reg',
				    MirTypes.GC_REG(new_reg, MirTypes.ABSENT),
				    imm)]
d589 1
a589 3
	| REAL fp_op =>
	    [MirTypes.STOREFPOP(MirTypes.FST, fp_op, MirTypes.GC_REG gc_reg,
				MirTypes.GP_IMM_INT 0)])
d605 2
a606 2
	 let val new_reg =
	   (MirTypes.new_gc_register(), MirTypes.ABSENT)
d608 1
a608 5
	   (MirTypes.GP_GC_REG new_reg,
	     [MirTypes.ALLOCATE(MirTypes.ALLOC_REAL, MirTypes.GC_REG new_reg,
				0),
	       MirTypes.STOREFPOP(MirTypes.FST, fp_op, MirTypes.GC_REG new_reg,
				  MirTypes.GP_IMM_INT 0)])
a921 16
(*
      fun unary_calc opcode =
	let
	  val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
	  val res1 = MirTypes.GP_GC_REG result
	  val res2 = MirTypes.GC_REG result
	in
	  case regs of
	    ONE reg =>
	      (ONE res1, combine(the_code,
		([(MirTypes.UNARY(opcode, res2, reg))], [],
		  MirTypes.ABSENT, [])))
	  | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 1)")
	end
*)

d924 2
a925 2
	  val result = (MirTypes.new_fp_register(), MirTypes.ABSENT)
	  val res = MirTypes.FP_REG result
d950 7
a956 1
	    | LIST[REAL reg1, REAL reg2] => (regs, [])
d961 1
a961 1
	      (ONE(REAL res), combine(the_code,
d963 1
a963 1
		  [(MirTypes.BINARYFP(opcode, res, val1, val2))],
a967 3
      fun unary_fnegate opcode =
	raise(LambdaTypes.not_done_yet"cg_sub(BUILTIN 2)")

d970 2
a971 2
	  val result = (MirTypes.new_fp_register(), MirTypes.ABSENT)
	  val res = MirTypes.FP_REG result
d973 1
a973 1
	  (ONE(REAL res),
d977 2
a978 1
		  [MirTypes.STOREFPOP(MirTypes.FLD, res, MirTypes.GC_REG reg,
d980 1
a980 1
		    MirTypes.UNARYFP(opcode, res, res)]
d982 1
a982 1
		    [MirTypes.UNARYFP(opcode, res, reg)]
d987 2
a988 1
      fun do_test prim =
a989 2
	  val test =
	    Mir_Env.lookup_prim_test(prim, Mir_Env.initial_prim_test_env)
a990 4
	  val (sense, is_fp) =
	    case test of
	      Mir_Env.ITEST _ => (false, false)
	    | Mir_Env.FTEST(_, sense) => (sense, true)
d993 17
a1009 23
	  if is_fp
	    then
	      raise(LambdaTypes.not_done_yet"cg_sub(BUILTIN 3(FP))")
	  else
	    let
	      val (LIST[INT val1, INT val2], new_code) = case regs of
		ONE(INT reg) => destruct_2_tuple reg
	      | LIST[INT reg1, INT reg2] => (regs, [])
	      | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 0)")
	      val branch = case test of
		Mir_Env.ITEST branch => branch
	      | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 0)")
	    in
	      (ONE(INT(MirTypes.GP_GC_REG res_reg)),
	        combine(the_code, (new_code @@
		  [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
				  MirTypes.GP_IMM_INT 0),
		    MirTypes.TEST(branch, tag, val1, val2),
		    MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
				   MirTypes.GP_IMM_INT 1),
		    MirTypes.BRANCH(MirTypes.BRA, tag)],
		  [], MirTypes.PRESENT tag, [])))
	    end
d1012 38
d1218 1
a1218 1
      | Pervasives.REALUMINUS => unary_fnegate MirTypes.FSUB
d1220 12
a1231 12
      | Pervasives.INTLESS => do_test prim
      | Pervasives.REALLESS => do_test prim
      | Pervasives.INTGREATER => do_test prim
      | Pervasives.REALGREATER => do_test prim
      | Pervasives.INTLESSEQ => do_test prim
      | Pervasives.REALLESSEQ => do_test prim
      | Pervasives.INTGREATEREQ => do_test prim
      | Pervasives.REALGREATEREQ => do_test prim
      | Pervasives.INTEQ => do_test prim
      | Pervasives.INTNE => do_test prim
      | Pervasives.REALEQ => do_test prim
      | Pervasives.REALNE => do_test prim
d1336 1
a1336 1
	ONE(INT reg) =>
a1338 1
	    val reg = reg_from_gp reg
d1341 2
a1342 1
	      ([MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg, reg,
d1348 1
d1355 1
d1371 3
a1373 3
      val (regs, the_code as (first, blocks, tag_opt, last)) =
      cg_sub(lexp, env, closure, static_offset, start_at, funs_in_closure,
	     fn_tag)
a1377 1
      val end_fp_reg = (MirTypes.new_fp_register(), MirTypes.ABSENT)
d1379 1
d1392 1
a1392 3
	    | ONE(REAL reg) =>
		[MirTypes.UNARYFP(MirTypes.FMOVE, MirTypes.FP_REG end_fp_reg,
				  reg)]
d1409 2
d1422 2
d1429 3
a1431 1
	    ONE(INT reg) => (reg, [])
d1449 2
d1500 1
d1506 2
d1598 13
a1610 1
	    raise(LambdaTypes.not_done_yet"SCON_TAG REAL")
d1635 5
a1639 3
	Ident.INT i => (ONE(INT(MirTypes.GP_IMM_INT(convert_int i))), no_code)
      | Ident.STRING s =>
	let val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1646 4
a1649 4
	     [MirTypes.BLOCK(new_tag, [MirTypes.VALUE scon])],
	     MirTypes.ABSENT, []))
	end
      | Ident.REAL r => raise(LambdaTypes.not_done_yet"cg_sub(real)"))
a1812 3
(*
    | cg_sub _ = raise(LambdaTypes.not_done_yet"cg_sub")
*)
d1819 1
d1822 7
a1828 1
    | LIST sub_regs =>
d1834 1
@


1.17
log
@Added code for ref, !, :=
@
text
@d4 3
a228 7

(*
    Mir_Env.is_prim_calc(prim, Mir_Env.initial_prim_calc_env)
    orelse
    Mir_Env.is_prim_test(prim, Mir_Env.initial_prim_test_env)
*)

d424 3
d436 3
a438 2
      ([], map (fn (MirTypes.GP_GC_REG reg, imm) =>
	[MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG reg,
d440 23
a462 10
	     | (MirTypes.GP_NON_GC_REG reg, imm) =>
	[MirTypes.STOREOP(MirTypes.ST, MirTypes.NON_GC_REG reg,
	  MirTypes.GC_REG(new_reg, MirTypes.ABSENT), imm)]
	     | (i as MirTypes.GP_IMM_INT _, imm) =>
	 let val new_reg' = (MirTypes.new_gc_register(), MirTypes.ABSENT)
	 in
	   [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg', i),
	     MirTypes.STOREOP(MirTypes.ST, MirTypes.GC_REG new_reg',
	     MirTypes.GC_REG(new_reg, MirTypes.ABSENT), imm)]
	 end
d482 2
a483 2
    ONE of MirTypes.gp_operand |
    LIST of MirTypes.gp_operand list
d491 1
a491 1
	((MirTypes.GP_GC_REG new_reg,
d497 7
a503 1
      ((gp_from_reg(Mir_Env.lookup_lambda(lvar, env)), []), false)
d511 2
a512 1
    let val reg1 = MirTypes.new_gc_register()
d515 2
a516 2
      (LIST[MirTypes.GP_GC_REG(reg1, MirTypes.ABSENT),
	MirTypes.GP_GC_REG(reg2, MirTypes.ABSENT)],
d555 3
a557 3
	  MirTypes.GP_IMM_INT i =>
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG gc_reg, reg)]
	| MirTypes.GP_IMM_ANY _ =>
d559 1
a559 1
	| MirTypes.GP_GC_REG gc_reg' =>
d561 6
a566 2
	    else [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG gc_reg, reg)]
	| _ => [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG gc_reg, reg)])
d571 1
a571 1
       MirTypes.GP_IMM_INT i =>
d576 1
a576 1
	    [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg, reg)])
d578 1
a578 1
     | MirTypes.GP_IMM_ANY _ =>
d580 11
a590 1
     | _ => (reg, []))
d728 9
a736 2
	  [MirTypes.STOREOP(MirTypes.ST, reg_from_gp reg,
			    reg_operand, MirTypes.GP_IMM_INT i)])
d774 2
a775 1
	  (ONE (reg as MirTypes.GP_GC_REG _), (first, blocks, opt, last)) =>
d810 1
a810 1
      (ONE(MirTypes.GP_GC_REG res_reg),
d834 1
a834 1
	      (ONE(MirTypes.GP_GC_REG new_reg),
d846 133
a978 72
      fun do_calc prim =
	case Mir_Env.lookup_prim_calc(prim, Mir_Env.initial_prim_calc_env) of
	  (* Various opcode cases, each with case of tuple presented bound up
	   or not *)
	  MirTypes.TBCALC tagged_binary_op =>
	    let
	      val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
	      val res1 = MirTypes.GP_GC_REG result
	      val res2 = MirTypes.GC_REG result
	      val (regs, new_code) = case regs of
		ONE reg => destruct_2_tuple reg
	      | LIST[reg1, reg2] => (regs, [])
	      | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 0)")
	    in
	      case regs of
	        LIST[val1, val2] =>
		(ONE res1, combine(the_code,
		  (new_code @@
		    [(MirTypes.TBINARY(tagged_binary_op,
		      get_overflow_tag tagged_binary_op, res2, val1, val2))],
		      [], MirTypes.ABSENT, [])))
	      | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 1)")
	    end
	| MirTypes.BCALC binary_op =>
	    let val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
	      val res1 = MirTypes.GP_GC_REG result
	      val res2 = MirTypes.GC_REG result
	      val (regs, new_code) = case regs of
		ONE reg => destruct_2_tuple reg
	      | LIST[reg1, reg2] => (regs, [])
	      | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 0)")
	    in
	      case regs of
	        LIST[val1, val2] =>
		(ONE res1, combine(the_code,
		  (new_code @@
		    [(MirTypes.BINARY(binary_op, res2, val1, val2))],
		      [], MirTypes.ABSENT, [])))
	      | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 1)")
	    end
	| MirTypes.NCALC tagged_binary_op =>
	    let
	      val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
	      val res1 = MirTypes.GP_GC_REG result
	      val res2 = MirTypes.GC_REG result
	    in
	      case regs of
	        ONE reg =>
		(ONE res1, combine(the_code,
		  ([(MirTypes.TBINARY(tagged_binary_op,
		    get_overflow_tag tagged_binary_op, res2,
		    MirTypes.GP_IMM_INT 0, reg))], [],
		    MirTypes.ABSENT, [])))
	      | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 1)")
	    end
	| MirTypes.UCALC unary_op =>
	    let
	      val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
	      val res1 = MirTypes.GP_GC_REG result
	      val res2 = MirTypes.GC_REG result
	    in
	      case regs of
	        ONE reg =>
		(ONE res1, combine(the_code,
		  ([(MirTypes.UNARY(unary_op, res2, reg))], [],
		    MirTypes.ABSENT, [])))
	      | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 1)")
	    end
	| MirTypes.BFCALC binary_fp_op =>
	    raise(LambdaTypes.not_done_yet"cg_sub(BUILTIN 2)")
	| MirTypes.UFCALC unary_fp_op =>
	    raise(LambdaTypes.not_done_yet"cg_sub(BUILTIN 2)")
d996 3
a998 3
	      val (LIST[val1, val2], new_code) = case regs of
		ONE reg => destruct_2_tuple reg
	      | LIST[reg1, reg2] => (regs, [])
d1004 1
a1004 1
	      (ONE(MirTypes.GP_GC_REG res_reg),
d1042 1
a1042 1
	    (ONE(MirTypes.GP_GC_REG result),
d1052 1
a1052 1
	    LIST[MirTypes.GP_GC_REG reg, arg] =>
d1058 1
a1058 1
		(ONE(MirTypes.GP_GC_REG result),
d1072 1
a1072 1
	    ONE(MirTypes.GP_GC_REG reg) =>
d1077 1
a1077 1
		(ONE(MirTypes.GP_GC_REG result),
d1129 6
a1134 6
      | Pervasives.SQRT => temp_external_prim prim
      | Pervasives.SIN => temp_external_prim prim
      | Pervasives.COS => temp_external_prim prim
      | Pervasives.ARCTAN => temp_external_prim prim
      | Pervasives.EXP => temp_external_prim prim
      | Pervasives.LN => temp_external_prim prim
d1140 3
a1142 3
      | Pervasives.FDIV => do_calc prim
      | Pervasives.DIV => do_calc prim
      | Pervasives.MOD => do_calc prim
d1178 8
a1185 8
      | Pervasives.REALPLUS => do_calc prim
      | Pervasives.INTPLUS => do_calc prim
      | Pervasives.REALSTAR => do_calc prim
      | Pervasives.INTSTAR => do_calc prim
      | Pervasives.REALMINUS => do_calc prim
      | Pervasives.INTMINUS => do_calc prim
      | Pervasives.REALUMINUS => do_calc prim
      | Pervasives.INTUMINUS => do_calc prim
d1201 1
a1201 1
      | Pervasives.REALABS => temp_external_prim prim
d1213 5
a1217 5
	ONE reg => (case reg of
	  MirTypes.GP_GC_REG x =>
	    (MirTypes.GC_REG x, [MirTypes.COMMENT("Function argument")])
	| MirTypes.GP_NON_GC_REG x =>
	    (MirTypes.NON_GC_REG x, [MirTypes.COMMENT("Function argument")])
d1219 2
a1220 1
	  let val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d1222 4
a1225 3
	    (MirTypes.GC_REG new_reg,
	      [MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG new_reg, reg),
	        MirTypes.COMMENT("Function argument")])
d1228 2
d1233 2
a1234 2
	  (MirTypes.GC_REG(gc_reg, MirTypes.ABSENT),
	    MirTypes.COMMENT("Function argument") :: more_code)
d1285 1
a1285 1
	      (MirTypes.GP_GC_REG(reg, MirTypes.ABSENT),
d1302 1
a1302 1
	ONE reg =>
d1307 1
a1307 1
	    (ONE(MirTypes.GP_GC_REG new_reg), combine(the_code,
d1342 1
d1354 1
a1354 1
	      ONE reg =>
d1356 3
d1391 1
a1391 1
	    ONE reg => (reg, [])
d1440 1
a1440 1
	        ONE reg => [MirTypes.UNARY(MirTypes.MOVE,
d1442 2
d1499 1
a1499 1
	        ONE reg => [MirTypes.UNARY(MirTypes.MOVE,
d1501 2
d1528 3
a1530 1
	      val use_cgt = high+1-low <= 2*length val_le_tags_list
d1561 1
a1561 1
      (ONE(MirTypes.GP_GC_REG end_reg),
d1574 1
a1574 1
      (ONE(MirTypes.GP_IMM_INT i), no_code)
d1578 1
a1578 1
	Ident.INT i => (ONE(MirTypes.GP_IMM_INT(convert_int i)), no_code)
d1583 1
a1583 1
	  (ONE(MirTypes.GP_GC_REG new_reg),
d1614 3
a1616 1
	       Mir_Env.add_lambda_env((lvar, MirTypes.GC_REG arg_reg), env),
d1639 1
a1639 1
      (ONE(gp_from_reg cl_reg), (code, the_fn, MirTypes.ABSENT, []))
d1690 3
a1692 2
	  cg_sub(lexp, Mir_Env.add_lambda_env((lvar, MirTypes.GC_REG arg_reg),
					      env),
d1763 1
a1763 1
      ONE reg => (MirTypes.GP_GC_REG fn_arg, last @@
@


1.16
log
@Redid primitive application coding
@
text
@d4 3
d135 93
a227 1
  fun is_inline prim =
d231 1
d430 3
a432 1
    val alloc_op = MirTypes.ALLOCATE(MirTypes.ALLOC, new_reg, length reg_list)
d439 1
a439 1
	  MirTypes.GC_REG(new_reg, MirTypes.ABSENT), imm)]
d506 1
d516 1
a682 1
      val gc_reg = MirTypes.new_gc_register()
d684 2
a685 1
      val reg_operand = MirTypes.GC_REG(gc_reg, MirTypes.ABSENT)
d714 1
a714 1
        MirTypes.ALLOCATE(MirTypes.ALLOC, gc_reg, funs + statics + free_size) ::
a848 4
	      val (regs, new_code) = case regs of
		ONE reg => destruct_1_tuple reg
	      | LIST[reg] => (regs, [])
	      | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 0)")
d851 1
a851 1
	        LIST[reg] =>
d853 1
a853 1
		  (new_code @@ [(MirTypes.TBINARY(tagged_binary_op,
a863 4
	      val (regs, new_code) = case regs of
		ONE reg => destruct_1_tuple reg
	      | LIST[reg] => (regs, [])
	      | _ => raise(LambdaTypes.impossible"cg_sub(BUILTIN 0)")
d866 1
a866 1
	        LIST[reg] =>
d868 1
a868 1
		  (new_code @@ [(MirTypes.UNARY(unary_op, res2, reg))], [],
d933 49
a981 1
	Pervasives.REF => temp_external_prim prim
d1018 2
a1019 2
      | Pervasives.MAP => temp_external_prim prim
      | Pervasives.REV => temp_external_prim prim
d1035 2
a1036 3
      | Pervasives.EXPLODE => temp_external_prim prim
      | Pervasives.IMPLODE => temp_external_prim prim
      | Pervasives.DEREF => temp_external_prim prim
d1046 3
a1048 3
      | Pervasives.HAT => temp_external_prim prim
      | Pervasives.AT => temp_external_prim prim
      | Pervasives.NE => temp_external_prim prim
a1056 1
      | Pervasives.BECOMES => temp_external_prim prim
d1061 1
a1061 1
      | Pervasives.EQ => temp_external_prim prim
d1066 9
a1074 9
      | Pervasives.OPEN_IN => temp_external_prim prim
      | Pervasives.OPEN_OUT => temp_external_prim prim
      | Pervasives.INPUT => temp_external_prim prim
      | Pervasives.LOOKAHEAD => temp_external_prim prim
      | Pervasives.CLOSE_IN => temp_external_prim prim
      | Pervasives.END_OF_STREAM => temp_external_prim prim
      | Pervasives.OUTPUT => temp_external_prim prim
      | Pervasives.CLOSE_OUT => temp_external_prim prim
      | Pervasives.MAKE_NEW_UNQIUE => temp_external_prim prim
d1250 2
a1251 1
		  tuple_up_in_reg(many, #1 end_reg))) @@ [final_branch],
d1331 2
a1332 1
	      | LIST many => #2 (tuple_up_in_reg(many, #1 end_reg))) @@
d1388 2
a1389 1
	      | LIST many => #2 (tuple_up_in_reg(many, #1 end_reg))) @@
d1646 2
a1647 1
      let val (reg, new_code) = tuple_up_in_reg(sub_regs, #1 fn_arg)
@


1.15
log
@Changed to use pervasives
@
text
@d4 3
d685 15
a699 14
    if prim = load_string then
      case lexp of
	LambdaTypes.SCON(Ident.STRING chars) =>
	  let
	    val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
	  in
	    (ONE(MirTypes.GP_GC_REG new_reg),
	      ([MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG new_reg,
				MirTypes.GC_REG cl_arg',
				MirTypes.GP_IMM_INT(find_ext_string chars))],
	      [], MirTypes.ABSENT, []))
	  end
      | _ => raise(LambdaTypes.impossible"Bad parameter to load_string")
    else
d704 2
a705 5
    in
      if Mir_Env.is_prim_calc(prim, Mir_Env.initial_prim_calc_env) then
	let val calc_code =
	  Mir_Env.lookup_prim_calc(prim, Mir_Env.initial_prim_calc_env)
	in
d708 1
a708 2
	  case calc_code of
	    MirTypes.TBCALC tagged_binary_op =>
d727 1
a727 1
	  | MirTypes.BCALC binary_op =>
d744 1
a744 1
	  | MirTypes.NCALC tagged_binary_op =>
d763 1
a763 1
    	  | MirTypes.UCALC unary_op =>
d780 6
a785 10
	  | MirTypes.BFCALC binary_fp_op =>
	      raise(LambdaTypes.not_done_yet"cg_sub(BUILTIN 2)")
	  | MirTypes.UFCALC unary_fp_op =>
	      raise(LambdaTypes.not_done_yet"cg_sub(BUILTIN 2)")
(*
	  | _ =>
*)
	end
      else
	if Mir_Env.is_prim_test(prim, Mir_Env.initial_prim_test_env) then
d820 144
a963 13
	else
	  (* Treat it as APP(le, le') *)
	  let
	    val (regs', the_code') =
	      cg_sub(LambdaTypes.BUILTIN prim, env, closure, static_offset,
		     start_at, funs_in_closure, fn_tag)
	  in
	    do_app(regs', the_code', regs, the_code, false, fn_tag)
(*
	    raise(LambdaTypes.not_done_yet"cg_sub(BUILTIN 3)")
*)
	  end
    end
@


1.14
log
@Added optimisation for simple recursive functions to avoid reloading via
closure by use of BSR
@
text
@d4 4
d68 1
d82 1
d100 1
d125 4
d223 1
a223 1
        Map.add((y, z), x, LambdaTypes.Prim_order)
@


1.13
log
@Modified in line with later version of HARP
Added pervasives module references, plus overflow exception detection
@
text
@d4 4
d362 3
a364 1
      let val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d366 1
a366 1
	(MirTypes.GP_GC_REG new_reg,
d369 1
a369 2
	      MirTypes.GP_IMM_INT(Mir_Env.lookup_in_closure(lvar,
							    closure)))])
d372 1
a372 1
      (gp_from_reg(Mir_Env.lookup_lambda(lvar, env)), [])
d572 2
a573 1
      val cl_code_list = map (fn lv => cg_lvar(lv, env, closure)) free_list
d611 2
a612 1
	       regs', the_code' as (first', blocks', opt', last')) =
d631 22
a652 11
	[MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG cl_arg, fn_reg),
	  MirTypes.COMMENT("Set up new closure pointer"),
	  MirTypes.STOREOP(MirTypes.LD, MirTypes.GC_REG res_reg,
			   MirTypes.GC_REG cl_arg, MirTypes.GP_IMM_INT 0),
	  MirTypes.COMMENT("Get address of code"),
	  MirTypes.BRANCH_AND_LINK(MirTypes.BLR,
				   MirTypes.REG(MirTypes.GC_REG res_reg)),
	  MirTypes.COMMENT("Call the function"),
	  MirTypes.UNARY(MirTypes.MOVE, MirTypes.GC_REG res_reg,
			 MirTypes.GP_GC_REG fn_arg),
	  MirTypes.COMMENT("And acquire result")]
d661 1
a661 1
	       static_offset, start_at, funs_in_closure) =
d687 2
a688 1
	cg_sub(lexp, env, closure, static_offset, start_at, funs_in_closure)
d818 1
a818 1
		     start_at, funs_in_closure)
d820 1
a820 1
	    do_app(regs', the_code', regs, the_code)
d827 1
a827 1
	     closure, static_offset, start_at, funs_in_closure) =
d831 2
a832 1
	cg_sub(lexp2, env, closure, static_offset, start_at, funs_in_closure)
d856 1
a856 1
	       start_at + gc_in_arg, funs_in_closure)
d862 1
a862 1
	     funs_in_closure) =
d865 2
a866 2
       then evaluate the argument, then call the function
	 *)
d868 13
a880 2
      val (fn_reg, fn_code) =
	cg_sub(le1, env, closure, static_offset, start_at, funs_in_closure)
d883 1
a883 1
	       start_at + gc_objects_in_call, funs_in_closure)
d885 1
a885 1
      do_app(fn_reg, fn_code, arg_reg, arg_code)
d888 1
a888 1
	   funs_in_closure) =
d893 1
a893 1
			     funs_in_closure))
d912 1
a912 1
	   start_at, funs_in_closure) =
d915 1
a915 1
				    start_at, funs_in_closure)
d935 1
a935 1
	   static_offset, start_at, funs_in_closure) =
d953 2
a954 1
      cg_sub(lexp, env, closure, static_offset, start_at, funs_in_closure)
d967 1
a967 1
		   funs_in_closure)
d1019 1
a1019 1
	   start_at + le_offset, funs_in_closure), MirTypes.new_tag()))
d1172 2
a1173 2
    | cg_sub(LambdaTypes.VAR lvar, env, closure, _, _, _) =
    let val (reg, code) = cg_lvar(lvar, env, closure)
d1177 1
a1177 1
    | cg_sub(LambdaTypes.INT i, _, _, _, _, _) =
d1180 1
a1180 1
	     funs_in_closure) =
d1196 1
a1196 1
	   start_at, funs_in_closure) =
d1219 1
a1219 1
	       new_closure, 0, start_at, 1)
d1244 1
a1244 1
	     static_offset, start_at, funs_in_closure) =
d1291 1
a1291 1
	(fn (((LambdaTypes.FN(lvar, lexp), new_closure), pos), x) =>
d1294 1
a1294 1
		 new_closure, pos, start_at + pos, funs - x)
d1297 4
a1300 2
	  Lists.zip(Lists.zip(le_list', new_closure_list), positions),
		   offsets))
d1342 1
a1342 1
	       start_at + gc_objects_within + funs, funs)
d1346 2
a1347 2
    | cg_sub(LambdaTypes.RAISE le, env, closure,
	       static_offset, start_at, funs_in_closure) =
d1349 2
a1350 2
    | cg_sub(LambdaTypes.HANDLE(le, le'), env, closure,
	       static_offset, start_at, funs_in_closure) =
d1352 2
a1353 2
    | cg_sub(LambdaTypes.BUILTIN prim, env, closure,
	       static_offset, start_at, funs_in_closure) =
d1359 1
d1362 1
a1362 1
	     Mir_Env.empty_closure_env, 0, 0, 1)
a1374 1
    val clos_range = Map.range top_closure
@


1.12
log
@Added external references. Fixed bug in SELECT
@
text
@d4 3
d322 1
a322 1
	[MirTypes.STOREOP(MirTypes.STX, MirTypes.GC_REG reg,
d325 1
a325 1
	[MirTypes.STOREOP(MirTypes.STX, MirTypes.NON_GC_REG reg,
d330 2
a331 2
	   [MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG new_reg', i),
	     MirTypes.STOREOP(MirTypes.STX, MirTypes.GC_REG new_reg',
d361 1
a361 1
	  [MirTypes.STOREOP(MirTypes.LDX, MirTypes.GC_REG new_reg,
d380 1
a380 1
        [MirTypes.STOREOP(MirTypes.LDX,
d383 1
a383 1
	  MirTypes.STOREOP(MirTypes.LDX,
d393 1
a393 1
        [MirTypes.STOREOP(MirTypes.LDX,
d417 1
a417 1
	    [MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG gc_reg, reg)]
d422 2
a423 2
	    else [MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG gc_reg, reg)]
	| _ => [MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG gc_reg, reg)])
d433 1
a433 1
	    [MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG new_reg, reg)])
d529 13
d574 1
a574 1
	  [MirTypes.STOREOP(MirTypes.STX, reg_from_gp reg,
d583 1
a583 1
	    [MirTypes.STOREOP(MirTypes.LDX, MirTypes.GC_REG new_reg,
d585 1
a585 1
	      MirTypes.STOREOP(MirTypes.STX, MirTypes.GC_REG new_reg,
d604 38
d660 1
a660 1
	      ([MirTypes.STOREOP(MirTypes.LDX, MirTypes.GC_REG new_reg,
d678 20
a697 1
	    MirTypes.BCALC binary_op =>
d714 1
a714 1
	  | MirTypes.UCALC unary_op =>
d727 19
a749 1
(*
d751 1
d753 3
a756 1
	  | _ => raise(LambdaTypes.not_done_yet"cg_sub(BUILTIN 2)")
d761 1
a761 1
	  val (cmp_op, branch) =
d764 4
a767 1
	  val is_fp = case cmp_op of MirTypes.UFCALC _ => true | _ => false
d772 1
a772 6
	      let val the_cmp = case cmp_op of
		MirTypes.UFCALC the_cmp => the_cmp
	      | _ => raise(LambdaTypes.impossible"")
	      in
		raise(LambdaTypes.not_done_yet"cg_sub(BUILTIN 3(FP))")
	      end
a774 3
	      val the_cmp = case cmp_op of
		MirTypes.UCALC the_cmp => the_cmp
	      | _ => raise(LambdaTypes.impossible"")
d779 3
a781 13
	      val (val1, extra) = case val1 of
		MirTypes.GP_IMM_INT i =>
		let
		  val new_reg =
		    MirTypes.GC_REG(MirTypes.new_gc_register(),
				    MirTypes.ABSENT)
		in
		  (new_reg,
		    [MirTypes.UNARY(MirTypes.MOV, new_reg, val1)])
		end
	      | MirTypes.GP_IMM_ANY _ =>
		raise(LambdaTypes.impossible"Untagged int in comparison")
	      | _ => (reg_from_gp val1, [])
d784 2
a785 2
	        combine(the_code, (new_code @@ extra @@
		  [MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG res_reg,
d787 2
a788 3
		    MirTypes.UNARY(the_cmp, val1, val2),
		    MirTypes.BRANCH(branch, tag),
		    MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG res_reg,
d795 11
a805 1
	  raise(LambdaTypes.not_done_yet"cg_sub(BUILTIN 3)")
d823 1
a823 1
	      [MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG new_reg, reg),
d849 2
a850 8
	case cg_sub(le1, env, closure, static_offset, start_at,
	       funs_in_closure) of
	  (ONE (reg as MirTypes.GP_GC_REG _), (first, blocks, opt, last)) =>
	    (reg,
	      (MirTypes.COMMENT("Evaluate function to be called") :: first,
	        blocks, opt, last))
	| _ => raise(LambdaTypes.impossible"STRUCT or NON_GC as FN")
      val (arg_reg, (first, blocks, opt, last)) =
a852 18
      val arg_code =
	(MirTypes.COMMENT("Evaluate function argument") :: first,
	  blocks, opt, last)
      val extra_code = send_to_given_reg(arg_reg, fn_arg)
      val fn_reg_op = reg_from_gp fn_reg
      val res_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
      val call_code =
	[MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG cl_arg, fn_reg),
	  MirTypes.COMMENT("Set up new closure pointer"),
	  MirTypes.STOREOP(MirTypes.LDX, MirTypes.GC_REG res_reg,
			   MirTypes.GC_REG cl_arg, MirTypes.GP_IMM_INT 0),
	  MirTypes.COMMENT("Get address of code"),
	  MirTypes.BRANCH_AND_LINK(MirTypes.BLR,
				   MirTypes.REG(MirTypes.GC_REG res_reg)),
	  MirTypes.COMMENT("Call the function"),
	  MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG res_reg,
			 MirTypes.GP_GC_REG fn_arg),
	  MirTypes.COMMENT("And acquire result")]
d854 1
a854 4
      (ONE(MirTypes.GP_GC_REG res_reg),
        combine(fn_code,
		combine(arg_code,
			(extra_code @@ call_code, [], MirTypes.ABSENT, []))))
d894 1
a894 1
	      ([MirTypes.STOREOP(MirTypes.LDX, MirTypes.GC_REG new_reg, reg,
d939 1
a939 1
		[MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG end_reg, reg)]
d981 2
a982 3
	   MirTypes.UNARY(MirTypes.CMP, MirTypes.NON_GC_REG new_reg,
			  MirTypes.GP_IMM_INT 0),
	   MirTypes.BRANCH(MirTypes.BNE, tag2)]
d1020 1
a1020 1
	        ONE reg => [MirTypes.UNARY(MirTypes.MOV,
d1056 2
a1057 3
	    [MirTypes.UNARY(MirTypes.CMP, reg_from_gp the_reg,
			    MirTypes.GP_IMM_INT high),
	      MirTypes.BRANCH(MirTypes.BGT, tag1)]
d1076 1
a1076 1
	        ONE reg => [MirTypes.UNARY(MirTypes.MOV,
d1108 2
a1109 3
		    MirTypes.UNARY(MirTypes.CMP, reg_from_gp the_reg,
				   MirTypes.GP_IMM_INT high),
		    MirTypes.BRANCH(MirTypes.BGT, tag1)]
d1117 2
a1118 3
		    [MirTypes.UNARY(MirTypes.CMP, reg_from_gp reg,
				    MirTypes.GP_IMM_INT i),
		      MirTypes.BRANCH(MirTypes.BEQ, tag)]
d1156 1
a1156 1
	    ([MirTypes.STOREOP(MirTypes.LDX, MirTypes.GC_REG new_reg,
d1176 1
a1176 1
	        MirTypes.STOREOP(MirTypes.LDX, gc_reg, MirTypes.GC_REG cl_arg',
d1179 1
a1179 1
	        MirTypes.STOREOP(MirTypes.STX, gc_reg, reg,
d1191 2
a1192 3
	([(if makes_calls then MirTypes.ENTER else MirTypes.ENTER_NO_CALLS) 0
	  (* Number of locals not yet known *),
	  MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG cl_arg',
d1195 1
a1195 1
	  MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG arg_reg,
d1250 1
a1250 1
	    [MirTypes.STOREOP(MirTypes.LDX, gc_reg, MirTypes.GC_REG cl_arg',
d1253 1
a1253 1
	      MirTypes.STOREOP(MirTypes.STX, gc_reg, cl_reg,
d1273 2
a1274 3
	  ([(if makes_calls then MirTypes.ENTER else MirTypes.ENTER_NO_CALLS) 0
	  (* Number of locals not yet known *),
	  MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG cl_arg',
d1276 2
a1277 2
	  MirTypes.COMMENT"Copy closure pointer to local copy (calle save)",
	  MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG arg_reg,
d1330 1
a1330 1
		  [MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG fn_arg, reg)])
@


1.11
log
@Added code to start dealing with pervasives and external references
@
text
@d4 3
d210 1
a210 1
		      LambdaTypes.SCON(Ident.STRING".library"))) :: selects)
d511 1
a511 1
	get_string new_lambda_exp
d515 1
a515 1
      LambdaSub.number_from(Set.set_to_list ext_strings, next, fn x => x)
a714 3
(*
	  raise(LambdaTypes.not_done_yet"cg_sub(BUILTIN 3)")
*)
d828 2
a829 1
	  let val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d834 1
a834 1
		  MirTypes.GP_IMM_INT 0),
d839 2
a840 1
      | LIST many => (ONE(LambdaSub.nth(field, many)), the_code)
d1257 10
a1267 7
(*
  | RAISE of LambdaExp                (* Exceptions --- throw ... *)
  | HANDLE of (LambdaExp * LambdaExp) (*            ... and catch *)
  | BUILTIN of Primitive              (* built-in functions --
				         These functions are
				         primitive to the abstract
				         machine. *)
d1271 2
a1272 2
      cg_sub(lambda_exp, Mir_Env.empty_lambda_env, Mir_Env.empty_closure_env,
	     0, 0, 1)
d1286 3
a1288 2
    val loc_refs =
      (MirTypes.new_tag(), [MirTypes.LOC_REF clos_range])
d1293 1
a1293 1
				 [MirTypes.FN_CALL(new_tag, #1 loc_refs)]) ::
d1295 1
a1295 1
		  [MirTypes.BLOCK loc_refs])
@


1.10
log
@Added stuff to generate pervasive environment prior to code generating
general builtins
@
text
@d4 4
d52 1
d71 1
d76 2
a77 1
    LambdaSub.LambdaTypes = Environ.LambdaTypes = Primitives.LambdaTypes
d108 46
a153 1
  val (pervasive_env, bindings) =
d155 3
d160 12
d183 1
a183 1
      initial_domain
d205 3
a207 1
    (outer_lambda, LambdaTypes.BUILTIN load_string) :: selects)
d252 2
d449 4
d454 3
d460 1
a460 3
      (Map.empty_map,
        #1 (LambdaSub.number_from(list_of_tags(number_of_gc_objects+1), 0,
				  fn x => x)))
d462 61
d596 17
a612 2
    let val (regs, the_code) =
      cg_sub(lexp, env, closure, static_offset, start_at, funs_in_closure)
a1063 3
(*
		raise(LambdaTypes.not_done_yet"SWITCH(non_cgt)")
*)
@


1.9
log
@Added relational operations for integers
@
text
@d4 3
d42 1
d46 1
d48 1
d59 1
d61 1
d64 1
d70 2
a71 1
    LambdaSub.LambdaTypes
d73 4
a76 3
  sharing MirTypes.Ident = LambdaTypes.Ident = Ident
  sharing Set = LambdaSub.Set
  sharing EnvironTypes.Map = Map = Mir_Env.Map
d95 46
d487 2
a488 1
	    let val result = (MirTypes.new_gc_register(), MirTypes.ABSENT)
@


1.8
log
@Added SWITCH on ints using chained branches,
and LETRECs.
@
text
@d4 4
d76 1
a76 1
  (* The closure pointer for all functions *)
d78 4
d228 1
a228 1
	    MirTypes.GC_REG cl_arg,
d371 1
a371 1
	      MirTypes.GC_REG cl_arg, MirTypes.GP_IMM_INT from),
d394 1
a394 1
       closure is the free lambda to offsets from cl_arg environment
d399 1
a399 1
       funs_in_closure is the number of functions following cl_arg
d452 56
a507 1
	raise(LambdaTypes.not_done_yet"cg_sub(BUILTIN 3)")
a566 1
      val cl_save = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d568 1
a568 4
	[MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG cl_save,
			MirTypes.GP_GC_REG cl_arg),
	  MirTypes.COMMENT("Save existing closure pointer"),
	  MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG cl_arg, fn_reg),
a575 3
	  MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG cl_arg,
			 MirTypes.GP_GC_REG cl_save),
	  MirTypes.COMMENT("Restore current closure pointer"),
d891 1
a891 1
	      MirTypes.GC_REG cl_arg,
d910 1
a910 1
	        MirTypes.STOREOP(MirTypes.LDX, gc_reg, MirTypes.GC_REG cl_arg,
d927 3
d985 1
a985 1
	    [MirTypes.STOREOP(MirTypes.LDX, gc_reg, MirTypes.GC_REG cl_arg,
d1010 3
@


1.7
log
@Added some comments to the output Harp. Ensured that SCON_TAGs involving
strings and reals were treated as garbage collectable. Spotted leaf
(no call) procedures.
@
text
@d4 5
d13 1
a13 1
Sorted out closures and the tope level argument a bit more
d324 1
a324 1
       statics, how may static gc objects to allow for in this closure.
d504 1
d506 2
a507 1
	[MirTypes.STACKOP(MirTypes.PUSH, MirTypes.GC_REG cl_arg),
d517 2
a518 1
	  MirTypes.STACKOP(MirTypes.POP, MirTypes.GC_REG cl_arg),
d603 4
a606 2
	let val (regs, the_code) =
	  cg_sub(lexp, env, closure, static_offset, start_at, funs_in_closure)
d619 1
a619 1
	      [MirTypes.BLOCK(new_tag, first)]
d622 1
a622 1
	        MirTypes.BLOCK(tag, last)],
d690 2
a691 1
	    let val end_code = (case regs of
d738 26
a763 18
       for reals and strings. *)
	(case x of
	  Ident.INT _ =>
	let val val_le_tags_list =
	  Match_Utils.Qsort (fn ((i:int, _, _), (i', _, _)) => i < i')
	  (map (fn (LambdaTypes.SCON_TAG(Ident.INT i), code, tag) =>
	      (convert_int i, code, tag)
	    | _ => raise(LambdaTypes.impossible"Mixed tag type in switch"))
	  tagged_code)
	  val (low, high) = bounds(0, 0, val_le_tags_list)
	  val use_cgt = high+1-low <= 2*length val_le_tags_list
	  val (the_reg, extra) = send_to_reg regs
	  val def_code = case def1 of
	    LambdaTypes.ABSENT => []
	  | LambdaTypes.PRESENT _ =>
	    [MirTypes.UNARY(MirTypes.CMP, reg_from_gp the_reg,
			    MirTypes.GP_IMM_INT high),
	      MirTypes.BRANCH(MirTypes.BGT, tag1)]
d765 41
a805 4
	  if use_cgt then
	    (extra @@ def_code,
	     make_cgt(the_reg, low, high, val_le_tags_list))
	  else raise(LambdaTypes.not_done_yet"SWITCH(non_cgt)")
a806 4
	| Ident.REAL _ =>
	  raise(LambdaTypes.not_done_yet"SCON_TAG REAL")
	| Ident.STRING _ =>
	  raise(LambdaTypes.not_done_yet"SCON_TAG STRING"))
d853 2
a854 1
	      [MirTypes.STOREOP(MirTypes.LDX, gc_reg, MirTypes.GC_REG cl_arg,
d887 99
a987 2
  | LETREC of                         (* allows recursive definitions *)
    (LVar list * LambdaExp list * LambdaExp)
@


1.6
log
@Completed function definition. Added function call.
@
text
@d4 3
d77 33
d128 11
a138 1
	    LambdaTypes.EXP_TAG lexp => count_gc_objects lexp
d154 4
d297 3
a299 3
  fun gc_list_positions(_, []) = []
    | gc_list_positions(prev_total, le :: rest) =
      let val this_size = count_gc_objects le
d301 1
a301 1
	prev_total :: gc_list_positions(prev_total + this_size, rest)
d346 2
a347 1
	([], map (fn ((reg, code), i) => code @@
d363 1
d449 4
a452 2
	  MirTypes.GP_GC_REG x => (MirTypes.GC_REG x, [])
	| MirTypes.GP_NON_GC_REG x => (MirTypes.NON_GC_REG x, [])
d457 2
a458 1
	      [MirTypes.UNARY(MirTypes.MOV, MirTypes.GC_REG new_reg, reg)])
d464 2
a465 1
	  (MirTypes.GC_REG(gc_reg, MirTypes.ABSENT), more_code)
d485 4
a488 1
	  (ONE (reg as MirTypes.GP_GC_REG _), code) => (reg, code)
d490 1
a490 1
      val (arg_reg, arg_code) =
d493 3
d501 1
d503 1
d506 1
d509 1
d511 1
d513 2
a514 1
			 MirTypes.GP_GC_REG fn_arg)]
d524 1
a524 1
      val positions = gc_list_positions(0, le_list)
d532 1
a532 1
	map (fn ONE reg => (reg, [])
d536 2
a537 1
	      (MirTypes.GP_GC_REG(reg, MirTypes.ABSENT), code)
d559 3
a561 1
		  MirTypes.GP_IMM_INT 0)], [], MirTypes.ABSENT, [])))
d571 1
a571 1
	gc_list_positions(arg_size, map #2 tag_le_list)
d574 4
d591 2
a592 1
      fun get_blocks_for_defs(def, static_offset, start_at) = case def of
d602 3
a604 2
	      #2 (tuple_up_in_reg(many, #1 end_reg))) @@ [final_branch],
	      [], MirTypes.ABSENT, []))
d617 4
a620 2
	get_blocks_for_defs(def1, static_offset + arg_size + list_size,
			    start_at + arg_size + list_size)
d623 4
a626 2
			    static_offset + arg_size + list_size + def1_size,
			    start_at + arg_size + list_size + def1_size)
d628 1
a628 1
	LambdaTypes.ABSENT => []
d639 1
a639 1
	  code @@
d647 3
a649 3
	(fn ((t, x), offset) =>
	 (t, cg_sub(x, env, closure, static_offset + offset, start_at + offset,
		    funs_in_closure), MirTypes.new_tag()))
d674 2
a675 1
				full_tag_list)]
d814 1
d816 2
a817 1
	([MirTypes.ENTER 0(* Number of locals not yet known *),
d822 3
a824 1
	(final_code @@ [MirTypes.EXIT], [], MirTypes.ABSENT, [])
@


1.5
log
@Sorted out closures and the tope level argument a bit more
@
text
@d4 3
a176 39
  fun make_closure(funs, free, env, closure) =
  (* funs, how many functions this closure is for
   free, the set of free variables
   env, the old env
   closure, the old closure *)
  let
    val free_list = Set.set_to_list free
    val free_size = length free_list
    val (tags, _) =
      LambdaSub.number_from(list_of_tags funs, 0, fn x => x)
    val lambda_offset_list_list =
      map
      (fn (_, n) => #1 (LambdaSub.number_from(free_list, funs-n, fn x => x)))
      tags
    (* This produces numberings of the free variables assuming the pointer
     (cl_arg) is some distance before the first free variable, as required
     for common closures for mutually recursive functions *)
    val new_tag = MirTypes.new_tag() (* For the code of the function *)
    val gc_reg = MirTypes.new_gc_register()
    val reg_operand = MirTypes.GC_REG(gc_reg, MirTypes.ABSENT)
    val cl_code_list = map (fn lv => cg_lvar(lv, env, closure)) free_list
    val (num_cl_code, _) =
      LambdaSub.number_from(cl_code_list, funs, fn x => x)
  in
    (tags, reg_operand,
      MirTypes.ALLOCATE(MirTypes.ALLOC, gc_reg, funs + free_size) ::
      LambdaSub.reduce_left op @@
      ([], map (fn ((reg, code), i) => code @@
	    [MirTypes.STOREOP(MirTypes.STX, reg_from_gp reg,
			      reg_operand, MirTypes.GP_IMM_INT i)])
      num_cl_code),
      map
      (fn x =>
        LambdaSub.reduce_left
	(fn (x, y) => Mir_Env.add_closure_env(y, x))
	(Mir_Env.empty_closure_env, x))
      lambda_offset_list_list)
  end

d215 14
d265 61
d328 9
d419 34
a710 4
(*
      val _ = if Set.empty_setp free then print"local function"
	else print"non-local function"
*)
d712 1
d714 8
a721 5
      val (tag, reg, code, new_closure) =
	case make_closure(1, free, env, closure) of
	  ([(tag, _)], reg, code, [new_closure]) =>
	    (tag, reg, code @@
	      [MirTypes.ADR(MirTypes.LEA, gc_reg, tag),
d726 19
a744 1

d746 1
a746 2
      
      raise(LambdaTypes.not_done_yet"cg_sub FN")
a751 1
  | APP of (LambdaExp * LambdaExp)    (* function application *)
@


1.4
log
@Started on FNs. Looking at global analysis of static gc objects
@
text
@d4 3
d20 2
d34 2
d50 1
d65 6
d79 1
a79 1
      (count_gc_objects lexp, map count_gc_objects le_list)
d171 3
d183 1
a183 5
      let fun list_of_tags n =
	if n <= 0 then [] else MirTypes.new_tag() :: list_of_tags(n-1)
      in
	LambdaSub.number_from(list_of_tags funs, 0, fn x => x)
      end
d269 22
a290 2
  fun cg_sub(LambdaTypes.APP(LambdaTypes.BUILTIN prim, lexp), env, closure) =
    let val (regs, the_code) = cg_sub(lexp, env, closure)
d341 6
a346 2
  | cg_sub(LambdaTypes.APP(LambdaTypes.FN(lvar, lexp1), lexp2), env, closure) =
    let val (regs, the_code) = cg_sub(lexp2, env, closure)
d364 3
a366 1
      val (rest_regs, rest_code) = cg_sub(lexp1, env', closure)
d371 8
a378 2
  | cg_sub(LambdaTypes.STRUCT le_list, env, closure) =
    let val reg_code_list = map (fn x => cg_sub(x, env, closure)) le_list
d394 2
a395 1
  | cg_sub(LambdaTypes.SELECT(field, lexp), env, closure) =
d397 2
a398 1
      val (regs, the_code) = cg_sub(lexp, env, closure)
d413 16
a428 3
  | cg_sub(LambdaTypes.SWITCH(lexp, tag_le_list, def1, def2), env, closure) =
    let val (regs, the_code as (first, blocks, tag_opt, last)) =
      cg_sub(lexp, env, closure)
d434 1
a434 1
      fun get_blocks_for_defs def = case def of
d437 2
a438 1
	let val (regs, the_code) = cg_sub(lexp, env, closure)
d457 7
a463 2
      val (blocks1, tag1) = get_blocks_for_defs def1
      val (blocks2, tag2) = get_blocks_for_defs def2
d483 5
a487 3
      val tagged_code =
	map (fn (t, x) => (t, cg_sub(x, env, closure), MirTypes.new_tag()))
	tag_le_list
d602 1
a602 1
  | cg_sub(LambdaTypes.VAR lvar, env, closure) =
d607 7
a613 5
  | cg_sub(LambdaTypes.INT i, _, _) = (ONE(MirTypes.GP_IMM_INT i), no_code)
  | cg_sub(LambdaTypes.SCON scon, _, _) =
    (case scon of
      Ident.INT i => (ONE(MirTypes.GP_IMM_INT(convert_int i)), no_code)
    | Ident.STRING s =>
d615 1
a615 1
	  val new_tag = MirTypes.new_tag()
d618 5
a622 3
	    ([MirTypes.ADR(MirTypes.LEA,
	      MirTypes.GC_REG new_reg, new_tag),
	      MirTypes.VALUE [(new_tag, scon)]], [], MirTypes.ABSENT, []))
d624 6
a629 3
    | Ident.REAL r => raise(LambdaTypes.not_done_yet"cg_sub(real)"))
  | cg_sub(fcn as LambdaTypes.FN(lvar, lexp), env, closure) =
    let val (_, free) = LambdaSub.bounds_and_frees fcn
d632 2
d649 1
a649 1
  | cg_sub _ = raise(LambdaTypes.not_done_yet"cg_sub")
d662 26
a687 20
  fun mir_cg(lambda_exp, top_env) =
    let val new_tag = MirTypes.new_tag()
      val number_of_gc_objects = count_gc_objects lambda_exp
      val _ = print(Integer.makestring number_of_gc_objects ^ " gc objects")
      val (regs, (first, blocks, tag_opt, last)) =
	cg_sub(lambda_exp, Mir_Env.empty_lambda_env, Mir_Env.empty_closure_env)
      val (reg, last) = case regs of
	ONE reg => (reg, last)
      | LIST sub_regs =>
	let val (reg, new_code) = tuple_up sub_regs
	in
	  (MirTypes.GP_GC_REG(reg, MirTypes.ABSENT), last @@ new_code)
	end
      val last = last @@ [MirTypes.END]
      val (first, block) = case tag_opt of
	MirTypes.ABSENT => (first @@ last, [])
      | MirTypes.PRESENT tag_val => (first, [MirTypes.BLOCK(tag_val, last)])
    in
      MirTypes.CODE(MirTypes.BLOCK(new_tag, first) :: block @@ blocks)
    end
@


1.3
log
@Coded most of switch, apart from reals and strings, and sparse ints
@
text
@d4 3
d17 1
d29 1
d57 34
d142 12
a153 6
(*
  type code_list =
    (MirTypes.block list, (* Optionally some blocks (may be empty) *)
      MirTypes.tag MirTypes.Opt, (* Optionally a tag *)
        MirTypes.opcode list) (* And optionally some code (may be empty) *)
*)
d155 45
a419 1
      fun list_of(i, v) = if i <= 0 then [] else v :: list_of(i-1, v)
d535 4
a538 12
    if Mir_Env.is_in_closure(lvar, closure) then
      let val new_reg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
      in
	(ONE(MirTypes.GP_GC_REG new_reg),
	  ([MirTypes.STOREOP(MirTypes.LDX, MirTypes.GC_REG new_reg,
	    MirTypes.GC_REG cl_arg,
	      MirTypes.GP_IMM_INT(Mir_Env.lookup_in_closure(lvar,
							    closure)))],
	  [], MirTypes.ABSENT, []))
      end
    else
    (ONE(gp_from_reg(Mir_Env.lookup_lambda(lvar, env))), no_code)
d557 11
d569 1
d587 2
@


1.2
log
@Updated to deal with simple APP of FN
@
text
@d4 3
d13 1
d15 1
d24 3
a26 1
  structure Ident: IDENT
d37 1
d45 1
d47 5
d61 2
a62 2
  fun tuple_up reg_list =
  let val new_reg = MirTypes.new_gc_register()
d64 2
a65 1
    val (number_list, _) = LambdaSub.number_from(reg_list, 0, MirTypes.GP_IMM)
d74 1
a74 1
	     | (i as MirTypes.GP_IMM _, imm) =>
d80 2
a81 1
	 end)
d85 3
d103 7
d118 1
a118 1
			  MirTypes.GP_IMM 0),
d121 1
a121 1
			  MirTypes.GP_IMM 1)])
d131 1
a131 1
			  MirTypes.GP_IMM 0)])
d135 27
a161 2
  fun cg_sub(LambdaTypes.APP(LambdaTypes.BUILTIN prim, lexp), env) =
    let val (regs, code) = cg_sub(lexp, env)
d163 6
d187 4
a190 3
		(ONE res1,
		  code @@ new_code @@ [(MirTypes.BINARY(binary_op, res2,
						      val1, val2))])
d204 3
a206 2
		(ONE res1,
		  code @@ new_code @@ [(MirTypes.UNARY(unary_op, res2, reg))])
d218 2
a219 2
  | cg_sub(LambdaTypes.APP(LambdaTypes.FN(lvar, lexp1), lexp2), env) =
    let val (regs, code) = cg_sub(lexp2, env)
d224 1
a224 1
	| MirTypes.GP_IMM i =>
d229 2
a230 1
	  end)
d237 1
a237 1
      val (rest_regs, rest_code) = cg_sub(lexp1, env')
d239 2
a240 1
      (rest_regs, code @@ more_code @@ rest_code)
d242 4
a245 3
  | cg_sub(LambdaTypes.STRUCT le_list, env) =
    let val reg_code_list = map (fn x => cg_sub(x, env)) le_list
      val code = LambdaSub.reduce_left op @@ ([], map #2 reg_code_list)
d256 2
a257 1
      (LIST(map #1 new_reg_code_list), code @@ new_code)
d259 1
a259 1
  | cg_sub(LambdaTypes.SELECT(field, lexp), env) =
d261 1
a261 1
      val (regs, code) = cg_sub(lexp, env)
d269 3
a271 4
	    (ONE(MirTypes.GP_GC_REG new_reg),
	      code @@
	        [MirTypes.STOREOP(MirTypes.LDX, MirTypes.GC_REG new_reg, reg,
		  MirTypes.GP_IMM 0)])
d274 1
a274 1
      | LIST many => (ONE(LambdaSub.nth(field, many)), code)
d276 184
a459 4
  | cg_sub(LambdaTypes.VAR lvar, env) =
    (ONE(gp_from_reg(Mir_Env.lookup_lambda(lvar, env))), [])
  | cg_sub(LambdaTypes.INT i, _) = (ONE(MirTypes.GP_IMM i), [])
  | cg_sub(LambdaTypes.SCON scon, _) =
d461 1
a461 1
      Ident.INT i => (ONE(MirTypes.GP_IMM(convert_int i)), [])
d467 1
a467 1
	    [MirTypes.ADR(MirTypes.LEA,
d469 1
a469 1
	      MirTypes.VALUE [(new_tag, scon)]])
d472 7
a480 1
  | FN of (LVar * LambdaExp)          (* function definition *)
a483 6
  | SWITCH of                         (* like a case statement *)
    (LambdaExp * (Tag * LambdaExp) list * LambdaExp Opt * LambdaExp Opt)
                                      (* First default for constructor not in
				         in list, second for not a constructor
					 so we can efficiently check for
					 non-nullary constructors *)
d494 4
a497 3
      val (regs, code_list) = cg_sub(lambda_exp, Mir_Env.empty_lambda_env)
      val (reg, code_list) = case regs of
	ONE reg => (reg, code_list)
d501 1
a501 1
	  (MirTypes.GP_GC_REG(reg, MirTypes.ABSENT), code_list @@ new_code)
d503 4
d508 1
a508 1
      MirTypes.CODE[MirTypes.BLOCK(new_tag, code_list)]
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d36 1
a36 2
  fun foldleft f (e, []) = e
    | foldleft f (e, x :: xs) = foldleft f (f(e, x), xs)
d38 3
a40 6
  fun number_from([], i, _) = ([], i)
  | number_from(x :: xs, i, num_fun) =
    let val (rest, i') = number_from(xs, i+1, num_fun)
    in
      ((x, num_fun i) :: rest, i')
    end
d42 5
d52 15
a66 4
    (new_reg, alloc_op ::
      map (fn (reg, imm) =>
	MirTypes.STOREOP(MirTypes.STX, reg, MirTypes.GC_REG new_reg, imm))
      number_list)
d81 2
a82 2
    ONE of MirTypes.reg_operand |
    LIST of MirTypes.reg_operand list
d84 1
a84 1
  fun destruct_2_tuple gc_reg =
d88 4
a91 2
      (LIST[MirTypes.GC_REG reg1, MirTypes.GC_REG reg2],
        [MirTypes.STOREOP(MirTypes.LDX, MirTypes.GC_REG reg1, gc_reg,
d93 2
a94 1
	 MirTypes.STOREOP(MirTypes.LDX, MirTypes.GC_REG reg2, gc_reg,
d97 1
d99 1
a99 1
  fun destruct_1_tuple gc_reg =
d102 3
a104 2
      (LIST[MirTypes.GC_REG reg],
        [MirTypes.STOREOP(MirTypes.LDX, MirTypes.GC_REG reg, gc_reg,
d107 1
d109 2
a110 2
  fun cg_sub(LambdaTypes.APP(LambdaTypes.BUILTIN prim, lexp)) =
    let val (regs, code) = cg_sub lexp
d120 3
a122 2
	    let val result =
	      MirTypes.NON_GC_REG(MirTypes.new_non_gc_register())
d129 4
a132 6
	        LIST[reg1, reg2] =>
		(ONE result,
		  code @@ new_code @@ [(MirTypes.BINARY(binary_op, result, reg1,
		    case reg2 of
		      MirTypes.GC_REG reg => MirTypes.GP_GC_REG reg
		    | MirTypes.NON_GC_REG reg => MirTypes.GP_NON_GC_REG reg))])
d136 3
a138 2
	    let val result =
	      MirTypes.NON_GC_REG(MirTypes.new_non_gc_register())
d146 2
a147 5
		(ONE result,
		  code @@ new_code @@ [(MirTypes.UNARY(unary_op, result,
		    case reg of
		      MirTypes.GC_REG reg => MirTypes.GP_GC_REG reg
		    | MirTypes.NON_GC_REG reg => MirTypes.GP_NON_GC_REG reg))])
d159 24
a182 2
  | cg_sub(LambdaTypes.STRUCT le_list) =
    let val reg_code_list = map cg_sub le_list
d189 1
a189 1
	      (MirTypes.GC_REG reg, code)
d196 1
a196 1
  | cg_sub(LambdaTypes.SELECT(field, lexp)) =
d198 1
a198 1
      val (regs, code) = cg_sub lexp
d203 2
a204 1
	  let val new_reg = MirTypes.GC_REG(MirTypes.new_gc_register())
d206 1
a206 1
	    (ONE new_reg,
d208 1
a208 1
	        [MirTypes.STOREOP(MirTypes.LDX, new_reg, reg,
d214 4
a217 1
  | cg_sub(LambdaTypes.SCON scon) =
d219 1
a219 7
      Ident.INT i =>
	let val new_reg = MirTypes.new_non_gc_register()
	in
	  (ONE(MirTypes.NON_GC_REG new_reg),
	    [MirTypes.UNARY(MirTypes.MOV, MirTypes.NON_GC_REG new_reg,
	      MirTypes.GP_IMM(convert_int i))])
	end
d221 1
a221 1
	let val new_reg = MirTypes.new_gc_register()
d224 3
a226 2
	  (ONE(MirTypes.GC_REG new_reg),
	    [MirTypes.ADR(MirTypes.LEA, MirTypes.GC_REG new_reg, new_tag),
a231 1
    VAR of LVar                       (* variable lookup *)
a235 1
  | INT of int                        (* int as int (for tags) *)
d252 1
a252 1
      val (regs, code_list) = cg_sub lambda_exp
d258 1
a258 1
	  (MirTypes.GC_REG reg, code_list @@ new_code)
@
