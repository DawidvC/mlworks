head	1.33;
access;
symbols
	MLW_daveb_inline_1_4_99:1.33.1
	MLWorks_21c0_1999_03_25:1.33
	MLWorks_20c1_1998_08_20:1.31
	MLWorks_20c0_1998_08_04:1.31
	MLWorks_20b2c2_1998_06_19:1.31
	MLWorks_20b2_Windows_1998_06_12:1.31
	MLWorks_20b1c1_1998_05_07:1.31
	MLWorks_20b0_1998_04_07:1.31
	MLWorks_20b0_1998_03_20:1.31
	MLWorks_20m2_1998_02_16:1.31
	MLWorks_20m1_1997_10_23:1.31
	MLWorks_11r1:1.29.1.1.1.1.1
	MLWorks_workspace_97:1.31.2
	MLWorks_dt_wizard:1.31.1
	MLWorks_11c0_1997_09_09:1.29.1.1.1.1
	MLWorks_10r3:1.29.1.1.3
	MLWorks_10r2_551:1.29.1.1.2
	MLWorks_11:1.29.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.29.1.1
	MLWorks_20m0_1997_06_20:1.31
	MLWorks_1_0_r2c2_1997_06_14:1.29.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.29.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.29.1
	MLWorks_BugFix_1997_04_24:1.29
	MLWorks_1_0_r2_Win32_1997_04_11:1.29
	MLWorks_1_0_r2_Unix_1997_04_04:1.29
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.27.3.1.1
	MLWorks_gui_1996_12_18:1.27.4
	MLWorks_1_0_Win32_1996_12_17:1.27.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.27.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.27.1.1
	MLWorks_1_0_Irix_1996_11_28:1.27.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.27.2
	MLWorks_1_0_Unix_1996_11_14:1.27.1
	MLWorks_Open_Beta2_1996_10_11:1.26.3
	MLWorks_License_dev:1.26.2
	MLWorks_1_open_beta_1996_09_13:1.26.1
	MLWorks_Open_Beta_1996_08_22:1.26
	MLWorks_Beta_1996_07_02:1.26
	MLWorks_Beta_1996_06_07:1.26
	MLWorks_Beta_1996_06_06:1.26
	MLWorks_Beta_1996_06_05:1.26
	MLWorks_Beta_1996_06_03:1.26
	MLWorks_Beta_1996_05_31:1.26
	MLWorks_Beta_1996_05_30:1.26
	ML_beta_release_12/08/94:1.19
	ML_beta_release_03/08/94:1.19
	ML_revised_beta_release_25/05/94:1.17
	ML_final_beta_release_02/03/94:1.17
	mlworks-28-01-1994:1.17
	Release:1.15
	mlworks-beta-01-09-1993:1.15
	MLWorks-1-0-4-29/01/1993:1.13
	MLWorks-1-0-3-21/12/1992:1.13
	MLWorks-1-0-2-15/12/1992:1.12
	MLWorks-1-0-1-04/12/1992:1.12
	checkpoint_17_08_92:1.7;
locks; strict;
comment	@ * @;


1.33
date	99.02.02.16.01.18;	author mitchell;	state Exp;
branches
	1.33.1.1;
next	1.32;

1.32
date	98.08.27.12.32.54;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	97.05.02.16.24.33;	author jont;	state Exp;
branches
	1.31.1.1
	1.31.2.1;
next	1.30;

1.30
date	97.04.24.15.43.22;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	97.02.07.12.23.21;	author jont;	state Exp;
branches
	1.29.1.1;
next	1.28;

1.28
date	97.01.24.12.08.01;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	96.11.06.11.08.58;	author matthew;	state Exp;
branches
	1.27.1.1
	1.27.2.1
	1.27.3.1
	1.27.4.1;
next	1.26;

1.26
date	96.05.07.11.04.50;	author jont;	state Exp;
branches
	1.26.1.1
	1.26.2.1
	1.26.3.1;
next	1.25;

1.25
date	96.04.29.14.48.35;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	96.03.28.11.05.01;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	95.12.22.16.31.02;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	95.05.31.11.25.11;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	94.10.17.11.37.17;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	94.08.25.13.04.30;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	94.07.13.10.51.08;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	94.06.10.17.22.37;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	93.10.19.09.09.48;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.10.11.13.10.01;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	93.08.03.15.56.48;	author richard;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	93.05.18.14.44.02;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.12.21.16.34.37;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	92.11.03.14.00.15;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.10.02.16.57.46;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.09.22.10.00.16;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.08.26.15.21.03;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.08.21.07.21.20;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	92.06.23.14.10.06;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	92.06.19.11.26.34;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	92.06.19.09.50.27;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.06.17.10.20.41;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	92.06.11.11.56.07;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.06.09.15.58.24;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.06.04.15.01.35;	author richard;	state Exp;
branches;
next	;

1.15.1.1
date	93.08.03.15.56.48;	author jont;	state Exp;
branches;
next	;

1.26.1.1
date	96.09.13.11.14.42;	author hope;	state Exp;
branches;
next	;

1.26.2.1
date	96.10.07.16.05.05;	author hope;	state Exp;
branches;
next	;

1.26.3.1
date	96.10.17.11.23.21;	author hope;	state Exp;
branches;
next	;

1.27.1.1
date	96.11.14.12.47.40;	author hope;	state Exp;
branches
	1.27.1.1.1.1;
next	;

1.27.1.1.1.1
date	96.11.28.14.59.12;	author hope;	state Exp;
branches;
next	;

1.27.2.1
date	96.11.22.18.07.43;	author hope;	state Exp;
branches;
next	;

1.27.3.1
date	96.12.17.17.46.25;	author hope;	state Exp;
branches
	1.27.3.1.1.1;
next	;

1.27.3.1.1.1
date	97.02.24.11.36.03;	author hope;	state Exp;
branches;
next	;

1.27.4.1
date	96.12.18.09.40.24;	author hope;	state Exp;
branches;
next	;

1.29.1.1
date	97.05.12.10.32.45;	author hope;	state Exp;
branches
	1.29.1.1.1.1
	1.29.1.1.2.1
	1.29.1.1.3.1;
next	;

1.29.1.1.1.1
date	97.07.28.18.17.42;	author daveb;	state Exp;
branches
	1.29.1.1.1.1.1.1;
next	;

1.29.1.1.1.1.1.1
date	97.10.07.11.42.34;	author jkbrook;	state Exp;
branches;
next	;

1.29.1.1.2.1
date	97.09.08.17.11.13;	author daveb;	state Exp;
branches;
next	;

1.29.1.1.3.1
date	97.09.09.14.06.50;	author daveb;	state Exp;
branches;
next	;

1.31.1.1
date	97.09.10.19.21.25;	author brucem;	state Exp;
branches;
next	;

1.31.2.1
date	97.09.11.20.52.36;	author daveb;	state Exp;
branches;
next	;

1.33.1.1
date	99.04.01.17.55.45;	author daveb;	state Exp;
branches;
next	;


desc
@Register colourer functor
@


1.33
log
@[Bug #190500]
Remove redundant require statements
@
text
@(*  ==== REGISTER GRAPH COLOURER ====
 *             FUNCTOR
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  See below for details of the graph data structure.
 *  The colouring algorithm is greedy, but colours the vertex with the most
 *  edges first.
 *
 *  Revision Log
 *  ------------
 *  $Log: _registercolourer.sml,v $
 * Revision 1.32  1998/08/27  12:32:54  jont
 * [Bug #70040]
 * Modify register colourer to use stack colourer only if requested from machspec
 *
 * Revision 1.31  1997/05/02  16:24:33  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.30  1997/04/24  15:43:22  jont
 * [Bug #20007]
 * Adding reserved_but_preferencable registers
 *
 * Revision 1.29  1997/02/07  12:23:21  jont
 * [Bug #0]
 * Pass name of function to colourer so we don't try too hard on setups and functors
 * Only try to recolour where there are some bug not many spills
 * Only accept the result when all spills are removed
 * This produces an improvement of around 400 bytes in a batch.img
 *
 * Revision 1.28  1997/01/24  12:08:01  jont
 * Redoing so as to use unspill registers when sufficiently few spills
 *
 * Revision 1.27  1996/11/06  11:08:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.26  1996/05/07  11:04:50  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.25  1996/04/29  14:48:35  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.24  1996/03/28  11:05:01  matthew
 * Adding where type clause
 *
 * Revision 1.23  1995/12/22  16:31:02  jont
 * Remove references to utils/option
 *
 *  Revision 1.22  1995/05/31  11:25:11  matthew
 *  Simplification
 *
 *  Revision 1.21  1994/10/17  11:37:17  matthew
 *  Use pervasive Option.option for return values in NewMap
 *
 *  Revision 1.20  1994/08/25  13:04:30  matthew
 *  Added move preferencing mechanism (see comments).
 *
 *  Revision 1.19  1994/07/13  10:51:08  jont
 *  Change use of temporaries to be from a list
 *
 *  Revision 1.18  1994/06/10  17:22:37  jont
 *  Use improved register preference sorting
 *
 *  Revision 1.17  1993/10/19  09:09:48  matthew
 *  Added MLWorks to ExtendedArray in a couple of places
 *
 *  Revision 1.16  1993/10/11  13:10:01  jont
 *  Changed the sorting mechanism when the number of vertices is very large,
 *  all that is need is the most popular registers
 *
 *  Revision 1.15  1993/08/03  15:56:48  richard
 *  Added graph printing diagnostics.
 *
 *  Revision 1.14  1993/05/18  14:44:02  jont
 *  Removed Integer parameter
 *
 *  Revision 1.13  1992/12/21  16:34:37  daveb
 *  Chnaged references to Array to ExtendedArray, where appropriate.
 *
 *  Revision 1.12  1992/11/03  14:00:15  jont
 *  Efficiency changes to use mononewmap for registers and tags
 *
 *  Revision 1.11  1992/10/02  16:57:46  clive
 *  Change to NewMap.empty which now takes < and = functions instead of the
 *  single-function
 *
 *  Revision 1.10  1992/09/22  10:00:16  clive
 *  Got rid of some handles using tryApply and co
 *
 *  Revision 1.9  1992/08/26  15:21:03  jont
 *  Removed some redundant structures and sharing
 *
 *  Revision 1.8  1992/08/21  07:21:20  richard
 *  Changed use of Array structure due to changes in ther
 *  pervasive environment.
 *
 *  Revision 1.7  1992/06/23  14:10:06  richard
 *  Disabled unspilling -- it doesn't work properly.
 *
 *  Revision 1.6  1992/06/19  11:26:34  richard
 *  If the number of spill is not greater than the number of temporaries
 *  then the temporaries are assigned the spills.
 *
 *  Revision 1.5  1992/06/19  09:50:27  jont
 *  Added missing require integer
 *
 *  Revision 1.4  1992/06/17  10:20:41  richard
 *  Hints are no longer needed by the graphs.
 *  RegisterPack now packs registers incidentally.
 *
 *  Revision 1.3  1992/06/11  11:56:07  richard
 *  Altered the colouring priorities to generate better spill behaviour
 *  when pulling structures apart.
 *
 *  Revision 1.2  1992/06/09  15:58:24  richard
 *  Integer sets are used for adjacency rather than lists, which were
 *  getting rather long!
 *  Colours are now allocated using an ordering which is a parameter to
 *  the functor, and scattered pseudo-randomly across registers which
 *  compare equal.
 *  The colour function no longer returns a set of registers used, as this
 *  always included the preassigned registers and was therefore of little
 *  use.
 *
 *  Revision 1.1  1992/06/04  15:01:35  richard
 *  Initial revision
 *
 *)

require "../basis/__int";
require "../utils/lists";
require "../utils/crash";
require "../utils/diagnostic";
require "../utils/mutableintset";
require "../main/machspec";
require "virtualregister";
require "registercolourer";

functor RegisterColourer (structure Register   : VIRTUALREGISTER where type T = int
			  structure MachSpec   : MACHSPEC
                          structure Lists      : LISTS
                          structure Crash      : CRASH
                          structure Diagnostic : DIAGNOSTIC
                          structure IntSet     : MUTABLEINTSET
                          val instance_name    : Diagnostic.Text.T
                          val preassigned      : Register.Pack.T
                          val available        : Register.Pack.T
                          val debugging_available        : Register.Pack.T
                          val temporaries      : Register.T list
			  val corrupted_by_callee : Register.Pack.T
			  val reserved_but_preferencable : Register.Pack.T
			  val debugger_reserved_but_preferencable : Register.Pack.T
                          val allocation_equal : Register.T * Register.T -> bool
                          val allocation_order : Register.T * Register.T -> bool

                          sharing Diagnostic.Text = Register.Set.Text = IntSet.Text) : REGISTERCOLOURER =
  struct

    structure Register = Register
    structure Diagnostic = Diagnostic

    datatype ('a, 'b) union = INL of 'a | INR of 'b

    val callee_save_temporaries =
      Lists.filterp
      (fn reg => not(Register.Pack.member(corrupted_by_callee, reg)))
      temporaries

    val nr_temporaries = Lists.length temporaries
    val nr_callee_save_temporaries = Lists.length callee_save_temporaries
    val callee_save_temporary_array =
      MLWorks.Internal.Array.arrayoflist callee_save_temporaries

    val have_spills = nr_temporaries <> 0

    val have_callee_save_spills = nr_callee_save_temporaries <> 0

    val do_preferencing = true

    val do_diagnostics = false

    val N = Int.toString
    val $ = Diagnostic.Text.from_string
    val ^^ = Diagnostic.Text.concatenate
    infix ^^

    fun diagnostic (level, output_function) =
      if do_diagnostics
        then
          Diagnostic.output_text level
          (fn verbosity => $"RegisterColourer (" ^^ instance_name ^^ $"): " ^^ output_function verbosity)
      else
        ()

    fun crash message = Crash.impossible ("RegisterColourer: " ^ message)


    (*  == Sort graph vertices ==
     *
     *  This function maps a graph (array of adjacency sets) onto a list of
     *  vertices (array indices).  It is used to determine the order in
     *  which to colour the vertices.
     *
     *  At present the vertex with the largest number of uses is coloured
     *  first.  It is possible that a hybrid between this and the number of
     *  clashes should be used.
     *)

    (* Be nice to have this defined in IntSet -- it would be more efficient *)
    fun intsetforall f a =
      IntSet.reduce
      (fn (r,n) => r andalso f n)
      (true,a)

    val small_size = 32 (* This should depend on machspec later *)

    fun order_vertices (graph, uses) =
      let
	val length = MLWorks.Internal.Array.length graph
      in
	if length <= small_size*2 then
	  let
	    fun order ({vertex=_, uses=uses : int}, {vertex=_, uses=uses'}) = uses >= uses'
	    fun list (l, 0) = l
	      | list (l, n) =
		let
		  val n' = n-1
		in
		  list ({vertex=n', uses=MLWorks.Internal.Array.sub (uses, n')}::l, n')
		end
	  in
	    INL(Lists.qsort order (list ([], length)))
	  end
	else
	  (* The big list case *)
	  (* Algorithm *)
	  (* Set up an array of indirection pointers to the uses array *)
	  (* Sort this to get the largest at the start, but leave the rest *)
	  (* in a random order as we don't care about spill slot ordering *)
	  let
	    val indirections =
	      MLWorks.Internal.Array.tabulate (length, fn x => {vertex=x, uses=MLWorks.Internal.Array.sub(uses, x)})
	    fun find_smallest(result, 0) = result
	      | find_smallest(result as (best, {vertex=_, uses=value}), n) =
		let
		  val n' = n-1
		  val curr as {uses=current, ...} = MLWorks.Internal.Array.sub(indirections, n')
		in
		  find_smallest(if value > current then (n', curr) else result, n')
		end
	    val initial_smallest =
	      find_smallest((0, (MLWorks.Internal.Array.sub(indirections, 0))), small_size)

	    fun try_one_element(n, smallest as (index, value), current) =
	      if #uses current > #uses value then
		let
		  val _ = MLWorks.Internal.Array.update(indirections, index, current)
		  val _ = MLWorks.Internal.Array.update(indirections, n, value)
		(* Swap the larger value in and the smaller out *)
		in
		  find_smallest((0, MLWorks.Internal.Array.sub(indirections, 0)), small_size)
		end
	      else
		smallest

	    val _ = MLWorks.Internal.ExtendedArray.reducel_index
	      try_one_element
	      (initial_smallest, indirections)

	    (* Move all elements from from to to-1 up one place *)
	    fun shuffle(from, to) =
	      if from >= to then ()
	      else
		let
		  val to' = to-1
		in
		  (MLWorks.Internal.Array.update(indirections, to, MLWorks.Internal.Array.sub(indirections, to'));
		   shuffle(from, to'))
		end

	    (* Find index of first value at least as big as the given one *)
	    fun find(0, _:int) = 0
	      | find(m, value) =
		let
		  val m' = m-1
		  val {uses=curr, ...} = MLWorks.Internal.Array.sub(indirections, m')
		in
		  if curr >= value then m else find(m', value)
		end

	    (* a function to insert value in the correct place before n*)
	    (* Order is descending (biggest first) *)
	    fun insert(n, arg as {vertex=_, uses=value}) =
	      let
		val n' = n-1
		val {uses=prev, ...} = MLWorks.Internal.Array.sub(indirections, n')
	      in
		if prev >=  value then () (* Already in the right place *)
		else
		  let
		    val from = find(n', value) (* First place that shouldn't be moved *)
		    val _ = shuffle(from, n) (* Move those above up *)
		  in
		    MLWorks.Internal.Array.update(indirections, from, arg) (* And place in our current one*)
		  end
	      end

	    fun insert_all n =
	      if n >= small_size then () (* Only interested in first smallest_size *)
	      else
		(insert(n, MLWorks.Internal.Array.sub(indirections, n)); (* Put nth in right place *)
		 insert_all(n+1)) (* And recurse *)
	  in
	    INR(insert_all 1; (* Start at 1, because 0th is sorted (on its own) *)
			 indirections)
	  end
      end

    (*  === THE COLOURS ===
     *
     *  The colours are the real register aliases which are assigned to the
     *  virtual registers by the colouring of the graph.  The colour_order
     *  structure is an array of arrays.  Colours are taken from the first
     *  array in this array in preference to the second, and so on.  Colours
     *  are selected pseudo-randomly from each array.  (For any graph the
     *  colouring will be the same.)
     *
     *  Temporaries are registers reserved for the loading and storing of
     *  spills.  However, if the number of spills is not greater than the
     *  number of temporaries the spill slots can be assigned to the
     *  temporaries.  The colouring function does this.
     *)

   fun make_colour_info(available, reserved_but_preferencable) =
     let
       val nr_colours = Register.Pack.cardinality available
       val colours = MLWorks.Internal.Array.arrayoflist (Register.Pack.to_list available)
       val colour_order =
	 let

	   (*  == Insertion Sort Registers ==
	    *
	    *  This function sorts the available registers into a list of
	    *  lists.  The colours to use first are in the first list, and so
	    *  on.
	    *)

	   fun sort list =
	     let
	       fun insert (list, register) =
		 let
		   fun insert' [] = [[register]]
		     | insert' ((e as r::rs) :: es) =
		       (if allocation_equal (register, r)
			  then
			    (register::r::rs) :: es
			else
			  if allocation_order (register, r)
			    then
			      [register] :: e :: es
			  else
			    e :: insert' es)
		     | insert' _ = crash "insert"
		 in
		   insert' list
		 end
	     in
	       Lists.reducel insert ([], list)
	     end

	   (* Convert the list of lists into an array of arrays of colour *)
	   (* numbers. *)

	   fun convert list =
	     let
	       val length = Lists.length list
	       val new = MLWorks.Internal.Array.array (length, MLWorks.Internal.Array.array (0, 0))

	       fun colour register =
		 let
		   fun find 0 = crash "find"
		     | find n = if MLWorks.Internal.Array.sub (colours, n-1) = register then n-1 else find (n-1)
		 in
		   find nr_colours
		 end

	       fun fill (0, []) = new
		 | fill (n, e::es) =
		   (if do_diagnostics
		      then diagnostic (1, fn _ => $"Colour preference " ^^ $(N (n-1)) ^^
				       $" is " ^^ Register.Pack.to_text (Register.Pack.from_list e))
		    else ();
		      MLWorks.Internal.Array.update (new, n-1, MLWorks.Internal.Array.arrayoflist (map colour e));
		      fill (n-1, es))
		 | fill _ = crash "fill"
	     in
	       fill (length, list)
	     end
	 in
	   convert (sort (Register.Pack.to_list available))
	 end
     in
       (nr_colours, colours, colour_order, Register.Pack.cardinality available, reserved_but_preferencable)
     end

    val non_debug_colour_info = make_colour_info(available, reserved_but_preferencable)
    val debug_colour_info = make_colour_info(debugging_available, debugger_reserved_but_preferencable)

    (*  === GRAPH DATA STRUCTURE ===
     *
     *  A Graph consists of an array of adjacency sets and an array of
     *  colourings for the vertices.  The preassigned registers (such as the
     *  argument register) must be coloured so that the colouring function
     *  won't reassign them later.
     *)

    datatype Colour = COLOUR of int | SLOT of int | RESERVED of Register.T | MERGE of Register.T | UNCOLOURED

    type Graph = {nr_vertices : int,
                  graph	      : IntSet.T MLWorks.Internal.Array.array,
                  uses	      : int MLWorks.Internal.Array.array,
                  colouring   : Colour MLWorks.Internal.Array.array}

    local
      val (nr_colours,colours,colour_order, _, _) = debug_colour_info
      val map =
        let
          fun list (done, 0) = done
            | list (done, n) = list ((MLWorks.Internal.Array.sub (colours, n-1), n-1)::done, n-1)
        in
          Register.Map.tryApply (Register.Map.from_list (list ([], nr_colours)))
        end
    in
      fun debugging_preassigned_colour reg =
        case map reg of
          SOME x => COLOUR x
        |  _ => RESERVED reg
    end

    local
      val (nr_colours,colours,colour_order, _, _) = non_debug_colour_info
      val map =
        let
          fun list (done, 0) = done
            | list (done, n) = list ((MLWorks.Internal.Array.sub (colours, n-1), n-1)::done, n-1)
        in
          Register.Map.tryApply (Register.Map.from_list (list ([], nr_colours)))
        end
    in
      fun non_debugging_preassigned_colour reg =
        case map reg of
          SOME x => COLOUR x
        |  _ => RESERVED reg
    end

    fun empty(nr_registers, make_debugging_code) =
      let
        val preassigned_colour =
          if make_debugging_code then debugging_preassigned_colour
          else non_debugging_preassigned_colour
	val colouring =
	  let
	    val colouring = MLWorks.Internal.Array.array (nr_registers, UNCOLOURED)
	  in
	    Register.Pack.iterate
	    (fn reg => MLWorks.Internal.Array.update (colouring, reg, preassigned_colour reg))
	    preassigned;
	    colouring
	  end
      in
        {nr_vertices = nr_registers,
         graph = MLWorks.Internal.Array.array (nr_registers, IntSet.empty),
         uses = MLWorks.Internal.Array.array (nr_registers, 0),
	 colouring = colouring}
      end

    fun both_coloured(colouring, reg, reg') =
      case (MLWorks.Internal.Array.sub(colouring, reg),
	    MLWorks.Internal.Array.sub(colouring, reg')) of
	(COLOUR _, COLOUR _) => true
      | _ => false

    fun clash({graph, uses, colouring, ...} : Graph, defined, referenced, live) =
      (Register.Pack.iterate
       (fn reg => MLWorks.Internal.Array.update (uses, reg, MLWorks.Internal.Array.sub (uses, reg) + 1))
       referenced;

       let
	 val card = Register.Pack.cardinality defined
       in
	 if card > 0 then
	   Register.Pack.iterate
	   (fn reg =>
	    (MLWorks.Internal.Array.update (uses, reg, MLWorks.Internal.Array.sub (uses, reg) + 1);
	     Register.Pack.iterate
	     (fn reg' =>
	      (* avoid self clashes in the graph as this causes trouble later on *)
	      if reg = reg' orelse both_coloured(colouring, reg, reg')
		then ()
	      else
		(MLWorks.Internal.Array.update (graph,reg',IntSet.add' (MLWorks.Internal.Array.sub (graph, reg'),reg));
		 MLWorks.Internal.Array.update (graph,reg,IntSet.add' (MLWorks.Internal.Array.sub (graph, reg),reg'))))
	     live;
	     (* Now clash every defined register with every other one *)
	     (if card > 1 then
		Register.Pack.iterate
		(fn reg' =>
		 (* avoid self clashes in the graph as this causes trouble later on *)
		 if reg = reg' orelse both_coloured(colouring, reg, reg')
		   then ()
		 else
		   (MLWorks.Internal.Array.update (graph,reg',IntSet.add' (MLWorks.Internal.Array.sub (graph, reg'),reg));
		    MLWorks.Internal.Array.update (graph,reg,IntSet.add' (MLWorks.Internal.Array.sub (graph, reg),reg'))))
		defined
	      else
		()))
	    )
	   defined
	 else
	   ()
       end
     )

    datatype assignment = REGISTER of Register.T | SPILL of int

    (*  === COLOUR A GRAPH ===
     *
     *  The colourer works by considering the vertices in order of the
     *  number of edges they have.  The algorithm is basically:
     *
     *  For each vertex in order of nr of clashes:
     *    Clear the availability arrays.
     *    For each adjacent vertex:
     *      If the adjacent vertex is coloured or a spill slot then
     *        make the colour or slot unavailable
     *    Look for an available colour, using the colour_order.
     *    If that fails, look for an available spill slot.
     *)

    (* Preferencing:
     One of the inputs to colour is a list of pairs of registers.  Before
     the main part of the colouring algorithm, the preferencer attempts to
     ensure that each pair will be coloured the same.  If one of the pair is
     a precoloured register, then the other will be coloured the same, if
     possible.  If neither of the two registers have been coloured, they
     will be merged together, and eventually assigned the same colour
     *)

    fun copy_graph graph =
      let
	val graph' =
	  MLWorks.Internal.Array.tabulate
	  (MLWorks.Internal.Array.length graph,
	   fn i => IntSet.from_list(IntSet.to_list(MLWorks.Internal.Array.sub(graph, i))))
      in
	graph'
      end

    fun copy_colouring colouring = MLWorks.Internal.ExtendedArray.duplicate colouring

    fun colour({nr_vertices, graph, uses, colouring},preferences,make_debugging_code, name) =
      let
        val (nr_colours,colours,colour_order, _, reserved_but_preferencable) =
          if make_debugging_code then
	    debug_colour_info
	  else
	    non_debug_colour_info
        val available = MLWorks.Internal.Array.array (nr_colours, true)
        val available_spill = ref (MLWorks.Internal.Array.array (0, true))
        val nr_spills = ref 0
        val scatter = ref 0    (* Seed to scattering register assignments *)

        (* Find the real register corresponding to a merged register *)

        fun real_colour r =
          case MLWorks.Internal.Array.sub (colouring,r) of
            MERGE r' => real_colour r'
          | c => c

	fun resolve r =
	  case MLWorks.Internal.Array.sub (colouring,r) of
	    MERGE r' => resolve r'
	  | _ => r

        (* Try to colour r as c *)
        fun colour_preference (r,c) =
          let
	    (* Check that all registers clashing with r are either *)
	    (* uncoloured, or coloured to something different from c *)
	    (* If not, we can't do the merge *)
	    (* A MERGE should never happen here because merging *)
	    (* updates the clash graph *)
            val ok =
              intsetforall
              (fn r' =>
               case MLWorks.Internal.Array.sub (colouring,r') of
                 COLOUR c' => c <> c'
               | MERGE _ => crash "MERGE in colour_preference"
               | _ => true)
              (MLWorks.Internal.Array.sub (graph,r))
          in
            if ok then
	      ((* output (std_out,"Precolouring " ^ N r ^ " as " ^ N c ^ "\n"); *)
	       MLWorks.Internal.Array.update (colouring,r,COLOUR c))
            else ()
          end

	(* merge r1 and r2 together *)
	(* r2 disappears *)
	fun merge (r1,r2) =
	  if r1 = r2 orelse IntSet.member (MLWorks.Internal.Array.sub (graph,r1),r2)
	    then ()
	  (* Don't merge if they are the same *)
	  (* Or if they clash *)
	  else
	    (* merge the clash sets *)
	    (MLWorks.Internal.Array.update (graph,r1,IntSet.union' (MLWorks.Internal.Array.sub (graph,r1),MLWorks.Internal.Array.sub (graph,r2)));
	     IntSet.iterate
	     (fn r =>
	      let
		val set = MLWorks.Internal.Array.sub (graph,r)
	      in
		MLWorks.Internal.Array.update (graph,r,IntSet.add'(IntSet.remove' (set,r2),r1))
	      end)
	     (MLWorks.Internal.Array.sub (graph,r2));
	     MLWorks.Internal.Array.update (colouring,r2,MERGE r1))

        (* Attempts to do some colouring based on the moves in the program *)
        (* before the main colouring pass *)
	(* This is an aggressive coalesce *)
	(* It can produce graphs which are more difficult to colour *)
	(* One day we will try a conservative coalesce *)

        fun preference (r1,r2) =
          let
            val r1 = resolve r1
            val r2 = resolve r2
          in
	    case (MLWorks.Internal.Array.sub (colouring,r1),MLWorks.Internal.Array.sub (colouring,r2)) of
	      (COLOUR c,UNCOLOURED) => colour_preference (r2,c)
	    | (UNCOLOURED,COLOUR c) => colour_preference (r1,c)
	    | (UNCOLOURED,UNCOLOURED) => merge (r1,r2)
	    (* Allow merging with reserved registers -- *)
	    (* though they shouldn't be used for colouring *)
	    (* Have a special set which can be merged with *)
	    (* We may be able to extend this special set *)
	    | (RESERVED r1',UNCOLOURED) =>
		if Register.Pack.member(reserved_but_preferencable, r1') then
		  merge (r1',r2)
		else ()
	    | (UNCOLOURED,RESERVED r2') =>
		if Register.Pack.member(reserved_but_preferencable, r2') then
		  merge (r2',r1)
		else ()
	    | _ => ()
          end

        (* Scan the neighbours of a vertex, disallowing their colours *)
        (* and spill slots. *)

        fun neighbour vertex =
          case MLWorks.Internal.Array.sub (colouring, vertex)
            of COLOUR c => MLWorks.Internal.Array.update (available, c, false)
             | SLOT s   => MLWorks.Internal.Array.update (!available_spill, s, false)
             | MERGE r => crash (N vertex ^ " = " ^ "MERGE " ^ N r ^ " in neighbour")
             | _        => ()

        fun find_spill (spill,limit,available) =
          if spill = limit
            then (* We've run out of spills, so extend the spill array *)
              let
                val new_nr_spills = if limit = 0 then 4 else limit + limit
              in
                available_spill := MLWorks.Internal.Array.array (new_nr_spills,false);
                nr_spills := limit+1;
                SLOT limit
              end
          else
            if MLWorks.Internal.Array.sub (available, spill) then
              (if spill >= (!nr_spills) then nr_spills := spill+1 else ();
               SLOT spill)
            else
              find_spill (spill+1,limit,available)

        fun find_colour 0 =
          let
            val available = !available_spill
            val limit = MLWorks.Internal.Array.length available
          in
            find_spill (0,limit,available)
          end
          | find_colour n =
            let
              val set = MLWorks.Internal.Array.sub (colour_order, n-1)
              val length = MLWorks.Internal.Array.length set

              fun find 0 = find_colour (n-1)
                | find n =
                  let
                    val colour = MLWorks.Internal.Array.sub (set, (!scatter + n-1) mod length)
                  in
                    if MLWorks.Internal.Array.sub (available, colour) then
		      COLOUR colour
                    else
                      find (n-1)
                  end
            in
              scatter := !scatter+1;
              find length
            end

        (* Scan through the list of vertices, colouring each in turn. *)
        fun colour_one {vertex, uses} =
	  case MLWorks.Internal.Array.sub (colouring, vertex)
	     of UNCOLOURED =>
	       (MLWorks.Internal.ExtendedArray.fill (available, true);
		MLWorks.Internal.ExtendedArray.fill (!available_spill, true);
		IntSet.iterate neighbour (MLWorks.Internal.Array.sub (graph, vertex));
		MLWorks.Internal.Array.update (colouring, vertex, find_colour (MLWorks.Internal.Array.length colour_order)))
	   | _ => ()

	fun colour_all (INL x) = Lists.iterate colour_one x
	  | colour_all (INR x) = MLWorks.Internal.ExtendedArray.iterate colour_one x

(*
        val _ =
          if do_diagnostics
            then
              diagnostic (2, fn _ =>
                          let
                            fun p (text, 0) = text
                              | p (text, n) =
                                p (text ^^ $"\n" ^^ $(N (n-1)) ^^
                                   $": " ^^ $(N (MLWorks.Internal.Array.sub (uses, n-1))) ^^
                                   $"  " ^^ IntSet.to_text (MLWorks.Internal.Array.sub (graph, n-1)), n-1)
                          in
                            p ($"graph", MLWorks.Internal.Array.length graph)
                          end)
          else
            ()
*)

        val _ = if do_preferencing then Lists.iterate preference preferences else ()

	val use_order = order_vertices(graph, uses)
        val _ = colour_all use_order

        (* Use the results of colouring to assign each register to either a *)
        (* real register or a spill slot.  If the number of spill slots is *)
        (* less than the number of callee save temporary registers then the *)
	(* callee save temporaries are assigned to the slots, eliminating *)
	(* the spills. *)

	val do_unspill =
	  let
	    val nr_spills = !nr_spills
	  in
	    0 < nr_spills andalso
	    nr_spills <= nr_callee_save_temporaries
	  end

        val assign =
          let
            val assignments = MLWorks.Internal.Array.array (nr_vertices, SPILL 0)

            fun assign 0 = ()
              | assign n =
                (MLWorks.Internal.Array.update
                 (assignments, n-1,
                  case real_colour(n-1) of
		    UNCOLOURED    => crash "Colour: Unassigned registers after colouring"
		  | MERGE _ => crash "MERGE in assign"
		  | RESERVED reg  => REGISTER reg
		  | COLOUR colour => REGISTER (MLWorks.Internal.Array.sub (colours, colour))
		  | SLOT spill    => if do_unspill then REGISTER(MLWorks.Internal.Array.sub(callee_save_temporary_array, spill)) else SPILL spill);
                 assign (n-1))
          in
            assign nr_vertices;
            if do_diagnostics then
              diagnostic (2, fn _ =>
                          let
                            fun p (text, 0) = text
                              | p (text, n) =
                                p (text ^^ $"\n" ^^ $(N (n-1)) ^^ $" -> " ^^
                                   (case MLWorks.Internal.Array.sub (assignments, n-1)
                                      of REGISTER reg => Register.to_text reg
                                       | SPILL slot   => $(N slot)), n-1)
                          in
                            p ($"assignments", nr_vertices)
                          end)
            else ();
            fn reg => MLWorks.Internal.Array.sub (assignments, reg)
          end
      in
        {assign = assign,
         nr_spills = if do_unspill then 0 else !nr_spills}
      end

    fun resolve colouring =
      let
	fun res r =
	  case MLWorks.Internal.Array.sub (colouring,r) of
	    MERGE r' => res r'
	  | _ => r
      in
	res
      end

    fun find_low_degree_unassigned_node(graph, colouring, nodes_used, real_colours_available) =
      let
	val resolve = resolve colouring
	fun do_node (0, res) = res
	  | do_node (i, res) =
	  let
	    val i' = i-1
	  in
	    if resolve i' <> i' then
	      do_node(i', res) (* Merged node, ignore *)
	    else
	      case Register.Map.tryApply'(nodes_used, i') of
		SOME _ => do_node(i', res) (* Already done this node, ignore *)
	      | NONE =>
		  let
		    val set = MLWorks.Internal.ExtendedArray.sub(graph, i')
		    val degree' = IntSet.cardinality set
		  in
		    case res of
		      SOME(node, degree) =>
			if degree' < degree then
			  let
			    val res = SOME(i', degree')
			  in
			    if degree' < real_colours_available then
			      SOME(i', degree')
			    else
			      do_node(i', res) (* Try for a better one if we can *)
			  end
			else
			  do_node(i', res) (* Try for a better one if we can *)
		    | NONE =>
			let
			  val res = SOME(i', degree')
			in
			  if degree' <= real_colours_available then
			    res
			  else
			    do_node(i', res) (* Try for a better one if we can *)
			end
		  end
	  end
      in
	do_node(MLWorks.Internal.ExtendedArray.length graph, NONE)
      end

    fun assign_stack(nr_vertices, stack, info as (nr_colours, colours, colour_order, _, _),
		     colouring, graph) =
      (*
       * stack is the stack of unassigned resisters, in order
       * nr_colours is the number of real colours available
       * colours is the list of virtual names of the non-reserved machine registers
       * colouring is the assignment of the node names within the graph to
       * the names used within colours
       *)
      let
        val available = MLWorks.Internal.Array.array(nr_colours, true)
        val available_spill = ref (MLWorks.Internal.Array.array (0, true))
        val nr_spills = ref 0

        fun find_spill(spill, limit, available) =
          if spill = limit
            then (* We've run out of spills, so extend the spill array *)
              let
                val new_nr_spills =
                  if limit = 0
                    then 4
                  else limit + limit
              in
                available_spill := MLWorks.Internal.Array.array(new_nr_spills, false);
                nr_spills := limit+1;
                SLOT limit
              end
          else
            if MLWorks.Internal.Array.sub(available, spill) then
              (if spill >= (!nr_spills) then nr_spills := spill+1 else ();
               SLOT spill)
            else
              find_spill (spill+1,limit,available)

        val scatter = ref 0    (* Seed to scattering register assignments *)

        fun find_colour 0 =
	  (* No ordinary register available, so use a spill *)
          let
            val available = !available_spill
            val limit = MLWorks.Internal.Array.length available
          in
            find_spill(0, limit, available)
          end
          | find_colour n =
            let
              val set = MLWorks.Internal.Array.sub(colour_order, n-1)
              val length = MLWorks.Internal.Array.length set
              fun find 0 = find_colour(n-1)
                | find n =
                  let
                    val colour = MLWorks.Internal.Array.sub(set, (!scatter + n-1) mod length)
                  in
                    if MLWorks.Internal.Array.sub(available, colour) then
		      COLOUR colour
                    else
                      find(n-1)
                  end
            in
              scatter := !scatter+1;
              find length
            end

        fun neighbour vertex =
          case MLWorks.Internal.Array.sub(colouring, vertex) of
	    COLOUR c => MLWorks.Internal.Array.update(available, c, false)
	  | SLOT s   => MLWorks.Internal.Array.update(!available_spill, s, false)
	  | MERGE r => crash(N vertex ^ " = " ^ "MERGE " ^ N r ^ " in neighbour")
	  | _        => ()

        fun colour_one vertex =
	  case MLWorks.Internal.Array.sub(colouring, vertex) of
	    UNCOLOURED =>
	      (MLWorks.Internal.ExtendedArray.fill(available, true);
	       MLWorks.Internal.ExtendedArray.fill(!available_spill, true);
	       IntSet.iterate neighbour (MLWorks.Internal.Array.sub(graph, vertex));
	       MLWorks.Internal.Array.update(colouring, vertex, find_colour(MLWorks.Internal.Array.length colour_order)))
	  | _ => ()

	val _ = Lists.iterate colour_one stack

        fun real_colour r =
          case MLWorks.Internal.Array.sub (colouring,r) of
            MERGE r' => real_colour r'
          | c => c

        (* Use the results of colouring to assign each register to either a *)
        (* real register or a spill slot.  If the number of spill slots is *)
        (* less than the number of callee save temporary registers then the *)
	(* callee save temporaries are assigned to the slots, eliminating *)
	(* the spills. *)

	val do_unspill =
	  let
	    val nr_spills = !nr_spills
	  in
	    0 < nr_spills andalso
	    nr_spills <= nr_callee_save_temporaries
	  end

        val assign =
          let
            val assignments = MLWorks.Internal.Array.array (nr_vertices, SPILL 0)

            fun assign 0 = ()
              | assign n =
                (MLWorks.Internal.Array.update
                 (assignments, n-1,
                  case real_colour(n-1) of
		    UNCOLOURED    => crash "Stack Colour: Unassigned registers after colouring"
		  | MERGE _ => crash "MERGE in assign"
		  | RESERVED reg  => REGISTER reg
		  | COLOUR colour => REGISTER (MLWorks.Internal.Array.sub (colours, colour))
		  | SLOT spill    => if do_unspill then REGISTER(MLWorks.Internal.Array.sub(callee_save_temporary_array, spill)) else SPILL spill);
                 assign (n-1))
          in
            assign nr_vertices;
(*
            if do_diagnostics then
              diagnostic (2, fn _ =>
                          let
                            fun p (text, 0) = text
                              | p (text, n) =
                                p (text ^^ $"\n" ^^ $(N (n-1)) ^^ $" -> " ^^
                                   (case MLWorks.Internal.Array.sub (assignments, n-1)
                                      of REGISTER reg => Register.to_text reg
                                       | SPILL slot   => $(N slot)), n-1)
                          in
                            p ($"assignments", nr_vertices)
                          end)
            else ();
*)
            fn reg => MLWorks.Internal.Array.sub (assignments, reg)
          end
      in
	{assign = assign,
	 nr_spills = if do_unspill then 0 else !nr_spills}
      end

    (* Stack based colourer, version two, hopefully less time consuming *)
    (* Find the lowest degree uncoloured node from the graph *)
    (* Remember its degree then remove all its edges *)
    (* If its degree was less than colours_needed, simpy recurse *)
    (* Otherwise, recurse with colours_needed set to degree+1 *)
    (* When no further uncoloured nodes, return the stack we've made *)
    fun stack_colour'
      (nr_vertices, info, graph, uses, colouring, preferences, do_preference, real_colours_available, name, reserved_but_preferencable) =
      let
	fun resolve r =
	  case MLWorks.Internal.Array.sub(colouring,r) of
	    MERGE r' => resolve r'
	  | _ => r

	fun colour_preference(r, c) =
	  let
	    (* Check that all registers clashing with r are either *)
	    (* uncoloured, or coloured to something different from c *)
	    (* If not, we can't do the merge *)
	    (* A MERGE should never happen here because merging *)
	    (* updates the clash graph *)
	    val ok =
	      intsetforall
	      (fn r' =>
	       case MLWorks.Internal.Array.sub(colouring, r') of
		 COLOUR c' => c <> c'
	       | MERGE _ => crash "MERGE in colour_preference"
	       | _ => true)
	      (MLWorks.Internal.Array.sub(graph, r))
	  in
	    if ok then
	      (MLWorks.Internal.Array.update(colouring, r, COLOUR c))
	    else ()
	  end

	(* merge r1 and r2 together *)
	(* r2 disappears *)
	fun merge(r1, r2) =
	  if r1 = r2 orelse IntSet.member(MLWorks.Internal.Array.sub(graph, r1), r2)
	    then ()
	  else
	    (* merge the clash sets *)
	    ((*print("Merging " ^ N r2 ^ " as " ^ N r1 ^ "\n");*)
	     (* Merge on the stacking graph *)
	     MLWorks.Internal.Array.update(graph, r1, IntSet.union'(MLWorks.Internal.Array.sub(graph, r1), MLWorks.Internal.Array.sub(graph, r2)));
	     (* Now replace all clashes with r2 by clashes with r1 in the graphs *)
	     IntSet.iterate
	     (fn r =>
	      let
		val set = MLWorks.Internal.Array.sub(graph, r)
	      in
		MLWorks.Internal.Array.update(graph, r, IntSet.add'(IntSet.remove'(set, r2), r1))
	      end)
	     (MLWorks.Internal.Array.sub(graph, r2));
	     (* Finally update the colouring *)
	     MLWorks.Internal.Array.update(colouring, r2, MERGE r1))

	fun preference (r1, r2) =
	  let
	    val r1 = resolve r1
	    val r2 = resolve r2
	  in
	    case (MLWorks.Internal.Array.sub(colouring, r1), MLWorks.Internal.Array.sub(colouring, r2)) of
	      (COLOUR c, UNCOLOURED) => colour_preference(r2, c)
	    | (UNCOLOURED, COLOUR c) => colour_preference(r1, c)
	    | (UNCOLOURED, UNCOLOURED) => merge(r1, r2)
	    (* Allow merging with reserved registers -- *)
	    (* though they shouldn't be used for colouring *)
	    (* Have a special set which can be merged with *)
	    (* We may be able to extend this special set *)
	    | (RESERVED r1',UNCOLOURED) =>
		if Register.Pack.member(reserved_but_preferencable, r1') then
		  merge (r1',r2)
		else ()
	    | (UNCOLOURED,RESERVED r2') =>
		if Register.Pack.member(reserved_but_preferencable, r2') then
		  merge (r2',r1)
		else ()
	    | _ => ()
	  end

	val _ =
	  if do_preference then
	    Lists.iterate preference preferences
	  else
	    ()

	val unshrunk_graph = copy_graph graph

	fun stack_colour(stack, nodes_used) =
	  case find_low_degree_unassigned_node(graph, colouring, nodes_used, real_colours_available) of
	    NONE => stack
	  | SOME(node, degree) =>
	      (* Recurse with this node removed *)
	      (MLWorks.Internal.Array.update(graph, node, IntSet.empty);
	       MLWorks.Internal.ExtendedArray.iterate_index
	       (fn (i, set) =>
		MLWorks.Internal.Array.update(graph, i, IntSet.remove'(set, node)))
	       graph;
	       stack_colour(node :: stack, Register.Map.define(nodes_used, node, true)))

      in
	assign_stack(nr_vertices, stack_colour([], Register.Map.empty), info, colouring, unshrunk_graph)
      end

    val colour =
      fn (args as ({nr_vertices, graph, uses, colouring},
		   preferences,make_debugging_code, name)) =>
      if MachSpec.use_stack_colourer then
	let
	  val info as (_, _, _, real_colours_available, reserved_but_preferencable) =
	    if make_debugging_code then debug_colour_info else non_debug_colour_info
	  fun ignore_stack_colourer s =
	    let
	      fun is_prefix n =
		let
		  val l = size n
		in
		  size s > l andalso MLWorks.String.substring (s,0,l) = n
		end
	    in
	      is_prefix "<Setup>" orelse is_prefix "Functor "
	    end

	  val ignore = ignore_stack_colourer name
	  val (result as {nr_spills, ...}, result' as {nr_spills=nr_spills', ...}) =
	    if ignore then
	      let
		val result = colour args
	      in
		(result, result)
	      end
	    else
	      let
		val graph' = copy_graph graph
		val colouring' = copy_colouring colouring
		val result as {nr_spills, ...} = colour args

		(* Now retry using the stack colourer *)
		val result' =
		  if nr_spills = 0 orelse nr_spills > 3 then
		    (* No point if no spills, or too many, as we will ignore the result *)
		    result
		  else
		    stack_colour'
		    (nr_vertices, info, graph', uses, colouring', preferences, do_preferencing, real_colours_available, name, reserved_but_preferencable)
	      in
		(result, result')
	      end
	in
	  (* Accept stack colourer result if it gets rid of all spills *)
	  if nr_spills' = 0 then result' else result
	end
      else
	colour args
  end
@


1.33.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a14 4
 * Revision 1.33  1999/02/02  16:01:18  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.32
log
@[Bug #70040]
Modify register colourer to use stack colourer only if requested from machspec
@
text
@d15 4
a134 1
require "../basis/__string";
@


1.31
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d15 4
d136 1
d141 1
d1103 25
a1127 16
      let
(*
        val _ = diagnostic (2, fn _ =>
                            Lists.reducel (fn (text, i) => text ^^ $" " ^^ $(N i))
                            ($"Colouring order", order))
*)

        val info as (_, _, _, real_colours_available, reserved_but_preferencable) =
          if make_debugging_code then debug_colour_info else non_debug_colour_info
	val graph' = copy_graph graph
	val colouring' = copy_colouring colouring
	val result as {nr_spills, ...} = colour args

	fun ignore_stack_colourer s =
	  let
	    fun is_prefix n =
d1129 12
a1140 1
		val l = size n
d1142 1
a1142 1
		size s > l andalso MLWorks.String.substring (s,0,l) = n
d1144 6
a1149 15
	  in
	    is_prefix "<Setup>" orelse is_prefix "Functor "
	  end

	(* Now retry using the stack colourer *)
	val result' as {nr_spills=nr_spills', ...} =
	  if nr_spills = 0 orelse nr_spills > 3 orelse ignore_stack_colourer name then
	    result (* No point if no spills, or too many, as we will ignore the result *)
	  else
	    stack_colour'
	    (nr_vertices, info, graph', uses, colouring', preferences, do_preferencing, real_colours_available, name, reserved_but_preferencable)
      in
	(* Accept stack colourer result if it gets rid of all spills *)
	if nr_spills' = 0 then result' else result
      end
@


1.31.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a14 4
 * Revision 1.31  1997/05/02  16:24:33  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.31.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a14 4
 * Revision 1.31  1997/05/02  16:24:33  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.30
log
@[Bug #20007]
[Bug #20007]
Adding reserved_but_preferencable registers
@
text
@d15 4
d157 2
d227 1
a227 1
	    MLWorks.Option.INL(Lists.qsort order (list ([], length)))
d309 1
a309 1
	    MLWorks.Option.INR(insert_all 1; (* Start at 1, because 0th is sorted (on its own) *)
d431 1
a431 1
          MLWorks.Option.SOME x => COLOUR x
d447 1
a447 1
          MLWorks.Option.SOME x => COLOUR x
d717 2
a718 2
	fun colour_all (MLWorks.Option.INL x) = Lists.iterate colour_one x
	  | colour_all (MLWorks.Option.INR x) = MLWorks.Internal.ExtendedArray.iterate colour_one x
@


1.29
log
@[Bug #0]
Pass name of function to colourer so we don't try too hard on setups and functors
Only try to recolour where there are some bug not many spills
Only accept the result when all spills are removed
This produces an improvement of around 400 bytes in a batch.img
@
text
@d15 7
d142 2
d323 1
a323 1
   fun make_colour_info available =
a326 1

d392 1
a392 1
       (nr_colours, colours, colour_order, Register.Pack.cardinality available)
d395 2
a396 2
    val non_debug_colour_info = make_colour_info available
    val debug_colour_info = make_colour_info debugging_available
d414 1
a414 1
      val (nr_colours,colours,colour_order, _) = debug_colour_info
d430 1
a430 1
      val (nr_colours,colours,colour_order, _) = non_debug_colour_info
d552 1
a552 1
        val (nr_colours,colours,colour_order, _) =
d577 5
d602 2
d632 12
a643 11
	    (* This next bit doesn't work *)
	    (* Perhaps handler registers? *)
	    (* Merging with fixed registers might cause us for instance *)
	    (* to merge with sp. Not a good idea. *)
	    (* However, we might be able to split the reserved registers *)
	    (* In such a way that some merging can be done *)
	    (*
	    (* Allow merging with reserved registers -- though they shouldn't be used for colouring *)
	    | (RESERVED r1',UNCOLOURED) => merge (r1',r2)
	    | (UNCOLOURED,RESERVED r2') => merge (r2',r1)
	    *)
d844 1
a844 1
    fun assign_stack(nr_vertices, stack, info as (nr_colours, colours, colour_order, _),
d990 1
a990 1
      (nr_vertices, info, graph, uses, colouring, preferences, do_preference, real_colours_available, name) =
d999 5
d1049 12
d1098 1
a1098 1
        val info as (_, _, _, real_colours_available) =
d1122 1
a1122 1
	    (nr_vertices, info, graph', uses, colouring', preferences, do_preferencing, real_colours_available, name)
@


1.29.1.1
log
@branched from 1.29
@
text
@a14 7
 * Revision 1.29  1997/02/07  12:23:21  jont
 * [Bug #0]
 * Pass name of function to colourer so we don't try too hard on setups and functors
 * Only try to recolour where there are some bug not many spills
 * Only accept the result when all spills are removed
 * This produces an improvement of around 400 bytes in a batch.img
 *
@


1.29.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a14 3
 * Revision 1.29.1.1  1997/05/12  10:32:45  hope
 * branched from 1.29
 *
@


1.29.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a14 3
 * Revision 1.29.1.1  1997/05/12  10:32:45  hope
 * branched from 1.29
 *
@


1.29.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a14 3
 * Revision 1.29.1.1  1997/05/12  10:32:45  hope
 * branched from 1.29
 *
@


1.29.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a14 3
 * Revision 1.29.1.1.1.1  1997/07/28  18:17:42  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.28
log
@Redoing so as to use unspill registers when sufficiently few spills
@
text
@d15 3
d116 1
a157 3
    val available_without_spilling =
      Lists.reducel Register.Pack.add (available, temporaries)

d169 1
a169 1
        then 
a199 4
(*
	val _ = output(std_out, "ordering vertices for graph of length " ^ N length ^ "\n")
*)

d371 1
a371 1
		      then diagnostic (1, fn _ => $"Colour preference " ^^ $(N (n-1)) ^^ 
a388 5
    val non_debug_colour_info_without_spills =
      if have_spills then
	make_colour_info available_without_spilling
      else
	non_debug_colour_info
d403 1
a403 2
                  colouring   : Colour MLWorks.Internal.Array.array,
		  non_spill_colouring : Colour MLWorks.Internal.Array.array}
a436 16
    local
      val (nr_colours,colours,colour_order, _) = non_debug_colour_info_without_spills
      val map =
        let
          fun list (done, 0) = done
            | list (done, n) = list ((MLWorks.Internal.Array.sub (colours, n-1), n-1)::done, n-1)
        in
          Register.Map.tryApply (Register.Map.from_list (list ([], nr_colours)))
        end
    in
      fun non_debugging_preassigned_colour_without_spills reg =
        case map reg of
          MLWorks.Option.SOME x => COLOUR x
        |  _ => RESERVED reg
    end

d439 2
a440 2
        val preassigned_colour = 
          if make_debugging_code then debugging_preassigned_colour 
a450 11
	val non_spill_colouring =
	  if make_debugging_code then colouring
	  else
	    let
	      val colouring = MLWorks.Internal.Array.array (nr_registers, UNCOLOURED)
	    in
	      Register.Pack.iterate
	      (fn reg => MLWorks.Internal.Array.update (colouring, reg, non_debugging_preassigned_colour_without_spills reg))
	      preassigned;
	      colouring
	    end
d455 1
a455 2
	 colouring = colouring,
	 non_spill_colouring = non_spill_colouring}
d458 5
d464 1
a464 1
    fun clash({graph, uses, ...} : Graph, defined, referenced, live) =
d468 1
a468 1
       
d474 1
a474 1
	   (fn reg => 
d479 1
a479 1
	      if reg = reg' 
d490 1
a490 1
		 if reg = reg' 
d540 3
a542 1
    fun colour(({nr_vertices, graph, uses, colouring, non_spill_colouring},preferences,make_debugging_code),use_no_spills) =
d548 1
a548 5
	    if use_no_spills then
	      non_debug_colour_info_without_spills
	    else
	      non_debug_colour_info
	val colouring = if use_no_spills then non_spill_colouring else colouring
d601 1
a601 1
	    
d619 4
d633 1
a633 1
          
d640 2
a641 2
                
        fun find_spill (spill,limit,available) = 
d645 1
a645 4
                val new_nr_spills = 
                  if limit = 0 
                    then 4
                  else limit + limit
d657 2
a658 2
          
        fun find_colour 0 = 
d662 1
a662 1
          in 
a685 1
          
d688 1
a688 1
	     of UNCOLOURED => 
d699 1
a699 1
        val _ = 
d718 188
a905 1
        val order = order_vertices (graph, uses)
d907 1
a907 5
(*
        val _ = diagnostic (2, fn _ =>
                            Lists.reducel (fn (text, i) => text ^^ $" " ^^ $(N i))
                            ($"Colouring order", order))
*)
d909 4
a912 1
        val _ = colour_all order
a920 1
	  not use_no_spills andalso
d936 6
a941 6
                  case real_colour(n-1)
                    of UNCOLOURED    => crash "Unassigned registers after colouring"
                     | MERGE _ => crash "MERGE in assign"
                     | RESERVED reg  => REGISTER reg
                     | COLOUR colour => REGISTER (MLWorks.Internal.Array.sub (colours, colour))
                     | SLOT spill    => if do_unspill then REGISTER(MLWorks.Internal.Array.sub(callee_save_temporary_array, spill)) else SPILL spill);
d945 1
d959 1
d963 90
a1052 2
        {assign = assign,
         nr_spills = if do_unspill then 0 else !nr_spills}
d1056 2
a1057 2
      fn (args as ({nr_vertices, graph, uses, colouring, non_spill_colouring},
		   preferences,make_debugging_code)) =>
d1059 28
a1086 18
	val unshrunk_graph = copy_graph graph
	val result as {nr_spills, ...} = colour(args, false)
	val result =
	  if nr_spills > 0 andalso nr_spills <= nr_temporaries andalso
	    not make_debugging_code then
	    (* Chance of colouring without spills at all *)
	    let
	      val result' as {nr_spills, ...} =
		colour(({nr_vertices = nr_vertices,
			 graph = unshrunk_graph,
			 uses = uses,
			 colouring = non_spill_colouring,
			 non_spill_colouring = non_spill_colouring},
			preferences,
			make_debugging_code), true)
	    in
	      if nr_spills = 0 then result' else result
	    end
d1088 2
a1089 1
	    result
d1091 2
a1092 1
	result
@


1.27
log
@[Bug #1728]
__integer becomes __int
@
text
@d15 4
a112 1

d130 1
d140 17
a156 2
    (* Disable unspilling until the consequences are worked out *)
    val do_unspill = false
d321 1
a321 1
     
d323 1
a323 39
       let

        (*  == Insertion Sort Registers ==
         *
         *  This function sorts the available registers into a list of
         *  lists.  The colours to use first are in the first list, and so
         *  on.
         *)

        fun sort list =
          let
            fun insert (list, register) =
              let
                fun insert' [] = [[register]]
                  | insert' ((e as r::rs) :: es) =
                    (if allocation_equal (register, r)
                       then
                         (register::r::rs) :: es
                     else
                       if allocation_order (register, r)
                         then
                           [register] :: e :: es
                       else
                         e :: insert' es)
                  | insert' _ = crash "insert"
              in
                insert' list
              end
          in
            Lists.reducel insert ([], list)
          end

        (* Convert the list of lists into an array of arrays of colour *)
        (* numbers. *)

        fun convert list =
          let
            val length = Lists.length list
            val new = MLWorks.Internal.Array.array (length, MLWorks.Internal.Array.array (0, 0))
d325 61
a385 23
            fun colour register =
              let
                fun find 0 = crash "find"
                  | find n = if MLWorks.Internal.Array.sub (colours, n-1) = register then n-1 else find (n-1)
              in
                find nr_colours
              end

            fun fill (0, []) = new
              | fill (n, e::es) =
                (if do_diagnostics
                   then diagnostic (1, fn _ => $"Colour preference " ^^ $(N (n-1)) ^^ 
                                    $" is " ^^ Register.Pack.to_text (Register.Pack.from_list e))
                 else ();
                 MLWorks.Internal.Array.update (new, n-1, MLWorks.Internal.Array.arrayoflist (map colour e));
                 fill (n-1, es))
              | fill _ = crash "fill"
          in
            fill (length, list)
          end
      in
        convert (sort (Register.Pack.to_list available))
      end
d387 1
a387 1
       (nr_colours,colours,colour_order)
d392 5
a396 4

    val nr_temporaries = Lists.length temporaries
    val temporary_array = MLWorks.Internal.Array.arrayoflist temporaries

d411 2
a412 1
                  colouring   : Colour MLWorks.Internal.Array.array}
d415 1
a415 1
      val (nr_colours,colours,colour_order) = debug_colour_info
d431 1
a431 1
      val (nr_colours,colours,colour_order) = non_debug_colour_info
d446 17
a462 1
    fun empty (nr_registers,make_debugging_code) =
d467 20
d491 2
a492 9
         colouring =
           let
             val colouring = MLWorks.Internal.Array.array (nr_registers, UNCOLOURED)
           in
             Register.Pack.iterate
             (fn reg => MLWorks.Internal.Array.update (colouring, reg, preassigned_colour reg))
             preassigned;
             colouring
           end}
d496 1
a496 1
    fun clash ({graph, uses, ...} : Graph, defined, referenced, live) =
d501 35
a535 13
       Register.Pack.iterate
       (fn reg => 
        (MLWorks.Internal.Array.update (uses, reg, MLWorks.Internal.Array.sub (uses, reg) + 1);
         Register.Pack.iterate
         (fn reg' =>
          (* avoid self clashes in the graph as this causes trouble later on *)
          if reg = reg' 
            then ()
          else
            (MLWorks.Internal.Array.update (graph,reg',IntSet.add' (MLWorks.Internal.Array.sub (graph, reg'),reg));
             MLWorks.Internal.Array.update (graph,reg,IntSet.add' (MLWorks.Internal.Array.sub (graph, reg),reg'))))
         live))
       defined)
a538 1

d562 11
a572 1
    fun colour ({nr_vertices, graph, uses, colouring},preferences,make_debugging_code) =
d574 9
a582 2
        val (nr_colours,colours,colour_order) =
          if make_debugging_code then debug_colour_info else non_debug_colour_info
d595 4
a598 4
        fun resolve r =
          case MLWorks.Internal.Array.sub (colouring,r) of
            MERGE r' => resolve r'
          | _ => r
d612 3
a614 4
            if ok 
              then
                ((* output (std_out,"Precolouring " ^ N r ^ " as " ^ N c ^ "\n"); *)
                 MLWorks.Internal.Array.update (colouring,r,COLOUR c))
d618 18
a635 19
        (* merge r1 and r2 together *)
        (* r2 disappears *)
        fun merge (r1,r2) =
          if r1 = r2 orelse IntSet.member (MLWorks.Internal.Array.sub (graph,r1),r2)
            then ()
          else
            (* merge the clash sets *)
            ((* output (std_out,"Merging " ^ N r1 ^ " and " ^ N r2 ^ "\n"); *)
             MLWorks.Internal.Array.update (graph,r1,IntSet.union' (MLWorks.Internal.Array.sub (graph,r1),MLWorks.Internal.Array.sub (graph,r2)));
             IntSet.iterate
             (fn r =>
              let
                val set = MLWorks.Internal.Array.sub (graph,r)
              in
                MLWorks.Internal.Array.update (graph,r,IntSet.add'(IntSet.remove' (set,r2),r1))
              end)
             (MLWorks.Internal.Array.sub (graph,r2));
             MLWorks.Internal.Array.update (colouring,r2,MERGE r1))

d638 4
d647 12
a658 12
            case (MLWorks.Internal.Array.sub (colouring,r1),MLWorks.Internal.Array.sub (colouring,r2)) of
              (COLOUR c,UNCOLOURED) => colour_preference (r2,c)
            | (UNCOLOURED,COLOUR c) => colour_preference (r1,c)
            | (UNCOLOURED,UNCOLOURED) => merge (r1,r2)
            (* This next bit doesn't work *)
            (* Perhaps handler registers? *)
(*
            (* Allow merging with reserved registers -- though they shouldn't be used for colouring *)
            | (RESERVED r1',UNCOLOURED) => merge (r1',r2)
            | (UNCOLOURED,RESERVED r2') => merge (r2',r1)
*)
            | _ => ()
d709 1
a709 1
                      COLOUR colour
d732 1
d748 1
d764 12
a775 2
        (* less than the number of temporary registers then the temporaries *)
        (* are assigned to the slots, eliminating the spills. *)
a780 5
            (* Unspilling only works for certain choices of temporary register *)
            (* Specifically, they must be callee save *)

            val unspill = do_unspill andalso (!nr_spills <= nr_temporaries)

d785 1
a785 1
                  case real_colour (n-1)
d790 1
a790 1
                     | SLOT spill    => if unspill then REGISTER (MLWorks.Internal.Array.sub (temporary_array, spill)) else SPILL spill);
a792 6
            if unspill then
              (if do_diagnostics andalso !nr_spills > 0 then
                 diagnostic (1, fn _ => $"unspilling " ^^ $(N (!nr_spills)) ^^ $" spills")
               else ();
               nr_spills := 0)
            else ();
d811 1
a811 1
         nr_spills = !nr_spills}
d814 27
@


1.27.4.1
log
@branched from 1.27
@
text
@a14 4
 * Revision 1.27  1996/11/06  11:08:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.27.3.1
log
@branched from 1.27
@
text
@a14 4
 * Revision 1.27  1996/11/06  11:08:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.27.3.1.1.1
log
@branched from 1.27.3.1
@
text
@a14 3
 * Revision 1.27.3.1  1996/12/17  17:46:25  hope
 * branched from 1.27
 *
@


1.27.2.1
log
@branched from 1.27
@
text
@a14 4
 * Revision 1.27  1996/11/06  11:08:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.27.1.1
log
@branched from 1.27
@
text
@a14 4
 * Revision 1.27  1996/11/06  11:08:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.27.1.1.1.1
log
@branched from 1.27.1.1
@
text
@a14 3
 * Revision 1.27.1.1  1996/11/14  12:47:40  hope
 * branched from 1.27
 *
@


1.26
log
@Array moving to MLWorks.Array
@
text
@d15 3
d108 1
a108 1
require "../basis/__integer";
@


1.26.3.1
log
@branched from 1.26
@
text
@a14 3
 * Revision 1.26  1996/05/07  11:04:50  jont
 * Array moving to MLWorks.Array
 *
@


1.26.2.1
log
@branched from 1.26
@
text
@a14 3
 * Revision 1.26  1996/05/07  11:04:50  jont
 * Array moving to MLWorks.Array
 *
@


1.26.1.1
log
@branched from 1.26
@
text
@a14 3
 * Revision 1.26  1996/05/07  11:04:50  jont
 * Array moving to MLWorks.Array
 *
@


1.25
log
@Removing MLWorks.Integer
@
text
@d15 3
a171 13
(*
    fun order_vertices (graph, uses) =
      let
        fun list (l, 0) = l
          | list (l, n) =
            list ((n-1, Array.sub (uses, n-1))::l, n-1)

        fun order ((_, uses : int), (_, uses' : int)) = uses > uses'
      in
        map #1 (Lists.qsort order (list ([], Array.length graph)))
      end
*)

d176 1
a176 1
	val length = Array.length graph
d190 1
a190 1
		  list ({vertex=n', uses=Array.sub (uses, n')}::l, n')
d203 1
a203 1
	      Array.tabulate (length, fn x => {vertex=x, uses=Array.sub(uses, x)})
d208 1
a208 1
		  val curr as {uses=current, ...} = Array.sub(indirections, n')
d213 1
a213 1
	      find_smallest((0, (Array.sub(indirections, 0))), small_size)
d218 2
a219 2
		  val _ = Array.update(indirections, index, current)
		  val _ = Array.update(indirections, n, value)
d222 1
a222 1
		  find_smallest((0, Array.sub(indirections, 0)), small_size)
d227 1
a227 1
	    val _ = MLWorks.ExtendedArray.reducel_index
d238 1
a238 1
		  (Array.update(indirections, to, Array.sub(indirections, to'));
d247 1
a247 1
		  val {uses=curr, ...} = Array.sub(indirections, m')
d257 1
a257 1
		val {uses=prev, ...} = Array.sub(indirections, n')
d265 1
a265 1
		    Array.update(indirections, from, arg) (* And place in our current one*)
d272 1
a272 1
		(insert(n, Array.sub(indirections, n)); (* Put nth in right place *)
d298 1
a298 1
       val colours = Array.arrayoflist (Register.Pack.to_list available)
d339 1
a339 1
            val new = Array.array (length, Array.array (0, 0))
d344 1
a344 1
                  | find n = if Array.sub (colours, n-1) = register then n-1 else find (n-1)
d355 1
a355 1
                 Array.update (new, n-1, Array.arrayoflist (map colour e));
d372 1
a372 1
    val temporary_array = Array.arrayoflist temporaries
d386 3
a388 3
                  graph	      : IntSet.T Array.array,
                  uses	      : int Array.array,
                  colouring   : Colour Array.array}
d395 1
a395 1
            | list (done, n) = list ((Array.sub (colours, n-1), n-1)::done, n-1)
d411 1
a411 1
            | list (done, n) = list ((Array.sub (colours, n-1), n-1)::done, n-1)
d429 2
a430 2
         graph = Array.array (nr_registers, IntSet.empty),
         uses = Array.array (nr_registers, 0),
d433 1
a433 1
             val colouring = Array.array (nr_registers, UNCOLOURED)
d436 1
a436 1
             (fn reg => Array.update (colouring, reg, preassigned_colour reg))
d445 1
a445 1
       (fn reg => Array.update (uses, reg, Array.sub (uses, reg) + 1))
d450 1
a450 1
        (Array.update (uses, reg, Array.sub (uses, reg) + 1);
d457 2
a458 2
            (Array.update (graph,reg',IntSet.add' (Array.sub (graph, reg'),reg));
             Array.update (graph,reg,IntSet.add' (Array.sub (graph, reg),reg'))))
d492 2
a493 2
        val available = Array.array (nr_colours, true)
        val available_spill = ref (Array.array (0, true))
d500 1
a500 1
          case Array.sub (colouring,r) of
d505 1
a505 1
          case Array.sub (colouring,r) of
d515 1
a515 1
               case Array.sub (colouring,r') of
d519 1
a519 1
              (Array.sub (graph,r))
d524 1
a524 1
                 Array.update (colouring,r,COLOUR c))
d531 1
a531 1
          if r1 = r2 orelse IntSet.member (Array.sub (graph,r1),r2)
d536 1
a536 1
             Array.update (graph,r1,IntSet.union' (Array.sub (graph,r1),Array.sub (graph,r2)));
d540 1
a540 1
                val set = Array.sub (graph,r)
d542 1
a542 1
                Array.update (graph,r,IntSet.add'(IntSet.remove' (set,r2),r1))
d544 2
a545 2
             (Array.sub (graph,r2));
             Array.update (colouring,r2,MERGE r1))
d554 1
a554 1
            case (Array.sub (colouring,r1),Array.sub (colouring,r2)) of
d572 3
a574 3
          case Array.sub (colouring, vertex)
            of COLOUR c => Array.update (available, c, false)
             | SLOT s   => Array.update (!available_spill, s, false)
d587 1
a587 1
                available_spill := Array.array (new_nr_spills,false);
d592 1
a592 1
            if Array.sub (available, spill) then
d601 1
a601 1
            val limit = Array.length available
d607 2
a608 2
              val set = Array.sub (colour_order, n-1)
              val length = Array.length set
d613 1
a613 1
                    val colour = Array.sub (set, (!scatter + n-1) mod length)
d615 1
a615 1
                    if Array.sub (available, colour) then
d628 1
a628 1
	  case Array.sub (colouring, vertex)
d630 4
a633 4
	       (MLWorks.ExtendedArray.fill (available, true);
		MLWorks.ExtendedArray.fill (!available_spill, true);
		IntSet.iterate neighbour (Array.sub (graph, vertex));
		Array.update (colouring, vertex, find_colour (Array.length colour_order)))
d637 1
a637 1
	  | colour_all (MLWorks.Option.INR x) = MLWorks.ExtendedArray.iterate colour_one x
d647 2
a648 2
                                   $": " ^^ $(N (Array.sub (uses, n-1))) ^^
                                   $"  " ^^ IntSet.to_text (Array.sub (graph, n-1)), n-1)
d650 1
a650 1
                            p ($"graph", Array.length graph)
d674 1
a674 1
            val assignments = Array.array (nr_vertices, SPILL 0)
d683 1
a683 1
                (Array.update
d689 2
a690 2
                     | COLOUR colour => REGISTER (Array.sub (colours, colour))
                     | SLOT spill    => if unspill then REGISTER (Array.sub (temporary_array, spill)) else SPILL spill);
d706 1
a706 1
                                   (case Array.sub (assignments, n-1)
d713 1
a713 1
            fn reg => Array.sub (assignments, reg)
@


1.24
log
@Adding where type clause
@
text
@d15 3
d102 2
d136 1
a136 1
    val N = MLWorks.Integer.makestring
@


1.23
log
@Remove references to utils/option
@
text
@d15 3
d106 1
a106 1
functor RegisterColourer (structure Register   : VIRTUALREGISTER
a118 1
                          sharing type Register.T = int
@


1.22
log
@Simplification
@
text
@d15 3
a99 1
require "../utils/option";
a106 1
			  structure Option     : OPTION
d196 1
a196 1
	    Option.SOME1(Lists.qsort order (list ([], length)))
d278 1
a278 1
	    Option.SOME2(insert_all 1; (* Start at 1, because 0th is sorted (on its own) *)
d639 2
a640 2
	fun colour_all (Option.SOME1 x) = Lists.iterate colour_one x
	  | colour_all (Option.SOME2 x) = MLWorks.ExtendedArray.iterate colour_one x
@


1.21
log
@Use pervasive Option.option for return values in NewMap
@
text
@d15 3
d110 1
d147 1
a147 1
     *  vertices (array indeces).  It is used to determine the order in
d155 1
d297 4
a300 2
    val nr_colours = Register.Pack.cardinality available
    val colours = Array.arrayoflist (Register.Pack.to_list available)
d302 2
a303 2
    val colour_order =
      let
d366 3
d370 3
a376 1

a391 1
    (* Assign colours to the colouring registers *)
d393 1
d402 1
a402 1
      fun preassigned_colour reg =
d404 1
a404 1
           MLWorks.Option.SOME x => COLOUR x
d408 15
a422 37

    fun print p out ({nr_vertices, graph, uses, colouring} : Graph) =
      MLWorks.ExtendedArray.reducel_index
      (fn (r, out, set) =>
       let
         val out = p (out, Register.to_string r)
         val out = p (out, " -> ")
         val out = p (out,
                      let
                        fun aux r = 
                          case Array.sub (colouring, r) of
                            COLOUR c   => Register.to_string (Array.sub (colours, c))
                          | SLOT s     => N s
                          | RESERVED r' => Register.to_string r'
                          | MERGE r' => aux r'
                          | UNCOLOURED => "?"
                      in
                        aux r
                      end)
         val out = p (out, ", ")
         val out = p (out, N (Array.sub (uses, r)))
         val out = p (out, ":")
         val out =
           IntSet.reduce
           (fn (out, r) =>
            let
              val out = p (out, " ")
              val out = p (out, Register.to_string r)
            in
              out
            end)
           (out, set)
         val out = p (out, "\n")
       in
         out
       end)
      (out, graph)
d424 1
a424 1
    fun empty nr_registers =
d426 3
a428 5
        val _ =
          if do_diagnostics then
            diagnostic (1, fn _ =>
                        $"creating empty graph with " ^^ $(N nr_registers) ^^ $" vertices.")
          else ()
d490 1
a490 1
    fun colour ({nr_vertices, graph, uses, colouring},preferences) =
d492 2
@


1.20
log
@Added move preferencing mechanism (see comments).
@
text
@d15 3
d392 2
a393 2
           Register.Map.YES x => COLOUR x
        |  Register.Map.NO => RESERVED reg
d541 1
d570 7
@


1.19
log
@Change use of temporaries to be from a list
@
text
@d15 3
d99 1
a99 1
			  structure Option : OPTION
d107 2
d115 3
a117 1
    val diagnostics = true
d119 3
d125 1
d127 6
a132 2
      Diagnostic.output_text level
      (fn verbosity => $"RegisterColourer (" ^^ instance_name ^^ $"): " ^^ output_function verbosity)
d148 5
d172 1
a172 2
	val _ = output(std_out, "ordering vertices for graph of length " ^
		       MLWorks.Integer.makestring length ^ "\n")
d343 4
a346 2
                (diagnostic (0, fn _ => $"Colour preference " ^^ $(MLWorks.Integer.makestring (n-1)) ^^ $" is " ^^ 
                             Register.Pack.to_text (Register.Pack.from_list e));
d370 1
a370 1
    datatype Colour = COLOUR of int | SLOT of int | RESERVED of Register.T | UNCOLOURED
d372 4
d377 1
a393 5
    type Graph = {nr_vertices : int,
                  graph	      : IntSet.T Array.array,
                  uses	      : int Array.array,
                  colouring   : Colour Array.array}

d398 1
a398 1
         val out = p (out, Register.to_string (Register.pack r))
d401 11
a411 5
                      case Array.sub (colouring, r) of
                        COLOUR c   => Register.to_string (Array.sub (colours, c))
                      | SLOT s     => MLWorks.Integer.makestring s
                      | RESERVED r => Register.to_string r
                      | UNCOLOURED => "?")
d413 1
a413 1
         val out = p (out, MLWorks.Integer.makestring (Array.sub (uses, r)))
d420 1
a420 1
              val out = p (out, Register.to_string (Register.pack r))
d434 1
a434 1
          if diagnostics then
d436 1
a436 1
                        $"creating empty graph with " ^^ $(MLWorks.Integer.makestring nr_registers) ^^ $" vertices.")
d447 1
a447 1
             (fn reg => Array.update (colouring, Register.unpack reg, preassigned_colour reg))
d455 4
a458 5
      (if diagnostics then
         diagnostic (4, fn _ => $"adding clash between " ^^ Register.Pack.to_text defined ^^
                                $" and " ^^ Register.Pack.to_text referenced)
       else ();

d460 12
a471 23
       (fn reg =>
        let
          val r = Register.unpack reg
        in
          Array.update (uses, r, Array.sub (uses, r)+1)
        end) referenced;
                
       Register.Pack.iterate
       (fn reg =>
        let
          val r = Register.unpack reg
        in
          Array.update (uses, r, Array.sub (uses, r)+1);
          Register.Pack.iterate
          (fn reg' =>
           let
             val r' = Register.unpack reg'
           in
             Array.update (graph, r,  IntSet.add' (Array.sub (graph, r), r'));
             Array.update (graph, r', IntSet.add' (Array.sub (graph, r'), r))
           end) live
        end) defined)

d490 10
a499 1
    fun colour {nr_vertices, graph, uses, colouring} =
d502 1
a502 1
        val available_spill = Array.array (nr_vertices, true)
d506 63
d575 2
a576 1
             | SLOT s   => Array.update (available_spill, s, false)
d579 19
a597 11
        fun find_spill 0 = crash "Couldn't find a spill slot."
          | find_spill n =
            let
              val spill = nr_vertices - n
            in
              if Array.sub (available_spill, spill) then
                (if spill >= (!nr_spills) then nr_spills := spill+1 else ();
                 SLOT spill)
              else
                find_spill (n-1)
            end
d599 7
a605 1
        fun find_colour 0 = find_spill nr_vertices
d628 1
a628 13
(*
        fun colour' [] = ()
          | colour' (vertex::vertices) =
            ((case Array.sub (colouring, vertex)
                of UNCOLOURED => 
                   (MLWorks.ExtendedArray.fill (available, true);
                    MLWorks.ExtendedArray.fill (available_spill, true);
                    IntSet.iterate neighbour (Array.sub (graph, vertex));
                    Array.update (colouring, vertex, find_colour (Array.length colour_order)))
                 | _ => ());
                colour' vertices)
*)
        fun colour''{vertex, uses} =
d632 1
a632 1
		MLWorks.ExtendedArray.fill (available_spill, true);
d637 18
a654 2
	fun colour'(Option.SOME1 x) = Lists.iterate colour'' x
	  | colour'(Option.SOME2 x) = MLWorks.ExtendedArray.iterate colour'' x
d656 1
a656 10
        val _ = diagnostic (2, fn _ =>
                            let
                              fun p (text, 0) = text
                                | p (text, n) =
                                  p (text ^^ $"\n" ^^ $(MLWorks.Integer.makestring (n-1)) ^^
                                     $": " ^^ $(MLWorks.Integer.makestring (Array.sub (uses, n-1))) ^^
                                     $"  " ^^ IntSet.to_text (Array.sub (graph, n-1)), n-1)
                            in
                              p ($"graph", Array.length graph)
                            end)
d662 1
a662 1
                            Lists.reducel (fn (text, i) => text ^^ $" " ^^ $(MLWorks.Integer.makestring i))
d666 1
a666 1
        val _ = colour' order
d677 4
a680 1
            val unspill = false (* !nr_spills <= nr_temporaries *)
d686 1
a686 1
                  case Array.sub (colouring, n-1)
d688 1
d695 2
a696 2
              (if diagnostics andalso !nr_spills > 0 then
                 diagnostic (1, fn _ => $"unspilling " ^^ $(MLWorks.Integer.makestring (!nr_spills)) ^^ $" spills")
d701 1
a701 1
            if diagnostics then
d706 1
a706 1
                                p (text ^^ $"\n" ^^ $(MLWorks.Integer.makestring (n-1)) ^^ $" -> " ^^
d709 1
a709 1
                                       | SPILL slot   => $(MLWorks.Integer.makestring slot)), n-1)
d714 1
a714 1
            fn reg => Array.sub (assignments, Register.unpack reg)
@


1.18
log
@Use improved register preference sorting
@
text
@d15 3
d101 1
a101 1
                          val temporaries      : Register.Pack.T
d336 2
a337 2
    val nr_temporaries = Register.Pack.cardinality temporaries
    val temporary_array = Array.arrayoflist (Register.Pack.to_list temporaries)
@


1.17
log
@Added MLWorks to ExtendedArray in a couple of places
@
text
@d15 3
a146 3
        fun list (l, 0) = l
          | list (l, n) =
            list ((n-1, Array.sub (uses, n-1))::l, n-1)
a151 1
	fun order ((_, uses : int), (_, uses' : int)) = uses >= uses'
a153 1
(*
d155 12
a166 3
*)
	  Option.SOME1(Lists.qsort order (list ([], Array.length graph)))
(*
d174 4
a177 3
	    val indirections = Array.tabulate (length, fn x => (x, Array.sub(uses, x)))
	    fun find_smallest(result as (best, (_, value : int)), 0) = result
	      | find_smallest(result as (best, (_, value)), n) =
d180 1
a180 1
		  val curr as (_, current) = Array.sub(indirections, n')
d186 3
a188 2
	    fun try_one_element(n, smallest as (index, value : (int * int)), current) =
	      if #2 current > #2 value then
d198 1
d201 1
a201 1
	      ((0, Array.sub(indirections, 0)), indirections)
d203 1
d214 2
a215 1
	    fun find(0, value : int) = 0
d219 1
a219 1
		  val (_, curr) = Array.sub(indirections, m')
d221 1
a221 3
		  if curr >= value then m
		  else
		    find(m', value)
d223 4
a226 3
		  
	    fun insert(n, arg as (_, value : int)) =
	      (* a function to insert value in the correct place before n*)
d229 1
a229 1
		val (_, prev) = Array.sub(indirections, n')
d231 1
a231 1
		if prev >=  value then ()
d234 2
a235 2
		    val from = find(n', value)
		    val _ = shuffle(from, n)
d237 1
a237 1
		    Array.update(indirections, from, arg)
d242 1
a242 1
	      if n >= small_size then ()
d244 2
a245 2
		(insert(n, Array.sub(indirections, n));
		 insert_all(n+1))
d247 1
a247 1
	    Option.SOME2(insert_all 1;
a249 1
*)
d535 1
a535 1
        fun colour''(vertex, _) =
d544 2
a545 3
	val colour' =
	  fn Option.SOME1 x => Lists.iterate colour'' x
	   | Option.SOME2 x => MLWorks.ExtendedArray.iterate colour'' x
@


1.16
log
@Changed the sorting mechanism when the number of vertices is very large,
all that is need is the most popular registers
@
text
@d15 4
d189 1
a189 1
	    val _ = ExtendedArray.reducel_index
d536 1
a536 1
	   | Option.SOME2 x => ExtendedArray.iterate colour'' x
@


1.15
log
@Added graph printing diagnostics.
@
text
@d15 3
d78 1
d86 1
d123 1
d134 1
d136 1
d138 100
d509 1
d520 9
d530 4
d547 1
d551 1
@


1.15.1.1
log
@Fork for bug fixing
@
text
@a14 3
 *  Revision 1.15  1993/08/03  15:56:48  richard
 *  Added graph printing diagnostics.
 *
@


1.14
log
@Removed Integer parameter
@
text
@d15 3
d25 2
a26 1
 *  Change to NewMap.empty which now takes < and = functions instead of the single-function
d248 30
@


1.13
log
@Chnaged references to Array to ExtendedArray, where appropriate.
@
text
@d15 3
a68 1
require "../utils/integer";
a77 1
                          structure Integer    : INTEGER
d195 1
a195 1
                (diagnostic (0, fn _ => $"Colour preference " ^^ $(Integer.makestring (n-1)) ^^ $" is " ^^ 
d250 1
a250 1
                        $"creating empty graph with " ^^ $(Integer.makestring nr_registers) ^^ $" vertices.")
d382 2
a383 2
                                  p (text ^^ $"\n" ^^ $(Integer.makestring (n-1)) ^^
                                     $": " ^^ $(Integer.makestring (Array.sub (uses, n-1))) ^^
d392 1
a392 1
                            Lists.reducel (fn (text, i) => text ^^ $" " ^^ $(Integer.makestring i))
d421 1
a421 1
                 diagnostic (1, fn _ => $"unspilling " ^^ $(Integer.makestring (!nr_spills)) ^^ $" spills")
d431 1
a431 1
                                p (text ^^ $"\n" ^^ $(Integer.makestring (n-1)) ^^ $" -> " ^^
d434 1
a434 1
                                       | SPILL slot   => $(Integer.makestring slot)), n-1)
@


1.12
log
@Efficiency changes to use mononewmap for registers and tags
@
text
@d15 3
d370 2
a371 2
                   (MLWorks.Array.fill (available, true);
                    MLWorks.Array.fill (available_spill, true);
@


1.11
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d15 3
a60 2

require "../utils/newmap";
a68 1

a70 1
                          structure Map	       : NEWMAP
d225 1
a225 1
          Map.tryApply (Map.from_list' Register.order (list ([], nr_colours)))
d230 2
a231 2
          Map.YES x => COLOUR x
        | Map.NO => RESERVED reg
@


1.10
log
@Got rid of some handles using tryApply and co
@
text
@d15 3
d80 2
a81 2
                          datatype relation = LESS | EQUAL | GREATER
                          val allocation_order : Register.T * Register.T -> relation
d157 9
a165 4
                    (case allocation_order (register, r)
                       of LESS    => [register] :: e :: es
                        | EQUAL   => (register::r::rs) :: es
                        | GREATER => e :: insert' es)
@


1.9
log
@Removed some redundant structures and sharing
@
text
@d15 3
d218 1
a218 1
          Map.apply (Map.from_list' Register.order (list ([], nr_colours)))
d222 3
a224 1
        COLOUR (map reg) handle Map.Undefined => RESERVED reg
@


1.8
log
@Changed use of Array structure due to changes in ther
pervasive environment.
@
text
@d15 4
d76 1
a76 1
                          sharing Diagnostic.Text = Register.Text = IntSet.Text) : REGISTERCOLOURER =
@


1.7
log
@Disabled unspilling -- it doesn't work properly.
@
text
@d15 3
a88 11
    open Array
    nonfix sub

    fun fill_array (array, value) =
      let
        fun fill 0 = ()
          | fill n = (update (array, n-1, value); fill (n-1))
      in
        fill (length array)
      end

d105 1
a105 1
            list ((n-1, sub (uses, n-1))::l, n-1)
d109 1
a109 1
        map #1 (Lists.qsort order (list ([], length graph)))
d129 1
a129 1
    val colours = arrayoflist (Register.Pack.to_list available)
d165 1
a165 1
            val new = array (length, array (0, 0))
d170 1
a170 1
                  | find n = if sub (colours, n-1) = register then n-1 else find (n-1)
d179 1
a179 1
                 update (new, n-1, arrayoflist (map colour e));
d190 1
a190 1
    val temporary_array = arrayoflist (Register.Pack.to_list temporaries)
d209 1
a209 1
            | list (done, n) = list ((sub (colours, n-1), n-1)::done, n-1)
d220 3
a222 3
                  graph	      : IntSet.T array,
                  uses	      : int array,
                  colouring   : Colour array}
d234 2
a235 2
         graph = array (nr_registers, IntSet.empty),
         uses = array (nr_registers, 0),
d238 1
a238 1
             val colouring = array (nr_registers, UNCOLOURED)
d240 3
a242 1
             Register.Pack.iterate (fn reg => update (colouring, Register.unpack reg, preassigned_colour reg)) preassigned;
d259 1
a259 1
          update (uses, r, sub (uses, r)+1)
d267 1
a267 1
          update (uses, r, sub (uses, r)+1);
d273 2
a274 2
             update (graph, r,  IntSet.add' (sub (graph, r), r'));
             update (graph, r', IntSet.add' (sub (graph, r'), r))
d298 2
a299 2
        val available = array (nr_colours, true)
        val available_spill = array (nr_vertices, true)
d307 3
a309 3
          case sub (colouring, vertex)
            of COLOUR c => update (available, c, false)
             | SLOT s   => update (available_spill, s, false)
d317 1
a317 1
              if sub (available_spill, spill) then
d327 2
a328 2
              val set = sub (colour_order, n-1)
              val length = length set
d333 1
a333 1
                    val colour = sub (set, (!scatter + n-1) mod length)
d335 1
a335 1
                    if sub (available, colour) then
d349 1
a349 1
            ((case sub (colouring, vertex)
d351 4
a354 4
                   (fill_array (available, true);
                    fill_array (available_spill, true);
                    IntSet.iterate neighbour (sub (graph, vertex));
                    update (colouring, vertex, find_colour (length colour_order)))
d363 2
a364 2
                                     $": " ^^ $(Integer.makestring (sub (uses, n-1))) ^^
                                     $"  " ^^ IntSet.to_text (sub (graph, n-1)), n-1)
d366 1
a366 1
                              p ($"graph", length graph)
d384 1
a384 1
            val assignments = array (nr_vertices, SPILL 0)
d390 8
a397 7
                (update (assignments, n-1,
                         case sub (colouring, n-1)
                           of UNCOLOURED    => crash "Unassigned registers after colouring"
                            | RESERVED reg  => REGISTER reg
                            | COLOUR colour => REGISTER (sub (colours, colour))
                            | SLOT spill    => if unspill then REGISTER (sub (temporary_array, spill)) else SPILL spill);
                assign (n-1))
d412 1
a412 1
                                   (case sub (assignments, n-1)
d419 1
a419 1
            fn reg => sub (assignments, Register.unpack reg)
@


1.6
log
@If the number of spill is not greater than the number of temporaries
then the temporaries are assigned the spills.
@
text
@d15 4
d392 1
a392 1
            val unspill = !nr_spills <= nr_temporaries
@


1.5
log
@Added missing require integer
@
text
@d15 3
d59 1
d62 1
d78 1
a78 1
      (fn verbosity => $"RegisterColourer: " ^^ output_function verbosity)
d125 5
d193 3
d303 1
a303 1
        val scatter = ref 0
d346 2
d379 5
d388 2
d392 7
a398 11
                case sub (colouring, n-1)
                  of SLOT spill   => (update (assignments, n-1, SPILL spill); assign (n-1))
                   | UNCOLOURED   => crash "Unassigned registers after colouring"
                   | RESERVED reg =>
                       (update (assignments, n-1, REGISTER reg); assign (n-1))
                   | COLOUR colour =>
                       let
                         val reg = sub (colours, colour)
                       in
                         update (assignments, n-1, REGISTER reg); assign (n-1)
                       end
d400 6
@


1.4
log
@Hints are no longer needed by the graphs.
RegisterPack now packs registers incidentally.
@
text
@d15 4
d42 1
@


1.3
log
@Altered the colouring priorities to generate better spill behaviour
when pulling structures apart.
@
text
@d15 4
d182 4
a185 14
     *  A Graph consists of an array which maps registers to vertices, an
     *  array of adjacency sets which forms the graph itself, and an array
     *  of colourings for the vertices.
     *
     *  The merging array is constructed from the list of hints passed to
     *  the `empty' function.  These hints specify registers which do not
     *  clash, and may therefore be represented by the same vertex in the
     *  graph.  Constructing the merging array is a unification-like
     *  problem, as the hints are supplied as lists of pairs of such
     *  registers.
     *
     *  Once the merging array is built the preassigned registers (such as
     *  the argument register) must be coloured so that the colouring
     *  function won't reassign them later.
a205 1
                  merge	      : Register.T -> int,
d211 1
a211 1
    fun empty (nr_registers, hints) =
d216 1
a216 80
                        $"creating empty graph with " ^^ $(Integer.makestring nr_registers) ^^ $" registers.")
          else ()

        val mergers = array (nr_registers, [])
        val table = array (nr_registers, 0)
          
        val _ =
          let
            fun number 0 = ()
              | number n = (update (mergers, n-1, [n-1]); number (n-1))
          in
            number nr_registers
          end

        val _ =
          let
            fun join [] = ()
              | join ((reg, reg')::hints) =
                let
                  val r = Register.unpack reg
                  val r' = Register.unpack reg'
                in
                  update (mergers, r, r' :: sub (mergers, r));
                  update (mergers, r', r :: sub (mergers, r'));
                  join hints
                end
          in
            join hints;
            if diagnostics then
              diagnostic (3, fn _ =>
                          let
                            fun p (text, 0) = text
                              | p (text, n) =
                                p (text ^^ $"\n" ^^ $(Integer.makestring (n-1)) ^^ $" -> " ^^
                                   $(Lists.to_string Integer.makestring (sub (mergers, n-1))), n-1)
                          in
                            p ($"merger matrix", nr_registers)
                          end)
            else ()
          end

        fun assign (count, 0) = count
          | assign (count, n) =
            case sub (mergers, n-1)
              of [] => assign (count, n-1)
               | _ =>
                 let
                   fun assign' r =
                     case sub (mergers, r)
                       of []   => ()
                        | list => (update (mergers, r, []); update (table, r, count); Lists.iterate assign' list)
                 in
                   assign' (n-1);
                   assign (count+1, n-1)
                 end

        val nr_vertices = assign (0, nr_registers)

        fun merge reg = sub (table, Register.unpack reg)

        val colouring =
          let
            val colouring = array (nr_vertices, UNCOLOURED)
          in
            Register.Pack.iterate (fn reg => update (colouring, merge reg, preassigned_colour reg)) preassigned;
            colouring
          end

        val _ =
          if diagnostics then
            diagnostic
            (1, fn 0 => $(Integer.makestring nr_registers) ^^ $" merged down to " ^^ $(Integer.makestring nr_vertices)
                 | _ => let
                          fun p (text, 0) = text
                            | p (text, n) =
                              p (text ^^ $"\n" ^^ Register.to_text (Register.pack (n-1)) ^^ $" -> " ^^
                                 $(Integer.makestring (sub (table, n-1))), n-1)
                        in
                          p ($"mergers", nr_registers)
                        end)
d219 10
a228 5
        {nr_vertices = nr_vertices,
         merge = merge,
         graph = array (nr_vertices, IntSet.empty),
         uses = array (nr_vertices, 0),
         colouring = colouring}
d232 1
a232 1
    fun clash ({merge, graph, uses, ...} : Graph, defined, referenced, live) =
d241 1
a241 1
          val r = merge reg
d249 1
a249 1
          val r = merge reg
d255 1
a255 1
             val r' = merge reg'
d280 1
a280 1
    fun colour {nr_vertices, merge, graph, uses, colouring} =
d391 1
a391 1
            fn reg => sub (assignments, merge reg)
@


1.2
log
@Integer sets are used for adjacency rather than lists, which were
getting rather long!
Colours are now allocated using an ordering which is a parameter to
the functor, and scattered pseudo-randomly across registers which
compare equal.
The colour function no longer returns a set of registers used, as this
always included the preassigned registers and was therefore of little
use.
@
text
@d15 10
d51 1
a51 1
                          sharing Diagnostic.Text = Register.Text) : REGISTERCOLOURER =
d83 6
a88 1
     *  vertices (array indeces) with the vertex with the most first.
d91 1
a91 1
    fun order_vertices graph =
d93 5
a97 3
        fun degree (list, 0) = list
          | degree (list, n) = degree ((n-1, IntSet.cardinality (sub (graph, n-1)))::list, n-1)
        fun order ((_, degree:int), (_, degree':int)) = degree > degree'
d99 1
a99 1
        map #1 (Lists.qsort order (degree ([], length graph)))
d214 1
d308 1
d313 1
a313 1
    fun clash ({merge, graph, ...} : Graph, set, set') =
d315 2
a316 1
         diagnostic (4, fn _ => $"adding clash between " ^^ Register.Pack.to_text set ^^ $" and " ^^ Register.Pack.to_text set')
d324 9
d340 2
a341 2
           end) set'
        end) set)
d361 1
a361 1
    fun colour {nr_vertices, merge, graph, colouring} =
d406 1
a406 1
              scatter := !scatter+1; (*******************)
d421 12
a432 1
        val _ = colour' (order_vertices graph)
d434 6
a456 15

            val _ =
              if diagnostics then
                diagnostic (2, fn _ =>
                            let
                              fun p (text, 0) = text
                                | p (text, n) =
                                  p (text ^^ $"\n" ^^ $(Integer.makestring (n-1)) ^^ $" -> " ^^
                                     (case sub (assignments, n-1)
                                        of REGISTER reg => Register.to_text reg
                                         | SPILL slot   => $(Integer.makestring slot)), n-1)
                            in
                              p ($"assignments", nr_vertices)
                            end)
              else ()
d459 13
@


1.1
log
@Initial revision
@
text
@d14 4
a17 1
 *  $Log$
d25 1
d36 1
d39 2
d47 1
a47 1
    val diagnostics = false
d72 2
a73 3
     *  This function maps a graph (array of adjacency lists) onto a list of
     *  vertices (array indeces) with the vertex with the most edges
     *  (longest list) first.
d79 1
a79 1
          | degree (list, n) = degree ((n-1, Lists.length (sub (graph, n-1)))::list, n-1)
d86 73
d162 1
a162 1
     *  array of adjacency lists which forms the graph itself, and an array
d177 1
a177 1
    datatype Colour = COLOUR of int | UNCOLOUR of int | RESERVED of Register.T | UNCOLOURED
a178 2
    val nr_colours = Register.Pack.cardinality available
    val colours = arrayoflist (Register.Pack.to_list available)
d196 1
a196 1
                  graph	      : int list array,
d275 3
a277 2
            diagnostic (2, fn _ =>
                        let
d289 1
a289 1
         graph = array (nr_vertices, []),
d296 1
a296 1
         diagnostic (2, fn _ => $"adding clash between " ^^ Register.Pack.to_text set ^^ $" and " ^^ Register.Pack.to_text set')
d309 2
a310 2
             update (graph, r, r' :: sub (graph, r));
             update (graph, r', r :: sub (graph, r'))
d321 9
a329 4
     *  number of edges they have.  It uses two arrays of booleans,
     *  `available' and `available_spill' to mask out registers and spill
     *  slots that clash with a vertex, then scans these to find an
     *  available colour.
d337 1
d342 5
a346 7
        fun neighbours [] = ()
          | neighbours (vertex::vertices) =
            ((case sub (colouring, vertex)
                of COLOUR c    => update (available, c, false)
                 | UNCOLOUR s  => update (available_spill, s, false)
                 | _           => ());
             neighbours vertices)
d355 1
a355 1
                 UNCOLOUR spill)
d363 13
a375 1
              val colour = nr_colours - n
d377 2
a378 4
              if sub (available, colour) then
                COLOUR colour
              else
                find_colour (n-1)
d387 2
a388 2
                    neighbours (sub (graph, vertex));
                    update (colouring, vertex, find_colour nr_colours))
d394 1
a394 1
        val (used, assign) =
d398 2
a399 2
            fun assign (used, 0) = used
              | assign (used, n) =
d401 2
a402 2
                  of UNCOLOUR spill => (update (assignments, n-1, SPILL spill); assign (used, n-1))
                   | UNCOLOURED     => crash "Unassigned registers after colouring"
d404 1
a404 2
                       (update (assignments, n-1, REGISTER reg);
                        assign (Register.Pack.add' (used, reg), n-1))
d409 1
a409 2
                         update (assignments, n-1, REGISTER reg);
                         assign (Register.Pack.add' (used, reg), n-1)
a411 2
            val used = assign (Register.Pack.empty, nr_vertices)

d421 1
a421 1
                                         | SPILL slot =>   $(Integer.makestring slot)), n-1)
d427 2
a428 1
            (used, fn reg => sub (assignments, merge reg))
d432 1
a432 2
         nr_spills = !nr_spills,
         used = used}
@
