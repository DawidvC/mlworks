head	1.29;
access;
symbols
	MLW_daveb_inline_1_4_99:1.29.1
	MLWorks_21c0_1999_03_25:1.29
	MLWorks_20c1_1998_08_20:1.29
	MLWorks_20c0_1998_08_04:1.29
	MLWorks_20b2c2_1998_06_19:1.29
	MLWorks_20b2_Windows_1998_06_12:1.29
	MLWorks_20b1c1_1998_05_07:1.29
	MLWorks_20b0_1998_04_07:1.29
	MLWorks_20b0_1998_03_20:1.29
	MLWorks_20m2_1998_02_16:1.28
	MLWorks_20m1_1997_10_23:1.28
	MLWorks_11r1:1.26.1.1.1.1.1
	MLWorks_workspace_97:1.28.2
	MLWorks_dt_wizard:1.28.1
	MLWorks_11c0_1997_09_09:1.26.1.1.1.1
	MLWorks_10r3:1.26.1.1.3
	MLWorks_10r2_551:1.26.1.1.2
	MLWorks_11:1.26.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.26.1.1
	MLWorks_20m0_1997_06_20:1.28
	MLWorks_1_0_r2c2_1997_06_14:1.26.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.26.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.26.1
	MLWorks_BugFix_1997_04_24:1.26
	MLWorks_1_0_r2_Win32_1997_04_11:1.26
	MLWorks_1_0_r2_Unix_1997_04_04:1.26
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.24.3.1.1
	MLWorks_gui_1996_12_18:1.24.4
	MLWorks_1_0_Win32_1996_12_17:1.24.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.24.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.24.1.1
	MLWorks_1_0_Irix_1996_11_28:1.24.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.24.2
	MLWorks_1_0_Unix_1996_11_14:1.24.1
	MLWorks_Open_Beta2_1996_10_11:1.23.3
	MLWorks_License_dev:1.23.2
	MLWorks_1_open_beta_1996_09_13:1.23.1
	MLWorks_Open_Beta_1996_08_22:1.23
	MLWorks_Beta_1996_07_02:1.23
	MLWorks_Beta_1996_06_07:1.23
	MLWorks_Beta_1996_06_06:1.23
	MLWorks_Beta_1996_06_05:1.23
	MLWorks_Beta_1996_06_03:1.23
	MLWorks_Beta_1996_05_31:1.23
	MLWorks_Beta_1996_05_30:1.23
	ML_beta_release_12/08/94:1.16
	ML_beta_release_03/08/94:1.16
	ML_revised_beta_release_25/05/94:1.14
	ML_final_beta_release_02/03/94:1.14
	mlworks-28-01-1994:1.14
	Release:1.13
	mlworks-beta-01-09-1993:1.13
	MLWorks-1-0-4-29/01/1993:1.9
	MLWorks-1-0-3-21/12/1992:1.9
	MLWorks-1-0-2-15/12/1992:1.9
	MLWorks-1-0-1-04/12/1992:1.9
	checkpoint_17_08_92:1.4;
locks; strict;
comment	@ * @;


1.29
date	98.02.19.14.52.06;	author jont;	state Exp;
branches
	1.29.1.1;
next	1.28;

1.28
date	97.05.19.10.00.49;	author jont;	state Exp;
branches
	1.28.1.1
	1.28.2.1;
next	1.27;

1.27
date	97.05.01.13.11.23;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	97.01.03.13.30.33;	author matthew;	state Exp;
branches
	1.26.1.1;
next	1.25;

1.25
date	96.12.18.11.59.47;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	96.11.06.11.09.04;	author matthew;	state Exp;
branches
	1.24.1.1
	1.24.2.1
	1.24.3.1
	1.24.4.1;
next	1.23;

1.23
date	96.05.07.11.01.58;	author jont;	state Exp;
branches
	1.23.1.1
	1.23.2.1
	1.23.3.1;
next	1.22;

1.22
date	96.04.29.14.48.47;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	96.03.28.11.02.12;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	94.11.11.14.20.12;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	94.10.11.12.11.46;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	94.09.30.12.49.00;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	94.08.25.10.27.51;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	94.07.22.15.43.59;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	94.06.08.11.38.04;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	93.11.05.10.27.54;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	93.05.20.21.03.06;	author nosa;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	93.05.18.14.49.20;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	93.04.27.13.43.59;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	93.03.10.17.58.32;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	92.11.03.16.26.58;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.10.29.17.55.57;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.09.22.09.46.41;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.08.26.15.09.00;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.08.24.13.36.37;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	92.06.29.09.54.18;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.06.18.16.19.17;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.06.17.13.23.01;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.05.27.14.11.37;	author richard;	state Exp;
branches;
next	;

1.13.1.1
date	93.05.20.21.03.06;	author jont;	state Exp;
branches;
next	;

1.23.1.1
date	96.09.13.11.14.36;	author hope;	state Exp;
branches;
next	;

1.23.2.1
date	96.10.07.16.05.01;	author hope;	state Exp;
branches;
next	;

1.23.3.1
date	96.10.17.11.23.16;	author hope;	state Exp;
branches;
next	;

1.24.1.1
date	96.11.14.12.47.35;	author hope;	state Exp;
branches
	1.24.1.1.1.1;
next	;

1.24.1.1.1.1
date	96.11.28.14.59.08;	author hope;	state Exp;
branches;
next	;

1.24.2.1
date	96.11.22.18.07.38;	author hope;	state Exp;
branches;
next	;

1.24.3.1
date	96.12.17.17.46.21;	author hope;	state Exp;
branches
	1.24.3.1.1.1;
next	;

1.24.3.1.1.1
date	97.02.24.11.35.58;	author hope;	state Exp;
branches;
next	;

1.24.4.1
date	96.12.18.09.40.20;	author hope;	state Exp;
branches;
next	;

1.26.1.1
date	97.05.12.10.32.40;	author hope;	state Exp;
branches
	1.26.1.1.1.1
	1.26.1.1.2.1
	1.26.1.1.3.1;
next	;

1.26.1.1.1.1
date	97.07.28.18.18.24;	author daveb;	state Exp;
branches
	1.26.1.1.1.1.1.1;
next	;

1.26.1.1.1.1.1.1
date	97.10.07.11.43.27;	author jkbrook;	state Exp;
branches;
next	;

1.26.1.1.2.1
date	97.09.08.17.11.59;	author daveb;	state Exp;
branches;
next	;

1.26.1.1.3.1
date	97.09.09.14.07.34;	author daveb;	state Exp;
branches;
next	;

1.28.1.1
date	97.09.10.19.22.28;	author brucem;	state Exp;
branches;
next	;

1.28.2.1
date	97.09.11.20.53.42;	author daveb;	state Exp;
branches;
next	;

1.29.1.1
date	99.04.01.17.56.13;	author daveb;	state Exp;
branches;
next	;


desc
@Virtual register packing functor.
@


1.29
log
@[Bug #30341]
Fix where type ... and syntax
@
text
@(*  ==== PACK REGISTERS IN A PROCEDURE ====
 *                FUNCTOR
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *
 *  Revision Log
 *  ------------
 *  $Log: _registerpack.sml,v $
 * Revision 1.28  1997/05/19  10:00:49  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.27  1997/05/01  13:11:23  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.26  1997/01/03  13:30:33  matthew
 * Simplifications and rationalizations
 *
 * Revision 1.25  1996/12/18  11:59:47  jont
 * [Bug #1857]
 * Fix problems where last sue of a register is a definition
 *
 * Revision 1.24  1996/11/06  11:09:04  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.23  1996/05/07  11:01:58  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.22  1996/04/29  14:48:47  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.21  1996/03/28  11:02:12  matthew
 * Adding where type clause
 *
 * Revision 1.20  1994/11/11  14:20:12  jont
 * Add immediate store operations
 *
 *  Revision 1.19  1994/10/11  12:11:46  matthew
 *  Use inthashtables for efficiency
 *
 *  Revision 1.18  1994/09/30  12:49:00  jont
 *  Remove handler register concept
 *
 *  Revision 1.17  1994/08/25  10:27:51  matthew
 *  Simplifications.
 *
 *  Revision 1.16  1994/07/22  15:43:59  matthew
 *  Added function argument register lists to BRANCH_AND_LINK, TAIL_CALL and ENTER
 *
 *  Revision 1.15  1994/06/08  11:38:04  richard
 *  Fix deep recursion in scan routine.
 *
 *  Revision 1.14  1993/11/05  10:27:54  jont
 *  Added handling of INTERRUPT instruction
 *
 *  Revision 1.13  1993/05/20  21:03:06  nosa
 *  Debugger Environments for local and closure variable inspection
 *  in the debugger.
 *
 *  Revision 1.12  1993/05/18  14:49:20  jont
 *  Removed Integer parameter
 *
 *  Revision 1.11  1993/04/27  13:43:59  richard
 *  Changed PROFILE instruction to INTERCEPT.
 *
 *  Revision 1.10  1993/03/10  17:58:32  matthew
 *  Map substructure is now MirTypes.Map
 *
 *  Revision 1.9  1992/11/03  16:26:58  jont
 *  Efficiency changes to use mononewmap for registers and tags
 *
 *  Revision 1.8  1992/10/29  17:55:57  jont
 *  Removed some name clashes caused by open statements by remvoing the
 *  offending opens
 *
 *  Revision 1.7  1992/09/22  09:46:41  clive
 *  Got rid of some handles using tryApply and co
 *
 *  Revision 1.6  1992/08/26  15:09:00  jont
 *  Removed some redundant structures and sharing
 *
 *  Revision 1.5  1992/08/24  13:36:37  richard
 *  Added NULLARY opcode type and ALLOC_BYTEARRAY.
 *
 *  Revision 1.4  1992/06/29  09:54:18  clive
 *  Added type annotation information at application points
 *
 *  Revision 1.3  1992/06/18  16:19:17  richard
 *  Added parameter to RAISE once again.
 *
 *  Revision 1.2  1992/06/17  13:23:01  richard
 *  Merged this module with the preallocator.  The module now does some
 *  preliminary register allocation in order to reduce the number of
 *  virtual registers knocking about and hence improve the performance
 *  of the rest of the optimiser.
 *
 *  Revision 1.1  1992/05/27  14:11:37  richard
 *  Initial revision
 *
 *)

require "../basis/__int";

require "../utils/diagnostic";
require "../utils/crash";
require "../utils/lists";
require "../utils/inthashtable";
require "mirprint";
require "mirtables";
require "mirregisters";
require "registerpack";


functor RegisterPack (
  include sig
  structure Diagnostic   : DIAGNOSTIC
  structure Crash        : CRASH
  structure Lists        : LISTS
  structure IntHashTable : INTHASHTABLE
  structure MirTables    : MIRTABLES
  structure MirRegisters : MIRREGISTERS
  structure MirPrint	 : MIRPRINT

  val full_analysis_threshold : int

  (* Keep this type sharing here for abstraction of VirtualRegister *)
  sharing MirTables.MirTypes = MirRegisters.MirTypes = MirPrint.MirTypes
  sharing MirRegisters.MirTypes.GC.Set.Text = Diagnostic.Text
  end where type MirTables.MirTypes.GC.T = int 
      where type MirTables.MirTypes.NonGC.T = int
      where type MirTables.MirTypes.FP.T = int
    ) : REGISTERPACK =
  struct
    structure MirTypes = MirRegisters.MirTypes
    structure Diagnostic = Diagnostic
    structure Map = MirTypes.Map

    val do_diagnostics = false

    val $ = Diagnostic.Text.from_string
    val ^^ = Diagnostic.Text.concatenate
    infix ^^
    fun diagnostic (level, output_function) =
      Diagnostic.output_text level
      (fn verbosity => $"RegisterPack: " ^^ (output_function verbosity))

    fun crash message = Crash.impossible ("RegisterPack: " ^ message)

    fun reducel f = 
      let
        fun red (acc, []) = acc
          | red (acc, x::xs) = red (f(acc,x), xs)
      in 
        red
      end

    fun assignment_to_text assignment =
      reducel (fn (text, (reg, r)) => text ^^ $"\n" ^^ MirTypes.GC.to_text reg ^^ $" -> " ^^ $(Int.toString r))
      ($"GC assignments", IntHashTable.to_list assignment)

    fun fp_assignment_to_text assignment =
      reducel (fn (text, (reg, r)) => text ^^ $"\n" ^^ MirTypes.FP.to_text reg ^^ $" -> " ^^ $(Int.toString r))
      ($"FP assignments", IntHashTable.to_list assignment)

    fun table_update (map,x,y) = (IntHashTable.update (map,x,y);map)

    fun table_from_list l =
      let
        val table = IntHashTable.new (Lists.length l)
        fun aux [] = ()
          | aux ((i,x)::l) =
            (IntHashTable.update (table,i,x);
             aux l)
        val _ = aux l
      in
        table
      end

    fun substitute {gc, non_gc, fp} =
      let
        open MirTypes

        fun any (GC r) = GC (gc r)
          | any (NON_GC r) = NON_GC (non_gc r)
          | any (FLOAT r) = FLOAT (fp r)

        val gp = fn GP_GC_REG r     => GP_GC_REG (gc r)
                  | GP_NON_GC_REG r => GP_NON_GC_REG (non_gc r)
                  | other => other

        val reg = fn GC_REG r     => GC_REG (gc r)
                   | NON_GC_REG r => NON_GC_REG (non_gc r)

        val fp = fn FP_REG r => FP_REG (fp r)

      in
        fn TBINARY   (operator, tag, reg1, gp1, gp2) => TBINARY   (operator, tag, reg reg1, gp gp1, gp gp2)
         | BINARY    (operator, reg1, gp1, gp2)      => BINARY    (operator, reg reg1, gp gp1, gp gp2)
         | UNARY     (operator, reg1, gp1)           => UNARY     (operator, reg reg1, gp gp1)
         | NULLARY   (operator, reg1)                => NULLARY   (operator, reg reg1)
         | TBINARYFP (operator, tag, fp1, fp2, fp3)  => TBINARYFP (operator, tag, fp fp1, fp fp2, fp fp3)
         | TUNARYFP  (operator, tag, fp1, fp2)       => TUNARYFP  (operator, tag, fp fp1, fp fp2)
         | BINARYFP  (operator, fp1, fp2, fp3)       => BINARYFP  (operator, fp fp1, fp fp2, fp fp3)
         | UNARYFP   (operator, fp1, fp2)            => UNARYFP   (operator, fp fp1, fp fp2)
         | STACKOP   (operator, reg1, offset)        => STACKOP   (operator, reg reg1, offset)
         | STOREOP   (operator, reg1, reg2, gp1)     => STOREOP   (operator, reg reg1, reg reg2, gp gp1)
         | IMMSTOREOP(operator, gp1, reg2, gp3)      => IMMSTOREOP(operator, gp gp1, reg reg2, gp gp3)
         | STOREFPOP (operator, fp1, reg1, gp1)      => STOREFPOP (operator, fp fp1, reg reg1, gp gp1)
         | REAL      (operator, fp1, gp1)            => REAL      (operator, fp fp1, gp gp1)
         | FLOOR     (operator, tag, reg1, fp1)      => FLOOR     (operator, tag, reg reg1, fp fp1)
         | BRANCH    (operator, REG reg1)            => BRANCH    (operator, REG (reg reg1))
         | TEST      (operator, tag, gp1, gp2)       => TEST      (operator, tag, gp gp1, gp gp2)
         | FTEST     (operator, tag, fp1, fp2)       => FTEST     (operator, tag, fp fp1, fp fp2)
         | TAIL_CALL (operator, REG reg1,regs)       => TAIL_CALL (operator, REG (reg reg1),map any regs)
         | TAIL_CALL (operator, x, regs)             => TAIL_CALL (operator, x, map any regs)
         | SWITCH    (operator, reg1, tags)          => SWITCH    (operator, reg reg1, tags)
         | ALLOCATE  (operator, reg1, gp1)           => ALLOCATE  (operator, reg reg1, gp gp1)
         | ADR       (operator, reg1, tag)           => ADR       (operator, reg reg1, tag)
         | RAISE     reg1                            => RAISE     (reg reg1)
         | ALLOCATE_STACK  (operator, reg1, amount, offset) => ALLOCATE_STACK (operator, reg reg1, amount, offset)
         | BRANCH_AND_LINK (operator, REG reg1,debug,regs)  => BRANCH_AND_LINK (operator, REG (reg reg1),debug,map any regs)
         | BRANCH_AND_LINK (operator,x,debug,regs)  => BRANCH_AND_LINK (operator,x,debug,map any regs)
         | opcode as INTERCEPT 		=> opcode
         | opcode as INTERRUPT 		=> opcode
         | opcode as ENTER regs         => ENTER (map any regs)
         | opcode as RTS                => opcode
         | opcode as NEW_HANDLER(frame, tag)      =>
	     NEW_HANDLER(reg frame, tag)
         | opcode as OLD_HANDLER        => opcode
         | opcode as DEALLOCATE_STACK _ => opcode
         | opcode as CALL_C             => opcode
         | opcode as BRANCH _           => opcode
         | opcode as COMMENT _          => opcode
      end



    (*  === SCAN OPCODES TO DETERMINE REGISTER USAGE ===
     *
     *  There are two sorts of register usage to consider: whether registers
     *  are confined to a single block, and the lifespans of registers.  The
     *  function `scan' determines both of these.
     *
     *  The confining information is stored in a map called `uses' which
     *  contains ONCE of the register has been used in a single block, MANY
     *  if it has been used in more than one, and FIXED for registers which
     *  can't be renamed anyway.  It is updated and augmented by scan.
     *
     *  The lifespan information is produced in a list of the form
     *   [(first, last), (first, last), ...]
     *  where first and last are the lists of first-used and last-used GC
     *  registers corresponding to the opcode list passed to scan.
     *)

    datatype uses = ONCE of MirTypes.tag | MANY | FIXED

    (* The preassigned registers may not be renamed, and so are defined as *)
    (* FIXED in the uses maps. *)

    local
      val fix =
        let
          val fixed = ref FIXED
        in
          map (fn reg => (reg, fixed))
        end
      val gc = fix (MirTypes.GC.Pack.to_list (#gc MirRegisters.preassigned))
      val non_gc = fix (MirTypes.NonGC.Pack.to_list (#non_gc MirRegisters.preassigned))
      val fp = fix (MirTypes.FP.Pack.to_list (#fp MirRegisters.preassigned))
    in
      fun make_initial_uses () =
        {gc     = table_from_list gc,
         non_gc = table_from_list non_gc,
         fp     = table_from_list fp}
    end

    fun scan ((uses, lifespans), MirTypes.BLOCK (tag, opcodes)) =
      let
        local
          val count_gc = MirTypes.GC.Set.reduce
            (fn (uses, reg) =>
             (case IntHashTable.tryLookup (uses, reg) of
                SOME x => 
                  ((case x of 
                      ref MANY  => ()
                    | ref FIXED => ()
                    | other as ref (ONCE tag') => if tag=tag' then () else other := MANY);
                   uses)
              | _ =>
                  table_update (uses, reg, ref (ONCE tag))))

          val count_non_gc = MirTypes.NonGC.Set.reduce
            (fn (uses, reg) =>
             (case IntHashTable.tryLookup (uses, reg) of
                SOME x => 
                  ((case x of 
                      ref MANY  => ()
                    | ref FIXED => ()
                    | other as ref (ONCE tag') => if tag=tag' then () else other := MANY);
                   uses)
              | _ =>
                  table_update (uses, reg, ref (ONCE tag))))

          val count_fp = MirTypes.FP.Set.reduce
            (fn (uses, reg) =>
             (case IntHashTable.tryLookup (uses, reg) of
                SOME x => 
                  ((case x of 
                      ref MANY  => ()
                    | ref FIXED => ()
                    | other as ref (ONCE tag') => if tag=tag' then () else other := MANY);
                   uses)
              | _ =>
                  table_update(uses, reg, ref (ONCE tag))))
        in
          fun count ({gc = gc_uses, non_gc = non_gc_uses, fp = fp_uses},
                     {gc = gc_touched, non_gc = non_gc_touched, fp = fp_touched}) =
            {gc = count_gc (gc_uses, gc_touched),
             non_gc = count_non_gc (non_gc_uses, non_gc_touched),
             fp = count_fp (fp_uses, fp_touched)}
        end

        fun union_diff (map, set) =
          MirTypes.GC.Set.reduce
          (fn ((map, new), reg) =>
           (case IntHashTable.tryLookup (map, reg) of
              SOME () => (map, new) 
            | _ => (table_update (map, reg, ()), reg::new)))
          ((map, []), set)

        fun backward (uses, lifespans, referenced, []) = (uses, lifespans)
          | backward (uses, lifespans, referenced, (opcode, first)::rev_opcodes_firsts) =
            let
              val referenced_here as {gc = gc_referenced_here, ...} =
		MirTables.referenced_by opcode
	      (* We want to treat definitions as references *)
	      (* in order to avoid problems with definitions that are never used *)
	      (* but whose instructions cause side effects, eg clean or add *)
	      (* We only update gc_referenced_here as this is *)
	      (* the only value used by the lifespans stuff *)
	      (* The uses stuff actually counts all occurrences *)
	      val defined_here as {gc = gc_defined_here, ...} =
		MirTables.defined_by opcode
	      val gc_referenced_here =
		MirTypes.GC.Set.union(gc_referenced_here, gc_defined_here)
              val (referenced, last) = union_diff (referenced, gc_referenced_here)
              val uses = count (uses, referenced_here)
            in
              backward (uses,
                        case (first, last) of
                          ([], []) => lifespans
                        | _ => (first, last)::lifespans,
                        referenced,
                        rev_opcodes_firsts)
            end

        fun forward (rev_opcodes_firsts, uses, defined, []) =
	  backward (uses, lifespans, IntHashTable.new 8, rev_opcodes_firsts)
          | forward (rev_opcodes_firsts, uses, defined, opcode::opcodes) =
            let
              val defined_here as {gc = gc_defined_here, ...} = MirTables.defined_by opcode
              val (defined, first) = union_diff (defined, gc_defined_here)
              val uses = count (uses, defined_here)
            in
              forward ((opcode, first)::rev_opcodes_firsts, uses, defined, opcodes)
            end

      in
        forward ([], uses, IntHashTable.new 8, opcodes)
      end

    (*  === ASSIGN PACKED REGISTERS ===
     *
     *  The information computed by scanning the blocks is used to produce
     *  packed virtual registers from the registers in the opcodes
     *  passed to this module.
     *)

    (* The preassigned registers are already assigned to themselves. *)

    local 
      fun double r = (r,r)
      val gc = (map double (MirTypes.GC.Pack.to_list (#gc MirRegisters.preassigned)))
      val non_gc = (map double (MirTypes.NonGC.Pack.to_list (#non_gc MirRegisters.preassigned)))
      val fp = (map double (MirTypes.FP.Pack.to_list (#fp MirRegisters.preassigned)))
    in
      fun make_initial_assignments () =
        {gc     = table_from_list gc,
         non_gc = table_from_list non_gc,
         fp     = table_from_list fp}
    end

    fun assign (uses, lifespans) =
      let
        val _ = 
          if do_diagnostics
            then
              diagnostic (4, fn _ =>
                          let
                            val reduce = reducel (fn (text, reg) => text ^^ $" " ^^ MirTypes.GC.to_text reg)
                          in
                            reducel
                            (fn (text, (first, last)) => reduce (reduce (text ^^ $"\n", first) ^^ $" / ", last))
                            ($"assigning for lifespans", lifespans)
                          end)
          else ()

        val initial_assignments = make_initial_assignments ()

        (* Assign the registers used across blocks naively, giving each a *)
        (* new packed register.  Assign _all_ the non GC and FP registers *)
        (* this way, as it is not worth doing any further analysis on them. *)
        (* nr_packable is the number of GC registers which are confined to a *)
        (* single block, and threshold is the first packing number available *)
        (* after the naive assignment. *)

        val (nr_packable, threshold, nr_registers, assignments) =
          let
            fun assign' (assignment, next, map) =
              reducel
              (fn ((assignment, next, others), (reg, ref MANY))     =>
	       (table_update (assignment, reg, next), next+1, others)
                | ((assignment, next, others), (reg, ref (ONCE _))) =>
		    (assignment, next, others+1)
                | ((assignment, next, others), (reg, ref FIXED))    =>
		    (assignment, next, others))
              ((assignment, next, 0), IntHashTable.to_list map)

            fun assign_simple_non_gc' (assignment, next, map) =
              (reducel
               (fn ((assignment, next), (reg, ref FIXED)) => (assignment,next)
                 | ((assignment, next), (reg, _)) =>
		(table_update (assignment, reg, next), next+1))
               ((assignment, next), IntHashTable.to_list map))

            fun assign_simple_fp' (assignment, next, map) =
              (reducel
               (fn ((assignment, next), (reg, ref FIXED)) => (assignment,next)
                 | ((assignment, next), (reg, _)) =>
		(table_update (assignment, reg, next), next+1))
               ((assignment, next), IntHashTable.to_list map))

            val {gc = gc_uses, non_gc = non_gc_uses, fp = fp_uses} = uses

            val (gc_assignment, next, nr_packable) =
              assign' (#gc initial_assignments, #gc MirRegisters.pack_next, gc_uses)

            val (non_gc_assignment, nr_non_gc) =
              assign_simple_non_gc' (#non_gc initial_assignments, #non_gc MirRegisters.pack_next, non_gc_uses)

            val (fp_assignment, nr_fp) =
              assign_simple_fp' (#fp initial_assignments, #fp MirRegisters.pack_next, fp_uses)
          in
            (nr_packable, next,
             {gc = next, non_gc = nr_non_gc, fp = nr_fp},
             {gc = gc_assignment, non_gc = non_gc_assignment, fp = fp_assignment})
          end

        (* Now use the lifespan information on the GC registers to merge *)
        (* them together and so reduce their total number. *)

        val (nr_registers', assignments') =
          let
            val alive = MLWorks.Internal.Array.array (threshold + nr_packable, false)

            fun merge (assignment, next, []) = (next, assignment)
              | merge (assignment, next, (first,last)::rest) =
                let
                  (* For each first-use register look for a dead register *)
                  (* above the packing threshold which it can be merged *)
                  (* with, and resurrect it. *)

                  val (assignment', next') =
                    reducel
                    (fn ((assignment, next), reg) =>
                     (case IntHashTable.tryLookup (assignment, reg) of
                        SOME _ => (assignment, next)
                      | _ =>
                          let
                            fun find_dead n =
                              if n = next then
                                (MLWorks.Internal.Array.update (alive, next, true);
                                 (table_update
				  (assignment, reg, next), next+1))
                              else
                                if MLWorks.Internal.Array.sub (alive, n) then
                                  find_dead (n+1)
                                else
                                  (MLWorks.Internal.Array.update (alive, n, true);
                                   (table_update
				    (assignment, reg, n), next))
                          in
                            find_dead threshold
                          end))
                    ((assignment, next), first)
                  (* Mark all last-use registers as dead. *)

                  val _ =
                    Lists.iterate
                    (fn reg =>
                     MLWorks.Internal.Array.update (alive, 
                                   IntHashTable.lookup (assignment, reg), false)
                     handle IntHashTable.Lookup   =>
		       crash ("The unassigned register " ^
			      MirTypes.GC.to_string reg ^ " has died.")
                          | MLWorks.Internal.Array.Subscript =>
			      crash ("Register " ^ MirTypes.GC.to_string reg ^
				     " was assigned outside " ^
				     "the alive array."))
                    last
                in
                  merge (assignment', next', rest)
                end

            val {gc, non_gc, fp} = assignments
            val {non_gc = nr_non_gc, fp = nr_fp, ...} = nr_registers
            val (nr_gc, gc_assign) = merge (gc, threshold, lifespans)

            val _ = 
              if do_diagnostics
                then 
                  diagnostic (2, fn _ =>
                              $"originally " ^^ $(Int.toString (threshold + nr_packable)) ^^ $" GC registers")
              else ()
          in
            ({gc = nr_gc,     non_gc = nr_non_gc, fp = nr_fp},
             {gc = gc_assign, non_gc = non_gc,    fp = fp})
          end

      in
        (nr_registers', assignments')
      end



    (*  === PACK REGISTERS SIMPLY ===
     *
     *  For small procedures the complex analysis above is probably
     *  overkill.  This function scans the blocks and simply assigns
     *  distinct virtual registers to distinct packed registers.
     *)

    local
      fun assign_gc ((next, map), reg) =
        (case IntHashTable.tryLookup (map, reg) of
           SOME _ => (next, map)
         | _ =>
             (next+1, table_update (map, reg, next)))
      fun assign_non_gc ((next, map), reg) =
        (case IntHashTable.tryLookup (map, reg) of
           SOME _ => (next, map)
         | _ => (next+1, table_update (map, reg, next)))
      fun assign_fp ((next, map), reg) =
        (case IntHashTable.tryLookup (map, reg) of
           SOME _ => (next, map)
         | _ => (next+1, table_update (map, reg, next)))

      val gc_assign     = MirTypes.GC.Set.reduce    assign_gc
      val non_gc_assign = MirTypes.NonGC.Set.reduce assign_non_gc
      val fp_assign     = MirTypes.FP.Set.reduce    assign_fp
    in

      fun pack_simply ((nr_registers, assignments), MirTypes.BLOCK (_, opcodes)) =
        let
          fun scan (nr_registers, assignments, []) = (nr_registers, assignments)
            | scan ({gc = gc_nr, non_gc = non_gc_nr, fp = fp_nr},
                    {gc = gc_map, non_gc = non_gc_map, fp = fp_map},
                    opcode::opcodes) =
              let
                val {gc, non_gc, fp} = MirTables.defined_by opcode

                val (gc_nr',     gc_map')     = gc_assign     ((gc_nr,     gc_map),     gc)
                val (non_gc_nr', non_gc_map') = non_gc_assign ((non_gc_nr, non_gc_map), non_gc)
                val (fp_nr',     fp_map')     = fp_assign     ((fp_nr,     fp_map),     fp)
              in
                scan ({gc = gc_nr', non_gc = non_gc_nr', fp = fp_nr'},
                      {gc = gc_map', non_gc = non_gc_map', fp = fp_map'},
                      opcodes)
              end
        in
          scan (nr_registers, assignments, opcodes)
        end

    end


    fun f (MirTypes.PROC (name, start_tag, _, blocks,_)) =
      let
        val _ = 
          if do_diagnostics
            then diagnostic (1, fn _ => $"procedure " ^^ $(MirTypes.print_tag start_tag) ^^ $": " ^^ $name)
          else ()

        val longest =
          reducel (fn (longest, MirTypes.BLOCK (_, opcodes)) =>
                         let
                           val length = Lists.length opcodes
                         in
                           if length > longest then length else longest
                         end) (0, blocks)

        val _ = 
          if do_diagnostics
            then diagnostic (2, fn _ => $"longest block " ^^ $(Int.toString longest))
          else ()

        val do_full_analysis = longest > full_analysis_threshold

        val _ = if do_full_analysis andalso do_diagnostics
                  then diagnostic (2,
                                   fn _ =>
                                   $"Full analysis for " ^^ $ name ^^ $":" ^^
                                   $(Int.toString longest))
                else ()

        val (nr_registers, assignments) =
          if do_full_analysis 
            then (assign (reducel scan ((make_initial_uses(), []), blocks)))
          else
            (reducel pack_simply ((MirRegisters.pack_next, make_initial_assignments()), blocks))

        val _ = 
          if do_diagnostics
            then diagnostic (2, fn _ => $(Int.toString (#gc nr_registers)) ^^ $" GC registers")
          else ()

        val _ = 
          if do_diagnostics
            then diagnostic (3, fn _ => assignment_to_text (#gc assignments))
          else ()

        val _ = 
          if do_diagnostics
            then diagnostic (3, fn _ => fp_assignment_to_text (#fp assignments))
          else ()

        val register_mappings =
          let
            val {gc, non_gc, fp} = assignments
            val gc'     = fn r => case IntHashTable.tryLookup (gc,r) of SOME g => g | _ => crash ("GC lookup failed for " ^ MirTypes.GC.to_string r)
            val non_gc' = fn r => case IntHashTable.tryLookup (non_gc,r) of SOME g => g | _ => crash ("Non-GC lookup failed for " ^ MirTypes.NonGC.to_string r)
            val fp'     = fn r => case IntHashTable.tryLookup (fp,r) of SOME g => g | _ => crash ("FP lookup failed for " ^ MirTypes.FP.to_string r)
          in
            {gc     = fn reg => gc' reg,
             non_gc = fn reg => non_gc' reg,
             fp     = fn reg => fp' reg}
          end
      in
        {nr_registers = nr_registers,
         substitute = substitute register_mappings}
      end

  end
@


1.29.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 * Revision 1.29  1998/02/19  14:52:06  jont
 * [Bug #30341]
 * Fix where type ... and syntax
 *
@


1.28
log
@[Bug #30090]
Translate output std_out to print
@
text
@d12 4
d134 3
a136 3
  end  where type  MirTables.MirTypes.GC.T = int 
             and MirTables.MirTypes.NonGC.T = int
             and MirTables.MirTypes.FP.T = int
@


1.28.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 4
 * Revision 1.28  1997/05/19  10:00:49  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.28.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 4
 * Revision 1.28  1997/05/19  10:00:49  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.27
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d12 4
a139 2

    fun P s = MLWorks.IO.output (MLWorks.IO.std_out,s)
@


1.26
log
@Simplifications and rationalizations
@
text
@d12 3
a16 1
 * [Bug #1857]
d282 1
a282 1
                MLWorks.Option.SOME x => 
d294 1
a294 1
                MLWorks.Option.SOME x => 
d306 1
a306 1
                MLWorks.Option.SOME x => 
d326 1
a326 1
              MLWorks.Option.SOME () => (map, new) 
d476 1
a476 1
                        MLWorks.Option.SOME _ => (assignment, next)
d545 1
a545 1
           MLWorks.Option.SOME _ => (next, map)
d550 1
a550 1
           MLWorks.Option.SOME _ => (next, map)
d554 1
a554 1
           MLWorks.Option.SOME _ => (next, map)
@


1.26.1.1
log
@branched from 1.26
@
text
@a11 3
 * Revision 1.26  1997/01/03  13:30:33  matthew
 * Simplifications and rationalizations
 *
@


1.26.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 * Revision 1.26.1.1  1997/05/12  10:32:40  hope
 * branched from 1.26
 *
@


1.26.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 * Revision 1.26.1.1  1997/05/12  10:32:40  hope
 * branched from 1.26
 *
@


1.26.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 * Revision 1.26.1.1  1997/05/12  10:32:40  hope
 * branched from 1.26
 *
@


1.26.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 3
 * Revision 1.26.1.1.1.1  1997/07/28  18:18:24  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.25
log
@[Bug #1857]
[Bug #1857]
Fix problems where last sue of a register is a definition
@
text
@d12 5
d134 3
a136 1
    
d158 4
d323 3
a325 4
           case IntHashTable.tryLookup (map, reg) of
             MLWorks.Option.SOME () => (map, new)
           | _ =>
               (table_update (map, reg, ()), reg::new))
a327 1

d428 2
a429 1
               (fn ((assignment, next), (reg, _)) =>
d435 2
a436 1
               (fn ((assignment, next), (reg, _)) =>
a492 1

a507 1

d629 5
d637 3
a639 3
            val gc'     = fn r => IntHashTable.lookup (gc,r)
            val non_gc' = fn r => IntHashTable.lookup (non_gc,r)
            val fp'     = fn r => IntHashTable.lookup (fp,r)
@


1.24
log
@[Bug #1728]
__integer becomes __int
@
text
@d12 4
d129 1
a129 1

a317 10
        fun forward (rev_opcodes_firsts, uses, defined, []) =
             backward (uses, lifespans, IntHashTable.new 8, rev_opcodes_firsts)
          | forward (rev_opcodes_firsts, uses, defined, opcode::opcodes) =
            let
              val defined_here as {gc = gc_defined_here, ...} = MirTables.defined_by opcode
              val (defined, first) = union_diff (defined, gc_defined_here)
              val uses = count (uses, defined_here)
            in
              forward ((opcode, first)::rev_opcodes_firsts, uses, defined, opcodes)
            end
d319 1
a319 1
        and backward (uses, lifespans, referenced, []) = (uses, lifespans)
d322 12
a333 1
              val referenced_here as {gc = gc_referenced_here, ...} = MirTables.referenced_by opcode
d345 11
a454 16
                  (* Mark all last-use registers as dead. *)

                  val _ =
                    Lists.iterate
                    (fn reg =>
                     MLWorks.Internal.Array.update (alive, 
                                   IntHashTable.lookup (assignment, reg), false)
                     handle IntHashTable.Lookup   =>
		       crash ("The unassigned register " ^
			      MirTypes.GC.to_string reg ^ " has died.")
                          | MLWorks.Internal.Array.Subscript =>
			      crash ("Register " ^ MirTypes.GC.to_string reg ^
				     " was assigned outside " ^
				     "the alive array."))
                    last

d482 17
@


1.24.4.1
log
@branched from 1.24
@
text
@a11 4
 * Revision 1.24  1996/11/06  11:09:04  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.24.3.1
log
@branched from 1.24
@
text
@a11 4
 * Revision 1.24  1996/11/06  11:09:04  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.24.3.1.1.1
log
@branched from 1.24.3.1
@
text
@a11 3
 * Revision 1.24.3.1  1996/12/17  17:46:21  hope
 * branched from 1.24
 *
@


1.24.2.1
log
@branched from 1.24
@
text
@a11 4
 * Revision 1.24  1996/11/06  11:09:04  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.24.1.1
log
@branched from 1.24
@
text
@a11 4
 * Revision 1.24  1996/11/06  11:09:04  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.24.1.1.1.1
log
@branched from 1.24.1.1
@
text
@a11 3
 * Revision 1.24.1.1  1996/11/14  12:47:35  hope
 * branched from 1.24
 *
@


1.23
log
@Array moving to MLWorks.Array
@
text
@d12 3
d88 1
a88 1
require "../basis/__integer";
@


1.23.3.1
log
@branched from 1.23
@
text
@a11 3
 * Revision 1.23  1996/05/07  11:01:58  jont
 * Array moving to MLWorks.Array
 *
@


1.23.2.1
log
@branched from 1.23
@
text
@a11 3
 * Revision 1.23  1996/05/07  11:01:58  jont
 * Array moving to MLWorks.Array
 *
@


1.23.1.1
log
@branched from 1.23
@
text
@a11 3
 * Revision 1.23  1996/05/07  11:01:58  jont
 * Array moving to MLWorks.Array
 *
@


1.22
log
@Removing MLWorks.Integer
@
text
@d12 3
d431 1
a431 1
            val alive = Array.array (threshold + nr_packable, false)
d441 1
a441 1
                     Array.update (alive, 
d446 1
a446 1
                          | Array.Subscript =>
d465 1
a465 1
                                (Array.update (alive, next, true);
d469 1
a469 1
                                if Array.sub (alive, n) then
d472 1
a472 1
                                  (Array.update (alive, n, true);
@


1.21
log
@Adding where type clause
@
text
@d12 3
d82 2
d138 1
a138 1
      reducel (fn (text, (reg, r)) => text ^^ $"\n" ^^ MirTypes.GC.to_text reg ^^ $" -> " ^^ $(MLWorks.Integer.makestring r))
d488 1
a488 1
                              $"originally " ^^ $(MLWorks.Integer.makestring (threshold + nr_packable)) ^^ $" GC registers")
d569 1
a569 1
            then diagnostic (2, fn _ => $"longest block " ^^ $(MLWorks.Integer.makestring longest))
d578 1
a578 1
                                   $(MLWorks.Integer.makestring longest))
d589 1
a589 1
            then diagnostic (2, fn _ => $(MLWorks.Integer.makestring (#gc nr_registers)) ^^ $" GC registers")
@


1.20
log
@Add immediate store operations
@
text
@d12 3
d90 1
a101 1
  sharing type MirTables.MirTypes.GC.T = MirTables.MirTypes.NonGC.T = MirTables.MirTypes.FP.T = int
d103 5
a107 1
  sharing MirRegisters.MirTypes.GC.Set.Text = Diagnostic.Text) : REGISTERPACK =
@


1.19
log
@Use inthashtables for efficiency
@
text
@d12 3
d171 1
@


1.18
log
@Remove handler register concept
@
text
@d12 3
d76 1
d87 1
d114 8
d123 2
a124 2
      Lists.reducel (fn (text, (reg, r)) => text ^^ $"\n" ^^ MirTypes.GC.to_text reg ^^ $" -> " ^^ $(MLWorks.Integer.makestring r))
      ($"GC assignments", MirTypes.GC.Map.to_list assignment)
d126 13
d220 16
a235 17
    val initial_uses =
      let
        val fix =
          let
            val fixed = ref FIXED
          in
            map (fn reg => (reg, fixed))
          end
      in
        {gc     = MirTypes.GC.Map.from_list
	 (fix (MirTypes.GC.Pack.to_list (#gc MirRegisters.preassigned))),
         non_gc = MirTypes.NonGC.Map.from_list
	 (fix (MirTypes.NonGC.Pack.to_list
	       (#non_gc MirRegisters.preassigned))),
         fp     = MirTypes.FP.Map.from_list
	 (fix (MirTypes.FP.Pack.to_list (#fp MirRegisters.preassigned)))}
      end
a238 1

d242 2
a243 2
             (case MirTypes.GC.Map.tryApply' (uses, reg) of
                MirTypes.GC.Map.YES x => 
d250 1
a250 1
                  MirTypes.GC.Map.define (uses, reg, ref (ONCE tag))))
d254 2
a255 2
             (case MirTypes.NonGC.Map.tryApply' (uses, reg) of
                MirTypes.NonGC.Map.YES x => 
d262 1
a262 1
                  MirTypes.NonGC.Map.define (uses, reg, ref (ONCE tag))))
d266 2
a267 2
             (case MirTypes.FP.Map.tryApply' (uses, reg) of
                MirTypes.FP.Map.YES x => 
d274 1
a274 1
                  MirTypes.FP.Map.define (uses, reg, ref (ONCE tag))))
d286 4
a289 4
           case MirTypes.GC.Map.tryApply' (map, reg) of
             MirTypes.GC.Map.YES () => (map, new)
           | MirTypes.GC.Map.NO =>
               (MirTypes.GC.Map.define (map, reg, ()), reg::new))
d293 1
a293 1
             backward (uses, lifespans, MirTypes.GC.Map.empty, rev_opcodes_firsts)
d319 1
a319 1
        forward ([], uses, MirTypes.GC.Map.empty, opcodes)
a321 1

d331 11
a341 25
    val initial_assignments =
      let
        fun self_gc (empty, regs) =
          Lists.reducel
          (fn (map, reg) => MirTypes.GC.Map.define (map, reg, reg))
          (empty, regs)
        fun self_non_gc (empty, regs) =
          Lists.reducel
          (fn (map, reg) => MirTypes.NonGC.Map.define (map, reg, reg))
          (empty, regs)
        fun self_fp (empty, regs) =
          Lists.reducel
          (fn (map, reg) => MirTypes.FP.Map.define (map, reg, reg))
          (empty, regs)
      in
        {gc     = self_gc (MirTypes.GC.Map.empty,
			   MirTypes.GC.Pack.to_list
			   (#gc MirRegisters.preassigned)),
         non_gc = self_non_gc (MirTypes.NonGC.Map.empty,
			       MirTypes.NonGC.Pack.to_list
			       (#non_gc MirRegisters.preassigned)),
         fp     = self_fp (MirTypes.FP.Map.empty,
			   MirTypes.FP.Pack.to_list
			   (#fp MirRegisters.preassigned))}
      end
d350 1
a350 1
                            val reduce = Lists.reducel (fn (text, reg) => text ^^ $" " ^^ MirTypes.GC.to_text reg)
d352 1
a352 1
                            Lists.reducel
d358 2
d370 1
a370 1
              Lists.reducel
d372 1
a372 1
	       (MirTypes.GC.Map.define (assignment, reg, next), next+1, others)
d377 1
a377 1
              ((assignment, next, 0), MirTypes.GC.Map.to_list map)
d380 1
a380 1
              (Lists.reducel
d382 2
a383 2
		(MirTypes.NonGC.Map.define (assignment, reg, next), next+1))
               ((assignment, next), MirTypes.NonGC.Map.to_list map))
d386 1
a386 1
              (Lists.reducel
d388 2
a389 2
		(MirTypes.FP.Map.define (assignment, reg, next), next+1))
               ((assignment, next), MirTypes.FP.Map.to_list map))
d422 3
a424 3
                     Array.update (alive, MirTypes.GC.Map.apply'
				   (assignment, reg), false)
                     handle MirTypes.GC.Map.Undefined   =>
d438 1
a438 1
                    Lists.reducel
d440 3
a442 3
                     (case MirTypes.GC.Map.tryApply' (assignment, reg) of
                        MirTypes.GC.Map.YES _ => (assignment, next)
                      | MirTypes.GC.Map.NO =>
d447 1
a447 1
                                 (MirTypes.GC.Map.define
d454 1
a454 1
                                   (MirTypes.GC.Map.define
d494 4
a497 4
        (case MirTypes.GC.Map.tryApply' (map, reg) of
           MirTypes.GC.Map.YES _ => (next, map)
         | MirTypes.GC.Map.NO =>
             (next+1, MirTypes.GC.Map.define (map, reg, next)))
d499 3
a501 4
        (case MirTypes.NonGC.Map.tryApply' (map, reg) of
           MirTypes.NonGC.Map.YES _ => (next, map)
         | MirTypes.NonGC.Map.NO =>
             (next+1, MirTypes.NonGC.Map.define (map, reg, next)))
d503 3
a505 4
        (case MirTypes.FP.Map.tryApply' (map, reg) of
           MirTypes.FP.Map.YES _ => (next, map)
         | MirTypes.FP.Map.NO =>
             (next+1, MirTypes.FP.Map.define (map, reg, next)))
d544 1
a544 1
          Lists.reducel (fn (longest, MirTypes.BLOCK (_, opcodes)) =>
d566 2
a567 2
          if do_full_analysis then
            (assign (Lists.reducel scan ((initial_uses, []), blocks)))
d569 1
a569 1
            (Lists.reducel pack_simply ((MirRegisters.pack_next, initial_assignments), blocks))
d584 3
a586 3
            val gc'     = MirTypes.GC.Map.apply gc
            val non_gc' = MirTypes.NonGC.Map.apply non_gc
            val fp'     = MirTypes.FP.Map.apply fp
@


1.17
log
@Simplifications.
@
text
@d12 3
d161 2
a162 1
         | opcode as NEW_HANDLER _      => opcode
@


1.16
log
@Added function argument register lists to BRANCH_AND_LINK, TAIL_CALL and ENTER
@
text
@d12 3
d86 2
d95 2
d298 1
a298 1
     *  packed virtual registers from the unpacked registers in the opcodes
d306 1
a306 1
        fun self_gc (empty, unpack, regs) =
d308 1
a308 1
          (fn (map, reg) => MirTypes.GC.Map.define (map, reg, unpack reg))
d310 1
a310 1
        fun self_non_gc (empty, unpack, regs) =
d312 1
a312 1
          (fn (map, reg) => MirTypes.NonGC.Map.define (map, reg, unpack reg))
d314 1
a314 1
        fun self_fp (empty, unpack, regs) =
d316 1
a316 1
          (fn (map, reg) => MirTypes.FP.Map.define (map, reg, unpack reg))
d319 1
a319 1
        {gc     = self_gc (MirTypes.GC.Map.empty, MirTypes.GC.unpack,
d322 1
a322 1
         non_gc = self_non_gc (MirTypes.NonGC.Map.empty, MirTypes.NonGC.unpack,
d325 1
a325 1
         fp     = self_fp (MirTypes.FP.Map.empty, MirTypes.FP.unpack,
d332 12
a343 8
        val _ = diagnostic (4, fn _ =>
                            let
                              val reduce = Lists.reducel (fn (text, reg) => text ^^ $" " ^^ MirTypes.GC.to_text reg)
                            in
                              Lists.reducel
                              (fn (text, (first, last)) => reduce (reduce (text ^^ $"\n", first) ^^ $" / ", last))
                              ($"assigning for lifespans", lifespans)
                            end)
d453 6
a458 2
            val _ = diagnostic (2, fn _ =>
                                $"originally " ^^ $(MLWorks.Integer.makestring (threshold + nr_packable)) ^^ $" GC registers")
d525 4
a528 1
        val _ = diagnostic (1, fn _ => $"procedure " ^^ $(MirTypes.print_tag start_tag) ^^ $": " ^^ $name)
d538 13
a550 1
        val _ = diagnostic (2, fn _ => $"longest block " ^^ $(MLWorks.Integer.makestring longest))
d553 2
a554 3
          if longest > full_analysis_threshold then
            (diagnostic (2, fn _ => $"full analysis");
             assign (Lists.reducel scan ((initial_uses, []), blocks)))
d556 1
a556 4
            (diagnostic (2, fn _ => $"fast analysis");
             Lists.reducel pack_simply ((MirRegisters.pack_next, initial_assignments), blocks))

        val _ = diagnostic (2, fn _ => $(MLWorks.Integer.makestring (#gc nr_registers)) ^^ $" GC registers")
d558 9
a566 1
        val _ = diagnostic (3, fn _ => assignment_to_text (#gc assignments))
d575 3
a577 3
            {gc     = fn reg => MirTypes.GC.pack (gc' reg),
             non_gc = fn reg => MirTypes.NonGC.pack (non_gc' reg),
             fp     = fn reg => MirTypes.FP.pack (fp' reg)}
@


1.15
log
@Fix deep recursion in scan routine.
@
text
@d12 3
d108 4
d120 1
d138 2
a139 1
         | TAIL_CALL (operator, REG reg1)            => TAIL_CALL (operator, REG (reg reg1))
d145 2
a146 1
         | BRANCH_AND_LINK (operator, REG reg1,debug)             => BRANCH_AND_LINK (operator, REG (reg reg1),debug)
d149 1
a149 1
         | opcode as ENTER              => opcode
a155 2
         | opcode as BRANCH_AND_LINK _  => opcode
         | opcode as TAIL_CALL _        => opcode
@


1.14
log
@Added handling of INTERRUPT instruction
@
text
@d12 3
d64 1
d76 1
d80 1
a80 1
  sharing MirTables.MirTypes = MirRegisters.MirTypes
d193 39
a231 85
    local
      val empty_gc_life = MirTypes.GC.Map.empty
    in

      fun scan ((uses, lifespans), MirTypes.BLOCK (tag, opcodes)) =
        let
          val _ = diagnostic (2, fn _ => $"scanning block " ^^ $(MirTypes.print_tag tag))

          fun scan' (life, []) = (uses, lifespans)
            | scan' (life, (MirTypes.COMMENT _)::opcodes) = scan' (life, opcodes)
            | scan' (life, opcode::opcodes) =
              let
                val {gc = gc_defined, non_gc = non_gc_defined, fp = fp_defined} = MirTables.defined_by opcode

                val (life, first) =
                  MirTypes.GC.Set.reduce
                  (fn ((life, first), reg) =>
                   (case MirTypes.GC.Map.tryApply' (life, reg) of
                      MirTypes.GC.Map.YES _ => (life, first)
                    | MirTypes.GC.Map.NO =>
                        (MirTypes.GC.Map.define (life, reg, ref false), reg::first)))
                  ((life, []), gc_defined)

                val (uses, rest) = scan' (life, opcodes)

                val {gc = gc_referenced, non_gc = non_gc_referenced, fp = fp_referenced} = MirTables.referenced_by opcode

                val last =
                  MirTypes.GC.Set.reduce
                  (fn (last, reg) =>
                   (case MirTypes.GC.Map.tryApply' (life, reg) of
                     MirTypes.GC.Map.YES x =>
                        (case x of 
                           ref true => last
                         | other => (other := true; reg::last))
                    | MirTypes.GC.Map.NO => last))
                  ([], gc_referenced)

                val uses' =
                  let
                    fun count_gc (uses, reg) =
                      (case MirTypes.GC.Map.tryApply' (uses, reg) of
                         MirTypes.GC.Map.YES x => 
                           ((case x of 
                               ref MANY  => ()
                             | ref FIXED => ()
                             | other as ref (ONCE tag') => if tag=tag' then () else other := MANY);
                               uses)
                       | _ =>
                           MirTypes.GC.Map.define (uses, reg, ref (ONCE tag)))
                    fun count_non_gc (uses, reg) =
                      (case MirTypes.NonGC.Map.tryApply' (uses, reg) of
                         MirTypes.NonGC.Map.YES x => 
                           ((case x of 
                               ref MANY  => ()
                             | ref FIXED => ()
                             | other as ref (ONCE tag') => if tag=tag' then () else other := MANY);
                               uses)
                       | _ =>
                           MirTypes.NonGC.Map.define (uses, reg, ref (ONCE tag)))

                    fun count_fp (uses, reg) =
                      (case MirTypes.FP.Map.tryApply' (uses, reg) of
                         MirTypes.FP.Map.YES x => 
                           ((case x of 
                               ref MANY  => ()
                             | ref FIXED => ()
                             | other as ref (ONCE tag') => if tag=tag' then () else other := MANY);
                               uses)
                       | _ =>
                           MirTypes.FP.Map.define (uses, reg, ref (ONCE tag)))

                    val count_gc     = MirTypes.GC.Set.reduce count_gc
                    val count_non_gc = MirTypes.NonGC.Set.reduce count_non_gc
                    val count_fp     = MirTypes.FP.Set.reduce count_fp

                    val {gc = gc_uses, non_gc = non_gc_uses, fp = fp_uses} = uses
                  in
                    {gc     = count_gc     (count_gc     (gc_uses, gc_defined),         gc_referenced),
                     non_gc = count_non_gc (count_non_gc (non_gc_uses, non_gc_defined), non_gc_referenced),
                     fp     = count_fp     (count_fp     (fp_uses, fp_defined),         fp_referenced)}
                  end
              in
                (uses', case (first, last) of ([], []) => rest | something => something::rest)
              end
d233 5
a237 1
          scan' (empty_gc_life, opcodes)
d240 34
a273 1
    end
d275 3
@


1.13
log
@Debugger Environments for local and closure variable inspection
in the debugger.
@
text
@d12 4
d133 1
@


1.13.1.1
log
@Fork for bug fixing
@
text
@a11 4
 *  Revision 1.13  1993/05/20  21:03:06  nosa
 *  Debugger Environments for local and closure variable inspection
 *  in the debugger.
 *
@


1.12
log
@Removed Integer parameter
@
text
@d12 3
d496 1
a496 1
    fun f (MirTypes.PROC (name, start_tag, _, blocks)) =
@


1.11
log
@Changed PROFILE instruction to INTERCEPT.
@
text
@d12 3
a53 1
require "../utils/integer";
a64 1
  structure Integer	 : INTEGER
d85 1
a85 1
      Lists.reducel (fn (text, (reg, r)) => text ^^ $"\n" ^^ MirTypes.GC.to_text reg ^^ $" -> " ^^ $(Integer.makestring r))
d428 1
a428 1
                                $"originally " ^^ $(Integer.makestring (threshold + nr_packable)) ^^ $" GC registers")
d505 1
a505 1
        val _ = diagnostic (2, fn _ => $"longest block " ^^ $(Integer.makestring longest))
d515 1
a515 1
        val _ = diagnostic (2, fn _ => $(Integer.makestring (#gc nr_registers)) ^^ $" GC registers")
@


1.10
log
@Map substructure is now MirTypes.Map
@
text
@d12 3
a120 1
         | PROFILER  reg1                            => PROFILER  (reg reg1)
d124 1
@


1.9
log
@Efficiency changes to use mononewmap for registers and tags
@
text
@d12 3
d69 1
a69 1
    structure Map = MirTypes.Debugger_Types.Datatypes.NewMap
@


1.8
log
@Removed some name clashes caused by open statements by remvoing the
offending opens
@
text
@d12 4
d79 1
a79 1
      ($"GC assignments", Map.to_list assignment)
d164 7
a170 3
        {gc     = Map.from_list' MirTypes.GC.order    (fix (MirTypes.GC.Pack.to_list    (#gc MirRegisters.preassigned))),
         non_gc = Map.from_list' MirTypes.NonGC.order (fix (MirTypes.NonGC.Pack.to_list (#non_gc MirRegisters.preassigned))),
         fp     = Map.from_list' MirTypes.FP.order    (fix (MirTypes.FP.Pack.to_list    (#fp MirRegisters.preassigned)))}
d174 1
a174 1
      val empty_gc_life = Map.empty' MirTypes.GC.order
d190 4
a193 4
                   (case Map.tryApply' (life, reg) of
                      Map.YES _ => (life, first)
                    | Map.NO =>
                        (Map.define (life, reg, ref false), reg::first)))
d203 2
a204 2
                   (case Map.tryApply' (life, reg) of
                      Map.YES x =>
d208 1
a208 1
                    | Map.NO => last))
d213 3
a215 3
                    fun count (uses, reg) =
                      (case Map.tryApply' (uses, reg) of
                         Map.YES x => 
d221 12
a232 2
                       | Map.NO =>
                           Map.define (uses, reg, ref (ONCE tag)))
d234 10
a243 3
                    val count_gc     = MirTypes.GC.Set.reduce count
                    val count_non_gc = MirTypes.NonGC.Set.reduce count
                    val count_fp     = MirTypes.FP.Set.reduce count
d245 4
d277 1
a277 1
        fun self (empty, unpack, regs) =
d279 1
a279 1
          (fn (map, reg) => Map.define (map, reg, unpack reg))
d281 8
d290 9
a298 3
        {gc     = self (Map.empty' MirTypes.GC.order,    MirTypes.GC.unpack,    MirTypes.GC.Pack.to_list (#gc MirRegisters.preassigned)),
         non_gc = self (Map.empty' MirTypes.NonGC.order, MirTypes.NonGC.unpack, MirTypes.NonGC.Pack.to_list (#non_gc MirRegisters.preassigned)),
         fp     = self (Map.empty' MirTypes.FP.order,    MirTypes.FP.unpack,    MirTypes.FP.Pack.to_list (#fp MirRegisters.preassigned))}
d323 7
a329 4
              (fn ((assignment, next, others), (reg, ref MANY))     => (Map.define (assignment, reg, next), next+1, others)
                | ((assignment, next, others), (reg, ref (ONCE _))) => (assignment, next, others+1)
                | ((assignment, next, others), (reg, ref FIXED))    => (assignment, next, others))
              ((assignment, next, 0), Map.to_list map)
d331 1
a331 1
            fun assign_simple' (assignment, next, map) =
d333 3
a335 2
               (fn ((assignment, next), (reg, _)) => (Map.define (assignment, reg, next), next+1))
               ((assignment, next), Map.to_list map))
d337 6
d349 1
a349 1
              assign_simple' (#non_gc initial_assignments, #non_gc MirRegisters.pack_next, non_gc_uses)
d352 1
a352 1
              assign_simple' (#fp initial_assignments, #fp MirRegisters.pack_next, fp_uses)
d374 9
a382 5
                     Array.update (alive, Map.apply' (assignment, reg), false)
                     handle Map.Undefined   => crash ("The unassigned register " ^ MirTypes.GC.to_string reg ^ 
                                                      " has died.")
                          | Array.Subscript => crash ("Register " ^ MirTypes.GC.to_string reg ^ " was assigned outside " ^
                                                      "the alive array."))
d392 3
a394 3
                     (case Map.tryApply' (assignment, reg) of
                        Map.YES _ => (assignment, next)
                      | Map.NO =>
d399 2
a400 1
                                 (Map.define (assignment, reg, next), next+1))
d406 2
a407 1
                                   (Map.define (assignment, reg, n), next))
d441 15
a455 5
      fun assign ((next, map), reg) =
        (case Map.tryApply' (map, reg) of
           Map.YES _ => (next, map)
         | Map.NO =>
             (next+1, Map.define (map, reg, next)))
d457 3
a459 3
      val gc_assign     = MirTypes.GC.Set.reduce    assign
      val non_gc_assign = MirTypes.NonGC.Set.reduce assign
      val fp_assign     = MirTypes.FP.Set.reduce    assign
d515 3
a517 3
            val gc'     = Map.apply gc
            val non_gc' = Map.apply non_gc
            val fp'     = Map.apply fp
@


1.7
log
@Got rid of some handles using tryApply and co
@
text
@d12 3
a152 2
        open MirTypes

d160 3
a162 3
        {gc     = Map.from_list' GC.order    (fix (GC.Pack.to_list    (#gc MirRegisters.preassigned))),
         non_gc = Map.from_list' NonGC.order (fix (NonGC.Pack.to_list (#non_gc MirRegisters.preassigned))),
         fp     = Map.from_list' FP.order    (fix (FP.Pack.to_list    (#fp MirRegisters.preassigned)))}
a251 2

        open MirTypes
d253 3
a255 3
        {gc     = self (Map.empty' GC.order,    GC.unpack,    GC.Pack.to_list (#gc MirRegisters.preassigned)),
         non_gc = self (Map.empty' NonGC.order, NonGC.unpack, NonGC.Pack.to_list (#non_gc MirRegisters.preassigned)),
         fp     = self (Map.empty' FP.order,    FP.unpack,    FP.Pack.to_list (#fp MirRegisters.preassigned))}
@


1.6
log
@Removed some redundant structures and sharing
@
text
@d12 3
d181 4
a184 3
                   (Map.apply' (life, reg); (life, first))
                   handle Map.Undefined =>
                     (Map.define (life, reg, ref false), reg::first))
d194 6
a199 4
                   (case Map.apply' (life, reg)
                      of ref true => last
                       | other => (other := true; reg::last))
                   handle Map.Undefined => last)
d205 9
a213 7
                      ((case Map.apply' (uses, reg)
                         of ref MANY  => ()
                          | ref FIXED => ()
                          | other as ref (ONCE tag') => if tag=tag' then () else other := MANY);
                       uses)
                      handle Map.Undefined =>
                        Map.define (uses, reg, ref (ONCE tag))
d323 2
a324 1
                     handle Map.Undefined   => crash ("The unassigned register " ^ MirTypes.GC.to_string reg ^ " has died.")
d336 17
a352 16
                     (Map.apply' (assignment, reg); (assignment, next))
                     handle Map.Undefined =>
                       let
                         fun find_dead n =
                           if n = next then
                             (Array.update (alive, next, true);
                              (Map.define (assignment, reg, next), next+1))
                           else
                             if Array.sub (alive, n) then
                               find_dead (n+1)
                             else
                               (Array.update (alive, n, true);
                                (Map.define (assignment, reg, n), next))
                       in
                         find_dead threshold
                       end)
d384 4
a387 3
        (Map.apply' (map, reg); (next, map))
        handle Map.Undefined =>
          (next+1, Map.define (map, reg, next))
@


1.5
log
@Added NULLARY opcode type and ALLOC_BYTEARRAY.
@
text
@d12 3
a31 2

require "../utils/newmap";
a35 1
require "mirtypes";
d41 7
a47 8
functor RegisterPack (structure MirTypes     : MIRTYPES
                      structure Map          : NEWMAP
                      structure Diagnostic   : DIAGNOSTIC
                      structure Crash        : CRASH
                      structure Lists        : LISTS
                      structure MirTables    : MIRTABLES
                      structure MirRegisters : MIRREGISTERS
                      structure Integer	     : INTEGER
d49 1
a49 1
                      val full_analysis_threshold : int
d51 2
a52 2
                      sharing MirTypes = MirTables.MirTypes = MirRegisters.MirTypes
                      sharing MirTypes.Text = Diagnostic.Text) : REGISTERPACK =
d54 1
a54 1
    structure MirTypes = MirTypes
d56 1
@


1.4
log
@Added type annotation information at application points
@
text
@d12 3
d88 1
@


1.3
log
@Added parameter to RAISE once again.
@
text
@d12 3
d104 1
a104 1
         | BRANCH_AND_LINK (operator, REG reg1)             => BRANCH_AND_LINK (operator, REG (reg reg1))
@


1.2
log
@Merged this module with the preallocator.  The module now does some
preliminary register allocation in order to reduce the number of
virtual registers knocking about and hence improve the performance
of the rest of the optimiser.
@
text
@d12 6
d99 1
a105 1
         | opcode as RAISE              => opcode
@


1.1
log
@Initial revision
@
text
@d11 4
a14 1
 *  $Log$
d22 1
d36 6
a41 1
                      sharing MirTypes = MirTables.MirTypes = MirRegisters.MirTypes) : REGISTERPACK =
d44 1
d52 1
d55 4
d109 19
a127 9
    val empty_gens =
      let
        fun self (map, r) = Map.define (map, r, r)
        val {gc, non_gc, fp} = MirRegisters.pack_next
      in
        {gc     = (gc, MirTypes.GC.Pack.reduce self (Map.empty' MirTypes.GC.order, #gc MirRegisters.preassigned)),
         non_gc = (non_gc, MirTypes.NonGC.Pack.reduce self (Map.empty' MirTypes.NonGC.order, #non_gc MirRegisters.preassigned)),
         fp     = (fp, MirTypes.FP.Pack.reduce self (Map.empty' MirTypes.FP.order, #fp MirRegisters.preassigned))}
      end
d129 2
d132 1
a132 1
    fun f (MirTypes.PROC (name, _, _, blocks)) =
d134 1
a134 1
        val _ = diagnostic (1, fn _ => $"procedure " ^^ $name)
d136 1
a136 1
        val gens =
d138 9
a146 9
            fun add trurl ((next, map), r) =
              (Map.apply' (map, r); (next, map))
              handle Map.Undefined =>
                (next+1,
                 Map.define (map, r, trurl next))
                
            val add_gcs     = MirTypes.GC.Set.reduce    (add MirTypes.GC.pack)
            val add_non_gcs = MirTypes.NonGC.Set.reduce (add MirTypes.NonGC.pack)
            val add_fps     = MirTypes.FP.Set.reduce    (add MirTypes.FP.pack)
d148 11
a158 1
            fun block (gens, MirTypes.BLOCK (_, opcodes)) =
d160 24
a183 1
                fun opcode (gens as {gc, non_gc, fp}, opcode) =
d185 14
a198 3
                    val {gc = gc_defined,
                         non_gc = non_gc_defined,
                         fp = fp_defined} = MirTables.defined_by opcode
d200 3
a202 3
                    {gc = add_gcs (gc, gc_defined),
                     non_gc = add_non_gcs (non_gc, non_gc_defined),
                     fp = add_fps (fp, fp_defined)}
d205 1
a205 1
                Lists.reducel opcode (gens, opcodes)
d207 134
d342 2
a343 1
            Lists.reducel block (empty_gens, blocks)
d346 85
a430 3
        val {gc = (gc_next, gc_map),
             non_gc = (non_gc_next, non_gc_map),
             fp = (fp_next, fp_map)} = gens
d432 2
a433 5
        {nr_registers = {gc = gc_next, non_gc = non_gc_next, fp = fp_next},
         substitute =
           substitute {gc     = Map.apply gc_map,
                       non_gc = Map.apply non_gc_map,
                       fp     = Map.apply fp_map}}
d436 1
a436 1
  end        
@
