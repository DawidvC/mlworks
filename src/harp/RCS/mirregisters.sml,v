head	1.37;
access;
symbols
	MLW_daveb_inline_1_4_99:1.37.3
	MLWorks_21c0_1999_03_25:1.37
	MLWorks_20c1_1998_08_20:1.37
	MLWorks_20c0_1998_08_04:1.37
	MLWorks_20b2c2_1998_06_19:1.37
	MLWorks_20b2_Windows_1998_06_12:1.37
	MLWorks_20b1c1_1998_05_07:1.37
	MLWorks_20b0_1998_04_07:1.37
	MLWorks_20b0_1998_03_20:1.37
	MLWorks_20m2_1998_02_16:1.37
	MLWorks_20m1_1997_10_23:1.37
	MLWorks_11r1:1.34.1.1.1.1.1
	MLWorks_workspace_97:1.37.2
	MLWorks_dt_wizard:1.37.1
	MLWorks_11c0_1997_09_09:1.34.1.1.1.1
	MLWorks_10r3:1.34.1.1.3
	MLWorks_10r2_551:1.34.1.1.2
	MLWorks_11:1.34.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.34.1.1
	MLWorks_20m0_1997_06_20:1.37
	MLWorks_1_0_r2c2_1997_06_14:1.34.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.34.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.34.1
	MLWorks_BugFix_1997_04_24:1.34
	MLWorks_1_0_r2_Win32_1997_04_11:1.34
	MLWorks_1_0_r2_Unix_1997_04_04:1.34
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.32.6.1.1
	MLWorks_gui_1996_12_18:1.32.7
	MLWorks_1_0_Win32_1996_12_17:1.32.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.32.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.32.4.1
	MLWorks_1_0_Irix_1996_11_28:1.32.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.32.5
	MLWorks_1_0_Unix_1996_11_14:1.32.4
	MLWorks_Open_Beta2_1996_10_11:1.32.3
	MLWorks_License_dev:1.32.2
	MLWorks_1_open_beta_1996_09_13:1.32.1
	MLWorks_Open_Beta_1996_08_22:1.32
	MLWorks_Beta_1996_07_02:1.32
	MLWorks_Beta_1996_06_07:1.32
	MLWorks_Beta_1996_06_06:1.32
	MLWorks_Beta_1996_06_05:1.32
	MLWorks_Beta_1996_06_03:1.32
	MLWorks_Beta_1996_05_31:1.32
	MLWorks_Beta_1996_05_30:1.32
	ML_beta_release_12/08/94:1.28
	ML_beta_release_03/08/94:1.28
	ML_revised_beta_release_25/05/94:1.26
	ML_final_beta_release_02/03/94:1.25
	mlworks-28-01-1994:1.25
	Release:1.25
	mlworks-beta-01-09-1993:1.25
	MLWorks-1-0-4-29/01/1993:1.22
	MLWorks-1-0-3-21/12/1992:1.22
	MLWorks-1-0-2-15/12/1992:1.22
	MLWorks-1-0-1-04/12/1992:1.22
	checkpoint_17_08_92:1.19;
locks; strict;
comment	@ * @;


1.37
date	97.05.13.13.03.16;	author jont;	state Exp;
branches
	1.37.1.1
	1.37.2.1
	1.37.3.1;
next	1.36;

1.36
date	97.05.01.12.37.21;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	97.04.24.15.39.28;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	97.01.16.18.20.10;	author jont;	state Exp;
branches
	1.34.1.1;
next	1.33;

1.33
date	96.12.03.14.20.54;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	95.12.20.12.45.07;	author jont;	state Exp;
branches
	1.32.1.1
	1.32.2.1
	1.32.3.1
	1.32.4.1
	1.32.5.1
	1.32.6.1
	1.32.7.1;
next	1.31;

1.31
date	95.05.30.11.09.35;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	94.09.29.15.52.29;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	94.08.08.09.54.08;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	94.07.25.11.44.41;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	94.07.13.10.49.23;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	94.03.04.12.28.03;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	93.08.05.10.22.48;	author richard;	state Exp;
branches
	1.25.1.1;
next	1.24;

1.24
date	93.05.28.14.43.06;	author nosa;	state Exp;
branches;
next	1.23;

1.23
date	93.02.01.16.24.50;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	92.11.02.17.13.24;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.10.02.17.05.58;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.08.26.13.53.29;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.06.22.11.47.54;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	92.06.08.10.40.16;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	92.06.03.16.05.45;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	92.05.27.12.10.40;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.02.27.16.03.42;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	92.02.10.10.47.16;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	92.01.21.12.22.19;	author clive;	state Exp;
branches;
next	1.12;

1.12
date	92.01.03.15.54.39;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	91.12.04.12.59.42;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	91.11.29.11.57.06;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	91.11.14.10.49.59;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	91.11.04.15.20.50;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	91.10.16.09.12.45;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.10.15.15.06.43;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	91.10.09.16.13.23;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	91.10.02.11.05.17;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.10.01.14.51.43;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.09.20.13.13.34;	author jont;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	91.09.18.11.46.22;	author jont;	state Exp;
branches;
next	;

1.2.1.1
date	91.09.26.13.39.52;	author richard;	state Exp;
branches;
next	;

1.25.1.1
date	93.08.05.10.22.48;	author jont;	state Exp;
branches;
next	;

1.32.1.1
date	96.09.13.11.14.00;	author hope;	state Exp;
branches;
next	;

1.32.2.1
date	96.10.07.16.04.31;	author hope;	state Exp;
branches;
next	;

1.32.3.1
date	96.10.17.11.22.44;	author hope;	state Exp;
branches;
next	;

1.32.4.1
date	96.11.14.12.46.58;	author hope;	state Exp;
branches
	1.32.4.1.1.1;
next	;

1.32.4.1.1.1
date	96.11.28.14.58.34;	author hope;	state Exp;
branches;
next	;

1.32.5.1
date	96.11.22.18.07.06;	author hope;	state Exp;
branches;
next	;

1.32.6.1
date	96.12.17.17.45.50;	author hope;	state Exp;
branches
	1.32.6.1.1.1;
next	;

1.32.6.1.1.1
date	97.02.24.11.35.20;	author hope;	state Exp;
branches;
next	;

1.32.7.1
date	96.12.18.09.39.48;	author hope;	state Exp;
branches;
next	;

1.34.1.1
date	97.05.12.10.32.09;	author hope;	state Exp;
branches
	1.34.1.1.1.1
	1.34.1.1.2.1
	1.34.1.1.3.1;
next	;

1.34.1.1.1.1
date	97.07.28.18.17.54;	author daveb;	state Exp;
branches
	1.34.1.1.1.1.1.1;
next	;

1.34.1.1.1.1.1.1
date	97.10.07.11.42.50;	author jkbrook;	state Exp;
branches;
next	;

1.34.1.1.2.1
date	97.09.08.17.11.28;	author daveb;	state Exp;
branches;
next	;

1.34.1.1.3.1
date	97.09.09.14.07.03;	author daveb;	state Exp;
branches;
next	;

1.37.1.1
date	97.09.10.19.21.44;	author brucem;	state Exp;
branches;
next	;

1.37.2.1
date	97.09.11.20.53.00;	author daveb;	state Exp;
branches;
next	;

1.37.3.1
date	99.04.01.17.55.54;	author daveb;	state Exp;
branches;
next	;


desc
@Special code generation registers such as fn_arg, fp etc
@


1.37
log
@[Bug #20038]
Add referenced_by_alloc
@
text
@(*  ==== MIR VIRTUAL REGISTER MODEL ===
 *              SIGNATURE
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This module defines the register use model for procedures in MIR code.
 *  It also defines sets of unique MIR registers and tables to map them onto
 *  real machine registers; these uniques can be used as _aliases_ for the
 *  real registers, allowing register allocation to take place entirely
 *  within the MIR environment.
 *
 *  Revision Log
 *  ------------
 *  $Log: mirregisters.sml,v $
 * Revision 1.36  1997/05/01  12:37:21  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.35  1997/04/24  15:39:28  jont
 * [Bug #20007]
 * Adding reserved_but_preferencable registers
 *
 * Revision 1.34  1997/01/16  18:20:10  jont
 * Add corrupted_by_alloc
 *
 * Revision 1.33  1996/12/03  14:20:54  matthew
 * Adding fp_arg_regs
 *
 * Revision 1.32  1995/12/20  12:45:07  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
 *  Revision 1.31  1995/05/30  11:09:35  matthew
 *  Simplifications
 *
 *  Revision 1.30  1994/09/29  15:52:29  jont
 *  Remove handler register concept
 *
 *  Revision 1.29  1994/08/08  09:54:08  matthew
 *  Changed *_arg2 reg to *_arg_regs
 *
 *  Revision 1.28  1994/07/25  11:44:41  matthew
 *  Added extra argument register.  A more general solution would be desirable.
 *
 *  Revision 1.27  1994/07/13  10:49:23  jont
 *  Fix to avoid lr unspilling alloc
 *
 *  Revision 1.26  1994/03/04  12:28:03  jont
 *  Changes for automatic_callee mechanism removal
 *  and moving machspec from machine to main
 *
 *  Revision 1.25  1993/08/05  10:22:48  richard
 *  Removed unnecessary defined_by_raise.
 *
 *  Revision 1.24  1993/05/28  14:43:06  nosa
 *  Changed Option.T to Option.opt.
 *
 *  Revision 1.23  1993/02/01  16:24:50  matthew
 *  Added sharing
 *
 *  Revision 1.22  1992/11/02  17:13:24  jont
 *  Reworked in terms of mononewmap
 *
 *  Revision 1.21  1992/10/02  17:05:58  clive
 *  Change to NewMap.empty which now takes < and = functions instead of the single-function
 *
 *  Revision 1.20  1992/08/26  13:53:29  jont
 *  Removed some redundant structures and sharing
 *
 *  Revision 1.19  1992/06/22  11:47:54  richard
 *  Added defined_by_raise.
 *
 *  Revision 1.18  1992/06/08  10:40:16  richard
 *  Added allocation_order.
 *
 *  Revision 1.17  1992/06/03  16:05:45  richard
 *  Temporaries are now sets of registers which are also reserved.
 *
 *  Revision 1.16  1992/05/27  12:10:40  richard
 *  Changed register Sets to Packs.
 *
 *  Revision 1.15  1992/02/27  16:03:42  richard
 *  Changed the way virtual registers are handled.  See MirTypes.
 *
 *  Revision 1.14  1992/02/10  10:47:16  richard
 *  Major changes to accommodate new version (2.1) of register allocator.
 *
 *  Revision 1.13  1992/01/21  12:22:19  clive
 *  Added implicit
 *
 *  Revision 1.12  1992/01/03  15:54:39  richard
 *  Added the zero register.
 *
 *  Revision 1.11  1991/12/04  12:59:42  richard
 *  Added ordered_general_purpose.
 *
 *  Revision 1.10  91/11/29  11:57:06  richard
 *  Corrected the definition of general_purpose and removed the
 *  useless definition of machine_register_aliases.
 *  
 *  Revision 1.9  91/11/14  10:49:59  richard
 *  Removed references to fp_double registers.
 *  
 *  Revision 1.8  91/11/04  15:20:50  richard
 *  Added general_purpose.
 *  
 *  Revision 1.7  91/10/16  09:12:45  richard
 *  Recommented and added corrupted_by_callee.
 *  
 *  Revision 1.6  91/10/15  15:06:43  richard
 *  Moved register assignments here from the register allocator functor.
 *  
 *  Revision 1.5  91/10/09  16:13:23  richard
 *  Added various new register definitions.
 *  
 *  Revision 1.4  91/10/02  11:05:17  jont
 *  Removed real register options, these are being done elsewhere
 *  
 *  Revision 1.3  91/10/01  14:51:43  richard
 *  Added global register.
 *  
 *  Revision 1.2  91/09/20  13:13:34  jont
 *  Removed temp_sp, not required
 *  
 *  Revision 1.1  91/09/18  11:46:22  jont
 *  Initial revision
 *)

require "../main/machspec";
require "mirtypes";


signature MIRREGISTERS =

  sig

    structure MirTypes	: MIRTYPES
    structure MachSpec	: MACHSPEC

    (*  === MACHINE REGISTER ALIASES ===
     *
     *  These tables map unique virtual (MIR) registers onto their machine
     *  register counterparts.  The virtual registers can then be used to do
     *  register allocation wholly within MIR.
     *)

    val machine_register_assignments :
      {gc	: (MachSpec.register) MirTypes.GC.Map.T,
       non_gc	: (MachSpec.register) MirTypes.NonGC.Map.T,
       fp	: (MachSpec.register) MirTypes.FP.Map.T}


    (*  === CALL MODEL ===
     *
     *  The following values define the way in which MIR registers are used
     *  inter- and intra-procedurally.
     *
     *  general_purpose
     *    sets of registers which can be used to hold general purpose values
     *    during a procedure: the registers available for register
     *    allocation.  These registers may be spilled onto the stack.
     *
     *  reserved
     *    sets of registers distinct from general_purpose which may not be
     *    used to hold any value except that assigned by the original code
     *    from the code generator (for example, the frame pointer).  These
     *    registers may not be spilled onto the stack.
     *
     *  preassigned
     *    sets of registers which should not be allocated to new virtual
     *    registers.  These are registers which have been effectively
     *    allocated by the code generator.  NOTE: These be general purpose
     *    or reserved registers.
     *
     *  temporary
     *    sets of reserved registers which can be used as temporaries when
     *    spilling.
     *
     *  Special purpose registers
     *
     *  caller_arg	The register used to pass an argument to a
     *  		procedure.
     *  callee_arg	The argument
     *  		from the caller is found in this register.
     *  caller_closure	The register used to pass the closure to a
     *  		procedure.
     *  callee_closure  As for callee_arg.
     *  tail_arg        The register used to pass an argument to a tail call.
     *                  Will be either caller_arg or callee_arg as appropriate
     *  tail_closure    As for tail_arg
     *
     *  fp		The pointer to the procedure stack frame.
     *  sp		The stack pointer.
     *  global		A scratch register which is unaffected by the
     *  		PREVIOUS_ENVIRONMENT instruction.
     *
     *  defined_on_entry
     *    The set of registers which contain values on entry to the
     *    procedure.  These will be the registers defined as arguments to
     *    the procedure or necessary to the call mechanism.
     *
     *  defined_on_exit
     *    The set of registers which must contain values on exit to the
     *    procedure.  These will be registers returned to the caller or
     *    necessary to the call mechanism.
     *
     *  corrupted_by_callee
     *    The set of registers which may be overwritten by a procedure.
     *    These are sets of virtual registers --- they are the ones which
     *    map on to the real registers which are corrupted under the
     *    machine_register_assignments (see above).  They are therefore
     *    in preassigned.
     *
     *  zero
     *    This register is present if target machine has a `zero' register
     *    which can be used instead of a literal zero and as a data sink.
     *)

    val general_purpose :
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}

    val debugging_general_purpose :
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}

    val gp_for_preferencing :
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}

    val debugging_gp_for_preferencing :
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}

    val allocation_order :
      {gc	: MirTypes.GC.T * MirTypes.GC.T -> bool,
       non_gc	: MirTypes.NonGC.T * MirTypes.NonGC.T -> bool,
       fp	: MirTypes.FP.T * MirTypes.FP.T -> bool}

    val allocation_equal :
      {gc	: MirTypes.GC.T * MirTypes.GC.T -> bool,
       non_gc	: MirTypes.NonGC.T * MirTypes.NonGC.T -> bool,
       fp	: MirTypes.FP.T * MirTypes.FP.T -> bool}

    val preassigned :
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}

    val temporary :
      {gc	: MirTypes.GC.T list,
       non_gc	: MirTypes.NonGC.T list,
       fp	: MirTypes.FP.T list}
      
    val caller_arg :		MirTypes.GC.T
    val callee_arg :		MirTypes.GC.T
    val caller_arg_regs :       MirTypes.GC.T list
    val callee_arg_regs :	MirTypes.GC.T list
    val caller_closure :	MirTypes.GC.T
    val callee_closure :	MirTypes.GC.T
    val tail_arg :		MirTypes.GC.T
    val tail_arg_regs :    	MirTypes.GC.T list
    val tail_closure :		MirTypes.GC.T
    val fp :	 		MirTypes.GC.T
    val sp :			MirTypes.GC.T
    val global :		MirTypes.GC.T
    val implicit :		MirTypes.GC.T
    val zero :			MirTypes.GC.T option

    val fp_arg_regs:            MirTypes.FP.T list

    val defined_on_entry :
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}

    val defined_on_exit :
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}

    val corrupted_by_callee :
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}

    val corrupted_by_alloc :
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}

    val referenced_by_alloc :
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}

    val pack_next : {gc : int, non_gc : int, fp : int}

  end
@


1.37.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a16 4
 * Revision 1.37  1997/05/13  13:03:16  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
@


1.37.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a16 4
 * Revision 1.37  1997/05/13  13:03:16  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
@


1.37.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a16 4
 * Revision 1.37  1997/05/13  13:03:16  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
@


1.36
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d17 4
d294 5
@


1.35
log
@[Bug #20007]
[Bug #20007]
Adding reserved_but_preferencable registers
@
text
@d17 4
d270 1
a270 1
    val zero :			MirTypes.GC.T MLWorks.Option.option
@


1.34
log
@Add corrupted_by_alloc
@
text
@d17 3
d219 10
@


1.34.1.1
log
@branched from 1.34
@
text
@a16 3
 * Revision 1.34  1997/01/16  18:20:10  jont
 * Add corrupted_by_alloc
 *
@


1.34.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a16 3
 * Revision 1.34.1.1  1997/05/12  10:32:09  hope
 * branched from 1.34
 *
@


1.34.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a16 3
 * Revision 1.34.1.1  1997/05/12  10:32:09  hope
 * branched from 1.34
 *
@


1.34.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a16 3
 * Revision 1.34.1.1  1997/05/12  10:32:09  hope
 * branched from 1.34
 *
@


1.34.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a16 3
 * Revision 1.34.1.1.1.1  1997/07/28  18:17:54  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.33
log
@Adding fp_arg_regs
@
text
@d17 3
d268 5
@


1.32
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d17 4
d251 2
@


1.32.7.1
log
@branched from 1.32
@
text
@a16 4
 * Revision 1.32  1995/12/20  12:45:07  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.32.6.1
log
@branched from 1.32
@
text
@a16 4
 * Revision 1.32  1995/12/20  12:45:07  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.32.6.1.1.1
log
@branched from 1.32.6.1
@
text
@a16 3
 * Revision 1.32.6.1  1996/12/17  17:45:50  hope
 * branched from 1.32
 *
@


1.32.5.1
log
@branched from 1.32
@
text
@a16 4
 * Revision 1.32  1995/12/20  12:45:07  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.32.4.1
log
@branched from 1.32
@
text
@a16 4
 * Revision 1.32  1995/12/20  12:45:07  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.32.4.1.1.1
log
@branched from 1.32.4.1
@
text
@a16 3
 * Revision 1.32.4.1  1996/11/14  12:46:58  hope
 * branched from 1.32
 *
@


1.32.3.1
log
@branched from 1.32
@
text
@a16 4
 * Revision 1.32  1995/12/20  12:45:07  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.32.2.1
log
@branched from 1.32
@
text
@a16 4
 * Revision 1.32  1995/12/20  12:45:07  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.32.1.1
log
@branched from 1.32
@
text
@a16 4
 * Revision 1.32  1995/12/20  12:45:07  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.31
log
@Simplifications
@
text
@d17 3
a112 1
require "../utils/option";
a122 3
    structure Option	: OPTION

    sharing Option = MachSpec.Option = MirTypes.Option
d246 1
a246 1
    val zero :			MirTypes.GC.T Option.opt
@


1.30
log
@Remove handler register concept
@
text
@d17 3
d209 5
a222 5

    val reserved :
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}
@


1.29
log
@Changed *_arg2 reg to *_arg_regs
@
text
@d17 3
a175 4
     *  handler		This register points to the currently active
     *  		handler record. The handler record contains
     *  		information about what to do when an exception
     *  		is raised.
a241 1
    val handler :		MirTypes.GC.T
@


1.28
log
@Added extra argument register.  A more general solution would be desirable.
@
text
@d17 3
d117 1
a117 1
    sharing Option = MachSpec.Option
d234 2
a235 2
    val caller_arg2 :		MirTypes.GC.T
    val callee_arg2 :		MirTypes.GC.T
d239 1
a239 1
    val tail_arg2 :		MirTypes.GC.T
@


1.27
log
@Fix to avoid lr unspilling alloc
@
text
@d17 3
d231 2
d236 1
@


1.26
log
@Changes for automatic_callee mechanism removal
and moving machspec from machine to main
@
text
@d17 4
d222 4
a225 4
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}

@


1.25
log
@Removed unnecessary defined_by_raise.
@
text
@d17 3
d95 1
a95 1
require "../machine/machspec";
d151 2
a152 3
     *  		procedure. This may be moved automatically to
     *  		callee_arg (see automatic_callee below).
     *  callee_arg	If automatic_callee is true then the argument
a153 1
     *  		Otherwise it is available for scratch use.
d155 1
a155 2
     *  		procedure. This may be moved in the same way
     *  		as the argument (see above).
d157 4
a179 5
     *  automatic_callee
     *    This is true if the caller_arg and caller_closure registers are
     *    implicitly moved (NOT copied) to the callee_arg and callee_closure
     *    registers on entry to a procedure, and back on exit.
     *
d226 2
a248 2

    val automatic_callee : bool
@


1.25.1.1
log
@Fork for bug fixing
@
text
@a16 3
 *  Revision 1.25  1993/08/05  10:22:48  richard
 *  Removed unnecessary defined_by_raise.
 *
@


1.24
log
@Changed Option.T to Option.opt.
@
text
@d17 3
a187 5
     *  defined_by_raise
     *    The set of registers which are overwritten when an exception is
     *    raised, i.e., the set used by the raise code either as workspace
     *    or to pass values to the continuation code.
     *
a244 5
      {gc	: MirTypes.GC.Pack.T,
       non_gc	: MirTypes.NonGC.Pack.T,
       fp	: MirTypes.FP.Pack.T}

    val defined_by_raise :
@


1.23
log
@Added sharing
@
text
@d17 3
d234 1
a234 1
    val zero :			MirTypes.GC.T Option.T
@


1.22
log
@Reworked in terms of mononewmap
@
text
@d17 3
d98 1
@


1.21
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d17 3
d104 3
a106 3
      {gc	: (MirTypes.GC.T, MachSpec.register) MirTypes.Debugger_Types.Datatypes.NewMap.T,
       non_gc	: (MirTypes.NonGC.T, MachSpec.register) MirTypes.Debugger_Types.Datatypes.NewMap.T,
       fp	: (MirTypes.FP.T, MachSpec.register) MirTypes.Debugger_Types.Datatypes.NewMap.T}
@


1.20
log
@Removed some redundant structures and sharing
@
text
@d17 3
a189 1
    datatype relation = LESS | EQUAL | GREATER
d191 8
a198 3
      {gc	: MirTypes.GC.T * MirTypes.GC.T -> relation,
       non_gc	: MirTypes.NonGC.T * MirTypes.NonGC.T -> relation,
       fp	: MirTypes.FP.T * MirTypes.FP.T -> relation}
@


1.19
log
@Added defined_by_raise.
@
text
@d17 3
a75 3

require "../utils/set";
require "../utils/newmap";
a85 1
    structure Set	: SET
a86 1
    structure Map	: NEWMAP
d98 3
a100 3
      {gc	: (MirTypes.GC.T, MachSpec.register) Map.T,
       non_gc	: (MirTypes.NonGC.T, MachSpec.register) Map.T,
       fp	: (MirTypes.FP.T, MachSpec.register) Map.T}
@


1.18
log
@Added allocation_order.
@
text
@d17 3
d174 5
d232 5
@


1.17
log
@Temporaries are now sets of registers which are also reserved.
@
text
@d17 3
d180 6
@


1.16
log
@Changed register Sets to Packs.
@
text
@d17 3
d122 2
a123 2
     *    lists of preassigned registers which can be used as temporaries
     *    when spilling.  These are in order of preference.
d189 3
a191 3
      {gc	: MirTypes.GC.T list,
       non_gc	: MirTypes.NonGC.T list,
       fp	: MirTypes.FP.T list}
@


1.15
log
@Changed the way virtual registers are handled.  See MirTypes.
@
text
@d17 3
d171 3
a173 3
      {gc	: MirTypes.GC.T Set.Set,
       non_gc	: MirTypes.NonGC.T Set.Set,
       fp	: MirTypes.FP.T Set.Set}
d176 3
a178 3
      {gc	: MirTypes.GC.T Set.Set,
       non_gc	: MirTypes.NonGC.T Set.Set,
       fp	: MirTypes.FP.T Set.Set}
d181 3
a183 3
      {gc	: MirTypes.GC.T Set.Set,
       non_gc	: MirTypes.NonGC.T Set.Set,
       fp	: MirTypes.FP.T Set.Set}
d201 14
a214 1
    val defined_on_entry : MirTypes.GC.T Set.Set
d216 1
a216 1
    val defined_on_exit : MirTypes.GC.T Set.Set
d218 1
a218 3
    val corrupted_by_callee : MirTypes.any_register Set.Set

    val automatic_callee : bool
@


1.14
log
@Major changes to accommodate new version (2.1) of register allocator.
@
text
@d17 3
d88 3
a90 3
      {gc	: (MirTypes.gc_register, MachSpec.register) Map.T,
       non_gc	: (MirTypes.non_gc_register, MachSpec.register) Map.T,
       fp	: (MirTypes.fp_register, MachSpec.register) Map.T}
d168 3
a170 3
      {gc	: MirTypes.gc_register Set.Set,
       non_gc	: MirTypes.non_gc_register Set.Set,
       fp	: MirTypes.fp_register Set.Set}
d173 3
a175 3
      {gc	: MirTypes.gc_register Set.Set,
       non_gc	: MirTypes.non_gc_register Set.Set,
       fp	: MirTypes.fp_register Set.Set}
d178 3
a180 3
      {gc	: MirTypes.gc_register Set.Set,
       non_gc	: MirTypes.non_gc_register Set.Set,
       fp	: MirTypes.fp_register Set.Set}
d183 3
a185 3
      {gc	: MirTypes.gc_register list,
       non_gc	: MirTypes.non_gc_register list,
       fp	: MirTypes.fp_register list}
d187 10
a196 10
    val caller_arg :		MirTypes.gc_register
    val callee_arg :		MirTypes.gc_register
    val caller_closure :	MirTypes.gc_register
    val callee_closure :	MirTypes.gc_register
    val fp :	 		MirTypes.gc_register
    val sp :			MirTypes.gc_register
    val handler :		MirTypes.gc_register
    val global :		MirTypes.gc_register
    val implicit :		MirTypes.gc_register
    val zero :			MirTypes.gc_register Option.T
d198 1
a198 1
    val defined_on_entry : MirTypes.gc_register Set.Set
d200 1
a200 1
    val defined_on_exit : MirTypes.gc_register Set.Set
@


1.13
log
@Added implicit
@
text
@d17 3
d60 1
a60 1
require "../utils/table";
d73 1
a73 1
    structure Table	: TABLE
d85 3
a87 3
      {gc	: (MirTypes.gc_register, MachSpec.register) Table.table,
       non_gc	: (MirTypes.non_gc_register, MachSpec.register) Table.table,
       fp	: (MirTypes.fp_register, MachSpec.register) Table.table}
d98 1
a98 1
     *    allocation.
d100 5
a104 5
     *  ordered_general_purpose
     *    The same registers as general_purpose, but as a list of sets.
     *    Registers should be allocated from the first set (allocations
     *    should be spread out as much as possible within a set), and only
     *    from the second set if necessary, then from the third, etc.
d109 2
a110 4
     *    allocated by the code generator.  NOTE: These may still be general
     *    purpose registers, it's just that they can't be allocated to
     *    different registers.  The preassigned registers are mapped to
     *    machine registers in the machine_register_assignments (see above).
d112 3
a114 3
     *  spillable
     *    sets of registers which it is possible to spill into the stack
     *    frame if necessary.
d153 1
a153 1
     *    The sets of registers which may be overwritten by a procedure.
d156 2
a157 1
     *    machine_register_assignments (see above).
d169 1
a169 6
    val ordered_general_purpose :
      {gc	: MirTypes.gc_register Set.Set list,
       non_gc	: MirTypes.non_gc_register Set.Set list,
       fp	: MirTypes.fp_register Set.Set list}

    val preassigned :
d174 1
a174 1
    val spillable :
d179 5
d199 2
a201 6

    val corrupted_by_callee :
      {gc	: MirTypes.gc_register Set.Set,
       non_gc	: MirTypes.non_gc_register Set.Set,
       fp	: MirTypes.fp_register Set.Set}

@


1.12
log
@Added the zero register.
@
text
@d17 3
d190 1
@


1.11
log
@Added ordered_general_purpose.
@
text
@d16 4
a19 1
 *  $Log:	mirregisters.sml,v $
d55 1
d68 1
d153 4
d187 1
@


1.10
log
@Corrected the definition of general_purpose and removed the
useless definition of machine_register_aliases.
@
text
@d17 4
d89 6
d103 4
d155 5
d161 5
@


1.9
log
@Removed references to fp_double registers.
@
text
@d1 43
a43 5
(* mirregisters.sml the signature *)
(*
$Log:	mirregisters.sml,v $
Revision 1.8  91/11/04  15:20:50  richard
Added general_purpose.
a44 2
Revision 1.7  91/10/16  09:12:45  richard
Recommented and added corrupted_by_callee.
a45 21
Revision 1.6  91/10/15  15:06:43  richard
Moved register assignments here from the register allocator functor.

Revision 1.5  91/10/09  16:13:23  richard
Added various new register definitions.

Revision 1.4  91/10/02  11:05:17  jont
Removed real register options, these are being done elsewhere

Revision 1.3  91/10/01  14:51:43  richard
Added global register.

Revision 1.2  91/09/20  13:13:34  jont
Removed temp_sp, not required

Revision 1.1  91/09/18  11:46:22  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

d62 1
a62 1
    (*  === SPECIAL PURPOSE REGISTERS ===
d64 31
a94 1
     *  The following registers are reserved for a particular purpose:
d113 21
d136 10
a154 4

    (* A set of the above registers which are defined on entry to a *)
    (* procedure (i.e. set up by the caller). *)

a156 3
    (* A set of the above registers which must be defined on exit *)
    (* from a procedure (i.e. returned to the caller). *)

a158 6

    (* On some architectures (e.g. Sparc) the caller registers are *)
    (* `moved' (NOT copied) to the callee registers on entry to a *)
    (* procedure, and back on exit. These flag whether this is the *)
    (* case. *)

a160 40

    (* Some virtual registers are always mapped onto the same real *)
    (* machine registers (e.g. the stack pointer). This is a record of *)
    (* association lists (one for each register type) to perform these *)
    (* mappings. *)

    val preassigned :
      {gc	: (MirTypes.gc_register * MachSpec.register) list,
       non_gc	: (MirTypes.non_gc_register * MachSpec.register) list,
       fp	: (MirTypes.fp_register * MachSpec.register) list}


    (* The following are lists of unique virtual registers, and *)
    (* tables to map them onto real machine registers, for use by a *)
    (* register allocator and machine code generator. The registers *)
    (* should be used in the order of preference of the list. *)

    val machine_register_aliases :
      {gc	: MirTypes.gc_register list,
       non_gc	: MirTypes.non_gc_register list,
       fp	: MirTypes.fp_register list}

    val machine_register_assignments :
      {gc	: (MirTypes.gc_register, MachSpec.register) Table.table,
       non_gc	: (MirTypes.non_gc_register, MachSpec.register) Table.table,
       fp	: (MirTypes.fp_register, MachSpec.register) Table.table}


    (* The following subset of machine_register_aliases are for general *)
    (* purpose use, i.e. may be used for ordinary values. *)

    val general_purpose :
      {gc	: MirTypes.gc_register list,
       non_gc	: MirTypes.non_gc_register list,
       fp	: MirTypes.fp_register list}


    (* The following subset of machine_register_aliases may be *)
    (* corrupted by a procedure. *)

d165 1
@


1.8
log
@Added general_purpose.
@
text
@d4 3
d107 1
a107 2
       fp	: (MirTypes.fp_register * MachSpec.register) list,
       fp_double: (MirTypes.fp_double_register * MachSpec.register) list}
d118 1
a118 2
       fp	: MirTypes.fp_register list,
       fp_double: MirTypes.fp_double_register list}
d123 1
a123 2
       fp	: (MirTypes.fp_register, MachSpec.register) Table.table,
       fp_double: (MirTypes.fp_double_register, MachSpec.register) Table.table}
d132 1
a132 2
       fp	: MirTypes.fp_register list,
       fp_double: MirTypes.fp_double_register list}
d141 1
a141 2
       fp	: MirTypes.fp_register Set.Set,
       fp_double: MirTypes.fp_double_register Set.Set}
@


1.7
log
@Recommented and added corrupted_by_callee.
@
text
@d4 3
d124 10
@


1.6
log
@Moved register assignments here from the register allocator functor.
@
text
@d4 3
d40 24
d86 3
a88 3
    (* `moved' (NOT copied) to the callee registers by the *)
    (* PRESERVE_REGS, and back by the RESTORE_REGS. These flag whether *)
    (* this is the case. *)
d93 4
a96 3
    (* Some registers are always mapped onto the same real machine *)
    (* registers. This is a record of association lists (one for each *)
    (* register type) to perform these mappings. *)
d122 9
@


1.5
log
@Added various new register definitions.
@
text
@d4 3
d23 2
d27 1
d34 2
d64 30
@


1.4
log
@Removed real register options, these are being done elsewhere
@
text
@d4 3
d19 1
d22 1
a22 2
signature MIRREGISTERS = sig
  structure MirTypes : MIRTYPES
d24 34
a57 8
  val fn_arg: MirTypes.gc_register
  val cl_arg: MirTypes.gc_register
  val cl_arg': MirTypes.gc_register
  val fp:  MirTypes.gc_register
  val sp: MirTypes.gc_register
  val handler:  MirTypes.gc_register
  val global: MirTypes.gc_register
end
@


1.3
log
@Added global register.
@
text
@d4 3
d21 7
a27 7
  val fn_arg: MirTypes.gc_register * MirTypes.real_gc_reg MirTypes.Opt
  val cl_arg: MirTypes.gc_register * MirTypes.real_gc_reg MirTypes.Opt
  val cl_arg': MirTypes.gc_register * MirTypes.real_gc_reg MirTypes.Opt
  val fp:  MirTypes.gc_register * MirTypes.real_gc_reg MirTypes.Opt
  val sp: MirTypes.gc_register * MirTypes.real_gc_reg MirTypes.Opt
  val handler:  MirTypes.gc_register * MirTypes.real_gc_reg MirTypes.Opt
  val global: MirTypes.gc_register * MirTypes.real_gc_reg MirTypes.Opt
@


1.2
log
@Removed temp_sp, not required
@
text
@d4 3
d24 1
@


1.2.1.1
log
@This is a modified version to use the reworked MirTypes module
(ver 1.23.1.1). This module is correct, but work has been suspended
on this branch because of the amount of time it would take to convert
the code generator (Mir_Cg) module.
@
text
@a3 3
Revision 1.2  91/09/20  13:13:34  jont
Removed temp_sp, not required

d15 6
a20 7
  val fn_arg : MirTypes.operand
  val cl_arg : MirTypes.operand
  val cl_arg': MirTypes.operand
  val fp     : MirTypes.operand
  val sp     : MirTypes.operand
  val handler: MirTypes.operand
  val global : MirTypes.operand
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
a20 1
  val temp_sp: MirTypes.gc_register * MirTypes.real_gc_reg MirTypes.Opt
@
