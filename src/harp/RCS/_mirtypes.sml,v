head	1.88;
access;
symbols
	MLW_daveb_inline_1_4_99:1.88.3
	MLWorks_21c0_1999_03_25:1.88
	MLWorks_20c1_1998_08_20:1.88
	MLWorks_20c0_1998_08_04:1.88
	MLWorks_20b2c2_1998_06_19:1.88
	MLWorks_20b2_Windows_1998_06_12:1.88
	MLWorks_20b1c1_1998_05_07:1.88
	MLWorks_20b0_1998_04_07:1.88
	MLWorks_20b0_1998_03_20:1.88
	MLWorks_20m2_1998_02_16:1.88
	MLWorks_20m1_1997_10_23:1.88
	MLWorks_11r1:1.86.1.1.1.1.1
	MLWorks_workspace_97:1.88.2
	MLWorks_dt_wizard:1.88.1
	MLWorks_11c0_1997_09_09:1.86.1.1.1.1
	MLWorks_10r3:1.86.1.1.3
	MLWorks_10r2_551:1.86.1.1.2
	MLWorks_11:1.86.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.86.1.1
	MLWorks_20m0_1997_06_20:1.87
	MLWorks_1_0_r2c2_1997_06_14:1.86.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.86.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.86.1
	MLWorks_BugFix_1997_04_24:1.86
	MLWorks_1_0_r2_Win32_1997_04_11:1.86
	MLWorks_1_0_r2_Unix_1997_04_04:1.86
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.85.3.1.1
	MLWorks_gui_1996_12_18:1.85.4
	MLWorks_1_0_Win32_1996_12_17:1.85.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.85.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.85.1.1
	MLWorks_1_0_Irix_1996_11_28:1.85.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.85.2
	MLWorks_1_0_Unix_1996_11_14:1.85.1
	MLWorks_Open_Beta2_1996_10_11:1.84.3
	MLWorks_License_dev:1.84.2
	MLWorks_1_open_beta_1996_09_13:1.84.1
	MLWorks_Open_Beta_1996_08_22:1.84
	MLWorks_Beta_1996_07_02:1.84
	MLWorks_Beta_1996_06_07:1.84
	MLWorks_Beta_1996_06_06:1.84
	MLWorks_Beta_1996_06_05:1.84
	MLWorks_Beta_1996_06_03:1.84
	MLWorks_Beta_1996_05_31:1.84
	MLWorks_Beta_1996_05_30:1.84
	ML_beta_release_12/08/94:1.74
	ML_beta_release_03/08/94:1.74
	ML_revised_beta_release_25/05/94:1.73
	ML_final_beta_release_02/03/94:1.71
	mlworks-28-01-1994:1.71
	Release:1.69
	mlworks-beta-01-09-1993:1.69
	MLWorks-1-0-4-29/01/1993:1.63
	MLWorks-1-0-3-21/12/1992:1.61
	MLWorks-1-0-2-15/12/1992:1.61
	MLWorks-1-0-1-04/12/1992:1.61
	checkpoint_17_08_92:1.56
	Ten15_release_19-08-91:1.8
	ten15_release:1.3;
locks; strict;
comment	@ * @;


1.88
date	97.07.31.12.57.37;	author jont;	state Exp;
branches
	1.88.1.1
	1.88.2.1
	1.88.3.1;
next	1.87;

1.87
date	97.05.01.12.35.16;	author jont;	state Exp;
branches;
next	1.86;

1.86
date	97.01.16.12.33.50;	author matthew;	state Exp;
branches
	1.86.1.1;
next	1.85;

1.85
date	96.11.06.11.07.36;	author matthew;	state Exp;
branches
	1.85.1.1
	1.85.2.1
	1.85.3.1
	1.85.4.1;
next	1.84;

1.84
date	96.05.14.10.17.10;	author matthew;	state Exp;
branches
	1.84.1.1
	1.84.2.1
	1.84.3.1;
next	1.83;

1.83
date	96.04.29.14.48.00;	author matthew;	state Exp;
branches;
next	1.82;

1.82
date	96.02.02.10.58.08;	author jont;	state Exp;
branches;
next	1.81;

1.81
date	95.12.20.12.43.09;	author jont;	state Exp;
branches;
next	1.80;

1.80
date	95.01.04.12.55.48;	author matthew;	state Exp;
branches;
next	1.79;

1.79
date	94.11.23.14.00.01;	author matthew;	state Exp;
branches;
next	1.78;

1.78
date	94.11.11.14.04.56;	author jont;	state Exp;
branches;
next	1.77;

1.77
date	94.09.30.12.44.23;	author jont;	state Exp;
branches;
next	1.76;

1.76
date	94.09.14.13.50.15;	author matthew;	state Exp;
branches;
next	1.75;

1.75
date	94.08.25.13.31.15;	author matthew;	state Exp;
branches;
next	1.74;

1.74
date	94.07.21.15.50.35;	author matthew;	state Exp;
branches;
next	1.73;

1.73
date	94.05.12.12.40.37;	author richard;	state Exp;
branches;
next	1.72;

1.72
date	94.03.09.14.57.30;	author jont;	state Exp;
branches;
next	1.71;

1.71
date	94.01.17.18.36.19;	author daveb;	state Exp;
branches;
next	1.70;

1.70
date	93.11.04.16.30.02;	author jont;	state Exp;
branches;
next	1.69;

1.69
date	93.07.29.14.23.29;	author nosa;	state Exp;
branches
	1.69.1.1;
next	1.68;

1.68
date	93.05.18.14.36.47;	author jont;	state Exp;
branches;
next	1.67;

1.67
date	93.04.27.10.58.55;	author richard;	state Exp;
branches;
next	1.66;

1.66
date	93.03.10.18.00.53;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	93.03.04.13.23.43;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	93.03.01.14.06.07;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	93.01.28.09.54.36;	author jont;	state Exp;
branches;
next	1.62;

1.62
date	93.01.04.17.00.46;	author jont;	state Exp;
branches;
next	1.61;

1.61
date	92.12.01.12.57.58;	author daveb;	state Exp;
branches;
next	1.60;

1.60
date	92.11.02.13.16.17;	author richard;	state Exp;
branches;
next	1.59;

1.59
date	92.10.29.18.03.03;	author jont;	state Exp;
branches;
next	1.58;

1.58
date	92.08.26.13.33.01;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	92.08.24.13.10.35;	author richard;	state Exp;
branches;
next	1.56;

1.56
date	92.06.29.08.08.40;	author clive;	state Exp;
branches;
next	1.55;

1.55
date	92.06.18.16.12.35;	author richard;	state Exp;
branches;
next	1.54;

1.54
date	92.06.16.19.15.13;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	92.05.06.17.14.57;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	92.04.13.15.15.08;	author clive;	state Exp;
branches;
next	1.51;

1.51
date	92.03.31.14.15.21;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	92.02.27.15.37.22;	author richard;	state Exp;
branches;
next	1.49;

1.49
date	92.02.07.12.47.46;	author richard;	state Exp;
branches;
next	1.48;

1.48
date	92.01.16.11.18.59;	author clive;	state Exp;
branches;
next	1.47;

1.47
date	92.01.14.13.48.06;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	91.12.02.13.57.52;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	91.11.20.12.20.50;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	91.11.14.15.20.48;	author richard;	state Exp;
branches;
next	1.43;

1.43
date	91.11.14.10.43.35;	author richard;	state Exp;
branches;
next	1.42;

1.42
date	91.11.08.16.08.49;	author richard;	state Exp;
branches;
next	1.41;

1.41
date	91.10.28.15.16.50;	author richard;	state Exp;
branches;
next	1.40;

1.40
date	91.10.28.11.23.41;	author davidt;	state Exp;
branches;
next	1.39;

1.39
date	91.10.24.10.40.51;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	91.10.21.09.30.24;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	91.10.17.14.17.30;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	91.10.16.14.14.25;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	91.10.15.15.10.32;	author richard;	state Exp;
branches;
next	1.34;

1.34
date	91.10.11.13.43.06;	author richard;	state Exp;
branches;
next	1.33;

1.33
date	91.10.11.09.55.58;	author richard;	state Exp;
branches;
next	1.32;

1.32
date	91.10.10.13.44.42;	author richard;	state Exp;
branches;
next	1.31;

1.31
date	91.10.04.11.33.33;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	91.10.03.11.22.41;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	91.10.03.11.06.30;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	91.10.03.10.57.21;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	91.10.02.11.03.15;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	91.10.01.09.57.34;	author richard;	state Exp;
branches;
next	1.25;

1.25
date	91.09.30.10.04.18;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	91.09.25.14.54.28;	author richard;	state Exp;
branches
	1.24.1.1;
next	1.23;

1.23
date	91.09.24.10.41.56;	author richard;	state Exp;
branches;
next	1.22;

1.22
date	91.09.23.15.54.07;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	91.09.23.15.08.36;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	91.09.23.10.38.31;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	91.09.20.15.30.52;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	91.09.19.15.52.34;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	91.09.17.13.50.09;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	91.09.17.10.44.11;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	91.09.10.14.28.30;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	91.09.05.15.56.24;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	91.09.03.16.35.12;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	91.09.03.13.53.38;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	91.08.30.16.33.56;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.08.29.14.02.50;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.08.22.16.39.35;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.08.15.14.15.53;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.08.09.16.46.22;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.08.02.16.35.35;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.08.01.17.18.52;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.07.31.18.02.36;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.07.30.14.08.09;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.07.26.17.31.27;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.07.25.14.12.56;	author jont;	state Exp;
branches;
next	;

1.24.1.1
date	91.09.26.12.43.15;	author richard;	state Exp;
branches;
next	;

1.69.1.1
date	93.07.29.14.23.29;	author jont;	state Exp;
branches;
next	;

1.84.1.1
date	96.09.13.11.13.56;	author hope;	state Exp;
branches;
next	;

1.84.2.1
date	96.10.07.16.04.28;	author hope;	state Exp;
branches;
next	;

1.84.3.1
date	96.10.17.11.22.41;	author hope;	state Exp;
branches;
next	;

1.85.1.1
date	96.11.14.12.46.54;	author hope;	state Exp;
branches
	1.85.1.1.1.1;
next	;

1.85.1.1.1.1
date	96.11.28.14.58.31;	author hope;	state Exp;
branches;
next	;

1.85.2.1
date	96.11.22.18.07.03;	author hope;	state Exp;
branches;
next	;

1.85.3.1
date	96.12.17.17.45.47;	author hope;	state Exp;
branches
	1.85.3.1.1.1;
next	;

1.85.3.1.1.1
date	97.02.24.11.35.17;	author hope;	state Exp;
branches;
next	;

1.85.4.1
date	96.12.18.09.39.46;	author hope;	state Exp;
branches;
next	;

1.86.1.1
date	97.05.12.10.32.06;	author hope;	state Exp;
branches
	1.86.1.1.1.1
	1.86.1.1.2.1
	1.86.1.1.3.1;
next	;

1.86.1.1.1.1
date	97.07.28.18.17.51;	author daveb;	state Exp;
branches
	1.86.1.1.1.1.1.1;
next	;

1.86.1.1.1.1.1.1
date	97.10.07.11.42.46;	author jkbrook;	state Exp;
branches;
next	;

1.86.1.1.2.1
date	97.09.08.17.11.25;	author daveb;	state Exp;
branches;
next	;

1.86.1.1.3.1
date	97.09.09.14.07.01;	author daveb;	state Exp;
branches;
next	;

1.88.1.1
date	97.09.10.19.21.39;	author brucem;	state Exp;
branches;
next	;

1.88.2.1
date	97.09.11.20.52.56;	author daveb;	state Exp;
branches;
next	;

1.88.3.1
date	99.04.01.17.55.52;	author daveb;	state Exp;
branches;
next	;


desc
@Abstract description of the mir
@


1.88
log
@[Bug #30215]
Remove BIC, and replace by INTTAG instruction
@
text
@(* _mirtypes.sml the functor *)
(*
$Log: _mirtypes.sml,v $
 * Revision 1.87  1997/05/01  12:35:16  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.86  1997/01/16  12:33:50  matthew
 * Have tag list in tagged operations
 *
 * Revision 1.85  1996/11/06  11:07:36  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.84  1996/05/14  10:17:10  matthew
 * Adding NOT32 MIR instruction
 *
 * Revision 1.83  1996/04/29  14:48:00  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.82  1996/02/02  10:58:08  jont
 * Add ADDW, SUBW for untagged integer operations
 * with register cleaning on overflow
 *
Revision 1.81  1995/12/20  12:43:09  jont
Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend

Revision 1.80  1995/01/04  12:55:48  matthew
Renaming debugger_env to runtime_env

Revision 1.79  1994/11/23  14:00:01  matthew
Adding ALLOC_VECTOR

Revision 1.78  1994/11/11  14:04:56  jont
Add immediate store operations

Revision 1.77  1994/09/30  12:44:23  jont
Remove handler register concept

Revision 1.76  1994/09/14  13:50:15  matthew
Abstraction of debug information

Revision 1.75  1994/08/25  13:31:15  matthew
Simplifications of annotations

Revision 1.74  1994/07/21  15:50:35  matthew
Added function argument register lists to BRANCH_AND_LINK, TAIL_CALL and ENTER
Changed loop_entry in procedure parameters to be a tag list, so we can have lots.

Revision 1.73  1994/05/12  12:40:37  richard
Add loop entry point to procedure parameters.

Revision 1.72  1994/03/09  14:57:30  jont
Adding load offset instruction

Revision 1.71  1994/01/17  18:36:19  daveb
Removed unnecessary exceptions from closures.

Revision 1.70  1993/11/04  16:30:02  jont
Added INTERRUPT instruction

Revision 1.69  1993/07/29  14:23:29  nosa
Debugger Environments for local and closure variable inspection
in the debugger;
new stack spill slots;
structure Option.

Revision 1.68  1993/05/18  14:36:47  jont
Removed Integer parameter

Revision 1.67  1993/04/27  10:58:55  richard
Changed PROFILE instruction to INTERCEPT.

Revision 1.66  1993/03/10  18:00:53  matthew
Removed options
Added type SCon

Revision 1.65  1993/03/04  13:23:43  matthew
Options & Info changes

Revision 1.64  1993/03/01  14:06:07  matthew
Changed representation of value to include MLVALUEs

Revision 1.63  1993/01/28  09:54:36  jont
Added default options

Revision 1.62  1993/01/04  17:00:46  jont
Added code printing controls to options

Revision 1.61  1992/12/01  12:57:58  daveb
Changes to propagate compiler options as parameters instead of references.

Revision 1.60  1992/11/02  13:16:17  richard
Changed erroneous require.

Revision 1.59  1992/10/29  18:03:03  jont
Added Map structure for mononewmaps to allow efficient implementation
of lookup tables for integer based values

Revision 1.58  1992/08/26  13:33:01  jont
Removed some redundant structures and sharing

Revision 1.57  1992/08/24  13:10:35  richard
Added NULLARY opcode type and ALLOC_BYTEARRAY.

Revision 1.56  1992/06/29  08:08:40  clive
Added type annotation information at application points

Revision 1.55  1992/06/18  16:12:35  richard
Added parameter to RAISE once again.

Revision 1.54  1992/06/16  19:15:13  jont
Expanded refs section of mir_code to allow for interpretive stuff

Revision 1.53  1992/05/06  17:14:57  jont
Added int_of_tag function

Revision 1.52  1992/04/13  15:15:08  clive
First version of the profiler

Revision 1.51  1992/03/31  14:15:21  jont
Added require counter

Revision 1.50  1992/02/27  15:37:22  richard
Changed virtual registers to be structures in their own right.
See VirtualRegister module.

Revision 1.49.1.1  1992/02/27  15:37:22  richard
This version of MirTypes supplied monomorphic virtual register sets
as abstract types.

Revision 1.49  1992/02/07  12:47:46  richard
Abolished PRESERVE_ALL_REGS and PREVIOUS_ENVIRONMENT.
Added `hash_*_register'.

Revision 1.48  1992/01/16  11:18:59  clive
Alloc may now have a register argument for allocating arrays

Revision 1.47  1992/01/14  13:48:06  jont
Raise no longer has a parameter

Revision 1.46  1991/12/02  13:57:52  jont
Added tail call operation

Revision 1.45  91/11/20  12:20:50  jont
Added exception generating fp opcodes

Revision 1.44  91/11/14  15:20:48  richard
Added CALL_C opcode.

Revision 1.43  91/11/14  10:43:35  richard
Removed references to fp_double registers.

Revision 1.42  91/11/08  16:08:49  richard
Added offset argument to STACKOPs and also FSTREF and FLDREF

Revision 1.41  91/10/28  15:16:50  richard
Changed the form of the allocation instructions yet again. This
time they're a bit more orthogonal.

Revision 1.40  91/10/28  11:23:41  davidt
ALLOCATE doesn't have a scratch register or a proc_ref any more.

Revision 1.39  91/10/24  10:40:51  jont
Added BTA and BNT for tagged value testing

Revision 1.38  91/10/21  09:30:24  jont
New local and external reference code

Revision 1.37  91/10/17  14:17:30  jont
New style ALLOC opcodes

Revision 1.36  91/10/16  14:14:25  jont
Updated to reflect new simplified module structure
Added parameter to heap allocation to indicate position in closure
of call_c function

Revision 1.35  91/10/15  15:10:32  richard
Added ALLOC_PAIR.

Revision 1.34  91/10/11  13:43:06  richard
Added DEALLOC_STACK.

Revision 1.33  91/10/11  09:55:58  richard
Parameters removed from ENTER and added to the
procedure type. Parameters for spill, stack, and register
usage added.

Revision 1.32  91/10/10  13:44:42  richard
Removed RESTORE_REGS and PRESERVE_REGS and replaced with parameterized
ENTER and PREVIOUS_ENVIRONMENT. Parameterized RAISE.

Revision 1.31  91/10/04  11:33:33  jont
Added new PROC type

Revision 1.30  91/10/03  11:22:41  jont
New code structure

Revision 1.29  91/10/03  11:06:30  jont
Added tag to refs

Revision 1.28  91/10/03  10:57:21  jont
Changed CODE structure to enable easier handling of code, values
and load time semantics

Revision 1.27  91/10/02  11:03:15  jont
Removed real register options, these are being done elsewhere

Revision 1.26  91/10/01  09:57:34  richard
Added ordering functions for gc, non_gc, fp and fp_double registers
so that they can be used in tables.

Revision 1.25  91/09/30  10:04:18  richard
Added ordering function for the any_register type.

Revision 1.24  91/09/25  14:54:28  richard
Added functions to convert between register types.

Revision 1.23  91/09/24  10:41:56  richard
Added tag equality function.

Revision 1.22  91/09/23  15:54:07  richard
Corrected a unresolved operator cause by as hasty check-in.

Revision 1.21  91/09/23  15:08:36  richard
Added an ordering function on block tags to allow use of lookup tables.

Revision 1.20  91/09/23  10:38:31  richard
Added NEW_HANDLER, OLD_HANDLER, and RAISE directives.

Revision 1.19  91/09/20  15:30:52  jont
Added PRESERVE_ALL_REGS.

Revision 1.18  91/09/19  15:52:34  jont
Added MODV

Revision 1.17  91/09/17  13:50:09  jont
Changed branches to target bl_dest

Revision 1.16  91/09/17  10:44:11  jont
Added ALLOCA for stack allocated items

Revision 1.15  91/09/10  14:28:30  jont
Added new type symbolic, and extra constructor GP_IMM_SYMB for
values not yet known

Revision 1.14  91/09/05  15:56:24  jont
Added LDREF and STREF to assist optimiser deduce available expressions

Revision 1.13  91/09/03  16:35:12  jont
Added LDB, STB

Revision 1.12  91/09/03  13:53:38  jont
Added PRESERVE_REGS and RESTORE_REGS. Removed ENTER_NO_CALLS
and EXIT_NO_CALLS

Revision 1.11  91/08/30  16:33:56  jont
Changed format for floating point operations to allow register colouring

Revision 1.10  91/08/29  14:02:50  jont
Slight change to ALLOC

Revision 1.9  91/08/22  16:39:35  jont
New ALLOC_REF
Removed data flow hints, these can be deduced.

Revision 1.8  91/08/15  14:15:53  jont
Updated for later version of HARP

Revision 1.7  91/08/09  16:46:22  jont
Added EXT_REF type

Revision 1.6  91/08/02  16:35:35  jont
Added a comment opcode to allow information to be passed through

Revision 1.5  91/08/01  17:18:52  jont
Added new opcodes for local reference and FN_CALL as required by the
loader

Revision 1.4  91/07/31  18:02:36  jont
Added some new instructions to indicate leaf procedures

Revision 1.3  91/07/30  14:08:09  jont
Minor changes

Revision 1.2  91/07/26  17:31:27  jont
Changed some types to allow register colouring information plus
more general purpose operands

Revision 1.1  91/07/25  14:12:56  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";

require "../utils/counter";
require "../utils/set";
require "../utils/intnewmap";
require "../basics/ident";
require "../debugger/debugger_types";
require "virtualregister";
require "mirtypes";

functor MirTypes(
  structure GC		: VIRTUALREGISTER
  structure NonGC	: VIRTUALREGISTER
  structure FP		: VIRTUALREGISTER
  structure Map         : INTNEWMAP
  structure Counter	: COUNTER
  structure Set		: SET
  structure Ident       : IDENT
  structure Debugger_Types : DEBUGGER_TYPES

  sharing GC.Set.Text = NonGC.Set.Text = FP.Set.Text
) : MIRTYPES =

struct
  structure Ident = Ident
  structure Set = Set
  structure Text = GC.Set.Text
  structure GC = GC
  structure NonGC = NonGC
  structure FP = FP
  structure Map = Map
  structure Debugger_Types = Debugger_Types
  structure RuntimeEnv = Debugger_Types.RuntimeEnv

  type SCon = Ident.SCon

  datatype any_register =
    GC of GC.T |
    NON_GC of NonGC.T |
    FLOAT of FP.T

  fun order_any_reg (GC r, GC r') = GC.order (r, r')
    | order_any_reg (GC _, _) = true
    | order_any_reg (_, GC _) = false
    | order_any_reg (NON_GC r, NON_GC r') = NonGC.order (r, r')
    | order_any_reg (NON_GC _, _) = true
    | order_any_reg (_, NON_GC _) = false
    | order_any_reg (FLOAT r, FLOAT r') = FP.order (r, r')
     
  (* offset of spill slot N from the frame pointer *)
  datatype SlotInfo = SIMPLE of int | DEBUG of RuntimeEnv.Offset ref * string

  (* Symbolic values *)
  datatype symbolic =
    GC_SPILL_SIZE |
    NON_GC_SPILL_SIZE |
    GC_SPILL_SLOT of SlotInfo | 
    NON_GC_SPILL_SLOT of SlotInfo | 
    FP_SPILL_SLOT of SlotInfo

  (* Operands *)
  datatype gp_operand =
    GP_GC_REG of GC.T
  | GP_NON_GC_REG of NonGC.T
  | GP_IMM_INT of int (* For real ints, represented with run time tags *)
  | GP_IMM_ANY of int (* For other values *)
  | GP_IMM_SYMB of symbolic (* For unknown (macro) values *)

  exception NotAnyRegister

  fun gp_to_any (GP_GC_REG reg) = GC reg
    | gp_to_any (GP_NON_GC_REG reg) = NON_GC reg
    | gp_to_any _ = raise NotAnyRegister

  fun any_to_gp (GC reg) = GP_GC_REG reg
    | any_to_gp (NON_GC reg) = GP_NON_GC_REG reg
    | any_to_gp _ = raise NotAnyRegister

  datatype reg_operand =
    GC_REG of GC.T
  | NON_GC_REG of NonGC.T

  fun reg_to_any (GC_REG reg) = GC reg
    | reg_to_any (NON_GC_REG reg) = NON_GC reg

  fun any_to_reg (GC reg) = GC_REG reg
    | any_to_reg (NON_GC reg) = NON_GC_REG reg
    | any_to_reg _ = raise NotAnyRegister

  datatype fp_operand =
    FP_REG of FP.T

  fun fp_to_any (FP_REG reg) = FLOAT reg

  fun any_to_fp (FLOAT reg) = FP_REG reg
    | any_to_fp _ = raise NotAnyRegister

  (* Addresses in store *)
  type tag = int
  fun int_of_tag tag = tag
  fun init_tag () = Counter.reset_counter 0
  fun new_tag () = Counter.counter ()
  fun print_tag t = Int.toString t
  fun print_tag_list [] = "_"
    | print_tag_list ([t]) = print_tag t
    | print_tag_list (t::rest) = print_tag t ^ ", " ^ print_tag_list rest

  fun order_tag (tag : tag, tag' : tag) = tag<tag'
  fun equal_tag (tag : tag, tag' : tag) = tag=tag'
  fun init_counters () = init_tag()

  datatype bl_dest = TAG of tag | REG of reg_operand
  (* Operations *)
    datatype binary_op =
      ADDU |
      SUBU |
      MULU |
      MUL32U |
      AND |
      OR | 
      EOR | 
      LSR | 
      ASL | 
      ASR
    datatype tagged_binary_op =
      ADDS |
      SUBS |

      (* Handle overflow specially for these *)
      (* (because traps are hard) *)
      ADD32S |
      SUB32S |

      MULS |
      DIVS |
      MODS |

      MUL32S |
      DIV32S |
      MOD32S |
      (* These can raise Div *)
      DIVU |
      MODU |
      DIV32U |
      MOD32U

  datatype unary_op = 
    MOVE |
    INTTAG |
    NOT |
    NOT32

  datatype binary_fp_op = FADD | FSUB | FMUL | FDIV
  datatype tagged_binary_fp_op = FADDV | FSUBV | FMULV | FDIVV
  datatype tagged_unary_fp_op =
    FABSV |
    FNEGV |
    FSQRTV |
    FLOGEV |
    FETOXV
  datatype unary_fp_op =
    FMOVE |
    FABS |
    FNEG |
    FINT |
    FSQRT |
    FLOG10 |
    FLOG2 |
    FLOGE |
    FLOGEP1 |
    F10TOX |
    F2TOX |
    FETOX |
    TETOXM1 |
    FSIN |
    FCOS |
    FTAN |
    FASIN |
    FACOS |
    FATAN
  datatype stack_op = PUSH | POP
  datatype store_op = LD | ST | LDB | STB | LDREF | STREF
  datatype store_fp_op = FLD | FST | FSTREF | FLDREF
  datatype int_to_float = ITOF
  datatype float_to_int = FTOI
  datatype branch = BRA (* Branch to basic block *)
  datatype cond_branch =
    BTA | (* Branch on tagged *)
    BNT | (* Branch on not tagged *)
    BEQ |
    BNE | (* Branch on eq/not eq *)
    BHI | (* Unsigned > *)
    BLS | (* Unsigned <= *)
    BHS | (* Unsigned >= *)
    BLO | (* Unsigned < *)
    BGT | (* Signed > *)
    BLE | (* Signed <= *)
    BGE | (* Signed >= *)
    BLT   (* Signed < *)
  datatype fcond_branch =
    FBEQ |
    FBNE | (* Branch on eq/not eq *)
    FBLE | (* Signed <= *)
    FBLT   (* Signed < *)
  datatype branch_and_link = BLR
  datatype tail_call = TAIL
  datatype computed_goto = CGT
  datatype allocate =
    ALLOC |
    ALLOC_VECTOR |
    ALLOC_REAL |
    ALLOC_STRING |
    ALLOC_BYTEARRAY |
    ALLOC_REF
  datatype adr = LEA | LEO
  datatype nullary_op = CLEAN

  datatype opcode =
    TBINARY of tagged_binary_op * tag list * reg_operand * gp_operand * gp_operand |
    BINARY of binary_op * reg_operand * gp_operand * gp_operand |
    UNARY of unary_op * reg_operand * gp_operand |
    NULLARY of nullary_op * reg_operand |
    TBINARYFP of tagged_binary_fp_op * tag list * fp_operand * fp_operand *
    fp_operand |
    TUNARYFP of tagged_unary_fp_op * tag list * fp_operand * fp_operand |
    BINARYFP of binary_fp_op * fp_operand * fp_operand * fp_operand |
    UNARYFP of unary_fp_op * fp_operand * fp_operand |
    STACKOP of stack_op * reg_operand * int option |
    STOREOP of store_op * reg_operand * reg_operand * gp_operand |
    IMMSTOREOP of store_op * gp_operand * reg_operand * gp_operand | (* For CISCs only *)
    STOREFPOP of store_fp_op * fp_operand * reg_operand * gp_operand |
    REAL of int_to_float * fp_operand * gp_operand |
    FLOOR of float_to_int * tag * reg_operand * fp_operand |
    BRANCH of branch * bl_dest |
    TEST of cond_branch * tag * gp_operand * gp_operand |
    FTEST of fcond_branch * tag * fp_operand * fp_operand |
    BRANCH_AND_LINK of branch_and_link * bl_dest * Debugger_Types.Backend_Annotation * any_register list |
    TAIL_CALL of tail_call * bl_dest * any_register list |
    CALL_C |
    SWITCH of computed_goto * reg_operand * tag list |
    ALLOCATE of allocate * reg_operand * gp_operand |
    ALLOCATE_STACK of allocate * reg_operand * int * int option |
    DEALLOCATE_STACK of allocate * int |
    ADR of adr * reg_operand * tag |
    (* Interception *)
    INTERCEPT |
    (* Interruption *)
    INTERRUPT |
    (* Information points *)
    ENTER of any_register list | (* Entry point for procedure *)
    RTS | (* Return point from procedure *)
    NEW_HANDLER of reg_operand (* Pointer to the frame *) *
      tag (* tag on continuation point *) | (* Set handler inside function *)
    OLD_HANDLER | (* Restore previous handler *)
    RAISE of reg_operand | (* Raise the current handler (special call) *)
    COMMENT of string

  datatype refs = REFS of
    (tag * int) list *		(* internal references *)
      {requires : (string * int) list,		(* external references *)
       vars : (string * int) list, (* interpretive environment vars *)
       exns : (string * int) list, (* interpretive environment exns *)
       strs : (string * int) list, (* interpretive environment strs *)
       funs : (string * int) list} (* interpretive environment funs *)

  datatype valspec =
    SCON of Ident.SCon
  | MLVALUE of MLWorks.Internal.Value.ml_value

  datatype value = VALUE of tag * valspec

  datatype block = BLOCK of tag * opcode list

  datatype procedure_parameters = PROC_PARAMS of
    {spill_sizes	: {gc		: int,
			   non_gc	: int,
			   fp		: int} option,
     old_spill_sizes	: {gc		: int,
                           non_gc	: int,
                           fp		: int} option,
     stack_allocated	: int option}

  datatype procedure = PROC of
    string *          (* Procedure name *)
    tag *		(* tag of the procedure entry block *)
    procedure_parameters *
    block list *		(* procedure code *)
    RuntimeEnv.RuntimeEnv    (* runtime environment for code *)

  datatype mir_code = CODE of
    refs *
    value list *
    procedure list list	(* list of recursive procedure sets *)

  val _ = init_counters()
end
@


1.88.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.88  1997/07/31  12:57:37  jont
 * [Bug #30215]
 * Remove BIC, and replace by INTTAG instruction
 *
@


1.88.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.88  1997/07/31  12:57:37  jont
 * [Bug #30215]
 * Remove BIC, and replace by INTTAG instruction
 *
@


1.88.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.88  1997/07/31  12:57:37  jont
 * [Bug #30215]
 * Remove BIC, and replace by INTTAG instruction
 *
@


1.87
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
a416 1
      BIC | (* AND-NOT *)
d445 1
@


1.86
log
@Have tag list in tagged operations
@
text
@d4 3
d520 1
a520 1
    STACKOP of stack_op * reg_operand * int MLWorks.Option.option |
d534 1
a534 1
    ALLOCATE_STACK of allocate * reg_operand * int * int MLWorks.Option.option |
d569 1
a569 1
			   fp		: int} MLWorks.Option.option,
d572 2
a573 2
                           fp		: int} MLWorks.Option.option,
     stack_allocated	: int MLWorks.Option.option}
@


1.86.1.1
log
@branched from 1.86
@
text
@a3 3
 * Revision 1.86  1997/01/16  12:33:50  matthew
 * Have tag list in tagged operations
 *
@


1.86.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.86.1.1  1997/05/12  10:32:06  hope
 * branched from 1.86
 *
@


1.86.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.86.1.1  1997/05/12  10:32:06  hope
 * branched from 1.86
 *
@


1.86.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.86.1.1  1997/05/12  10:32:06  hope
 * branched from 1.86
 *
@


1.86.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.86.1.1.1.1  1997/07/28  18:17:51  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.85
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d393 4
a396 2
  fun print_tag_opt MLWorks.Option.NONE = "_"
  |   print_tag_opt (MLWorks.Option.SOME t) = print_tag t
d403 33
a435 27
  datatype binary_op =
  ADD |
  SUB |
  MULU |
  MULS |
  DIVU |
  DIVS |
  MODU |
  MODS |
  AND |
  OR | 
  BIC | (* AND-NOT *)
  EOR | 
  LSR | 
  ASL | 
  ASR
  datatype tagged_binary_op =
  ADDV |
  SUBV |
  MULV |
  DIVV |
  MODV |
  ADDW |
  SUBW |
  MULW |
  DIVW |
  MODW
d438 3
a440 3
  MOVE |
  NOT |
  NOT32
d508 1
a508 1
    TBINARY of tagged_binary_op * tag MLWorks.Option.option * reg_operand * gp_operand * gp_operand |
d512 1
a512 1
    TBINARYFP of tagged_binary_fp_op * tag MLWorks.Option.option * fp_operand * fp_operand *
d514 1
a514 1
    TUNARYFP of tagged_unary_fp_op * tag MLWorks.Option.option * fp_operand * fp_operand |
@


1.85.4.1
log
@branched from 1.85
@
text
@a3 4
 * Revision 1.85  1996/11/06  11:07:36  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.85.3.1
log
@branched from 1.85
@
text
@a3 4
 * Revision 1.85  1996/11/06  11:07:36  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.85.3.1.1.1
log
@branched from 1.85.3.1
@
text
@a3 3
 * Revision 1.85.3.1  1996/12/17  17:45:47  hope
 * branched from 1.85
 *
@


1.85.2.1
log
@branched from 1.85
@
text
@a3 4
 * Revision 1.85  1996/11/06  11:07:36  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.85.1.1
log
@branched from 1.85
@
text
@a3 4
 * Revision 1.85  1996/11/06  11:07:36  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.85.1.1.1.1
log
@branched from 1.85.1.1
@
text
@a3 3
 * Revision 1.85.1.1  1996/11/14  12:46:54  hope
 * branched from 1.85
 *
@


1.84
log
@Adding NOT32 MIR instruction
@
text
@d4 3
d286 1
a286 1
require "../basis/__integer";
@


1.84.3.1
log
@branched from 1.84
@
text
@a3 3
 * Revision 1.84  1996/05/14  10:17:10  matthew
 * Adding NOT32 MIR instruction
 *
@


1.84.2.1
log
@branched from 1.84
@
text
@a3 3
 * Revision 1.84  1996/05/14  10:17:10  matthew
 * Adding NOT32 MIR instruction
 *
@


1.84.1.1
log
@branched from 1.84
@
text
@a3 3
 * Revision 1.84  1996/05/14  10:17:10  matthew
 * Adding NOT32 MIR instruction
 *
@


1.83
log
@Removing MLWorks.Integer
@
text
@d4 3
d424 3
a426 1
  NOT
@


1.82
log
@Add ADDW, SUBW for untagged integer operations
with register cleaning on overflow
@
text
@d4 4
d280 2
d382 1
a382 1
  fun print_tag t = MLWorks.Integer.makestring t
@


1.81
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d4 4
d406 7
a412 1
  MODV
@


1.80
log
@Renaming debugger_env to runtime_env
@
text
@d4 3
a274 1
require "../utils/option";
a287 1
  structure Option      : OPTION
a300 1
  structure Option = Option
d373 2
a374 2
  fun print_tag_opt Option.ABSENT = "_"
  |   print_tag_opt (Option.PRESENT t) = print_tag t
d472 1
a472 1
    TBINARY of tagged_binary_op * tag Option.opt * reg_operand * gp_operand * gp_operand |
d476 1
a476 1
    TBINARYFP of tagged_binary_fp_op * tag Option.opt * fp_operand * fp_operand *
d478 1
a478 1
    TUNARYFP of tagged_unary_fp_op * tag Option.opt * fp_operand * fp_operand |
d481 1
a481 1
    STACKOP of stack_op * reg_operand * int Option.opt |
d495 1
a495 1
    ALLOCATE_STACK of allocate * reg_operand * int * int Option.opt |
d530 5
a534 2
			   fp		: int} Option.opt,
     stack_allocated	: int Option.opt}
@


1.79
log
@Adding ALLOC_VECTOR
@
text
@d4 3
a274 1
require "../debugger/debugger_env";
d538 1
a538 1
    RuntimeEnv.debugger_env    (* runtime environment for code *)
@


1.78
log
@Add immediate store operations
@
text
@d4 3
d461 1
@


1.77
log
@Remove handler register concept
@
text
@d4 3
d477 1
@


1.76
log
@Abstraction of debug information
@
text
@d4 3
d495 2
a496 1
    NEW_HANDLER of tag | (* Set handler inside function *)
@


1.75
log
@Simplifications of annotations
@
text
@d4 3
a276 1
  structure RuntimeEnv : DEBUGGER_ENVIRONMENT_TYPE
d291 1
a291 1
  structure RuntimeEnv = RuntimeEnv
d308 3
d315 3
a317 5
    GC_SPILL_SLOT of ((int,int) Option.option ref * string,int) Option.option |  
      (* offset of spill slot N from the frame pointer *)
    NON_GC_SPILL_SLOT of ((int,int) Option.option ref * string,int) 
    Option.option |  
    FP_SPILL_SLOT of ((int,int) Option.option ref * string,int) Option.option 
@


1.74
log
@Added function argument register lists to BRANCH_AND_LINK, TAIL_CALL and ENTER
Changed loop_entry in procedure parameters to be a tag list, so we can have lots.
@
text
@d4 4
d511 1
a511 5
    {leaf		: bool,
     registers_used	: {gc		: GC.T Set.Set,
			   non_gc	: NonGC.T Set.Set,
			   fp		: FP.T Set.Set} Option.opt,
     spill_sizes	: {gc		: int,
d514 1
a514 2
     stack_allocated	: int Option.opt,
     loop_entry		: tag list}
@


1.73
log
@Add loop entry point to procedure parameters.
@
text
@d4 3
d470 2
a471 2
    BRANCH_AND_LINK of branch_and_link * bl_dest * Debugger_Types.Backend_Annotation |
    TAIL_CALL of tail_call * bl_dest |
d483 1
a483 1
    ENTER | (* Entry point for procedure *)
d515 1
a515 1
     loop_entry		: tag Option.opt}
@


1.72
log
@Adding load offset instruction
@
text
@d4 3
d511 2
a512 1
     stack_allocated	: int Option.opt}
@


1.71
log
@Removed unnecessary exceptions from closures.
@
text
@d4 3
d443 1
a443 1
  datatype adr = LEA
@


1.70
log
@Added INTERRUPT instruction
@
text
@d4 3
d346 2
d444 1
a444 1
    TBINARY of tagged_binary_op * tag * reg_operand * gp_operand * gp_operand |
d448 1
a448 1
    TBINARYFP of tagged_binary_fp_op * tag * fp_operand * fp_operand *
d450 1
a450 1
    TUNARYFP of tagged_unary_fp_op * tag * fp_operand * fp_operand |
@


1.69
log
@Debugger Environments for local and closure variable inspection
in the debugger;
new stack spill slots;
structure Option.
@
text
@d4 6
d466 2
@


1.69.1.1
log
@Fork for bug fixing
@
text
@a3 6
Revision 1.69  1993/07/29  14:23:29  nosa
Debugger Environments for local and closure variable inspection
in the debugger;
new stack spill slots;
structure Option.

@


1.68
log
@Removed Integer parameter
@
text
@d4 3
d235 1
d238 1
d250 1
d252 1
d265 1
d267 1
a270 2
  datatype 'a Opt = PRESENT of 'a | ABSENT

d288 5
a292 3
    GC_SPILL_SLOT of int |  (* offset of spill slot N from the frame pointer *)
    NON_GC_SPILL_SLOT of int |
    FP_SPILL_SLOT of int
d442 1
a442 1
    STACKOP of stack_op * reg_operand * int Opt |
d455 1
a455 1
    ALLOCATE_STACK of allocate * reg_operand * int * int Opt |
d488 1
a488 1
			   fp		: FP.T Set.Set} Opt,
d491 2
a492 2
			   fp		: int} Opt,
     stack_allocated	: int Opt}
d495 1
a495 1
    string *            (* Name of the procedure *)
d498 2
a499 1
    block list		(* procedure code *)
@


1.67
log
@Changed PROFILE instruction to INTERCEPT.
@
text
@d4 3
a228 1
require "../utils/integer";
a242 1
  structure Integer	: INTEGER
d327 1
a327 1
  fun print_tag t = Integer.makestring t
@


1.66
log
@Removed options
Added type SCon
@
text
@d4 4
d448 2
a449 2
    (* Profile *)
    PROFILER of reg_operand | 
@


1.65
log
@Options & Info changes
@
text
@d4 3
d226 1
d239 1
d246 1
a246 1
  structure Ident = Debugger_Types.Datatypes.Ident
d255 1
a255 50
(*
  datatype back_end_listing_options =
    BELO of {
      show_absyn      : bool,
      show_lambda     : bool,
      show_match      : bool,
      show_opt_lambda : bool,
      show_environ    : bool,
      show_mir        : bool,
      show_opt_mir    : bool,
      show_mach       : bool
      }

  datatype options =
    OPTIONS of {
      info_opts             : Info.options,
      list_opts             : back_end_listing_options,
      debug                 : bool,
      profile               : bool,
      trace                 : bool,
      debug_warnings        : bool,
      opt_leaf_fns          : bool,
      opt_tail_calls        : bool,
      opt_self_calls        : bool
    }

  val default_options =
    OPTIONS
    {
     info_opts = Info.default_options,
     list_opts =
       BELO {
	 show_absyn = false,
	 show_lambda = false,
	 show_match = false,
         show_opt_lambda = false,
         show_environ = false,
         show_mir = false,
         show_opt_mir = false,
         show_mach = false
	 },
     debug = false,
     debug_warnings = false,
     profile = false,
     trace = false,
     opt_leaf_fns = true,
     opt_tail_calls = true,
     opt_self_calls = true
     }
*)
d463 1
a463 1
    SCON of Debugger_Types.Datatypes.Ident.SCon
@


1.64
log
@Changed representation of value to include MLVALUEs
@
text
@d4 3
a222 1
require "../main/info";
a240 1
  structure Info = Debugger_Types.Info
d250 1
d299 1
@


1.63
log
@Added default options
@
text
@d4 3
d503 5
a507 1
  datatype value = VALUE of tag * Ident.SCon
@


1.62
log
@Added code printing controls to options
@
text
@d4 3
d270 24
@


1.61
log
@Changes to propagate compiler options as parameters instead of references.
@
text
@d4 3
d243 12
d258 1
@


1.60
log
@Changed erroneous require.
@
text
@d4 3
d211 1
d230 1
a230 1

d239 12
@


1.59
log
@Added Map structure for mononewmaps to allow efficient implementation
of lookup tables for integer based values
@
text
@d4 4
d207 1
a207 1
require "../utils/mononewmap";
@


1.58
log
@Removed some redundant structures and sharing
@
text
@d4 3
d203 1
a208 1

d212 1
a218 1

d229 1
@


1.57
log
@Added NULLARY opcode type and ALLOC_BYTEARRAY.
@
text
@d4 3
a199 2
require "../utils/text";
require "../basics/ident";
a211 2
  structure Ident	: IDENT
  structure Text	: TEXT
d214 1
a214 1
  sharing Text = GC.Text = NonGC.Text = FP.Text
d220 1
a220 1
  structure Ident = Ident
d222 1
a222 1
  structure Text = Text
a226 1

@


1.56
log
@Added type annotation information at application points
@
text
@d4 3
d386 1
a387 1

d389 1
d395 1
@


1.55
log
@Added parameter to RAISE once again.
@
text
@d4 3
d196 1
d210 1
d224 1
d226 1
d404 1
a404 1
    BRANCH_AND_LINK of branch_and_link * bl_dest |
@


1.54
log
@Expanded refs section of mir_code to allow for interpretive stuff
@
text
@d4 3
d412 1
a412 1
    RAISE (*of reg_operand*) | (* Raise the current handler (special call) *)
@


1.53
log
@Added int_of_tag function
@
text
@d4 3
d414 5
a418 1
    (string * int) list		(* external references *)
@


1.52
log
@First version of the profiler
@
text
@d4 3
d276 1
@


1.51
log
@Added require counter
@
text
@d4 3
d395 2
d424 1
@


1.50
log
@Changed virtual registers to be structures in their own right.
See VirtualRegister module.
@
text
@d4 4
d177 1
@


1.49
log
@Abolished PRESERVE_ALL_REGS and PREVIOUS_ENVIRONMENT.
Added `hash_*_register'.
@
text
@d4 8
a172 1
require "../utils/counter";
d174 1
d176 1
d180 12
a191 8
  structure Counter1: COUNTER
  structure Counter2: COUNTER
  structure Counter3: COUNTER
  structure Counter4: COUNTER
  structure Counter5: COUNTER
  structure Integer: INTEGER
  structure Set : SET
  structure Ident : IDENT
d193 1
d195 1
d198 4
a204 3
  type gc_register = int
  type non_gc_register = int 
  type fp_register = int 
d206 3
a208 18
    GC of gc_register |
    NON_GC of non_gc_register |
    FLOAT of fp_register
  fun new_gc_register () = Counter1.counter ()
  fun new_non_gc_register () = Counter2.counter ()
  fun new_fp_register () = Counter3.counter ()
  fun init_gc_register () = Counter1.reset_counter 0
  val order_gc_register = op< : gc_register * gc_register -> bool
  fun hash_gc_register reg = reg
  fun print_gc_register reg = Integer.makestring reg
  fun init_non_gc_register () = Counter2.reset_counter 0
  val order_non_gc_register = op< : non_gc_register * non_gc_register -> bool
  fun hash_non_gc_register reg = reg
  fun print_non_gc_register reg = Integer.makestring reg
  fun init_fp_register () = Counter3.reset_counter 0
  val order_fp_register = op< : fp_register * fp_register -> bool
  fun hash_fp_register reg = reg
  fun print_fp_register reg = Integer.makestring reg
d210 1
a210 1
  fun order_any_reg (GC r, GC r') = r<r'
d213 1
a213 1
    | order_any_reg (NON_GC r, NON_GC r') = r<r'
d216 1
a216 1
    | order_any_reg (FLOAT r, FLOAT r') = r<r'
d228 2
a229 2
    GP_GC_REG of gc_register
  | GP_NON_GC_REG of non_gc_register
d245 2
a246 2
    GC_REG of gc_register
  | NON_GC_REG of non_gc_register
d256 1
a256 1
    FP_REG of fp_register
d265 2
a266 2
  fun init_tag () = Counter5.reset_counter 0
  fun new_tag () = Counter5.counter ()
d270 1
a270 5
  fun init_counters () =
    (init_gc_register();
     init_non_gc_register();
     init_fp_register();
     init_tag())
d405 3
a407 3
     registers_used	: {gc		: gc_register Set.Set,
			   non_gc	: non_gc_register Set.Set,
			   fp		: fp_register Set.Set} Opt,
@


1.48
log
@Alloc may now have a register argument for allocating arrays
@
text
@d4 3
d198 1
d202 1
d206 1
a391 1
    PRESERVE_ALL_REGS |
a392 1
    PREVIOUS_ENVIRONMENT | (* Restore caller environment *)
@


1.47
log
@Raise no longer has a parameter
@
text
@d4 3
d380 1
a380 1
    ALLOCATE of allocate * reg_operand * int |
@


1.46
log
@Added tail call operation
@
text
@d3 4
a6 1
$Log:	_mirtypes.sml,v $
d388 1
a388 1
    RAISE of reg_operand | (* Raise the current handler (special call) *)
@


1.45
log
@Added exception generating fp opcodes
@
text
@d4 3
d342 2
a343 1
  datatype branch_and_link = BSR | BLR
d371 1
@


1.44
log
@Added CALL_C opcode.
@
text
@d4 3
d288 7
d318 2
a319 1
  datatype int_to_float = ITOF | FTOI
d353 3
d361 2
a362 1
    CONVOP of int_to_float * fp_operand * gp_operand |
@


1.43
log
@Removed references to fp_double registers.
@
text
@d4 3
d352 1
@


1.42
log
@Added offset argument to STACKOPs and also FSTREF and FLDREF
@
text
@d4 3
a170 1
  type fp_double_register = int
d174 1
a174 2
    FLOAT of fp_register |
    DOUBLE of fp_double_register
a177 1
  fun new_fp_double_register () = Counter4.counter ()
a186 4
  fun init_fp_double_register () = Counter4.reset_counter 0
  val order_fp_double_register =
    op< : fp_double_register * fp_double_register -> bool
  fun print_fp_double_register reg = Integer.makestring reg
a194 3
    | order_any_reg (FLOAT _, _) = true
    | order_any_reg (_, FLOAT _) = false
    | order_any_reg (DOUBLE r, DOUBLE r') = r<r'
d202 1
a202 2
    FP_SPILL_SLOT of int |
    FP_DOUBLE_SPILL_SLOT of int
a251 1
     init_fp_double_register();
d376 1
a376 2
			   fp		: fp_register Set.Set,
			   fp_double	: fp_double_register Set.Set} Opt,
d379 1
a379 2
			   fp		: int,
			   fp_double	: int} Opt,
@


1.41
log
@Changed the form of the allocation instructions yet again. This
time they're a bit more orthogonal.
@
text
@d4 4
d313 1
a313 1
  datatype store_fp_op = FLD | FST
d350 1
a350 1
    STACKOP of stack_op * reg_operand |
@


1.40
log
@ALLOCATE doesn't have a scratch register or a proc_ref any more.
@
text
@d4 3
d336 1
a336 2
    ALLOC_REF |
    ALLOC_STACK
a337 3
  datatype deallocate =
    DEALLOC_STACK

d356 2
a357 1
    DEALLOCATE of deallocate * int |
@


1.39
log
@Added BTA and BNT for tagged value testing
@
text
@d4 3
a340 4
  datatype proc_ref =
    REG_REF of reg_operand |
    CLOSURE_REF of reg_operand * int

d356 1
a356 2
    ALLOCATE of
    allocate * reg_operand * int (*size*) * reg_operand * proc_ref |
@


1.38
log
@New local and external reference code
@
text
@d4 3
d307 2
@


1.37
log
@New style ALLOC opcodes
@
text
@d4 3
d367 2
a368 2
    tag list *		(* internal references *)
    string list		(* external references *)
@


1.36
log
@Updated to reflect new simplified module structure
Added parameter to heap allocation to indicate position in closure
of call_c function
@
text
@d4 5
d329 5
d349 2
a350 1
    ALLOCATE of allocate * reg_operand * int (*size*) * int (*call_c*) |
@


1.35
log
@Added ALLOC_PAIR.
@
text
@d4 3
d318 1
a318 2
    ALLOC_STACK |
    ALLOC_PAIR
d339 1
a339 1
    ALLOCATE of allocate * reg_operand * int |
a351 2
  datatype fn_call = FN_CALL of tag * tag (* Loader level function call *)

a352 1
    tag *
a377 1
    fn_call *
d380 1
a380 2
    procedure list list *	(* list of recursive procedure sets *)
    procedure
@


1.34
log
@Added DEALLOC_STACK.
@
text
@d4 3
d315 2
a316 1
    ALLOC_STACK
@


1.33
log
@Parameters removed from ENTER and added to the
procedure type. Parameters for spill, stack, and register
usage added.
@
text
@d4 5
d313 4
d334 1
@


1.32
log
@Removed RESTORE_REGS and PRESERVE_REGS and replaced with parameterized
ENTER and PREVIOUS_ENVIRONMENT. Parameterized RAISE.
@
text
@d4 4
d174 5
a178 1
    NON_GC_SPILL_SIZE
d327 1
a327 1
    ENTER of {leaf : bool} | (* Entry point for procedure *)
d334 2
a335 2
    COMMENT of string | (* Allows comments in the harp *)
    END (* The code ends here *)
d347 12
d361 1
d369 1
a369 1
    block
@


1.31
log
@Added new PROC type
@
text
@d4 3
d319 1
a319 2
    ENTER | (* Entry point for procedure *)
    PRESERVE_REGS of reg_operand list * fp_operand list |
d322 1
a322 1
    RESTORE_REGS of reg_operand list * fp_operand list |
d325 1
a325 1
    RAISE | (* Raise the current handler *)
@


1.30
log
@New code structure
@
text
@d4 3
d327 6
a332 1
  datatype refs = REFS of tag * tag list * string list
d334 1
d336 12
a347 2
  datatype mir_code =
    CODE of fn_call * refs * value list * block list list * block
@


1.29
log
@Added tag to refs
@
text
@d4 3
d328 1
a328 1
    CODE of fn_call * refs * value list * block list Set.Set * block
@


1.28
log
@Changed CODE structure to enable easier handling of code, values
and load time semantics
@
text
@d4 4
d321 1
a321 1
  datatype refs = REFS of tag list * string list
@


1.27
log
@Removed real register options, these are being done elsewhere
@
text
@d4 3
d96 1
a100 1
  structure Ident : IDENT
d107 2
d112 1
a313 5
    (* Data *)
    VALUE of Ident.SCon |
    LOC_REF of tag list |
    EXT_REF of string list |
    FN_CALL of tag * tag | (* Loader level function call *)
d316 3
d320 2
a321 1
  datatype mir_code = CODE of block list
@


1.26
log
@Added ordering functions for gc, non_gc, fp and fp_double registers
so that they can be used in tables.
@
text
@d4 4
d107 3
a109 1
  datatype 'a Opt = ABSENT | PRESENT of 'a
a118 9
  datatype real_gc_reg =
    GC_REAL of gc_register |
    GC_SPILL of int
  datatype real_non_gc_reg =
    NON_GC_REAL of non_gc_register |
    NON_GC_SPILL of int
  datatype real_fp_reg =
    FP_REAL of fp_register |
    FP_SPILL of int
a147 4
  (* Immediates *)
  type fp_immediate = real
  type fp_double_immediate = real

d155 2
a156 2
    GP_GC_REG of gc_register * real_gc_reg Opt
  | GP_NON_GC_REG of non_gc_register * real_non_gc_reg Opt
d163 2
a164 2
  fun gp_to_any (GP_GC_REG(reg,_)) = GC reg
    | gp_to_any (GP_NON_GC_REG(reg,_)) = NON_GC reg
d167 2
a168 2
  fun any_to_gp (GC reg) = GP_GC_REG(reg,ABSENT)
    | any_to_gp (NON_GC reg) = GP_NON_GC_REG(reg,ABSENT)
d172 2
a173 2
    GC_REG of gc_register * real_gc_reg Opt
  | NON_GC_REG of non_gc_register * real_non_gc_reg Opt
d175 2
a176 2
  fun reg_to_any (GC_REG(reg,_)) = GC reg
    | reg_to_any (NON_GC_REG(reg,_)) = NON_GC reg
d178 2
a179 2
  fun any_to_reg (GC reg) = GC_REG(reg,ABSENT)
    | any_to_reg (NON_GC reg) = NON_GC_REG(reg,ABSENT)
d183 1
a183 1
    FP_REG of fp_register * real_fp_reg Opt
d185 1
a185 1
  fun fp_to_any (FP_REG(reg,_)) = FLOAT reg
d187 1
a187 1
  fun any_to_fp (FLOAT reg) = FP_REG(reg,ABSENT)
@


1.25
log
@Added ordering function for the any_register type.
@
text
@d4 3
d127 1
d130 1
d133 1
d136 2
a149 2
    | order_any_reg (DOUBLE _, _) = true
    | order_any_reg (_, DOUBLE _) = false
@


1.24
log
@Added functions to convert between register types.
@
text
@d4 3
d131 13
@


1.24.1.1
log
@This branch is a revision of the operand and register datatypes, leaving
this file much simplified and potentially leading to great simplification
of the code generator and optimiser modules. I have make a new branch
because converting the code generator (Mir_Cg) will take too long and
hold up more important work. There are corresponding branches for the
MirOptimiser and sub-modules.
@
text
@a3 3
Revision 1.24  91/09/25  14:54:28  richard
Added functions to convert between register types.

d90 3
a94 1

a95 1

d97 35
d133 4
d138 7
a144 9
  (*  === ADDRESSES IN STORE (CODE LABELS) ===
   *
   *  These are used to label blocks of code and data. A fresh tag is
   *  produced each time fresh_tag is called. The same sequence of
   *  tags can be generated twice by calling reset_fresh_tag followed
   *  by fresh_tag any number of times. Ordering and equality
   *  functions are provided on tags to allow them to be used in
   *  efficient look-up tables.
   *)
d146 1
a146 6
  type tag = int
  fun reset_fresh_tag () = Counter1.reset_counter 0
  fun fresh_tag () = Counter1.counter ()
  fun order_tag (tag : tag, tag' : tag) = tag<tag'
  fun equal_tag (tag : tag, tag' : tag) = tag=tag'
  fun print_tag tag = Integer.makestring tag
d148 3
d152 3
d156 3
a158 1
  (*  === OPERANDS ===  *)
d160 2
d163 3
a165 8
  (*  == Virtual registers ==
   *
   *  An indefinite supply of virtual registers is available. A fresh
   *  register is returned by fresh_virtual_register each time it is
   *  called. The same sequence of registers can be generated twice by
   *  calling reset_fresh_register followed by fresh_virtual_register
   *  any number of times.
   *)
d167 2
a168 4
  type virtual_register = int
  fun reset_fresh_counter () = Counter2.reset_counter 0
  fun fresh_virtual_register () = Counter2.counter ()
  fun print_virtual_register reg = Integer.makestring reg
d170 1
d172 2
a173 1
  (*  == Immediate values ==  *)
d175 13
a187 1
  (* These are the types of floating-point immediate operands. *)
d189 2
a190 32
  type fp_immediate = real
  and  fp_double_immediate = real

  (* Symbolic values are replaced by immediate values in the final *)
  (* stages of compilation. They represent values which cannot be *)
  (* known by earlier stages. *)

  datatype symbol_name =
    SPILL_SIZE


  (*  == Typed operands ==
   *
   *  These correspond to the register formats available in HARP.
   *)

  datatype untyped_operand =
    REG of virtual_register |
    INT of int |
    ANY of int |
    SYMBOL of symbol_name

  datatype operand =
    GC of untyped_operand |
    NON_GC of untyped_operand |
    FLOAT of untyped_operand |
    DOUBLE of untyped_operand



  (*  === OPERATIONS ===  *)

a206 1

a212 1

a215 1

a216 1

a236 1

a237 1

a238 1

a239 1

d241 1
a241 3

  datatype branch = BRA

a252 1

d258 1
a258 3

  datatype branch_and_link = BSR

a259 1

a265 1

a266 1

d268 19
a286 25

    TBINARY	of tagged_binary_op * tag * operand * operand * operand |
    BINARY	of binary_op * operand * operand * operand |
    UNARY	of unary_op * operand * operand |
    BINARYFP	of binary_fp_op * operand * operand * operand |
    UNARYFP	of unary_fp_op * operand * operand |
    STACKOP	of stack_op * operand |
    STOREOP	of store_op * operand * operand * operand |
    STOREFPOP	of store_fp_op * operand * operand * operand |
    CONVOP	of int_to_float * operand * operand |
    BRANCH_REG	of branch * operand |
    BRANCH	of branch * tag |
    TEST	of cond_branch * tag * operand * operand |
    FTEST	of fcond_branch * tag * operand * operand |
    LINK_REG	of branch_and_link * operand |
    LINK	of branch_and_link * tag |
    SWITCH	of computed_goto * operand * tag list |
    ALLOCATE	of allocate * operand * int |
    ADR		of adr * operand * tag |

    (* Information points: These are directives which do not expand *)
    (* directly into code but are used by later stages in compilation. *)

    ENTER | 			(* Entry point for procedure *)
    PRESERVE_REGS of operand list |
d288 5
a292 6
    RTS | 			(* Return point from procedure *)
    RESTORE_REGS of operand list |
    NEW_HANDLER	of tag |	(* Set handler inside function *)
    OLD_HANDLER |		(* Restore previous handler *)
    RAISE |			(* Raise the current handler *)

d294 6
a299 9

    VALUE	of Ident.SCon |
    LOC_REF	of tag list |
    EXT_REF	of string list |
    FN_CALL	of tag * tag |	(* Loader level function call *)
    COMMENT	of string |	(* Allows comments in the harp *)

    END		(* The code ends here *)

a300 1

d302 1
a302 1

@


1.23
log
@Added tag equality function.
@
text
@d4 3
d145 11
d159 8
d169 6
@


1.22
log
@Corrected a unresolved operator cause by as hasty check-in.
@
text
@d4 3
d153 1
@


1.21
log
@Added an ordering function on block tags to allow use of lookup tables.
@
text
@d4 3
d149 1
a149 1
  fun order_tag (tag,tag') = tag<tag'
@


1.20
log
@Added NEW_HANDLER, OLD_HANDLER, and RAISE directives.
@
text
@d4 3
d146 1
@


1.19
log
@Added PRESERVE_ALL_REGS.
@
text
@d4 3
a245 5
(*
    INIT of any_register | (* Register is initialised here *)
    USE of any_register | (* Register is used here *)
    DISCARD of any_register | (* Register is not used after here *)
*)
d251 3
@


1.18
log
@Added MODV
@
text
@d4 3
d249 2
a250 1
    PRESERVE_REGS |
d252 1
a252 1
    RESTORE_REGS |
@


1.17
log
@Changed branches to target bl_dest
@
text
@d4 3
d166 2
a167 1
  DIVV
@


1.16
log
@Added ALLOCA for stack allocated items
@
text
@d4 3
d228 1
a228 1
    BRANCH of branch * tag |
@


1.15
log
@Added new type symbolic, and extra constructor GP_IMM_SYMB for
values not yet known
@
text
@d4 4
d208 6
a213 1
  datatype allocate = ALLOC | ALLOC_REAL | ALLOC_STRING | ALLOC_REF
d240 1
a240 1
    EXIT | (* Return point from procedure *)
@


1.14
log
@Added LDREF and STREF to assist optimiser deduce available expressions
@
text
@d4 3
d104 6
d116 1
@


1.13
log
@Added LDB, STB
@
text
@d4 3
d172 1
a172 1
  datatype store_op = LD | ST | LDB | STB
@


1.12
log
@Added PRESERVE_REGS and RESTORE_REGS. Removed ENTER_NO_CALLS
and EXIT_NO_CALLS
@
text
@d4 4
d169 1
a169 1
  datatype store_op = LD | ST
d202 1
a202 1
    CONVOP of int_to_float * fp_operand * reg_operand |
@


1.11
log
@Changed format for floating point operations to allow register colouring
@
text
@d4 3
d213 1
a213 1
    ENTER_NO_CALLS | (* Entry point for leaf procedure *)
d215 1
a215 1
    EXIT_NO_CALLS | (* Return point from procedure *)
@


1.10
log
@Slight change to ALLOC
@
text
@d4 3
d72 3
d100 2
a101 3
  datatype fp_double_operand =
    FP_DOUBLE_REG of fp_double_register
  | FP_DOUBLE_IMM of fp_double_immediate
d142 1
a160 7
  datatype calc_op =
    TBCALC of tagged_binary_op |
    BCALC of binary_op |
    NCALC of tagged_binary_op | (* For negate *)
    UCALC of unary_op |
    BFCALC of binary_fp_op |
    UFCALC of unary_fp_op
d190 2
a191 2
    BINARYFP of binary_fp_op * fp_register * fp_register * fp_register |
    UNARYFP of unary_fp_op * fp_register * fp_register |
d194 2
a195 2
    STOREFPOP of store_fp_op * fp_register * reg_operand * gp_operand |
    CONVOP of int_to_float * fp_register * reg_operand |
d198 1
a198 1
    FTEST of fcond_branch * tag * fp_register * fp_register |
@


1.9
log
@New ALLOC_REF
Removed data flow hints, these can be deduced.
@
text
@d4 4
d202 1
a202 1
    ALLOCATE of allocate * gc_register * int |
@


1.8
log
@Updated for later version of HARP
@
text
@d4 3
d181 1
a181 1
  datatype allocate = ALLOC | ALLOC_REAL | ALLOC_STRING
d201 1
d205 1
@


1.7
log
@Added EXT_REF type
@
text
@d4 3
a86 3
  datatype fp_operand =
    FP_REG of fp_register
  | FP_IMM of fp_immediate
d107 6
a112 3
  MUL |
  DIV |
  REM |
d115 1
d117 8
a124 5
  SHL | 
  SHR | 
  SHRL |
  DIVL |
  REML
d126 1
a126 4
  CMP |
  CMPL |
  MOV |
  NEG |
d128 20
a147 2
  datatype binary_fp_op = ADDF | SUBF | MULF | DIVF
  datatype unary_fp_op = MOVF | CMPF | NEGF
d149 1
d151 1
d156 2
a157 2
  datatype store_op = LDX | STX
  datatype store_fp_op = LDXF | STXF
d159 2
a160 2
  datatype branch =
    BRA | (* Branch to basic block *)
d170 7
a176 6
    BLT | (* Signed < *)
    BVS | (* Integer overflow *)
    BVC | (* Not integer overflow *)
    BMI | (* Signed negative *)
    BPL (* Signed positive *)
  datatype branch_and_link = BL | BLR
d181 1
d184 2
a185 2
    BINARYFP of binary_fp_op * fp_register * fp_operand * fp_operand |
    UNARYFP of unary_fp_op * fp_register * fp_operand |
d191 2
d201 2
a202 3
    ENTER of int | (* Entry point for procedure with n locals *)
    ENTER_NO_CALLS of int |
    (* Entry point for procedure with n locals and no calls *)
@


1.6
log
@Added a comment opcode to allow information to be passed through
@
text
@d4 3
d125 1
a125 1
  datatype unary_fp_op = MOVF | CMPF
d181 1
@


1.5
log
@Added new opcodes for local reference and FN_CALL as required by the
loader
@
text
@d4 4
d179 1
@


1.4
log
@Added some new instructions to indicate leaf procedures
@
text
@d4 3
d172 3
a174 1
    VALUE of (tag * Ident.SCon) list |
@


1.3
log
@Minor changes
@
text
@d4 3
d162 6
a167 3
    ENTER of int * reg_operand |
    (* Entry point for procedure, with n locals and arg reg *)
    EXIT of reg_operand | (* Return point from procedure, result in reg *)
@


1.2
log
@Changed some types to allow register colouring information plus
more general purpose operands
@
text
@d4 4
d66 2
a67 1
  | GP_IMM of int
d153 1
a153 1
    SWITCH of computed_goto * non_gc_register * tag list |
d163 2
a164 1
    VALUE of (tag * Ident.SCon) list
d167 1
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d26 1
d36 6
d60 2
a61 2
    GP_GC_REG of gc_register
  | GP_NON_GC_REG of non_gc_register
d64 2
a65 2
    GC_REG of gc_register
  | NON_GC_REG of non_gc_register
a90 1
  RSB |
d138 1
a138 1
    BINARY of binary_op * reg_operand * reg_operand * gp_operand |
d140 1
a140 1
    BINARYFP of binary_fp_op * fp_register * fp_register * fp_operand |
@
