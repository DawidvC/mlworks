head	1.97;
access;
symbols
	MLW_daveb_inline_1_4_99:1.97.3
	MLWorks_21c0_1999_03_25:1.97
	MLWorks_20c1_1998_08_20:1.97
	MLWorks_20c0_1998_08_04:1.97
	MLWorks_20b2c2_1998_06_19:1.97
	MLWorks_20b2_Windows_1998_06_12:1.97
	MLWorks_20b1c1_1998_05_07:1.97
	MLWorks_20b0_1998_04_07:1.97
	MLWorks_20b0_1998_03_20:1.97
	MLWorks_20m2_1998_02_16:1.97
	MLWorks_20m1_1997_10_23:1.97
	MLWorks_11r1:1.95.1.1.1.1.1
	MLWorks_workspace_97:1.97.2
	MLWorks_dt_wizard:1.97.1
	MLWorks_11c0_1997_09_09:1.95.1.1.1.1
	MLWorks_10r3:1.95.1.1.3
	MLWorks_10r2_551:1.95.1.1.2
	MLWorks_11:1.95.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.95.1.1
	MLWorks_20m0_1997_06_20:1.96
	MLWorks_1_0_r2c2_1997_06_14:1.95.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.95.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.95.1
	MLWorks_BugFix_1997_04_24:1.95
	MLWorks_1_0_r2_Win32_1997_04_11:1.95
	MLWorks_1_0_r2_Unix_1997_04_04:1.95
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.94.3.1.1
	MLWorks_gui_1996_12_18:1.94.4
	MLWorks_1_0_Win32_1996_12_17:1.94.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.94.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.94.1.1
	MLWorks_1_0_Irix_1996_11_28:1.94.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.94.2
	MLWorks_1_0_Unix_1996_11_14:1.94.1
	MLWorks_Open_Beta2_1996_10_11:1.92.3
	MLWorks_License_dev:1.92.2
	MLWorks_1_open_beta_1996_09_13:1.92.1
	MLWorks_Open_Beta_1996_08_22:1.92
	MLWorks_Beta_1996_07_02:1.92
	MLWorks_Beta_1996_06_07:1.92
	MLWorks_Beta_1996_06_06:1.92
	MLWorks_Beta_1996_06_05:1.92
	MLWorks_Beta_1996_06_03:1.92
	MLWorks_Beta_1996_05_31:1.92
	MLWorks_Beta_1996_05_30:1.92
	ML_beta_release_12/08/94:1.80
	ML_beta_release_03/08/94:1.80
	ML_revised_beta_release_25/05/94:1.79
	ML_final_beta_release_02/03/94:1.77
	mlworks-28-01-1994:1.77
	Release:1.75
	mlworks-beta-01-09-1993:1.75
	MLWorks-1-0-4-29/01/1993:1.70
	MLWorks-1-0-3-21/12/1992:1.69
	MLWorks-1-0-2-15/12/1992:1.69
	MLWorks-1-0-1-04/12/1992:1.69
	checkpoint_17_08_92:1.66
	Ten15_release_19-08-91:1.8
	ten15_release:1.3;
locks; strict;
comment	@ * @;


1.97
date	97.07.31.13.22.22;	author jont;	state Exp;
branches
	1.97.1.1
	1.97.2.1
	1.97.3.1;
next	1.96;

1.96
date	97.05.21.17.02.19;	author jont;	state Exp;
branches;
next	1.95;

1.95
date	97.01.16.12.46.57;	author matthew;	state Exp;
branches
	1.95.1.1;
next	1.94;

1.94
date	96.11.06.11.08.21;	author matthew;	state Exp;
branches
	1.94.1.1
	1.94.2.1
	1.94.3.1
	1.94.4.1;
next	1.93;

1.93
date	96.10.09.11.54.35;	author io;	state Exp;
branches;
next	1.92;

1.92
date	96.05.14.10.48.33;	author matthew;	state Exp;
branches
	1.92.1.1
	1.92.2.1
	1.92.3.1;
next	1.91;

1.91
date	96.04.30.16.49.04;	author jont;	state Exp;
branches;
next	1.90;

1.90
date	96.04.30.16.49.04;	author jont;	state Exp;
branches;
next	1.89;

1.89
date	96.04.29.14.47.36;	author matthew;	state Exp;
branches;
next	1.88;

1.88
date	96.04.03.14.56.19;	author jont;	state Exp;
branches;
next	1.87;

1.87
date	96.02.02.10.57.10;	author jont;	state Exp;
branches;
next	1.86;

1.86
date	95.12.20.12.57.25;	author jont;	state Exp;
branches;
next	1.85;

1.85
date	94.11.23.14.00.18;	author matthew;	state Exp;
branches;
next	1.84;

1.84
date	94.11.11.14.20.40;	author jont;	state Exp;
branches;
next	1.83;

1.83
date	94.09.30.12.44.31;	author jont;	state Exp;
branches;
next	1.82;

1.82
date	94.09.13.11.24.15;	author matthew;	state Exp;
branches;
next	1.81;

1.81
date	94.08.25.13.45.08;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	94.07.22.16.40.12;	author matthew;	state Exp;
branches;
next	1.79;

1.79
date	94.05.12.12.50.30;	author richard;	state Exp;
branches;
next	1.78;

1.78
date	94.03.09.14.58.11;	author jont;	state Exp;
branches;
next	1.77;

1.77
date	94.01.17.18.31.52;	author daveb;	state Exp;
branches;
next	1.76;

1.76
date	93.11.04.16.30.08;	author jont;	state Exp;
branches;
next	1.75;

1.75
date	93.07.29.15.02.52;	author nosa;	state Exp;
branches
	1.75.1.1;
next	1.74;

1.74
date	93.05.18.14.30.57;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	93.04.27.13.44.05;	author richard;	state Exp;
branches;
next	1.72;

1.72
date	93.03.10.17.11.19;	author matthew;	state Exp;
branches;
next	1.71;

1.71
date	93.03.01.14.55.19;	author matthew;	state Exp;
branches;
next	1.70;

1.70
date	93.01.05.16.01.27;	author jont;	state Exp;
branches;
next	1.69;

1.69
date	92.11.02.17.35.02;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	92.08.26.13.58.55;	author jont;	state Exp;
branches;
next	1.67;

1.67
date	92.08.24.13.33.57;	author richard;	state Exp;
branches;
next	1.66;

1.66
date	92.06.29.09.14.56;	author clive;	state Exp;
branches;
next	1.65;

1.65
date	92.06.18.16.15.30;	author richard;	state Exp;
branches;
next	1.64;

1.64
date	92.06.17.15.19.11;	author jont;	state Exp;
branches;
next	1.63;

1.63
date	92.06.16.19.02.18;	author jont;	state Exp;
branches;
next	1.62;

1.62
date	92.05.18.14.19.28;	author richard;	state Exp;
branches;
next	1.61;

1.61
date	92.04.14.15.41.02;	author clive;	state Exp;
branches;
next	1.60;

1.60
date	92.02.28.15.35.25;	author richard;	state Exp;
branches;
next	1.59;

1.59
date	92.02.07.13.25.18;	author richard;	state Exp;
branches;
next	1.58;

1.58
date	92.01.23.10.01.06;	author richard;	state Exp;
branches;
next	1.57;

1.57
date	92.01.16.11.20.49;	author clive;	state Exp;
branches;
next	1.56;

1.56
date	92.01.14.13.48.38;	author jont;	state Exp;
branches;
next	1.55;

1.55
date	92.01.03.16.05.35;	author richard;	state Exp;
branches;
next	1.54;

1.54
date	91.12.02.14.00.22;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	91.11.20.12.31.34;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	91.11.14.15.48.58;	author richard;	state Exp;
branches;
next	1.51;

1.51
date	91.11.14.11.15.14;	author richard;	state Exp;
branches;
next	1.50;

1.50
date	91.11.08.16.09.39;	author richard;	state Exp;
branches;
next	1.49;

1.49
date	91.11.05.10.16.31;	author richard;	state Exp;
branches;
next	1.48;

1.48
date	91.10.28.15.21.26;	author richard;	state Exp;
branches;
next	1.47;

1.47
date	91.10.28.12.02.46;	author davidt;	state Exp;
branches;
next	1.46;

1.46
date	91.10.24.10.42.05;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	91.10.21.09.35.17;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	91.10.18.14.23.01;	author richard;	state Exp;
branches;
next	1.43;

1.43
date	91.10.17.14.39.15;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	91.10.17.09.27.49;	author richard;	state Exp;
branches;
next	1.41;

1.41
date	91.10.16.16.07.11;	author richard;	state Exp;
branches;
next	1.40;

1.40
date	91.10.16.14.18.21;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	91.10.15.15.24.56;	author richard;	state Exp;
branches;
next	1.38;

1.38
date	91.10.11.14.53.39;	author richard;	state Exp;
branches;
next	1.37;

1.37
date	91.10.11.10.05.24;	author richard;	state Exp;
branches;
next	1.36;

1.36
date	91.10.10.13.39.48;	author richard;	state Exp;
branches;
next	1.34;

1.34
date	91.10.08.15.49.05;	author richard;	state Exp;
branches;
next	1.33;

1.33
date	91.10.04.15.12.13;	author richard;	state Exp;
branches;
next	1.32;

1.32
date	91.10.04.11.54.07;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	91.10.04.08.35.14;	author richard;	state Exp;
branches;
next	1.30;

1.30
date	91.10.03.11.25.08;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	91.10.03.10.57.42;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	91.10.02.11.11.47;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	91.09.25.16.11.08;	author richard;	state Exp;
branches
	1.27.1.1;
next	1.26;

1.26
date	91.09.23.10.38.29;	author richard;	state Exp;
branches;
next	1.25;

1.25
date	91.09.20.15.48.46;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	91.09.20.13.53.58;	author richard;	state Exp;
branches;
next	1.23;

1.23
date	91.09.19.15.53.07;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	91.09.17.13.52.21;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	91.09.17.10.45.27;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	91.09.11.14.40.36;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	91.09.10.15.51.43;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	91.09.09.14.05.26;	author davida;	state Exp;
branches;
next	1.17;

1.17
date	91.09.09.13.41.59;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	91.09.06.15.55.12;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	91.09.05.15.57.59;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	91.09.05.13.06.49;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	91.09.03.16.36.13;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	91.09.03.13.55.19;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	91.08.30.16.34.35;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.08.29.15.57.54;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.08.22.16.41.03;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.08.15.14.39.07;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.08.09.16.58.29;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.08.05.10.46.45;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.08.02.16.36.42;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.08.01.17.20.40;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.07.30.16.22.11;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.07.26.20.00.13;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.07.25.15.45.09;	author jont;	state Exp;
branches;
next	;

1.27.1.1
date	91.09.26.13.52.26;	author richard;	state Exp;
branches;
next	;

1.75.1.1
date	93.07.29.15.02.52;	author jont;	state Exp;
branches;
next	;

1.92.1.1
date	96.09.13.11.14.50;	author hope;	state Exp;
branches;
next	;

1.92.2.1
date	96.10.07.16.05.12;	author hope;	state Exp;
branches;
next	;

1.92.3.1
date	96.10.17.11.23.27;	author hope;	state Exp;
branches;
next	;

1.94.1.1
date	96.11.14.12.47.47;	author hope;	state Exp;
branches
	1.94.1.1.1.1;
next	;

1.94.1.1.1.1
date	96.11.28.14.59.19;	author hope;	state Exp;
branches;
next	;

1.94.2.1
date	96.11.22.18.07.50;	author hope;	state Exp;
branches;
next	;

1.94.3.1
date	96.12.17.17.46.31;	author hope;	state Exp;
branches
	1.94.3.1.1.1;
next	;

1.94.3.1.1.1
date	97.02.24.11.36.10;	author hope;	state Exp;
branches;
next	;

1.94.4.1
date	96.12.18.09.40.31;	author hope;	state Exp;
branches;
next	;

1.95.1.1
date	97.05.12.10.32.52;	author hope;	state Exp;
branches
	1.95.1.1.1.1
	1.95.1.1.2.1
	1.95.1.1.3.1;
next	;

1.95.1.1.1.1
date	97.07.28.18.17.47;	author daveb;	state Exp;
branches
	1.95.1.1.1.1.1.1;
next	;

1.95.1.1.1.1.1.1
date	97.10.07.11.42.41;	author jkbrook;	state Exp;
branches;
next	;

1.95.1.1.2.1
date	97.09.08.17.11.20;	author daveb;	state Exp;
branches;
next	;

1.95.1.1.3.1
date	97.09.09.14.06.56;	author daveb;	state Exp;
branches;
next	;

1.97.1.1
date	97.09.10.19.21.32;	author brucem;	state Exp;
branches;
next	;

1.97.2.1
date	97.09.11.20.52.47;	author daveb;	state Exp;
branches;
next	;

1.97.3.1
date	99.04.01.17.55.49;	author daveb;	state Exp;
branches;
next	;


desc
@Printing of mir for debugging purposes
@


1.97
log
@[Bug #30215]
Replacing BIC by INTTAG
@
text
@(* _mirprint.sml the functor *)
(*
$Log: _mirprint.sml,v $
 * Revision 1.96  1997/05/21  17:02:19  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
 * Revision 1.95  1997/01/16  12:46:57  matthew
 * Have tag list in tagged operations
 *
 * Revision 1.94  1996/11/06  11:08:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.93  1996/10/09  11:54:35  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.92  1996/05/14  10:48:33  matthew
 * Added NOT32
 *
 * Revision 1.91  1996/04/30  16:49:04  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.89  1996/04/29  14:47:36  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.88  1996/04/03  14:56:19  jont
 * Add ability to deal with RuntimeEnv.OFFSET spill entries
 *
 * Revision 1.87  1996/02/02  10:57:10  jont
 * Add printing of new tagged operations for 32 bit integers
 *
Revision 1.86  1995/12/20  12:57:25  jont
Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend

Revision 1.85  1994/11/23  14:00:18  matthew
Adding ALLOC_VECTOR

Revision 1.84  1994/11/11  14:20:40  jont
Add immediate store operations

Revision 1.83  1994/09/30  12:44:31  jont
Remove handler register concept

Revision 1.82  1994/09/13  11:24:15  matthew
Abstraction of debug information

Revision 1.81  1994/08/25  13:45:08  matthew
Changes to annotations

Revision 1.80  1994/07/22  16:40:12  matthew
Added function argument register lists to BRANCH_AND_LINK, TAIL_CALL and ENTER
Changed loop entry points to be a list

Revision 1.79  1994/05/12  12:50:30  richard
Add field to MirTypes.PROC_PARAMS.

Revision 1.78  1994/03/09  14:58:11  jont
Adding load offset instruction

Revision 1.77  1994/01/17  18:31:52  daveb
Removed unnecessary exceptions from closures.

Revision 1.76  1993/11/04  16:30:08  jont
Added INTERRUPT instruction

Revision 1.75  1993/07/29  15:02:52  nosa
New stack spill slots for local and closure variable inspection
in the debugger;
structure Option.

Revision 1.74  1993/05/18  14:30:57  jont
Removed Integer parameter

Revision 1.73  1993/04/27  13:44:05  richard
Changed PROFILE instruction to INTERCEPT.

Revision 1.72  1993/03/10  17:11:19  matthew
Signature revisions

Revision 1.71  1993/03/01  14:55:19  matthew
Added MLVALUE lambda exp

Revision 1.70  1993/01/05  16:01:27  jont
Modified to print directly to a given stream for speed and controllability

Revision 1.69  1992/11/02  17:35:02  jont
Reworked in terms of mononewmap

Revision 1.68  1992/08/26  13:58:55  jont
Removed some redundant structures and sharing

Revision 1.67  1992/08/24  13:33:57  richard
Added NULLARY opcode type.
Added ALLOC_BYTEARRAY.

Revision 1.66  1992/06/29  09:14:56  clive
Added type annotation information at application points

Revision 1.65  1992/06/18  16:15:30  richard
Added parameter to RAISE once again.

Revision 1.64  1992/06/17  15:19:11  jont
Added printing for interpretive external types

Revision 1.63  1992/06/16  19:02:18  jont
Expanded refs section of mir_code to allow for interpretive stuff

Revision 1.62  1992/05/18  14:19:28  richard
Removed redundant names from register printing routines.

Revision 1.61  1992/04/14  15:41:02  clive
First version of the profiler

Revision 1.60  1992/02/28  15:35:25  richard
Changed the way virtual registers are handled.  See MirTypes.
Added switches to allow different printing format for virtual
registers.

Revision 1.59  1992/02/07  13:25:18  richard
Abolished PREVIOUS_ENVIRONMENT and PRESERVE_ALL_REGS.
Changed register lookup to use Map rather than Table.

Revision 1.58  1992/01/23  10:01:06  richard
Added special case printing of the `implicit' register.

Revision 1.57  1992/01/16  11:20:49  clive
Alloc may now have a register argument for allocating arrays

Revision 1.56  1992/01/14  13:48:38  jont
Raise no longer has a parameter

Revision 1.55  1992/01/03  16:05:35  richard
Added the zero register (if present) to those registers printed
with names.

Revision 1.54  1991/12/02  14:00:22  jont
Added tail call operation

Revision 1.53  91/11/20  12:31:34  jont
Added exception generating fp opcodes

Revision 1.52  91/11/14  15:48:58  richard
Added printing for the CALL_C opcode.

Revision 1.51  91/11/14  11:15:14  richard
Removed references to fp_double registers.

Revision 1.50  91/11/08  16:09:39  richard
Added argument to STACKOP and new opcodes FSTREF and FLDREF.

Revision 1.49  91/11/05  10:16:31  richard
Added procedure print function.

Revision 1.48  91/10/28  15:21:26  richard
Changed the form of the allocation instructions yet again.

Revision 1.47  91/10/28  12:02:46  davidt
ALLOCATE doesn't have a scratch register or a proc_ref any more.

Revision 1.46  91/10/24  10:42:05  jont
Added BTA and BNT for tagged value testing

Revision 1.45  91/10/21  09:35:17  jont
New local and external reference code

Revision 1.44  91/10/18  14:23:01  richard
Tidied up output of ALLOCATE opcodes.

Revision 1.43  91/10/17  14:39:15  jont
New ALLOC opcodes

Revision 1.42  91/10/17  09:27:49  richard
Changed the way registers are displayed again.

Revision 1.41  91/10/16  16:07:11  richard
A big mindless clean-up while I thought about register colouring.

Revision 1.40  91/10/16  14:18:21  jont
Updated to reflect new simplified module structure
Added parameter to heap allocation to indicate position in closure
of call_c function

Revision 1.39  91/10/15  15:24:56  richard
When decoding the names of registers which are aliases of real registers
the real names are displayed also. Added ALLOC_PAIR.

Revision 1.38  91/10/11  14:53:39  richard
Added DEALLOC_STACK and fixed a minor carriage return bug.

Revision 1.37  91/10/11  10:05:24  richard
Slight alterations to cope with new MirTypes.

Revision 1.36  91/10/10  13:39:48  richard
Removed RESTORE_REGS and PRESERVE_REGS and replaced with
PREVIOUS_ENVIRONMENT. Parameterized RAISE.

Revision 1.34  91/10/08  15:49:05  richard
Added code to print "global" for the global GC register rather than
its number.

Revision 1.33  91/10/04  15:12:13  richard
Rewrote higher level printing functions to nest neatly, and also
to print the non-procedure information from the Mir code.

Revision 1.32  91/10/04  11:54:07  jont
Changed to use new PROC type for bundling up procedures

Revision 1.31  91/10/04  08:35:14  richard
Added fp_operand.

Revision 1.30  91/10/03  11:25:08  jont
Printed new structure of code

Revision 1.29  91/10/03  10:57:42  jont
Changed CODE structure to enable easier handling of code, values
and load time semantics

Revision 1.28  91/10/02  11:11:47  jont
Removed real register options, these are being done elsewhere

Revision 1.27  91/09/25  16:11:08  richard
Removed redundant FP(...) from printing functions.

Revision 1.26  91/09/23  10:38:29  richard
Added NEW_HANDLER, OLD_HANDLER, and RAISE directives.

Revision 1.25  91/09/20  15:48:46  jont
Added PRESERVE_ALL_REGS

Revision 1.24  91/09/20  13:53:58  richard
Modified register printing functions to display the names of the
special registers rather than their numbers.

Revision 1.23  91/09/19  15:53:07  jont
Added printing for MODV

Revision 1.22  91/09/17  13:52:21  jont
Changed branches to target bl_dest

Revision 1.21  91/09/17  10:45:27  jont
Added ALLOCA for stack allocated items

Revision 1.20  91/09/11  14:40:36  richard
Brought reg_operand function to the outside.

Revision 1.19  91/09/10  15:51:43  jont
Decoded symbolics

Revision 1.18  91/09/09  14:05:26  davida
Changed to use reduce function from Lists

Revision 1.17  91/09/09  13:41:59  richard
Yet more functions made available. Names containing ``print''
shortened (it's in the structure name).

Revision 1.16  91/09/06  15:55:12  richard
Still more functions revealed to the outside world (but
mostly to MirDataFlow so I can watch what it is doing).

Revision 1.15  91/09/05  15:57:59  jont
Added LDREF and STREF to assist optimiser deduce available expressions

Revision 1.14  91/09/05  13:06:49  richard
Added functions to allow individual opcodes and blocks to be printed.

Revision 1.13  91/09/03  16:36:13  jont
Added printing of byte loads and stores needed for string operations

Revision 1.12  91/09/03  13:55:19  jont
Changed printing of ENTRY and EXIT. Added printing of STOREFPOP

Revision 1.11  91/08/30  16:34:35  jont
Changed format for floating point operations

Revision 1.10  91/08/29  15:57:54  jont
Slight change to ALLOC

Revision 1.9  91/08/22  16:41:03  jont
Data flow analysis

Revision 1.8  91/08/15  14:39:07  jont
Updated for later version of HARP

Revision 1.7  91/08/09  16:58:29  jont
More items printed

Revision 1.6  91/08/05  10:46:45  jont
More items printed.

Revision 1.5  91/08/02  16:36:42  jont
More opcodes printed

Revision 1.4  91/08/01  17:20:40  jont
More opcodes printed

Revision 1.3  91/07/30  16:22:11  jont
Printed more opcodes (branch and cgt)

Revision 1.2  91/07/26  20:00:13  jont
Redid some printing in light of changes in mirtypes

Revision 1.1  91/07/25  15:45:09  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";
require "../basis/__text_io";

require "../utils/lists";
require "../utils/crash";
require "../basics/identprint";
require "mirregisters";
require "mirprint";


functor MirPrint(
  structure Lists : LISTS
  structure Crash : CRASH
  structure IdentPrint : IDENTPRINT
  structure MirRegisters : MIRREGISTERS

  sharing type IdentPrint.Ident.SCon = MirRegisters.MirTypes.SCon

) : MIRPRINT =

struct

  structure MirTypes = MirRegisters.MirTypes
  structure Set = MirTypes.Set
  structure RuntimeEnv = MirTypes.Debugger_Types.RuntimeEnv

  fun binary MirTypes.ADDU = "ADDU"
    | binary MirTypes.SUBU = "SUBU"
    | binary MirTypes.MULU = "MULU"
    | binary MirTypes.MUL32U = "MUL32U"
    | binary MirTypes.AND = "AND"
    | binary MirTypes.OR = "OR"
    | binary MirTypes.EOR = "EOR"
    | binary MirTypes.LSR = "LSR"
    | binary MirTypes.ASL = "ASL"
    | binary MirTypes.ASR = "ASR"
      
    fun tagged_binary MirTypes.ADDS = "ADDS"
      | tagged_binary MirTypes.SUBS = "SUBS"

      (* Handle overflow specially for these *)
      (* (because traps are hard) *)
      | tagged_binary MirTypes.ADD32S = "ADD32S"
      | tagged_binary MirTypes.SUB32S = "SUB32S"

      | tagged_binary MirTypes.MULS = "MULS"
      | tagged_binary MirTypes.DIVS = "DIVS"
      | tagged_binary MirTypes.MODS = "MODS"

      | tagged_binary MirTypes.MUL32S = "MUL32S"
      | tagged_binary MirTypes.DIV32S = "DIV32S"
      | tagged_binary MirTypes.MOD32S = "MOD32S"
      (* These can raise Div *)
      | tagged_binary MirTypes.DIVU = "DIVU"
      | tagged_binary MirTypes.MODU = "MODU"
      | tagged_binary MirTypes.DIV32U = "DIV32U"
      | tagged_binary MirTypes.MOD32U = "MOD32U"

  fun unary MirTypes.MOVE = "MOVE"
    | unary MirTypes.INTTAG = "INTTAG"
    | unary MirTypes.NOT = "NOT"
    | unary MirTypes.NOT32 = "NOT32"

  fun nullary MirTypes.CLEAN = "CLEAN"

  fun binaryfp MirTypes.FADD = "FADD"
    | binaryfp MirTypes.FSUB = "FSUB"
    | binaryfp MirTypes.FMUL = "FMUL"
    | binaryfp MirTypes.FDIV = "FDIV"

  fun tagged_binaryfp MirTypes.FADDV = "FADDV"
    | tagged_binaryfp MirTypes.FSUBV = "FSUBV"
    | tagged_binaryfp MirTypes.FMULV = "FMULV"
    | tagged_binaryfp MirTypes.FDIVV = "FDIVV"

  fun unaryfp MirTypes.FABS = "FABS"
    | unaryfp MirTypes.FNEG = "FNEG"
    | unaryfp MirTypes.FMOVE = "FMOVE"
    | unaryfp MirTypes.FINT = "FINT"
    | unaryfp MirTypes.FSQRT = "FSQRT"
    | unaryfp MirTypes.FLOG10 = "FLOG10"
    | unaryfp MirTypes.FLOG2 = "FLOG2"
    | unaryfp MirTypes.FLOGE = "FLOGE"
    | unaryfp MirTypes.FLOGEP1 = "FLOGEP1"
    | unaryfp MirTypes.F10TOX = "F10TOX"
    | unaryfp MirTypes.F2TOX = "F2TOX"
    | unaryfp MirTypes.FETOX = "FETOX"
    | unaryfp MirTypes.TETOXM1 = "TETOXM1"
    | unaryfp MirTypes.FSIN = "FSIN"
    | unaryfp MirTypes.FCOS = "FCOS"
    | unaryfp MirTypes.FTAN = "FTAN"
    | unaryfp MirTypes.FASIN = "FASIN"
    | unaryfp MirTypes.FACOS = "FACOS"
    | unaryfp MirTypes.FATAN = "FATAN"

  fun tagged_unaryfp MirTypes.FABSV = "FABSV"
    | tagged_unaryfp MirTypes.FNEGV = "FNEGV"
    | tagged_unaryfp MirTypes.FSQRTV = "FSQRTV"
    | tagged_unaryfp MirTypes.FLOGEV = "FLOGEV"
    | tagged_unaryfp MirTypes.FETOXV = "FETOXV"

  fun store MirTypes.LD = "LD"
    | store MirTypes.ST = "ST"
    | store MirTypes.LDB = "LDB"
    | store MirTypes.STB = "STB"
    | store MirTypes.LDREF = "LDREF"
    | store MirTypes.STREF = "STREF"

  fun storefp MirTypes.FLD = "FLD"
    | storefp MirTypes.FST = "FST"
    | storefp MirTypes.FSTREF = "FSTREF"
    | storefp MirTypes.FLDREF = "FLDREF"

  fun int_to_float MirTypes.ITOF = "ITOF"

  fun float_to_int MirTypes.FTOI = "FTOI"

  fun allocate MirTypes.ALLOC = "ALLOC"
    | allocate MirTypes.ALLOC_VECTOR = "ALLOC_VECTOR"
    | allocate MirTypes.ALLOC_REAL = "ALLOC_REAL"
    | allocate MirTypes.ALLOC_STRING = "ALLOC_STRING"
    | allocate MirTypes.ALLOC_REF = "ALLOC_REF"
    | allocate MirTypes.ALLOC_BYTEARRAY = "ALLOC_BYTEARRAY"

  fun allocate_stack operator =
    "STACK_" ^ allocate operator

  fun deallocate_stack operator =
    "STACK_DE" ^ allocate operator
      
  fun branch MirTypes.BRA = "BRA"

  fun test MirTypes.BTA = "BTA"
    | test MirTypes.BNT = "BNT"
    | test MirTypes.BEQ = "BEQ"
    | test MirTypes.BNE = "BNE"
    | test MirTypes.BHI = "BHI"
    | test MirTypes.BLS = "BLS"
    | test MirTypes.BHS = "BHS"
    | test MirTypes.BLO = "BLO"
    | test MirTypes.BGT = "BGT"
    | test MirTypes.BLE = "BLE"
    | test MirTypes.BGE = "BGE"
    | test MirTypes.BLT = "BLT"

  fun ftest MirTypes.FBEQ = "FBEQ"
    | ftest MirTypes.FBNE = "FBNE"
    | ftest MirTypes.FBLE = "FBLE"
    | ftest MirTypes.FBLT = "FBLT"

  fun adr MirTypes.LEA = "LEA"
    | adr MirTypes.LEO = "LEO"

  fun stack_op MirTypes.PUSH = "PUSH"
    | stack_op MirTypes.POP = "POP"

  fun branch_and_link MirTypes.BLR = "BLR"

  fun tail_call MirTypes.TAIL = "TAIL"

  val show_register_names = ref true
  val show_real_registers = ref true

  local
    open MirRegisters
  in
    fun gc_register gc_reg =
      let
	val name =
          if !show_register_names then
            if gc_reg = caller_arg then "/caller_argument"
            else if gc_reg = callee_arg then "/argument"
            else if gc_reg = caller_closure then "/caller_closure"
            else if gc_reg = callee_closure then "/closure"
            else if gc_reg = fp then "/frame"
            else if gc_reg = sp then "/stack"
            else if gc_reg = global then "/global"
            else if gc_reg = implicit then "/implicit"
                 else
                   case MirRegisters.zero
                     of SOME zero => if gc_reg = zero then "/zero" else ""
                      | NONE => ""
          else ""

        val machine_reg =
          if !show_real_registers then
            ("/" ^ MachSpec.print_register (MirTypes.GC.Map.apply (#gc machine_register_assignments) gc_reg))
            handle MirTypes.GC.Map.Undefined => ""
          else ""
      in
	MirTypes.GC.to_string gc_reg ^ name ^ machine_reg
      end

    fun non_gc_register non_gc_reg =
      let
        val machine_reg =
          if !show_real_registers then
            ("/" ^ MachSpec.print_register (MirTypes.NonGC.Map.apply (#non_gc machine_register_assignments) non_gc_reg))
            handle MirTypes.NonGC.Map.Undefined => ""
          else ""
      in
        MirTypes.NonGC.to_string non_gc_reg ^ machine_reg
      end

    fun fp_register fp_reg =
      let
        val machine_reg =
          if !show_real_registers then
            ("/" ^ MachSpec.print_register (MirTypes.FP.Map.apply (#fp machine_register_assignments) fp_reg))
            handle MirTypes.FP.Map.Undefined => ""
          else ""
      in
        MirTypes.FP.to_string fp_reg ^ machine_reg
      end

  end


  fun reg_operand(MirTypes.GC_REG gc_reg) =
      gc_register gc_reg
    | reg_operand(MirTypes.NON_GC_REG non_gc_reg) =
      non_gc_register non_gc_reg

  fun fp_operand(MirTypes.FP_REG fp_reg) =
      fp_register fp_reg

  fun any_reg(MirTypes.GC gc_reg) =
      gc_register gc_reg
    | any_reg(MirTypes.NON_GC non_gc_reg) =
      non_gc_register non_gc_reg
    | any_reg(MirTypes.FLOAT fp_reg) =
      fp_register fp_reg

  fun offset2(ref(RuntimeEnv.OFFSET2(RuntimeEnv.GC, i)), name) =
    "GC_SPILL_SLOT (mach_cg) (" ^ Int.toString i ^ ":" ^ name ^ ")"
    | offset2(ref(RuntimeEnv.OFFSET2(RuntimeEnv.NONGC, i)), name) =
      "NON_GC_SPILL_SLOT (mach_cg) (" ^ Int.toString i ^ ":" ^ name ^ ")"
    | offset2(ref(RuntimeEnv.OFFSET2(RuntimeEnv.FP, i)), name) =
      "FP_SPILL_SLOT (mach_cg) (" ^ Int.toString i ^ ":" ^ name ^ ")"
    | offset2 _ = Crash.impossible "offset2:_mirprint.sml"

  fun symb MirTypes.GC_SPILL_SIZE = "GC_SPILL_SIZE"
    | symb MirTypes.NON_GC_SPILL_SIZE = "NON_GC_SPILL_SIZE"
    | symb (MirTypes.GC_SPILL_SLOT (MirTypes.SIMPLE n)) =
      "GC_SPILL_SLOT(" ^ Int.toString n ^ ")"
    | symb (MirTypes.GC_SPILL_SLOT (MirTypes.DEBUG (ref (RuntimeEnv.OFFSET1(n)),name))) =
      "GC_SPILL_SLOT(" ^ Int.toString n ^ ":"^name^")"
    | symb (MirTypes.NON_GC_SPILL_SLOT (MirTypes.SIMPLE n)) =
      "NON_GC_SPILL_SLOT(" ^ Int.toString n ^ ")"
    | symb (MirTypes.NON_GC_SPILL_SLOT (MirTypes.DEBUG (ref (RuntimeEnv.OFFSET1(n)),name))) =
      "NON_GC_SPILL_SLOT(" ^ Int.toString n ^ ":"^name^")"
    | symb (MirTypes.FP_SPILL_SLOT (MirTypes.SIMPLE n)) =
      "FP_SPILL_SLOT(" ^ Int.toString n ^ ")"
    | symb (MirTypes.FP_SPILL_SLOT (MirTypes.DEBUG (ref (RuntimeEnv.OFFSET1(n)),name))) =
      "FP_SPILL_SLOT(" ^ Int.toString n ^ ":"^name^")"
    | symb(MirTypes.GC_SPILL_SLOT(MirTypes.DEBUG x)) = offset2 x
    | symb(MirTypes.NON_GC_SPILL_SLOT(MirTypes.DEBUG x)) = offset2 x
    | symb(MirTypes.FP_SPILL_SLOT(MirTypes.DEBUG x)) = offset2 x

  fun gp_operand(MirTypes.GP_GC_REG gc_reg) =
      gc_register gc_reg
    | gp_operand(MirTypes.GP_NON_GC_REG non_gc_reg) =
      non_gc_register non_gc_reg
    | gp_operand(MirTypes.GP_IMM_INT imm) =
      Int.toString imm
    | gp_operand(MirTypes.GP_IMM_ANY imm) =
      "Any:" ^ Int.toString imm
    | gp_operand(MirTypes.GP_IMM_SYMB symbol) =
      symb symbol

  fun bl_dest(MirTypes.TAG tag) = MirTypes.print_tag tag
    | bl_dest(MirTypes.REG reg) = reg_operand reg

  fun cat x =
    let
      fun cat'([], done) = concat(rev done)
      | cat'(s :: ss, done) = cat'(ss, " " :: s :: done)
    in
      cat'(x, [])
    end

  val tag = MirTypes.print_tag

  fun opcode(MirTypes.BINARY(operator, reg, gp1, gp2)) =
      cat [binary operator, reg_operand reg, gp_operand gp1, gp_operand gp2]

    | opcode(MirTypes.TBINARY(operator, tag1, reg, gp1, gp2)) =
      cat [tagged_binary operator, MirTypes.print_tag_list tag1, reg_operand reg,
	   gp_operand gp1, gp_operand gp2]

    | opcode(MirTypes.UNARY(operator, reg, gp)) =
      cat [unary operator, reg_operand reg, gp_operand gp]

    | opcode(MirTypes.NULLARY(operator, reg)) =
      cat [nullary operator, reg_operand reg]

    | opcode(MirTypes.STOREOP(operator, reg1, reg2, gp)) =
      cat [store operator, reg_operand reg1, reg_operand reg2, gp_operand gp]
    
    | opcode(MirTypes.IMMSTOREOP(operator, gp1, reg, gp2)) =
      cat [store operator, gp_operand gp1, reg_operand reg, gp_operand gp2]
    
    | opcode(MirTypes.ALLOCATE(operator, reg1, imm)) =
      cat [allocate operator, reg_operand reg1,
	   case operator of
	     MirTypes.ALLOC_REAL => ""
	   | _ => gp_operand imm]

    | opcode(MirTypes.ALLOCATE_STACK(operator, reg1, imm, NONE)) =
      cat [allocate_stack operator, reg_operand reg1,
	   case operator
	     of MirTypes.ALLOC_REAL => ""
	      | _ => Int.toString imm]

    | opcode(MirTypes.ALLOCATE_STACK(operator, reg1, imm,
				     SOME offset)) =
      cat [allocate_stack operator, reg_operand reg1,
	   case operator
	      of MirTypes.ALLOC_REAL => ""
	       | _ => Int.toString imm,
	   "OFFSET", Int.toString offset]

    | opcode(MirTypes.DEALLOCATE_STACK(operator, imm)) =
      cat [deallocate_stack operator, Int.toString imm]

    | opcode(MirTypes.BRANCH(operator, bl_dest1)) =
      cat [branch operator, bl_dest bl_dest1]
    
    | opcode(MirTypes.TEST(operator, tag1, gp, gp')) =
      cat [test operator, tag tag1, gp_operand gp, gp_operand gp']
    
    | opcode(MirTypes.FTEST(operator, tag1, fp, fp')) =
      cat [ftest operator, tag tag1, fp_operand fp, fp_operand fp']

    | opcode(MirTypes.SWITCH(_, reg, tag_list)) =
      cat (["CGT", reg_operand reg] @@ map tag tag_list)

    | opcode(MirTypes.ADR(operator, reg, tag1)) =
      cat [adr operator, reg_operand reg, tag tag1]

    | opcode MirTypes.INTERCEPT = "Intercept"

    | opcode MirTypes.INTERRUPT = "Interrupt"

    | opcode (MirTypes.ENTER _) = "Procedure entry"

    | opcode MirTypes.RTS = "Procedure exit"
    
    | opcode(MirTypes.NEW_HANDLER (stack, tag1)) =
      "New exception handler at tag " ^ tag tag1

    | opcode(MirTypes.OLD_HANDLER) =
      "Restore previous exception handler"

    | opcode(MirTypes.RAISE reg) =
      "Raise " ^ reg_operand reg

    | opcode(MirTypes.BINARYFP(operator, fp1, fp2, fp3)) =
      cat [binaryfp operator, fp_operand fp1, fp_operand fp2,
	   fp_operand fp3]

    | opcode(MirTypes.UNARYFP(operator, fp, fp')) =
      cat [unaryfp operator, fp_operand fp, fp_operand fp']

    | opcode(MirTypes.TBINARYFP(operator, tag, fp1, fp2, fp3)) =
      cat [tagged_binaryfp operator, MirTypes.print_tag_list tag, fp_operand fp1,
	   fp_operand fp2, fp_operand fp3]

    | opcode(MirTypes.TUNARYFP(operator, tag, fp, fp')) =
      cat [tagged_unaryfp operator, MirTypes.print_tag_list tag, fp_operand fp,
	   fp_operand fp']

    | opcode(MirTypes.STACKOP(operator, reg, NONE)) =
      cat [stack_op operator, reg_operand reg]

    | opcode (MirTypes.STACKOP(operator, reg, SOME offset)) =
      cat [stack_op operator, reg_operand reg,
	   "OFFSET", Int.toString offset]

    | opcode(MirTypes.STOREFPOP(operator, fp, reg, gp)) =
      cat [storefp operator, fp_operand fp, reg_operand reg, gp_operand gp]

    | opcode(MirTypes.REAL(operator, fp, gp)) =
      cat [int_to_float operator, fp_operand fp, gp_operand gp]

    | opcode(MirTypes.FLOOR(operator, tag, reg, fp)) =
      cat [float_to_int operator, MirTypes.print_tag tag, reg_operand reg,
	   fp_operand fp]

    | opcode(MirTypes.BRANCH_AND_LINK(operator, bl_dest1,_,_)) =
      cat [branch_and_link operator, bl_dest bl_dest1]

    | opcode(MirTypes.TAIL_CALL(operator, bl_dest1,_)) =
      cat [tail_call operator, bl_dest bl_dest1]

    | opcode MirTypes.CALL_C = "CALL_C"

    | opcode(MirTypes.COMMENT s) = " ; " ^ s


  local

    fun any_block_list (name, indent) (MirTypes.BLOCK(tag, opcodes)) =
      let
	val newl = "\n " ^ indent
      in
	indent ^ name ^ " " ^ MirTypes.print_tag tag ::
	map
	(fn opc => newl ^ opcode opc)
	opcodes
      end

    fun any_block(name, indent) (MirTypes.BLOCK(tag, opcodes)) =
      concat(any_block_list (name, indent) (MirTypes.BLOCK(tag, opcodes)))
  in
    val block = any_block ("Block", "    ")
    fun block_print(stream, MirTypes.BLOCK(tag, opcodes)) =
      Lists.iterate
      (fn x => TextIO.output(stream, x))
      (any_block_list ("Block", "    ")
       (MirTypes.BLOCK(tag, opcodes)))
  end


  fun procedure (MirTypes.PROC(name_string,
                               start_tag,
			       MirTypes.PROC_PARAMS {spill_sizes,
						     old_spill_sizes,
						     stack_allocated},
			       blocks,_)) =
    let

      val spill_string =
	case spill_sizes
	  of NONE => "\n    No spill size information."
	   | SOME {gc, non_gc, fp} =>
	       ("\n    Spill areas: GC " ^ Int.toString gc ^
		", NON_GC " ^ Int.toString non_gc ^
		", FP " ^ Int.toString fp)

      val old_spill_string =
	case old_spill_sizes
	  of NONE => "\n    No previous spill size information."
	   | SOME {gc, non_gc, fp} =>
	       ("\n    Spill areas: GC " ^ Int.toString gc ^
		", NON_GC " ^ Int.toString non_gc ^
		", FP " ^ Int.toString fp)

      val stack_string =
	case stack_allocated
	  of NONE => "\n    No stack allocation information."
	   | SOME s =>
	       ("\n    " ^ Int.toString s ^
		" words of stack required.")


      val message =
	"   Procedure " ^ MirTypes.print_tag start_tag ^ " " ^ name_string ^
	spill_string ^ old_spill_string ^ stack_string 

    in
      Lists.reducel
      (fn (a,b) => a ^ "\n" ^ b)
      (message, map block blocks)
    end

  fun procedure_print(stream,
		      MirTypes.PROC(name_string,
				    start_tag,
				    MirTypes.PROC_PARAMS {spill_sizes,
							  old_spill_sizes,
							  stack_allocated},
				    blocks,_)) =
    let
      val spill_string =
	case spill_sizes
	  of NONE => "\n    No spill size information."
	   | SOME {gc, non_gc, fp} =>
	       ("\n    Spill areas: GC " ^ Int.toString gc ^
		", NON_GC " ^ Int.toString non_gc ^
		", FP " ^ Int.toString fp)

      val old_spill_string =
	case old_spill_sizes
	  of NONE => "\n    No previous spill size information."
	   | SOME {gc, non_gc, fp} =>
	       ("\n    Spill areas: GC " ^ Int.toString gc ^
		", NON_GC " ^ Int.toString non_gc ^
		", FP " ^ Int.toString fp)

      val stack_string =
	case stack_allocated
	  of NONE => "\n    No stack allocation information."
	   | SOME s =>
	       ("\n    " ^ Int.toString s ^
		" words of stack required.")

    in
      TextIO.output(stream, "   Procedure ");
      TextIO.output(stream, MirTypes.print_tag start_tag);
      TextIO.output(stream, " ");
      TextIO.output(stream, name_string);
      TextIO.output(stream, " (");
      TextIO.output(stream, spill_string);
      TextIO.output(stream, old_spill_string);
      TextIO.output(stream, stack_string);
      Lists.iterate
      (fn x => (TextIO.output(stream, "\n"); block_print(stream, x)))
      blocks
    end

  val set_up = procedure

  fun proc_set_print(stream, procs) =
    (TextIO.output(stream, "  Procedure set { ");
     Lists.iterate
     (fn (MirTypes.PROC(_,tag,_,_,_)) =>
      (TextIO.output(stream, MirTypes.print_tag tag); TextIO.output(stream, " ")))
     procs;
     TextIO.output(stream, "}");
     Lists.iterate
     (fn proc => (TextIO.output(stream, "\n"); procedure_print(stream,  proc)))
     procs
     )

  fun proc_set procs =
    let
      val proc_tags =
	Lists.reducel
	(fn (a,b) => a ^ " " ^ b)
	("", map (fn MirTypes.PROC(_,tag,_,_,_) => MirTypes.print_tag tag) procs)
    in
      Lists.reducel
      (fn (a,b) => a ^ "\n" ^ b)
      ("  Procedure set {" ^ proc_tags ^ " }",
       map procedure procs)
    end


  fun refs (MirTypes.REFS(tags,
			  {requires, vars, exns, strs, funs})) =
    "  References\n   Local " ^
    Lists.to_string
    (fn (x, i) => ("Tag " ^ MirTypes.print_tag x ^ ", position " ^
		   Int.toString i)) tags ^
    "\n   External " ^
    Lists.to_string
    (fn (s, i) => s ^ ", position " ^ Int.toString i)
    requires ^
    "\n   Interpreter vars " ^
    Lists.to_string
    (fn (s, i) => s ^ ", position " ^ Int.toString i)
    vars ^
    "\n   Interpreter exns " ^
    Lists.to_string
    (fn (s, i) => s ^ ", position " ^ Int.toString i)
    exns ^
    "\n   Interpreter strs " ^
    Lists.to_string
    (fn (s, i) => s ^ ", position " ^ Int.toString i)
    strs ^
    "\n   Interpreter funs " ^
    Lists.to_string
    (fn (s, i) => s ^ ", position " ^ Int.toString i)
    funs

  fun value (MirTypes.VALUE(tag, value)) =
    case value of
      MirTypes.SCON scon =>
        MirTypes.print_tag tag ^ ": " ^ IdentPrint.printSCon scon
    | MirTypes.MLVALUE _ =>
        MirTypes.print_tag tag ^ ": <ml_value>"

  fun string_mir_code(MirTypes.CODE(the_refs, values, proc_sets)) =
    "MIR code unit\n" ^
    refs the_refs ^ "\n" ^
    (Lists.reducel
     (fn (a,b) => a ^ "\n  " ^ b)
     (" Values", map value values)) ^ "\n" ^
    (Lists.reducel
     (fn (a,b) => a ^ "\n" ^ b)
     (" Procedure sets", map proc_set proc_sets)) ^ "\n"

  fun print_mir_code (MirTypes.CODE(the_refs, values, proc_sets)) stream =
    (TextIO.output(stream, "MIR code unit\n");
     TextIO.output(stream, refs the_refs);
     TextIO.output(stream, "\n Values\n");
     Lists.iterate
     (fn x => (TextIO.output(stream, value x); TextIO.output(stream, "\n")))
     values;
     TextIO.output(stream, " Procedure sets\n");
     Lists.iterate
     (fn x => (proc_set_print(stream, x); TextIO.output(stream, "\n")))
     proc_sets)

  val binary_op = binary
  val unary_op = unary
  val binary_fp_op = binaryfp
  val unary_fp_op = unaryfp
  val store_op = store
  val store_fp_op = storefp

end
@


1.97.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.97  1997/07/31  13:22:22  jont
 * [Bug #30215]
 * Replacing BIC by INTTAG
 *
@


1.97.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.97  1997/07/31  13:22:22  jont
 * [Bug #30215]
 * Replacing BIC by INTTAG
 *
@


1.97.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.97  1997/07/31  13:22:22  jont
 * [Bug #30215]
 * Replacing BIC by INTTAG
 *
@


1.96
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@d4 4
a345 1
    | binary MirTypes.BIC = "BIC"
d373 1
@


1.95
log
@Have tag list in tagged operations
@
text
@d4 3
d260 1
a260 1
mostly to MirDataFlow so I can watch what it is doing.
d311 1
d728 1
a728 1
      (fn x => MLWorks.IO.output(stream, x))
d808 8
a815 8
      MLWorks.IO.output(stream, "   Procedure ");
      MLWorks.IO.output(stream, MirTypes.print_tag start_tag);
      MLWorks.IO.output(stream, " ");
      MLWorks.IO.output(stream, name_string);
      MLWorks.IO.output(stream, " (");
      MLWorks.IO.output(stream, spill_string);
      MLWorks.IO.output(stream, old_spill_string);
      MLWorks.IO.output(stream, stack_string);
d817 1
a817 1
      (fn x => (MLWorks.IO.output(stream, "\n"); block_print(stream, x)))
d824 1
a824 1
    (MLWorks.IO.output(stream, "  Procedure set { ");
d827 1
a827 1
      (MLWorks.IO.output(stream, MirTypes.print_tag tag); MLWorks.IO.output(stream, " ")))
d829 1
a829 1
     MLWorks.IO.output(stream, "}");
d831 1
a831 1
     (fn proc => (MLWorks.IO.output(stream, "\n"); procedure_print(stream,  proc)))
d894 3
a896 3
    (MLWorks.IO.output(stream, "MIR code unit\n");
     MLWorks.IO.output(stream, refs the_refs);
     MLWorks.IO.output(stream, "\n Values\n");
d898 1
a898 1
     (fn x => (MLWorks.IO.output(stream, value x); MLWorks.IO.output(stream, "\n")))
d900 1
a900 1
     MLWorks.IO.output(stream, " Procedure sets\n");
d902 1
a902 1
     (fn x => (proc_set_print(stream, x); MLWorks.IO.output(stream, "\n")))
@


1.95.1.1
log
@branched from 1.95
@
text
@a3 3
 * Revision 1.95  1997/01/16  12:46:57  matthew
 * Have tag list in tagged operations
 *
@


1.95.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.95.1.1  1997/05/12  10:32:52  hope
 * branched from 1.95
 *
@


1.95.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.95.1.1  1997/05/12  10:32:52  hope
 * branched from 1.95
 *
@


1.95.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.95.1.1  1997/05/12  10:32:52  hope
 * branched from 1.95
 *
@


1.95.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.95.1.1.1.1  1997/07/28  18:17:47  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.94
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d332 2
a333 2
  fun binary MirTypes.ADD = "ADD"
    | binary MirTypes.SUB = "SUB"
d335 1
a335 5
    | binary MirTypes.MULS = "MULS"
    | binary MirTypes.DIVU = "DIVU"
    | binary MirTypes.DIVS = "DIVS"
    | binary MirTypes.MODU = "MODU"
    | binary MirTypes.MODS = "MODS"
d344 20
a363 10
  fun tagged_binary MirTypes.ADDV = "ADDV"
    | tagged_binary MirTypes.SUBV = "SUBV"
    | tagged_binary MirTypes.MULV = "MULV"
    | tagged_binary MirTypes.DIVV = "DIVV"
    | tagged_binary MirTypes.MODV = "MODV"
    | tagged_binary MirTypes.ADDW = "ADDW"
    | tagged_binary MirTypes.SUBW = "SUBW"
    | tagged_binary MirTypes.MULW = "MULW"
    | tagged_binary MirTypes.DIVW = "DIVW"
    | tagged_binary MirTypes.MODW = "MODW"
d593 1
a593 1
      cat [tagged_binary operator, MirTypes.print_tag_opt tag1, reg_operand reg,
d671 1
a671 1
      cat [tagged_binaryfp operator, MirTypes.print_tag_opt tag, fp_operand fp1,
d675 1
a675 1
      cat [tagged_unaryfp operator, MirTypes.print_tag_opt tag, fp_operand fp,
@


1.94.4.1
log
@branched from 1.94
@
text
@a3 4
 * Revision 1.94  1996/11/06  11:08:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.94.3.1
log
@branched from 1.94
@
text
@a3 4
 * Revision 1.94  1996/11/06  11:08:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.94.3.1.1.1
log
@branched from 1.94.3.1
@
text
@a3 3
 * Revision 1.94.3.1  1996/12/17  17:46:31  hope
 * branched from 1.94
 *
@


1.94.2.1
log
@branched from 1.94
@
text
@a3 4
 * Revision 1.94  1996/11/06  11:08:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.94.1.1
log
@branched from 1.94
@
text
@a3 4
 * Revision 1.94  1996/11/06  11:08:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.94.1.1.1.1
log
@branched from 1.94.1.1
@
text
@a3 3
 * Revision 1.94.1.1  1996/11/14  12:47:47  hope
 * branched from 1.94
 *
@


1.93
log
@[Bug #1614]
basifying String
@
text
@d4 4
d303 1
a303 1
require "../basis/__integer";
@


1.92
log
@Added NOT32
@
text
@d4 3
d472 2
a473 2
                     of MLWorks.Option.SOME zero => if gc_reg = zero then "/zero" else ""
                      | MLWorks.Option.NONE => ""
d567 1
a567 1
      fun cat'([], done) = String.implode(rev done)
d600 1
a600 1
    | opcode(MirTypes.ALLOCATE_STACK(operator, reg1, imm, MLWorks.Option.NONE)) =
d607 1
a607 1
				     MLWorks.Option.SOME offset)) =
d664 1
a664 1
    | opcode(MirTypes.STACKOP(operator, reg, MLWorks.Option.NONE)) =
d667 1
a667 1
    | opcode (MirTypes.STACKOP(operator, reg, MLWorks.Option.SOME offset)) =
d705 1
a705 1
      String.implode(any_block_list (name, indent) (MirTypes.BLOCK(tag, opcodes)))
d726 2
a727 2
	  of MLWorks.Option.NONE => "\n    No spill size information."
	   | MLWorks.Option.SOME {gc, non_gc, fp} =>
d734 2
a735 2
	  of MLWorks.Option.NONE => "\n    No previous spill size information."
	   | MLWorks.Option.SOME {gc, non_gc, fp} =>
d742 2
a743 2
	  of MLWorks.Option.NONE => "\n    No stack allocation information."
	   | MLWorks.Option.SOME s =>
d768 2
a769 2
	  of MLWorks.Option.NONE => "\n    No spill size information."
	   | MLWorks.Option.SOME {gc, non_gc, fp} =>
d776 2
a777 2
	  of MLWorks.Option.NONE => "\n    No previous spill size information."
	   | MLWorks.Option.SOME {gc, non_gc, fp} =>
d784 2
a785 2
	  of MLWorks.Option.NONE => "\n    No stack allocation information."
	   | MLWorks.Option.SOME s =>
@


1.92.3.1
log
@branched from 1.92
@
text
@a3 3
 * Revision 1.92  1996/05/14  10:48:33  matthew
 * Added NOT32
 *
@


1.92.2.1
log
@branched from 1.92
@
text
@a3 3
 * Revision 1.92  1996/05/14  10:48:33  matthew
 * Added NOT32
 *
@


1.92.1.1
log
@branched from 1.92
@
text
@a3 3
 * Revision 1.92  1996/05/14  10:48:33  matthew
 * Added NOT32
 *
@


1.91
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d350 1
@


1.90
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@@


1.89
log
@Removing MLWorks.Integer
@
text
@d4 3
d557 1
a557 1
      fun cat'([], done) = implode(rev done)
d695 1
a695 1
      implode(any_block_list (name, indent) (MirTypes.BLOCK(tag, opcodes)))
d700 1
a700 1
      (fn x => output(stream, x))
d780 8
a787 8
      output(stream, "   Procedure ");
      output(stream, MirTypes.print_tag start_tag);
      output(stream, " ");
      output(stream, name_string);
      output(stream, " (");
      output(stream, spill_string);
      output(stream, old_spill_string);
      output(stream, stack_string);
d789 1
a789 1
      (fn x => (output(stream, "\n"); block_print(stream, x)))
d796 1
a796 1
    (output(stream, "  Procedure set { ");
d799 1
a799 1
      (output(stream, MirTypes.print_tag tag); output(stream, " ")))
d801 1
a801 1
     output(stream, "}");
d803 1
a803 1
     (fn proc => (output(stream, "\n"); procedure_print(stream,  proc)))
d866 3
a868 3
    (output(stream, "MIR code unit\n");
     output(stream, refs the_refs);
     output(stream, "\n Values\n");
d870 1
a870 1
     (fn x => (output(stream, value x); output(stream, "\n")))
d872 1
a872 1
     output(stream, " Procedure sets\n");
d874 1
a874 1
     (fn x => (proc_set_print(stream, x); output(stream, "\n")))
@


1.88
log
@Add ability to deal with RuntimeEnv.OFFSET spill entries
@
text
@d4 3
d287 2
d513 1
a513 1
    "GC_SPILL_SLOT (mach_cg) (" ^ MLWorks.Integer.makestring i ^ ":" ^ name ^ ")"
d515 1
a515 1
      "NON_GC_SPILL_SLOT (mach_cg) (" ^ MLWorks.Integer.makestring i ^ ":" ^ name ^ ")"
d517 1
a517 1
      "FP_SPILL_SLOT (mach_cg) (" ^ MLWorks.Integer.makestring i ^ ":" ^ name ^ ")"
d523 1
a523 1
      "GC_SPILL_SLOT(" ^ MLWorks.Integer.makestring n ^ ")"
d525 1
a525 1
      "GC_SPILL_SLOT(" ^ MLWorks.Integer.makestring n ^ ":"^name^")"
d527 1
a527 1
      "NON_GC_SPILL_SLOT(" ^ MLWorks.Integer.makestring n ^ ")"
d529 1
a529 1
      "NON_GC_SPILL_SLOT(" ^ MLWorks.Integer.makestring n ^ ":"^name^")"
d531 1
a531 1
      "FP_SPILL_SLOT(" ^ MLWorks.Integer.makestring n ^ ")"
d533 1
a533 1
      "FP_SPILL_SLOT(" ^ MLWorks.Integer.makestring n ^ ":"^name^")"
d543 1
a543 1
      MLWorks.Integer.makestring imm
d545 1
a545 1
      "Any:" ^ MLWorks.Integer.makestring imm
d591 1
a591 1
	      | _ => MLWorks.Integer.makestring imm]
d598 2
a599 2
	       | _ => MLWorks.Integer.makestring imm,
	   "OFFSET", MLWorks.Integer.makestring offset]
d602 1
a602 1
      cat [deallocate_stack operator, MLWorks.Integer.makestring imm]
d656 1
a656 1
	   "OFFSET", MLWorks.Integer.makestring offset]
d715 3
a717 3
	       ("\n    Spill areas: GC " ^ MLWorks.Integer.makestring gc ^
		", NON_GC " ^ MLWorks.Integer.makestring non_gc ^
		", FP " ^ MLWorks.Integer.makestring fp)
d723 3
a725 3
	       ("\n    Spill areas: GC " ^ MLWorks.Integer.makestring gc ^
		", NON_GC " ^ MLWorks.Integer.makestring non_gc ^
		", FP " ^ MLWorks.Integer.makestring fp)
d731 1
a731 1
	       ("\n    " ^ MLWorks.Integer.makestring s ^
d757 3
a759 3
	       ("\n    Spill areas: GC " ^ MLWorks.Integer.makestring gc ^
		", NON_GC " ^ MLWorks.Integer.makestring non_gc ^
		", FP " ^ MLWorks.Integer.makestring fp)
d765 3
a767 3
	       ("\n    Spill areas: GC " ^ MLWorks.Integer.makestring gc ^
		", NON_GC " ^ MLWorks.Integer.makestring non_gc ^
		", FP " ^ MLWorks.Integer.makestring fp)
d773 1
a773 1
	       ("\n    " ^ MLWorks.Integer.makestring s ^
d823 1
a823 1
		   MLWorks.Integer.makestring i)) tags ^
d826 1
a826 1
    (fn (s, i) => s ^ ", position " ^ MLWorks.Integer.makestring i)
d830 1
a830 1
    (fn (s, i) => s ^ ", position " ^ MLWorks.Integer.makestring i)
d834 1
a834 1
    (fn (s, i) => s ^ ", position " ^ MLWorks.Integer.makestring i)
d838 1
a838 1
    (fn (s, i) => s ^ ", position " ^ MLWorks.Integer.makestring i)
d842 1
a842 1
    (fn (s, i) => s ^ ", position " ^ MLWorks.Integer.makestring i)
@


1.87
log
@Add printing of new tagged operations for 32 bit integers
@
text
@d4 3
d507 8
d529 3
a531 1
    | symb _ = Crash.impossible "symb:_mirprint.sml"
@


1.86
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d4 4
d325 5
@


1.85
log
@Adding ALLOC_VECTOR
@
text
@d4 3
a289 2
  sharing MirRegisters.Option = MirRegisters.MirTypes.Debugger_Types.RuntimeEnv.Option = 
    MirRegisters.MirTypes.Option
a296 1
  structure Option = MirRegisters.Option
d442 2
a443 2
                     of Option.PRESENT zero => if gc_reg = zero then "/zero" else ""
                      | Option.ABSENT => ""
d560 1
a560 1
    | opcode(MirTypes.ALLOCATE_STACK(operator, reg1, imm, MirTypes.Option.ABSENT)) =
d567 1
a567 1
				     MirTypes.Option.PRESENT offset)) =
d624 1
a624 1
    | opcode(MirTypes.STACKOP(operator, reg, MirTypes.Option.ABSENT)) =
d627 1
a627 1
    | opcode (MirTypes.STACKOP(operator, reg, MirTypes.Option.PRESENT offset)) =
d679 1
d686 10
a695 2
	  of MirTypes.Option.ABSENT => "\n    No spill size information."
	   | MirTypes.Option.PRESENT {gc, non_gc, fp} =>
d702 2
a703 2
	  of MirTypes.Option.ABSENT => "\n    No stack allocation information."
	   | MirTypes.Option.PRESENT s =>
d710 1
a710 1
	spill_string ^ stack_string 
d722 1
d728 2
a729 2
	  of MirTypes.Option.ABSENT => "\n    No spill size information."
	   | MirTypes.Option.PRESENT {gc, non_gc, fp} =>
d733 9
d744 2
a745 2
	  of MirTypes.Option.ABSENT => "\n    No stack allocation information."
	   | MirTypes.Option.PRESENT s =>
d756 1
@


1.84
log
@Add immediate store operations
@
text
@d4 3
d380 1
@


1.83
log
@Remove handler register concept
@
text
@d4 3
d546 3
@


1.82
log
@Abstraction of debug information
@
text
@d4 3
a430 1
            else if gc_reg = handler then "/handler"
d590 1
a590 1
    | opcode(MirTypes.NEW_HANDLER tag1) =
@


1.81
log
@Changes to annotations
@
text
@d4 3
d278 1
a278 1
  sharing MirRegisters.Option = MirRegisters.MirTypes.RuntimeEnv.Option = 
d289 1
d488 1
a488 1
    | symb (MirTypes.GC_SPILL_SLOT (Option.SOME2(n))) =
d490 1
a490 1
    | symb (MirTypes.GC_SPILL_SLOT (Option.SOME1(ref (Option.SOME1(n)),name))) =
d492 1
a492 1
    | symb (MirTypes.NON_GC_SPILL_SLOT (Option.SOME2(n))) =
d494 1
a494 1
    | symb (MirTypes.NON_GC_SPILL_SLOT (Option.SOME1(ref (Option.SOME1(n)),name))) =
d496 1
a496 1
    | symb (MirTypes.FP_SPILL_SLOT (Option.SOME2(n))) =
d498 1
a498 1
    | symb (MirTypes.FP_SPILL_SLOT (Option.SOME1(ref (Option.SOME1(n)),name))) =
@


1.80
log
@Added function argument register lists to BRANCH_AND_LINK, TAIL_CALL and ENTER
Changed loop entry points to be a list
@
text
@d4 4
a419 2
            else if gc_reg = caller_arg2 then "/caller_argument2"
            else if gc_reg = callee_arg2 then "/argument2"
d662 2
a663 5
			       MirTypes.PROC_PARAMS {leaf,
						     registers_used,
						     spill_sizes,
						     stack_allocated,
                                                     loop_entry},
a665 12
      val leaf_string = (if leaf then "" else "non-") ^ "leaf"

      val reg_string =
	case registers_used
	  of MirTypes.Option.ABSENT => "\n    No register information."
	   | MirTypes.Option.PRESENT {gc, non_gc, fp} =>
	       ("\n    GCs used: " ^
		Set.set_print(gc, gc_register) ^
		"\n    NON_GCs used: " ^
		Set.set_print(non_gc, non_gc_register) ^
		"\n    FPs used: " ^
		Set.set_print(fp, fp_register))
a681 10
      val loop_string =
        case loop_entry
          of [] => "\n    No loop entry points."
           | taglist =>
               let
                 fun f ([],acc) = implode (rev acc)
                   | f (t::rest,acc) = f (rest," " :: MirTypes.print_tag t :: acc)
               in
                 f (taglist, ["\n   Loop entry points: "])
               end
d685 1
a685 2
	" (" ^ leaf_string ^ ")" ^ reg_string ^ spill_string ^
	stack_string ^ loop_string
d696 2
a697 5
				    MirTypes.PROC_PARAMS {leaf,
							  registers_used,
							  spill_sizes,
							  stack_allocated,
                                                          loop_entry},
a699 10
      val reg_string =
	case registers_used
	  of MirTypes.Option.ABSENT => "\n    No register information."
	| MirTypes.Option.PRESENT {gc, non_gc, fp} =>
	    ("\n    GCs used: " ^
	     Set.set_print(gc, gc_register) ^
	     "\n    NON_GCs used: " ^
	     Set.set_print(non_gc, non_gc_register) ^
	     "\n    FPs used: " ^
	     Set.set_print(fp, fp_register))
a713 10
      val loop_string =
        case loop_entry
          of [] => "\n    No loop entry points."
           | taglist =>
               let
                 fun f ([],acc) = implode (rev acc)
                   | f (t::rest,acc) = f (rest," " :: MirTypes.print_tag t :: acc)
               in
                 f (taglist, ["\n   Loop entry points: "])
               end
a719 3
      output(stream, if leaf then "" else "non-");
      output(stream, "leaf)");
      output(stream, reg_string);
a721 1
      output(stream, loop_string);
@


1.79
log
@Add field to MirTypes.PROC_PARAMS.
@
text
@d4 3
d414 1
a414 1
            if gc_reg = caller_arg then "/caller argument"
d416 3
a418 1
            else if gc_reg = caller_closure then "/caller closure"
d578 1
a578 1
    | opcode MirTypes.ENTER = "Procedure entry"
d623 1
a623 1
    | opcode(MirTypes.BRANCH_AND_LINK(operator, bl_dest1,_)) =
d626 1
a626 1
    | opcode(MirTypes.TAIL_CALL(operator, bl_dest1)) =
d697 8
a704 3
          of MirTypes.Option.ABSENT => "\n    No loop entry point."
           | MirTypes.Option.PRESENT t =>
               ("\n   Loop entry point: " ^ MirTypes.print_tag t)
d753 8
a760 3
          of MirTypes.Option.ABSENT => "\n    No loop entry point."
           | MirTypes.Option.PRESENT t =>
               ("\n   Loop entry point: " ^ MirTypes.print_tag t)
@


1.78
log
@Adding load offset instruction
@
text
@d4 3
d658 2
a659 1
						     stack_allocated},
d690 6
d699 1
a699 1
	stack_string
d713 2
a714 1
							  stack_allocated},
d740 6
d757 1
@


1.77
log
@Removed unnecessary exceptions from closures.
@
text
@d4 3
d389 1
@


1.76
log
@Added INTERRUPT instruction
@
text
@d4 3
d512 1
a512 1
      cat [tagged_binary operator, tag tag1, reg_operand reg,
d587 1
a587 1
      cat [tagged_binaryfp operator, MirTypes.print_tag tag, fp_operand fp1,
d591 1
a591 1
      cat [tagged_unaryfp operator, MirTypes.print_tag tag, fp_operand fp,
@


1.75
log
@New stack spill slots for local and closure variable inspection
in the debugger;
structure Option.
@
text
@d4 5
d560 2
@


1.75.1.1
log
@Fork for bug fixing
@
text
@a3 5
Revision 1.75  1993/07/29  15:02:52  nosa
New stack spill slots for local and closure variable inspection
in the debugger;
structure Option.

@


1.74
log
@Removed Integer parameter
@
text
@d4 3
d254 2
d462 1
a462 1
    | symb (MirTypes.GC_SPILL_SLOT n) =
d464 3
a466 1
    | symb (MirTypes.NON_GC_SPILL_SLOT n) =
d468 3
a470 1
    | symb (MirTypes.FP_SPILL_SLOT n) =
d472 3
d522 1
a522 1
    | opcode(MirTypes.ALLOCATE_STACK(operator, reg1, imm, MirTypes.ABSENT)) =
d529 1
a529 1
				     MirTypes.PRESENT offset)) =
d584 1
a584 1
    | opcode(MirTypes.STACKOP(operator, reg, MirTypes.ABSENT)) =
d587 1
a587 1
    | opcode (MirTypes.STACKOP(operator, reg, MirTypes.PRESENT offset)) =
d642 1
a642 1
			       blocks)) =
d648 2
a649 2
	  of MirTypes.ABSENT => "\n    No register information."
	   | MirTypes.PRESENT {gc, non_gc, fp} =>
d659 2
a660 2
	  of MirTypes.ABSENT => "\n    No spill size information."
	   | MirTypes.PRESENT {gc, non_gc, fp} =>
d667 2
a668 2
	  of MirTypes.ABSENT => "\n    No stack allocation information."
	   | MirTypes.PRESENT s =>
d690 1
a690 1
				    blocks)) =
d694 2
a695 2
	  of MirTypes.ABSENT => "\n    No register information."
	| MirTypes.PRESENT {gc, non_gc, fp} =>
d704 2
a705 2
	  of MirTypes.ABSENT => "\n    No spill size information."
	   | MirTypes.PRESENT {gc, non_gc, fp} =>
d711 2
a712 2
	  of MirTypes.ABSENT => "\n    No stack allocation information."
	   | MirTypes.PRESENT s =>
d736 1
a736 1
     (fn (MirTypes.PROC(_,tag,_,_)) =>
d750 1
a750 1
	("", map (fn MirTypes.PROC(_,tag,_,_) => MirTypes.print_tag tag) procs)
d792 1
a792 1
    
@


1.73
log
@Changed PROFILE instruction to INTERCEPT.
@
text
@d4 3
a238 1
require "../utils/integer";
a246 1
  structure Integer : INTEGER
d458 1
a458 1
      "GC_SPILL_SLOT(" ^ Integer.makestring n ^ ")"
d460 1
a460 1
      "NON_GC_SPILL_SLOT(" ^ Integer.makestring n ^ ")"
d462 1
a462 1
      "FP_SPILL_SLOT(" ^ Integer.makestring n ^ ")"
d469 1
a469 1
      Integer.makestring imm
d471 1
a471 1
      "Any:" ^ Integer.makestring imm
d514 1
a514 1
	      | _ => Integer.makestring imm]
d521 2
a522 2
	       | _ => Integer.makestring imm,
	   "OFFSET", Integer.makestring offset]
d525 1
a525 1
      cat [deallocate_stack operator, Integer.makestring imm]
d577 1
a577 1
	   "OFFSET", Integer.makestring offset]
d649 3
a651 3
	       ("\n    Spill areas: GC " ^ Integer.makestring gc ^
		", NON_GC " ^ Integer.makestring non_gc ^
		", FP " ^ Integer.makestring fp)
d657 1
a657 1
	       ("\n    " ^ Integer.makestring s ^
d694 3
a696 3
	       ("\n    Spill areas: GC " ^ Integer.makestring gc ^
		", NON_GC " ^ Integer.makestring non_gc ^
		", FP " ^ Integer.makestring fp)
d701 1
a701 1
	       ("\n    " ^ Integer.makestring s ^
d752 1
a752 1
		   Integer.makestring i)) tags ^
d755 1
a755 1
    (fn (s, i) => s ^ ", position " ^ Integer.makestring i)
d759 1
a759 1
    (fn (s, i) => s ^ ", position " ^ Integer.makestring i)
d763 1
a763 1
    (fn (s, i) => s ^ ", position " ^ Integer.makestring i)
d767 1
a767 1
    (fn (s, i) => s ^ ", position " ^ Integer.makestring i)
d771 1
a771 1
    (fn (s, i) => s ^ ", position " ^ Integer.makestring i)
@


1.72
log
@Signature revisions
@
text
@d4 3
d541 1
a541 2
    | opcode (MirTypes.PROFILER reg) =
      cat ["Profiler ",reg_operand reg]
@


1.71
log
@Added MLVALUE lambda exp
@
text
@d4 3
d247 1
a247 2
  sharing IdentPrint.Ident =
		 MirRegisters.MirTypes.Debugger_Types.Datatypes.Ident
@


1.70
log
@Modified to print directly to a given stream for speed and controllability
@
text
@d4 3
d769 7
a775 3
  fun value (MirTypes.VALUE(tag, scon)) =
    MirTypes.print_tag tag ^ ": " ^ IdentPrint.printSCon scon

@


1.69
log
@Reworked in terms of mononewmap
@
text
@d4 3
d594 9
a602 5
    fun any_block (name, indent) (MirTypes.BLOCK(tag, opcodes)) =
      Lists.reducel
      (fn(a,b) => a ^ "\n " ^ indent ^ b)
      (indent ^ name ^ " " ^ MirTypes.print_tag tag,
       map opcode opcodes)
d604 2
d608 5
d663 48
d713 12
d769 1
a769 1
  fun print_mir_code (MirTypes.CODE(the_refs, values, proc_sets)) =
d778 12
@


1.68
log
@Removed some redundant structures and sharing
@
text
@d4 3
a246 1
  structure NewMap = MirRegisters.MirTypes.Debugger_Types.Datatypes.NewMap
d396 2
a397 2
            ("/" ^ MachSpec.print_register (NewMap.apply (#gc machine_register_assignments) gc_reg))
            handle NewMap.Undefined => ""
d407 2
a408 2
            ("/" ^ MachSpec.print_register (NewMap.apply (#non_gc machine_register_assignments) non_gc_reg))
            handle NewMap.Undefined => ""
d418 2
a419 2
            ("/" ^ MachSpec.print_register (NewMap.apply (#fp machine_register_assignments) fp_reg))
            handle NewMap.Undefined => ""
@


1.67
log
@Added NULLARY opcode type.
Added ALLOC_BYTEARRAY.
@
text
@d4 4
a219 1
require "../utils/set";
a221 1
require "../utils/option";
a224 1
require "mirtypes";
a228 2

  structure Set : SET
a229 1
  structure Option : OPTION
a232 1
  structure MirTypes : MIRTYPES
d235 2
a236 4
  sharing IdentPrint.Ident = MirTypes.Ident
  sharing MirTypes = MirRegisters.MirTypes
  sharing Set = MirTypes.Set
  sharing Option = MirRegisters.Option
d242 4
a245 1
  structure MirTypes = MirTypes
a246 1

d394 2
a395 2
            ("/" ^ MachSpec.print_register (MirRegisters.Map.apply (#gc machine_register_assignments) gc_reg))
            handle MirRegisters.Map.Undefined => ""
d405 2
a406 2
            ("/" ^ MachSpec.print_register (MirRegisters.Map.apply (#non_gc machine_register_assignments) non_gc_reg))
            handle MirRegisters.Map.Undefined => ""
d416 2
a417 2
            ("/" ^ MachSpec.print_register (MirRegisters.Map.apply (#fp machine_register_assignments) fp_reg))
            handle MirRegisters.Map.Undefined => ""
@


1.66
log
@Added type annotation information at application points
@
text
@d4 3
d275 2
d333 1
d486 3
@


1.65
log
@Added parameter to RAISE once again.
@
text
@d4 3
d570 1
a570 1
    | opcode(MirTypes.BRANCH_AND_LINK(operator, bl_dest1)) =
@


1.64
log
@Added printing for interpretive external types
@
text
@d4 3
d532 2
a533 2
    | opcode(MirTypes.RAISE(* reg*)) =
      "Raise "(* ^ reg_operand reg*)
@


1.63
log
@Expanded refs section of mir_code to allow for interpretive stuff
@
text
@d4 3
d653 24
a676 11
    case (vars, exns, strs, funs) of
      ([], [], [], []) =>
	"  References\n   Local " ^
	Lists.to_string
	(fn (x, i) => ("Tag " ^ MirTypes.print_tag x ^ ", position " ^
		       Integer.makestring i)) tags ^
	"\n   External " ^
	Lists.to_string
	(fn (s, i) => s ^ ", position " ^ Integer.makestring i)
	requires
      | _ => Crash.unimplemented"Printing interpreter environment"
a680 1
  
@


1.62
log
@Removed redundant names from register printing routines.
@
text
@d4 3
d208 1
d221 1
d648 13
a660 10
  fun refs (MirTypes.REFS(tags, strings)) =
    "  References\n   Local " ^
    Lists.to_string
    (fn (x, i) => ("Tag " ^ MirTypes.print_tag x ^ ", position " ^
		   Integer.makestring i)) tags ^
    "\n   External " ^
    Lists.to_string
    (fn (s, i) => s ^ ", position " ^ Integer.makestring i)
    strings

@


1.61
log
@First version of the profiler
@
text
@d4 3
d381 1
a381 1
	"GC(" ^ MirTypes.GC.to_string gc_reg ^ name ^ machine_reg ^ ")"
d392 1
a392 1
        "NonGC(" ^ MirTypes.NonGC.to_string non_gc_reg ^ machine_reg ^ ")"
d403 1
a403 1
        "FP(" ^ MirTypes.FP.to_string fp_reg ^ machine_reg ^ ")"
@


1.60
log
@Changed the way virtual registers are handled.  See MirTypes.
Added switches to allow different printing format for virtual
registers.
@
text
@d4 5
d505 3
d577 2
a578 1
  fun procedure (MirTypes.PROC(start_tag,
d614 1
a614 1
	"   Procedure " ^ MirTypes.print_tag start_tag ^
d631 1
a631 1
	("", map (fn MirTypes.PROC(tag,_,_) => MirTypes.print_tag tag) procs)
@


1.59
log
@Abolished PREVIOUS_ENVIRONMENT and PRESERVE_ALL_REGS.
Changed register lookup to use Map rather than Table.
@
text
@d4 4
d342 3
d351 21
a371 15
	  if gc_reg = caller_arg then "caller argument"
	  else if gc_reg = callee_arg then "callee argument"
	  else if gc_reg = caller_closure then "caller closure"
	  else if gc_reg = callee_closure then "callee closure"
	  else if gc_reg = fp then "frame"
	  else if gc_reg = sp then "stack"
	  else if gc_reg = handler then "handler"
	  else if gc_reg = global then "global"
          else if gc_reg = implicit then "implicit"
	  else
            case MirRegisters.zero
              of Option.PRESENT zero =>
                 if gc_reg = zero then "zero"
                 else MirTypes.print_gc_register gc_reg
               | Option.ABSENT => MirTypes.print_gc_register gc_reg
d373 1
a373 10
	"GC(" ^
	(let
	   val machine_reg =
	     MirRegisters.Map.apply (#gc machine_register_assignments) gc_reg
	 in
	   name ^ "/" ^
	   MachSpec.print_register machine_reg
	 end
	   handle MirRegisters.Map.Undefined =>
	     MirTypes.print_gc_register gc_reg) ^ ")"
d377 9
a385 11
      "NonGC(" ^
      (let
	 val machine_reg =
           MirRegisters.Map.apply
           (#non_gc machine_register_assignments) non_gc_reg
       in
	 MirTypes.print_non_gc_register non_gc_reg ^ "/" ^
	 MachSpec.print_register machine_reg
       end
         handle MirRegisters.Map.Undefined =>
           MirTypes.print_non_gc_register non_gc_reg) ^ ")"
d388 10
a397 10
      "FP(" ^
      (let
	 val machine_reg =
           MirRegisters.Map.apply (#fp machine_register_assignments) fp_reg
       in
	 MirTypes.print_fp_register fp_reg ^ "/" ^
	 MachSpec.print_register machine_reg
       end
	 handle MirRegisters.Map.Undefined =>
	   MirTypes.print_fp_register fp_reg) ^ ")"
@


1.58
log
@Added special case printing of the `implicit' register.
@
text
@d4 3
d363 1
a363 1
	     Table.lookup (gc_reg, #gc machine_register_assignments)
d368 1
a368 1
	   handle Table.Lookup =>
d376 2
a377 1
	   Table.lookup (non_gc_reg, #non_gc machine_register_assignments)
d382 1
a382 1
         handle Table.Lookup =>
d389 1
a389 1
	   Table.lookup (fp_reg, #fp machine_register_assignments)
d394 1
a394 1
	 handle Table.Lookup =>
a501 6
    | opcode MirTypes.PRESERVE_ALL_REGS =
      "Preserve all registers for debugger"

    | opcode MirTypes.PREVIOUS_ENVIRONMENT =
      "Restore previous environment"

@


1.57
log
@Alloc may now have a register argument for allocating arrays
@
text
@d4 3
d349 1
@


1.56
log
@Raise no longer has a parameter
@
text
@d4 3
d456 1
a456 1
	   | _ => Integer.makestring imm]
@


1.55
log
@Added the zero register (if present) to those registers printed
with names.
@
text
@d4 4
d503 2
a504 2
    | opcode(MirTypes.RAISE reg) =
      "Raise " ^ reg_operand reg
@


1.54
log
@Added tail call operation
@
text
@d3 4
a6 1
$Log:	_mirprint.sml,v $
d179 1
d190 1
d199 1
d339 6
a344 1
	  else MirTypes.print_gc_register gc_reg
@


1.53
log
@Added exception generating fp opcodes
@
text
@d4 3
d315 1
a315 2
  fun branch_and_link MirTypes.BSR = "BSR"
    | branch_and_link MirTypes.BLR = "BLR"
d317 2
d525 3
@


1.52
log
@Added printing for the CALL_C opcode.
@
text
@d4 3
d229 5
d254 6
d272 1
a272 2
  fun convop MirTypes.ITOF = "ITOF"
    | convop MirTypes.FTOI = "FTOI"
d274 2
d494 8
d512 6
a517 2
    | opcode(MirTypes.CONVOP(operator, fp, gp)) =
      cat [convop operator, fp_operand fp, gp_operand gp]
@


1.51
log
@Removed references to fp_double registers.
@
text
@d4 3
d492 1
a492 1
  | opcode(MirTypes.BRANCH_AND_LINK(operator, bl_dest1)) =
d495 3
a497 1
  | opcode(MirTypes.COMMENT s) = " ; " ^ s
@


1.50
log
@Added argument to STACKOP and new opcodes FSTREF and FLDREF.
@
text
@d4 3
d348 1
a349 12
    fun fp_double_register fp_double_reg =
      "FPdouble(" ^
      (let
	 val machine_reg =
	   Table.lookup (fp_double_reg,
			 #fp_double machine_register_assignments)
       in
	 MirTypes.print_fp_double_register fp_double_reg ^ "/" ^
	 MachSpec.print_register machine_reg
       end
       handle Table.Lookup =>
	 MirTypes.print_fp_double_register fp_double_reg) ^ ")"
a350 2
  end

a364 2
    | any_reg(MirTypes.DOUBLE double_reg) =
      fp_double_register double_reg
a373 2
    | symb (MirTypes.FP_DOUBLE_SPILL_SLOT n) =
      "FP_DOUBLE_SPILL_SLOT(" ^ Integer.makestring n ^ ")"
d520 1
a520 1
	   | MirTypes.PRESENT {gc, non_gc, fp, fp_double} =>
d526 1
a526 3
		Set.set_print(fp, fp_register) ^
		"\n    FP_DOUBLEs used: " ^
		Set.set_print(fp_double, fp_double_register))
d531 1
a531 1
	   | MirTypes.PRESENT {gc, non_gc, fp, fp_double} =>
d534 1
a534 2
		", FP " ^ Integer.makestring fp ^
		", FP_DOUBLE " ^ Integer.makestring fp_double)
@


1.49
log
@Added procedure print function.
@
text
@d4 3
d249 2
d490 1
a490 1
    | opcode(MirTypes.STACKOP(operator, reg)) =
d492 4
@


1.48
log
@Changed the form of the allocation instructions yet again.
@
text
@d4 3
d513 6
a518 6
  fun proc (MirTypes.PROC(start_tag,
				 MirTypes.PROC_PARAMS {leaf,
						       registers_used,
						       spill_sizes,
						       stack_allocated},
				 blocks)) =
d562 1
a562 1
  val set_up = proc
d574 1
a574 1
       map proc procs)
@


1.47
log
@ALLOCATE doesn't have a scratch register or a proc_ref any more.
@
text
@d4 3
d251 6
a256 1
    | allocate MirTypes.ALLOC_STACK = "ALLOC_STACK"
a257 2
  fun deallocate MirTypes.DEALLOC_STACK = "DEALLOC_STACK"

d424 16
a439 2
    | opcode(MirTypes.DEALLOCATE(operator, imm)) =
      cat [deallocate operator, Integer.makestring imm]
@


1.46
log
@Added BTA and BNT for tagged value testing
@
text
@d4 3
a396 4
  fun proc_ref(MirTypes.REG_REF reg) = reg_operand reg
    | proc_ref(MirTypes.CLOSURE_REF(reg, i)) =
      "[" ^ reg_operand reg ^ ", #" ^ Integer.makestring i ^ "]"

d412 1
a412 1
    | opcode(MirTypes.ALLOCATE(operator, reg1, imm, reg2, proc_ref1)) =
d414 3
a416 5
	   (case operator
	      of MirTypes.ALLOC_REAL => ""
	       | _ => Integer.makestring imm),
	      "SCRATCH", reg_operand reg2,
	      "CALLC AT", proc_ref proc_ref1]
@


1.45
log
@New local and external reference code
@
text
@d4 3
d251 3
a253 1
  fun test MirTypes.BEQ = "BEQ"
@


1.44
log
@Tidied up output of ALLOCATE opcodes.
@
text
@d4 3
d555 3
a557 1
    Lists.to_string MirTypes.print_tag tags ^
d559 3
a561 1
    Lists.to_string (fn s=>s) strings
@


1.43
log
@New ALLOC opcodes
@
text
@d4 3
d386 3
a388 3
  fun decode_proc_ref(MirTypes.REG_REF reg) = reg_operand reg
  | decode_proc_ref(MirTypes.CLOSURE_REF(reg, i)) =
    cat["[", reg_operand reg, ", #", Integer.makestring i, "]"]
d405 2
a406 2
    | opcode(MirTypes.ALLOCATE(operator, reg, imm, reg', proc_ref)) =
      cat [allocate operator, reg_operand reg,
d409 3
a411 2
	       | _ => Integer.makestring imm), ",",
	   reg_operand reg', decode_proc_ref proc_ref]
@


1.42
log
@Changed the way registers are displayed again.
@
text
@d4 3
d375 7
a381 2
  fun cat [] = ""
    | cat (s::ss) = s ^ " " ^ (cat ss)
d383 4
d402 1
a402 1
    | opcode(MirTypes.ALLOCATE(operator, reg, imm, offset)) =
d407 1
a407 1
	   Integer.makestring offset]
@


1.41
log
@A big mindless clean-up while I thought about register colouring.
@
text
@d4 3
d279 1
a279 1
	"GC:" ^
d288 1
a288 1
	     MirTypes.print_gc_register gc_reg)	   
d292 1
a292 1
      "NonGC:" ^
d301 1
a301 1
           MirTypes.print_non_gc_register non_gc_reg)
d304 1
a304 1
      "FP:" ^
d313 1
a313 1
	   MirTypes.print_fp_register fp_reg)
d316 1
a316 1
      "FPdouble:" ^
d326 1
a326 1
	 MirTypes.print_fp_double_register fp_double_reg)
@


1.40
log
@Updated to reflect new simplified module structure
Added parameter to heap allocation to indicate position in closure
of call_c function
@
text
@d4 5
d163 21
a183 15
  fun decode_binary MirTypes.ADD = "ADD "
  | decode_binary MirTypes.SUB = "SUB "
  | decode_binary MirTypes.MULU = "MULU "
  | decode_binary MirTypes.MULS = "MULS "
  | decode_binary MirTypes.DIVU = "DIVU "
  | decode_binary MirTypes.DIVS = "DIVS "
  | decode_binary MirTypes.MODU = "MODU "
  | decode_binary MirTypes.MODS = "MODS "
  | decode_binary MirTypes.AND = "AND "
  | decode_binary MirTypes.OR = "OR "
  | decode_binary MirTypes.BIC = "BIC "
  | decode_binary MirTypes.EOR = "EOR "
  | decode_binary MirTypes.LSR = "LSR "
  | decode_binary MirTypes.ASL = "ASL "
  | decode_binary MirTypes.ASR = "ASR "
d185 2
a186 5
  fun decode_tagged_binary MirTypes.ADDV = "ADDV "
  | decode_tagged_binary MirTypes.SUBV = "SUBV "
  | decode_tagged_binary MirTypes.MULV = "MULV "
  | decode_tagged_binary MirTypes.DIVV = "DIVV "
  | decode_tagged_binary MirTypes.MODV = "MODV "
d188 4
a191 2
  fun decode_unary MirTypes.MOVE = "MOVE "
  | decode_unary MirTypes.NOT = "NOT "
d193 19
a211 4
  fun decode_binary_fp MirTypes.FADD = "FADD "
  | decode_binary_fp MirTypes.FSUB = "FSUB "
  | decode_binary_fp MirTypes.FMUL = "FMUL "
  | decode_binary_fp MirTypes.FDIV = "FDIV "
d213 6
a218 19
  fun decode_unary_fp MirTypes.FABS = "FABS "
  | decode_unary_fp MirTypes.FNEG = "FNEG "
  | decode_unary_fp MirTypes.FMOVE = "FMOVE "
  | decode_unary_fp MirTypes.FINT = "FINT "
  | decode_unary_fp MirTypes.FSQRT = "FSQRT "
  | decode_unary_fp MirTypes.FLOG10 = "FLOG10 "
  | decode_unary_fp MirTypes.FLOG2 = "FLOG2 "
  | decode_unary_fp MirTypes.FLOGE = "FLOGE "
  | decode_unary_fp MirTypes.FLOGEP1 = "FLOGEP1 "
  | decode_unary_fp MirTypes.F10TOX = "F10TOX "
  | decode_unary_fp MirTypes.F2TOX = "F2TOX "
  | decode_unary_fp MirTypes.FETOX = "FETOX "
  | decode_unary_fp MirTypes.TETOXM1 = "TETOXM1 "
  | decode_unary_fp MirTypes.FSIN = "FSIN "
  | decode_unary_fp MirTypes.FCOS = "FCOS "
  | decode_unary_fp MirTypes.FTAN = "FTAN "
  | decode_unary_fp MirTypes.FASIN = "FASIN "
  | decode_unary_fp MirTypes.FACOS = "FACOS "
  | decode_unary_fp MirTypes.FATAN = "FATAN "
d220 2
a221 6
  fun decode_store MirTypes.LD = "LD "
  | decode_store MirTypes.ST = "ST "
  | decode_store MirTypes.LDB = "LDB "
  | decode_store MirTypes.STB = "STB "
  | decode_store MirTypes.LDREF = "LDREF "
  | decode_store MirTypes.STREF = "STREF "
d223 2
a224 2
  fun decode_storefp MirTypes.FLD = "FLD "
  | decode_storefp MirTypes.FST = "FST "
d226 7
a232 2
  fun decode_convop MirTypes.ITOF = "ITOF "
  | decode_convop MirTypes.FTOI = "FTOI "
d234 1
a234 5
  fun decode_allocate MirTypes.ALLOC = "ALLOC "
  | decode_allocate MirTypes.ALLOC_REAL = "ALLOC_REAL "
  | decode_allocate MirTypes.ALLOC_STRING = "ALLOC_STRING "
  | decode_allocate MirTypes.ALLOC_REF = "ALLOC_REF "
  | decode_allocate MirTypes.ALLOC_STACK = "ALLOC_STACK "
d236 10
a245 1
  fun decode_deallocate MirTypes.DEALLOC_STACK = "DEALLOC_STACK "
d247 4
a250 1
  fun decode_branch MirTypes.BRA = "BRA "
d252 1
a252 10
  fun decode_test MirTypes.BEQ = "BEQ "
  | decode_test MirTypes.BNE = "BNE "
  | decode_test MirTypes.BHI = "BHI "
  | decode_test MirTypes.BLS = "BLS "
  | decode_test MirTypes.BHS = "BHS "
  | decode_test MirTypes.BLO = "BLO "
  | decode_test MirTypes.BGT = "BGT "
  | decode_test MirTypes.BLE = "BLE "
  | decode_test MirTypes.BGE = "BGE "
  | decode_test MirTypes.BLT = "BLT "
d254 2
a255 4
  fun decode_ftest MirTypes.FBEQ = "FBEQ "
  | decode_ftest MirTypes.FBNE = "FBNE "
  | decode_ftest MirTypes.FBLE = "FBLE "
  | decode_ftest MirTypes.FBLT = "FBLT "
d257 2
a258 1
  fun decode_adr MirTypes.LEA = "LEA "
a259 6
  fun decode_stack_op MirTypes.PUSH = "PUSH "
  | decode_stack_op MirTypes.POP = "POP "

  fun decode_bl MirTypes.BSR = "BSR "
  | decode_bl MirTypes.BLR = "BLR "

d263 1
a263 1
    fun decode_gc_register gc_reg =
d276 10
a285 9
	let
	  val machine_reg =
	    Table.lookup (gc_reg, #gc machine_register_assignments)
	in
	  name ^ "/" ^
	  MachSpec.print_register machine_reg
	end
      handle Table.Lookup =>
	MirTypes.print_gc_register gc_reg
d288 11
a298 10
    fun decode_non_gc_register non_gc_reg =
      let
	val machine_reg =
	  Table.lookup (non_gc_reg, #non_gc machine_register_assignments)
      in
	MirTypes.print_non_gc_register non_gc_reg ^ "/" ^
	MachSpec.print_register machine_reg
      end
      handle Table.Lookup =>
	MirTypes.print_non_gc_register non_gc_reg
d300 11
a310 10
    fun decode_fp_register fp_reg =
      let
	val machine_reg =
	  Table.lookup (fp_reg, #fp machine_register_assignments)
      in
	MirTypes.print_fp_register fp_reg ^ "/" ^
	MachSpec.print_register machine_reg
      end
      handle Table.Lookup =>
	MirTypes.print_fp_register fp_reg
d312 12
a323 10
    fun decode_fp_double_register fp_double_reg =
      let
	val machine_reg =
	  Table.lookup (fp_double_reg, #fp_double machine_register_assignments)
      in
	MirTypes.print_fp_double_register fp_double_reg ^ "/" ^
	MachSpec.print_register machine_reg
      end
      handle Table.Lookup =>
	MirTypes.print_fp_double_register fp_double_reg
d327 4
a330 4
  fun decode_reg_operand(MirTypes.GC_REG gc_reg) =
    "GC(" ^ decode_gc_register gc_reg ^ ") "
  | decode_reg_operand(MirTypes.NON_GC_REG non_gc_reg) =
    "NON_GC(" ^ decode_non_gc_register non_gc_reg ^ ") "
d332 2
a333 2
  fun decode_fp_operand(MirTypes.FP_REG fp_reg) =
    "FP(" ^ decode_fp_register fp_reg ^ ") "
d335 8
a342 8
  fun decode_any_reg(MirTypes.GC gc_reg) =
    "GC(" ^ decode_gc_register gc_reg ^ ") "
  | decode_any_reg(MirTypes.NON_GC non_gc_reg) =
    "NON_GC(" ^ decode_non_gc_register non_gc_reg ^ ") "
  | decode_any_reg(MirTypes.FLOAT fp_reg) =
    "FLOAT(" ^ decode_fp_register fp_reg ^ ") "
  | decode_any_reg(MirTypes.DOUBLE double_reg) =
    "DOUBLE(" ^ decode_fp_double_register double_reg ^ ") "
d344 3
a346 3
  fun decode_symb MirTypes.GC_SPILL_SIZE = "GC_SPILL_SIZE"
    | decode_symb MirTypes.NON_GC_SPILL_SIZE = "NON_GC_SPILL_SIZE"
    | decode_symb (MirTypes.GC_SPILL_SLOT n) =
d348 1
a348 1
    | decode_symb (MirTypes.NON_GC_SPILL_SLOT n) =
d350 1
a350 1
    | decode_symb (MirTypes.FP_SPILL_SLOT n) =
d352 1
a352 1
    | decode_symb (MirTypes.FP_DOUBLE_SPILL_SLOT n) =
d355 10
a364 10
  fun decode_gp_op(MirTypes.GP_GC_REG gc_reg) =
    "GC(" ^ decode_gc_register gc_reg ^ ") "
  | decode_gp_op(MirTypes.GP_NON_GC_REG non_gc_reg) =
    "NON_GC(" ^ decode_non_gc_register non_gc_reg ^ ") "
  | decode_gp_op(MirTypes.GP_IMM_INT imm) =
    "Int(" ^ Integer.makestring imm ^ ") "
  | decode_gp_op(MirTypes.GP_IMM_ANY imm) =
    "Any(" ^ Integer.makestring imm ^ ") "
  | decode_gp_op(MirTypes.GP_IMM_SYMB symb) =
    "Symbol(" ^ decode_symb symb ^ ") "
d366 2
a367 2
  fun decode_bl_dest(MirTypes.TAG tag) = MirTypes.print_tag tag
  | decode_bl_dest(MirTypes.REG reg) = decode_reg_operand reg
d369 2
a370 84
  fun decode_op(MirTypes.BINARY(binary_op, reg_op, gp_op1, gp_op2)) =
    decode_binary binary_op ^ decode_reg_operand reg_op ^
    decode_gp_op gp_op1 ^ decode_gp_op gp_op2
  | decode_op(MirTypes.TBINARY(tagged_binary_op, tag, reg_op, gp_op1,
			       gp_op2)) =
    decode_tagged_binary tagged_binary_op ^ MirTypes.print_tag tag ^ " " ^
    decode_reg_operand reg_op ^ decode_gp_op gp_op1 ^ decode_gp_op gp_op2
  | decode_op(MirTypes.UNARY(unary_op, reg_op, gp_op)) =
    decode_unary unary_op ^ decode_reg_operand reg_op ^ decode_gp_op gp_op
  | decode_op(MirTypes.STOREOP(store_op, reg_op1, reg_op2, gp_op)) =
    decode_store store_op ^ decode_reg_operand reg_op1 ^
    decode_reg_operand reg_op2 ^ decode_gp_op gp_op
  | decode_op(MirTypes.ALLOCATE(allocate, reg_operand, imm, offset)) =
    decode_allocate allocate ^ decode_reg_operand reg_operand ^
    (case allocate of MirTypes.ALLOC_REAL => ""
    | _ => Integer.makestring imm) ^ ", " ^
    Integer.makestring offset
  | decode_op(MirTypes.DEALLOCATE(deallocate, imm)) =
    decode_deallocate deallocate ^ Integer.makestring imm
  | decode_op(MirTypes.BRANCH(branch, bl_dest)) =
    decode_branch branch ^ decode_bl_dest bl_dest
  | decode_op(MirTypes.TEST(cond_branch, tag, gp_op, gp_op')) =
    decode_test cond_branch ^ MirTypes.print_tag tag ^ " " ^
    decode_gp_op gp_op ^ decode_gp_op gp_op'
  | decode_op(MirTypes.FTEST(fcond_branch, tag, fp, fp')) =
    decode_ftest fcond_branch ^ MirTypes.print_tag tag ^ " " ^
    decode_fp_operand fp ^ decode_fp_operand fp'
  | decode_op(MirTypes.SWITCH(cgt, reg_op, tag_list)) =
    Lists.reducel
    (fn (s, tag) => s ^ " " ^ MirTypes.print_tag tag)
    ("CGT " ^ decode_reg_operand reg_op, tag_list)
(*
  | decode_op(MirTypes.VALUE scon) = (case scon of
      IdentPrint.Ident.REAL _ => "Real "
    | IdentPrint.Ident.STRING _ => "String "
    | _ => raise(LambdaSub.LambdaTypes.impossible"VALUE(int)")) ^ 
    IdentPrint.printSCon scon
*)
  | decode_op(MirTypes.ADR(adr, reg_op, tag)) =
    decode_adr adr ^ decode_reg_operand reg_op ^ " " ^ MirTypes.print_tag tag
    (* Information points *)
(*
  | decode_op(MirTypes.LOC_REF tag_list) =
    Lists.reducel op ^
    ("Local references\n  ",
      map (fn tag => MirTypes.print_tag tag ^ " ") tag_list)
  | decode_op(MirTypes.EXT_REF string_list) =
    Lists.reducel op ^
    ("External references\n  ",
      map (fn chars => chars ^ " ") string_list)
  | decode_op(MirTypes.FN_CALL(tag1, tag2)) =
    "Fn call " ^ MirTypes.print_tag tag1 ^ " " ^ MirTypes.print_tag tag2
*)
  | decode_op MirTypes.ENTER = "Procedure entry"
  | decode_op MirTypes.RTS = "Procedure exit"
  | decode_op MirTypes.PRESERVE_ALL_REGS =
    "Preserve all registers (including pc)"
  | decode_op MirTypes.PREVIOUS_ENVIRONMENT =
    "Restore previous environment"
  | decode_op(MirTypes.NEW_HANDLER(tag)) =
    "New exception handler at tag " ^ (MirTypes.print_tag tag)
  | decode_op(MirTypes.OLD_HANDLER) =
    "Restore previous exception handler"
  | decode_op(MirTypes.RAISE(reg)) =
    "RAISE " ^ decode_reg_operand reg
  | decode_op(MirTypes.BINARYFP(binary_fp_op, fp_reg1, fp_reg2, fp_reg3)) =
    decode_binary_fp binary_fp_op ^ 
    decode_fp_operand fp_reg1 ^
    decode_fp_operand fp_reg2 ^
    decode_fp_operand fp_reg3
  | decode_op(MirTypes.UNARYFP(unary_fp_op, fp_reg, fp_reg')) =
    decode_unary_fp unary_fp_op ^ decode_fp_operand fp_reg ^
    decode_fp_operand fp_reg'
  | decode_op(MirTypes.STACKOP(stack_op, reg_op)) =
    decode_stack_op stack_op ^ decode_reg_operand reg_op
  | decode_op(MirTypes.STOREFPOP(store_fp_op, fp_reg, reg_op, gp_op)) =
    decode_storefp store_fp_op ^ decode_fp_operand fp_reg ^
    decode_reg_operand reg_op ^ decode_gp_op gp_op
  | decode_op(MirTypes.CONVOP(int_to_float, fp_reg, gp_op)) =
    decode_convop int_to_float ^ decode_fp_operand fp_reg ^
    decode_gp_op gp_op
  | decode_op(MirTypes.BRANCH_AND_LINK(branch_and_link, bl_dest)) =
    decode_bl branch_and_link ^ decode_bl_dest bl_dest
  | decode_op(MirTypes.COMMENT s) = " ; " ^ s
d372 1
d374 79
d455 1
a455 1
    fun decode_any_block (name, indent) (MirTypes.BLOCK(tag, opcodes)) =
d459 1
a459 1
       map decode_op opcodes)
d462 1
a462 1
    val decode_block = decode_any_block ("Block", "    ")
d466 1
a466 1
  fun decode_proc (MirTypes.PROC(start_tag,
d480 1
a480 1
		Set.set_print(gc, decode_gc_register) ^
d482 1
a482 1
		Set.set_print(non_gc, decode_non_gc_register) ^
d484 1
a484 1
		Set.set_print(fp, decode_fp_register) ^
d486 1
a486 1
		Set.set_print(fp_double, decode_fp_double_register))
d512 1
a512 1
      (message, map decode_block blocks)
d515 1
a515 1
  val decode_set_up = decode_proc
d517 1
a517 1
  fun decode_proc_set procs =
d527 1
a527 1
       map decode_proc procs)
d531 1
a531 1
  fun decode_refs (MirTypes.REFS(tags, strings)) =
d538 1
a538 1
  fun decode_value (MirTypes.VALUE(tag, scon)) =
d542 1
a542 1
  fun print_mir_code (MirTypes.CODE(refs, values, proc_sets)) =
d544 1
a544 1
    decode_refs refs ^ "\n" ^
d547 1
a547 1
     (" Values", map decode_value values)) ^ "\n" ^
d550 1
a550 1
     (" Procedure sets", map decode_proc_set proc_sets)) ^ "\n"
d552 6
a557 12
  val block = decode_block
  val opcode = decode_op
  val gp_operand = decode_gp_op
  val reg_operand = decode_reg_operand
  val fp_operand = decode_fp_operand
  val any_reg = decode_any_reg
  val binary_op = decode_binary
  val unary_op = decode_unary
  val binary_fp_op = decode_binary_fp
  val unary_fp_op = decode_unary_fp
  val store_op = decode_store
  val store_fp_op = decode_storefp
@


1.39
log
@When decoding the names of registers which are aliases of real registers
the real names are displayed also. Added ALLOC_PAIR.
@
text
@d4 4
a225 1
  | decode_allocate MirTypes.ALLOC_PAIR = "ALLOC_PAIR "
d371 1
a371 1
  | decode_op(MirTypes.ALLOCATE(allocate, reg_operand, imm)) =
d373 3
a375 1
    (case allocate of MirTypes.ALLOC_REAL => "" | _ => Integer.makestring imm)
d523 1
a523 7
  fun decode_fn_call (MirTypes.FN_CALL(tag1,tag2)) =
    " Loader function call " ^
    MirTypes.print_tag tag1 ^ "," ^
    MirTypes.print_tag tag2


  fun decode_refs (MirTypes.REFS(tag, tags, strings)) =
d534 1
a534 6
  fun print_mir_code (MirTypes.CODE(fn_call,
				    refs,
				    values,
				    proc_sets,
				    set_up)) =

a535 1
    decode_fn_call fn_call ^ "\n" ^
d542 1
a542 3
     (" Procedure sets", map decode_proc_set proc_sets)) ^ "\n" ^
    " Set up procedure\n" ^ decode_set_up set_up

@


1.38
log
@Added DEALLOC_STACK and fixed a minor carriage return bug.
@
text
@d4 3
d222 1
d252 26
a277 10
  fun decode_gc_register gc_reg =
    if gc_reg = MirRegisters.caller_arg then "caller argument"
    else if gc_reg = MirRegisters.callee_arg then "callee argument"
    else if gc_reg = MirRegisters.caller_closure then "caller closure"
    else if gc_reg = MirRegisters.callee_closure then "callee closure"
    else if gc_reg = MirRegisters.fp then "frame"
    else if gc_reg = MirRegisters.sp then "stack"
    else if gc_reg = MirRegisters.handler then "handler"
    else if gc_reg = MirRegisters.global then "global"
    else MirTypes.print_gc_register gc_reg
d279 35
d317 1
a317 1
    "NON_GC(" ^ MirTypes.print_non_gc_register non_gc_reg ^ ") "
d320 1
a320 1
    "FP(" ^ MirTypes.print_fp_register fp_reg ^ ") "
d325 1
a325 1
    "NON_GC(" ^ MirTypes.print_non_gc_register non_gc_reg ^ ") "
d327 1
a327 1
    "FLOAT(" ^ MirTypes.print_fp_register fp_reg ^ ") "
d329 1
a329 1
    "DOUBLE(" ^ MirTypes.print_fp_double_register double_reg ^ ") "
d345 1
a345 1
    "NON_GC(" ^ MirTypes.print_non_gc_register non_gc_reg ^ ") "
d467 1
a467 1
		Set.set_print(gc, MirTypes.print_gc_register) ^
d469 1
a469 1
		Set.set_print(non_gc, MirTypes.print_non_gc_register) ^
d471 1
a471 1
		Set.set_print(fp, MirTypes.print_fp_register) ^
d473 1
a473 1
		Set.set_print(fp_double, MirTypes.print_fp_double_register))
@


1.37
log
@Slight alterations to cope with new MirTypes.
@
text
@d4 3
d220 2
d316 2
d495 1
a495 1
    " Set up procedure" ^ decode_set_up set_up
@


1.36
log
@Removed RESTORE_REGS and PRESERVE_REGS and replaced with
PREVIOUS_ENVIRONMENT. Parameterized RAISE.
@
text
@d4 3
a6 2
Revision 1.35  91/10/09  14:59:32  richard
*** empty log message ***
d119 1
d129 2
d139 1
d272 9
a280 1
  | decode_symb MirTypes.NON_GC_SPILL_SIZE = "NON_GC_SPILL_SIZE"
d345 1
a345 2
  | decode_op (MirTypes.ENTER {leaf = true, ...}) = "Leaf procedure entry"
  | decode_op (MirTypes.ENTER {leaf = false, ...}) = "Procedure entry"
a356 1
  | decode_op MirTypes.END = "End of code"
a387 1
    val decode_set_up = decode_any_block ("Set up block", " ")
d391 8
a398 5
  fun decode_proc (MirTypes.PROC(start_tag, blocks)) =
    Lists.reducel
    (fn (a,b) => a ^ "\n" ^ b)
    ("   Procedure " ^ MirTypes.print_tag start_tag,
     map decode_block blocks)
d400 12
d413 29
d447 1
a447 1
	("", map (fn MirTypes.PROC(tag,_) => MirTypes.print_tag tag) procs)
d488 1
a488 1
    decode_set_up set_up
@


1.34
log
@Added code to print "global" for the global GC register rather than
its number.
@
text
@d4 7
d239 9
a247 16
    let
      val fn_arg = MirRegisters.fn_arg
      val cl_arg = MirRegisters.cl_arg
      val fp = MirRegisters.fp
      val sp = MirRegisters.sp
      val handler = MirRegisters.handler
      val global = MirRegisters.global
    in
      if gc_reg = fn_arg then "argument"
      else if gc_reg = cl_arg then "closure"
	   else if gc_reg = fp then "frame"
		else if gc_reg = sp then "stack"
		     else if gc_reg = handler then "handler"
			  else if gc_reg = global then "global"
			       else MirTypes.print_gc_register gc_reg
    end
d332 2
a333 1
  | decode_op MirTypes.ENTER  = "Procedure entry"
a334 2
  | decode_op(MirTypes.PRESERVE_REGS(reg_list, fp_list)) =
    "Preserve registers"
d337 2
a338 2
  | decode_op(MirTypes.RESTORE_REGS(reg_list, fp_list)) =
    "Restore registers"
d343 2
a344 2
  | decode_op(MirTypes.RAISE) =
    "Raise exception"
@


1.33
log
@Rewrote higher level printing functions to nest neatly, and also
to print the non-procedure information from the Mir code.
@
text
@d4 4
d233 4
a236 4
      val fn_arg = MirRegisters.fn_arg;
      val cl_arg = MirRegisters.cl_arg;
      val fp = MirRegisters.fp;
      val sp = MirRegisters.sp;
d238 1
d245 2
a246 1
			  else MirTypes.print_gc_register gc_reg
@


1.32
log
@Changed to use new PROC type for bundling up procedures
@
text
@d4 3
a107 1
require "../utils/set";
a109 2
require "../lambda/pretty";
require "../lambda/lambdasub";
d114 1
a116 1
  structure Set : SET
a120 2
  structure Pretty : PRETTY
  structure LambdaSub : LAMBDASUB
d124 1
a124 1
  sharing Set = MirTypes.Set
d126 1
d128 1
a129 1
  structure P = Pretty
a130 1
  exception pretty_not_done_yet = LambdaSub.LambdaTypes.not_done_yet
d359 1
a359 9
(*
  | decode_op(MirTypes.INIT any_reg) = "INIT " ^ decode_any_reg any_reg
  | decode_op(MirTypes.USE any_reg) = "USE " ^ decode_any_reg any_reg
  | decode_op(MirTypes.DISCARD any_reg) = "DISCARD " ^ decode_any_reg any_reg
*)
  | decode_op(MirTypes.COMMENT s) = "; " ^ s
(*
  | decode_op _ = raise(pretty_not_done_yet"unknown")
*)
a360 4
  fun decode_block(MirTypes.BLOCK(tag, op_list)) =
    P.blk(0, P.lst("", [P.nl], "")
      (P.blk(2, [P.str("Tag "), P.str(MirTypes.print_tag tag)]) ::
        (map (fn x => P.str("  " ^ decode_op x)) op_list)))
d362 1
a362 4
  fun decode_proc(MirTypes.PROC(tag, block_list)) =
    P.blk(0, P.lst("", [P.nl], "")
	  (P.blk(2, [P.str("Proc Tag "), P.str(MirTypes.print_tag tag)]) ::
	   map decode_block block_list))
d364 5
a368 4
  fun decode_list proc_list =
    P.blk(0, P.lst("", [P.nl], "")
	  (P.blk(0, [P.str"Proc set"]) ::
		 map decode_proc proc_list))
d370 4
a373 4
  fun print_mir_code(MirTypes.CODE(fn_call, refs, val_list, proc_list_list,
				   block)) =
    P.string_of_T(P.blk(0, P.lst("", [P.nl], "")
			(map decode_list proc_list_list)))
d375 58
a432 1
  val block = P.string_of_T o decode_block
@


1.31
log
@Added fp_operand.
@
text
@d4 3
d376 4
a379 2
  fun decode_list block_list_list =
    Lists.reducel op @@  ([], block_list_list)
d381 7
a387 1
  fun print_mir_code(MirTypes.CODE(fn_call, refs, val_list, block_list_list, block)) =
d389 1
a389 1
			(map decode_block (decode_list block_list_list))))
@


1.30
log
@Printed new structure of code
@
text
@d4 3
d384 1
@


1.29
log
@Changed CODE structure to enable easier handling of code, values
and load time semantics
@
text
@d4 4
d370 2
a371 2
  fun decode_set block_list_set =
    Lists.reducel op @@  ([], Set.set_to_list block_list_set)
d373 1
a373 1
  fun print_mir_code(MirTypes.CODE(fn_call, refs, val_list, block_list_set, block)) =
d375 1
a375 1
			(map decode_block (decode_set block_list_set))))
@


1.28
log
@Removed real register options, these are being done elsewhere
@
text
@d4 3
d95 1
d106 1
d113 1
d116 1
d296 1
d302 1
d306 1
d317 1
d366 4
a369 1
  fun print_mir_code(MirTypes.CODE block_list) =
d371 1
a371 1
			(map decode_block block_list)))
@


1.27
log
@Removed redundant FP(...) from printing functions.
@
text
@d4 3
a211 15
  fun decode_real_gc(MirTypes.GC_REAL gc_reg) =
    "REG " ^ MirTypes.print_gc_register gc_reg
  | decode_real_gc(MirTypes.GC_SPILL i) =
    "SPILL " ^ Integer.makestring i

  fun decode_real_non_gc(MirTypes.NON_GC_REAL gc_reg) =
    "REG " ^ MirTypes.print_non_gc_register gc_reg
  | decode_real_non_gc(MirTypes.NON_GC_SPILL i) =
    "SPILL " ^ Integer.makestring i

  fun decode_real_fp(MirTypes.FP_REAL fp_reg) =
    "FPREG " ^ MirTypes.print_fp_register fp_reg
  | decode_real_fp(MirTypes.FP_SPILL i) =
    "SPILL " ^ Integer.makestring i

d214 5
a218 5
      val (fn_arg,_) = MirRegisters.fn_arg;
      val (cl_arg,_) = MirRegisters.cl_arg;
      val (fp,_) = MirRegisters.fp;
      val (sp,_) = MirRegisters.sp;
      val (handler,_) = MirRegisters.handler
d228 4
a231 12
  fun decode_reg_operand(MirTypes.GC_REG(gc_reg, real_gc_reg_opt)) =
    "GC(" ^ decode_gc_register gc_reg ^
    (case real_gc_reg_opt of
      MirTypes.ABSENT => ""
    | MirTypes.PRESENT real_gc => decode_real_gc real_gc)
    ^ ") "
  | decode_reg_operand(MirTypes.NON_GC_REG(non_gc_reg, real_non_gc_reg_opt)) =
    "NON_GC(" ^ MirTypes.print_non_gc_register non_gc_reg ^
    (case real_non_gc_reg_opt of
      MirTypes.ABSENT => ""
    | MirTypes.PRESENT real_non_gc => decode_real_non_gc real_non_gc)
    ^ ") "
d233 2
a234 6
  fun decode_fp_operand(MirTypes.FP_REG(fp_reg, real_fp_reg_opt)) =
    "FP(" ^ MirTypes.print_fp_register fp_reg ^
    (case real_fp_reg_opt of
      MirTypes.ABSENT => ""
    | MirTypes.PRESENT real_fp => decode_real_fp real_fp)
    ^ ") "
d248 4
a251 12
  fun decode_gp_op(MirTypes.GP_GC_REG(gc_reg, real_gc_reg_opt)) =
    "GC(" ^ decode_gc_register gc_reg ^
    (case real_gc_reg_opt of
      MirTypes.ABSENT => ""
    | MirTypes.PRESENT real_gc => decode_real_gc real_gc)
    ^ ") "
  | decode_gp_op(MirTypes.GP_NON_GC_REG(non_gc_reg, real_non_gc_reg_opt)) =
    "NON_GC(" ^ MirTypes.print_non_gc_register non_gc_reg ^
    (case real_non_gc_reg_opt of
      MirTypes.ABSENT => ""
    | MirTypes.PRESENT real_non_gc => decode_real_non_gc real_non_gc)
    ^ ") "
@


1.27.1.1
log
@This is a modified version to use the reworked MirTypes module
(ver 1.23.1.1). This module is correct, but work has been suspended
on this branch because of the amount of time it would take to convert
the code generator (Mir_Cg) module.
@
text
@a3 3
Revision 1.27  91/09/25  16:11:08  richard
Removed redundant FP(...) from printing functions.

d207 1
d209 4
a212 6
  fun decode_untyped (MirTypes.REG r) =
      "Reg" ^ (MirTypes.print_virtual_register r)
    | decode_untyped (MirTypes.INT i) = "Int" ^ (Integer.makestring i)
    | decode_untyped (MirTypes.ANY i) = "Any" ^ (Integer.makestring i)
    | decode_untyped (MirTypes.SYMBOL(MirTypes.SPILL_SIZE)) =
      "spill_size"
d214 4
a217 10
  fun decode_other_operand (MirTypes.GC(MirTypes.INT(i))) =
      Integer.makestring i ^ " "
    | decode_other_operand (MirTypes.GC(u)) =
      "GC" ^ (decode_untyped u) ^ " "
    | decode_other_operand (MirTypes.NON_GC(u)) =
      "NonGC" ^ (decode_untyped u) ^ " "
    | decode_other_operand (MirTypes.FLOAT(u)) =
      "Float" ^ (decode_untyped u) ^ " "
    | decode_other_operand (MirTypes.DOUBLE(u)) =
      "Double" ^ (decode_untyped u) ^ " "
d219 4
a222 8
  fun decode_operand operand =
    if operand = MirRegisters.fn_arg then "argument"
    else if operand = MirRegisters.cl_arg then "closure"
	 else if operand = MirRegisters.fp then "frame"
	      else if operand = MirRegisters.sp then "stack"
		   else if operand = MirRegisters.handler then "handler"
			else if operand = MirRegisters.global then "global"
			     else decode_other_operand operand
d224 75
a298 5
  fun decode_op(MirTypes.BINARY(binary_op, operand, operand1, operand2)) =
    decode_binary binary_op ^ decode_operand operand ^
    decode_operand operand1 ^ decode_operand operand2
  | decode_op(MirTypes.TBINARY(tagged_binary_op, tag, operand, operand1,
			       operand2)) =
d300 8
a307 8
    decode_operand operand ^ decode_operand operand1 ^ decode_operand operand2
  | decode_op(MirTypes.UNARY(unary_op, operand, operand1)) =
    decode_unary unary_op ^ decode_operand operand ^ decode_operand operand1
  | decode_op(MirTypes.STOREOP(store_op, operand1, operand2, operand)) =
    decode_store store_op ^ decode_operand operand1 ^
    decode_operand operand2 ^ decode_operand operand
  | decode_op(MirTypes.ALLOCATE(allocate, operanderand, imm)) =
    decode_allocate allocate ^ decode_operand operanderand ^
d309 3
a311 5
  | decode_op(MirTypes.BRANCH_REG(branch, operand)) =
    decode_branch branch ^ decode_operand operand
  | decode_op(MirTypes.BRANCH(branch, tag)) =
    decode_branch branch ^ MirTypes.print_tag tag ^ " "
  | decode_op(MirTypes.TEST(cond_branch, tag, operand, operand')) =
d313 1
a313 1
    decode_operand operand ^ decode_operand operand'
d316 2
a317 2
    decode_operand fp ^ decode_operand fp'
  | decode_op(MirTypes.SWITCH(cgt, operand, tag_list)) =
d320 1
a320 1
    ("CGT " ^ decode_operand operand, tag_list)
d326 2
a327 2
  | decode_op(MirTypes.ADR(adr, operand, tag)) =
    decode_adr adr ^ decode_operand operand ^ " " ^ MirTypes.print_tag tag
d341 2
a342 4
  | decode_op(MirTypes.PRESERVE_REGS(operands)) =
    Lists.reducel op ^
    ("Preserve registers ",
      map (fn operand => decode_operand operand ^ " ") operands)
d345 2
a346 4
  | decode_op(MirTypes.RESTORE_REGS(operands)) =
    Lists.reducel op ^
    ("Restore registers ",
     map (fn operand => decode_operand operand ^ " ") operands)
d356 3
a358 3
    decode_operand fp_reg1 ^
    decode_operand fp_reg2 ^
    decode_operand fp_reg3
d360 17
a376 14
    decode_unary_fp unary_fp_op ^ decode_operand fp_reg ^
    decode_operand fp_reg'
  | decode_op(MirTypes.STACKOP(stack_op, operand)) =
    decode_stack_op stack_op ^ decode_operand operand
  | decode_op(MirTypes.STOREFPOP(store_fp_op, fp_reg, operand, operand1)) =
    decode_storefp store_fp_op ^ decode_operand fp_reg ^
    decode_operand operand ^ decode_operand operand1
  | decode_op(MirTypes.CONVOP(int_to_float, fp_reg, operand)) =
    decode_convop int_to_float ^ decode_operand fp_reg ^
    decode_operand operand
  | decode_op(MirTypes.LINK(branch_and_link, tag)) =
    decode_bl branch_and_link ^ MirTypes.print_tag tag ^ " "
  | decode_op(MirTypes.LINK_REG(branch_and_link, operand)) =
    decode_bl branch_and_link ^ decode_operand operand
d393 3
a395 1
  val operand = decode_operand
@


1.26
log
@Added NEW_HANDLER, OLD_HANDLER, and RAISE directives.
@
text
@d4 3
d355 4
a358 4
    decode_binary_fp binary_fp_op ^ "FP(" ^
    decode_fp_operand fp_reg1 ^ ") FP(" ^
    decode_fp_operand fp_reg2 ^ ") FP(" ^
    decode_fp_operand fp_reg3 ^ ")"
d360 2
a361 2
    decode_unary_fp unary_fp_op ^ "FP(" ^ decode_fp_operand fp_reg ^
    ") FP(" ^ decode_fp_operand fp_reg' ^ ")"
@


1.25
log
@Added PRESERVE_ALL_REGS
@
text
@d4 3
d344 6
@


1.24
log
@Modified register printing functions to display the names of the
special registers rather than their numbers.
@
text
@d4 4
d335 6
a340 2
  | decode_op MirTypes.PRESERVE_REGS = "Preserve registers"
  | decode_op MirTypes.RESTORE_REGS = "Restore registers"
@


1.23
log
@Added printing for MODV
@
text
@d4 3
d83 1
d92 1
d96 1
d214 16
d231 1
a231 1
    "GC(" ^ MirTypes.print_gc_register gc_reg ^
d251 1
a251 1
    "GC(" ^ MirTypes.print_gc_register gc_reg ^ ") "
d263 1
a263 1
    "GC(" ^ MirTypes.print_gc_register gc_reg ^
@


1.22
log
@Changed branches to target bl_dest
@
text
@d4 3
d118 1
@


1.21
log
@Added ALLOCA for stack allocated items
@
text
@d4 3
d273 2
a274 2
  | decode_op(MirTypes.BRANCH(branch, tag)) =
    decode_branch branch ^ MirTypes.print_tag tag
@


1.20
log
@Brought reg_operand function to the outside.
@
text
@d4 3
d158 1
d301 1
a301 1
  | decode_op MirTypes.EXIT = "Procedure exit"
@


1.19
log
@Decoded symbolics
@
text
@d4 3
d341 1
@


1.18
log
@Changed to use reduce function from Lists
@
text
@d4 3
d223 3
d242 2
@


1.17
log
@Yet more functions made available. Names containing ``print''
shortened (it's in the structure name).
@
text
@d4 4
d60 1
d69 1
d264 1
a264 1
    LambdaSub.reduce_left
d276 1
a276 1
    LambdaSub.reduce_left op ^
d280 1
a280 1
    LambdaSub.reduce_left op ^
@


1.16
log
@Still more functions revealed to the outside world (but
mostly to MirDataFlow so I can watch what it is doing.
@
text
@d4 4
d321 10
a330 2
  fun print_block block =
    P.string_of_T(decode_block block)
a331 8
  fun print_opcode opcode =
    decode_op opcode

  fun print_gp_operand opcode =
    decode_gp_op opcode

  fun print_any_reg reg =
    decode_any_reg reg
@


1.15
log
@Added LDREF and STREF to assist optimiser deduce available expressions
@
text
@d4 3
d322 6
@


1.14
log
@Added functions to allow individual opcodes and blocks to be printed.
@
text
@d4 3
d123 2
@


1.13
log
@Added printing of byte loads and stores needed for string operations
@
text
@d4 3
d308 6
@


1.12
log
@Changed printing of ENTRY and EXIT. Added printing of STOREFPOP
@
text
@d4 3
d115 2
d121 3
d282 3
a284 2
  | decode_op(MirTypes.CONVOP(int_to_float, fp_reg, reg_op)) =
    raise(pretty_not_done_yet"CONVOP")
@


1.11
log
@Changed format for floating point operations
@
text
@d4 3
d113 3
d229 2
a230 2
    decode_test cond_branch ^ MirTypes.print_tag tag ^ decode_gp_op gp_op ^
    decode_gp_op gp_op'
d232 1
a232 1
    decode_ftest fcond_branch ^ MirTypes.print_tag tag ^
d258 2
a259 2
  | decode_op MirTypes.ENTER_NO_CALLS = "Leaf procedure entry"
  | decode_op MirTypes.EXIT_NO_CALLS = "Leaf procedure exit"
d272 2
a273 1
    raise(pretty_not_done_yet"STOREFPOP")
@


1.10
log
@Slight change to ALLOC
@
text
@d4 3
d89 1
d151 5
d169 7
d227 1
a227 1
    MirTypes.print_fp_register fp ^ MirTypes.print_fp_register fp'
d257 3
a259 3
    MirTypes.print_fp_register fp_reg1 ^ ") FP(" ^
    MirTypes.print_fp_register fp_reg2 ^ ") FP(" ^
    MirTypes.print_fp_register fp_reg3 ^ ")"
d261 2
a262 2
    decode_unary_fp unary_fp_op ^ "FP(" ^ MirTypes.print_fp_register fp_reg ^
    ") FP(" ^ MirTypes.print_fp_register fp_reg' ^ ")"
@


1.9
log
@Data flow analysis
@
text
@d4 3
d194 1
a194 1
    decode_tagged_binary tagged_binary_op ^ MirTypes.print_tag tag ^
d201 2
a202 3
  | decode_op(MirTypes.ALLOCATE(allocate, gc_reg, imm)) =
    decode_allocate allocate ^ "GC(" ^ MirTypes.print_gc_register gc_reg ^
    ") " ^
@


1.8
log
@Updated for later version of HARP
@
text
@d4 3
d106 1
d253 1
d257 1
@


1.7
log
@More items printed
@
text
@d4 3
d51 6
a56 3
  | decode_binary MirTypes.MUL = "MUL "
  | decode_binary MirTypes.DIV = "DIV "
  | decode_binary MirTypes.REM = "REM "
d59 1
d61 3
a63 5
  | decode_binary MirTypes.SHL = "SHL "
  | decode_binary MirTypes.SHR = "SHR "
  | decode_binary MirTypes.SHRL = "SHRL "
  | decode_binary MirTypes.DIVL = "DIVL "
  | decode_binary MirTypes.REML = "REML "
d65 6
a70 4
  fun decode_unary MirTypes.CMP = "CMP "
  | decode_unary MirTypes.CMPL = "CMPL "
  | decode_unary MirTypes.MOV = "MOV "
  | decode_unary MirTypes.NEG = "NEG "
d73 4
a76 2
  fun decode_store MirTypes.LDX = "LDX "
  | decode_store MirTypes.STX = "STX "
d78 22
a104 14
  | decode_branch MirTypes.BEQ = "BEQ "
  | decode_branch MirTypes.BNE = "BNE "
  | decode_branch MirTypes.BHI = "BHI "
  | decode_branch MirTypes.BLS = "BLS "
  | decode_branch MirTypes.BHS = "BHS "
  | decode_branch MirTypes.BLO = "BLO "
  | decode_branch MirTypes.BGT = "BGT "
  | decode_branch MirTypes.BLE = "BLE "
  | decode_branch MirTypes.BGE = "BGE "
  | decode_branch MirTypes.BLT = "BLT "
  | decode_branch MirTypes.BVS = "BVS "
  | decode_branch MirTypes.BVC = "BVC "
  | decode_branch MirTypes.BMI = "BMI "
  | decode_branch MirTypes.BPL = "BPL "
d106 16
d127 1
a127 1
  fun decode_bl MirTypes.BL = "BL "
d185 4
d200 6
d228 1
a228 1
  | decode_op(MirTypes.ENTER i) = "Procedure entry " ^ Integer.makestring i
d230 1
a230 2
  | decode_op(MirTypes.ENTER_NO_CALLS i) =
    "Leaf procedure entry " ^ Integer.makestring i
d233 8
a240 4
  | decode_op(MirTypes.BINARYFP(binary_fp_op, fp_reg1, fp_reg2, fp_op)) =
    raise(pretty_not_done_yet"BINARYFP")
  | decode_op(MirTypes.UNARYFP(unary_fp_op, fp_reg, fp_op)) =
    raise(pretty_not_done_yet"UNARYFP")
d253 1
d255 1
@


1.6
log
@More items printed.
@
text
@d4 3
d120 9
d179 4
d203 4
a206 6
  | decode_op(MirTypes.INIT any_reg) =
    raise(pretty_not_done_yet"INIT")
  | decode_op(MirTypes.USE any_reg) =
    raise(pretty_not_done_yet"USE")
  | decode_op(MirTypes.COMMENT s) =
    "; " ^ s
@


1.5
log
@More opcodes printed
@
text
@d4 3
d171 3
@


1.4
log
@More opcodes printed
@
text
@d4 3
d38 1
a38 1
  exception pretty_not_done_yet
d85 6
d131 3
d166 2
d169 19
a187 15
  | decode_op _ = raise(pretty_not_done_yet)
(*
  | decode_op(MirTypes.BINARYFP of binary_fp_op * fp_register * fp_register * fp_operand |
  | decode_op(MirTypes.UNARYFP of unary_fp_op * fp_register * fp_operand |
  | decode_op(MirTypes.STACKOP of stack_op * reg_operand |
  | decode_op(MirTypes.STOREFPOP of store_fp_op * fp_register * reg_operand * gp_operand |
  | decode_op(MirTypes.CONVOP of int_to_float * fp_register * reg_operand |
  | decode_op(MirTypes.BRANCH_AND_LINK of branch_and_link * bl_dest |
  | decode_op(MirTypes.INIT of any_register | (* Register is initialised here *)
  | decode_op(MirTypes.USE of any_register | (* Register is used here *)
  | decode_op(MirTypes.ENTER of int * reg_operand |
    (* Entry point for procedure, with n locals and arg reg *)
  | decode_op(MirTypes.EXIT of reg_operand | (* Return point from procedure, result in reg *)
    (* Data *)
*)
@


1.3
log
@Printed more opcodes (branch and cgt)
@
text
@d4 3
d17 1
d25 1
d29 1
d80 2
d140 14
a162 2
  | decode_op(MirTypes.ADR of adr * reg_operand * tag |
    (* Information points *)
a168 1
  | decode_op(MirTypes.VALUE of (tag * Ident.SCon) list
@


1.2
log
@Redid some printing in light of changes in mirtypes
@
text
@d4 3
d15 1
d23 1
d56 1
a56 1
  | decode_allocate MirTypes.ALLOC_STRING = "ALLOC_STRING"
d58 16
d109 1
a109 1
  | decode_gp_op(MirTypes.GP_IMM imm) =
d111 2
d123 2
a124 2
    decode_allocate allocate ^ "GC(" ^ MirTypes.print_gc_register gc_reg ^ ") " 
    ^
d126 7
a139 1
  | decode_op(MirTypes.BRANCH of branch * tag |
a140 1
  | decode_op(MirTypes.SWITCH of computed_goto * non_gc_register * tag list |
d154 2
a155 2
      (P.blk(0, [P.str("Tag "), P.str(MirTypes.print_tag tag)]) ::
        (map (P.str o decode_op) op_list)))
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
a29 1
  | decode_binary MirTypes.RSB = "RSB "
d53 4
a56 4
  fun decode_reg_operand(MirTypes.GC_REG gc_reg) =
    "GC(" ^ MirTypes.print_gc_register gc_reg ^ ") "
  | decode_reg_operand(MirTypes.NON_GC_REG non_gc_reg) =
    "NON_GC(" ^ MirTypes.print_non_gc_register non_gc_reg ^ ") "
d58 30
a87 4
  fun decode_gp_op(MirTypes.GP_GC_REG gc_reg) =
    "GC(" ^ MirTypes.print_gc_register gc_reg ^ ") "
  | decode_gp_op(MirTypes.GP_NON_GC_REG non_gc_reg) =
    "NON_GC(" ^ MirTypes.print_non_gc_register non_gc_reg ^ ") "
d91 3
a93 3
  fun decode_op(MirTypes.BINARY(binary_op, reg_op1, reg_op2, gp_op)) =
    decode_binary binary_op ^ decode_reg_operand reg_op1 ^
    decode_reg_operand reg_op2 ^ decode_gp_op gp_op
@
