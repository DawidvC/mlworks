head	1.53;
access;
symbols
	MLW_daveb_inline_1_4_99:1.53.1
	MLWorks_21c0_1999_03_25:1.53
	MLWorks_20c1_1998_08_20:1.52
	MLWorks_20c0_1998_08_04:1.52
	MLWorks_20b2c2_1998_06_19:1.52
	MLWorks_20b2_Windows_1998_06_12:1.52
	MLWorks_20b1c1_1998_05_07:1.52
	MLWorks_20b0_1998_04_07:1.52
	MLWorks_20b0_1998_03_20:1.52
	MLWorks_20m2_1998_02_16:1.52
	MLWorks_20m1_1997_10_23:1.52
	MLWorks_11r1:1.51.5.1.1.1.1
	MLWorks_workspace_97:1.52.2
	MLWorks_dt_wizard:1.52.1
	MLWorks_11c0_1997_09_09:1.51.5.1.1.1
	MLWorks_10r3:1.51.5.1.3
	MLWorks_10r2_551:1.51.5.1.2
	MLWorks_11:1.51.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.51.5.1
	MLWorks_20m0_1997_06_20:1.52
	MLWorks_1_0_r2c2_1997_06_14:1.51.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.51.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.51.5
	MLWorks_BugFix_1997_04_24:1.51
	MLWorks_1_0_r2_Win32_1997_04_11:1.51
	MLWorks_1_0_r2_Unix_1997_04_04:1.51
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.51.3.1.1
	MLWorks_gui_1996_12_18:1.51.4
	MLWorks_1_0_Win32_1996_12_17:1.51.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.51.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.51.1.1
	MLWorks_1_0_Irix_1996_11_28:1.51.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.51.2
	MLWorks_1_0_Unix_1996_11_14:1.51.1
	MLWorks_Open_Beta2_1996_10_11:1.50.3
	MLWorks_License_dev:1.50.2
	MLWorks_1_open_beta_1996_09_13:1.50.1
	MLWorks_Open_Beta_1996_08_22:1.50
	MLWorks_Beta_1996_07_02:1.49
	MLWorks_Beta_1996_06_07:1.49
	MLWorks_Beta_1996_06_06:1.49
	MLWorks_Beta_1996_06_05:1.49
	MLWorks_Beta_1996_06_03:1.49
	MLWorks_Beta_1996_05_31:1.49
	MLWorks_Beta_1996_05_30:1.49
	ML_beta_release_12/08/94:1.41
	ML_beta_release_03/08/94:1.41
	ML_revised_beta_release_25/05/94:1.39
	ML_final_beta_release_02/03/94:1.38
	mlworks-28-01-1994:1.38
	Release:1.38
	mlworks-beta-01-09-1993:1.38
	MLWorks-1-0-4-29/01/1993:1.35
	MLWorks-1-0-3-21/12/1992:1.34
	MLWorks-1-0-2-15/12/1992:1.34
	MLWorks-1-0-1-04/12/1992:1.33
	checkpoint_17_08_92:1.30;
locks; strict;
comment	@ * @;


1.53
date	99.02.02.16.01.14;	author mitchell;	state Exp;
branches
	1.53.1.1;
next	1.52;

1.52
date	97.05.02.16.27.14;	author jont;	state Exp;
branches
	1.52.1.1
	1.52.2.1;
next	1.51;

1.51
date	96.11.06.11.08.43;	author matthew;	state Exp;
branches
	1.51.1.1
	1.51.2.1
	1.51.3.1
	1.51.4.1
	1.51.5.1;
next	1.50;

1.50
date	96.08.09.16.55.06;	author daveb;	state Exp;
branches
	1.50.1.1
	1.50.2.1
	1.50.3.1;
next	1.49;

1.49
date	96.05.07.11.07.31;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	96.04.29.14.48.16;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	96.03.28.11.07.03;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	95.05.31.11.13.48;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	95.05.15.10.52.34;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	94.10.13.11.16.06;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	94.09.13.16.33.38;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	94.08.25.13.09.52;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	94.07.19.10.31.59;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	94.07.11.11.58.55;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	94.05.12.12.58.47;	author richard;	state Exp;
branches;
next	1.38;

1.38
date	93.08.17.11.20.11;	author richard;	state Exp;
branches
	1.38.1.1;
next	1.37;

1.37
date	93.08.06.13.29.16;	author richard;	state Exp;
branches;
next	1.36;

1.36
date	93.03.10.18.04.04;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	93.01.21.16.34.21;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	92.12.08.19.56.00;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	92.11.03.14.57.08;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	92.09.22.09.37.54;	author clive;	state Exp;
branches;
next	1.31;

1.31
date	92.08.26.15.30.53;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	92.06.22.11.51.52;	author richard;	state Exp;
branches;
next	1.29;

1.29
date	92.06.22.10.20.03;	author richard;	state Exp;
branches;
next	1.28;

1.28
date	92.06.11.10.17.16;	author richard;	state Exp;
branches;
next	1.27;

1.27
date	92.06.04.15.03.13;	author richard;	state Exp;
branches;
next	1.26;

1.26
date	92.06.03.09.03.18;	author richard;	state Exp;
branches;
next	1.25;

1.25
date	92.05.19.11.05.45;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	92.05.12.10.50.50;	author richard;	state Exp;
branches;
next	1.23;

1.23
date	92.04.13.15.16.24;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.03.02.12.15.41;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	92.02.18.15.27.08;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.02.05.17.12.40;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	92.01.28.12.22.03;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	92.01.23.09.50.17;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	91.12.03.11.53.16;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	91.11.29.14.59.13;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	91.11.19.14.09.12;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	91.10.21.17.10.07;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	91.10.17.12.24.23;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	91.10.11.14.54.25;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	91.10.11.10.02.33;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	91.10.10.12.59.21;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	91.10.04.09.10.50;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	91.10.02.12.01.06;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	91.10.01.15.26.29;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.09.25.15.51.23;	author richard;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	91.09.24.12.25.40;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	91.09.23.14.30.59;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.09.20.11.40.08;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.09.19.15.36.39;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	91.09.18.17.46.39;	author richard;	state Exp;
branches;
next	;

1.6.1.1
date	91.09.26.14.44.27;	author richard;	state Exp;
branches;
next	;

1.38.1.1
date	93.08.17.11.20.11;	author jont;	state Exp;
branches;
next	;

1.50.1.1
date	96.09.13.11.14.14;	author hope;	state Exp;
branches;
next	;

1.50.2.1
date	96.10.07.16.04.42;	author hope;	state Exp;
branches;
next	;

1.50.3.1
date	96.10.17.11.22.56;	author hope;	state Exp;
branches;
next	;

1.51.1.1
date	96.11.14.12.47.12;	author hope;	state Exp;
branches
	1.51.1.1.1.1;
next	;

1.51.1.1.1.1
date	96.11.28.14.58.47;	author hope;	state Exp;
branches;
next	;

1.51.2.1
date	96.11.22.18.07.17;	author hope;	state Exp;
branches;
next	;

1.51.3.1
date	96.12.17.17.46.01;	author hope;	state Exp;
branches
	1.51.3.1.1.1;
next	;

1.51.3.1.1.1
date	97.02.24.11.35.36;	author hope;	state Exp;
branches;
next	;

1.51.4.1
date	96.12.18.09.40.00;	author hope;	state Exp;
branches;
next	;

1.51.5.1
date	97.05.12.10.32.21;	author hope;	state Exp;
branches
	1.51.5.1.1.1
	1.51.5.1.2.1
	1.51.5.1.3.1;
next	;

1.51.5.1.1.1
date	97.07.28.18.18.06;	author daveb;	state Exp;
branches
	1.51.5.1.1.1.1.1;
next	;

1.51.5.1.1.1.1.1
date	97.10.07.11.43.03;	author jkbrook;	state Exp;
branches;
next	;

1.51.5.1.2.1
date	97.09.08.17.11.39;	author daveb;	state Exp;
branches;
next	;

1.51.5.1.3.1
date	97.09.09.14.07.16;	author daveb;	state Exp;
branches;
next	;

1.52.1.1
date	97.09.10.19.22.02;	author brucem;	state Exp;
branches;
next	;

1.52.2.1
date	97.09.11.20.53.18;	author daveb;	state Exp;
branches;
next	;

1.53.1.1
date	99.04.01.17.56.00;	author daveb;	state Exp;
branches;
next	;


desc
@The MirVariable module performs reverse dataflow analysis (live
variable analysis and optimisation) of a MirOptTypes.procedure.
This is the functor.
@


1.53
log
@[Bug #190500]
Remove redundant require statements
@
text
@(*  ==== LIVE VARIABLE ANALYSIS ====
 *		FUNCTOR
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  The live variables of an arbitrary network of blocks are found using an
 *  iterative algorithm.  Firstly, the flow of control of the procedure is
 *  traced in order to build a map of blocks to the blocks that reach them,
 *  and also build a queue of blocks in postorder.  The postordered blocks are
 *  then repeatedly scanned, recomputing live variable sets until a fixed point
 *  is reached.  Postorder ensures that this is done in a small number of passes.
 *
 *  Revision Log
 *  ------------
 *  $Log: _mirvariable.sml,v $
 * Revision 1.52  1997/05/02  16:27:14  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.51  1996/11/06  11:08:43  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.50  1996/08/09  16:55:06  daveb
 * [Bug #1534]
 * Updated a comment.
 *
 * Revision 1.49  1996/05/07  11:07:31  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.48  1996/04/29  14:48:16  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.47  1996/03/28  11:07:03  matthew
 * Adding where type clause
 *
 * Revision 1.46  1995/05/31  11:13:48  matthew
 * Changing instruction datatype
 * /
 *
 *  Revision 1.45  1995/05/15  10:52:34  jont
 *  Use a tree instead of an assoc list in scan
 *  Remove gratuitous use of refs in scan (procedure parameters used instead)
 *
 *  Revision 1.44  1994/10/13  11:16:06  matthew
 *  Use pervasive Option.option for return values in NewMap
 *
 *  Revision 1.43  1994/09/13  16:33:38  matthew
 *  Use inthashtables for efficiency
 *
 *  Revision 1.42  1994/08/25  13:09:52  matthew
 *  Simplifications to annotations
 *  Changed the way the blocks are scanned in live variable
 *  analysis (see comments).
 *
 *  Revision 1.41  1994/07/19  10:31:59  matthew
 *  Extending loop entry points
 *
 *  Revision 1.40  1994/07/11  11:58:55  matthew
 *  Sometimes we get a loop entry point without a corresponding block (which
 *  presumably has been optimised away).  Check for this in analyse.
 *
 *  Revision 1.39  1994/05/12  12:58:47  richard
 *  Fixed analysis of infinite loops by importing the loop entry
 *  point from _mir_cg.
 *
 *  Revision 1.38  1993/08/17  11:20:11  richard
 *  Changed the annotation of raise instructions to model the fact that
 *  the raise might reach _any_ of the nexted continuation blocks.
 *
 *  Revision 1.37  1993/08/06  13:29:16  richard
 *  Split the analysis of an instruction into a before and after phase
 *  to ensure that registers defined by branching instructions are properly
 *  clashed.
 *
 *  Revision 1.36  1993/03/10  18:04:04  matthew
 *  Map substructure is now MirTypes.Map
 *
 *  Revision 1.35  1993/01/21  16:34:21  jont
 *  Changed handle Map.Undefined constructs for case statements thus
 *  allowing tail recursion to work proprely
 *
 *  Revision 1.34  1992/12/08  19:56:00  jont
 *  Removed a number of duplicated signatures and structures
 *
 *  Revision 1.33  1992/11/03  14:57:08  jont
 *  Efficiency changes to use mononewmap for registers and tags
 *
 *  Revision 1.32  1992/09/22  09:37:54  clive
 *  Got rid of some handles using tryApply and co
 *
 *  Revision 1.31  1992/08/26  15:30:53  jont
 *  Removed some redundant structures and sharing
 *
 *  Revision 1.30  1992/06/22  11:51:52  richard
 *  Corrected dataflow between exception raising instructions and
 *  continuation code.
 *
 *  Revision 1.28  1992/06/11  10:17:16  richard
 *  Changed call to graph clasher to include referenced register
 *  information.
 *
 *  Revision 1.27  1992/06/04  15:03:13  richard
 *  The variable analyser now updates the register clash graph
 *  directly rather than producing a list of clashes.
 *
 *  Revision 1.26  1992/06/03  09:03:18  richard
 *  Utilized mutable register sets (packs) and new Map operations.
 *
 *  Revision 1.26  1992/06/01  10:08:19  richard
 *  Utilized mutable register sets (packs) and new Map operations.
 *
 *  Revision 1.25  1992/05/19  11:05:45  richard
 *  Improved use of Map.apply.
 *
 *  Revision 1.24  1992/05/12  10:50:50  richard
 *  Moved operations on triples of register sets to MirProcedure.
 *
 *  Revision 1.23  1992/04/13  15:16:24  clive
 *  First version of the profiler
 *
 *  Revision 1.22  1992/03/02  12:15:41  richard
 *  Completely rewritten to use dependencies between blocks to determine
 *  the order of analysis.  This allows the module to cope with arbitrary
 *  networks of blocks.  The module now uses virtual register sets rather
 *  than the polymorphic set implementation and constructs the register
 *  clash information directly for use by the register allocator rather
 *  than annotating the procedure with it.  It also makes use of the new
 *  MirProcedure module for annotation purposes.
 *
 *)


require "../utils/diagnostic";
require "../utils/crash";
require "../utils/lists";
require "../utils/inthashtable";
require "registerallocator";
require "mirtables";
require "mirprint";
require "mirregisters";
require "mirvariable";


functor MirVariable(include
                    sig 
                      structure Diagnostic		: DIAGNOSTIC
                      structure Crash		: CRASH
                      structure Lists		: LISTS
                      structure IntHashTable        : INTHASHTABLE
                      structure MirPrint		: MIRPRINT
                      structure MirTables		: MIRTABLES
                      structure MirRegisters	: MIRREGISTERS
                      structure RegisterAllocator	: REGISTERALLOCATOR

                      sharing MirPrint.MirTypes = MirTables.MirTypes =
                        RegisterAllocator.MirProcedure.MirTypes = MirRegisters.MirTypes
                      sharing Diagnostic.Text = MirRegisters.MirTypes.GC.Set.Text
                    end
                    where type MirPrint.MirTypes.tag = int
                    ) : MIRVARIABLE =

  struct

    structure MirProcedure = RegisterAllocator.MirProcedure
    structure MirTypes = MirRegisters.MirTypes
    structure Set = MirTypes.Set
    structure RegisterAllocator = RegisterAllocator
    structure Diagnostic = Diagnostic
    structure Map = MirTypes.Map

    (*  == Switches ==
     *
     *  See signature for documentation.  The default behaviour is to
     *  eliminate apparently useless instructions.
     *)

    val eliminate = ref true


    (*  == Diagnostic output and crashes ==  *)

    val $ = Diagnostic.Text.from_string
    val ^^ = Diagnostic.Text.concatenate
    infix ^^

    val do_diagnostics = false

    fun diagnostic (level, output_function) =
      Diagnostic.output_text level
      (fn verbosity => $"MirVariable: " ^^ output_function verbosity)

    fun diagnostic_set (level, prefix_function, {gc, non_gc, fp}) =
      diagnostic (level, fn _ =>
                  prefix_function () ^^ $"  " ^^
                  MirTypes.GC.Pack.to_text gc ^^ $" " ^^
                  MirTypes.NonGC.Pack.to_text non_gc ^^ $" " ^^
                  MirTypes.FP.Pack.to_text fp)

    fun crash message =
      Crash.impossible ("MirVariable: " ^ message)


    (* Tag maps *)
    fun empty_tag_map () = IntHashTable.new 4
    fun lookup_tag (tag,map) = IntHashTable.tryLookup (map,tag)

    fun tagmap_from_list l =
      let
        val result = empty_tag_map ()
      in
        Lists.iterate (fn (tag,x) => IntHashTable.update (result,tag,x)) l;
        result
      end

    (*  === BUILD REACH MAP ===
     *
     *  This function analyses a list of (tag, block) pairs and produces a
     *  Map.T from block tags to the list of tags of those blocks which
     *  might reach them.
     *
     *  For the sake of the efficiency of this function the map is of
     *  references to lists rather than lists, but there is no reason to
     *  update the map returned by the function.
     *)

    fun reach_map blocks =
      let
        val result = tagmap_from_list (map (fn (tag, _) => (tag, ref [])) blocks)
        fun result_fn tag = lookup_tag (tag,result)

        fun block [] = ()
          | block ((from, MirProcedure.B ({reached, ...}, _))::rest) =
            let
              fun reach [] = ()
                | reach (to::rest) =
                  let
                    val to_list = 
                      case result_fn to of
                        SOME x => x
                      | NONE =>
                          crash ("Block " ^ MirTypes.print_tag to ^ 
                                 " was reached but isn't in the list of blocks.")
                  in
                    to_list := from::(!to_list);
                    reach rest
                  end
            in
              reach (Set.set_to_list reached);
              block rest
            end
      in
        block blocks;
        result
      end

    (* Do a dfs on the call graph *)
    fun dfs (block_fn,start) =
      let

	fun scan(arg as (seen, result), tag) =
	  case MirTypes.Map.tryApply'(seen, tag) of
	    NONE =>
	      let
		val MirProcedure.B({reached,...},_) = block_fn tag
		val seen = MirTypes.Map.define(seen, tag, true)
		val (seen, result) =
		  Lists.reducel
		  scan
		  ((seen, result), Set.set_to_list reached)
	      in
		(seen, tag :: result)
	      end
	  | _ => arg
	val (_, result) = scan((MirTypes.Map.empty, []), start)
      in
        (* And return in postorder *)
        rev result
      end

    (*  === ANALYSE A PROCEDURE ===
     *
     *  A procedure is analysed in two passes.  The first uses an iterative
     *  method to determine which registers are live on entry to each block,
     *  and the second uses this information to generate the register clash
     *  lists and discard useless instructions.
     *)

    fun analyse (procedure as MirProcedure.P (annotation as {parameters, ...},
                                              name, start, block_map), graph) =
      let
        val _ = 
          if do_diagnostics
            then diagnostic (1, fn _ => $"procedure " ^^ $(MirTypes.print_tag start) ^^ $" " ^^ $name)
          else ()

        val clash = RegisterAllocator.clash graph
        val blocks = Map.to_list block_map

        local
          val reach_map = reach_map blocks
          val live_map =
            tagmap_from_list (map (fn (tag, _) => (tag, ref MirProcedure.empty)) blocks)
          val block_table = tagmap_from_list blocks
        in

          fun reach_map_fn tag = 
          (case lookup_tag (tag,reach_map) of
             SOME (ref new_tags) => new_tags
           | _ => crash ("Block " ^ MirTypes.print_tag tag ^ " was found but is not in the reached map."))

          fun live_map_fn tag =
            case IntHashTable.tryLookup (live_map,tag) of
              SOME x => x
            | _ => crash ("Block " ^ MirTypes.print_tag tag ^ " is not in the live map.")

          fun block_fn tag = 
            case IntHashTable.tryLookup (block_table,tag) of
              SOME x => x
            | _ => crash ("Block " ^ MirTypes.print_tag tag ^ " is not in the procedure.")
        end

        (*  == Calculate registers live after an instruction ==
         *
         *  Given an annotated instruction and a set of registers live
         *  before the next instruction, this function calculates the set of
         *  live registers immediately after the instruction, including
         *  registers referenced from other blocks reached by branches and
         *  exceptions.
         *
         *  The live parameter may be mutated by this operation.
         *)

        fun after (MirProcedure.I {branches, excepts, opcode, ...}, live) =
          let
            fun reach (live, []) = live
              | reach (live, tag::tags) =
                reach (MirProcedure.union' (live, !(live_map_fn tag)), tags)

            val live' = reach (live, excepts)
            val live'' = reach (live', Set.set_to_list branches)
          in
            if do_diagnostics
              then
                diagnostic_set (4, fn () => $"live after " ^^ $(MirPrint.opcode opcode) ^^ $":", live'')
            else ();
            live''
          end


        (*  == Calculate registers live before an instruction ==
         *
         *  Given an annotated instruction and a set of registers live
         *  immediately after it, this function calculates the set of live
         *  registers before it using the formula:
         *
         *    live before = live after - defined + referenced
         *
         *  The live parameter may be mutated by this operation.
         *)

        nonfix before 

        fun before (MirProcedure.I {defined, referenced, opcode, ...}, live) =
          let
            val live' = MirProcedure.union' (MirProcedure.difference' (live, defined),referenced)
          in
            if do_diagnostics
              then diagnostic_set (4, fn () => $"live before " ^^ $(MirPrint.opcode opcode) ^^ $":", live')
            else ();
            live'
          end


        (*  == FIRST PASS: Analyse a single block ==
         *
         *  Given an annotated block this function scans it backwards
         *  calculating the sets of live registers before each
         *  instruction. The function returns the set of variables live on
         *  entry to the block.
         *)

        fun block (MirProcedure.B (_, instructions)) =
          Lists.reducer
          (fn (instruction, live) => before (instruction, after (instruction, live)))
          (instructions, MirProcedure.empty)


        (*  == FIRST PASS: Analyse blocks until a fixed point is reached ==
         *
         * Iterate repeatedly down the array of blocks recalculating live
         * sets.  When a live set changes, the blocks reachable from the
         * current block are marked for recomputation.  Eventually a fixed
         * point is reached, detected by a full scan through the block
         * without any recomputation .  The number of iterations is usually
         * 1 + the maximum number of back arcs an acyclic path of the call
         * graph. 
         *)

        val ordered_blocks = dfs (block_fn,start)
        val num_blocks = Lists.length ordered_blocks
        val block_array = MLWorks.Internal.Array.arrayoflist ordered_blocks
        val todo = MLWorks.Internal.Array.array (num_blocks,true)

        local 
          fun number ([],n,acc) = rev acc
            | number (a::rest,n,acc) = number (rest,n+1,(a,n)::acc)
          val block_index_map = tagmap_from_list (number (ordered_blocks,0,[]))
        in
          fun block_index tag =
            (case IntHashTable.tryLookup (block_index_map,tag) of
               SOME n => n
             | _ => crash "block index failure")
        end

        (* Iterate through the array of blocks to do *)
        fun iterate num_passes =
          let
            fun aux (changed,n) =
              (* Finished this pass *)
              if n = num_blocks
                then changed
              else
                (* Don't need to do this one *)
                if not (MLWorks.Internal.Array.sub (todo,n))
                  then aux (changed,n+1)
                else
                  let
                    val tag = MLWorks.Internal.Array.sub (block_array,n)
                    val old_live = live_map_fn tag
                    val new_live = block (block_fn tag)
                    val _ = MLWorks.Internal.Array.update (todo,n,false)
                  in
                    if MirProcedure.equal (!old_live, new_live)
                      then aux (true,n+1)
                    else
                      (old_live := new_live;
                       let
                         val new_tags = reach_map_fn tag
                       in
                         Lists.iterate
                         (fn tag => MLWorks.Internal.Array.update (todo,block_index tag,true))
                         new_tags;
                         aux (true,n+1)
                       end)
                  end
            val changed = aux (false,0)
          in
            (* Changed will be true if some blocks were recalculated *)
            if changed 
              then iterate (num_passes + 1)
            else ((* output(std_out,"Terminated after " ^ Int.toString num_passes ^ " passes\n" )*))
          end

        val _ = iterate 0

(* Old version *)
(*
        fun iterate [] = ()
          | iterate (tag::tags) =
            let
              (* val _ = output (std_out,MirTypes.print_tag tag ^ " ") *)
              val _ = 
                if do_diagnostics
                  then diagnostic (3, fn _ => $"analysing block " ^^ $(MirTypes.print_tag tag))
                else ()

              val old_live = live_map_fn tag

              val new_live = block (block_fn tag)

            in
              if MirProcedure.equal (!old_live, new_live) then
                iterate tags
              else
                (if do_diagnostics
                   then diagnostic_set (3, fn _ => $"new live", new_live)
                 else ();
                 old_live := new_live;
		 let
		   val new_tags = case reach_map_fn tag of
		     SOME (ref new_tags) => new_tags
		   | _ =>
		       crash ("Block " ^ MirTypes.print_tag tag ^
			      " was queued but is not in the reached map.")
		 in
		   iterate (tags @@ Lists.difference (new_tags, tags))
		 end)
            end
*)
(* Since we analyse all blocks reachable from the start, we don't need this *)
(* anymore *)
(*
        (* The analysis starts at the exit points of the procedure. *)

        val _ = iterate (Set.set_to_list exits)

        (* If there's a loop entry point, analyse from there as well.  This *)
        (* will catch any cycles which don't reach exits. *)

        val _ =
          case parameters of
            MirTypes.PROC_PARAMS {loop_entry = [], ...} => ()
          | MirTypes.PROC_PARAMS {loop_entry = [tag], ...} =>
              (case Map.tryApply block_map tag of
                 SOME x => iterate [tag]
               | _ => ())
          | MirTypes.PROC_PARAMS {loop_entry = taglist, ...} =>
              crash "Mirvariable can't cope with multiple entry points yet"

        val _ =
          if do_diagnostics
            then
              diagnostic
              (2,
               fn _ =>
               Lists.reducel
               (fn (text, (tag, ref {gc, non_gc, fp})) =>
                text ^^ $"\n  block " ^^ $(MirTypes.print_tag tag) ^^
                $" live: " ^^ MirTypes.GC.Pack.to_text gc ^^
                $" "    ^^ MirTypes.NonGC.Pack.to_text non_gc ^^
                $" "       ^^ MirTypes.FP.Pack.to_text fp)
               ($"Live map:", Map.to_list live_map))
          else ()
*)

        (* Consistency check:  There should be no registers live on entry to *)
        (* the procedure. *)
        (* This catches many errors *)
        val _ =
          let
            val live_at_start as {gc, non_gc, fp} = !(live_map_fn start)
          in
            if MirProcedure.is_empty live_at_start then () else
              crash (Lists.reducel (fn (s, r) => s ^ " " ^ MirTypes.GC.to_string r)
                     (Lists.reducel (fn (s, r) => s ^ " " ^ MirTypes.NonGC.to_string r)
                      (Lists.reducel (fn (s, r) => s ^ " " ^ MirTypes.FP.to_string r)
                       ("The following registers are used undefined in procedure " ^ 
                        MirTypes.print_tag start ^ " " ^ name ^ ":",
                        MirTypes.FP.Pack.to_list fp),
                       MirTypes.NonGC.Pack.to_list non_gc),
                      MirTypes.GC.Pack.to_list gc))
          end


        (*  == SECOND PASS: Generate clashes and optimise a block ==
         *
         *  This runs through the blocks using the resolved live_map to
         *  determine which instructions define dead registers and have no
         *  side effects.  These are eliminated if `eliminate' is set to
         *  true.  The register clashes are also added to the graph.
         *)

        fun modify (MirProcedure.B (annotation, instructions)) =
          let
            val instructions' =
              let
                fun modify' (live, done, []) = done
                  | modify' (live, done,
                             (instruction as MirProcedure.I {defined, referenced, opcode, ...})::instructions) =
                    if !eliminate andalso
                      not (MirTables.has_side_effects opcode) andalso
                      MirProcedure.is_empty (MirProcedure.intersection (defined, live)) then
                      (if do_diagnostics
                         then
                           diagnostic_set (3, fn () => $"eliminating " ^^ $(MirPrint.opcode opcode) ^^ $" in context ", live)
                       else ();
                       modify' (live, done, instructions))
                    else
                      let
                        val live' = after (instruction, live)
                      in
                        clash (defined, referenced, live');
                        modify' (before (instruction, live'), instruction::done, instructions)
                      end
              in
                modify' (MirProcedure.empty, [], rev instructions)
              end
          in
            MirProcedure.B (annotation, instructions')
          end

        val blocks' =
          Lists.reducel
          (fn (blocks, (tag, block)) =>
           (if do_diagnostics
              then diagnostic (3, fn _ => $"modifying block " ^^ $(MirTypes.print_tag tag))
            else ();
            (tag, modify block)::blocks))
          ([], blocks)

        val block_map' = Map.from_list blocks'
        val procedure' = MirProcedure.P (annotation, name,start, block_map')
      in
        procedure'
      end

  end
@


1.53.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a17 4
 * Revision 1.53  1999/02/02  16:01:14  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.52
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d18 4
a134 2

require "../basis/__int";
@


1.52.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a17 4
 * Revision 1.52  1997/05/02  16:27:14  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.52.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a17 4
 * Revision 1.52  1997/05/02  16:27:14  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.51
log
@[Bug #1728]
__integer becomes __int
@
text
@d18 4
a170 1
    structure Option = MLWorks.Option
d240 2
a241 2
                        Option.SOME x => x
                      | Option.NONE =>
d263 1
a263 1
	    MLWorks.Option.NONE =>
d309 1
a309 1
             Option.SOME (ref new_tags) => new_tags
d314 1
a314 1
              Option.SOME x => x
d319 1
a319 1
              Option.SOME x => x
d412 1
a412 1
               Option.SOME n => n
d482 1
a482 1
		     MLWorks.Option.SOME (ref new_tags) => new_tags
d506 1
a506 1
                 MLWorks.Option.SOME x => iterate [tag]
@


1.51.5.1
log
@branched from 1.51
@
text
@a17 4
 * Revision 1.51  1996/11/06  11:08:43  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.51.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a17 3
 * Revision 1.51.5.1  1997/05/12  10:32:21  hope
 * branched from 1.51
 *
@


1.51.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a17 3
 * Revision 1.51.5.1  1997/05/12  10:32:21  hope
 * branched from 1.51
 *
@


1.51.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a17 3
 * Revision 1.51.5.1  1997/05/12  10:32:21  hope
 * branched from 1.51
 *
@


1.51.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a17 3
 * Revision 1.51.5.1.1.1  1997/07/28  18:18:06  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.51.4.1
log
@branched from 1.51
@
text
@a17 4
 * Revision 1.51  1996/11/06  11:08:43  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.51.3.1
log
@branched from 1.51
@
text
@a17 4
 * Revision 1.51  1996/11/06  11:08:43  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.51.3.1.1.1
log
@branched from 1.51.3.1
@
text
@a17 3
 * Revision 1.51.3.1  1996/12/17  17:46:01  hope
 * branched from 1.51
 *
@


1.51.2.1
log
@branched from 1.51
@
text
@a17 4
 * Revision 1.51  1996/11/06  11:08:43  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.51.1.1
log
@branched from 1.51
@
text
@a17 4
 * Revision 1.51  1996/11/06  11:08:43  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.51.1.1.1.1
log
@branched from 1.51.1.1
@
text
@a17 3
 * Revision 1.51.1.1  1996/11/14  12:47:12  hope
 * branched from 1.51
 *
@


1.50
log
@[Bug #1534]
Updated a comment.
@
text
@d18 4
d128 1
a128 1
require "../basis/__integer";
@


1.50.3.1
log
@branched from 1.50
@
text
@a17 4
 * Revision 1.50  1996/08/09  16:55:06  daveb
 * [Bug #1534]
 * Updated a comment.
 *
@


1.50.2.1
log
@branched from 1.50
@
text
@a17 4
 * Revision 1.50  1996/08/09  16:55:06  daveb
 * [Bug #1534]
 * Updated a comment.
 *
@


1.50.1.1
log
@branched from 1.50
@
text
@a17 4
 * Revision 1.50  1996/08/09  16:55:06  daveb
 * [Bug #1534]
 * Updated a comment.
 *
@


1.49
log
@Array moving to MLWorks.Array
@
text
@d18 3
d355 1
a355 1
        nonfix before (* for SML/NJ, ack gag barf *)
@


1.48
log
@Removing MLWorks.Integer
@
text
@d18 3
d392 2
a393 2
        val block_array = Array.arrayoflist ordered_blocks
        val todo = Array.array (num_blocks,true)
d415 1
a415 1
                if not (Array.sub (todo,n))
d419 1
a419 1
                    val tag = Array.sub (block_array,n)
d422 1
a422 1
                    val _ = Array.update (todo,n,false)
d432 1
a432 1
                         (fn tag => Array.update (todo,block_index tag,true))
@


1.47
log
@Adding where type clause
@
text
@d18 3
d118 2
d439 1
a439 1
            else ((* output(std_out,"Terminated after " ^ MLWorks.Integer.makestring num_passes ^ " passes\n" )*))
@


1.46
log
@Changing instruction datatype
/
@
text
@d18 4
d126 17
a142 17
functor MirVariable(
  structure Diagnostic		: DIAGNOSTIC
  structure Crash		: CRASH
  structure Lists		: LISTS
  structure IntHashTable        : INTHASHTABLE
  structure MirPrint		: MIRPRINT
  structure MirTables		: MIRTABLES
  structure MirRegisters	: MIRREGISTERS
  structure RegisterAllocator	: REGISTERALLOCATOR

  sharing type MirPrint.MirTypes.tag = int 
  sharing MirPrint.MirTypes = MirTables.MirTypes =
    RegisterAllocator.MirProcedure.MirTypes = MirRegisters.MirTypes
  sharing Diagnostic.Text = MirRegisters.MirTypes.GC.Set.Text
    

) : MIRVARIABLE =
@


1.45
log
@Use a tree instead of an assoc list in scan
Remove gratuitous use of refs in scan (procedure parameters used instead)
@
text
@d18 4
d312 1
a312 1
        fun after (MirProcedure.I ({branches, except, ...}, opcode), live) =
d318 1
a318 1
            val live' = reach (live, except)
d342 1
a342 1
        fun before (MirProcedure.I ({defined, referenced, ...}, opcode), live) =
d538 1
a538 1
                             (instruction as MirProcedure.I ({defined, referenced, ...}, opcode))::instructions) =
@


1.44
log
@Use pervasive Option.option for return values in NewMap
@
text
@d18 3
d234 16
a249 13
        val seen = ref [] : MirTypes.tag list ref
        val result = ref [] : MirTypes.tag list ref
        fun scan tag =
          if Lists.member (tag,!seen)
            then ()
          else
            let
              val MirProcedure.B({reached,...},_) = block_fn tag
            in
              seen := tag :: (!seen);
              Lists.iterate scan (Set.set_to_list reached);
              result := tag :: (!result)
            end
a250 1
        scan start;
d252 1
a252 1
        rev (!result)
@


1.43
log
@Use inthashtables for efficiency
@
text
@d18 3
d451 1
a451 1
		     Map.YES(ref new_tags) => new_tags
d475 1
a475 1
                 Map.YES x => iterate [tag]
@


1.42
log
@Simplifications to annotations
Changed the way the blocks are scanned in live variable
analysis (see comments).
@
text
@d18 5
d104 1
d113 2
d116 1
a116 2
  structure Crash		: CRASH
  structure Diagnostic		: DIAGNOSTIC
d122 1
d126 1
d138 1
d172 11
d197 2
a198 2
        val result = Map.from_list (map (fn (tag, _) => (tag, ref [])) blocks)
        val result_fn = Map.tryApply result
d208 2
a209 2
                        Map.YES x => x
                      | Map.NO =>
d263 1
a264 10
        val reach_map = reach_map blocks
        val reach_map_fn = 
          let val f = Map.tryApply reach_map
          in
            fn tag => 
            (case f tag of
               Map.YES(ref new_tags) => new_tags
             | _ =>
                 crash ("Block " ^ MirTypes.print_tag tag ^ " was found but is not in the reached map."))
          end
a265 3
        val live_map =
          Map.from_list (map (fn (tag, _) => (tag, ref MirProcedure.empty)) blocks)

d267 4
a270 1
          val live_map_fn_returning_option = Map.tryApply live_map
d272 6
d279 2
a280 2
            case live_map_fn_returning_option tag of
              Map.YES x => x
a281 3
        end

        val clash = RegisterAllocator.clash graph
a282 3
        local
          val option_block_fn = Map.tryApply (block_map)
        in
d284 2
a285 2
            case option_block_fn tag of
              Map.YES x => x
d371 10
a380 9
        (* This should be replaced by  better function *)
        fun block_index tag =
          let 
            fun block_index_aux ([],n) = crash "block index failure"
              | block_index_aux (tag'::rest,n) =
                if tag = tag' then n else block_index_aux (rest,n+1)
          in
            block_index_aux (ordered_blocks,0)
          end
@


1.41
log
@Extending loop entry points
@
text
@d9 1
a9 1
 *  interative algorithm.  Firstly, the flow of control of the procedure is
d11 3
a13 4
 *  and also build a queue of blocks.  Then the fun begins.  Each block on
 *  the queue is analysed, and, for any block whose live variables on entry
 *  change the blocks which reach it are added to the back of the queue.
 *  Eventually the queue will empty.
d18 3
d107 3
a113 3
  structure Lists		: LISTS
  structure Crash		: CRASH
  structure Diagnostic		: DIAGNOSTIC
d145 2
d176 1
a176 2
        val result =
          Map.from_list (map (fn (tag, _) => (tag, ref [])) blocks)
d189 2
a190 1
                          crash ("Block " ^ MirTypes.print_tag to ^ " was reached but isn't in the list of blocks.")
d204 21
a224 1

d234 1
a234 1
    fun analyse (procedure as MirProcedure.P (annotation as {exits, parameters, ...},
d237 4
a240 1
        val _ = diagnostic (1, fn _ => $"procedure " ^^ $(MirTypes.print_tag start) ^^ $" " ^^ $name)
d244 10
a253 1
        val reach_map_fn = Map.tryApply reach_map
a255 2
        val live_map_fn = Map.apply live_map
        val live_map_fn_returning_option = Map.tryApply live_map
d257 9
d268 8
a275 12
        val _ =
          diagnostic
          (2,
           fn _ =>
           Lists.reducel
           (fn (text, (tag, ref list)) =>
            Lists.reducel
            (fn (text, tag) =>
             text ^^ $" " ^^ $(MirTypes.print_tag tag))
            (text ^^ $"\n  " ^^ $(MirTypes.print_tag tag) ^^ $" is reached by", list))
           ($"Reach map:", Map.to_list reach_map))

a292 3
                handle Map.Undefined =>
                 crash ("Block " ^ MirTypes.print_tag tag ^
                        " was reached but it not in the live map.")
d297 4
a300 1
            diagnostic_set (4, fn () => $"live after " ^^ $(MirPrint.opcode opcode) ^^ $":", live'');
d310 1
d320 1
a320 1
            val live' = MirProcedure.union' (MirProcedure.difference' (live, defined), referenced)
d322 3
a324 1
            diagnostic_set (4, fn () => $"live before " ^^ $(MirPrint.opcode opcode) ^^ $":", live');
d345 7
a351 11
         *  This function takes a list of tags of blocks to analyse and
         *  applies `block' (see above) to them.  If, for any block, this
         *  yields a different set of live variables to that in the live_map
         *  then the blocks which depend on that block are added to the list
         *  for reanalysis. This continues until the list is empty.  The
         *  process is guaranteed to terminate because the sets of live
         *  variables in the live_map can only increase up to a limit.
         *
         *  For a linear procedure this function will only analyse each
         *  block once.  For procedures with complex loops a few iterations
         *  may be required, but usually very few.
d354 58
d415 7
a421 1
              val _ = diagnostic (3, fn _ => $"analysing block " ^^ $(MirTypes.print_tag tag))
d423 2
a424 11
              val old_live = 
                case live_map_fn_returning_option tag of
                  Map.YES x => x
                | Map.NO => 
                    crash ("Block " ^ MirTypes.print_tag tag ^ " was queued but is not in the live map.")
              val new_live = 
                block (case Map.tryApply block_map tag of
                         Map.YES x => x
                       | Map.NO  =>
                           crash ("Block " ^ MirTypes.print_tag tag ^ 
                                  " was queued but is not in the procedure."))
d429 3
a431 1
                (diagnostic_set (3, fn _ => $"new live", new_live);
d443 4
a446 1

d465 14
a478 10
          diagnostic
          (2,
           fn _ =>
           Lists.reducel
           (fn (text, (tag, ref {gc, non_gc, fp})) =>
            text ^^ $"\n  block " ^^ $(MirTypes.print_tag tag) ^^
            $" live: " ^^ MirTypes.GC.Pack.to_text gc ^^
            $" "    ^^ MirTypes.NonGC.Pack.to_text non_gc ^^
            $" "       ^^ MirTypes.FP.Pack.to_text fp)
           ($"Live map:", Map.to_list live_map))
d482 1
d485 1
a485 6
            val live_at_start as {gc, non_gc, fp} = 
              case live_map_fn_returning_option start of
                Map.YES x => !x
              | Map.NO =>
                  crash ("Couldn't find the start block of procedure " ^ MirTypes.print_tag start ^ 
                         " in the live map.")
d491 2
a492 1
                       ("The following registers are used undefined in procedure " ^ MirTypes.print_tag start ^ " " ^ name ^ ":",
d517 4
a520 1
                      (diagnostic_set (3, fn () => $"eliminating " ^^ $(MirPrint.opcode opcode) ^^ $" in context ", live);
d539 3
a541 1
           (diagnostic (3, fn _ => $"modifying block " ^^ $(MirTypes.print_tag tag));
@


1.40
log
@Sometimes we get a loop entry point without a corresponding block (which
presumably has been optimised away).  Check for this in analyse.
@
text
@d19 4
d358 2
a359 1
            MirTypes.PROC_PARAMS {loop_entry = MirTypes.Option.PRESENT tag, ...} =>
d363 2
a364 4
          | _ => ()

        val MirTypes.PROC_PARAMS {loop_entry, ...} = parameters

@


1.39
log
@Fixed analysis of infinite loops by importing the loop entry
point from _mir_cg.
@
text
@d19 4
d355 3
a357 1
              iterate [tag]
@


1.38
log
@Changed the annotation of raise instructions to model the fact that
the raise might reach _any_ of the nexted continuation blocks.
@
text
@d19 4
d202 2
a203 1
    fun analyse (procedure as MirProcedure.P (annotation as {exits, ...}, name,start, block_map), graph) =
d341 2
d344 12
@


1.38.1.1
log
@Fork for bug fixing
@
text
@a18 4
 *  Revision 1.38  1993/08/17  11:20:11  richard
 *  Changed the annotation of raise instructions to model the fact that
 *  the raise might reach _any_ of the nexted continuation blocks.
 *
@


1.37
log
@Split the analysis of an instruction into a before and after phase
to ensure that registers defined by branching instructions are properly
clashed.
@
text
@d19 5
d238 4
a241 12
            val live' =
              case except of
                MirProcedure.Option.ABSENT => live
              | MirProcedure.Option.PRESENT tag =>
                  MirProcedure.union' (live, !(live_map_fn tag))
                  handle Map.Undefined =>
                    crash ("Exception continuation block " ^ MirTypes.print_tag tag ^
                           " was reached but is not in the live map.")
            val live'' =
              Lists.reducel
              (fn (live, tag) => MirProcedure.union' (live, !(live_map_fn tag))
               handle Map.Undefined =>
d243 4
a246 2
                        " was reached but it not in the live map."))
              (live', Set.set_to_list branches)
d265 1
a265 1
        fun before (MirProcedure.I ({defined, referenced, branches, except, ...}, opcode), live) =
@


1.36
log
@Map substructure is now MirTypes.Map
@
text
@d19 3
d195 1
a195 1
        val _ = diagnostic (1, fn _ => $"procedure " ^^ $(MirTypes.print_tag start))
d218 1
a218 1
          
d220 1
a220 1
        (*  == Analyse a single instruction ==
d223 4
a226 6
         *  immediately after it, this function calculates the set of live
         *  registers before it using the formula:
         *    live before = live after - defined + referenced
         *  If a branch or exception to another block is found then the
         *  registers live on entry to that block are extracted from the
         *  live_map and added to the referenced set.
d231 1
a231 1
        fun instruction ((MirProcedure.I ({defined, referenced, branches, except, ...}, opcode)), live) =
d233 9
a241 18
            val _ = diagnostic (4, fn _ => $(MirPrint.opcode opcode))

            val referenced' =
              case except
                of MirProcedure.Option.ABSENT => live
                 | MirProcedure.Option.PRESENT tag => 
                   let
                     val continuation_live = 
                       case live_map_fn_returning_option tag of
                         Map.YES x => !x
                       | Map.NO =>
                         crash ("Continuation block " ^ MirTypes.print_tag tag ^ 
                                " was reached but is not in the live map.")
                   in
                     MirProcedure.union' (live, MirProcedure.difference (continuation_live, MirRegisters.defined_by_raise))
                   end

            val referenced'' =
d245 20
a264 2
                 crash ("Block " ^ MirTypes.print_tag tag ^ " was reached but is not in the live map."))
              (referenced', Set.set_to_list branches)
d266 3
a268 1
            val live'' = MirProcedure.union' (MirProcedure.difference' (referenced'', defined), referenced)
d270 2
a271 2
            diagnostic_set (4, fn () => $"live:", live'');
            live''
d278 3
a280 3
         *  calculating the sets of live registers before each instruction
         *  using the `instruction' function above. The function returns
         *  the set of variables live on entry to the block.
d284 3
a286 1
          Lists.reducer instruction (instructions, MirProcedure.empty)
d366 1
a366 1
                       ("The following registers are used undefined in procedure " ^ MirTypes.print_tag start ^ ":",
d387 1
a387 1
                             (ins as MirProcedure.I ({defined, referenced, ...}, opcode))::instructions) =
d394 6
a399 2
                      (clash (defined, referenced, live);
                       modify' (instruction (ins, live), ins::done, instructions))
@


1.35
log
@Changed handle Map.Undefined constructs for case statements thus
allowing tail recursion to work proprely
@
text
@d19 4
d106 1
a106 1
    structure Map = MirTypes.Debugger_Types.Datatypes.NewMap
d153 2
a154 2
          MirTypes.Map.from_list (map (fn (tag, _) => (tag, ref [])) blocks)
        val result_fn = MirTypes.Map.tryApply result
d164 2
a165 2
                        MirTypes.Map.YES x => x
                      | MirTypes.Map.NO =>
d194 1
a194 1
        val blocks = MirTypes.Map.to_list block_map
d196 1
a196 1
        val reach_map_fn = MirTypes.Map.tryApply reach_map
d198 3
a200 3
          MirTypes.Map.from_list (map (fn (tag, _) => (tag, ref MirProcedure.empty)) blocks)
        val live_map_fn = MirTypes.Map.apply live_map
        val live_map_fn_returning_option = MirTypes.Map.tryApply live_map
d214 1
a214 1
           ($"Reach map:", MirTypes.Map.to_list reach_map))
d241 2
a242 2
                         MirTypes.Map.YES x => !x
                       | MirTypes.Map.NO =>
d252 1
a252 1
               handle MirTypes.Map.Undefined =>
d297 2
a298 2
                  MirTypes.Map.YES x => x
                | MirTypes.Map.NO => 
d301 3
a303 3
                block (case MirTypes.Map.tryApply block_map tag of
                         MirTypes.Map.YES x => x
                       | MirTypes.Map.NO  =>
d314 1
a314 1
		     MirTypes.Map.YES(ref new_tags) => new_tags
d335 1
a335 1
           ($"Live map:", MirTypes.Map.to_list live_map))
d343 2
a344 2
                MirTypes.Map.YES x => !x
              | MirTypes.Map.NO =>
d396 1
a396 1
        val block_map' = MirTypes.Map.from_list blocks'
@


1.34
log
@Removed a number of duplicated signatures and structures
@
text
@d19 3
d192 1
a192 1
        val reach_map_fn = MirTypes.Map.apply reach_map
d308 9
a316 3
                 iterate (tags @@ Lists.difference (!(reach_map_fn tag), tags))
                 handle MirTypes.Map.Undefined =>
                   crash ("Block " ^ MirTypes.print_tag tag ^ " was queued but is not in the reached map."))
@


1.33
log
@Efficiency changes to use mononewmap for registers and tags
@
text
@d19 3
a72 1
require "mirprocedure";
a77 2

  structure MirProcedure	: MIRPROCEDURE
d86 2
a87 2
  sharing MirProcedure.MirTypes = MirPrint.MirTypes =
    MirTables.MirTypes = RegisterAllocator.MirTypes = MirRegisters.MirTypes
d94 1
a94 1
    structure MirProcedure = MirProcedure
@


1.32
log
@Got rid of some handles using tryApply and co
@
text
@d19 3
d146 2
a147 2
          Map.from_list' MirTypes.order_tag (map (fn (tag, _) => (tag, ref [])) blocks)
        val result_fn = Map.tryApply result
d157 2
a158 2
                        Map.YES x => x
                      | Map.NO =>
d187 1
a187 1
        val blocks = Map.to_list block_map
d189 1
a189 1
        val reach_map_fn = Map.apply reach_map
d191 3
a193 3
          Map.from_list' MirTypes.order_tag (map (fn (tag, _) => (tag, ref MirProcedure.empty)) blocks)
        val live_map_fn = Map.apply live_map
        val live_map_fn_returning_option = Map.tryApply live_map
d207 1
a207 1
           ($"Reach map:", Map.to_list reach_map))
d234 2
a235 2
                         Map.YES x => !x
                       | Map.NO =>
d245 1
a245 1
               handle Map.Undefined =>
d290 2
a291 2
                  Map.YES x => x
                | Map.NO => 
d294 3
a296 3
                block (case Map.tryApply block_map tag of
                         Map.YES x => x
                       | Map.NO  =>
d306 1
a306 1
                 handle Map.Undefined =>
d322 1
a322 1
           ($"Live map:", Map.to_list live_map))
d330 2
a331 2
                Map.YES x => !x
              | Map.NO =>
d383 1
a383 1
        val block_map' = Map.from_list' MirTypes.order_tag blocks'
@


1.31
log
@Removed some redundant structures and sharing
@
text
@d19 3
d144 1
a144 1
        val result_fn = Map.apply result
d152 5
a156 3
                    val to_list = result_fn to
                      handle Map.Undefined =>
                        crash ("Block " ^ MirTypes.print_tag to ^ " was reached but isn't in the list of blocks.")
d190 1
d229 6
a234 3
                     val continuation_live = !(live_map_fn tag)
                       handle Map.Undefined =>
                         crash ("Continuation block " ^ MirTypes.print_tag tag ^ " was reached but is not in the live map.")
d285 11
a295 6
              val old_live = live_map_fn tag
                handle Map.Undefined =>
                  crash ("Block " ^ MirTypes.print_tag tag ^ " was queued but is not in the live map.")
              val new_live = block (Map.apply block_map tag)
                handle Map.Undefined =>
                  crash ("Block " ^ MirTypes.print_tag tag ^ " was queued but is not in the procedure.")
d325 6
a330 3
            val live_at_start as {gc, non_gc, fp} = !(live_map_fn start)
              handle Map.Undefined =>
                crash ("Couldn't find the start block of procedure " ^ MirTypes.print_tag start ^ " in the live map.")
@


1.30
log
@Corrected dataflow between exception raising instructions and
continuation code.
@
text
@d19 4
a59 2
require "../utils/set";
require "../utils/newmap";
a62 1
require "mirtypes";
a71 1
  structure MirTypes		: MIRTYPES
a76 2
  structure Set			: SET
  structure Map			: NEWMAP
d80 1
a80 1
  sharing MirTypes = MirProcedure.MirTypes = MirPrint.MirTypes =
d82 1
a82 3
  sharing Set = MirProcedure.Set = MirTypes.Set
  sharing Map = MirProcedure.Map
  sharing Diagnostic.Text = MirTypes.Text
d89 2
a90 1
    structure MirTypes = MirTypes
d93 1
a93 1

@


1.29
log
@A more helpful message is produced when registers are used undefined.
@
text
@d64 1
d74 1
d82 2
a83 1
  sharing MirTypes = MirProcedure.MirTypes = MirPrint.MirTypes = MirTables.MirTypes = RegisterAllocator.MirTypes
d220 2
a221 1
            val reached =
d223 11
a233 3
                of MirProcedure.Option.PRESENT tag => tag :: Set.set_to_list branches
                 | MirProcedure.Option.ABSENT      => Set.set_to_list branches
            val referenced' =
d238 3
a240 2
              (live, reached)
            val live' = MirProcedure.union' (MirProcedure.difference' (referenced', defined), referenced)
d242 2
a243 2
            diagnostic_set (4, fn () => $"live:", live');
            live'
@


1.28
log
@Changed call to graph clasher to include referenced register
information.
@
text
@d19 4
d300 14
a313 6
          (if MirProcedure.is_empty (!(live_map_fn start)) then
             ()
           else
             crash ("Registers are used undefined in procedure " ^ MirTypes.print_tag start))
          handle Map.Undefined =>
            crash ("Couldn't find the start block of procedure " ^ MirTypes.print_tag start ^ " in the live map.")
@


1.27
log
@The variable analyser now updates the register clash graph
directly rather than producing a list of clashes.
@
text
@d19 4
d318 1
a318 1
                             (ins as MirProcedure.I ({defined, ...}, opcode))::instructions) =
d325 1
a325 1
                      (clash (defined, live);
@


1.26
log
@Utilized mutable register sets (packs) and new Map operations.
@
text
@d19 3
d51 1
d65 1
d72 1
a72 1
  sharing MirTypes = MirProcedure.MirTypes = MirPrint.MirTypes = MirTables.MirTypes
d83 1
d167 1
a167 1
    fun analyse (procedure as MirProcedure.P (annotation as {exits, ...}, name,start, block_map)) =
d178 2
d215 1
a215 1
              (fn (live, tag) => MirProcedure.union (live, !(live_map_fn tag))
d219 1
a219 1
            val live' = MirProcedure.union (MirProcedure.difference (referenced', defined), referenced)
d300 1
a300 1
        (*  == SECOND PASS: Generate clash lists and optimise a block ==
d305 1
a305 1
         *  true.  The lists of register clashes are also built here.
d308 1
a308 1
        fun modify (clashes, MirProcedure.B (annotation, instructions)) =
d310 16
a325 24

            fun modify' (clashes, live, done, []) = (clashes, done)
              | modify' (clashes as {gc, non_gc, fp},
                         live,
                         done,
                         (ins as MirProcedure.I ({defined, ...}, opcode))::instructions) =
                if !eliminate andalso
                  not (MirTables.has_side_effects opcode) andalso
                  MirProcedure.is_empty (MirProcedure.intersection (defined, live)) then
                  (diagnostic_set (3, fn () => $"eliminating " ^^ $(MirPrint.opcode opcode) ^^ $" in context ", live);
                   modify' (clashes, live, done, instructions))
                else
                  let
                    val clashes' =
                      {gc     = (#gc defined, #gc live)::gc,
                       non_gc = (#non_gc defined, #non_gc live)::non_gc,
                       fp     = (#fp defined, #fp live)::fp}
                    val live' = instruction (ins, live)
                  in
                    modify' (clashes', live', ins::done, instructions)
                  end

            val (clashes, instructions') =
              modify' (clashes, MirProcedure.empty, [], rev instructions)
d327 1
a327 1
            (clashes, MirProcedure.B(annotation, instructions'))
d330 1
a330 1
        val (clashes, blocks') =
d332 4
a335 8
          (fn ((clashes, blocks), (tag, block)) =>
           let
             val _ = diagnostic (3, fn _ => $"modifying block " ^^ $(MirTypes.print_tag tag))
             val (clashes', block') = modify (clashes, block)
           in
             (clashes', (tag, block')::blocks)
           end)
          (({gc = [], non_gc = [], fp = []}, []), blocks)
d340 1
a340 1
        (procedure', clashes)
@


1.25
log
@Improved use of Map.apply.
@
text
@d19 6
d103 3
a105 3
                  $"GCs: "    ^^ MirTypes.GC.Set.to_text gc ^^
                  $" NonGCs: " ^^ MirTypes.NonGC.Set.to_text non_gc ^^
                  $" FPs: "    ^^ MirTypes.FP.Set.to_text fp)
a109 2
    fun order (op<) (x,y) =
      if x=y then Map.EQUAL else if x<y then Map.LESS else Map.GREATER
a111 1

d126 1
a126 1
          Map.from_list (order MirTypes.order_tag) (map (fn (tag, _) => (tag, ref [])) blocks)
d169 1
a169 3
          Map.from_list
          (order MirTypes.order_tag)
          (map (fn (tag, _) => (tag, ref MirProcedure.empty)) blocks)
d194 2
d211 1
a211 1
            val live' = MirProcedure.union (referenced, MirProcedure.difference (referenced', defined))
d276 3
a278 3
            $" live GCs: " ^^ MirTypes.GC.Set.to_text gc ^^
            $" NonGCs: "    ^^ MirTypes.NonGC.Set.to_text non_gc ^^
            $" FPs: "       ^^ MirTypes.FP.Set.to_text fp)
d341 1
a341 1
        val block_map' = Map.from_list (order MirTypes.order_tag) blocks'
@


1.24
log
@Moved operations on triples of register sets to MirProcedure.
@
text
@d19 3
d124 1
d132 1
a132 1
                    val to_list = Map.apply result to
d164 1
d169 1
d204 1
a204 1
              (fn (live, tag) => MirProcedure.union (live, !(Map.apply live_map tag))
d247 1
a247 1
              val old_live = Map.apply live_map tag
d259 1
a259 1
                 iterate (tags @@ Lists.difference (!(Map.apply reach_map tag), tags))
d281 1
a281 1
          (if MirProcedure.is_empty (!(Map.apply live_map start)) then
@


1.23
log
@First version of the profiler
@
text
@d19 3
a104 30
    fun union ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Set.union (gc, gc'),
       non_gc = MirTypes.NonGC.Set.union (non_gc, non_gc'),
       fp     = MirTypes.FP.Set.union (fp, fp')}

    fun intersection ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Set.intersection (gc, gc'),
       non_gc = MirTypes.NonGC.Set.intersection (non_gc, non_gc'),
       fp     = MirTypes.FP.Set.intersection (fp, fp')}

    fun difference ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      {gc     = MirTypes.GC.Set.difference (gc, gc'),
       non_gc = MirTypes.NonGC.Set.difference (non_gc, non_gc'),
       fp     = MirTypes.FP.Set.difference (fp, fp')}

    fun equal ({gc, non_gc, fp}, {gc = gc', non_gc = non_gc', fp = fp'}) =
      MirTypes.GC.Set.equal (gc, gc') andalso
      MirTypes.NonGC.Set.equal (non_gc, non_gc') andalso
      MirTypes.FP.Set.equal (fp, fp')

    val empty_sets = {gc = MirTypes.GC.Set.empty,
                      non_gc = MirTypes.NonGC.Set.empty,
                      fp = MirTypes.FP.Set.empty}

    fun empty {gc, non_gc, fp} =
      MirTypes.GC.Set.equal (gc, MirTypes.GC.Set.empty) andalso
      MirTypes.NonGC.Set.equal (non_gc, MirTypes.NonGC.Set.empty) andalso
      MirTypes.FP.Set.equal (fp, MirTypes.FP.Set.empty)


d163 1
a163 1
          (map (fn (tag, _) => (tag, ref empty_sets)) blocks)
d198 1
a198 1
              (fn (live, tag) => union (live, !(Map.apply live_map tag))
d202 1
a202 1
            val live' = union (referenced, difference (referenced', defined))
d218 1
a218 1
          Lists.reducer instruction (instructions, empty_sets)
d248 1
a248 1
              if equal (!old_live, new_live) then
d275 1
a275 1
          (if empty (!(Map.apply live_map start)) then
d301 1
a301 1
                  empty (intersection (defined, live)) then
d316 1
a316 1
              modify' (clashes, empty_sets, [], rev instructions)
@


1.22
log
@Completely rewritten to use dependencies between blocks to determine
the order of analysis.  This allows the module to cope with arbitrary
networks of blocks.  The module now uses virtual register sets rather
than the polymorphic set implementation and constructs the register
clash information directly for use by the register allocator rather
than annotating the procedure with it.  It also makes use of the new
MirProcedure module for annotation purposes.
@
text
@d19 9
d181 1
a181 1
    fun analyse (procedure as MirProcedure.P (annotation as {exits, ...}, start, block_map)) =
d360 1
a360 1
        val procedure' = MirProcedure.P (annotation, start, block_map')
@


1.21
log
@Switches.eliminate_useless is taken notice of
@
text
@d1 19
a19 1
(* mirvariable.sml the functor *)
a20 4
(*
$Log: _mirvariable.sml,v $
Revision 1.20  1992/02/05  17:12:40  richard
Abolished PREVIOUS_ENVIRONMENT and PRESERVE_ALL_REGS.
a21 74
Revision 1.19  1992/01/28  12:22:03  richard
Changed diagnostic output to reflect changes in MirOptTypes.

Revision 1.18  1992/01/23  09:50:17  richard
Separated instruction elimination from live variable analysis so that
it only occurs on the _first_ pass round a loop.

Revision 1.17  1991/12/03  11:53:16  richard
Removed the referenced registers from the MirOptTypes.REGS
as these are no longer required.

Revision 1.16  91/11/29  14:59:13  richard
Prevented the registers referenced by a block from being included
in the referenced registers of a branch to that block.

Revision 1.15  91/11/19  14:09:12  richard
Changed debugging output to use the Diagnostic module, which
prevents the debugging output strings being constructed even
if they aren't printed.

Revision 1.14  91/10/21  17:10:07  jont
Sorted out successors to avoid losing blocks referenced by cgt

Revision 1.13  91/10/17  12:24:23  richard
Now uses Switches module to control optimisation and debugging output.

Revision 1.12  91/10/11  14:54:25  richard
Switched off debugging output.

Revision 1.11  91/10/11  10:02:33  richard
Slight alterations to cope with new MirTypes.

Revision 1.10  91/10/10  12:59:21  richard
Moved tables to common MirTables module. Used records for parameters
to the process_* functions to simplify the code and facilitate later
implementation of backward copy propagation. Changed register names
for register window machines.

Revision 1.9  91/10/04  09:10:50  richard
Added a missing sharing specification.

Revision 1.8  91/10/02  12:01:06  richard
Modified to remove refereneces to real registers, which have been
expunged from MirTypes.

Revision 1.7  91/10/01  15:26:29  richard
Converted code to fill in the extra `referenced registers' field added
in revision 1.6 of MirOptTypes.

Revision 1.6  91/09/25  15:51:23  richard
Added floating point operators and registers.
Modified analysis to cope with loops by doing an extra pass. Phew!

Revision 1.5  91/09/24  12:25:40  richard
Modified to use a table of blocks rather than a simple list. See
MirOptTypes.

Revision 1.4  91/09/23  14:30:59  richard
Switched off debugging output.

Revision 1.3  91/09/20  11:40:08  richard
Added redundant instruction elimintation. Added extra special registers
(handle, closure, etc.) to register analysis.

Revision 1.2  91/09/19  15:36:39  richard
Finished implementing live variable analysis (without any code
modification --- that's the next stage).

Revision 1.1  91/09/18  17:46:39  richard
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

d25 1
d27 1
a27 2
require "../utils/print";
require "../utils/table";
a28 2
require "mirregisters";
require "mirtables";
d30 1
a30 2
require "miropttypes";
require "switches";
d36 9
a44 11
  structure MirOptTypes	: MIROPTTYPES
  structure MirTypes	: MIRTYPES
  structure MirRegisters: MIRREGISTERS
  structure MirPrint	: MIRPRINT
  structure MirTables	: MIRTABLES
  structure Table	: TABLE
  structure Lists	: LISTS
  structure Set		: SET
  structure Crash	: CRASH
  structure Switches	: SWITCHES
  structure Diagnostic	: DIAGNOSTIC
d46 4
a49 4
  sharing MirTypes = MirOptTypes.MirTypes =
    MirPrint.MirTypes = MirRegisters.MirTypes = MirTables.MirTypes
  sharing Set = MirOptTypes.Set = MirTypes.Set = MirTables.Set =
    MirRegisters.Set
d53 1
a53 1
struct
d55 3
a57 3
  structure MirOptTypes = MirOptTypes
  structure Switches = Switches
  structure Diagnostic = Diagnostic
d60 5
d66 1
a66 1
  (*  == Diagnostic output ==  *)
a67 4
  fun diagnostic (level, output_function) =
    Diagnostic.output level
    (fn verbosity =>
     "MirOptimiser (Variable): " :: (output_function verbosity))
d69 1
d71 3
d75 3
a77 1
  (*  === MISCELLANEOUS DATA ===  *)
d79 6
a84 4
  (*  == Fixed registers ==
   *
   *  These registers are used for special purposes by the code.
   *)
d86 2
a87 5
  val caller_arg_reg = MirTypes.GC MirRegisters.caller_arg
  val callee_arg_reg = MirTypes.GC MirRegisters.callee_arg
  val caller_closure_reg = MirTypes.GC MirRegisters.caller_closure
  val callee_closure_reg = MirTypes.GC MirRegisters.callee_closure
  val global_reg = MirTypes.GC MirRegisters.global
d89 2
d93 4
a96 7
  (*  === PROCESSED BLOCK RECORD ===
   *
   *  In order that work is not duplicated when analysing the live
   *  variables, a table of processed blocks is maintained. The table
   *  maintenance would be fairly verbose if written out explicitly,
   *  so the table is defined as an abstype here.
   *)
d98 4
a101 2
  type processed_block_record = {block	: MirOptTypes.block,
				 live	: MirTypes.any_register Set.Set}
d103 4
a106 3
  abstype processed_blocks =
    TABLE of (MirTypes.tag, processed_block_record) Table.table
  with
d108 4
a111 3
    val none_processed =
      TABLE (Table.empty_table
	     (Table.TableSpec {order = MirTypes.order_tag, eq = op=}))
d113 3
a115 3
    fun add_processed (TABLE table,
		       record as {block as MirOptTypes.BLOCK(tag,_), ...}) =
      TABLE (Table.overwrite ((tag, record), table))
d117 4
a120 3
    exception NotProcessed = Table.Lookup
    fun get_processed (TABLE table, tag) =
      Table.lookup (tag, table)
a121 7
    fun build_procedure (start_tag, params, TABLE table) =
      let
	val plain_block_list =
	  map (#block o #2) (Table.alist_of_table table)
      in
	MirOptTypes.make_proc (start_tag, params, plain_block_list)
      end
a122 1
  end
d124 1
a124 97


  (*  === ELIMINATE USELESS INSTRUCTIONS ===
   *
   *  This function examines a block which has been annotated with live
   *  variable information and removes any instructions which define dead
   *  variables and have no side effects.
   *)

  fun eliminate opcodes =
    let

      fun eliminate' (done, [triple]) = rev (triple::done)

        | eliminate' (done,
                      (triple as (opcode, regs, succs)) ::
                      (rest as (_, MirOptTypes.REGS live, _) :: _)) =
          if !Switches.eliminate_useless andalso
            (not (MirTables.has_side_effects opcode)) andalso
            (Set.empty_setp (Set.intersection
                             (MirTables.defined_by opcode, live))) then
          (
            diagnostic (3, fn _ =>
                        ["Eliminating ", MirPrint.opcode opcode,
                         " in context "] @@
                        (MirOptTypes.print_registers (MirOptTypes.REGS live)));
            eliminate' (done, rest)
          )
          else
            eliminate' (triple::done, rest)

        | eliminate' (_, []) =
          Crash.impossible
          "MirOptimiser (Variable): Empty opcode list passed to eliminate"

        | eliminate' _ =
          Crash.impossible
          "MirOptimiser (Variable): eliminate called with unannotated opcodes"

    in
      eliminate' ([], opcodes)
    end

              




  (*  === PERFORM LIVE VARIABLE ANALYSIS ON A PROCEDURE ===
   *
   *  ...featuring triple mutual recursion! This one's tricky. The
   *  parameters are a list of blocks and the tag of the first
   *  executed block.
   *
   *  Throughout processing a procedure containing the
   *  blocks processed so far is kept so that effort is not
   *  duplicated. Also, a two lists of `pending' blocks which are
   *  currently being processed (by callers of the current function)
   *  is kept so that loops can be detected and analysed. A block on
   *  the first pending list which can be reached from the current
   *  level _is_ analysed, but is copied to the second pending list
   *  while this is occurring. A block on the second pending list is
   *  not analysed, and is assumed to have no live registers. This
   *  gives the correct results for loops.
   *
   *  First, process_block tries to find the block in the proc_done.
   *  If it succeeds it returns the live registers at the start of the
   *  block, and the proc_done. If it fails it gets the block from
   *  the original procedure, and calls process on its opcodes. It then
   *  returns the live registers at the start of the newly-processed
   *  block, and the proc_done with the new block added.
   *
   *  process_ops examines each opcode, and determines which registers
   *  are referenced and defined by it. It then calls itself to work
   *  out which registers are live for the following opcode. If the
   *  opcode is some sort of branch, then process_succ is called on
   *  the successor blocks to work out their live registers. The live
   *  registers for the opcode can then be calculated using the rule
   *  live_in = ref'd union (live_out - def'd).
   *
   *  process_succ calls process_block on a list of blocks and unions
   *  together their live registers.
   *
   *  The most tricky part is not the live register analysis, but
   *  keeping track of all the blocks done and making sure that no
   *  loop can occur.
   *)


  fun analyse (original_proc as MirOptTypes.PROC(start_tag, params, _)) =
  let

    val _ = diagnostic (1, fn _ => ["processing procedure ",
				    MirTypes.print_tag start_tag])


    (*  == Generate live registers for a block ==
d126 3
a128 8
     *  Parameter record:
     *    processed A table of records containing the blocks already
     *              processed, together with the live variables on
     *              entry.
     *    pending   A tuple of two lists, the first contains the tags of
     *              the blocks which have been processed once, the
     *              second, those processed twice.
     *    tag       The tag of the block to process.
d130 3
a132 3
     *  Returns:
     *    A tuple of the live registers of that block and the updated
     *    version of the processed parameter.
d135 1
a135 1
    fun process_block {processed, pending as (pass1,pass2), tag} =
d137 2
d140 13
a152 65
	(* Try to find the block in the list of blocks already *)
	(* processed, and simply return its live registers. *)
	  
	val result = (#live (get_processed (processed, tag)), processed)

	val _ = diagnostic (2, fn _ => ["block ",
					MirTypes.print_tag tag,
					" already processed"])
      in
	result
      end

      (* If that fails then check whether the block is on the second *)
      (* pending list. If it is then assume it has no live variables. *)

      handle NotProcessed =>
	if Lists.member (tag, pass2) then
	(
	  diagnostic (2, fn _ => ["third pass of block ",
				  MirTypes.print_tag tag,
				  ", empty sets of live registers assumed"]);
	  (Set.empty_set, processed)
	)
	else
	let

	  (* The block will need processing, so find it in the original *)
	  (* list of blocks. *)

	  val MirOptTypes.BLOCK(_,opcodes) =
	    MirOptTypes.get_block original_proc tag
	    handle MirOptTypes.NoSuchBlock =>
	      Crash.impossible
	      ("MirOptimiser (Variable): process_block has been " ^
	       "passed a block tag which refers to a block which " ^
	       "is not in the current procedure. The tag was " ^
	       (MirTypes.print_tag tag) ^ ".")

	  val {live,
	       opcodes = processed_opcodes,
	       processed = more_processed} =

            (* If the block is on the first pending list then *)
            (* re-analyse it, but add it to the second list. If it is *)
            (* not then it has never been analysed, so analyse it, eliminate *)
            (* useless instructions and add it to the first list. *)

            if Lists.member (tag, pass1) then
            (
              diagnostic (2, fn _ => ["second pass of block ",
                                      MirTypes.print_tag tag]);
                
              process_ops {processed = processed,
                           pending = (pass1, tag::pass2),
                           opcodes = opcodes}
            )
            else
            let
              val _ = diagnostic (2, fn _ => ["first pass of block ",
                                              MirTypes.print_tag tag])

              val {live, opcodes, processed} =
                process_ops {processed = processed,
                             pending = (tag::pass1, pass2),
                             opcodes = opcodes}
d154 2
a155 3
              {live = live,
               opcodes = eliminate opcodes,
               processed = processed}
d157 4
a161 3
	  val processed_block_record =
	    {block = MirOptTypes.BLOCK(tag, processed_opcodes),
	     live =  live}
a162 3
	in
	  (live, add_processed (more_processed, processed_block_record))
	end
d164 1
a164 2

    (*  == Process a list of blocks and union their registers ==
d166 4
a169 5
     *  Parameter record as for process_block, except:
     *    successors  Is a MirOptTypes.successors containing the tags
     *                of the blocks to be processed.
     *
     *  Returns as for process_block.
d172 3
a174 4
    and process_succ {processed,
		      pending,
		      successors as MirOptTypes.SUCCS tags} =
	let
d176 6
a181 2
	  fun p (proc_processed, live, []) =
	      (live, proc_processed)
d183 12
a194 9
	    | p (proc_processed, live, tag::tags) =
	      let
		val (live', new_proc_processed) =
		  process_block {processed = proc_processed,
				 pending = pending,
				 tag = tag}
	      in
		p (new_proc_processed, Set.union(live,live'), tags)
	      end
d196 10
a205 3
	in
	  p (processed, Set.empty_set, tags)
	end
d207 18
a224 6
      | process_succ _ =
	Crash.impossible
	  ("MirOptimiser (Variable): I've been given some code which has "^
	   "not been flow analysed. The MirFlow module must be applied "^
	   "to the code before MirVariable can be used. And don't tell "^
	   "me it's a free country.")
d227 7
a233 18
    (*  == Process opcodes within a block, following branches ==
     *
     *  Parameter record:
     *    processed   As for process_block.
     *    pending     As for process_block.
     *    opcodes     A list of opcodes to perform analysis on.
     *                Opcodes which have successor information
     *                installed by the MirFlow module will cause
     *                recursive calls to process_succs to find out
     *                their live registers.
     *
     *  Return record:
     *    live        The set of live registers before the first
     *                opcode.
     *    opcodes     The opcodes, now annotated with live variable
     *                information.
     *    processed   An updated version of the processed parameter.
     *)
d235 2
a236 3
	(* If we reach the end of the opcodes then the previous *)
	(* instruction must have been some sort of unconditional block *)
	(* exit (see MirFlow) therefore no registers are live. *)
a237 4
    and process_ops {processed, opcodes as [], ...} =
        {live = Set.empty_set,
	 opcodes = [],
	 processed = processed}
d239 14
a252 3
      | process_ops {processed, pending,
		     opcodes as (opcode,_,successors)::rest} =
	let
d254 4
a257 2
	  (* Work out which registers are defined and referenced by *)
	  (* the opcode. *)
d259 16
a274 2
	  val defined_here = MirTables.defined_by opcode
	  val referenced_here = MirTables.referenced_by opcode
d276 1
a276 3
	  (* If the opcode is not a BRANCH, process the rest of the *)
	  (* opcodes in the block to find out which registers are live *)
	  (* after the opcode. *)
d278 11
a288 12
	  val {live = after_inside,
	       opcodes = processed_opcodes,
	       processed = more_processed} =
	    case opcode
	      of (MirTypes.BRANCH _) =>
		   {live = Set.empty_set,
		    opcodes = [],
		    processed = processed}
	       | _ =>
		   process_ops {processed = processed,
				pending = pending,
				opcodes = rest}
d290 9
a298 3
	  (* Process any blocks which can be reached from this opcode *)
	  (* (e.g., if it is a branch) to find out which registers are *)
	  (* live after this opcode. *)
a299 4
	  val (after_outside, even_more_processed) =
	    process_succ {processed = more_processed,
			  pending = pending,
			  successors = successors}
d301 7
a307 1
	  val after = Set.union (after_inside, after_outside)
d309 2
a310 12
          (* Work out which variables are live before the opcode from *)
          (* the above information. *)
            
          val live_before =
            Set.union (referenced_here,
                       Set.setdiff (after, defined_here))
            
          (* Work out which registers were referenced by the opcode. *)
            
          val regs = MirOptTypes.REGS live_before
            
        in
d312 20
a331 24
          diagnostic (4, fn _ => ["before ",
                                  MirPrint.opcode opcode,
                                  " are "] @@
                      (MirOptTypes.print_registers regs));
          
          (* Return the opcode and the processed rest of the opcodes, *)
          (* together with any blocks which have been processed *)
          (* incidentally. *)
          
          {live = live_before,
           opcodes = (opcode, regs, successors) :: processed_opcodes,
           processed = even_more_processed}
          
	end


    (* Start the ball rolling by processing the first block. *)

    val (still_live, processed_blocks) =
      process_block {processed = none_processed,
		     pending = ([],[]),
		     tag = start_tag}

  in
d333 5
a337 1
    if Set.empty_setp still_live then
d339 10
a348 1
      build_procedure (start_tag, params, processed_blocks)
d350 5
a354 1
    else
d356 1
a356 10
      Crash.impossible
      ("MirOptimiser (Variable): The following registers are used "^
       "undefined in procedure tagged " ^ MirTypes.print_tag start_tag ^
       ": " ^ Set.set_print (still_live, MirPrint.any_reg))

  end;
    


end (* of functor *)
@


1.20
log
@Abolished PREVIOUS_ENVIRONMENT and PRESERVE_ALL_REGS.
@
text
@d5 3
d204 2
a205 1
          if (not (MirTables.has_side_effects opcode)) andalso
@


1.19
log
@Changed diagnostic output to reflect changes in MirOptTypes.
@
text
@d5 3
a443 29

	(* PREVIOUS_ENVIRONMENT is a special case. It defines all *)
	(* registers. *)

      | process_ops {processed,
		     pending,
		     opcodes as (opcode as MirTypes.PREVIOUS_ENVIRONMENT,
				 _,
				 successors)::rest} =
	let
	  val {opcodes = processed_opcodes, processed = more_processed, ...} =
	    process_ops {processed = processed,
			 pending = pending,
			 opcodes = rest}

	  val live_before = MirTables.referenced_by opcode

	  val regs = MirOptTypes.REGS live_before

	in
	    (* Return the opcode and the processed rest of the opcodes, *)
	    (* together with any blocks which have been processed *)
	    (* incidentally. *)

	  {live = live_before,
	   opcodes = (opcode, regs, successors) :: processed_opcodes,
	   processed = more_processed}

	end
@


1.18
log
@Separated instruction elimination from live variable analysis so that
it only occurs on the _first_ pass round a loop.
@
text
@d5 4
d204 2
a205 3
                         " in context ",
                         MirOptTypes.print_registers
                         (MirOptTypes.REGS live)]);
d524 2
a525 2
                                  " are ",
                                  MirOptTypes.print_registers regs]);
@


1.17
log
@Removed the referenced registers from the MirOptTypes.REGS
as these are no longer required.
@
text
@d4 5
a8 1
$Log:	_mirvariable.sml,v $
a139 18
  (*  === USELESS INSTRUCTIONS ===
   *
   *  This function examines an instruction along with the set of
   *  registers defined by it and registers live just after it. If it
   *  defines a register which is not live then the instruction is
   *  useless. This rule only applies to instructions which have no
   *  other effect, though. It returns true if the instruction can be
   *  eliminated.
   *)

  fun useless (opcode, defined_here, live_after) =
    (not (MirTables.has_side_effects opcode))
    andalso
    (Set.seteq (Set.intersection (defined_here, live_after),
		Set.empty_set))



d179 46
a329 19
	  (* If the block is on the first pending list then *)
	  (* re-analyse it, but add it to the second list. If it is *)
	  (* not then it has never been analysed, so analyse it, but *)
	  (* add it to the first list. *)

	  val pending =
	    if Lists.member (tag, pass1) then
	    (
	      diagnostic (2, fn _ => ["second pass of block ",
				      MirTypes.print_tag tag]);
	      (pass1, tag::pass2)
	    )
	    else
	    (
	      diagnostic (2, fn _ => ["first pass of block ",
				      MirTypes.print_tag tag]);
	      (tag::pass1, pass2)
	    )

d333 30
a362 4
	    process_ops {processed = processed,
			 pending = pending,
			 opcodes = opcodes}
	    
d506 12
a517 1
	in
d519 13
a531 54
	  (* Attempt to eliminate the opcode if is does no useful *)
	  (* work. *)

	  if !Switches.eliminate_useless andalso
	    useless (opcode, defined_here, after) then
	  let
	    val regs = MirOptTypes.REGS after

	    val message =
	      "Eliminating " ^ (MirPrint.opcode opcode) ^
	      " in context " ^ (MirOptTypes.print_registers regs);

	    val comment =
	       (MirTypes.COMMENT message, regs, successors)

	    val _ = diagnostic (3, fn _ => [message])
	  in
	    {live = after,
	     opcodes = if !Switches.comment_out then
	                 comment :: processed_opcodes
		       else processed_opcodes,
 	     processed = even_more_processed}
	  end
	  else
	  let

	    (* Work out which variables are live before the opcode from *)
	    (* the above information. *)

	    val live_before =
	      Set.union (referenced_here,
			 Set.setdiff (after, defined_here))

	    (* Work out which registers were referenced by the opcode. *)
	      
	    val regs = MirOptTypes.REGS live_before
	      
	  in

	    diagnostic (4, fn _ => ["before ",
				    MirPrint.opcode opcode,
				    " are ",
				    MirOptTypes.print_registers regs]);

	    (* Return the opcode and the processed rest of the opcodes, *)
	    (* together with any blocks which have been processed *)
	    (* incidentally. *)

	    {live = live_before,
	     opcodes = (opcode, regs, successors) :: processed_opcodes,
	     processed = even_more_processed}

	  end

@


1.16
log
@Prevented the registers referenced by a block from being included
in the referenced registers of a branch to that block.
@
text
@d5 4
d416 1
a416 1
	  val regs = MirOptTypes.REGS(live_before, live_before)
d475 1
a475 1
	    val regs = MirOptTypes.REGS(after, Set.empty_set)
d504 1
a504 2
	    val regs =
	      MirOptTypes.REGS (live_before, referenced_here)
@


1.15
log
@Changed debugging output to use the Diagnostic module, which
prevents the debugging output strings being constructed even
if they aren't printed.
@
text
@d5 5
d498 1
a498 3
	    (* Work out which registers were referenced by the opcode, *)
	    (* and, if it has successors outside the block, include *)
	    (* them as well. *)
d501 1
a501 3
	      MirOptTypes.REGS (live_before,
				Set.union (referenced_here,
					   after_outside))
@


1.14
log
@Sorted out successors to avoid losing blocks referenced by cgt
@
text
@d5 3
d59 1
a80 1
  structure Print	: PRINT
d86 1
d99 1
d103 1
a103 1
  (*  === DEBUGGING INFORMATION OUTPUT ===  *)
d105 4
a108 4
  fun info message =
    if !Switches.variable_debug then
      Print.print ("MIR Optimiser (Variable): "^message^"\n")
    else ();
d228 2
a229 1
    val _ = info ("procedure " ^ (MirTypes.print_tag start_tag));
d249 1
d251 4
a254 2
      (* Try to find the block in the list of blocks already *)
      (* processed, and simply return its live registers. *)
d256 6
a261 1
      (#live (get_processed (processed, tag)), processed)
d269 3
a271 2
	  info ("block " ^ (MirTypes.print_tag tag) ^
		" third pass, no live registers assumed");
d297 2
a298 1
	      info ("block " ^ (MirTypes.print_tag tag) ^ " second pass");
d303 2
a304 1
	      info ("block " ^ (MirTypes.print_tag tag) ^ " first pass");
d475 1
a475 1
	    val _ = info message
d503 5
@


1.13
log
@Now uses Switches module to control optimisation and debugging output.
@
text
@d5 3
d327 1
a327 1
		  process_block {processed = processed,
@


1.12
log
@Switched off debugging output.
@
text
@d5 3
d63 1
d79 1
d91 1
a93 4
  val show_info = false;	(* false to disable debugging output *)
  val show_code = false;	(* false to disable listings *)
  val comment_out = false;	(* comment out rather than completely *)
				(* delete instructions *)
a94 1

d98 1
a98 1
    if show_info then
a101 4
  fun code_info message =
    if show_code then
      Print.print (message ^ "\n")
    else ();
a103 1

a298 3
	  val _ =
	    code_info (MirOptTypes.print_block (#block processed_block_record))

d443 2
a444 1
	  if useless (opcode, defined_here, after) then
d458 2
a459 1
	     opcodes = if comment_out then comment :: processed_opcodes
@


1.11
log
@Slight alterations to cope with new MirTypes.
@
text
@d5 3
d88 2
a89 2
  val show_info = true;		(* false to disable debugging output *)
  val show_code = true;		(* false to disable listings *)
@


1.10
log
@Moved tables to common MirTables module. Used records for parameters
to the process_* functions to simplify the code and facilitate later
implementation of backward copy propagation. Changed register names
for register window machines.
@
text
@d5 6
d165 1
a165 1
    fun build_procedure (start_tag, TABLE table) =
d170 1
a170 1
	MirOptTypes.make_proc (start_tag, plain_block_list)
d218 1
a218 1
  fun analyse (original_proc as MirOptTypes.PROC(start_tag, _)) =
d510 1
a510 1
      build_procedure (start_tag, processed_blocks)
@


1.9
log
@Added a missing sharing specification.
@
text
@d5 3
d45 1
d48 1
d60 1
d62 1
d68 3
a70 2
    MirPrint.MirTypes = MirRegisters.MirTypes
  sharing Set = MirOptTypes.Set = MirTypes.Set
d79 3
a81 3
  val show_info = false;	(* false to disable debugging output *)
  val show_code = false;	(* false to disable listings *)
  val comment_out = true;	(* comment out rather than completely *)
d88 3
a90 1
    if show_info then print ("MIR Optimiser (Variable): "^message) else ();
d93 3
a95 1
    if show_code then print message else ();
d106 4
a109 5
  val fn_arg_reg = MirTypes.GC MirRegisters.fn_arg;
  val cl_arg_reg = MirTypes.GC MirRegisters.cl_arg;
  val sp_reg = MirTypes.GC MirRegisters.sp;
  val fp_reg = MirTypes.GC MirRegisters.fp;
  val handler_reg = MirTypes.GC MirRegisters.handler;
d114 9
a122 1
  (*  === MISCELLANEOUS UTILITY FUNCTIONS ===  *)
d124 5
a128 1
  (*  == Find the set of registers live at the start of a block ==  *)
a129 2
  fun get_live (MirOptTypes.BLOCK(_,(_,MirOptTypes.REGS(live,_),_)::_)) =
      live
a130 5
    | get_live (MirOptTypes.BLOCK(_,(_,MirOptTypes.REGS_UNKNOWN,_)::_)) =
      Crash.impossible
      ("MirOptimiser (Variable): Somehow a block with undefined "^
       "registers has got onto the list of blocks already "^
       "processed. I'm stymied.")
d132 1
a132 9
    | get_live _ =
      Crash.impossible
      ("MirOptimiser (Variable): Somehow an empty block as got onto "^
       "the list of blocks already processed. There shouldn't even "^
       "_be_ any empty blocks! *sigh*");



  (*  === GENERATE SETS OF REGISTERS DEFINED AND REFERENCED ===
d134 4
a137 5
   *  Takes an opcode and generates the sets. It's basically a big
   *  look-up table. Some short-hand functions are used to reduce the
   *  size of the table.
   *
   *  NOTE: This table is now complete, I think.
d140 2
a141 2
  local
    open MirTypes;
d143 3
a145 2
    fun reg (GC_REG r) = [GC r]
      | reg (NON_GC_REG r) = [NON_GC r];
d147 3
a149 3
    fun gp (GP_GC_REG r) = [GC r]
      | gp (GP_NON_GC_REG r) = [NON_GC r]
      | gp _ = [];
d151 3
a153 1
    fun fp (FP_REG r) = [FLOAT r];
d155 3
a157 2
    fun out (defined_list, referenced_list) =
      (Set.list_to_set defined_list, Set.list_to_set referenced_list)
d159 7
a165 1
  in
d167 1
a167 2
    fun generate ENTER =
        out ([fn_arg_reg, cl_arg_reg, sp_reg, fp_reg, handler_reg], [])
a168 2
      | generate RTS =
	out ([], [fn_arg_reg, sp_reg, handler_reg])
a169 4
      | generate (BRANCH_AND_LINK(_,REG reg1)) =
	out ([fn_arg_reg],
	     (reg reg1) @@
	     [cl_arg_reg, fn_arg_reg, sp_reg, fp_reg, handler_reg])
a170 126
      | generate (RESTORE_REGS(regs,fps)) =
	out ((Lists.reducel op@@ ([], map reg regs)) @@
	     (Lists.reducel op@@ ([], map fp fps)),
	     [cl_arg_reg])

      | generate (PRESERVE_REGS(regs,fps)) =
	out ([],
	     [cl_arg_reg] @@
	     (Lists.reducel op@@ ([], map reg regs)) @@
	     (Lists.reducel op@@ ([], map fp fps)))

      | generate (UNARY(_,reg1,reg2)) =
        out (reg reg1, gp reg2)

      | generate (UNARYFP(_,fp1,fp2)) =
	out (fp fp1, fp fp2)

      | generate (BINARY(_,reg1,reg2,reg3)) =
	out (reg reg1, (gp reg2) @@ (gp reg3))

      | generate (BINARYFP(_,fp1,fp2,fp3)) =
	out (fp fp1, (fp fp2) @@ (fp fp3))

      | generate (TBINARY(_,_,reg1,reg2,reg3)) =
	out (reg reg1, (gp reg2) @@ (gp reg3))

      | generate (STACKOP(PUSH,reg1)) =
	out ([], reg reg1)

      | generate (STACKOP(POP,reg1)) =
	out (reg reg1, [])

      | generate (STOREOP(ST,reg1,reg2,reg3)) =
	out ([], (reg reg1) @@ (reg reg2) @@ (gp reg3))

      | generate (STOREOP(LD,reg1,reg2,reg3)) =
	out (reg reg1, (reg reg2) @@ (gp reg3))

      | generate (STOREOP(STREF,reg1,reg2,reg3)) =
	out ([], (reg reg1) @@ (reg reg2) @@ (gp reg3))

      | generate (STOREOP(LDREF,reg1,reg2,reg3)) =
	out (reg reg1, (reg reg2) @@ (gp reg3))

      | generate (STOREOP(STB,reg1,reg2,reg3)) =
	out ([], (reg reg1) @@ (reg reg2) @@ (gp reg3))

      | generate (STOREOP(LDB,reg1,reg2,reg3)) =
	out (reg reg1, (reg reg2) @@ (gp reg3))

      | generate (STOREFPOP(FST,fp1,reg2,reg3)) =
	out ([], (fp fp1) @@ (reg reg2) @@ (gp reg3))

      | generate (STOREFPOP(FLD,fp1,reg2,reg3)) =
	out (fp fp1, (reg reg2) @@ (gp reg3))

      | generate (CONVOP(ITOF,fp1,reg2)) =
	out (fp fp1, gp reg2)

      | generate (CONVOP(FTOI,fp1,reg2)) =
	out (gp reg2, fp fp1)

      | generate (BRANCH(_,REG reg1)) =
	out ([], reg reg1)

      | generate (TEST(_,_,reg1,reg2)) =
	out ([], (gp reg1) @@ (gp reg2))

      | generate (FTEST(_,_,fp1,fp2)) =
	out ([], (fp fp1) @@ (fp fp2))

      | generate (SWITCH(_,reg1,_)) =
	out ([], reg reg1)

      | generate (ALLOCATE(_,reg1,_)) =
	out (reg reg1, [])

      | generate (ADR(_,reg1,_)) =
	out (reg reg1, [])

      | generate _ =
	out ([], [])

  end;



  (*  === ELIMINATE USELESS INSTRUCTIONS ===
   *
   *  This function examines an instruction along with the set of
   *  registers defined by it and registers live just after it. If it
   *  defines a register which is not live then the instruction is
   *  useless. This rule only applies to instructions which have no
   *  other effect, though. It returns true if the instruction can be
   *  eliminated.
   *)

  fun eliminate (opcode, defined_here, live_after) =
  let
    open MirTypes;

    (* This is a list of opcodes which could be eliminated. They are *)
    (* the ones whos only effect is to generate a value in a register. *)

    fun able (TBINARY _) = true
      | able (BINARY _) = true
      | able (UNARY _) = true
      | able (BINARYFP _) = true
      | able (UNARYFP _) = true
      | able (STACKOP(POP,_)) = true
      | able (STOREOP(LD,_,_,_)) = true
      | able (STOREOP(LDB,_,_,_)) = true
      | able (STOREOP(LDREF,_,_,_)) = true
      | able (CONVOP _) = true
      | able (ALLOCATE _) = true
      | able (ADR _) = true
      | able _ = false
  in
    (able opcode)
    andalso
    (Set.seteq (Set.intersection (defined_here, live_after),
		Set.empty_set))
  end;



d218 15
a232 1
    (*  == Generate live registers for a block ==  *)
d234 1
a234 1
    fun process_block (proc_done, pending as (pass1,pass2), tag) =
d239 1
a239 1
      (get_live (MirOptTypes.get_block proc_done tag), proc_done)
d244 1
a244 1
      handle MirOptTypes.NoSuchBlock =>
d249 1
a249 1
	  (Set.empty_set, proc_done)
d283 6
a288 2
	  val (live, done_opcodes, new_proc_done) =
	    process_ops(proc_done, pending, opcodes);
d290 3
a292 1
	  val block = MirOptTypes.BLOCK(tag, done_opcodes);
d294 2
a295 1
	  val _ = code_info (MirOptTypes.print_block block)
d298 1
a298 1
	  (live, MirOptTypes.new_block new_proc_done block)
d302 8
a309 1
    (*  == Process a list of blocks and union their registers ==  *)
d311 3
a313 1
    and process_succ (proc_done, pending, MirOptTypes.SUCCS tags) =
d316 2
a317 2
	  fun p (proc_done, live, []) =
	      (live, proc_done)
d319 1
a319 1
	    | p (proc_done, live, tag::tags) =
d321 4
a324 2
		val (live', new_proc_done) =
		  process_block (proc_done, pending, tag)
d326 1
a326 1
		p (new_proc_done, Set.union(live,live'), tags)
d330 1
a330 1
	  p (proc_done, Set.empty_set, tags)
d341 18
a358 1
    (*  == Process opcodes within a block, following branches ==  *)
d360 3
a362 2
    and process_ops (proc_done, _, []) =
        (Set.empty_set, [], proc_done)
d364 4
a367 3
	(* RESTORE_REGS (without parameters) is a special case. It *)
	(* defines all registers except the argument and closure. To *)
	(* do this it references the closure. *)
d369 8
a376 4
      | process_ops (proc_done, pending,
		     (opcode as MirTypes.RESTORE_REGS([],[]),
		      _,
		      successors)::rest) =
d378 4
a381 2
	  val (live_after_in_block, done_rest, more_proc_done) =
	    process_ops (proc_done, pending, rest)
d383 1
a383 1
	  val survivors = Set.list_to_set [fn_arg_reg, cl_arg_reg, global_reg]
d385 1
a385 3
	  val live_before =
	    Set.add_member (cl_arg_reg,
			    Set.intersection (live_after_in_block, survivors))
a386 4
	  val regs =
	    MirOptTypes.REGS(live_before,
			     Set.singleton(cl_arg_reg))

d392 4
a395 3
	    (live_before,
	     (opcode, regs, successors) :: done_rest,
	     more_proc_done)
d398 2
a399 1
      | process_ops (proc_done, pending, (opcode,_,successors)::rest) =
d405 2
a406 1
	  val (defined_here, referenced_here) = generate opcode;
d408 3
a410 2
	  (* Process the rest of the opcodes in the block to find out *)
	  (* which registers are live after the opcode. *)
d412 12
a423 2
	  val (live_after_in_block, done_rest, more_proc_done) =
	    process_ops (proc_done, pending, rest);
d429 4
a432 2
	  val (live_after_outside_block, even_more_proc_done) =
	    process_succ (more_proc_done, pending, successors);
d434 1
a434 2
	  val live_after =
	    Set.union (live_after_in_block, live_after_outside_block)
d438 2
a439 1
	  (* Does the opcode do any useful work? *)
d441 1
a441 1
	  if eliminate (opcode, defined_here, live_after) then
d443 1
a443 1
	    val regs = MirOptTypes.REGS(live_after, Set.empty_set)
d445 1
a445 1
	    val s =
d449 4
a452 1
	    val _ = info s
d454 4
a457 6
	    if comment_out then
	      (live_after,
	       (MirTypes.COMMENT s, regs, successors) :: done_rest,
	       even_more_proc_done)
	    else
	      (live_after, done_rest, even_more_proc_done)
d467 1
a467 1
			 Set.setdiff (live_after, defined_here))
d476 1
a476 1
					   live_after_outside_block))
d484 3
a486 3
	    (live_before,
	     (opcode, regs, successors) :: done_rest,
	     even_more_proc_done)
d490 1
a490 1
	end;
d495 4
a498 3
    val new_empty_proc = MirOptTypes.make_proc (start_tag, []);
    val (live_at_start, processed_proc) =
      process_block (new_empty_proc, ([],[]), start_tag)
d501 11
a511 2
      
    processed_proc
@


1.8
log
@Modified to remove refereneces to real registers, which have been
expunged from MirTypes.
@
text
@d5 4
d62 1
a62 1
  sharing Set = MirOptTypes.Set
@


1.7
log
@Converted code to fill in the extra `referenced registers' field added
in revision 1.6 of MirOptTypes.
@
text
@d5 4
d90 6
a95 16
    local
      open MirTypes;
      val (fn_arg,_) = MirRegisters.fn_arg;
      val (cl_arg,_) = MirRegisters.cl_arg;
      val (sp,_) = MirRegisters.sp;
      val (fp,_) = MirRegisters.fp;
      val (handler,_) = MirRegisters.handler
      val (global,_) = MirRegisters.global
    in
      val fn_arg_reg = GC fn_arg;
      val cl_arg_reg = GC cl_arg;
      val sp_reg = GC sp;
      val fp_reg = GC fp;
      val handler_reg = GC handler;
      val global_reg = GC global
    end;
d132 2
a133 2
    fun reg (GC_REG(r,_)) = [GC r]
      | reg (NON_GC_REG(r,_)) = [NON_GC r];
d135 2
a136 2
    fun gp (GP_GC_REG(r,_)) = [GC r]
      | gp (GP_NON_GC_REG(r,_)) = [NON_GC r]
d139 1
a139 1
    fun fp (FP_REG(r,_)) = [FLOAT r];
@


1.6
log
@Added floating point operators and registers.
Modified analysis to cope with loops by doing an extra pass. Phew!
@
text
@d5 4
d93 1
d99 2
a100 1
      val handler_reg = GC handler
d109 1
a109 1
  fun get_live (MirOptTypes.BLOCK(_,(_,MirOptTypes.REGS live,_)::_)) =
d132 1
a132 1
   *  NOTE: This table is incomplete.
d156 1
a156 1
	out ([], [fn_arg_reg, sp_reg, fp_reg, handler_reg])
d159 1
a159 1
	out ([fn_arg_reg, cl_arg_reg],
d163 11
d432 3
a434 2
	(* RESTORE_REGS is a special case. It defines all registers *)
	(* except the argument and closure. *)
d437 1
a437 1
		     (opcode as MirTypes.RESTORE_REGS(_,_),
d442 1
a442 1
	    process_ops (proc_done, pending, rest);
d444 2
d447 7
a453 2
	    Set.intersection (live_after_in_block,
			      Set.list_to_set [fn_arg_reg, cl_arg_reg])
d460 1
a460 1
	     (opcode, MirOptTypes.REGS live_before, successors) :: done_rest,
d489 1
d494 1
a494 1
	    val regs = MirOptTypes.REGS live_after;
d519 9
d535 1
a535 1
	     (opcode, MirOptTypes.REGS live_before, successors) :: done_rest,
a549 8

    if Set.seteq (live_at_start, Set.empty_set) then
      ()
    else
      info ("Dataflow anomaly: The following registers were live " ^
	    "on entry to procedure " ^ (MirTypes.print_tag start_tag) ^
	    ": " ^ (MirOptTypes.print_registers
		    (MirOptTypes.REGS live_at_start)));
@


1.6.1.1
log
@This is a modified version to use the reworked MirTypes module
(ver 1.23.1.1). This module is correct, but work has been suspended
on this branch because of the amount of time it would take to convert
the code generator (Mir_Cg) module.
@
text
@a4 4
Revision 1.6  91/09/25  15:51:23  richard
Added floating point operators and registers.
Modified analysis to cope with loops by doing an extra pass. Phew!

d59 2
a60 2
  val show_info = true; 	(* false to disable debugging output *)
  val show_code = true; 	(* false to disable listings *)
d75 24
d130 1
a130 1
    open MirTypes
d132 2
a133 1
    (* Filter out non-register operands and convert to sets. *)
d135 6
d142 1
a142 10
      let
	fun is_register (GC(REG(_))) = true
	  | is_register (NON_GC(REG(_))) = true
	  | is_register (FLOAT(REG(_))) = true
	  | is_register (DOUBLE(REG(_))) = true
	  | is_register _ = false
      in
	(Set.list_to_set (Lists.filterp is_register defined_list),
	 Set.list_to_set (Lists.filterp is_register referenced_list))
      end
d147 1
a147 6
        out ([MirRegisters.fn_arg,
	      MirRegisters.cl_arg,
	      MirRegisters.sp,
	      MirRegisters.fp,
	      MirRegisters.handler],
	     [])
d150 1
a150 5
	out ([],
	     [MirRegisters.fn_arg,
	      MirRegisters.sp,
	      MirRegisters.fp,
	      MirRegisters.handler])
d152 4
a155 8
      | generate (LINK(_,_)) =
	out ([MirRegisters.fn_arg,
	      MirRegisters.cl_arg],
	     [MirRegisters.cl_arg,
	      MirRegisters.fn_arg,
	      MirRegisters.sp,
	      MirRegisters.fp,
	      MirRegisters.handler])
d157 2
a158 9
      | generate (LINK_REG(_,operand1)) =
	out ([MirRegisters.fn_arg,
	      MirRegisters.cl_arg],
	     [operand1,
	      MirRegisters.cl_arg,
	      MirRegisters.fn_arg,
	      MirRegisters.sp,
	      MirRegisters.fp,
	      MirRegisters.handler])
d160 2
a161 2
      | generate (RESTORE_REGS(operands)) =
	out (operands, [])
d163 2
a164 2
      | generate (PRESERVE_REGS(operands)) =
	out ([], operands)
d166 2
a167 2
      | generate (UNARY(_,operand1,operand2)) =
        out ([operand1], [operand2])
d169 2
a170 2
      | generate (UNARYFP(_,operand1,operand2)) =
	out ([operand1], [operand2])
d172 2
a173 2
      | generate (BINARY(_,operand1,operand2,operand3)) =
	out ([operand1], [operand2,operand3])
d175 2
a176 2
      | generate (BINARYFP(_,operand1,operand2,operand3)) =
	out ([operand1], [operand2, operand3])
d178 2
a179 2
      | generate (TBINARY(_,_,operand1,operand2,operand3)) =
	out ([operand1], [operand2, operand3])
d181 2
a182 2
      | generate (STACKOP(PUSH,operand1)) =
	out ([], [operand1])
d184 2
a185 2
      | generate (STACKOP(POP,operand1)) =
	out ([operand1], [])
d187 2
a188 2
      | generate (STOREOP(ST,operand1,operand2,operand3)) =
	out ([], [operand1, operand2, operand3])
d190 2
a191 2
      | generate (STOREOP(LD,operand1,operand2,operand3)) =
	out ([operand1], [operand2, operand3])
d193 2
a194 2
      | generate (STOREOP(STREF,operand1,operand2,operand3)) =
	out ([], [operand1, operand2, operand3])
d196 2
a197 2
      | generate (STOREOP(LDREF,operand1,operand2,operand3)) =
	out ([operand1], [operand2, operand3])
d199 2
a200 2
      | generate (STOREOP(STB,operand1,operand2,operand3)) =
	out ([], [operand1, operand2, operand3])
d202 2
a203 2
      | generate (STOREOP(LDB,operand1,operand2,operand3)) =
	out ([operand1], [operand2, operand3])
d205 2
a206 2
      | generate (STOREFPOP(FST,operand1,operand2,operand3)) =
	out ([], [operand1, operand2, operand3])
d208 2
a209 2
      | generate (STOREFPOP(FLD,operand1,operand2,operand3)) =
	out ([operand1], [operand2, operand3])
d211 2
a212 2
      | generate (CONVOP(ITOF,operand1,operand2)) =
	out ([operand1], [operand2])
d214 2
a215 2
      | generate (CONVOP(FTOI,operand1,operand2)) =
	out ([operand2], [operand1])
d217 2
a218 2
      | generate (BRANCH_REG(_,operand1)) =
	out ([], [operand1])
d220 2
a221 2
      | generate (TEST(_,_,operand1,operand2)) =
	out ([], [operand1, operand2])
d223 2
a224 2
      | generate (FTEST(_,_,operand1,operand2)) =
	out ([], [operand1, operand2])
a225 9
      | generate (SWITCH(_,operand1,_)) =
	out ([], [operand1])

      | generate (ALLOCATE(_,operand1,_)) =
	out ([operand1], [])

      | generate (ADR(_,operand1,_)) =
	out ([operand1], [])

d415 2
a416 2
	(* RESTORE_REGS (of nil) is a special case. It defines all *)
	(* registers except the argument, closure and global. *)
d419 1
a419 1
		     (opcode as MirTypes.RESTORE_REGS[],
d427 2
a428 9
	    let
	      val survivors =
		Set.list_to_set [MirRegisters.fn_arg,
				 MirRegisters.cl_arg,
				 MirRegisters.global]
	    in
	      Set.intersection (live_after_in_block, survivors)
	    end

@


1.5
log
@Modified to use a table of blocks rather than a simple list. See
MirOptTypes.
@
text
@d5 4
d59 1
a59 1
  val show_info = true;		(* false to disable debugging output *)
d61 1
a61 1
  val comment_out = false;	(* comment out rather than completely *)
d75 24
a131 14
    local
      val (fn_arg_reg,_) = MirRegisters.fn_arg;
      val (cl_arg_reg,_) = MirRegisters.cl_arg;
      val (sp_reg,_) = MirRegisters.sp;
      val (fp_reg,_) = MirRegisters.fp;
      val (handler_reg,_) = MirRegisters.handler
    in
      val fn_arg = GC fn_arg_reg;
      val cl_arg = GC cl_arg_reg;
      val sp = GC sp_reg;
      val fp = GC fp_reg;
      val handler = GC handler_reg
    end;

d139 2
d147 1
a147 1
        out ([fn_arg, cl_arg, sp, fp, handler], [])
d150 1
a150 1
	out ([], [fn_arg, fp])
d153 3
a155 2
	out ([fn_arg, cl_arg],
	     (reg reg1) @@ [cl_arg, fn_arg, sp, fp, handler])
d160 3
d166 3
d172 6
d196 12
d214 3
d276 1
a276 3
   *  executed block. Throughout processing a procedure containing the
   *  blocks processed so far is kept so that effort is not duplicated
   *  and the process terminates(!)
d278 11
d313 1
a313 1
  fun analyse (original_proc as MirOptTypes.PROC(start_tag, original_blocks)) =
d321 1
a321 3
    fun process_block (proc_done, tag) =
    (
      info ("block " ^ (MirTypes.print_tag tag));
d328 2
a329 2
      (* If that fails, then find the block in the original list of *)
      (* blocks and process it. *)
d332 8
a339 1
      let
d341 2
a342 2
	val MirOptTypes.BLOCK(_,opcodes) =
	  MirOptTypes.get_block original_proc tag
d344 8
a351 2
	val (live, done_opcodes, new_proc_done) =
	  process_ops(proc_done, opcodes);
d353 4
a356 1
	val block = MirOptTypes.BLOCK(tag, done_opcodes);
d358 11
a368 1
	val _ = code_info (MirOptTypes.print_block block)
d370 4
a373 10
      in
	(live, MirOptTypes.new_block new_proc_done block)
      end
      handle MirOptTypes.NoSuchBlock =>
        Crash.impossible
 	("MirOptimiser (Variable): process_block has been " ^
	 "passed a block tag which refers to a block which " ^
	 "is not in the current procedure. The tag was " ^
	 (MirTypes.print_tag tag) ^ ".")
    )
d375 1
d377 5
d384 1
a384 1
    and process_succ (proc_done, MirOptTypes.SUCCS tags) =
d393 1
a393 1
		  process_block (proc_done, tag)
d412 1
a412 1
    and process_ops (proc_done, []) =
d415 7
a421 1
      | process_ops (proc_done, (opcode,_,successors)::rest) =
d423 2
d426 16
d451 1
a451 1
	    process_ops (proc_done, rest);
d458 1
a458 1
	    process_succ (more_proc_done, successors);
d512 1
a512 1
      process_block (new_empty_proc, start_tag)
@


1.4
log
@Switched off debugging output.
@
text
@d5 3
d55 1
a55 1
  val show_info = false;	(* false to disable debugging output *)
a72 6
  (*  == Find block by tag ==  *)

  fun find_block (blocks,tag) =
    Lists.findp (fn (MirOptTypes.BLOCK(tag',_)) => tag=tag') blocks;


d232 3
a234 3
   *  executed block. Throughout processing a list of blocks_done is
   *  kept so that effort is not duplicated and the process
   *  terminates!
d236 1
a236 1
   *  First, process_block tries to find the block in the blocks_done.
d238 2
a239 2
   *  block, and the blocks_done. If it fails it gets the block from
   *  the original list, and calls process on its opcodes. It then
d241 1
a241 1
   *  block, and the blocks_done with the new block added.
d260 1
a260 1
  fun analyse (MirOptTypes.PROC(start_tag, original_blocks)) =
d268 1
a268 1
    fun process_block (blocks_done, tag) =
d275 1
a275 1
      (get_live (find_block (blocks_done, tag)), blocks_done)
d280 1
a280 1
      handle Lists.Find =>
d283 2
a284 7
	val MirOptTypes.BLOCK(_,opcodes) = find_block (original_blocks,tag)
	  handle Lists.Find =>
	    Crash.impossible
	    ("MirOptimiser (Variable): process_block has been " ^
	     "passed a block tag which refers to a block which " ^
	     "is not in the current procedure. The tag was " ^
	     (MirTypes.print_tag tag) ^ ".");
d286 2
a287 2
	val (live, done_opcodes, new_blocks_done) =
	  process_ops(blocks_done, opcodes);
d294 1
a294 1
	(live, block::new_blocks_done)
d296 6
d307 1
a307 1
    and process_succ (blocks_done, MirOptTypes.SUCCS tags) =
d310 2
a311 2
	  fun p (blocks_done, live, []) =
	      (live, blocks_done)
d313 1
a313 1
	    | p (blocks_done, live, tag::tags) =
d315 2
a316 2
		val (live', new_blocks_done) =
		  process_block (blocks_done, tag)
d318 1
a318 1
		p (new_blocks_done, Set.union(live,live'), tags)
d322 1
a322 1
	  p (blocks_done, Set.empty_set, tags)
d335 2
a336 2
    and process_ops (blocks_done, []) =
        (Set.empty_set, [], blocks_done)
d338 1
a338 1
      | process_ops (blocks_done, (opcode,_,successors)::rest) =
d349 2
a350 2
	  val (live_after_in_block, done_rest, more_blocks_done) =
	    process_ops (blocks_done, rest);
d356 2
a357 2
	  val (live_after_outside_block, even_more_blocks_done) =
	    process_succ (more_blocks_done, successors);
d378 1
a378 1
	       even_more_blocks_done)
d380 1
a380 1
	      (live_after, done_rest, even_more_blocks_done)
d400 1
a400 1
	     even_more_blocks_done)
a405 1
    val (live_at_start, processed_blocks) = process_block ([], start_tag)
d407 6
d423 1
a423 1
      MirOptTypes.PROC(start_tag, processed_blocks)
@


1.3
log
@Added redundant instruction elimintation. Added extra special registers
(handle, closure, etc.) to register analysis.
@
text
@d5 4
d52 1
a52 1
  val show_info = true;		(* false to disable debugging output *)
d54 1
a54 1
  val comment_out = true;	(* comment out rather than completely *)
@


1.2
log
@Finished implementing live variable analysis (without any code
modification --- that's the next stage).
@
text
@d5 4
d49 3
a51 1
  val show_code = true;		(* false to disable listings *)
d64 27
d105 4
a108 1
      val (cl_arg_reg,_) = MirRegisters.cl_arg
d111 4
a114 1
      val cl_arg = GC cl_arg_reg
d130 1
a130 1
        out ([fn_arg, cl_arg], [])
d133 1
a133 1
	out ([], [fn_arg])
d136 2
a137 1
	out ([fn_arg], (reg reg1) @@ [cl_arg, fn_arg])
d184 1
a184 1
  end
d188 9
a196 1
  (*  === MISCELLANEOUS UTILITY FUNCTIONS ===  *)
d198 3
a200 1
  (*  == Find block by tag ==  *)
d202 2
a203 2
  fun find_block (blocks,tag) =
    Lists.findp (fn (MirOptTypes.BLOCK(tag',_)) => tag=tag') blocks;
d205 19
a224 1
  (*  == Find the set of registers live at the start of a block ==  *)
a225 2
  fun get_live (MirOptTypes.BLOCK(_,(_,MirOptTypes.REGS live,_)::_)) =
      live
d227 1
a227 15
    | get_live (MirOptTypes.BLOCK(_,(_,MirOptTypes.REGS_UNKNOWN,_)::_)) =
      Crash.impossible
      ("MirOptimiser (Variable): Somehow a block with undefined "^
       "registers has got onto the list of blocks already "^
       "processed. I'm stymied.")

    | get_live _ =
      Crash.impossible
      ("MirOptimiser (Variable): Somehow an empty block as got onto "^
       "the list of blocks already processed. There shouldn't even "^
       "_be_ any empty blocks! *sigh*");



  (*  === GENERATE REGISTERS FOR A LIST OF BLOCKS ===
d258 2
a259 1
  fun process_blocks (original_blocks, tag) =
d262 1
a262 1
    val _ = info ("procedure " ^ (MirTypes.print_tag tag));
d357 2
a358 2
	  (* Work out which variables are live before the opcode from *)
	  (* the above information. *)
a359 6
	  val live_before =
	    Set.union (referenced_here,
		      Set.setdiff (Set.union (live_after_in_block,
					      live_after_outside_block),
				   defined_here))

d361 1
d363 3
a365 3
	  (* Return the opcode and the processed rest of the opcodes, *)
	  (* together with any blocks which have been processed *)
	  (* incidentally. *)
d367 3
a369 3
	  (live_before,
	   (opcode, MirOptTypes.REGS live_before, successors) :: done_rest,
	   even_more_blocks_done)
d371 31
d404 1
a405 2
    val (_, processed_blocks) = process_block ([], tag)

d408 9
a416 1
    processed_blocks
a419 8


  (*  === PERFORM LIVE VARIABLE ANALYSIS ON A PROCEDURE ===
   *
   *)

  fun analyse (MirOptTypes.PROC(start_tag, original_blocks)) =
    MirOptTypes.PROC(start_tag, process_blocks (original_blocks, start_tag));
@


1.1
log
@Initial revision
@
text
@d4 4
a7 1
$Log:$
d16 1
d26 1
d33 2
a34 1
  sharing MirTypes = MirOptTypes.MirTypes = MirPrint.MirTypes
a57 18

  (*  === FIND BLOCK BY TAG ===
   *
   *  Finds a block in a list of blocks by searching for its tag. It
   *  causes a crash if it can't find one, as the function is only
   *  used for successor (control flow) information.
   *)

  fun find_block (blocks,tag) =
    Lists.findp (fn (MirOptTypes.BLOCK(tag',_)) => tag=tag') blocks
    handle Lists.Find =>
      Crash.impossible
      ("MirOptimiser (variable): find_block has been passed a block tag "^
       "which refers to a block which is not in the current procedure. "^
       "The tag was " ^ (MirTypes.print_tag tag) ^ ".");



d61 2
a62 1
   *  look-up table.
a68 1
    open MirOptTypes;
d70 8
d86 1
a86 2
      (REGS (Set.list_to_set defined_list),
       REGS (Set.list_to_set referenced_list))
d90 10
a99 1
    fun generate (UNARY(_,reg1,reg2)) =
a131 3
      | generate (BRANCH_AND_LINK(_,REG reg1)) =
	out ([], reg reg1)

d142 1
a142 1
	(REGS Set.empty_set, REGS Set.empty_set);
d148 1
a148 6
  (*  === CALCULATE LIVE REGISTERS AT AN OPCODE ===
   *
   *  The set of live registers at an opcode is defined to be the set
   *  of registers referenced by it, union (the set of registers live
   *  after it minus the set of registers defined by it).
   *)
d150 1
a150 5
  fun live_here (MirOptTypes.REGS referenced_here,
		 MirOptTypes.REGS after,
		 MirOptTypes.REGS defined_here) =
      MirOptTypes.REGS (Set.union (referenced_here,
				   Set.setdiff (after, defined_here)))
d152 10
a161 1
    | live_here _ =
d163 3
a165 2
        ("MirOptimiser (variable): live_here was passed undefined "^
	 "registers. Something must be very very wrong.");
d167 5
d174 2
a175 1
  (*  === GENERATE VARIABLES FOR A LIST OF BLOCKS ===
d177 27
d209 5
d215 10
a224 6
    let
      val MirOptTypes.BLOCK(_,opcodes) = find_block (original_blocks,tag);
      val (done_opcodes, others) = process (blocks_done, opcodes)
    in
      MirOptTypes.BLOCK(tag, done_opcodes) :: others
    end
d226 2
a227 1
    and process (others, []) = ([], others)
d229 24
a252 1
      | process (others, (opcode,_,MirOptTypes.SUCCS successors)::rest) =
a253 2
	  val (defined_here, referenced_here) = generate opcode;
	  val (done_rest, more_others) = process (others, rest);
d255 2
a256 3
	  (* Find out what is live at the start of a list of opcodes. *)
	  fun live_at_start [] = MirOptTypes.REGS Set.empty_set
	    | live_at_start ((_,live,_)::_) = live;
d258 8
a265 2
	  val live_after = live_at_start done_rest;
	  val live = live_here(referenced_here, live_after, defined_here)
d267 1
a267 2
	  ((opcode, live, MirOptTypes.SUCCS successors)::done_rest,
	   more_others @@ others)
d270 1
a270 1
      | process _ =
d272 1
a272 1
	  ("MirOptimiser (variable): I've been given some code which has "^
d274 2
a275 1
	   "to the code before MirVariable can be used.")
d277 51
d330 1
a330 1
    process_block ([], tag)
@
