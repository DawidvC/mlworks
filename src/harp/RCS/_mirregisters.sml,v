head	1.45;
access;
symbols
	MLW_daveb_inline_1_4_99:1.45.1
	MLWorks_21c0_1999_03_25:1.45
	MLWorks_20c1_1998_08_20:1.45
	MLWorks_20c0_1998_08_04:1.45
	MLWorks_20b2c2_1998_06_19:1.45
	MLWorks_20b2_Windows_1998_06_12:1.45
	MLWorks_20b1c1_1998_05_07:1.45
	MLWorks_20b0_1998_04_07:1.45
	MLWorks_20b0_1998_03_20:1.45
	MLWorks_20m2_1998_02_16:1.44
	MLWorks_20m1_1997_10_23:1.44
	MLWorks_11r1:1.41.1.1.1.1.1
	MLWorks_workspace_97:1.44.2
	MLWorks_dt_wizard:1.44.1
	MLWorks_11c0_1997_09_09:1.41.1.1.1.1
	MLWorks_10r3:1.41.1.1.3
	MLWorks_10r2_551:1.41.1.1.2
	MLWorks_11:1.41.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.41.1.1
	MLWorks_20m0_1997_06_20:1.44
	MLWorks_1_0_r2c2_1997_06_14:1.41.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.41.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.41.1
	MLWorks_BugFix_1997_04_24:1.41
	MLWorks_1_0_r2_Win32_1997_04_11:1.41
	MLWorks_1_0_r2_Unix_1997_04_04:1.41
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.39.6.1.1
	MLWorks_gui_1996_12_18:1.39.7
	MLWorks_1_0_Win32_1996_12_17:1.39.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.39.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.39.4.1
	MLWorks_1_0_Irix_1996_11_28:1.39.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.39.5
	MLWorks_1_0_Unix_1996_11_14:1.39.4
	MLWorks_Open_Beta2_1996_10_11:1.39.3
	MLWorks_License_dev:1.39.2
	MLWorks_1_open_beta_1996_09_13:1.39.1
	MLWorks_Open_Beta_1996_08_22:1.39
	MLWorks_Beta_1996_07_02:1.39
	MLWorks_Beta_1996_06_07:1.39
	MLWorks_Beta_1996_06_06:1.39
	MLWorks_Beta_1996_06_05:1.39
	MLWorks_Beta_1996_06_03:1.39
	MLWorks_Beta_1996_05_31:1.39
	MLWorks_Beta_1996_05_30:1.39
	ML_beta_release_12/08/94:1.33
	ML_beta_release_03/08/94:1.33
	ML_revised_beta_release_25/05/94:1.29
	ML_final_beta_release_02/03/94:1.28
	mlworks-28-01-1994:1.28
	Release:1.28
	mlworks-beta-01-09-1993:1.28
	MLWorks-1-0-4-29/01/1993:1.27
	MLWorks-1-0-3-21/12/1992:1.27
	MLWorks-1-0-2-15/12/1992:1.27
	MLWorks-1-0-1-04/12/1992:1.27
	checkpoint_17_08_92:1.23;
locks; strict;
comment	@ * @;


1.45
date	98.02.19.14.49.01;	author jont;	state Exp;
branches
	1.45.1.1;
next	1.44;

1.44
date	97.05.20.17.20.53;	author jont;	state Exp;
branches
	1.44.1.1
	1.44.2.1;
next	1.43;

1.43
date	97.05.13.14.26.05;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	97.04.24.15.39.53;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	97.01.21.16.21.46;	author jont;	state Exp;
branches
	1.41.1.1;
next	1.40;

1.40
date	96.12.16.17.35.49;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	96.03.28.10.44.03;	author matthew;	state Exp;
branches
	1.39.1.1
	1.39.2.1
	1.39.3.1
	1.39.4.1
	1.39.5.1
	1.39.6.1
	1.39.7.1;
next	1.38;

1.38
date	95.12.20.12.46.13;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	95.05.30.11.55.23;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	94.10.24.11.38.03;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	94.09.29.15.53.55;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	94.08.15.10.46.37;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	94.07.26.10.40.28;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	94.07.25.11.44.27;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	94.07.15.13.46.26;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	94.07.13.10.52.15;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	94.03.04.12.33.15;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	93.08.05.10.22.47;	author richard;	state Exp;
branches
	1.28.1.1;
next	1.27;

1.27
date	92.11.02.17.28.19;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	92.10.29.17.45.20;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	92.10.05.09.42.39;	author clive;	state Exp;
branches;
next	1.24;

1.24
date	92.08.26.14.08.29;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	92.06.22.11.47.52;	author richard;	state Exp;
branches;
next	1.22;

1.22
date	92.06.08.15.00.40;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	92.06.03.16.34.50;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	92.05.27.12.13.56;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	92.04.07.10.11.09;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	92.03.31.15.09.30;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.02.27.16.14.31;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	92.02.10.10.47.11;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.01.21.12.21.57;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.01.03.16.36.11;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	91.12.04.13.09.24;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	91.11.29.11.59.47;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	91.11.21.19.49.33;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.11.14.10.41.24;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	91.11.04.15.15.51;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	91.10.16.09.28.42;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	91.10.15.15.06.42;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.10.10.12.49.17;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	91.10.09.13.49.00;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	91.10.02.11.06.20;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.10.01.14.52.23;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.09.20.13.13.53;	author jont;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	91.09.18.11.55.45;	author jont;	state Exp;
branches;
next	;

1.2.1.1
date	91.09.26.13.39.26;	author richard;	state Exp;
branches;
next	;

1.28.1.1
date	93.08.05.10.22.47;	author jont;	state Exp;
branches;
next	;

1.39.1.1
date	96.09.13.11.14.33;	author hope;	state Exp;
branches;
next	;

1.39.2.1
date	96.10.07.16.04.59;	author hope;	state Exp;
branches;
next	;

1.39.3.1
date	96.10.17.11.23.13;	author hope;	state Exp;
branches;
next	;

1.39.4.1
date	96.11.14.12.47.32;	author hope;	state Exp;
branches
	1.39.4.1.1.1;
next	;

1.39.4.1.1.1
date	96.11.28.14.59.04;	author hope;	state Exp;
branches;
next	;

1.39.5.1
date	96.11.22.18.07.36;	author hope;	state Exp;
branches;
next	;

1.39.6.1
date	96.12.17.17.46.19;	author hope;	state Exp;
branches
	1.39.6.1.1.1;
next	;

1.39.6.1.1.1
date	97.02.24.11.35.55;	author hope;	state Exp;
branches;
next	;

1.39.7.1
date	96.12.18.09.40.17;	author hope;	state Exp;
branches;
next	;

1.41.1.1
date	97.05.12.10.32.38;	author hope;	state Exp;
branches
	1.41.1.1.1.1
	1.41.1.1.2.1
	1.41.1.1.3.1;
next	;

1.41.1.1.1.1
date	97.07.28.18.18.22;	author daveb;	state Exp;
branches
	1.41.1.1.1.1.1.1;
next	;

1.41.1.1.1.1.1.1
date	97.10.07.11.43.23;	author jkbrook;	state Exp;
branches;
next	;

1.41.1.1.2.1
date	97.09.08.17.11.56;	author daveb;	state Exp;
branches;
next	;

1.41.1.1.3.1
date	97.09.09.14.07.32;	author daveb;	state Exp;
branches;
next	;

1.44.1.1
date	97.09.10.19.22.25;	author brucem;	state Exp;
branches;
next	;

1.44.2.1
date	97.09.11.20.53.39;	author daveb;	state Exp;
branches;
next	;

1.45.1.1
date	99.04.01.17.56.11;	author daveb;	state Exp;
branches;
next	;


desc
@Special code generation registers
@


1.45
log
@[Bug #30341]
Fix where type ... and syntax
@
text
@(*  ==== MIR VIRTUAL REGISTER MODEL ===
 *               FUNCTOR
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Revision Log
 *  ------------
 *  $Log: _mirregisters.sml,v $
 * Revision 1.44  1997/05/20  17:20:53  jont
 * [Bug #30076]
 * Sort out problems when caller_arg_regs and callee_arg_regs have
 * some but not all values in common
 *
 * Revision 1.43  1997/05/13  14:26:05  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
 * Revision 1.42  1997/04/24  15:39:53  jont
 * [Bug #20007]
 * Adding reserved_but_preferencable registers
 *
 * Revision 1.41  1997/01/21  16:21:46  jont
 * Add corrupted_by_alloc
 *
 * Revision 1.40  1996/12/16  17:35:49  matthew
 * Removing references to MLWorks.Option
 *
 * Revision 1.39  1996/03/28  10:44:03  matthew
 * Adding where type clause
 *
 * Revision 1.38  1995/12/20  12:46:13  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
 *  Revision 1.37  1995/05/30  11:55:23  matthew
 *  No reason?
 *
 *  Revision 1.36  1994/10/24  11:38:03  matthew
 *  Added info to "Failed to find real register" crash
 *
 *  Revision 1.35  1994/09/29  15:53:55  jont
 *  Remove handler register concept
 *
 *  Revision 1.34  1994/08/15  10:46:37  matthew
 *  Changed *_arg2 reg to *_arg_regs
 *
 *  Revision 1.33  1994/07/26  10:40:28  matthew
 *  Fix for problem with special asssigment of second arg reg.
 *
 *  Revision 1.32  1994/07/25  11:44:27  matthew
 *  Added extra argument register.
 *
 *  Revision 1.31  1994/07/15  13:46:26  jont
 *  Ensure caller_arg and callee_arg reflect machine values
 *
 *  Revision 1.30  1994/07/13  10:52:15  jont
 *  Fix to avoid lr unspilling alloc
 *
 *  Revision 1.29  1994/03/04  12:33:15  jont
 *  Changes for automatic_callee mechanism removal
 *  and moving machspec from machine to main
 *
 *  Revision 1.28  1993/08/05  10:22:47  richard
 *  Removed unnecessary defined_by_raise.
 *
 *  Revision 1.27  1992/11/02  17:28:19  jont
 *  Reworked in terms of mononewmap
 *
 *  Revision 1.26  1992/10/29  17:45:20  jont
 *  Removed some name clashes caused by open statements by remvoing the
 *  offending opens
 *
 *  Revision 1.25  1992/10/05  09:42:39  clive
 *  Change to NewMap.empty which now takes < and = functions instead of the single-function
 *
 *  Revision 1.24  1992/08/26  14:08:29  jont
 *  Removed some redundant structures and sharing
 *
 *  Revision 1.23  1992/06/22  11:47:52  richard
 *  Added defined_by_raise.
 *
 *  Revision 1.22  1992/06/08  15:00:40  richard
 *  Added allocation_order function.
 *
 *  Revision 1.21  1992/06/03  16:34:50  richard
 *  The temporary registers are now complete sets of temporaries, and
 *  are also reserved registers.
 *
 *  Revision 1.20  1992/05/27  12:13:56  richard
 *  Changed virtual register Sets to Packs.
 *  Preallocated registers are now packed small positive integers.
 *
 *  Revision 1.19  1992/04/07  10:11:09  richard
 *  MachSpec.corrupted_by_callee is now partitioned according to
 *  the register type.  This was causing naming confusion.
 *
 *  Revision 1.18  1992/03/31  15:09:30  jont
 *  Added require newmap
 *
 *  Revision 1.17  1992/02/27  16:14:31  richard
 *  Changed the way virtual registers are handled.  See MirTypes.
 *
 *  Revision 1.16  1992/02/10  10:47:11  richard
 *  Large scale reorganization, including addition of `reserved' and
 *  change of type of `corrupted_by_callee'.
 *
 *  Revision 1.15  1992/01/21  12:21:57  clive
 *  Added implicit
 *
 *  Revision 1.14  1992/01/03  16:36:11  richard
 *  Added the zero register, if present on the target machine.
 *
 *  Revision 1.13  1991/12/04  13:09:24  richard
 *  Added ordered_general_purpose, but didn't implement it.
 *  (It is initialized as empty at the moment.)
 *
 *  Revision 1.12  91/11/29  11:59:47  richard
 *  Corrected the definition of general_purpose and removed the
 *  useless definition of machine_register_aliases.
 *
 *  Revision 1.11  91/11/21  19:49:33  jont
 *  Added some brackets to keep njml 0.75 happy
 *
 *  Revision 1.10  91/11/14  10:41:24  richard
 *  Removed references to fp_double registers.
 *
 *  Revision 1.9  91/11/04  15:15:51  richard
 *  Added general_purpose.
 *
 *  Revision 1.8  91/10/16  09:28:42  richard
 *  Recommented, and added corrupted_by_callee.
 *
 *  Revision 1.7  91/10/15  15:06:42  richard
 *  Moved register assignments here from the register allocator functor.
 *
 *  Revision 1.6  91/10/10  12:49:17  richard
 *  Fixed defined_on_entry and defined_on_exit to mention callee rather
 *  than caller registers on machines with register windows.
 *
 *  Revision 1.5  91/10/09  13:49:00  richard
 *  Added various new register definitions.
 *
 *  Revision 1.4  91/10/02  11:06:20  jont
 *  Removed real register options, these are being done elsewhere
 *
 *  Revision 1.3  91/10/01  14:52:23  richard
 *  Added global register.
 *
 *  Revision 1.2  91/09/20  13:13:53  jont
 *  Removed temp_sp, not required
 *
 *  Revision 1.1  91/09/18  11:55:45  jont
 *  Initial revision
 *)

require "../utils/crash";
require "../utils/lists";
require "../main/machspec";
require "mirtypes";
require "mirregisters";


functor MirRegisters(

  structure MirTypes	: MIRTYPES where type GC.T = int where type NonGC.T = int where type FP.T = int
  structure MachSpec	: MACHSPEC
  structure Lists	: LISTS
  structure Crash	: CRASH

) : MIRREGISTERS =

  struct

    structure MirTypes = MirTypes
    structure MachSpec = MachSpec
    structure Set = MachSpec.Set

    fun crash message = Crash.impossible ("MirRegisters: " ^ message)


    fun ++r = let val n = !r in r:=n+1; n end

    val next_gc     = ref 0
    val next_non_gc = ref 0
    val next_fp     = ref 0

    fun new_gc ()     = (++next_gc)
    fun new_non_gc () = (++next_non_gc)
    fun new_fp ()     = (++next_fp)


    (*  === SPECIAL PURPOSE REGISTERS ===
     *
     *  These are simply assigned uniques here, and included in
     *  preassigned (see below) to ensure that they are mapped on to
     *  the correct real machine registers.
     *)

    val caller_equal_callee = MachSpec.caller_arg_regs = MachSpec.callee_arg_regs

    val caller_arg_regs = map (fn _ => new_gc ()) MachSpec.caller_arg_regs

    val caller_arg =
      case caller_arg_regs of
        (r::_) => r
      | _ => Crash.impossible "No caller arg reg"

    val callee_arg_regs =
      if caller_equal_callee then
	caller_arg_regs
      else
	let
	  fun assoc([], el) = NONE
	    | assoc((x, y) :: rest, el) =
	    if y = el then SOME x else assoc(rest, el)
	  val callee_arg_regs =
	    map
	    (fn _ => new_gc ())
	    MachSpec.callee_arg_regs
	  val assoc1 = Lists.zip(caller_arg_regs, MachSpec.caller_arg_regs)
	  val assoc2 = Lists.zip(callee_arg_regs, MachSpec.callee_arg_regs)
	  val callee_arg_regs =
	    map
	    (fn reg =>
	     case assoc(assoc1, reg) of
	       SOME x => x
	     | NONE =>
		 case assoc(assoc2, reg) of
		   SOME x => x
		 | NONE => Crash.impossible"MirRegisters: assoc")
	    MachSpec.callee_arg_regs
	in
	  callee_arg_regs
	end

    val callee_arg =
      case callee_arg_regs of
        (r::_) => r
      | _ => Crash.impossible "No callee arg reg"

    val fp_arg_regs = map (fn _ => new_fp ()) MachSpec.fp_arg_regs
    val caller_closure = 	new_gc ()
    val callee_closure = 	new_gc ()
    val fp = 			new_gc ()
    val sp = 			new_gc ()
    val global = 		new_gc ()
    val fp_global = 		new_fp ()
    val implicit =              new_gc ()

    val zero_virtual =		new_gc ()
    val zero =
      case MachSpec.zero
        of SOME _ => SOME zero_virtual
         | NONE => NONE

    (* Now set up tail_arg and tail_closure *)
    val tail_arg_regs =
      if MachSpec.tail_arg = MachSpec.callee_arg
        then callee_arg_regs
      else
        caller_arg_regs

    val tail_arg =
      case tail_arg_regs of
        (r::_) => r
      | _ => Crash.impossible "No tail arg reg"

    val tail_closure =
      if MachSpec.tail_closure = MachSpec.callee_closure then
	callee_closure
      else
	caller_closure

    (* These association lists define the real registers onto which the *)
    (* special purpose registers will map. *)

    val special_assignments =
      let
	val callers = Lists.zip (caller_arg_regs, MachSpec.caller_arg_regs)
	val callees = Lists.zip (callee_arg_regs, MachSpec.callee_arg_regs)
	val callees = Lists.difference(callees, callers)
      in
	{gc = callers @@
	 callees @@
	 [(caller_closure, MachSpec.caller_closure),
	  (callee_closure, MachSpec.callee_closure),
	  (fp, MachSpec.fp),
	  (sp, MachSpec.sp),
	  (global, MachSpec.global),
	  (implicit,MachSpec.implicit)] @@
	 (case MachSpec.zero
	    of SOME zero_real => [(zero_virtual, zero_real)]
	  | NONE            => []),
	 non_gc = [],
	 fp = Lists.zip (fp_global :: fp_arg_regs, MachSpec.fp_global :: MachSpec.fp_arg_regs)}
      end

    (*  === REAL REGISTER ASSIGNMENTS ===  *)

    (* Generate association lists relating MIR virtual registers to real *)
    (* registers.  Note that the special purpose registers are mapped to *)
    (* their special purpose real-register counterparts.  Other registers *)
    (* are simply generated uniques. *)

    (* Ensure that we don't reassign anything that has already been given *)
    (* a special assignment *)

    val assignments =
      {gc     = (#gc special_assignments) @@
                (map (fn r => (new_gc (), r))
                 (Lists.difference (MachSpec.gcs,map #2 (#gc special_assignments)))),
       non_gc = (#non_gc special_assignments) @@
                (map (fn r => (new_non_gc (), r))
                 (Lists.difference (MachSpec.non_gcs,map #2 (#non_gc special_assignments)))),
       fp =     (#fp special_assignments) @@
                (map (fn r => (new_fp (), r))
                 (Lists.difference (MachSpec.fps,map #2 (#fp special_assignments))))}

    val preassigned =
      {gc     = MirTypes.GC.Pack.from_list    (map (fn(v,r)=>v) (#gc assignments)),
       non_gc = MirTypes.NonGC.Pack.from_list (map (fn(v,r)=>v) (#non_gc assignments)),
       fp     = MirTypes.FP.Pack.from_list    (map (fn(v,r)=>v) (#fp assignments))}


    (* Build the exported tables from the association lists. *)

(*
    val _ =
      Lists.iterate
      (fn (v, r) =>
       print(MirTypes.GC.to_string v ^ " maps to " ^ MachSpec.print_register r ^ "\n"))
      (#gc assignments)
*)

    val gc_assignments = MirTypes.GC.Map.from_list (#gc assignments)
    val non_gc_assignments = MirTypes.NonGC.Map.from_list (#non_gc assignments)
    val fp_assignments = MirTypes.FP.Map.from_list (#fp assignments)

    val machine_register_assignments =
      {gc     = gc_assignments,
       non_gc = non_gc_assignments,
       fp     = fp_assignments}

    val machine_to_virtual =
      let
	fun rassoc list real =
	  let
	    fun find [] = crash ("Failed to find virtual register for " ^ MachSpec.print_register real)
	      | find ((virtual, real')::rest) = if real = real' then virtual else find rest
	  in
	    find list
	  end
      in
	{gc     = rassoc (#gc assignments),
	 non_gc = rassoc (#non_gc assignments),
	 fp     = rassoc (#fp assignments)}
      end

    local
      fun separate (convert, reserved, registers) =
        let
          fun separate' (g, []) = convert g
            | separate' (g, (virtual,real) ::rest) =
              if Set.is_member (real,reserved) then
                separate' (g, rest)
              else
                separate' (virtual::g, rest)
        in
          separate' ([], registers)
        end

      val gc_general =
        separate (MirTypes.GC.Pack.from_list, #gc MachSpec.reserved, #gc assignments)

      val non_gc_general =
        separate (MirTypes.NonGC.Pack.from_list, #non_gc MachSpec.reserved, #non_gc assignments)

      val fp_general =
        separate (MirTypes.FP.Pack.from_list, #fp MachSpec.reserved, #fp assignments)

      val debugging_gc_general =
        separate (MirTypes.GC.Pack.from_list, #gc MachSpec.debugging_reserved, #gc assignments)

      val debugging_non_gc_general =
        separate (MirTypes.NonGC.Pack.from_list, #non_gc MachSpec.debugging_reserved, #non_gc assignments)

      val debugging_fp_general =
        separate (MirTypes.FP.Pack.from_list, #fp MachSpec.debugging_reserved, #fp assignments)
      val gc_general_for_preferencing =
        MirTypes.GC.Pack.from_list(map (#gc machine_to_virtual) (#gc MachSpec.reserved_but_preferencable))

      val non_gc_general_for_preferencing =
	MirTypes.NonGC.Pack.from_list(map (#non_gc machine_to_virtual) (#non_gc MachSpec.reserved_but_preferencable))

      val fp_general_for_preferencing =
        MirTypes.FP.Pack.from_list(map (#fp machine_to_virtual) (#fp MachSpec.reserved_but_preferencable))

      val debugging_gc_general_for_preferencing =
        MirTypes.GC.Pack.from_list(map (#gc machine_to_virtual) (#gc MachSpec.debugging_reserved_but_preferencable))

      val debugging_non_gc_general_for_preferencing =
        MirTypes.NonGC.Pack.from_list(map (#non_gc machine_to_virtual) (#non_gc MachSpec.debugging_reserved_but_preferencable))

      val debugging_fp_general_for_preferencing =
        MirTypes.FP.Pack.from_list(map (#fp machine_to_virtual) (#fp MachSpec.debugging_reserved_but_preferencable))
    in

      val general_purpose = {gc     = gc_general,
                             non_gc = non_gc_general,
                             fp     = fp_general}

      val debugging_general_purpose =
        {gc     = debugging_gc_general,
         non_gc = debugging_non_gc_general,
         fp     = debugging_fp_general}

      val gp_for_preferencing =
	{gc     = gc_general_for_preferencing,
	 non_gc = non_gc_general_for_preferencing,
	 fp     = fp_general_for_preferencing}

      val debugging_gp_for_preferencing =
        {gc     = debugging_gc_general_for_preferencing,
         non_gc = debugging_non_gc_general_for_preferencing,
         fp     = debugging_fp_general_for_preferencing}
    end

    local
      val gc     = MirTypes.GC.Map.apply gc_assignments
      val non_gc = MirTypes.NonGC.Map.apply non_gc_assignments
      val fp     = MirTypes.FP.Map.apply fp_assignments
      val {gc = gc_order, non_gc = non_gc_order, fp = fp_order} = MachSpec.allocation_order
    in
      val allocation_order =
        {gc     = fn (r,r') => gc_order (gc r, gc r'),
         non_gc = fn (r,r') => non_gc_order (non_gc r, non_gc r'),
         fp     = fn (r,r') => fp_order (fp r, fp r')}
    end

    local
      val gc     = MirTypes.GC.Map.apply gc_assignments
      val non_gc = MirTypes.NonGC.Map.apply non_gc_assignments
      val fp     = MirTypes.FP.Map.apply fp_assignments
      val {gc = gc_equal, non_gc = non_gc_equal, fp = fp_equal} = MachSpec.allocation_equal
    in
      val allocation_equal =
        {gc     = fn (r,r') => gc_equal (gc r, gc r'),
         non_gc = fn (r,r') => non_gc_equal (non_gc r, non_gc r'),
         fp     = fn (r,r') => fp_equal (fp r, fp r')}
    end

    (* The machine registers which are corrupted by the callee are *)
    (* defined in MachSpec. Filter out the aliases which map to them. *)

    local
      fun corrupt set (done, []) = done
	| corrupt set (done, (virtual, real)::rest) =
	if Set.is_member (real, set) then
	  corrupt set (virtual::done, rest)
	else
	  corrupt set (done, rest)
    in
      val corrupted_by_callee =
        {gc =
	 MirTypes.GC.Pack.from_list
	 (corrupt (#gc MachSpec.corrupted_by_callee) ([], #gc assignments)),
         non_gc =
	 MirTypes.NonGC.Pack.from_list
	 (corrupt (#non_gc MachSpec.corrupted_by_callee) ([], #non_gc assignments)),
         fp =
	 MirTypes.FP.Pack.from_list
	 (corrupt (#fp MachSpec.corrupted_by_callee) ([], #fp assignments))}
      val corrupted_by_alloc =
        {gc =
	 MirTypes.GC.Pack.from_list
	 (corrupt (#gc MachSpec.corrupted_by_alloc) ([], #gc assignments)),
         non_gc =
	 MirTypes.NonGC.Pack.from_list
	 (corrupt (#non_gc MachSpec.corrupted_by_alloc) ([], #non_gc assignments)),
         fp =
	 MirTypes.FP.Pack.from_list
	 (corrupt (#fp MachSpec.corrupted_by_alloc) ([], #fp assignments))}
      val referenced_by_alloc =
        {gc =
	 MirTypes.GC.Pack.from_list
	 (corrupt (#gc MachSpec.referenced_by_alloc) ([], #gc assignments)),
         non_gc =
	 MirTypes.NonGC.Pack.from_list
	 (corrupt (#non_gc MachSpec.referenced_by_alloc) ([], #non_gc assignments)),
         fp =
	 MirTypes.FP.Pack.from_list
	 (corrupt (#fp MachSpec.referenced_by_alloc) ([], #fp assignments))}
    end


    (* The machine registers for temporary use are defined in MachSpec. *)
    (* Filter out the aliases which map to them. *)

    val temporary =
      {gc     =    (map (#gc     machine_to_virtual) (#gc     MachSpec.temporary)),
       non_gc =    (map (#non_gc machine_to_virtual) (#non_gc MachSpec.temporary)),
       fp     =    (map (#fp     machine_to_virtual) (#fp     MachSpec.temporary))}

    (* On entry to a procedure the argument and closure are assumed to be *)
    (* passed by the caller, and the fp, and sp registers are *)
    (* required by the call mechanism. *)

    val defined_on_entry =
      {gc =
         MirTypes.GC.Pack.from_list
         ((callee_closure :: map (#gc     machine_to_virtual) (Set.set_to_list(#gc MachSpec.defined_on_entry))) @@
           (case zero
              of SOME virtual_zero => [virtual_zero]
               | NONE => []) @@
           [fp, sp, implicit]),
       non_gc = MirTypes.NonGC.Pack.empty,
       fp = MirTypes.FP.Pack.empty}


    (* On exit from a procedure the argument contains the return value for *)
    (* the caller, and the fp and sp registers must contain the *)
    (* same values as they did on entry. *)

    val defined_on_exit =
      {gc =
         MirTypes.GC.Pack.from_list
         ((callee_arg) ::
           [fp, sp, implicit]),
       non_gc = MirTypes.NonGC.Pack.empty,
       fp = MirTypes.FP.Pack.empty}

    val pack_next = {gc = !next_gc,
                     non_gc = !next_non_gc,
                     fp = !next_fp}

  end
@


1.45.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a8 4
 * Revision 1.45  1998/02/19  14:49:01  jont
 * [Bug #30341]
 * Fix where type ... and syntax
 *
@


1.44
log
@[Bug #30076]
Sort out problems when caller_arg_regs and callee_arg_regs have
some but not all values in common
@
text
@d9 5
d165 1
a165 1
  structure MirTypes	: MIRTYPES where type GC.T = int and NonGC.T = int and FP.T = int
@


1.44.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a8 5
 * Revision 1.44  1997/05/20  17:20:53  jont
 * [Bug #30076]
 * Sort out problems when caller_arg_regs and callee_arg_regs have
 * some but not all values in common
 *
@


1.44.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a8 5
 * Revision 1.44  1997/05/20  17:20:53  jont
 * [Bug #30076]
 * Sort out problems when caller_arg_regs and callee_arg_regs have
 * some but not all values in common
 *
@


1.43
log
@[Bug #20038]
Add referenced_by_alloc
@
text
@d9 4
d115 1
a115 1
 *  
d118 1
a118 1
 *  
d121 1
a121 1
 *  
d124 1
a124 1
 *  
d127 1
a127 1
 *  
d130 1
a130 1
 *  
d134 1
a134 1
 *  
d137 1
a137 1
 *  
d140 1
a140 1
 *  
d143 1
a143 1
 *  
d146 1
a146 1
 *  
d203 27
a229 5
    val callee_arg_regs = 
      if caller_equal_callee 
        then caller_arg_regs
      else 
        map (fn _ => new_gc ()) MachSpec.callee_arg_regs
d252 1
a252 1
    val tail_arg_regs = 
d255 1
a255 1
      else 
d273 19
a291 14
      {gc = Lists.zip (caller_arg_regs, MachSpec.caller_arg_regs) @@
            Lists.zip (callee_arg_regs, MachSpec.callee_arg_regs) @@
            [(caller_closure, MachSpec.caller_closure),
             (callee_closure, MachSpec.callee_closure),
             (fp, MachSpec.fp),
             (sp, MachSpec.sp),
             (global, MachSpec.global),
             (implicit,MachSpec.implicit)] @@
            (case MachSpec.zero
               of SOME zero_real => [(zero_virtual, zero_real)]
                | NONE            => []),
       non_gc = [],
       fp = Lists.zip (fp_global :: fp_arg_regs, MachSpec.fp_global :: MachSpec.fp_arg_regs)}

d311 1
a311 1
                (map (fn r => (new_fp (), r)) 
d322 8
d407 1
a407 1
      val debugging_general_purpose = 
d417 1
a417 1
      val debugging_gp_for_preferencing = 
d489 1
a489 1
    
d498 1
a498 1
    
@


1.42
log
@[Bug #20007]
[Bug #20007]
Adding reserved_but_preferencable registers
@
text
@d9 4
d439 10
d467 1
a467 1
         ([callee_closure] @@
@


1.41
log
@Add corrupted_by_alloc
@
text
@d9 3
d212 1
d255 1
a255 1
       fp = Lists.zip (fp_arg_regs, MachSpec.fp_arg_regs)}
d300 1
a300 1
	    fun find [] = crash ("Failed to find real register for " ^ MachSpec.print_register real)
d341 17
d368 10
@


1.41.1.1
log
@branched from 1.41
@
text
@a8 3
 * Revision 1.41  1997/01/21  16:21:46  jont
 * Add corrupted_by_alloc
 *
@


1.41.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a8 3
 * Revision 1.41.1.1  1997/05/12  10:32:38  hope
 * branched from 1.41
 *
@


1.41.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a8 3
 * Revision 1.41.1.1  1997/05/12  10:32:38  hope
 * branched from 1.41
 *
@


1.41.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a8 3
 * Revision 1.41.1.1  1997/05/12  10:32:38  hope
 * branched from 1.41
 *
@


1.41.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a8 3
 * Revision 1.41.1.1.1.1  1997/07/28  18:18:22  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.40
log
@Removing references to MLWorks.Option
@
text
@d9 3
a139 1

d376 19
a394 9
    val corrupted_by_callee =
      let
        fun corrupt set (done, []) = done
          | corrupt set (done, (virtual, real)::rest) =
            if Set.is_member (real, set) then
              corrupt set (virtual::done, rest)
            else
              corrupt set (done, rest)
      in
d396 2
a397 2
           MirTypes.GC.Pack.from_list
           (corrupt (#gc MachSpec.corrupted_by_callee) ([], #gc assignments)),
d399 2
a400 2
           MirTypes.NonGC.Pack.from_list
           (corrupt (#non_gc MachSpec.corrupted_by_callee) ([], #non_gc assignments)),
d402 3
a404 3
           MirTypes.FP.Pack.from_list
           (corrupt (#fp MachSpec.corrupted_by_callee) ([], #fp assignments))}
      end
@


1.39
log
@Adding where type clause
@
text
@d9 3
d200 2
a201 1
        
d212 2
a213 2
        of MLWorks.Option.SOME _ => MLWorks.Option.SOME zero_virtual
         | MLWorks.Option.NONE => MLWorks.Option.NONE
d246 2
a247 2
               of MLWorks.Option.SOME zero_real => [(zero_virtual, zero_real)]
                | MLWorks.Option.NONE            => []),
d249 1
a249 1
       fp = []}
d259 3
d264 2
a265 1
                (map (fn r => (new_gc (), r)) MachSpec.gcs),
d267 2
a268 1
                (map (fn r => (new_non_gc (), r)) MachSpec.non_gcs),
d270 2
a271 1
                (map (fn r => (new_fp (), r)) MachSpec.fps)}
d412 2
a413 2
              of MLWorks.Option.SOME virtual_zero => [virtual_zero]
               | MLWorks.Option.NONE => []) @@
@


1.39.7.1
log
@branched from 1.39
@
text
@a8 3
 * Revision 1.39  1996/03/28  10:44:03  matthew
 * Adding where type clause
 *
@


1.39.6.1
log
@branched from 1.39
@
text
@a8 3
 * Revision 1.39  1996/03/28  10:44:03  matthew
 * Adding where type clause
 *
@


1.39.6.1.1.1
log
@branched from 1.39.6.1
@
text
@a8 3
 * Revision 1.39.6.1  1996/12/17  17:46:19  hope
 * branched from 1.39
 *
@


1.39.5.1
log
@branched from 1.39
@
text
@a8 3
 * Revision 1.39  1996/03/28  10:44:03  matthew
 * Adding where type clause
 *
@


1.39.4.1
log
@branched from 1.39
@
text
@a8 3
 * Revision 1.39  1996/03/28  10:44:03  matthew
 * Adding where type clause
 *
@


1.39.4.1.1.1
log
@branched from 1.39.4.1
@
text
@a8 3
 * Revision 1.39.4.1  1996/11/14  12:47:32  hope
 * branched from 1.39
 *
@


1.39.3.1
log
@branched from 1.39
@
text
@a8 3
 * Revision 1.39  1996/03/28  10:44:03  matthew
 * Adding where type clause
 *
@


1.39.2.1
log
@branched from 1.39
@
text
@a8 3
 * Revision 1.39  1996/03/28  10:44:03  matthew
 * Adding where type clause
 *
@


1.39.1.1
log
@branched from 1.39
@
text
@a8 3
 * Revision 1.39  1996/03/28  10:44:03  matthew
 * Adding where type clause
 *
@


1.38
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d9 4
d144 1
a144 1
  structure MirTypes	: MIRTYPES
a147 2

  sharing type MirTypes.GC.T = MirTypes.NonGC.T = MirTypes.FP.T = int
@


1.37
log
@No reason?
@
text
@d9 3
a145 1
  sharing MirTypes.Option = MachSpec.Option
a153 1
    structure Option = MachSpec.Option
d206 2
a207 2
        of Option.PRESENT _ => Option.PRESENT zero_virtual
         | Option.ABSENT => Option.ABSENT
d240 2
a241 2
               of Option.PRESENT zero_real => [(zero_virtual, zero_real)]
                | Option.ABSENT            => []),
d400 2
a401 2
              of Option.PRESENT virtual_zero => [virtual_zero]
               | Option.ABSENT => []) @@
@


1.36
log
@Added info to "Failed to find real register" crash
@
text
@d9 3
a219 7
(*
    val tail_arg =
      if MachSpec.tail_arg = MachSpec.callee_arg then
	callee_arg
      else
	caller_arg
*)
d295 4
a298 5
          fun separate' ((g, r), []) =
              (convert g, convert r)
            | separate' ((g, r), (virtual, real)::rest) =
              if Set.is_member (real, reserved) then
                separate' ((g, virtual::r), rest)
d300 1
a300 1
                separate' ((virtual::g, r), rest)
d302 1
a302 1
          separate' (([], []), registers)
d305 1
a305 1
      val (gc_general, gc_reserved) =
d308 1
a308 1
      val (non_gc_general, non_gc_reserved) =
d311 1
a311 1
      val (fp_general, fp_reserved) =
d313 9
d328 4
a331 4
      val reserved = {gc     = gc_reserved,
                      non_gc = non_gc_reserved,
                      fp     = fp_reserved}

@


1.35
log
@Remove handler register concept
@
text
@d9 3
d285 1
a285 1
	    fun find [] = crash "Failed to find real register"
@


1.34
log
@Changed *_arg2 reg to *_arg_regs
@
text
@d9 3
a192 1
    val handler = 		new_gc ()
a236 1
             (handler, MachSpec.handler),
d384 1
a384 1
    (* passed by the caller, and the fp, sp, and handler registers are *)
d394 1
a394 1
           [fp, sp, handler,implicit]),
d400 1
a400 1
    (* the caller, and the fp, sp, and handler registers must contain the *)
d407 1
a407 1
           [fp, sp, handler,implicit]),
@


1.33
log
@Fix for problem with special asssigment of second arg reg.
@
text
@d9 3
d133 2
d154 3
a156 3
    fun new_gc ()     = MirTypes.GC.pack    (++next_gc)
    fun new_non_gc () = MirTypes.NonGC.pack (++next_non_gc)
    fun new_fp ()     = MirTypes.FP.pack    (++next_fp)
d166 15
a180 1
    val caller_arg = 		new_gc ()
d182 3
a184 4
      if MachSpec.caller_arg = MachSpec.callee_arg then
	caller_arg
      else
	new_gc ()
a185 6
    val caller_arg2 = 		new_gc ()
    val callee_arg2 =
      if MachSpec.caller_arg2 = MachSpec.callee_arg2 then
        caller_arg2
      else new_gc ()

d201 12
d218 1
a218 8

    (* Now set up tail_arg and tail_closure *)
    val tail_arg2 =
      if MachSpec.tail_arg2 = MachSpec.callee_arg2 then
	callee_arg2
      else
	caller_arg2

a227 1
    (* Don't confuse the allocator with the extra arguments just yet *)
d229 3
a231 3
      {gc = [(caller_arg, MachSpec.caller_arg),
             (* (caller_arg2, MachSpec.caller_arg2), *)
             (caller_closure, MachSpec.caller_closure),
a232 2
             (callee_arg, MachSpec.callee_arg),
             (* (callee_arg2, MachSpec.callee_arg2), *)
d269 1
a269 2
    val non_gc_assignments =
      MirTypes.NonGC.Map.from_list (#non_gc assignments)
d389 1
a389 1
         ([callee_arg, callee_closure] @@
@


1.32
log
@Added extra argument register.
@
text
@d9 3
d211 1
d214 1
a214 1
             (caller_arg2, MachSpec.caller_arg2),
d216 3
d223 1
a223 4
             (implicit,MachSpec.implicit),
             (callee_closure, MachSpec.callee_closure),
             (callee_arg, MachSpec.callee_arg),
             (callee_arg2, MachSpec.callee_arg2)] @@
@


1.31
log
@Ensure caller_arg and callee_arg reflect machine values
@
text
@d9 3
d164 7
d192 7
d210 1
d216 4
a219 3
             (implicit,MachSpec.implicit)] @@
            ([(callee_closure, MachSpec.callee_closure),
                (callee_arg, MachSpec.callee_arg)]) @@
@


1.30
log
@Fix to avoid lr unspilling alloc
@
text
@d9 3
d156 5
a160 1
    val callee_arg = 		new_gc ()
@


1.29
log
@Changes for automatic_callee mechanism removal
and moving machspec from machine to main
@
text
@d9 4
d335 3
a337 3
      {gc     = MirTypes.GC.Pack.from_list    (map (#gc     machine_to_virtual) (#gc     MachSpec.temporary)),
       non_gc = MirTypes.NonGC.Pack.from_list (map (#non_gc machine_to_virtual) (#non_gc MachSpec.temporary)),
       fp     = MirTypes.FP.Pack.from_list    (map (#fp     machine_to_virtual) (#fp     MachSpec.temporary))}
a338 1

@


1.28
log
@Removed unnecessary defined_by_raise.
@
text
@d9 3
d105 1
a105 1
require "../machine/machspec";
d164 12
a175 8

    (* If the caller argument and callee argument are the same on the *)
    (* machine then it is assumed that they won't be moved from one to the *)
    (* other. *)

    val automatic_callee =
      not (MachSpec.caller_arg = MachSpec.callee_arg)

d188 2
a189 4
            (if automatic_callee then
               [(callee_closure, MachSpec.callee_closure),
                (callee_arg, MachSpec.callee_arg)]
             else []) @@
d343 1
a343 4
         ((if automatic_callee then
             [callee_arg, callee_closure]
           else
             [caller_arg, caller_closure]) @@
d359 1
a359 4
         ((if automatic_callee then
             callee_arg
           else
             caller_arg) ::
@


1.28.1.1
log
@Fork for bug fixing
@
text
@a8 3
 *  Revision 1.28  1993/08/05  10:22:47  richard
 *  Removed unnecessary defined_by_raise.
 *
@


1.27
log
@Reworked in terms of mononewmap
@
text
@d9 3
a363 8

    (* The raise code is like a function call, returning its result in the *)
    (* caller argument. *)

    val defined_by_raise =
      {gc = MirTypes.GC.Pack.add (#gc corrupted_by_callee, caller_arg),
       non_gc = #non_gc corrupted_by_callee,
       fp = #fp corrupted_by_callee}
@


1.26
log
@Removed some name clashes caused by open statements by remvoing the
offending opens
@
text
@d9 4
a118 1
    structure Map = MirTypes.Debugger_Types.Datatypes.NewMap
d212 1
a212 1
    val gc_assignments = Map.from_list' MirTypes.GC.order (#gc assignments)
d214 2
a215 2
      Map.from_list' MirTypes.NonGC.order (#non_gc assignments)
    val fp_assignments = Map.from_list' MirTypes.FP.order (#fp assignments)
d272 3
a274 3
      val gc     = Map.apply gc_assignments
      val non_gc = Map.apply non_gc_assignments
      val fp     = Map.apply fp_assignments
d284 3
a286 3
      val gc     = Map.apply gc_assignments
      val non_gc = Map.apply non_gc_assignments
      val fp     = Map.apply fp_assignments
@


1.25
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d9 3
d209 4
a212 6
    local
      open MirTypes
    in
      val gc_assignments = Map.from_list' GC.order (#gc assignments)
      val non_gc_assignments = Map.from_list' NonGC.order (#non_gc assignments)
      val fp_assignments = Map.from_list' FP.order (#fp assignments)
d214 4
a217 4
      val machine_register_assignments =
	{gc     = gc_assignments,
	 non_gc = non_gc_assignments,
	 fp     = fp_assignments}
d219 14
a232 16
      val machine_to_virtual =
        let
          fun rassoc list real =
            let
              fun find [] = crash "Failed to find real register"
                | find ((virtual, real')::rest) = if real = real' then virtual else find rest
            in
              find list
            end
        in
          {gc     = rassoc (#gc assignments),
           non_gc = rassoc (#non_gc assignments),
           fp     = rassoc (#fp assignments)}
        end
    end

@


1.24
log
@Removed some redundant structures and sharing
@
text
@d9 3
a269 6
      structure S : sig datatype relation = LESS | EQUAL | GREATER end = MachSpec
    in
      open S
    end

    local
d281 11
@


1.23
log
@Added defined_by_raise.
@
text
@d9 3
a86 1
require "../utils/set";
a87 1
require "../utils/table";
a88 2
require "../utils/newmap";
require "../utils/option";
a97 2
  structure Set		: SET
  structure Map		: NEWMAP
a99 1
  structure Option	: OPTION
a100 2
  sharing MachSpec.Set = Set
  sharing Option = MachSpec.Option
a106 1
    structure Set = Set
d108 3
a110 2
    structure Map = Map
    structure Option = Option
@


1.22
log
@Added allocation_order function.
@
text
@d9 3
d358 7
@


1.21
log
@The temporary registers are now complete sets of temporaries, and
are also reserved registers.
@
text
@d9 4
d209 4
d214 3
a216 3
	{gc     = Map.from_list' GC.order    (#gc assignments),
	 non_gc = Map.from_list' NonGC.order (#non_gc assignments),
	 fp     = Map.from_list' FP.order    (#fp assignments)}
d267 18
@


1.20
log
@Changed virtual register Sets to Packs.
Preallocated registers are now packed small positive integers.
@
text
@d9 4
d111 2
d205 4
a208 4
      fun order (op<) (x,y) =
        if x = y then Map.EQUAL
        else if x < y then Map.LESS
             else Map.GREATER
d210 14
a223 4
      val machine_register_assignments =
	{gc     = Map.from_list (order GC.order)    (#gc assignments),
	 non_gc = Map.from_list (order NonGC.order) (#non_gc assignments),
	 fp     = Map.from_list (order FP.order)    (#fp assignments)}
d228 1
a228 1
      fun separate convert registers =
d230 5
a234 5
          fun separate' ((general, reserved), []) =
              (convert general, convert reserved)
            | separate' ((general, reserved), (virtual, real)::rest) =
              if Set.is_member (real, MachSpec.reserved) then
                separate' ((general, virtual::reserved), rest)
d236 1
a236 1
                separate' ((virtual::general, reserved), rest)
d241 8
a248 3
      val (gc_general, gc_reserved)         = separate MirTypes.GC.Pack.from_list    (#gc assignments)
      val (non_gc_general, non_gc_reserved) = separate MirTypes.NonGC.Pack.from_list (#non_gc assignments)
      val (fp_general, fp_reserved)         = separate MirTypes.FP.Pack.from_list    (#fp assignments)
d290 3
a292 12
      let
        fun virtualize (alist, registers) =
          Lists.reducel
          (fn (virtuals, real) =>
           (#1 (Lists.findp (fn(v,r) => r=real) alist)) :: virtuals
           handle Lists.Find => virtuals)
          ([], registers)
      in
        {gc = virtualize (#gc assignments, #gc MachSpec.temporary),
         non_gc = virtualize (#non_gc assignments, #non_gc MachSpec.temporary),
         fp = virtualize (#fp assignments, #fp MachSpec.temporary)}
      end
@


1.19
log
@MachSpec.corrupted_by_callee is now partitioned according to
the register type.  This was causing naming confusion.
@
text
@d9 4
d108 9
d118 1
d126 9
a134 9
    val caller_arg = 		MirTypes.GC.new()
    val callee_arg = 		MirTypes.GC.new()
    val caller_closure = 	MirTypes.GC.new()
    val callee_closure = 	MirTypes.GC.new()
    val fp = 			MirTypes.GC.new()
    val sp = 			MirTypes.GC.new()
    val handler = 		MirTypes.GC.new()
    val global = 		MirTypes.GC.new()
    val implicit =              MirTypes.GC.new()
d136 1
a136 1
    val zero_virtual =		MirTypes.GC.new()
d182 1
a182 1
                (map (fn r => (MirTypes.GC.new (), r)) MachSpec.gcs),
d184 1
a184 1
                (map (fn r => (MirTypes.NonGC.new(), r)) MachSpec.non_gcs),
d186 1
a186 1
                (map (fn r => (MirTypes.FP.new(), r)) MachSpec.fps)}
d189 3
a191 3
      {gc     = Set.list_to_set (map (fn(v,r)=>v) (#gc assignments)),
       non_gc = Set.list_to_set (map (fn(v,r)=>v) (#non_gc assignments)),
       fp     = Set.list_to_set (map (fn(v,r)=>v) (#fp assignments))}
d212 1
a212 1
      fun separate registers =
d215 1
a215 2
              (Set.list_to_set general,
               Set.list_to_set reserved)
d225 3
a227 3
      val (gc_general, gc_reserved)         = separate (#gc assignments)
      val (non_gc_general, non_gc_reserved) = separate (#non_gc assignments)
      val (fp_general, fp_reserved)         = separate (#fp assignments)
d246 2
a247 2
        fun corrupt trurl set (done, []) = done
          | corrupt trurl set (done, (virtual, real)::rest) =
d249 1
a249 1
              corrupt trurl set ((trurl virtual)::done, rest)
d251 1
a251 1
              corrupt trurl set (done, rest)
d253 9
a261 4
        Set.list_to_set
        ((corrupt MirTypes.GC (#gc MachSpec.corrupted_by_callee) ([], #gc assignments)) @@
         (corrupt MirTypes.NON_GC (#non_gc MachSpec.corrupted_by_callee) ([], #non_gc assignments)) @@
         (corrupt MirTypes.FLOAT (#fp MachSpec.corrupted_by_callee) ([], #fp assignments)))
d288 12
a299 8
      Set.list_to_set ((if automatic_callee then
			  [callee_arg, callee_closure]
			else
			  [caller_arg, caller_closure]) @@
                       (case zero
                          of Option.PRESENT virtual_zero => [virtual_zero]
                           | Option.ABSENT => []) @@
		       [fp, sp, handler,implicit])
d307 10
a316 5
      Set.list_to_set ((if automatic_callee then
			  callee_arg
			else
			  caller_arg) ::
		       [fp, sp, handler,implicit])
d318 3
@


1.18
log
@Added require newmap
@
text
@d9 3
d233 4
a236 4
        fun corrupt trurl (done, []) = done
          | corrupt trurl (done, (virtual, real)::rest) =
            if Set.is_member (real, MachSpec.corrupted_by_callee) then
              corrupt trurl ((trurl virtual)::done, rest)
d238 1
a238 1
              corrupt trurl (done, rest)
d241 3
a243 3
        ((corrupt MirTypes.GC ([], #gc assignments)) @@
         (corrupt MirTypes.NON_GC ([], #non_gc assignments)) @@
         (corrupt MirTypes.FLOAT ([], #fp assignments)))
@


1.17
log
@Changed the way virtual registers are handled.  See MirTypes.
@
text
@d9 3
d70 1
@


1.16
log
@Large scale reorganization, including addition of `reserved' and
change of type of `corrupted_by_callee'.
@
text
@d9 4
d105 9
a113 9
    val caller_arg = 		MirTypes.new_gc_register()
    val callee_arg = 		MirTypes.new_gc_register()
    val caller_closure = 	MirTypes.new_gc_register()
    val callee_closure = 	MirTypes.new_gc_register()
    val fp = 			MirTypes.new_gc_register()
    val sp = 			MirTypes.new_gc_register()
    val handler = 		MirTypes.new_gc_register()
    val global = 		MirTypes.new_gc_register()
    val implicit =              MirTypes.new_gc_register()
d115 1
a115 1
    val zero_virtual =		MirTypes.new_gc_register()
d161 1
a161 1
                (map (fn r => (MirTypes.new_gc_register (), r)) MachSpec.gcs),
d163 1
a163 1
                (map (fn r => (MirTypes.new_non_gc_register(), r)) MachSpec.non_gcs),
d165 1
a165 1
                (map (fn r => (MirTypes.new_fp_register(), r)) MachSpec.fps)}
d184 3
a186 3
	{gc     = Map.from_list (order order_gc_register)     (#gc assignments),
	 non_gc = Map.from_list (order order_non_gc_register) (#non_gc assignments),
	 fp     = Map.from_list (order order_fp_register)     (#fp assignments)}
@


1.15
log
@Added implicit
@
text
@d9 3
d74 1
a74 1
  structure Table	: TABLE
d89 1
a89 1
    structure Table = Table
d126 2
a127 3
    (* On entry to a procedure the argument and closure are assumed to be *)
    (* passed by the caller, and the fp, sp, and handler registers are *)
    (* required by the call mechanism. *)
d129 17
a145 9
    val defined_on_entry =
      Set.list_to_set ((if automatic_callee then
			  [callee_arg, callee_closure]
			else
			  [caller_arg, caller_closure]) @@
                       (case zero
                          of Option.PRESENT virtual_zero => [virtual_zero]
                           | Option.ABSENT => []) @@
		       [fp, sp, handler,implicit])
a147 28
    (* On exit from a procedure the argument contains the return value for *)
    (* the caller, and the fp, sp, and handler registers must contain the *)
    (* same values as they did on entry. *)

    val defined_on_exit =
      Set.list_to_set ((if automatic_callee then
			  callee_arg
			else
			  caller_arg) ::
		       [fp, sp, handler,implicit])


    (* The preassigned registers happen to be the set of special purpose *)
    (* registers. *)

    val preassigned =
      {gc = Set.list_to_set
            ([caller_arg, caller_closure, fp, sp, handler,
	      global,implicit] @@
	     (if not automatic_callee then [] else
		[callee_arg, callee_closure]) @@
             (case zero
                of Option.PRESENT virtual_zero => [virtual_zero]
                 | Option.ABSENT => [])),
       non_gc = Set.empty_set,
       fp = Set.empty_set}


a153 15
      
    val gcs =
      [(caller_arg, MachSpec.caller_arg),
       (callee_arg, MachSpec.callee_arg),
       (caller_closure, MachSpec.caller_closure),
       (callee_closure, MachSpec.callee_closure),
       (fp, MachSpec.fp),
       (sp, MachSpec.sp),
       (handler, MachSpec.handler),
       (global, MachSpec.global),
       (implicit,MachSpec.implicit)] @@
      (case MachSpec.zero
         of Option.PRESENT zero_real => [(zero_virtual, zero_real)]
          | Option.ABSENT            => []) @@
      (map (fn r => (MirTypes.new_gc_register (), r)) MachSpec.gcs)
d155 7
a161 2
    val non_gcs =
      map (fn r => (MirTypes.new_non_gc_register(), r)) MachSpec.non_gcs
d163 4
a166 2
    val fps =
      map (fn r => (MirTypes.new_fp_register(), r)) MachSpec.fps
d169 1
a169 1
    (* Build tables from the association lists. *)
a171 1
      open Table
d174 4
a177 4
      val tablespec =
	{gc = TableSpec {order = order_gc_register, eq = op=},
	 non_gc = TableSpec {order = order_non_gc_register, eq = op=},
	 fp = TableSpec {order = order_fp_register, eq = op=}}
d180 3
a182 3
	{gc     = table_of_alist (gcs, #gc tablespec),
	 non_gc = table_of_alist (non_gcs, #non_gc tablespec),
	 fp     = table_of_alist (fps, #fp tablespec)}
d186 14
a199 1
   (* Filter out those registers which cannot be used for allocation. *)
d201 20
a220 1
    val general_purpose =
d222 6
a227 6
	fun not_reserved (done, []) = Set.list_to_set done
	  | not_reserved (done, (virtual, real)::rest) =
	    if Set.is_member (real, MachSpec.reserved) then
	      not_reserved (done, rest)
	    else
	      not_reserved (virtual::done, rest)
d229 4
a232 3
	{gc     = not_reserved ([], gcs),
	 non_gc = not_reserved ([], non_gcs),
	 fp     = not_reserved ([], fps)}
d234 1
d236 2
d239 14
a252 1
    (*  *******UNIMPLEMENTED**** *)
d254 3
a256 2
    val ordered_general_purpose =
      {gc = [], non_gc = [], fp = []}
d258 9
a267 1
    (* Any registers except the reserved registers may be spilled. *)
d269 3
a271 1
    val spillable = general_purpose
d273 6
a279 2
    (* The machine registers which are corrupted by the callee are *)
    (* defined in MachSpec. Filter out the aliases which map to them. *)
a280 14
    val corrupted_by_callee =
	let
	  fun corrupt (done, []) = Set.list_to_set done
	    | corrupt (done, (virtual, real)::rest) =
	      if Set.is_member (real, MachSpec.corrupted_by_callee) then
		corrupt (virtual::done, rest)
	      else
		corrupt (done, rest)
	in
	  {gc		= corrupt ([], gcs),
	   non_gc	= corrupt ([], non_gcs),
	   fp		= corrupt ([], fps)}
	end
    
@


1.14
log
@Added the zero register, if present on the target machine.
@
text
@d9 3
d106 1
d135 1
a135 1
		       [fp, sp, handler])
d147 1
a147 1
		       [fp, sp, handler])
d156 1
a156 1
	      global] @@
d181 2
a182 1
       (global, MachSpec.global)] @@
@


1.13
log
@Added ordered_general_purpose, but didn't implement it.
(It is initialized as empty at the moment.)
@
text
@d8 5
a12 1
 *  $Log:	_mirregisters.sml,v $
d57 1
d71 1
d74 1
d84 1
d104 5
d110 1
d128 3
d154 4
a157 1
		[callee_arg, callee_closure])),
d178 3
@


1.12
log
@Corrected the definition of general_purpose and removed the
useless definition of machine_register_aliases.
@
text
@d9 4
d200 11
@


1.11
log
@Added some brackets to keep njml 0.75 happy
@
text
@d1 42
a42 5
(* _mirregisters.sml the functor *)
(*
$Log:	_mirregisters.sml,v $
Revision 1.10  91/11/14  10:41:24  richard
Removed references to fp_double registers.
a43 2
Revision 1.9  91/11/04  15:15:51  richard
Added general_purpose.
a44 28
Revision 1.8  91/10/16  09:28:42  richard
Recommented, and added corrupted_by_callee.

Revision 1.7  91/10/15  15:06:42  richard
Moved register assignments here from the register allocator functor.

Revision 1.6  91/10/10  12:49:17  richard
Fixed defined_on_entry and defined_on_exit to mention callee rather
than caller registers on machines with register windows.

Revision 1.5  91/10/09  13:49:00  richard
Added various new register definitions.

Revision 1.4  91/10/02  11:06:20  jont
Removed real register options, these are being done elsewhere

Revision 1.3  91/10/01  14:52:23  richard
Added global register.

Revision 1.2  91/09/20  13:13:53  jont
Removed temp_sp, not required

Revision 1.1  91/09/18  11:55:45  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

d53 1
d75 1
d94 2
a95 1
    (* machine then there are no register windows. *)
d100 5
d112 5
d125 1
a125 1
    (* The preassigned registers are the same as the special purpose *)
d129 7
a135 11
      {gc = [(caller_arg,	MachSpec.caller_arg),
	     (caller_closure,	MachSpec.caller_closure),
	     (fp,		MachSpec.fp),
	     (sp,		MachSpec.sp),
	     (handler,		MachSpec.handler),
	     (global,		MachSpec.global)] @@
            (if not automatic_callee then [] else
	      [(callee_arg,	MachSpec.callee_arg),
	       (callee_closure,	MachSpec.callee_closure)]),
       non_gc = [],
       fp = []}
d138 1
a138 1
    local
d140 15
a154 5
      (* These are association lists mapping virtual to real registers *)
      (* in order of preference for assignment. One new virtual *)
      (* register is created for each machine register. NOTE: It's *)
      (* possible that some or all of the preassigned registers could *)
      (* be placed earlier in the list. *)
d156 2
a157 2
      val gc_general_list =
	map (fn r => (MirTypes.new_gc_register(), r)) MachSpec.gcs
d159 2
a160 2
      val non_gc_general_list =
	map (fn r => (MirTypes.new_non_gc_register(), r)) MachSpec.non_gcs
a161 2
      val fp_general_list =
	map (fn r => (MirTypes.new_fp_register(), r)) MachSpec.fps
d163 1
a163 3
      val gc_assign_list        = gc_general_list @@ (#gc preassigned)
      val non_gc_assign_list    = non_gc_general_list @@ (#non_gc preassigned)
      val fp_assign_list        = fp_general_list @@ (#fp preassigned)
d165 1
d167 2
a168 1

d170 3
a172 6
	{gc =
	 TableSpec {order = MirTypes.order_gc_register, eq = op=},
	 non_gc =
	 TableSpec {order = MirTypes.order_non_gc_register, eq = op=},
	 fp =
	 TableSpec {order = MirTypes.order_fp_register, eq = op=}}
a173 2
    in

d175 4
a178 6
	{gc =
	 Table.table_of_alist (gc_assign_list, #gc tablespec),
	 non_gc =
	 Table.table_of_alist (non_gc_assign_list, #non_gc tablespec),
	 fp =
	 Table.table_of_alist (fp_assign_list, #fp tablespec)}
a179 4
      val machine_register_aliases =
	{gc	= map #1 gc_assign_list,
	 non_gc	= map #1 non_gc_assign_list,
	 fp	= map #1 fp_assign_list}
d181 1
a181 4
      val general_purpose =
	{gc	= map #1 gc_general_list,
	 non_gc	= map #1 non_gc_general_list,
	 fp	= map #1 fp_general_list}
d183 13
a196 4
      (* The machine registers which are corrupted by the callee are *)
      (* defined in MachSpec. These are mapped backward through the *)
      (* assignment lists to get the virtual register aliases for *)
      (* them. *)
d198 4
a201 1
      val corrupted_by_callee =
d203 6
a208 7
	  fun corrupt alist =
	    Set.list_to_set
	    (map #1
	     (Lists.filterp
	      (fn (virtual, real) =>
	       Set.is_member(real, MachSpec.corrupted_by_callee))
	      alist))
d210 3
a212 3
	  {gc		= corrupt gc_assign_list,
	   non_gc	= corrupt non_gc_assign_list,
	   fp		= corrupt fp_assign_list}
a214 3
    end


@


1.10
log
@Removed references to fp_double registers.
@
text
@d4 3
d115 1
a115 1
            if not automatic_callee then [] else
d117 1
a117 1
	       (callee_closure,	MachSpec.callee_closure)],
@


1.9
log
@Added general_purpose.
@
text
@d4 3
d116 1
a116 2
       fp = [],
       fp_double = []}
a135 4
      val fp_double_general_list =
	map (fn r => (MirTypes.new_fp_double_register(), r))
	MachSpec.fp_doubles

a138 2
      val fp_double_assign_list = 
	fp_double_general_list @@ (#fp_double preassigned)
d148 1
a148 3
	 TableSpec {order = MirTypes.order_fp_register, eq = op=},
	 fp_double =
	 TableSpec {order = MirTypes.order_fp_double_register, eq = op=}}
d158 1
a158 3
	 Table.table_of_alist (fp_assign_list, #fp tablespec),
	 fp_double =
	 Table.table_of_alist (fp_double_assign_list, #fp_double tablespec)}
d163 1
a163 2
	 fp	= map #1 fp_assign_list,
	 fp_double= map #1 fp_double_assign_list}
d168 1
a168 2
	 fp	= map #1 fp_general_list,
	 fp_double= map #1 fp_double_general_list}
d188 1
a188 2
	   fp		= corrupt fp_assign_list,
	   fp_double	= corrupt fp_double_assign_list}
@


1.8
log
@Recommented, and added corrupted_by_callee.
@
text
@d4 3
d125 2
a126 3
      val gc_assign_list =
	(map (fn r => (MirTypes.new_gc_register(), r)) MachSpec.gcs) @@
	(#gc preassigned)
d128 2
a129 3
      val non_gc_assign_list =
	(map (fn r => (MirTypes.new_non_gc_register(), r)) MachSpec.non_gcs) @@
	(#non_gc preassigned)
d131 2
a132 3
      val fp_assign_list =
	(map (fn r => (MirTypes.new_fp_register(), r)) MachSpec.fps) @@
	(#fp preassigned)
d134 3
a136 4
      val fp_double_assign_list =
	(map (fn r => (MirTypes.new_fp_double_register(), r))
	 MachSpec.fp_doubles) @@
	(#fp_double preassigned)
d138 6
d173 6
@


1.7
log
@Moved register assignments here from the register allocator functor.
@
text
@d4 3
d46 2
d58 7
d75 3
d96 2
a97 3
    (* Some registers are always mapped onto the same real machine *)
    (* registers. This is a record of association lists (one for each *)
    (* register type) to perform these mappings. *)
d117 4
a120 3
      (* in order of preference for assignment. NOTE: It's possible *)
      (* that some or all of the preassigned registers could be placed *)
      (* earlier in the list. *)
a152 11
      (*  == Register assignments ==
       *
       *  The register allocator produces a MirOptTypes.procedure with the
       *  registers altered and a table mapping virtual to real registers.
       *  A new procedure type is not required, and the procedure could be
       *  re-run through the other optimisation stages.
       *
       *  Tables of mappings from new virtual registers to real machine
       *  registers are created here for the final code generator.
       *)

a162 8

      (*  == The fresh virtual registers ==
       *
       *  These are the `colours' which are assigned to the virtual
       *  registers in the input procedure, and which can be mapped onto
       *  real machine registers using the tables above.
       *)

d169 22
@


1.6
log
@Fixed defined_on_entry and defined_on_exit to mention callee rather
than caller registers on machines with register windows.
@
text
@d4 4
d27 3
d39 3
d49 2
d52 1
d79 96
@


1.5
log
@Added various new register definitions.
@
text
@d4 3
a48 6
    val defined_on_entry =
      Set.list_to_set [caller_arg,
		       caller_closure,
		       fp,
		       sp,
		       handler]
a49 6
    val defined_on_exit =
      Set.list_to_set [caller_arg,	(* the return value *)
		       fp,
		       sp,
		       handler]

d53 13
@


1.4
log
@Removed real register options, these are being done elsewhere
@
text
@d4 3
d19 2
d25 5
a29 1
  structure MirTypes : MIRTYPES
a30 2
struct
  structure MirTypes = MirTypes
d32 1
a32 2
  val fn_arg = MirTypes.new_gc_register()
  (* The argument register for all functions *)
d34 2
a35 2
  val cl_arg = MirTypes.new_gc_register()
  (* The closure pointer for all function calls *)
d37 8
a44 3
  val cl_arg' = MirTypes.new_gc_register()
  (* The closure pointer within all functions *)
  (* Note that this is copied during function prologue from cl_arg *)
d46 6
a51 2
  val fp = MirTypes.new_gc_register()
  (* The frame pointer within all functions *)
d53 5
a57 2
  val sp = MirTypes.new_gc_register()
  (* The stack pointer within all functions *)
d59 2
a60 2
  val handler = MirTypes.new_gc_register()
  (* The latest handler pointer *)
d62 2
a63 3
  val global = MirTypes.new_gc_register()
  (* A register unaffected by RESTORE_REGS *)
end
@


1.3
log
@Added global register.
@
text
@d4 3
d25 1
a25 1
  val fn_arg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d28 1
a28 1
  val cl_arg = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d31 1
a31 1
  val cl_arg' = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d35 1
a35 1
  val fp = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d38 1
a38 1
  val sp = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d41 1
a41 1
  val handler = (MirTypes.new_gc_register(), MirTypes.ABSENT)
d44 1
a44 1
  val global = (MirTypes.new_gc_register(), MirTypes.ABSENT)
@


1.2
log
@Removed temp_sp, not required
@
text
@d4 3
d40 3
@


1.2.1.1
log
@This is a modified version to use the reworked MirTypes module
(ver 1.23.1.1). This module is correct, but work has been suspended
on this branch because of the amount of time it would take to convert
the code generator (Mir_Cg) module.
@
text
@a3 3
Revision 1.2  91/09/20  13:13:53  jont
Removed temp_sp, not required

d19 1
a19 3
  open MirTypes

  val fn_arg = GC(REG(fresh_virtual_register ()))
d22 1
a22 1
  val cl_arg = GC(REG(fresh_virtual_register ()))
d25 1
a25 1
  val cl_arg' = GC(REG(fresh_virtual_register ()))
d29 1
a29 1
  val fp = GC(REG(fresh_virtual_register ()))
d32 1
a32 1
  val sp = GC(REG(fresh_virtual_register ()))
d35 1
a35 1
  val handler = GC(REG(fresh_virtual_register ()))
a36 3

  val global = GC(REG(fresh_virtual_register ()))
  (* A global register not affected by RESTORE_REGS *)
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
a36 4

  val temp_sp = (MirTypes.new_gc_register(), MirTypes.ABSENT)
  (* The temporary stack pointer used during function entry *)

@
