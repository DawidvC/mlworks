head	1.21;
access;
symbols
	MLW_daveb_inline_1_4_99:1.21.11
	MLWorks_21c0_1999_03_25:1.21
	MLWorks_20c1_1998_08_20:1.21
	MLWorks_20c0_1998_08_04:1.21
	MLWorks_20b2c2_1998_06_19:1.21
	MLWorks_20b2_Windows_1998_06_12:1.21
	MLWorks_20b1c1_1998_05_07:1.21
	MLWorks_20b0_1998_04_07:1.21
	MLWorks_20b0_1998_03_20:1.21
	MLWorks_20m2_1998_02_16:1.21
	MLWorks_20m1_1997_10_23:1.21
	MLWorks_11r1:1.21.8.1.1.1.1
	MLWorks_workspace_97:1.21.10
	MLWorks_dt_wizard:1.21.9
	MLWorks_11c0_1997_09_09:1.21.8.1.1.1
	MLWorks_10r3:1.21.8.1.3
	MLWorks_10r2_551:1.21.8.1.2
	MLWorks_11:1.21.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.21.8.1
	MLWorks_20m0_1997_06_20:1.21
	MLWorks_1_0_r2c2_1997_06_14:1.21.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.21.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.21.8
	MLWorks_BugFix_1997_04_24:1.21
	MLWorks_1_0_r2_Win32_1997_04_11:1.21
	MLWorks_1_0_r2_Unix_1997_04_04:1.21
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.21.6.1.1
	MLWorks_gui_1996_12_18:1.21.7
	MLWorks_1_0_Win32_1996_12_17:1.21.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.21.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.21.4.1
	MLWorks_1_0_Irix_1996_11_28:1.21.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.21.5
	MLWorks_1_0_Unix_1996_11_14:1.21.4
	MLWorks_Open_Beta2_1996_10_11:1.21.3
	MLWorks_License_dev:1.21.2
	MLWorks_1_open_beta_1996_09_13:1.21.1
	MLWorks_Open_Beta_1996_08_22:1.21
	MLWorks_Beta_1996_07_02:1.21
	MLWorks_Beta_1996_06_07:1.21
	MLWorks_Beta_1996_06_06:1.21
	MLWorks_Beta_1996_06_05:1.21
	MLWorks_Beta_1996_06_03:1.21
	MLWorks_Beta_1996_05_31:1.21
	MLWorks_Beta_1996_05_30:1.21
	ML_beta_release_12/08/94:1.18
	ML_beta_release_03/08/94:1.18
	ML_revised_beta_release_25/05/94:1.18
	ML_final_beta_release_02/03/94:1.18
	mlworks-28-01-1994:1.18
	Release:1.18
	mlworks-beta-01-09-1993:1.18
	MLWorks-1-0-4-29/01/1993:1.16
	MLWorks-1-0-3-21/12/1992:1.16
	MLWorks-1-0-2-15/12/1992:1.16
	MLWorks-1-0-1-04/12/1992:1.16
	checkpoint_17_08_92:1.12
	Ten15_release_19-08-91:1.6
	ten15_release:1.3;
locks; strict;
comment	@ * @;


1.21
date	96.03.28.10.45.44;	author matthew;	state Exp;
branches
	1.21.1.1
	1.21.2.1
	1.21.3.1
	1.21.4.1
	1.21.5.1
	1.21.6.1
	1.21.7.1
	1.21.8.1
	1.21.9.1
	1.21.10.1
	1.21.11.1;
next	1.20;

1.20
date	95.12.04.11.52.22;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	94.10.13.10.22.37;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.03.10.17.13.50;	author matthew;	state Exp;
branches
	1.18.1.1;
next	1.17;

1.17
date	93.02.01.17.32.05;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	92.10.30.12.10.31;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.10.29.18.21.27;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.10.05.09.46.31;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.08.19.18.11.44;	author davidt;	state Exp;
branches;
next	1.12;

1.12
date	92.07.21.11.37.40;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.03.12.12.50.31;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.09.05.16.35.49;	author jont;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	91.09.02.11.52.34;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.08.30.14.55.33;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.08.23.14.03.08;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.08.15.11.17.13;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.08.09.12.51.06;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.08.07.15.30.27;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.07.30.17.28.03;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.07.26.14.21.47;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.07.25.11.36.35;	author jont;	state Exp;
branches;
next	;

1.10.1.1
date	91.09.26.15.02.02;	author richard;	state Exp;
branches;
next	;

1.18.1.1
date	93.03.10.17.13.50;	author jont;	state Exp;
branches;
next	;

1.21.1.1
date	96.09.13.11.14.43;	author hope;	state Exp;
branches;
next	;

1.21.2.1
date	96.10.07.16.05.06;	author hope;	state Exp;
branches;
next	;

1.21.3.1
date	96.10.17.11.23.22;	author hope;	state Exp;
branches;
next	;

1.21.4.1
date	96.11.14.12.47.41;	author hope;	state Exp;
branches
	1.21.4.1.1.1;
next	;

1.21.4.1.1.1
date	96.11.28.14.59.13;	author hope;	state Exp;
branches;
next	;

1.21.5.1
date	96.11.22.18.07.44;	author hope;	state Exp;
branches;
next	;

1.21.6.1
date	96.12.17.17.46.26;	author hope;	state Exp;
branches
	1.21.6.1.1.1;
next	;

1.21.6.1.1.1
date	97.02.24.11.36.04;	author hope;	state Exp;
branches;
next	;

1.21.7.1
date	96.12.18.09.40.25;	author hope;	state Exp;
branches;
next	;

1.21.8.1
date	97.05.12.10.32.46;	author hope;	state Exp;
branches
	1.21.8.1.1.1
	1.21.8.1.2.1
	1.21.8.1.3.1;
next	;

1.21.8.1.1.1
date	97.07.28.18.17.42;	author daveb;	state Exp;
branches
	1.21.8.1.1.1.1.1;
next	;

1.21.8.1.1.1.1.1
date	97.10.07.11.42.36;	author jkbrook;	state Exp;
branches;
next	;

1.21.8.1.2.1
date	97.09.08.17.11.14;	author daveb;	state Exp;
branches;
next	;

1.21.8.1.3.1
date	97.09.09.14.06.51;	author daveb;	state Exp;
branches;
next	;

1.21.9.1
date	97.09.10.19.21.26;	author brucem;	state Exp;
branches;
next	;

1.21.10.1
date	97.09.11.20.52.38;	author daveb;	state Exp;
branches;
next	;

1.21.11.1
date	99.04.01.17.55.46;	author daveb;	state Exp;
branches;
next	;


desc
@Environment relating lambda vaiables to mir registers etc
@


1.21
log
@Adding where type clause
@
text
@(* _mir_env.sml the functor *)
(*
$Log: _mir_env.sml,v $
 * Revision 1.20  1995/12/04  11:52:22  matthew
 * Simplifying lambdatypes
 *
Revision 1.19  1994/10/13  10:22:37  matthew
Make lookup_in_closure return an Option value

Revision 1.18  1993/03/10  17:13:50  matthew
Signature revisions

Revision 1.17  1993/02/01  17:32:05  matthew
Added sharing

Revision 1.16  1992/10/30  12:10:31  jont
Changed to use LambdaTypes.Map

Revision 1.15  1992/10/29  18:21:27  jont
Removed LVar_ordering in favour of LVar_order (both same)

Revision 1.14  1992/10/05  09:46:31  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.13  1992/08/19  18:11:44  davidt
Mir_Env now uses NewMap instead of Map.

Revision 1.12  1992/07/21  11:37:40  jont
Removed is_in_lambda_env and is_in_closure_env, not needed

Revision 1.11  1992/03/12  12:50:31  jont
Changed environments to use eqfunmaps (slightly more efficient)

Revision 1.10  1991/09/05  16:35:49  jont
Added augment_lambda_env

Revision 1.9  91/09/02  11:52:34  jont
Removed translations from primitives to HARP

Revision 1.8  91/08/30  14:55:33  jont
Removed Prim_Calc and associated items, now explicit in mir_cg

Revision 1.7  91/08/23  14:03:08  jont
Changed to use pervasives

Revision 1.6  91/08/15  11:17:13  jont
Updated for later version of HARP

Revision 1.5  91/08/09  12:51:06  jont
Added encodings for unary minus

Revision 1.4  91/08/07  15:30:27  jont
Added special constant equality functions

Revision 1.3  91/07/30  17:28:03  jont
Added closure environment

Revision 1.2  91/07/26  14:21:47  jont
Added empty_lambda_env

Revision 1.1  91/07/25  11:36:35  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/intnewmap";
require "../lambda/lambdatypes";
require "mirtypes";
require "mir_env";

functor Mir_Env(
  structure LambdaTypes : LAMBDATYPES where type LVar = int
  structure MirTypes : MIRTYPES
  structure IntMap : INTNEWMAP
  sharing type MirTypes.Debugger_Types.Type = LambdaTypes.Type
                ) : MIR_ENV =

struct
  structure LambdaTypes = LambdaTypes
  structure MirTypes = MirTypes

  type 'a Map = 'a IntMap.T

  datatype Lambda_Env = LAMBDA_ENV of (MirTypes.any_register) IntMap.T
  val empty_lambda_env =
    LAMBDA_ENV(IntMap.empty)

  datatype Closure_Env = CLOSURE_ENV of (int) IntMap.T
  val empty_closure_env = CLOSURE_ENV(IntMap.empty)

  fun add_lambda_env((lv, reg), LAMBDA_ENV env) = LAMBDA_ENV(IntMap.define(env, lv, reg))
  fun lookup_lambda(lv, LAMBDA_ENV env) = IntMap.tryApply'(env, lv)

  fun augment_lambda_env(LAMBDA_ENV lenv1, LAMBDA_ENV lenv2) = LAMBDA_ENV(IntMap.union(lenv1, lenv2))
  fun add_closure_env((lv, i), CLOSURE_ENV env) = CLOSURE_ENV(IntMap.define(env, lv, i))

  fun lookup_in_closure(lv, CLOSURE_ENV env) = IntMap.tryApply'(env, lv)
end
@


1.21.11.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 3
 * Revision 1.21  1996/03/28  10:45:44  matthew
 * Adding where type clause
 *
@


1.21.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.21  1996/03/28  10:45:44  matthew
 * Adding where type clause
 *
@


1.21.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.21  1996/03/28  10:45:44  matthew
 * Adding where type clause
 *
@


1.21.8.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/03/28  10:45:44  matthew
 * Adding where type clause
 *
@


1.21.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.21.8.1  1997/05/12  10:32:46  hope
 * branched from 1.21
 *
@


1.21.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.21.8.1  1997/05/12  10:32:46  hope
 * branched from 1.21
 *
@


1.21.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.21.8.1  1997/05/12  10:32:46  hope
 * branched from 1.21
 *
@


1.21.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.21.8.1.1.1  1997/07/28  18:17:42  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.21.7.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/03/28  10:45:44  matthew
 * Adding where type clause
 *
@


1.21.6.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/03/28  10:45:44  matthew
 * Adding where type clause
 *
@


1.21.6.1.1.1
log
@branched from 1.21.6.1
@
text
@a3 3
 * Revision 1.21.6.1  1996/12/17  17:46:26  hope
 * branched from 1.21
 *
@


1.21.5.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/03/28  10:45:44  matthew
 * Adding where type clause
 *
@


1.21.4.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/03/28  10:45:44  matthew
 * Adding where type clause
 *
@


1.21.4.1.1.1
log
@branched from 1.21.4.1
@
text
@a3 3
 * Revision 1.21.4.1  1996/11/14  12:47:41  hope
 * branched from 1.21
 *
@


1.21.3.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/03/28  10:45:44  matthew
 * Adding where type clause
 *
@


1.21.2.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/03/28  10:45:44  matthew
 * Adding where type clause
 *
@


1.21.1.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/03/28  10:45:44  matthew
 * Adding where type clause
 *
@


1.20
log
@Simplifying lambdatypes
@
text
@d4 3
d73 1
a73 1
  structure LambdaTypes : LAMBDATYPES
a75 1
  sharing type LambdaTypes.LVar = int
@


1.19
log
@Make lookup_in_closure return an Option value
@
text
@d4 3
d64 1
d72 2
a73 1
  
a77 1
  structure NewMap = LambdaTypes.Map
d81 3
a83 1
  datatype Lambda_Env = LAMBDA_ENV of (MirTypes.any_register) NewMap.T
d85 1
a85 1
    LAMBDA_ENV(NewMap.empty)
d87 2
a88 2
  datatype Closure_Env = CLOSURE_ENV of (int) NewMap.T
  val empty_closure_env = CLOSURE_ENV(NewMap.empty)
d90 2
a91 2
  fun add_lambda_env((lv, reg), LAMBDA_ENV env) = LAMBDA_ENV(NewMap.define(env, lv, reg))
  fun lookup_lambda(lv, LAMBDA_ENV env) = NewMap.tryApply'(env, lv)
d93 2
a94 2
  fun augment_lambda_env(LAMBDA_ENV lenv1, LAMBDA_ENV lenv2) = LAMBDA_ENV(NewMap.union(lenv1, lenv2))
  fun add_closure_env((lv, i), CLOSURE_ENV env) = CLOSURE_ENV(NewMap.define(env, lv, i))
d96 1
a96 1
  fun lookup_in_closure(lv, CLOSURE_ENV env) = NewMap.tryApply'(env, lv)
@


1.18
log
@Signature revisions
@
text
@d4 3
a76 2
  exception Lookup = NewMap.Undefined

d85 2
a86 1
  fun lookup_lambda(lv, LAMBDA_ENV env) = NewMap.apply'(env, lv)
d89 2
a90 1
  fun lookup_in_closure(lv, CLOSURE_ENV env) = NewMap.apply'(env, lv)
@


1.18.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.18  1993/03/10  17:13:50  matthew
Signature revisions

@


1.17
log
@Added sharing
@
text
@d4 3
d66 1
a66 1
  sharing MirTypes.Debugger_Types.Datatypes = LambdaTypes.Datatypes
@


1.16
log
@Changed to use LambdaTypes.Map
@
text
@d4 3
d62 4
a65 1
) : MIR_ENV =
@


1.15
log
@Removed LVar_ordering in favour of LVar_order (both same)
@
text
@d4 3
d61 1
a61 1
  structure NewMap = LambdaTypes.Datatypes.NewMap
d67 1
a67 1
  datatype Lambda_Env = LAMBDA_ENV of (LambdaTypes.LVar, MirTypes.any_register) NewMap.T
d69 1
a69 1
    LAMBDA_ENV(NewMap.empty(LambdaTypes.LVar_order,LambdaTypes.LVar_eq))
d71 2
a72 2
  datatype Closure_Env = CLOSURE_ENV of (LambdaTypes.LVar, int) NewMap.T
  val empty_closure_env = CLOSURE_ENV(NewMap.empty(LambdaTypes.LVar_order,LambdaTypes.LVar_eq))
@


1.14
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d65 2
a66 1
  val empty_lambda_env = LAMBDA_ENV(NewMap.empty(LambdaTypes.LVar_ordering,LambdaTypes.LVar_eq))
d69 1
a69 1
  val empty_closure_env = CLOSURE_ENV(NewMap.empty(LambdaTypes.LVar_ordering,LambdaTypes.LVar_eq))
@


1.13
log
@Mir_Env now uses NewMap instead of Map.
@
text
@d4 3
d62 1
a62 1
  val empty_lambda_env = LAMBDA_ENV(NewMap.empty LambdaTypes.LVar_ordering)
d65 1
a65 1
  val empty_closure_env = CLOSURE_ENV(NewMap.empty LambdaTypes.LVar_ordering)
@


1.12
log
@Removed is_in_lambda_env and is_in_closure_env, not needed
@
text
@d4 3
a42 1
require "../utils/map";
a47 1
  structure Map : MAP
d52 1
a52 1
  structure Map = Map
d56 13
a68 16
  datatype Lambda_Env =
    LAMBDA_ENV of (LambdaTypes.LVar, MirTypes.any_register) Map.Map
  val empty_lambda_env = LAMBDA_ENV(Map.empty_eqfunmap LambdaTypes.LVar_eq)

  datatype Closure_Env =
    CLOSURE_ENV of (LambdaTypes.LVar, int) Map.Map
  val empty_closure_env = CLOSURE_ENV(Map.empty_eqfunmap LambdaTypes.LVar_eq)

  fun add_lambda_env((lv, reg), LAMBDA_ENV env) =
    LAMBDA_ENV(Map.add((lv, reg), env, LambdaTypes.LVar_order))
  fun lookup_lambda(lv, LAMBDA_ENV env) = Map.lookup(lv, env)
  fun augment_lambda_env(LAMBDA_ENV lenv1, LAMBDA_ENV lenv2) =
    LAMBDA_ENV(Map.plus(lenv1, lenv2, LambdaTypes.LVar_order))
  fun add_closure_env((lv, i), CLOSURE_ENV env) =
    CLOSURE_ENV(Map.add((lv, i), env, LambdaTypes.LVar_order))
  fun lookup_in_closure(lv, CLOSURE_ENV env) = Map.lookup(lv, env)
@


1.11
log
@Changed environments to use eqfunmaps (slightly more efficient)
@
text
@d4 3
a65 1
  fun is_in_lambda_env(lv, LAMBDA_ENV env) = Map.domain_member(lv, env)
a70 1
  fun is_in_closure(lv, CLOSURE_ENV env) = Map.domain_member(lv, env)
@


1.10
log
@Added augment_lambda_env
@
text
@d3 4
a6 1
$Log:	_mir_env.sml,v $
d54 1
a54 1
  val empty_lambda_env = LAMBDA_ENV Map.empty_map
d58 1
a58 1
  val empty_closure_env = CLOSURE_ENV Map.empty_map
@


1.10.1.1
log
@This is a modified version to use the reworked MirTypes module
(ver 1.23.1.1). This module is correct, but work has been suspended
on this branch because of the amount of time it would take to convert
the code generator (Mir_Cg) module.
@
text
@a3 3
Revision 1.10  91/09/05  16:35:49  jont
Added augment_lambda_env

d50 1
a50 1
    LAMBDA_ENV of (LambdaTypes.LVar, MirTypes.virtual_register) Map.Map
@


1.9
log
@Removed translations from primitives to HARP
@
text
@d4 3
d61 2
@


1.8
log
@Removed Prim_Calc and associated items, now explicit in mir_cg
@
text
@d4 3
a31 3
require "../utils/lists";
require "../basics/symbol";
require "../basics/ident";
a32 4
require "../lambda/environtypes";
require "../lambda/environ";
require "../main/primitives";
require "../main/pervasives";
a37 3
  structure Lists : LISTS
  structure Ident : IDENT
  structure Symbol : SYMBOL
a38 4
  structure EnvironTypes : ENVIRONTYPES
  structure Environ : ENVIRON
  structure Primitives : PRIMITIVES
  structure Pervasives : PERVASIVES
a39 9

  sharing MirTypes.Ident = LambdaTypes.Ident = Environ.Ident = Ident =
    EnvironTypes.Ident
  sharing Ident.Symbol = Symbol
  sharing LambdaTypes = Environ.LambdaTypes = Primitives.LambdaTypes =
    EnvironTypes.LambdaTypes
  sharing Environ.EnvironTypes = Primitives.EnvironTypes = EnvironTypes
  sharing Map = Environ.Map = EnvironTypes.Map
  sharing type LambdaTypes.Primitive = Pervasives.pervasive
a49 12
(*
  type Prim_Calc_Env =
    (LambdaTypes.Primitive * MirTypes.calc_op) list

*)
  datatype test =
    ITEST of MirTypes.cond_branch |
    FTEST of MirTypes.fcond_branch * bool (* Sense of test *)

  type Prim_Test_Env =
    (LambdaTypes.Primitive * test) list

a53 2
  fun foldleft f (e, xs) = Lists.foldl (fn x => (fn y => f(x, y))) e xs

d57 1
a57 49

  fun lookup_assoc(x, l) =
    let
      fun lookup_sub [] = raise(Map.Lookup)
      | lookup_sub((y, z) :: ys) =
	if x = y then z else lookup_sub ys
    in
      lookup_sub l
    end
(*
  fun lookup_prim_calc(prim, env) = lookup_assoc(prim, env)
  fun is_prim_calc(prim, env: Prim_Calc_Env) = Lists.member(prim, map #1 env)
*)
  fun lookup_prim_test(prim, env) = lookup_assoc(prim, env)
  fun is_prim_test(prim, env: Prim_Test_Env) = Lists.member(prim, map #1 env)
  fun prim_from_name chars =
    case Environ.lookup_valid(
      Ident.VAR(Symbol.find_symbol chars), Primitives.initial_env) of
      EnvironTypes.PRIM prim => prim
    | _ => raise(LambdaTypes.impossible"prim_from_names")
(*
  val initial_prim_calc_env =
    [(Pervasives.FDIV, MirTypes.BFCALC MirTypes.FDIV),
     (Pervasives.REALPLUS, MirTypes.BFCALC MirTypes.FADD),
     (Pervasives.REALSTAR, MirTypes.BFCALC MirTypes.FMUL),
     (Pervasives.REALUMINUS, MirTypes.UFCALC MirTypes.FNEG),
     (Pervasives.REALMINUS, MirTypes.BFCALC MirTypes.FSUB),
     (Pervasives.INTPLUS, MirTypes.TBCALC MirTypes.ADDV),
     (Pervasives.INTSTAR, MirTypes.TBCALC MirTypes.MULV),
     (Pervasives.INTUMINUS, MirTypes.NCALC MirTypes.SUBV),
     (Pervasives.INTMINUS, MirTypes.TBCALC MirTypes.SUBV),
     (Pervasives.DIV, MirTypes.TBCALC MirTypes.DIVV),
     (Pervasives.MOD, MirTypes.BCALC MirTypes.MODS)]
*)

  val initial_prim_test_env =
    [(Pervasives.REALLESS, FTEST(MirTypes.FBLT, false)),
     (Pervasives.REALGREATER, FTEST(MirTypes.FBLE, true)),
     (Pervasives.REALLESSEQ, FTEST(MirTypes.FBLE, false)),
     (Pervasives.REALGREATEREQ, FTEST(MirTypes.FBLT, true)),
     (Pervasives.REALEQ, FTEST(MirTypes.FBNE, true)),
     (Pervasives.REALNE, FTEST(MirTypes.FBEQ, true)),
     (Pervasives.INTLESS, ITEST MirTypes.BGE),
     (Pervasives.INTGREATER, ITEST MirTypes.BLE),
     (Pervasives.INTLESSEQ, ITEST MirTypes.BGT),
     (Pervasives.INTGREATEREQ, ITEST MirTypes.BLT),
     (Pervasives.INTEQ, ITEST MirTypes.BNE),
     (Pervasives.INTNE, ITEST MirTypes.BEQ)]

@


1.7
log
@Changed to use pervasives
@
text
@d4 3
d67 1
a67 1
    LAMBDA_ENV of (LambdaTypes.LVar, MirTypes.reg_operand) Map.Map
d70 1
d74 1
d100 1
d103 1
d111 1
d124 1
@


1.6
log
@Updated for later version of HARP
@
text
@d4 3
d33 1
d46 1
d56 1
d67 2
a68 2
  datatype Prim_Calc_Env =
    PRIM_CALC_ENV of (LambdaTypes.Primitive, MirTypes.calc_op) Map.Map
d74 2
a75 3
  datatype Prim_Test_Env =
    PRIM_TEST_ENV of
    (LambdaTypes.Primitive, test) Map.Map
d86 13
a98 8
  fun add_prim_calc_env((prim, calc_op), PRIM_CALC_ENV env) =
    PRIM_CALC_ENV(Map.add((prim, calc_op), env, LambdaTypes.Prim_order))
  fun lookup_prim_calc(prim, PRIM_CALC_ENV env) = Map.lookup(prim, env)
  fun is_prim_calc(prim, PRIM_CALC_ENV env) = Map.domain_member(prim, env)
  fun add_prim_test_env((prim, test_op), PRIM_TEST_ENV env) =
    PRIM_TEST_ENV(Map.add((prim, test_op), env, LambdaTypes.Prim_order))
  fun lookup_prim_test(prim, PRIM_TEST_ENV env) = Map.lookup(prim, env)
  fun is_prim_test(prim, PRIM_TEST_ENV env) = Map.domain_member(prim, env)
a103 25
  val calc_translations = map (fn (x, y) => (prim_from_name x, y))
    [("/", MirTypes.BFCALC MirTypes.FDIV),
     ("_real+", MirTypes.BFCALC MirTypes.FADD),
     ("_real*", MirTypes.BFCALC MirTypes.FMUL),
     ("_real~", MirTypes.UFCALC MirTypes.FNEG),
     ("_real-", MirTypes.BFCALC MirTypes.FSUB),
     ("_int+", MirTypes.TBCALC MirTypes.ADDV),
     ("_int*", MirTypes.TBCALC MirTypes.MULV),
     ("_int~", MirTypes.NCALC MirTypes.SUBV),
     ("_int-", MirTypes.TBCALC MirTypes.SUBV),
     ("div", MirTypes.TBCALC MirTypes.DIVV),
     ("mod", MirTypes.BCALC MirTypes.MODS)]
  val test_translations = map (fn (x, y) => (prim_from_name x, y))
    [("_real<", FTEST(MirTypes.FBLT, false)),
     ("_real>", FTEST(MirTypes.FBLE, true)),
     ("_real<=", FTEST(MirTypes.FBLE, false)),
     ("_real>=", FTEST(MirTypes.FBLT, true)),
     ("_real=", FTEST(MirTypes.FBNE, true)),
     ("_real<>", FTEST(MirTypes.FBEQ, true)),
     ("_int<", ITEST MirTypes.BGE),
     ("_int>", ITEST MirTypes.BLE),
     ("_int<=", ITEST MirTypes.BGT),
     ("_int>=", ITEST MirTypes.BLT),
     ("_int=", ITEST MirTypes.BNE),
     ("_int<>", ITEST MirTypes.BEQ)]
d105 12
a116 2
    foldleft add_prim_calc_env
    (PRIM_CALC_ENV(Map.empty_map), calc_translations)
d118 13
a130 2
    foldleft add_prim_test_env
    (PRIM_TEST_ENV(Map.empty_map), test_translations)
@


1.5
log
@Added encodings for unary minus
@
text
@d4 3
d56 1
d60 1
d63 5
d70 2
a71 1
    (LambdaTypes.Primitive, (MirTypes.calc_op * MirTypes.branch)) Map.Map
d95 11
a105 11
    [("/", MirTypes.BFCALC MirTypes.DIVF),
     ("_real+", MirTypes.BFCALC MirTypes.ADDF),
     ("_real*", MirTypes.BFCALC MirTypes.MULF),
     ("_real~", MirTypes.UFCALC MirTypes.NEGF),
     ("_real-", MirTypes.BFCALC MirTypes.SUBF),
     ("_int+", MirTypes.BCALC MirTypes.ADD),
     ("_int*", MirTypes.BCALC MirTypes.MUL),
     ("_int~", MirTypes.UCALC MirTypes.NEG),
     ("_int-", MirTypes.BCALC MirTypes.SUB),
     ("div", MirTypes.BCALC MirTypes.DIV),
     ("mod", MirTypes.BCALC MirTypes.REM)]
d107 12
a118 12
    [("_real<", (MirTypes.UFCALC MirTypes.CMPF, MirTypes.BGE)),
     ("_real>", (MirTypes.UFCALC MirTypes.CMPF, MirTypes.BLE)),
     ("_real<=", (MirTypes.UFCALC MirTypes.CMPF, MirTypes.BGT)),
     ("_real>=", (MirTypes.UFCALC MirTypes.CMPF, MirTypes.BLT)),
     ("_real=", (MirTypes.UFCALC MirTypes.CMPF, MirTypes.BEQ)),
     ("_real<>", (MirTypes.UFCALC MirTypes.CMPF, MirTypes.BNE)),
     ("_int<", (MirTypes.UCALC MirTypes.CMP, MirTypes.BGE)),
     ("_int>", (MirTypes.UCALC MirTypes.CMP, MirTypes.BGE)),
     ("_int<=", (MirTypes.UCALC MirTypes.CMP, MirTypes.BGE)),
     ("_int>=", (MirTypes.UCALC MirTypes.CMP, MirTypes.BGE)),
     ("_int=", (MirTypes.UCALC MirTypes.CMP, MirTypes.BEQ)),
     ("_int<>", (MirTypes.UCALC MirTypes.CMP, MirTypes.BNE))]
@


1.4
log
@Added special constant equality functions
@
text
@d4 3
d87 1
d91 1
@


1.3
log
@Added closure environment
@
text
@d4 3
d95 2
d100 9
a108 3
     ("_int>=", (MirTypes.UCALC MirTypes.CMP, MirTypes.BGE))]
  val initial_prim_calc_env = foldleft add_prim_calc_env (PRIM_CALC_ENV(Map.empty_map), calc_translations)
  val initial_prim_test_env = foldleft add_prim_test_env (PRIM_TEST_ENV(Map.empty_map), test_translations)
@


1.2
log
@Added empty_lambda_env
@
text
@d4 3
d55 3
d98 4
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d46 1
@
