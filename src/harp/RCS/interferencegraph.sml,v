head	1.4;
access;
symbols
	ML_final_beta_release_02/03/94:1.4
	mlworks-28-01-1994:1.4
	Release:1.4
	mlworks-beta-01-09-1993:1.4
	MLWorks-1-0-4-29/01/1993:1.4
	MLWorks-1-0-3-21/12/1992:1.4
	MLWorks-1-0-2-15/12/1992:1.4
	MLWorks-1-0-1-04/12/1992:1.4
	checkpoint_17_08_92:1.4;
locks; strict;
comment	@ *  @;


1.4
date	92.01.21.12.00.54;	author richard;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	91.12.03.15.16.39;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.11.25.14.11.55;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	91.11.21.16.38.01;	author richard;	state Exp;
branches;
next	;

1.4.1.1
date	92.01.21.12.00.54;	author jont;	state Exp;
branches;
next	;


desc
@Signature of the register interference graph module.
@


1.4
log
@Added missing require of array.
@
text
@(*  ==== REGISTER INTERFERENCE GRAPH ====
 *               SIGNATURE
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  The register interference graph contains information about the
 *  relationship between virtual registers.  This information is used to
 *  remove unnecessary MOVE instructions and to decide which virtual
 *  registers can be allocated to which real registers.
 *
 *  The graph is usually large and sparse, and very inefficient to build
 *  functionally, since old version of the graph are never really used, and
 *  the graph changes much while it is being built.  Therefore, this module
 *  uses imperative ML for efficiency.  See the functor documentation for
 *  more details.
 *
 *  Diagnostic output levels (see ../utils/diagnostic.sml)
 *  ------------------------
 *   0  none
 *   1  vertices added to the graph, empty graphs built
 *   2  graph after adding, and the adjacency array when colouring
 *
 *  Revision Log
 *  ------------
 *  $Log: interferencegraph.sml,v $
 *  Revision 1.3  1991/12/03  15:16:39  richard
 *  Added isolate and connect.
 *
 *  Revision 1.2  91/11/25  14:11:55  richard
 *  Added some functions to allow other modules to print graphs.
 *  
 *  Revision 1.1  91/11/21  16:38:01  richard
 *  Initial revision
 *)


require "../utils/diagnostic";
require "../utils/array";


signature INTERFERENCEGRAPH =

  sig

    structure Array	: ARRAY
    structure Diagnostic	: DIAGNOSTIC



    (*  === THE GRAPH TYPE ===  *)

    type 'vertex T



    (*  === CONSTRUCT AN EMPTY GRAPH ===
     *
     *  An empty graph is constructed from a record with the following
     *  fields:
     *    pack    A one-to-one contiguous packing function for the graph
     *            contents (usually registers).  The range of the function
     *            should be from zero to `range'-1, see below.
     *    range	  The largest integer returned by `pack', plus one.
     *    unpack  The inverse function of `pack'.
     *)

    val empty :
      {range	: int,
       pack	: 'vertex -> int,
       unpack	: int -> 'vertex} -> 'vertex T

       

    (*  === ADD INTERFERENCE EDGES ===
     *
     *  Updates an interference graph by adding an edge between all the
     *  elements in the list provided.  For register allocation, this means
     *  that none of the elements in the list may share a register.
     *)

    val add_edges	: 'vertex T * 'vertex list -> unit



    (*  === INDIVIDUAL VERTEX MODIFICATION ===
     *
     *  When the use of a particular register is changed drastically (for
     *  example, it is spilled) it is useful to change the part of the graph
     *  relating to it and it only.  The function `isolate' deletes all
     *  edges connecting a particular vertex to others, and the function
     *  `connect' adds an edge from a particular vertex to a list of others.
     *)

    val isolate : 'vertex T * 'vertex -> unit
    val connect : 'vertex T * 'vertex * 'vertex list -> unit



    (*  === CONVERT GRAPH INTO STRINGS ===
     *
     *  These two functions convert a graph into a list of strings which,
     *  when printed one after the other, will display the graph.  The first
     *  shows the graph as an adjacency matrix, the second shows it as a set
     *  of adjacency lists.
     *)

    val strings_of_graph_matrix : 'vertex T -> string list
    val strings_of_graph_lists :
      ('vertex -> string) -> 'vertex T -> string list



    (*  === COLOUR THE GRAPH ===
     *
     *  Parameters:
     *    graph    the graph to colour
     *    choose   a colour choosing function, see below
     *    state    an initial state for the choosing function
     *    colours  a list of (vertex, colour) pairs for any vertices which
     *             are already coloured.  These are not checked for
     *             validity.
     *
     *  The colour chooser is passed a vertex, an array of colours it
     *  cannot use for the vertex, and the state it returned last time it
     *  was called.  It must make a decision as to the colour of the vertex
     *  and return that, together with a state for next time.  The colour
     *  chooser may return NONE to indicate that it couldn't colour the
     *  vertex, or even raise an exception to terminate the colouring
     *  process.
     *
     *  Note: The length of the array passed to the choose function isn't
     *  necessarily the number of colours in the array.  Use the length
     *  field of the record passed.
     *
     *  The colourer returns an list of (vertex, colour) pairs and a list of
     *  uncloured vertices.
     *)

    datatype '_colour colour = COLOUR of '_colour | NONE

    val colour :
      {graph   : 'vertex T,
       choose  : {vertex   : 'vertex,
		  state    : 'state,
		  adjacent : '_colour colour Array.array,
		  length   : int} -> '_colour colour * 'state,
       state   : 'state,
       colours : ('vertex * '_colour) list} ->
      ('vertex * '_colour) list * 'vertex list


  end
@


1.4.1.1
log
@Fork for bug fixing
@
text
@a27 3
 *  Revision 1.4  1992/01/21  12:00:54  richard
 *  Added missing require of array.
 *
@


1.3
log
@Added isolate and connect.
@
text
@d27 4
a30 1
 *  $Log:	interferencegraph.sml,v $
d40 1
@


1.2
log
@Added some functions to allow other modules to print graphs.
@
text
@d28 3
d80 14
@


1.1
log
@Initial revision
@
text
@d19 11
a29 1
 *  Revision Log: $Log$
a40 7

    (* Diagnostic output levels:
     *   0  none
     *   1  vertices added to the graph
     *   2  graph after adding, and the adjacency array when colouring
     *)

d77 14
@
