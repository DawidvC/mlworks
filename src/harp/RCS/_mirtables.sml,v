head	1.51;
access;
symbols
	MLW_daveb_inline_1_4_99:1.51.3
	MLWorks_21c0_1999_03_25:1.51
	MLWorks_20c1_1998_08_20:1.51
	MLWorks_20c0_1998_08_04:1.51
	MLWorks_20b2c2_1998_06_19:1.51
	MLWorks_20b2_Windows_1998_06_12:1.51
	MLWorks_20b1c1_1998_05_07:1.51
	MLWorks_20b0_1998_04_07:1.51
	MLWorks_20b0_1998_03_20:1.51
	MLWorks_20m2_1998_02_16:1.51
	MLWorks_20m1_1997_10_23:1.51
	MLWorks_11r1:1.50.1.1.1.1.1
	MLWorks_workspace_97:1.51.2
	MLWorks_dt_wizard:1.51.1
	MLWorks_11c0_1997_09_09:1.50.1.1.1.1
	MLWorks_10r3:1.50.1.1.3
	MLWorks_10r2_551:1.50.1.1.2
	MLWorks_11:1.50.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.50.1.1
	MLWorks_20m0_1997_06_20:1.51
	MLWorks_1_0_r2c2_1997_06_14:1.50.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.50.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.50.1
	MLWorks_BugFix_1997_04_24:1.50
	MLWorks_1_0_r2_Win32_1997_04_11:1.50
	MLWorks_1_0_r2_Unix_1997_04_04:1.50
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.49.6.1.1
	MLWorks_gui_1996_12_18:1.49.7
	MLWorks_1_0_Win32_1996_12_17:1.49.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.49.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.49.4.1
	MLWorks_1_0_Irix_1996_11_28:1.49.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.49.5
	MLWorks_1_0_Unix_1996_11_14:1.49.4
	MLWorks_Open_Beta2_1996_10_11:1.49.3
	MLWorks_License_dev:1.49.2
	MLWorks_1_open_beta_1996_09_13:1.49.1
	MLWorks_Open_Beta_1996_08_22:1.49
	MLWorks_Beta_1996_07_02:1.49
	MLWorks_Beta_1996_06_07:1.49
	MLWorks_Beta_1996_06_06:1.49
	MLWorks_Beta_1996_06_05:1.49
	MLWorks_Beta_1996_06_03:1.49
	MLWorks_Beta_1996_05_31:1.49
	MLWorks_Beta_1996_05_30:1.49
	ML_beta_release_12/08/94:1.45
	ML_beta_release_03/08/94:1.45
	ML_revised_beta_release_25/05/94:1.44
	ML_final_beta_release_02/03/94:1.42
	mlworks-28-01-1994:1.42
	Release:1.40
	mlworks-beta-01-09-1993:1.40
	MLWorks-1-0-4-29/01/1993:1.36
	MLWorks-1-0-3-21/12/1992:1.36
	MLWorks-1-0-2-15/12/1992:1.36
	MLWorks-1-0-1-04/12/1992:1.36
	checkpoint_17_08_92:1.34;
locks; strict;
comment	@ * @;


1.51
date	97.05.13.13.06.08;	author jont;	state Exp;
branches
	1.51.1.1
	1.51.2.1
	1.51.3.1;
next	1.50;

1.50
date	97.01.17.12.56.08;	author jont;	state Exp;
branches
	1.50.1.1;
next	1.49;

1.49
date	95.05.23.09.53.16;	author matthew;	state Exp;
branches
	1.49.1.1
	1.49.2.1
	1.49.3.1
	1.49.4.1
	1.49.5.1
	1.49.6.1
	1.49.7.1;
next	1.48;

1.48
date	94.11.11.14.17.48;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	94.09.30.13.09.03;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	94.08.08.10.09.59;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	94.07.22.10.27.37;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	94.04.26.09.52.37;	author jont;	state Exp;
branches;
next	1.43;

1.43
date	94.03.04.12.31.54;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	93.11.04.18.01.44;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	93.11.01.16.31.32;	author nickh;	state Exp;
branches;
next	1.40;

1.40
date	93.08.05.10.22.46;	author richard;	state Exp;
branches
	1.40.1.1;
next	1.39;

1.39
date	93.07.29.11.32.21;	author richard;	state Exp;
branches;
next	1.38;

1.38
date	93.04.30.15.42.32;	author richard;	state Exp;
branches;
next	1.37;

1.37
date	93.04.28.15.52.26;	author richard;	state Exp;
branches;
next	1.36;

1.36
date	92.08.26.15.04.47;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	92.08.24.13.35.46;	author richard;	state Exp;
branches;
next	1.34;

1.34
date	92.07.27.09.53.47;	author richard;	state Exp;
branches;
next	1.33;

1.33
date	92.06.29.09.53.04;	author clive;	state Exp;
branches;
next	1.32;

1.32
date	92.06.18.16.12.43;	author richard;	state Exp;
branches;
next	1.31;

1.31
date	92.06.12.17.20.53;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	92.05.27.13.22.29;	author richard;	state Exp;
branches;
next	1.29;

1.29
date	92.04.13.15.13.43;	author clive;	state Exp;
branches;
next	1.28;

1.28
date	92.03.18.15.21.36;	author clive;	state Exp;
branches;
next	1.27;

1.27
date	92.02.12.13.59.53;	author richard;	state Exp;
branches;
next	1.26;

1.26
date	92.02.10.15.56.34;	author richard;	state Exp;
branches;
next	1.25;

1.25
date	92.01.31.10.03.02;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	92.01.16.11.22.37;	author clive;	state Exp;
branches;
next	1.23;

1.23
date	92.01.14.14.22.46;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	91.12.20.11.06.16;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	91.12.05.14.53.19;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	91.12.03.15.12.04;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	91.12.02.16.50.56;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	91.12.02.14.28.36;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	91.11.20.14.24.50;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	91.11.19.14.29.12;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	91.11.18.16.22.48;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	91.11.14.15.18.10;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	91.11.14.10.41.54;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	91.11.08.16.26.38;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	91.11.07.16.36.34;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	91.10.28.15.23.06;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	91.10.28.12.09.04;	author davidt;	state Exp;
branches;
next	1.8;

1.8
date	91.10.25.14.48.32;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	91.10.21.13.23.48;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.10.17.15.18.33;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.10.16.14.20.36;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.10.15.14.17.04;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.10.11.10.06.35;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.10.10.13.42.45;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	91.10.10.10.25.14;	author richard;	state Exp;
branches;
next	;

1.40.1.1
date	93.08.05.10.22.46;	author jont;	state Exp;
branches;
next	1.40.1.2;

1.40.1.2
date	93.11.01.16.23.55;	author nickh;	state Exp;
branches;
next	;

1.49.1.1
date	96.09.13.11.14.01;	author hope;	state Exp;
branches;
next	;

1.49.2.1
date	96.10.07.16.04.32;	author hope;	state Exp;
branches;
next	;

1.49.3.1
date	96.10.17.11.22.45;	author hope;	state Exp;
branches;
next	;

1.49.4.1
date	96.11.14.12.46.59;	author hope;	state Exp;
branches
	1.49.4.1.1.1;
next	;

1.49.4.1.1.1
date	96.11.28.14.58.35;	author hope;	state Exp;
branches;
next	;

1.49.5.1
date	96.11.22.18.07.07;	author hope;	state Exp;
branches;
next	;

1.49.6.1
date	96.12.17.17.45.51;	author hope;	state Exp;
branches
	1.49.6.1.1.1;
next	;

1.49.6.1.1.1
date	97.02.24.11.35.21;	author hope;	state Exp;
branches;
next	;

1.49.7.1
date	96.12.18.09.39.49;	author hope;	state Exp;
branches;
next	;

1.50.1.1
date	97.05.12.10.32.10;	author hope;	state Exp;
branches
	1.50.1.1.1.1
	1.50.1.1.2.1
	1.50.1.1.3.1;
next	;

1.50.1.1.1.1
date	97.07.28.18.17.55;	author daveb;	state Exp;
branches
	1.50.1.1.1.1.1.1;
next	;

1.50.1.1.1.1.1.1
date	97.10.07.11.42.53;	author jkbrook;	state Exp;
branches;
next	;

1.50.1.1.2.1
date	97.09.08.17.11.29;	author daveb;	state Exp;
branches;
next	;

1.50.1.1.3.1
date	97.09.09.14.07.05;	author daveb;	state Exp;
branches;
next	;

1.51.1.1
date	97.09.10.19.21.48;	author brucem;	state Exp;
branches;
next	;

1.51.2.1
date	97.09.11.20.53.03;	author daveb;	state Exp;
branches;
next	;

1.51.3.1
date	99.04.01.17.55.55;	author daveb;	state Exp;
branches;
next	;


desc
@Dataflow information tables for MIR code.
@


1.51
log
@[Bug #20038]
Add referenced_by_alloc
@
text
@(* mirtables.sml the functor *)
(*
$Log: _mirtables.sml,v $
 * Revision 1.50  1997/01/17  12:56:08  jont
 * Add in use of corrupted_by_alloc on ALLOCATE, SWITCH and ADR
 *
Revision 1.49  1995/05/23  09:53:16  matthew
Improving dynamic allocation

Revision 1.48  1994/11/11  14:17:48  jont
Add immediate store operations

Revision 1.47  1994/09/30  13:09:03  jont
Remove handler register concept

Revision 1.46  1994/08/08  10:09:59  matthew
Change to registers defined by call etc.

Revision 1.45  1994/07/22  10:27:37  matthew
Added function argument register lists to BRANCH_AND_LINK, TAIL_CALL and ENTER
These are used to calculate referenced_by and defined_by

Revision 1.44  1994/04/26  09:52:37  jont
Add handler to referenced set of RAISE

Revision 1.43  1994/03/04  12:31:54  jont
Changes for automatic_callee mechanism removal
and moving machspec from machine to main

Revision 1.42  1993/11/04  18:01:44  jont
Added handling of INTERRUPT instruction

Revision 1.41  1993/11/01  16:31:32  nickh
Merging in structure simplification.

Revision 1.40.1.2  1993/11/01  16:23:55  nickh
Removed unused substructures of MirTables

Revision 1.40.1.1  1993/08/05  10:22:46  jont
Fork for bug fixing

Revision 1.40  1993/08/05  10:22:46  richard
Remove bofus successors function.

Revision 1.39  1993/07/29  11:32:21  richard
Fixed RAISE to define the registers defined by calls, since
raising an exception will call a handler before continuing.

Revision 1.38  1993/04/30  15:42:32  richard
INTERCEPT defines the callee argument.

Revision 1.37  1993/04/28  15:52:26  richard
Changed PROFILE instruction to INTERCEPT.
INTERCEPT references the callee argument.

Revision 1.36  1992/08/26  15:04:47  jont
Removed some redundant structures and sharing

Revision 1.35  1992/08/24  13:35:46  richard
Added NULLARY opcode type and ALLOC_BYTEARRAY.

Revision 1.34  1992/07/27  09:53:47  richard
Changed calls to C to pass a single argument.

Revision 1.33  1992/06/29  09:53:04  clive
Added type annotation information at application points

Revision 1.32  1992/06/18  16:12:43  richard
Added parameter to RAISE once again.

Revision 1.31  1992/06/12  17:20:53  jont
Made PROFILER reference only the explicit register mentioned

Revision 1.30  1992/05/27  13:22:29  richard
Rewrote defined_by and referenced_by to return a triple of register
sets rather than a set of any_registers.

Revision 1.29  1992/04/13  15:13:43  clive
First version of the profiler

Revision 1.28  1992/03/18  15:21:36  clive
ALLOCATE may now take a register argument, added to referenced_by
Added global as defined_by ALLOCATE

Revision 1.27  1992/02/12  13:59:53  richard
Changed register types to reflect changes in MirTypes.
Removed obsolote `substitute' function.

Revision 1.26  1992/02/10  15:56:34  richard
Abolished PREVIOUS_ENVIRONMENT and PRESERVE_ALL_REGS.
Made defined_by more efficient in the case of call instructions.

Revision 1.26  1992/02/05  16:40:56  richard
Abolished PREVIOUS_ENVIRONMENT and PRESERVE_ALL_REGS.
Added corrupted_by.

Revision 1.25  1992/01/31  10:03:02  richard
Changed successors function to distinguish between normal branches
and exception raising.

Revision 1.24  1992/01/16  11:22:37  clive
Alloc may now have a register argument for allocating arrays

Revision 1.23  1992/01/14  14:22:46  jont
Raise no longer has a parameter

Revision 1.22  1991/12/20  11:06:16  richard
Added TBINARYFP to the defined_by function, and made this function
an exhaustive list of cases rather than having a catch-all clause.

Revision 1.21  91/12/05  14:53:19  richard
Added `exits' return from the successors function to show
whether an opcode might exit the procedure.

Revision 1.20  91/12/03  15:12:04  richard
Added successor case for FLOOR.  Added side effects = true for
tagged operations.

Revision 1.19  91/12/02  16:50:56  jont
Added successor information on TAIL_CALL

Revision 1.18  91/12/02  14:28:36  jont
Added tail call operation

Revision 1.17  91/11/20  14:24:50  jont
Added exception generating fp opcodes to tables.
Made matches explicitly exhaustive

Revision 1.16  91/11/19  14:29:12  richard
Changed debugging output to use the Diagnostic module, which
prevents the debugging output strings being constructed even
if they aren't printed.

Revision 1.15  91/11/18  16:22:48  jont
Fixed bug whereby tags in FTEST instructions weren't being followed

Revision 1.14  91/11/14  15:18:10  richard
Removed symbol substitution from substitute_registers.  Added code
for the new CALL_C opcode.

Revision 1.13  91/11/14  10:41:54  richard
Removed references to fp_double registers.

Revision 1.12  91/11/08  16:26:38  richard
Added offset argument to STACKOPs.

Revision 1.11  91/11/07  16:36:34  richard
Removed the assumption that POP has no side effects.

Revision 1.10  91/10/28  15:23:06  richard
Changed the form of the allocation instructions yet again.

Revision 1.9  91/10/28  12:09:04  davidt
ALLOCATE doesn't have a scratch register or a proc_ref any more.

Revision 1.8  91/10/25  14:48:32  richard
Added parameter to NoMapping exception to ease debugging.
Added generalized successors function to trace flow of control.

Revision 1.8  91/10/25  14:48:32  richard
Added a parameter to the NoMapping exception to ease debugging.

Revision 1.7  91/10/21  13:23:48  richard
Added missing BRANCH_AND_LINK clause to referenced_by.

Revision 1.6  91/10/17  15:18:33  jont
New style ALLOC opcodes

Revision 1.5  91/10/16  14:20:36  jont
Updated to reflect extra parameter on ALLOCATEs

Revision 1.4  91/10/15  14:17:04  richard
Moved substitute_registers here from the register allocator functor.

Revision 1.3  91/10/11  10:06:35  richard
Slight alterations to cope with new MirTypes.

Revision 1.2  91/10/10  13:42:45  richard
Removed RESTORE_REGS and PRESERVE_REGS and replaced by
PREVIOUS_ENVIRONMENT and parameterized ENTER. Added
parameterized RAISE.

Revision 1.1  91/10/10  10:25:14  richard
Initial revision

Revision 1.1  91/10/09  15:13:43  richard
Initial revision

Copyright (C) 1991 Harlequin Ltd
*)

require "../utils/lists";
require "../utils/crash";
require "mirregisters";
require "mirtables";

functor MirTables (
  structure MirRegisters: MIRREGISTERS
  structure Lists	: LISTS
  structure Crash	: CRASH
) : MIRTABLES =

  struct

    structure MirTypes = MirRegisters.MirTypes

    (*  === LOOK UP SETS OF REGISTERS DEFINED AND REFERENCED ===
     *
     *  Takes an opcode and generates the sets. It's basically a big
     *  look-up table. Some short-hand functions are used to reduce the
     *  size of the table.
     *
     *  NOTE: This table is now complete, I think.
     *)

    local
      open MirTypes

      fun pack {gc, non_gc, fp} =
        {gc     = MirTypes.GC.pack_set gc,
         non_gc = MirTypes.NonGC.pack_set non_gc,
         fp     = MirTypes.FP.pack_set fp}
        
      fun unpack {gc, non_gc, fp} =
        {gc     = MirTypes.GC.unpack_set gc,
         non_gc = MirTypes.NonGC.unpack_set non_gc,
         fp     = MirTypes.FP.unpack_set fp}
        
      val caller_arg = MirRegisters.caller_arg
      val callee_arg = MirRegisters.callee_arg
      val caller_closure = MirRegisters.caller_closure
      val callee_closure = MirRegisters.callee_closure
      val stack = MirRegisters.sp
      val frame = MirRegisters.fp
      val global = MirRegisters.global

      fun reg ({gc, non_gc, fp}, GC_REG r) =
          {gc = GC.Set.add (gc, r), non_gc = non_gc, fp = fp}
        | reg ({gc, non_gc, fp}, NON_GC_REG r) =
          {gc = gc, non_gc = NonGC.Set.add (non_gc, r), fp = fp}

      fun single_reg (GC_REG r) =
          {gc = GC.Set.singleton r, non_gc = NonGC.Set.empty, fp = FP.Set.empty}
        | single_reg (NON_GC_REG r) =
          {gc = GC.Set.empty, non_gc = NonGC.Set.singleton r, fp = FP.Set.empty}

      fun gp ({gc, non_gc, fp}, GP_GC_REG r) =
          {gc = GC.Set.add (gc, r), non_gc = non_gc, fp = fp}
        | gp ({gc, non_gc, fp}, GP_NON_GC_REG r) =
          {gc = gc, non_gc = NonGC.Set.add (non_gc, r), fp = fp}
        | gp (sets, _) = sets

      fun fp ({gc, non_gc, fp}, FP_REG r) =
          {gc = gc, non_gc = non_gc, fp = FP.Set.add (fp, r)}

      fun single_fp (FP_REG r) =
          {gc = GC.Set.empty, non_gc = NonGC.Set.empty, fp = FP.Set.singleton r}

      val empty = {gc = GC.Set.empty, non_gc = NonGC.Set.empty, fp = FP.Set.empty}

      val defined_by_call = reg (unpack MirRegisters.corrupted_by_callee, GC_REG caller_arg)

      val defined_by_alloc = unpack MirRegisters.corrupted_by_alloc
      val referenced_by_alloc = unpack MirRegisters.referenced_by_alloc

      fun merge_any_registers ([],acc) = acc
        | merge_any_registers (GC reg::rest, {gc,non_gc,fp}) =
          merge_any_registers (rest,{gc=GC.Set.add (gc,reg),non_gc=non_gc,fp=fp})
        | merge_any_registers (NON_GC reg::rest, {gc,non_gc,fp}) =
          merge_any_registers (rest,{gc=gc,non_gc=NonGC.Set.add (non_gc,reg),fp=fp})
        | merge_any_registers (FLOAT reg::rest, {gc,non_gc,fp}) =
          merge_any_registers (rest,{gc=gc,non_gc=non_gc,fp=FP.Set.add (fp,reg)})

      val always_referenced_by_call =
        {gc = GC.Set.from_list [caller_closure, stack, frame],
         non_gc = NonGC.Set.empty,
         fp = FP.Set.empty}

      fun referenced_by_call regs =
        merge_any_registers (regs,always_referenced_by_call)

      val always_referenced_by_tail =
        {gc = GC.Set.from_list [MirRegisters.tail_closure,
                                stack, frame],
         non_gc = NonGC.Set.empty,
         fp = FP.Set.empty}

      fun referenced_by_tail regs =
        merge_any_registers (regs,always_referenced_by_tail)

      val always_defined_on_entry = unpack MirRegisters.defined_on_entry

      fun defined_on_entry regs =
        merge_any_registers (regs,always_defined_on_entry)

      val defined_on_exit = unpack MirRegisters.defined_on_exit
    in

      fun defined_by (ENTER regs)                    = defined_on_entry regs
	| defined_by INTERCEPT                       = single_reg (GC_REG callee_arg)
	| defined_by INTERRUPT                       = empty
	| defined_by (UNARY(_, reg1, _))             = single_reg reg1
	| defined_by (NULLARY(_, reg1))              = single_reg reg1
	| defined_by (BINARY(_, reg1, _, _))         = single_reg reg1
	| defined_by (TBINARY(_, _, reg1, _, _))     = single_reg reg1
	| defined_by (BINARYFP(_, fp1, _, _))        = single_fp fp1
	| defined_by (TBINARYFP(_, _, fp1, _, _))    = single_fp fp1
	| defined_by (UNARYFP(_, fp1, _))            = single_fp fp1
	| defined_by (TUNARYFP(_, _, fp1, _))        = single_fp fp1
	| defined_by (STACKOP(POP, reg1, _))         = single_reg reg1
	| defined_by (STACKOP(PUSH, _, _))           = empty
	| defined_by (STOREOP(LD, reg1, _, _))       = single_reg reg1
        | defined_by (STOREOP(ST, _, _, _))          = empty
        | defined_by (IMMSTOREOP(ST, _, _, _))       = empty
	| defined_by (STOREFPOP(FLD, fp1, _, _))     = single_fp fp1
        | defined_by (STOREFPOP(FST, _, _, _))       = empty
	| defined_by (STOREFPOP(FLDREF, fp1, _, _))  = single_fp fp1
        | defined_by (STOREFPOP(FSTREF, _, _, _))    = empty
	| defined_by (STOREOP(LDREF, reg1, _, _))    = single_reg reg1
        | defined_by (STOREOP(STREF, _, _, _))       = empty
        | defined_by (IMMSTOREOP(STREF, _, _, _))    = empty
	| defined_by (STOREOP(LDB, reg1, _, _))      = single_reg reg1
        | defined_by (STOREOP(STB, _, _, _))         = empty
        | defined_by (IMMSTOREOP(STB, _, _, _))      = empty
        | defined_by (IMMSTOREOP _)                  =
	  Crash.impossible"STORE immediate without a store"
	| defined_by (REAL(ITOF, fp1, _))            = single_fp fp1
	| defined_by (FLOOR(FTOI, _, reg1, _))       = single_reg reg1
        (* Adding gp1 is a sort of hack to prevent reg1 and gp1 being coloured together *)
	| defined_by (ALLOCATE(_, reg1,gp1))         = reg (reg (gp (defined_by_alloc, gp1), GC_REG global), reg1)
	| defined_by (ALLOCATE_STACK(_, reg1, _, _)) = single_reg reg1
	| defined_by (ADR(_, reg1, _))               = reg(defined_by_alloc, reg1)
	| defined_by (BRANCH_AND_LINK _)             = defined_by_call
	| defined_by CALL_C                          = defined_by_call
        | defined_by (BRANCH _)                      = empty
        | defined_by (TEST _)                        = empty
        | defined_by (FTEST _)                       = empty
        | defined_by (TAIL_CALL _)                   = empty
        | defined_by (SWITCH _)                      = defined_by_alloc
        | defined_by (DEALLOCATE_STACK _)            = empty
        | defined_by RTS                             = empty
        | defined_by (NEW_HANDLER _)                 = empty
        | defined_by OLD_HANDLER                     = empty
        | defined_by (RAISE _)                       = defined_by_call
        | defined_by (COMMENT _)                     = empty


      fun referenced_by RTS                                 = defined_on_exit
	| referenced_by (BRANCH_AND_LINK(_,REG reg1,_,args))= reg (referenced_by_call args, reg1)
	| referenced_by (BRANCH_AND_LINK(_,_,_,args))       = referenced_by_call args
	| referenced_by (TAIL_CALL(_, REG reg1,args))       = reg (referenced_by_tail args, reg1)
	| referenced_by (TAIL_CALL (_,_,args))              = referenced_by_tail args
	| referenced_by (UNARY(_, _, gp2))                  = gp (empty, gp2)
	| referenced_by (UNARYFP(_, _, fp2))                = single_fp fp2
	| referenced_by (TUNARYFP(_, _, _, fp2))            = single_fp fp2
	| referenced_by (BINARY(_, _, gp2, gp3))            = gp (gp (empty, gp2), gp3)
	| referenced_by (BINARYFP(_, _, fp2, fp3))          = fp (single_fp fp2, fp3)
	| referenced_by (TBINARYFP(_, _, _, fp2, fp3))      = fp (single_fp fp2, fp3)
	| referenced_by (TBINARY(_, _, _, gp2, gp3))        = gp (gp (empty, gp2), gp3)
	| referenced_by (STACKOP(PUSH, reg1, _))            = single_reg reg1
	| referenced_by (STACKOP(POP, _, _))                = empty
	| referenced_by (STOREOP(ST, reg1, reg2, gp3))      = gp (reg (single_reg reg1, reg2), gp3)
	| referenced_by (IMMSTOREOP(ST, gp1, reg2, gp3))    = gp (reg (gp(empty, gp1), reg2), gp3)
	| referenced_by (STOREOP(LD, _, reg2, gp3))         = gp (single_reg reg2, gp3)
	| referenced_by (STOREOP(STREF, reg1, reg2, gp3))   = gp (reg (single_reg reg1, reg2), gp3)
	| referenced_by (IMMSTOREOP(STREF, gp1, reg2, gp3)) = gp (reg (gp(empty, gp1), reg2), gp3)
	| referenced_by (STOREOP(LDREF, _, reg2, gp3))      = gp (single_reg reg2, gp3)
	| referenced_by (STOREOP(STB, reg1, reg2, gp3))     = gp (reg (single_reg reg1, reg2), gp3)
	| referenced_by (IMMSTOREOP(STB, gp1, reg2, gp3))   = gp (reg (gp(empty, gp1), reg2), gp3)
	| referenced_by (STOREOP(LDB, _, reg2, gp3))        = gp (single_reg reg2, gp3)
	| referenced_by (IMMSTOREOP _)                      =
	  Crash.impossible"STORE immediate without a store"
	| referenced_by (STOREFPOP(FST, fp1, reg2, gp3))    = gp (fp (single_reg reg2, fp1), gp3)
	| referenced_by (STOREFPOP(FSTREF, fp1, reg2, gp3)) = gp (fp (single_reg reg2, fp1), gp3)
	| referenced_by (STOREFPOP(FLD, _, reg2, gp3))      = gp (single_reg reg2, gp3)
	| referenced_by (STOREFPOP(FLDREF, _, reg2, gp3))   = gp (single_reg reg2, gp3)
	| referenced_by (REAL(ITOF, _, gp2))                = gp (empty, gp2)
	| referenced_by (FLOOR(FTOI, _, _, fp1))            = single_fp fp1
	| referenced_by (BRANCH(_, REG reg1))               = single_reg reg1
	| referenced_by (BRANCH _)                          = empty
	| referenced_by (TEST(_, _, gp1, gp2))              = gp (gp (empty, gp2), gp1)
	| referenced_by (FTEST(_, _, fp1, fp2))             = fp (single_fp fp1, fp2)
	| referenced_by (SWITCH(_, reg1, _))                = single_reg reg1
	| referenced_by (COMMENT _)                         = empty
	| referenced_by (ENTER _)                           = empty
	| referenced_by INTERCEPT                           = single_reg (GC_REG callee_arg)
	| referenced_by INTERRUPT                           = empty
	| referenced_by (NEW_HANDLER(frame, _)) =
	  single_reg frame
	| referenced_by OLD_HANDLER                         = empty
        | referenced_by (ALLOCATE (_, _, gp1))              = gp (referenced_by_alloc, gp1)
	| referenced_by (ALLOCATE_STACK _)                  = empty
	| referenced_by (DEALLOCATE_STACK _)                = empty
	| referenced_by (ADR _)                             = empty
	| referenced_by (NULLARY _)                         = empty
	| referenced_by CALL_C =
          {gc = GC.Set.from_list [caller_arg, stack, frame],
           non_gc = NonGC.Set.empty,
           fp = FP.Set.empty}
	| referenced_by (RAISE reg1) =
          reg ({gc = GC.Set.from_list [stack, frame],
                non_gc = NonGC.Set.empty,
                fp = FP.Set.empty}, reg1)

    end



    (*  === DOES AN OPCODE HAVE SIDE EFFECTS? ===
     *
     *  Returns true if the opcode does more than just define a
     *  register.
     *)

    local
      open MirTypes
    in

      fun has_side_effects (BINARY _) = false
	| has_side_effects (UNARY _) = false
	| has_side_effects (BINARYFP _) = false
	| has_side_effects (UNARYFP _) = false
	| has_side_effects (STOREOP(LD, _, _, _)) = false
	| has_side_effects (STOREOP(LDB, _, _, _)) = false
	| has_side_effects (STOREOP(LDREF, _, _, _)) = false
	| has_side_effects (REAL _) = false
	| has_side_effects (ALLOCATE _) = false
	| has_side_effects (ALLOCATE_STACK _) = false
	| has_side_effects (ADR _) = false
	| has_side_effects _ = true
    end

  end
@


1.51.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.51  1997/05/13  13:06:08  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
@


1.51.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.51  1997/05/13  13:06:08  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
@


1.51.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.51  1997/05/13  13:06:08  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
@


1.50
log
@Add in use of corrupted_by_alloc on ALLOCATE, SWITCH and ADR
@
text
@d4 3
d264 1
d391 1
a391 1
        | referenced_by (ALLOCATE (_, _, gp1))              = gp (empty, gp1)
@


1.50.1.1
log
@branched from 1.50
@
text
@a3 3
 * Revision 1.50  1997/01/17  12:56:08  jont
 * Add in use of corrupted_by_alloc on ALLOCATE, SWITCH and ADR
 *
@


1.50.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.50.1.1  1997/05/12  10:32:10  hope
 * branched from 1.50
 *
@


1.50.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.50.1.1  1997/05/12  10:32:10  hope
 * branched from 1.50
 *
@


1.50.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.50.1.1  1997/05/12  10:32:10  hope
 * branched from 1.50
 *
@


1.50.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.50.1.1.1.1  1997/07/28  18:17:55  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.49
log
@Improving dynamic allocation
@
text
@d4 3
d260 2
d326 1
a326 1
	| defined_by (ALLOCATE(_, reg1,gp1))         = reg (reg (gp (empty, gp1), GC_REG global), reg1)
d328 1
a328 1
	| defined_by (ADR(_, reg1, _))               = single_reg reg1
d335 1
a335 1
        | defined_by (SWITCH _)                      = empty
@


1.49.7.1
log
@branched from 1.49
@
text
@a3 3
 * Revision 1.49  1995/05/23  09:53:16  matthew
 * Improving dynamic allocation
 *
@


1.49.6.1
log
@branched from 1.49
@
text
@a3 3
 * Revision 1.49  1995/05/23  09:53:16  matthew
 * Improving dynamic allocation
 *
@


1.49.6.1.1.1
log
@branched from 1.49.6.1
@
text
@a3 3
 * Revision 1.49.6.1  1996/12/17  17:45:51  hope
 * branched from 1.49
 *
@


1.49.5.1
log
@branched from 1.49
@
text
@a3 3
 * Revision 1.49  1995/05/23  09:53:16  matthew
 * Improving dynamic allocation
 *
@


1.49.4.1
log
@branched from 1.49
@
text
@a3 3
 * Revision 1.49  1995/05/23  09:53:16  matthew
 * Improving dynamic allocation
 *
@


1.49.4.1.1.1
log
@branched from 1.49.4.1
@
text
@a3 3
 * Revision 1.49.4.1  1996/11/14  12:46:59  hope
 * branched from 1.49
 *
@


1.49.3.1
log
@branched from 1.49
@
text
@a3 3
 * Revision 1.49  1995/05/23  09:53:16  matthew
 * Improving dynamic allocation
 *
@


1.49.2.1
log
@branched from 1.49
@
text
@a3 3
 * Revision 1.49  1995/05/23  09:53:16  matthew
 * Improving dynamic allocation
 *
@


1.49.1.1
log
@branched from 1.49
@
text
@a3 3
 * Revision 1.49  1995/05/23  09:53:16  matthew
 * Improving dynamic allocation
 *
@


1.48
log
@Add immediate store operations
@
text
@d4 3
d320 2
a321 1
	| defined_by (ALLOCATE(_, reg1, _))          = reg (reg (empty, GC_REG global), reg1)
@


1.47
log
@Remove handler register concept
@
text
@d4 3
d302 1
d309 1
d312 3
d350 1
d353 1
d356 1
d358 2
@


1.46
log
@Change to registers defined by call etc.
@
text
@d4 3
a222 1
      val handler = MirRegisters.handler
d260 1
a260 1
        {gc = GC.Set.from_list [caller_closure, stack, frame, handler],
d269 1
a269 1
                                stack, frame, handler],
d362 2
a363 1
	| referenced_by (NEW_HANDLER _)                     = empty
d375 1
a375 1
          reg ({gc = GC.Set.from_list [stack, frame, handler],
@


1.45
log
@Added function argument register lists to BRANCH_AND_LINK, TAIL_CALL and ENTER
These are used to calculate referenced_by and defined_by
@
text
@d4 4
d258 1
a258 1
        {gc = GC.Set.from_list [caller_arg, caller_closure, stack, frame, handler],
d266 1
a266 1
        {gc = GC.Set.from_list [MirRegisters.tail_arg, MirRegisters.tail_closure,
@


1.44
log
@Add handler to referenced set of RAISE
@
text
@d4 3
d245 9
a253 1
      val referenced_by_call =
d258 4
a261 1
      val referenced_by_tail =
d267 8
a274 1
      val defined_on_entry = unpack MirRegisters.defined_on_entry
d278 1
a278 1
      fun defined_by ENTER                           = defined_on_entry
d322 4
a325 4
	| referenced_by (BRANCH_AND_LINK(_, REG reg1,_))    = reg (referenced_by_call, reg1)
	| referenced_by (BRANCH_AND_LINK _)                 = referenced_by_call
	| referenced_by (TAIL_CALL(_, REG reg1))            = reg (referenced_by_tail, reg1)
	| referenced_by (TAIL_CALL _)                       = referenced_by_tail
d353 1
a353 1
	| referenced_by ENTER                               = empty
@


1.43
log
@Changes for automatic_callee mechanism removal
and moving machspec from machine to main
@
text
@d4 4
d347 1
a347 1
          reg ({gc = GC.Set.from_list [stack, frame],
@


1.42
log
@Added handling of INTERRUPT instruction
@
text
@d4 3
d244 1
a244 2
        {gc = GC.Set.from_list [if MirRegisters.automatic_callee then callee_arg else caller_arg,
                                if MirRegisters.automatic_callee then callee_closure else caller_closure,
@


1.41
log
@Merging in structure simplification.
@
text
@d4 3
d253 1
d328 1
@


1.40
log
@Remove bofus successors function.
@
text
@d4 9
a161 1
require "../utils/table";
a168 1
  structure Table	: TABLE
a173 4
    structure Option = MirRegisters.Option
    structure Set = MirTypes.Set
    structure Table = Table

@


1.40.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.40  1993/08/05  10:22:46  richard
Remove bofus successors function.

@


1.40.1.2
log
@Removed unused substructures of MirTables
@
text
@a3 3
Revision 1.40.1.1  1993/08/05  10:22:46  jont
Fork for bug fixing

d156 1
d164 1
d170 4
@


1.39
log
@Fixed RAISE to define the registers defined by calls, since
raising an exception will call a handler before continuing.
@
text
@d4 4
a362 170
    end



    (*  === FIND SUCCESSORS OF AN OPCODE ===
     *
     *  The flow state is a list of local exception handler blocks
     *  which are in force at the time of the opcode.
     *)

    type flow_state = MirTypes.tag list

    fun handler [] = Option.ABSENT
      | handler (handler::_) = Option.PRESENT handler

    val procedure_entry_flow_state = []

    datatype path = NORMAL | EXCEPTION

    local
      open MirTypes
    in

      fun successors (handlers, opcode as BRANCH(_, TAG tag)) =
	  {flow_state = handlers,
	   opcode = opcode,
	   next = false,
           exits = false,
	   successors = [(NORMAL, tag)]}

        | successors ([], opcode as TAIL_CALL(_, TAG tag)) =
	  {flow_state = [],
	   opcode = opcode,
	   next = false,
           exits = true,
	   successors = []}

        | successors ([], opcode as TAIL_CALL(_, REG _)) =
	  {flow_state = [],
	   opcode = opcode,
	   next = false,
           exits = true,
	   successors = []}

        | successors (_, TAIL_CALL _) =
	  Crash.impossible
          ("MirOptimiser (Tables): A tail call has been found while " ^
           "a local exception handler is in force.")

	| successors ([], opcode as RTS) =
	  {flow_state = [],
	   opcode = opcode,
	   next = false,
           exits = true,
	   successors = []}

	| successors (_, RTS) =
          Crash.impossible
          ("MirOptimiser (Tables): A procedure exit has been found while " ^
           "a local exception handler is in force.")

	| successors (handlers, opcode as SWITCH(_, _, tags as [tag])) =
	  {flow_state = handlers,
	   opcode = BRANCH(BRA, TAG tag),
	   next = false,
           exits = false,
	   successors = [(NORMAL, tag)]}

	| successors (handlers, opcode as SWITCH(_, _, tags)) =
	  {flow_state = handlers,
	   opcode = opcode,
	   next = false,
           exits = false,
	   successors = map (fn tag => (NORMAL, tag)) tags}

	| successors (handlers, opcode as TEST(_, tag, _, _)) =
	  {flow_state = handlers,
	   opcode = opcode,
	   next = true,
           exits = false,
	   successors = [(NORMAL, tag)]}

	| successors (handlers, opcode as FTEST(_, tag, _, _)) =
	  {flow_state = handlers,
	   opcode = opcode,
	   next = true,
           exits = false,
	   successors = [(NORMAL, tag)]}

	| successors (handlers, opcode as TBINARY(_, tag, _, _, _)) =
	  {flow_state = handlers,
	   opcode = opcode,
	   next = true,
           exits = false,
	   successors = [(NORMAL, tag)]}

	| successors (handlers, opcode as TBINARYFP(_, tag, _, _, _)) =
	  {flow_state = handlers,
	   opcode = opcode,
	   next = true,
           exits = false,
	   successors = [(NORMAL, tag)]}

	| successors (handlers, opcode as TUNARYFP(_, tag, _, _)) =
	  {flow_state = handlers,
	   opcode = opcode,
	   next = true,
           exits = false,
	   successors = [(NORMAL, tag)]}

	| successors (handlers, opcode as FLOOR(_, tag, _, _)) =
	  {flow_state = handlers,
	   opcode = opcode,
	   next = true,
           exits = false,
	   successors = [(NORMAL, tag)]}

	| successors (handlers, opcode as NEW_HANDLER tag) =
	  {flow_state = tag::handlers,
	   opcode = opcode,
	   next = true,
           exits = false,
	   successors = []}

	| successors (_::handlers, opcode as OLD_HANDLER) =
	  {flow_state = handlers,
	   opcode = opcode,
	   next = true,
           exits = false,
	   successors = []}

	| successors (_, OLD_HANDLER) =
	  Crash.impossible ("MirTables: An OLD_HANDLER opcode was found " ^
			    "where no local handlers are in force.")

	| successors ([], opcode as RAISE _) =
	  {flow_state = [],
	   opcode = opcode,
	   next = false,
           exits = true,
	   successors = []}

	| successors (handlers as handler::_, opcode as RAISE _) =
	  {flow_state = handlers,
	   opcode = BRANCH(BRA, TAG handler),
	   next = false,
           exits = false,
	   successors = [(EXCEPTION, handler)]}

	| successors ([], opcode as BRANCH_AND_LINK _) =
	  {flow_state = [],
	   opcode = opcode,
	   next = true,
           exits = true,
	   successors = []}

	| successors (handlers as handler::_, opcode as BRANCH_AND_LINK _) =
	  {flow_state = handlers,
	   opcode = opcode,
	   next = true,
           exits = false,
	   successors = [(EXCEPTION, handler)]}

	| successors (handlers, opcode) =
	  {flow_state = handlers,
	   opcode = opcode,
	   next = true,
           exits = false,
	   successors = []}

@


1.38
log
@INTERCEPT defines the callee argument.
@
text
@d4 3
d279 1
a279 1
        | defined_by (RAISE _)                       = empty
@


1.37
log
@Changed PROFILE instruction to INTERCEPT.
INTERCEPT references the callee argument.
@
text
@d4 4
d239 1
a239 1
        | defined_by INTERCEPT                       = empty
@


1.36
log
@Removed some redundant structures and sharing
@
text
@d4 3
d235 1
a235 1
        | defined_by (PROFILER reg1)                 = single_reg reg1
d277 1
a277 1
	| referenced_by (BRANCH_AND_LINK(_, REG reg1,_))      = reg (referenced_by_call, reg1)
d309 1
a309 1
	| referenced_by (MirTypes.PROFILER _)               = single_reg (GC_REG callee_closure)
@


1.35
log
@Added NULLARY opcode type and ALLOC_BYTEARRAY.
@
text
@d2 4
a6 1
(* $Log: _mirtables.sml,v $
a136 2
require "../utils/option";
require "../utils/set";
a140 1
require "mirtypes";
a142 1

a143 2

  structure MirTypes	: MIRTYPES
a144 2
  structure Set		: SET
  structure Option	: OPTION
a147 4

  sharing MirTypes = MirRegisters.MirTypes
  sharing Set = MirTypes.Set = MirRegisters.Set

d152 3
a154 3
    structure Option = Option
    structure Set = Set
    structure MirTypes = MirTypes
@


1.34
log
@Changed calls to C to pass a single argument.
@
text
@d4 3
d241 1
a241 6
        | defined_by (PROFILER reg1)                 =
(*
	  reg (defined_by_call, reg1)
*)
	  single_reg reg1
	  (* Changed to allow leaf profiling *)
d243 1
d322 1
@


1.33
log
@Added type annotation information at application points
@
text
@d4 3
d324 1
a324 1
          {gc = GC.Set.from_list [caller_arg, caller_closure, stack, frame],
@


1.32
log
@Added parameter to RAISE once again.
@
text
@d4 3
d281 1
a281 1
	| referenced_by (BRANCH_AND_LINK(_, REG reg1))      = reg (referenced_by_call, reg1)
@


1.31
log
@Made PROFILER reference only the explicit register mentioned
@
text
@d4 3
d273 1
a273 1
        | defined_by RAISE                           = empty
d321 4
a324 4
	| referenced_by RAISE =
          {gc = GC.Set.from_list [caller_arg, stack, frame],
           non_gc = NonGC.Set.empty,
           fp = FP.Set.empty}
d487 1
a487 1
	| successors ([], opcode as RAISE) =
d494 1
a494 1
	| successors (handlers as handler::_, opcode as RAISE) =
@


1.30
log
@Rewrote defined_by and referenced_by to return a triple of register
sets rather than a set of any_registers.
@
text
@d4 4
d229 6
a234 1
        | defined_by (PROFILER reg1)                 = reg (defined_by_call, reg1)
@


1.29
log
@First version of the profiler
@
text
@d4 3
a150 18
    (*  === MISCELLANEOUS DATA ===  *)

    (*  == Fixed registers ==
     *
     *  These registers are used for special purposes by the code.
     *)

    val caller_arg_reg = MirTypes.GC MirRegisters.caller_arg
    val callee_arg_reg = MirTypes.GC MirRegisters.callee_arg
    val caller_closure_reg = MirTypes.GC MirRegisters.caller_closure
    val callee_closure_reg = MirTypes.GC MirRegisters.callee_closure
    val sp_reg = MirTypes.GC MirRegisters.sp
    val fp_reg = MirTypes.GC MirRegisters.fp
    val handler_reg = MirTypes.GC MirRegisters.handler
    val global_reg = MirTypes.GC MirRegisters.global



d163 59
a221 7
      val defined_by_call =
        Set.union (Set.list_to_set [caller_arg_reg, caller_closure_reg],
                   MirRegisters.corrupted_by_callee)

      fun gp operand =
	[MirTypes.gp_to_any operand]
	handle MirTypes.NotAnyRegister => []
d224 81
a304 134
      fun defined_by ENTER =
	  Set.map MirTypes.GC MirRegisters.defined_on_entry

        | defined_by (PROFILER reg) =
	  Set.union(Set.singleton(MirTypes.reg_to_any reg),
                    defined_by_call)

	| defined_by (UNARY(_,reg,_)) =
	  Set.singleton(MirTypes.reg_to_any reg)

	| defined_by (BINARY(_,reg,_,_)) =
	  Set.singleton(MirTypes.reg_to_any reg)

	| defined_by (TBINARY(_,_,reg,_,_)) =
	  Set.singleton(MirTypes.reg_to_any reg)

	| defined_by (BINARYFP(_,fp,_,_)) =
	  Set.singleton(MirTypes.fp_to_any fp)

	| defined_by (TBINARYFP(_,_,fp,_,_)) =
	  Set.singleton(MirTypes.fp_to_any fp)

	| defined_by (UNARYFP(_,fp,_)) =
	  Set.singleton(MirTypes.fp_to_any fp)

	| defined_by (TUNARYFP(_,_,fp,_)) =
	  Set.singleton(MirTypes.fp_to_any fp)

	| defined_by (STACKOP(POP,reg,_)) =
	  Set.singleton(MirTypes.reg_to_any reg)

	| defined_by (STACKOP(PUSH,_,_)) = Set.empty_set

	| defined_by (STOREOP(LD,reg,_,_)) =
	  Set.singleton(MirTypes.reg_to_any reg)

        | defined_by (STOREOP(ST,_,_,_)) = Set.empty_set

	| defined_by (STOREFPOP(FLD,fp,_,_)) =
	  Set.singleton(MirTypes.fp_to_any fp)

        | defined_by (STOREFPOP(FST,_,_,_)) = Set.empty_set

	| defined_by (STOREFPOP(FLDREF,fp,_,_)) =
	  Set.singleton(MirTypes.fp_to_any fp)

        | defined_by (STOREFPOP(FSTREF,_,_,_)) = Set.empty_set

	| defined_by (STOREOP(LDREF,reg,_,_)) =
	  Set.singleton(MirTypes.reg_to_any reg)

        | defined_by (STOREOP(STREF,_,_,_)) = Set.empty_set

	| defined_by (STOREOP(LDB,reg,_,_)) =
	  Set.singleton(MirTypes.reg_to_any reg)

        | defined_by (STOREOP(STB,_,_,_)) = Set.empty_set

	| defined_by (REAL(ITOF,fp,_)) =
	  Set.singleton(MirTypes.fp_to_any fp)

	| defined_by (FLOOR(FTOI,_,reg,_)) =
	  (Set.singleton(MirTypes.reg_to_any reg)
	   handle MirTypes.NotAnyRegister =>
	     Crash.impossible
	     ("MirOptimiser (Tables): There's an FTOI instruction which "^
	      "is trying to store its result in a non-register here."))

	| defined_by (ALLOCATE(_,reg,_)) =
	  Set.list_to_set[MirTypes.reg_to_any reg,global_reg]

	| defined_by (ALLOCATE_STACK(_,reg,_,_)) =
	  Set.singleton(MirTypes.reg_to_any reg)

	| defined_by (ADR(_,reg,_)) =
	  Set.singleton(MirTypes.reg_to_any reg)

	| defined_by (BRANCH_AND_LINK _) = defined_by_call
	| defined_by CALL_C = defined_by_call

        | defined_by (BRANCH _) = Set.empty_set
        | defined_by (TEST _) = Set.empty_set
        | defined_by (FTEST _) = Set.empty_set
        | defined_by (TAIL_CALL _) = Set.empty_set
        | defined_by (SWITCH _) = Set.empty_set
        | defined_by (DEALLOCATE_STACK _) = Set.empty_set
        | defined_by RTS = Set.empty_set
        | defined_by (NEW_HANDLER _) = Set.empty_set
        | defined_by OLD_HANDLER = Set.empty_set
        | defined_by RAISE = Set.empty_set
        | defined_by (COMMENT _) = Set.empty_set


      fun referenced_by RTS =
	  Set.map MirTypes.GC MirRegisters.defined_on_exit

	| referenced_by (BRANCH_AND_LINK(_,REG reg1)) =
	  Set.list_to_set
	  ((MirTypes.reg_to_any reg1) ::
	   [caller_arg_reg,
	    caller_closure_reg,
	    sp_reg,
	    fp_reg,
	    handler_reg])

	| referenced_by (BRANCH_AND_LINK _) =
	  Set.list_to_set
	  [caller_arg_reg,
	   caller_closure_reg,
	   sp_reg,
	   fp_reg,
	   handler_reg]

	| referenced_by (TAIL_CALL(_,REG reg1)) =
	  Set.list_to_set
	  ((MirTypes.reg_to_any reg1) ::
	   [if MirRegisters.automatic_callee then
	      callee_arg_reg else caller_arg_reg,
	    if MirRegisters.automatic_callee then
	      callee_closure_reg else caller_closure_reg,
	    sp_reg,
	    fp_reg,
	    handler_reg])

	| referenced_by (TAIL_CALL _) =
	  Set.list_to_set
	  [if MirRegisters.automatic_callee then
	     callee_arg_reg else caller_arg_reg,
	   if MirRegisters.automatic_callee then
	     callee_closure_reg else caller_closure_reg,
	   sp_reg,
	   fp_reg,
	   handler_reg]

d306 3
a308 6
	  Set.list_to_set
	  [caller_arg_reg,
	   caller_closure_reg,
	   sp_reg,
	   fp_reg]

d310 3
a312 106
	  Set.list_to_set
	  [caller_arg_reg,
	   sp_reg,
	   handler_reg]

	| referenced_by (UNARY(_,_,reg2)) =
	  Set.list_to_set (gp reg2)

	| referenced_by (UNARYFP(_,_,fp2)) =
	  Set.singleton (MirTypes.fp_to_any fp2)

	| referenced_by (TUNARYFP(_,_,_,fp2)) =
	  Set.singleton (MirTypes.fp_to_any fp2)

	| referenced_by (BINARY(_,_,reg2,reg3)) =
	  Set.list_to_set ((gp reg2) @@ (gp reg3))

	| referenced_by (BINARYFP(_,_,fp2,fp3)) =
	  Set.list_to_set [MirTypes.fp_to_any fp2, MirTypes.fp_to_any fp3]

	| referenced_by (TBINARYFP(_,_,_,fp2,fp3)) =
	  Set.list_to_set [MirTypes.fp_to_any fp2, MirTypes.fp_to_any fp3]

	| referenced_by (TBINARY(_,_,_,reg2,reg3)) =
	  Set.list_to_set ((gp reg2) @@ (gp reg3))

	| referenced_by (STACKOP(PUSH,reg1,_)) =
	  Set.singleton (MirTypes.reg_to_any reg1)

	| referenced_by (STACKOP(POP,_,_)) = Set.empty_set

	| referenced_by (STOREOP(ST,reg1,reg2,reg3)) =
	  Set.list_to_set ([MirTypes.reg_to_any reg1,
			    MirTypes.reg_to_any reg2] @@ (gp reg3))

	| referenced_by (STOREOP(LD,_,reg2,reg3)) =
	  Set.list_to_set ((MirTypes.reg_to_any reg2) :: (gp reg3))

	| referenced_by (STOREOP(STREF,reg1,reg2,reg3)) =
	  Set.list_to_set ([MirTypes.reg_to_any reg1,
			    MirTypes.reg_to_any reg2] @@ (gp reg3))

	| referenced_by (STOREOP(LDREF,_,reg2,reg3)) =
	  Set.list_to_set ((MirTypes.reg_to_any reg2) :: (gp reg3))

	| referenced_by (STOREOP(STB,reg1,reg2,reg3)) =
	  Set.list_to_set ([MirTypes.reg_to_any reg1,
			    MirTypes.reg_to_any reg2] @@ (gp reg3))

	| referenced_by (STOREOP(LDB,_,reg2,reg3)) =
	  Set.list_to_set ((MirTypes.reg_to_any reg2) :: (gp reg3))

	| referenced_by (STOREFPOP(FST,fp1,reg2,reg3)) =
	  Set.list_to_set ([MirTypes.fp_to_any fp1,
			    MirTypes.reg_to_any reg2] @@ (gp reg3))

	| referenced_by (STOREFPOP(FSTREF,fp1,reg2,reg3)) =
	  Set.list_to_set ([MirTypes.fp_to_any fp1,
			    MirTypes.reg_to_any reg2] @@ (gp reg3))

	| referenced_by (STOREFPOP(FLD,_,reg2,reg3)) =
	  Set.list_to_set ((MirTypes.reg_to_any reg2) :: (gp reg3))

	| referenced_by (STOREFPOP(FLDREF,_,reg2,reg3)) =
	  Set.list_to_set ((MirTypes.reg_to_any reg2) :: (gp reg3))

	| referenced_by (REAL(ITOF,_,reg2)) =
	  Set.list_to_set (gp reg2)

	| referenced_by (FLOOR(FTOI,_,_,fp1)) =
	  Set.singleton (MirTypes.fp_to_any fp1)

	| referenced_by (BRANCH(_,REG reg1)) =
	  Set.singleton (MirTypes.reg_to_any reg1)

	| referenced_by (BRANCH _) = Set.empty_set

	| referenced_by (TEST(_,_,reg1,reg2)) =
	  Set.list_to_set ((gp reg1) @@ (gp reg2))

	| referenced_by (FTEST(_,_,fp1,fp2)) =
	  Set.list_to_set [MirTypes.fp_to_any fp1,
			   MirTypes.fp_to_any fp2]

	| referenced_by (SWITCH(_,reg1,_)) =
	  Set.singleton (MirTypes.reg_to_any reg1)

	| referenced_by(COMMENT _) = Set.empty_set

	| referenced_by ENTER = Set.empty_set

	| referenced_by (MirTypes.PROFILER _) = 
          Set.singleton(callee_closure_reg)

	| referenced_by(NEW_HANDLER _) = Set.empty_set

	| referenced_by OLD_HANDLER = Set.empty_set

        | referenced_by(ALLOCATE (_,_,reg)) =  Set.list_to_set (gp reg)

	| referenced_by(ALLOCATE_STACK _) = Set.empty_set

	| referenced_by(DEALLOCATE_STACK _) = Set.empty_set

	| referenced_by(ADR _) = Set.empty_set

d332 3
a334 3
	| has_side_effects (STOREOP(LD,_,_,_)) = false
	| has_side_effects (STOREOP(LDB,_,_,_)) = false
	| has_side_effects (STOREOP(LDREF,_,_,_)) = false
@


1.28
log
@ALLOCATE may now take a register argument, added to referenced_by
Added global as defined_by ALLOCATE
@
text
@d4 4
d190 4
d419 3
@


1.27
log
@Changed register types to reflect changes in MirTypes.
Removed obsolote `substitute' function.
@
text
@d4 4
d248 1
a248 1
	  Set.singleton(MirTypes.reg_to_any reg)
d416 1
a416 1
	| referenced_by(ALLOCATE _) = Set.empty_set
@


1.26
log
@Abolished PREVIOUS_ENVIRONMENT and PRESERVE_ALL_REGS.
Made defined_by more efficient in the case of call instructions.
@
text
@d4 4
a617 137



    (*  === SUBSTITUTE REGISTERS IN AN OPCODE ===
     *
     *  A record of four tables, one for each register type, is used
     *  to map each register mentioned in the opcode on to a new
     *  register. If a register is mentioned which is not in the
     *  table, NoMapping is raised.
     *)

    exception NoMapping of MirTypes.any_register

    fun substitute_registers {gc = gc_table,
			      non_gc = non_gc_table,
			      fp = fp_table} opcode =
      let
	open MirTypes

	(*  == Operand substitution functions ==
	 *
	 *  These look up the fresh register version of each operand type.
	 *)

	fun sub_gp (GP_GC_REG r) =
	    (GP_GC_REG (Table.lookup (r, gc_table))
	     handle Table.Lookup => raise NoMapping (GC r))
	  | sub_gp (GP_NON_GC_REG r) =
	    (GP_NON_GC_REG (Table.lookup (r, non_gc_table))
	     handle Table.Lookup => raise NoMapping (NON_GC r))
	  | sub_gp operand = operand

	fun sub_reg (GC_REG r) =
	    (GC_REG (Table.lookup (r, gc_table))
	     handle Table.Lookup => raise NoMapping (GC r))
	  | sub_reg (NON_GC_REG r) =
	    (NON_GC_REG (Table.lookup (r, non_gc_table))
	     handle Table.Lookup => raise NoMapping (NON_GC r))

	fun sub_fp (operand as (FP_REG r)) =
	  (FP_REG (Table.lookup (r, fp_table))
	   handle Table.Lookup => raise NoMapping (FLOAT r))


	(*  == Substitute registers in an opcode ==  *)

	fun sub_op (TBINARY(operator, tag, reg, gp1, gp2)) =
	  TBINARY(operator, tag, sub_reg reg, sub_gp gp1, sub_gp gp2)

	  | sub_op (BINARY(operator, reg, gp1, gp2)) =
	    BINARY(operator, sub_reg reg, sub_gp gp1, sub_gp gp2)

	  | sub_op (UNARY(operator, reg, gp)) =
	    UNARY(operator, sub_reg reg, sub_gp gp)

	  | sub_op (BINARYFP(operator, fp1, fp2, fp3)) =
	    BINARYFP(operator, sub_fp fp1, sub_fp fp2, sub_fp fp3)

	  | sub_op (UNARYFP(operator, fp1, fp2)) =
	    UNARYFP(operator, sub_fp fp1, sub_fp fp2)

	  | sub_op (TBINARYFP(operator, tag, fp1, fp2, fp3)) =
	    TBINARYFP(operator, tag, sub_fp fp1, sub_fp fp2, sub_fp fp3)

	  | sub_op (TUNARYFP(operator, tag, fp1, fp2)) =
	    TUNARYFP(operator, tag, sub_fp fp1, sub_fp fp2)

	  | sub_op (STACKOP(operator, reg, offset)) =
	    STACKOP(operator, sub_reg reg, offset)

	  | sub_op (STOREOP(operator, reg1, reg2, gp)) =
	    STOREOP(operator, sub_reg reg1, sub_reg reg2, sub_gp gp)

	  | sub_op (STOREFPOP(operator, fp, reg, gp)) =
	    STOREFPOP(operator, sub_fp fp, sub_reg reg, sub_gp gp)

	  | sub_op (REAL(operator, fp, gp)) =
	    REAL(operator, sub_fp fp, sub_gp gp)

	  | sub_op (FLOOR(operator, tag, reg, fp)) =
	    FLOOR(operator, tag, sub_reg reg, sub_fp fp)

	  | sub_op (BRANCH(operator, REG reg)) =
	    BRANCH(operator, REG (sub_reg reg))

	  | sub_op (opcode as BRANCH _) = opcode

	  | sub_op (TEST(operator, tag, gp1, gp2)) =
	    TEST(operator, tag, sub_gp gp1, sub_gp gp2)

	  | sub_op (FTEST(operator, tag, fp1, fp2)) =
	    FTEST(operator, tag, sub_fp fp1, sub_fp fp2)

	  | sub_op (BRANCH_AND_LINK(operator, REG reg)) =
	    BRANCH_AND_LINK(operator, REG (sub_reg reg))

	  | sub_op (opcode as BRANCH_AND_LINK _) = opcode

	  | sub_op (TAIL_CALL(operator, REG reg)) =
	    TAIL_CALL(operator, REG (sub_reg reg))

	  | sub_op (opcode as TAIL_CALL _) = opcode

	  | sub_op (SWITCH(operator, reg, tags)) =
	    SWITCH(operator, sub_reg reg, tags)

	  | sub_op (ALLOCATE(operator, reg, i)) =
	    ALLOCATE(operator, sub_reg reg, sub_gp i)

	  | sub_op (ALLOCATE_STACK(operator, reg, i, offset)) =
	    ALLOCATE_STACK(operator, sub_reg reg, i, offset)

	  | sub_op (opcode as DEALLOCATE_STACK _) = opcode

	  | sub_op (ADR(operator, reg, tag)) =
	    ADR(operator, sub_reg reg, tag)

	  | sub_op RAISE = RAISE

	  | sub_op CALL_C = CALL_C

	  | sub_op ENTER = ENTER

	  | sub_op RTS = RTS

	  | sub_op(opcode as NEW_HANDLER _) = opcode

	  | sub_op OLD_HANDLER = OLD_HANDLER

	  | sub_op(opcode as COMMENT _) = opcode

      in

	sub_op opcode

      end

@


1.25
log
@Changed successors function to distinguish between normal branches
and exception raising.
@
text
@d4 8
d166 4
d248 2
a249 4
	| defined_by (BRANCH_AND_LINK _) =
	  let
	    fun unpack (con, set) =
	      map con (Set.set_to_list set)
a250 25
	    val corrupted =
	      (unpack (GC, #gc MirRegisters.corrupted_by_callee)) @@
	      (unpack (NON_GC, #non_gc MirRegisters.corrupted_by_callee)) @@
	      (unpack (FLOAT, #fp MirRegisters.corrupted_by_callee))
	  in
	    Set.list_to_set (caller_arg_reg ::
			     caller_closure_reg ::
			     corrupted)
	  end

	| defined_by CALL_C =
	  let
	    fun unpack (con, set) =
	      map con (Set.set_to_list set)

	    val corrupted =
	      (unpack (GC, #gc MirRegisters.corrupted_by_callee)) @@
	      (unpack (NON_GC, #non_gc MirRegisters.corrupted_by_callee)) @@
	      (unpack (FLOAT, #fp MirRegisters.corrupted_by_callee))
	  in
	    Set.list_to_set (caller_arg_reg ::
			     caller_closure_reg ::
			     corrupted)
	  end

a256 1
        | defined_by PRESERVE_ALL_REGS = Set.empty_set
a262 2
          (* Previous environment defined almost everything, in fact, but is *)
          (* dealt with specially in the optimisers. *)
a263 4
        | defined_by PREVIOUS_ENVIRONMENT = Set.empty_set



a317 3
	| referenced_by PREVIOUS_ENVIRONMENT =
	  Set.list_to_set [fp_reg, sp_reg]

a403 2
	| referenced_by PRESERVE_ALL_REGS = Set.empty_set

d415 2
a416 4
(*
	| referenced_by _ =
	  Set.empty_set
*)
a736 2
	  | sub_op PRESERVE_ALL_REGS = PRESERVE_ALL_REGS

a737 2

	  | sub_op PREVIOUS_ENVIRONMENT = PREVIOUS_ENVIRONMENT
@


1.24
log
@Alloc may now have a register argument for allocating arrays
@
text
@d4 3
d95 1
d110 1
d122 1
d484 3
d489 2
d500 1
a500 1
	   successors = [tag]}
d519 1
a519 1
           "a local exception handler was in force.")
d521 2
a522 2
	| successors (handlers, opcode as RTS) =
	  {flow_state = handlers,
d528 5
d538 1
a538 1
	   successors = tags}
d545 1
a545 1
	   successors = tags}
d552 1
a552 1
	   successors = [tag]}
d559 1
a559 1
	   successors = [tag]}
d566 1
a566 1
	   successors = [tag]}
d573 1
a573 1
	   successors = [tag]}
d580 1
a580 1
	   successors = [tag]}
d587 1
a587 1
	   successors = [tag]}
d619 1
a619 1
	   successors = [handler]}
d633 1
a633 1
	   successors = [handler]}
a776 3
(*
	  | sub_op opcode = opcode
*)
@


1.23
log
@Raise no longer has a parameter
@
text
@d4 3
d734 1
a734 1
	    ALLOCATE(operator, sub_reg reg, i)
@


1.22
log
@Added TBINARYFP to the defined_by function, and made this function
an exhaustive list of cases rather than having a catch-all clause.
@
text
@d3 5
a7 1
(* $Log:	_mirtables.sml,v $
d267 1
a267 1
        | defined_by (RAISE _) = Set.empty_set
d325 1
a325 1
	| referenced_by (RAISE(reg1)) =
d327 3
a329 4
	  ((MirTypes.reg_to_any reg1) ::
	   [caller_arg_reg,
	    sp_reg,
	    handler_reg])
d588 1
a588 1
	| successors ([], opcode as RAISE _) =
d595 1
a595 1
	| successors (handlers as handler::_, opcode as RAISE _) =
d741 1
a741 2
	  | sub_op (RAISE reg) =
	    RAISE(sub_reg reg)
@


1.21
log
@Added `exits' return from the successors function to show
whether an opcode might exit the procedure.
@
text
@d4 4
d165 3
d171 3
d177 2
d182 2
d187 7
d197 2
d202 2
d253 18
a270 1
	| defined_by _ = Set.empty_set
@


1.20
log
@Added successor case for FLOOR.  Added side effects = true for
tagged operations.
@
text
@d4 4
d440 1
d443 1
a443 1
      | successors ([], opcode as TAIL_CALL(_, TAG tag)) =
d447 1
d450 1
a450 1
      | successors ([], opcode as TAIL_CALL(_, REG _)) =
d454 1
d457 4
a460 2
      | successors (_, TAIL_CALL _) =
	Crash.impossible"Tail call with local handler in existence"
d466 1
d473 1
d480 1
d487 1
d494 1
d501 1
d508 1
d515 1
d522 1
d529 1
d536 1
d547 1
d554 1
d557 7
d568 1
d575 1
@


1.19
log
@Added successor information on TAIL_CALL
@
text
@d4 3
d402 1
a402 2
      fun has_side_effects (TBINARY _) = false
	| has_side_effects (BINARY _) = false
a405 2
	| has_side_effects (TBINARYFP _) = false
	| has_side_effects (TUNARYFP _) = false
a409 1
	| has_side_effects (FLOOR _) = false
d496 6
@


1.18
log
@Added tail call operation
@
text
@d4 3
d438 15
@


1.17
log
@Added exception generating fp opcodes to tables.
Made matches explicitly exhaustive
@
text
@d4 4
d233 1
a233 1
	| referenced_by CALL_C =
d238 2
a239 1
	   fp_reg]
d241 1
a241 1
	| referenced_by (BRANCH_AND_LINK _) =
d243 15
a257 2
	  [caller_arg_reg,
	   caller_closure_reg,
d262 7
d622 5
@


1.16
log
@Changed debugging output to use the Diagnostic module, which
prevents the debugging output strings being constructed even
if they aren't printed.
@
text
@d4 5
d165 1
a165 1
	| defined_by (CONVOP(ITOF,fp,_)) =
d168 2
a169 2
	| defined_by (CONVOP(FTOI,_,gp)) =
	  (Set.singleton(MirTypes.gp_to_any gp)
d260 3
d269 3
d278 2
d305 4
d312 4
a315 1
	| referenced_by (CONVOP(ITOF,_,reg2)) =
d318 1
a318 1
	| referenced_by (CONVOP(FTOI,fp1,_)) =
d324 2
d336 18
d356 1
d376 2
d381 2
a382 1
	| has_side_effects (CONVOP _) = false
d447 12
d561 6
d576 2
a577 2
	  | sub_op (CONVOP(operator, fp, gp)) =
	    CONVOP(operator, sub_fp fp, sub_gp gp)
d579 3
d585 2
d596 2
d607 2
d615 16
d632 1
@


1.15
log
@Fixed bug whereby tags in FTEST instructions weren't being followed
@
text
@d4 3
d534 3
@


1.14
log
@Removed symbol substitution from substitute_registers.  Added code
for the new CALL_C opcode.
@
text
@d4 4
d383 6
@


1.13
log
@Removed references to fp_double registers.
@
text
@d4 3
d187 15
d217 7
d444 3
a446 4
    fun substitute_registers ({gc = gc_table,
			       non_gc = non_gc_table,
			       fp = fp_table},
			      sym_to_gp) opcode =
a460 2
	  | sub_gp (GP_IMM_SYMB symbol) =
	    sym_to_gp symbol
@


1.12
log
@Added offset argument to STACKOPs.
@
text
@d4 3
d177 1
a177 2
	      (unpack (FLOAT, #fp MirRegisters.corrupted_by_callee)) @@
	      (unpack (DOUBLE, #fp_double MirRegisters.corrupted_by_callee))
d421 1
a421 2
			       fp = fp_table,
			       fp_double = fp_double_table},
a450 3

	fun sub_fp_double _ =
	  Crash.unimplemented ("MirOptimiser (Tables): sub_fp_double")
@


1.11
log
@Removed the assumption that POP has no side effects.
@
text
@d4 3
d132 1
a132 1
	| defined_by (STACKOP(POP,reg)) =
d167 3
a169 1
	  Set.list_to_set [caller_arg_reg, caller_closure_reg]
d171 11
d230 1
a230 1
	| referenced_by (STACKOP(PUSH,reg1)) =
d472 2
a473 2
	  | sub_op (STACKOP(operator, reg)) =
	    STACKOP(operator, sub_reg reg)
@


1.10
log
@Changed the form of the allocation instructions yet again.
@
text
@d4 3
a284 1
	| has_side_effects (STACKOP(POP,_)) = false
@


1.9
log
@ALLOCATE doesn't have a scratch register or a proc_ref any more.
@
text
@d4 3
d154 3
d288 1
@


1.8
log
@Added parameter to NoMapping exception to ease debugging.
Added generalized successors function to trace flow of control.
@
text
@d5 4
d148 2
a149 2
	| defined_by (ALLOCATE(_,reg,_, reg', _)) =
	  Set.list_to_set[MirTypes.reg_to_any reg, MirTypes.reg_to_any reg']
a254 6
	| referenced_by (ALLOCATE(_,_,_,_,proc_ref)) =
	  (case proc_ref of
	    MirTypes.REG_REF reg => Set.singleton (MirTypes.reg_to_any reg)
	  | MirTypes.CLOSURE_REF(reg,_) =>
	      Set.singleton (MirTypes.reg_to_any reg))

a256 1

d474 2
a475 9
	  | sub_op (ALLOCATE(operator, reg, i, reg', proc_ref)) =
	    let
	      val proc_ref' = case proc_ref of
		MirTypes.REG_REF reg => MirTypes.REG_REF(sub_reg reg)
	      | MirTypes.CLOSURE_REF(reg, i) =>
		  MirTypes.CLOSURE_REF(sub_reg reg, i)
	    in
	      ALLOCATE(operator, sub_reg reg, i, sub_reg reg', proc_ref')
	    end
d481 1
a481 1
	      RAISE(sub_reg reg)
@


1.7
log
@Added missing BRANCH_AND_LINK clause to referenced_by.
@
text
@d4 6
d291 94
d393 1
a393 1
    exception NoMapping = Table.Lookup
d409 2
a410 1
	    GP_GC_REG (Table.lookup (r, gc_table))
d412 2
a413 1
	    GP_NON_GC_REG (Table.lookup (r, non_gc_table))
d419 2
a420 1
	    GC_REG (Table.lookup (r, gc_table))
d422 2
a423 1
	    NON_GC_REG (Table.lookup (r, non_gc_table))
d426 2
a427 1
	  FP_REG (Table.lookup (r, fp_table))
@


1.6
log
@New style ALLOC opcodes
@
text
@d4 3
d144 1
a144 1
	| defined_by (BRANCH_AND_LINK(_,_)) =
d161 8
@


1.5
log
@Updated to reflect extra parameter on ALLOCATEs
@
text
@d4 3
d135 2
a136 2
	| defined_by (ALLOCATE(_,reg,_, _)) =
	  Set.singleton(MirTypes.reg_to_any reg)
d234 6
d361 9
a369 2
	  | sub_op (ALLOCATE(operator, reg, i, j)) =
	    ALLOCATE(operator, sub_reg reg, i, j)
@


1.4
log
@Moved substitute_registers here from the register allocator functor.
@
text
@d4 3
d132 1
a132 1
	| defined_by (ALLOCATE(_,reg,_)) =
d352 2
a353 2
	  | sub_op (ALLOCATE(operator, reg, i)) =
	    ALLOCATE(operator, sub_reg reg, i)
@


1.3
log
@Slight alterations to cope with new MirTypes.
@
text
@d4 3
d24 1
d37 1
d48 1
d259 106
@


1.2
log
@Removed RESTORE_REGS and PRESERVE_REGS and replaced by
PREVIOUS_ENVIRONMENT and parameterized ENTER. Added
parameterized RAISE.
@
text
@d4 5
d80 1
a80 1
      fun defined_by (ENTER _) =
@


1.1
log
@Initial revision
@
text
@d4 3
d30 1
a30 1
  sharing Set = MirTypes.Set
d75 4
a78 1
      fun defined_by (UNARY(_,reg,_)) =
d130 4
a133 1
      fun referenced_by (BRANCH_AND_LINK(_,REG reg1)) =
d142 6
a147 2
	| referenced_by (RESTORE_REGS _) =
	  Set.singleton (callee_closure_reg)
d149 2
a150 4
	| referenced_by (PRESERVE_REGS(regs,fps)) =
	  Set.list_to_set (callee_closure_reg ::
			   ((map MirTypes.reg_to_any regs) @@
			    (map MirTypes.fp_to_any fps)))
@
