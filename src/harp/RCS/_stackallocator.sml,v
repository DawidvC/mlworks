head	1.31;
access;
symbols
	MLW_daveb_inline_1_4_99:1.31.3
	MLWorks_21c0_1999_03_25:1.31
	MLWorks_20c1_1998_08_20:1.31
	MLWorks_20c0_1998_08_04:1.31
	MLWorks_20b2c2_1998_06_19:1.31
	MLWorks_20b2_Windows_1998_06_12:1.31
	MLWorks_20b1c1_1998_05_07:1.31
	MLWorks_20b0_1998_04_07:1.31
	MLWorks_20b0_1998_03_20:1.31
	MLWorks_20m2_1998_02_16:1.31
	MLWorks_20m1_1997_10_23:1.31
	MLWorks_11r1:1.30.8.1.1.1.1
	MLWorks_workspace_97:1.31.2
	MLWorks_dt_wizard:1.31.1
	MLWorks_11c0_1997_09_09:1.30.8.1.1.1
	MLWorks_10r3:1.30.8.1.3
	MLWorks_10r2_551:1.30.8.1.2
	MLWorks_11:1.30.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.30.8.1
	MLWorks_20m0_1997_06_20:1.31
	MLWorks_1_0_r2c2_1997_06_14:1.30.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.30.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.30.8
	MLWorks_BugFix_1997_04_24:1.30
	MLWorks_1_0_r2_Win32_1997_04_11:1.30
	MLWorks_1_0_r2_Unix_1997_04_04:1.30
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.30.6.1.1
	MLWorks_gui_1996_12_18:1.30.7
	MLWorks_1_0_Win32_1996_12_17:1.30.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.30.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.30.4.1
	MLWorks_1_0_Irix_1996_11_28:1.30.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.30.5
	MLWorks_1_0_Unix_1996_11_14:1.30.4
	MLWorks_Open_Beta2_1996_10_11:1.30.3
	MLWorks_License_dev:1.30.2
	MLWorks_1_open_beta_1996_09_13:1.30.1
	MLWorks_Open_Beta_1996_08_22:1.30
	MLWorks_Beta_1996_07_02:1.30
	MLWorks_Beta_1996_06_07:1.30
	MLWorks_Beta_1996_06_06:1.30
	MLWorks_Beta_1996_06_05:1.30
	MLWorks_Beta_1996_06_03:1.30
	MLWorks_Beta_1996_05_31:1.30
	MLWorks_Beta_1996_05_30:1.30
	ML_beta_release_12/08/94:1.24
	ML_beta_release_03/08/94:1.24
	ML_revised_beta_release_25/05/94:1.24
	ML_final_beta_release_02/03/94:1.23
	mlworks-28-01-1994:1.23
	Release:1.23
	mlworks-beta-01-09-1993:1.23
	MLWorks-1-0-4-29/01/1993:1.19
	MLWorks-1-0-3-21/12/1992:1.19
	MLWorks-1-0-2-15/12/1992:1.19
	MLWorks-1-0-1-04/12/1992:1.19
	checkpoint_17_08_92:1.15;
locks; strict;
comment	@ * @;


1.31
date	97.05.01.12.36.48;	author jont;	state Exp;
branches
	1.31.1.1
	1.31.2.1
	1.31.3.1;
next	1.30;

1.30
date	95.12.20.13.51.54;	author jont;	state Exp;
branches
	1.30.1.1
	1.30.2.1
	1.30.3.1
	1.30.4.1
	1.30.5.1
	1.30.6.1
	1.30.7.1
	1.30.8.1;
next	1.29;

1.29
date	95.05.31.11.15.16;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	95.05.15.10.33.44;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	94.10.13.11.16.41;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	94.08.30.13.11.24;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	94.08.25.13.55.09;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	94.05.12.12.52.43;	author richard;	state Exp;
branches;
next	1.23;

1.23
date	93.08.17.14.58.11;	author richard;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	93.07.29.15.19.43;	author nosa;	state Exp;
branches;
next	1.21;

1.21
date	93.05.18.14.53.35;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	93.03.10.17.59.21;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	92.11.03.14.50.02;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.09.22.09.48.38;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.08.28.15.07.59;	author davidt;	state Exp;
branches;
next	1.16;

1.16
date	92.08.26.15.40.16;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.08.04.18.53.09;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.06.09.15.49.17;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	92.06.01.11.24.47;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	92.04.13.15.21.23;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.04.09.15.45.18;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	92.04.03.13.06.33;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	92.03.05.11.03.15;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	92.01.31.10.02.50;	author richard;	state Exp;
branches
	1.8.1.1;
next	1.7;

1.7
date	91.12.12.13.46.05;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.12.05.14.57.19;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	91.11.26.12.52.07;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	91.11.19.16.05.50;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.11.08.16.06.28;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.11.07.16.10.46;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	91.10.29.16.41.57;	author richard;	state Exp;
branches;
next	;

1.8.1.1
date	92.03.04.13.47.11;	author richard;	state Exp;
branches;
next	;

1.23.1.1
date	93.08.17.14.58.11;	author jont;	state Exp;
branches;
next	;

1.30.1.1
date	96.09.13.11.14.52;	author hope;	state Exp;
branches;
next	;

1.30.2.1
date	96.10.07.16.05.14;	author hope;	state Exp;
branches;
next	;

1.30.3.1
date	96.10.17.11.23.29;	author hope;	state Exp;
branches;
next	;

1.30.4.1
date	96.11.14.12.47.50;	author hope;	state Exp;
branches
	1.30.4.1.1.1;
next	;

1.30.4.1.1.1
date	96.11.28.14.59.21;	author hope;	state Exp;
branches;
next	;

1.30.5.1
date	96.11.22.18.07.52;	author hope;	state Exp;
branches;
next	;

1.30.6.1
date	96.12.17.17.46.33;	author hope;	state Exp;
branches
	1.30.6.1.1.1;
next	;

1.30.6.1.1.1
date	97.02.24.11.36.12;	author hope;	state Exp;
branches;
next	;

1.30.7.1
date	96.12.18.09.40.33;	author hope;	state Exp;
branches;
next	;

1.30.8.1
date	97.05.12.10.32.54;	author hope;	state Exp;
branches
	1.30.8.1.1.1
	1.30.8.1.2.1
	1.30.8.1.3.1;
next	;

1.30.8.1.1.1
date	97.07.28.18.17.49;	author daveb;	state Exp;
branches
	1.30.8.1.1.1.1.1;
next	;

1.30.8.1.1.1.1.1
date	97.10.07.11.42.43;	author jkbrook;	state Exp;
branches;
next	;

1.30.8.1.2.1
date	97.09.08.17.11.23;	author daveb;	state Exp;
branches;
next	;

1.30.8.1.3.1
date	97.09.09.14.06.58;	author daveb;	state Exp;
branches;
next	;

1.31.1.1
date	97.09.10.19.21.35;	author brucem;	state Exp;
branches;
next	;

1.31.2.1
date	97.09.11.20.52.50;	author daveb;	state Exp;
branches;
next	;

1.31.3.1
date	99.04.01.17.55.50;	author daveb;	state Exp;
branches;
next	;


desc
@Calculates stack needed for ALLOCATE instructions. This is the functor.
@


1.31
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(*  ==== STATIC STACK ALLOCATOR ====
 *              FUNCTOR
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  Two passes are made over the procedure.  The first pass determines the
 *  total amount of static stack required by the procedure and the stack
 *  position on entry to each block.  This is accomplished by tracing all
 *  the possible control flow paths (while also ensuring that the stack use
 *  in a loop is consistent).  In the second pass, the blocks are remade
 *  with the stack offsets added to any stack operations.
 *
 *  Notes
 *  -----
 *  1.  There is no way that this module can cope with stack allocation
 *      determined at run-time.
 *
 *  Revision Log
 *  ------------
 *  $Log: _stackallocator.sml,v $
 * Revision 1.30  1995/12/20  13:51:54  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
 *  Revision 1.29  1995/05/31  11:15:16  matthew
 *  Changing instruction datatype
 *
 *  Revision 1.28  1995/05/15  10:33:44  jont
 *  Modify to use a tree instead of an association list when determining stack requirements
 *
 *  Revision 1.27  1994/10/13  11:16:41  matthew
 *  Use pervasive Option.option for return values in NewMap
 *
 *  Revision 1.26  1994/08/30  13:11:24  matthew
 *  Efficiency improvements
 *
 *  Revision 1.25  1994/08/25  13:55:09  matthew
 *  Changes to procedurure and block annotations.
 *
 *  Revision 1.24  1994/05/12  12:52:43  richard
 *  Add field to MirTypes.PROC_PARAMS.
 *
 *  Revision 1.23  1993/08/17  14:58:11  richard
 *  Changed the annotation of raise instructions to model the fact that
 *  the raise might reach _any_ of the nexted continuation blocks.
 *
 *  Revision 1.22  1993/07/29  15:19:43  nosa
 *  structure Option.
 *
 *  Revision 1.21  1993/05/18  14:53:35  jont
 *  Removed Integer parameter
 *
 *  Revision 1.20  1993/03/10  17:59:21  matthew
 *  Map substructure is now MirTypes.Map
 *  Signature revisions
 *
 *  Revision 1.19  1992/11/03  14:50:02  jont
 *  Efficiency changes to use mononewmap for registers and tags
 *
 *  Revision 1.18  1992/09/22  09:48:38  clive
 *  Got rid of some handles using tryApply and co
 *
 *  Revision 1.17  1992/08/28  15:07:59  davidt
 *  Removed some unncesessary intermediate lists which
 *  were being built.
 *
 *  Revision 1.16  1992/08/26  15:40:16  jont
 *  Removed some redundant structures and sharing
 *
 *  Revision 1.15  1992/08/04  18:53:09  jont
 *  Removed various uses of NewMap.to_list in favour of fold and union
 *
 *  Revision 1.14  1992/06/09  15:49:17  richard
 *  Added registers annotation to procedures.
 *
 *  Revision 1.13  1992/06/01  11:24:47  richard
 *  Improved use of Map.
 *
 *  Revision 1.12  1992/04/13  15:21:23  clive
 *  First version of the profiler
 *
 *  Revision 1.11  1992/04/09  15:45:18  richard
 *  Changed code to take advantage of uses_stack.  No analysis is performed
 *  if the procedure does not contain stacking instruction.
 *
 *  Revision 1.10  1992/04/03  13:06:33  richard
 *  Corrected calculation of stack required in the presence of exceptions.
 *
 *  Revision 1.9  1992/03/05  11:03:15  richard
 *  Rewrote in terms of MirProcedure annotated procedures and corrected
 *  the algorithm so that it is no longer exponential on depth of block
 *  nesting.
 *
 *  Revision 1.8  1992/01/31  10:02:50  richard
 *  Changed stack allocation to cope with jumping to the exception
 *  continuation block with the correct stack state.
 *
 *  Revision 1.7  1991/12/12  13:46:05  richard
 *  A complete rewrite.  See documentation at the start of the file.
 *
 *  Revision 1.6  91/12/05  14:57:19  richard
 *  Added extra documentation and a safeguard against procedures with
 *  no exits points.
 *  
 *  Revision 1.5  91/11/26  12:52:07  richard
 *  Added offsets to POP instructions as well as PUSH instructions.
 *  I'm not sure why I didn't do this before.
 *  
 *  Revision 1.4  91/11/19  16:05:50  richard
 *  Changed debugging output to use the Diagnostic module, which
 *  prevents the debugging output strings being constructed even
 *  if they aren't printed.
 *  
 *  Revision 1.3  91/11/08  16:06:28  richard
 *  Added offset argument to STACKOPs.
 *  
 *  Revision 1.2  91/11/07  16:10:46  richard
 *  The ProcedureMap structure is built inside this functor, so that extra
 *  processing can take place. Also added debugging output.
 *  
 *  Revision 1.1  91/10/29  16:41:57  richard
 *  Initial revision
 *)


require "../utils/diagnostic";
require "../utils/lists";
require "../utils/crash";
require "mirprocedure";
require "mirprint";
require "stackallocator";


functor StackAllocator (
  structure MirPrint		: MIRPRINT
  structure Crash		: CRASH
  structure Lists		: LISTS
  structure MirProcedure	: MIRPROCEDURE
  structure Diagnostic		: DIAGNOSTIC

  sharing MirProcedure.MirTypes = MirPrint.MirTypes

) : STACKALLOCATOR =

  struct

    structure MirProcedure = MirProcedure
    structure Diagnostic = Diagnostic
    structure MirTypes = MirProcedure.MirTypes
    structure Map = MirTypes.Map

    (*  == Diagnostic output ==  *)

    infix ^^
    val op^^ = Diagnostic.Text.concatenate
    val $ = Diagnostic.Text.from_string
    fun diagnostic (level, output_function) =
      Diagnostic.output_text level
      (fn verbosity =>
       $"Stack Allocator: " ^^ output_function verbosity)

    fun crash message = Crash.impossible ("Stack Allocator: " ^ message)

    val do_diagnostics = false

    (*  === STACK EFFECT OF AN OPCODE ===
     *
     *  This function returns the change to the stack pointer caused by an
     *  opcode.
     *)

    local
      open MirTypes

      val message =
        "Stack Allocator: I don't know how to deal with non-word stack allocation."
    in
      fun stack_effect (STACKOP (PUSH, _, _)) = 1
        | stack_effect (STACKOP (POP, _, _)) = ~1
        | stack_effect (ALLOCATE_STACK (ALLOC, _, amount, _)) = amount
        | stack_effect (ALLOCATE_STACK _) = Crash.unimplemented message
        | stack_effect (DEALLOCATE_STACK (ALLOC, amount)) = ~amount
        | stack_effect (DEALLOCATE_STACK _) = Crash.unimplemented  message
        | stack_effect _ = 0
    end



    (*  === FIRST PASS: ANALYSE STACK USAGE OF A PROCEDURE ===
     *
     *  Returns a pair containing the maximum number of words required by
     *  the procedure for its stack allocation and an association lists of
     *  blocks and their stack positions on entry.
     *)

    fun used_by_procedure (MirProcedure.P (_, _,start_tag, block_map)) =
      let

        val _ = if do_diagnostics 
                  then diagnostic (1, fn _ => $"analysing stack usage of procedure " ^^
                                   $(MirTypes.print_tag start_tag))
                else ()

        val block_map_fn = Map.tryApply block_map

        (*  == Analyse stack usage of a block ==
         *
         *  Returns a pair containing the maximum amount of stack required
         *  by a block AND its successors for stack allocation, and the
         *  alist of blocks visited and their stack positions on entry.  The
         *  following parameters are *  required:
         *    visited    An association list of other blocks passed through
         *               on the way to this one with their stack positions
         *               on entry.
         *    stack_position
         *               The position of the stack pointer on entry to the
         *               block.
         *    exception_stack_positions
         *               A list of stack positions.  The topmost position is
         *               that which was current when the topmost exception
         *               hander was set up, and must therefore be restored
         *               when that exception is raised.
         *    maximum_used
         *               The largest value of the stack pointer before
         *               entering the block.
         *    tag        The tag of the block to process.
         *)

        fun used_by_block (visited, stack_position, maximum_used, exception_stack_positions, tag) =

          (* If the block has already been visited then check that the stack *)
          (* pointer was in the same position last time.  If the block has *)
          (* been visited then its maximum usage has already been looked at, *)
          (* so return zero. *)

         (case MirTypes.Map.tryApply'(visited, tag) of
            SOME previous_position =>
              if previous_position = stack_position then
		(0, visited)
              else
                crash ("The block tagged " ^ MirTypes.print_tag tag ^
                       " has been reached with inconsistent stack positions.")
          | _ =>

          (* If the block hasn't been visited before then run through its *)
          (* opcodes calculating their effect on the stack.  If the flow of *)
          (* control leaves the block then call used_by_block on the blocks *)
          (* reached and take the maximum stack used by them into account. *)

          let
            fun used_by_opcodes (visited, _, maximum_used, _, []) = (maximum_used, visited)
              | used_by_opcodes (visited, stack_position, maximum_used, exception_stack_positions,
                                 MirProcedure.I {branches, excepts, opcode, ...} ::instructions) =
                let
                  val stack_position_after =
                    let
                      val new = stack_position + (stack_effect opcode)
                    in
                      if new >= 0 then
                        new
                      else
                        crash ("The stack position has gone negative in block " ^
                               MirTypes.print_tag tag ^
                               ".  There must be badly nested stack operations somewhere.")
                    end

                  val exception_stack_positions' =
		    case opcode of
		      MirTypes.NEW_HANDLER _ =>
			stack_position_after :: exception_stack_positions
                         | MirTypes.OLD_HANDLER =>
			     (case exception_stack_positions of
				_::rest => rest
			      | [] =>
				  crash ("Badly nested OLD_HANDLER in block " ^
					 MirTypes.print_tag tag ^ "."))
                         | _ => exception_stack_positions

                  val maximum_used_after =
                    if stack_position_after > maximum_used then stack_position_after else maximum_used

                  val (maximum_used_after', visited') =
                    Lists.reducel
                    (fn ((maximum, visited), tag) =>
                     let
                       val (used, visited') =
                         used_by_block (visited,
                                        stack_position_after,
                                        maximum_used_after,
                                        exception_stack_positions',
                                        tag)
                     in
                       (if used > maximum then used else maximum, visited')
                     end)
                    ((maximum_used_after, visited), MirTypes.Set.set_to_list branches)

                  val (maximum_used_after'', visited'') =
                    case excepts of
                      [] => (maximum_used_after', visited')
                    | _ => 
                      let
                        fun reach (maximum, visited, [], []) = (maximum, visited)
                          | reach (maximum, visited, cont::conts, exception_stack_positions as sp::sps) =
                            let
                              val (used, visited') =
                                used_by_block (visited, sp, maximum, exception_stack_positions, cont)
                            in
                              reach (if used > maximum then used else maximum,
                                     visited',
                                     conts, sps)
                            end
                          | reach _ =
                            crash ("The exception block " ^ MirTypes.print_tag tag ^ " was reached " ^
                                   "without a stack position in force.")
                      in
                        reach (maximum_used_after', visited', excepts, exception_stack_positions')
                      end
                in
                  used_by_opcodes (visited'',
                                   stack_position_after,
                                   maximum_used_after'',
                                   exception_stack_positions',
                                   instructions)
                end

            val MirProcedure.B (annotation, instructions) = 
              case block_map_fn tag of
                SOME x => x
              | _ =>
                  crash ("Block " ^ MirTypes.print_tag tag ^ " was reached but not found.")
          in
            used_by_opcodes (MirTypes.Map.define(visited, tag, stack_position),
                             stack_position,
                             maximum_used,
                             exception_stack_positions,
                             instructions)
          end)

      in

        (* Analyse the whole procedure by analysing the first block. *)

        used_by_block (MirTypes.Map.empty, 0, 0, [], start_tag)

      end



    (*  === PASS 2: ADD OFFSETS TO PROCEDURE ===
     *
     *  This function adds the stack offset positions to the stack operation
     *  opcodes.  It is passed a Map.T of blocks and a mapping function from
     *  blocks to stack positions on entry and returns an updated Map.T of
     *  blocks.
     *)

    fun add_offsets (positions, block_map) =
      let
        fun add_to_block (tag, MirProcedure.B (annotation, instructions)) =
          let
            fun add_to_opcodes (done, _, []) = rev done
              | add_to_opcodes (done, position, MirProcedure.I {defined,referenced,branches,excepts,opcode}::instructions) =
                let
                  val position_after = position + (stack_effect opcode)

                  local
                    open MirTypes
                  in
                    val opcode_with_offset =
                      case opcode
                        of STACKOP(PUSH, reg, _) =>
                           STACKOP(PUSH, reg, SOME position)
                         | STACKOP(POP, reg, _) => 
                           STACKOP(POP, reg, SOME position_after)
                         | ALLOCATE_STACK(oper, reg, amount, _) => 
                           ALLOCATE_STACK(oper, reg, amount, SOME position)
                         | other_opcode => other_opcode
                  end
                in
                  add_to_opcodes (MirProcedure.I {defined = defined,
                                                  referenced = referenced,
                                                  branches = branches,
                                                  excepts = excepts,
                                                  opcode = opcode_with_offset} :: done,
                                  position_after,
                                  instructions)
                end

            val new_instructions =
              add_to_opcodes ([], positions tag, instructions)
          in
            MirProcedure.B (annotation, new_instructions)
          end

      in
	Map.map add_to_block block_map
	handle Map.Undefined => crash ("Block does not have a starting stack position.")
      end




    (*  === STACK ALLOCATE A PROCEDURE ===
     *
     *  Applies the two passes to the procedure and fills in the procedure
     *  parameters.
     *)

    fun allocate (procedure as MirProcedure.P (annotation, name, start, block_map)) =
      let
        val (used, block_map') =
          if #uses_stack annotation then
            let
              val (used, positions) = used_by_procedure procedure
              val positions = Map.apply positions
              val block_map' = add_offsets (positions, block_map)
            in
              (used, block_map')
            end
          else
            (0, block_map)

        val annotation' =
          let
            val {uses_stack,
                 nr_registers,
                 parameters = MirTypes.PROC_PARAMS
                   {spill_sizes, ...}} = annotation
          in
            {nr_registers = nr_registers,
             uses_stack = uses_stack,
             parameters = MirTypes.PROC_PARAMS {spill_sizes = spill_sizes,
						old_spill_sizes = NONE,
                                                stack_allocated = SOME used}}
          end
                               
      in
        MirProcedure.P (annotation', name, start, block_map')
      end


  end
@


1.31.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a22 4
 * Revision 1.31  1997/05/01  12:36:48  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.31.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a22 4
 * Revision 1.31  1997/05/01  12:36:48  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.31.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a22 4
 * Revision 1.31  1997/05/01  12:36:48  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.30
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d23 4
d239 1
a239 1
            MLWorks.Option.SOME previous_position =>
d330 1
a330 1
                MLWorks.Option.SOME x => x
d374 1
a374 1
                           STACKOP(PUSH, reg, MLWorks.Option.SOME position)
d376 1
a376 1
                           STACKOP(POP, reg, MLWorks.Option.SOME position_after)
d378 1
a378 1
                           ALLOCATE_STACK(oper, reg, amount, MLWorks.Option.SOME position)
d435 2
a436 2
						old_spill_sizes = MLWorks.Option.NONE,
                                                stack_allocated = MLWorks.Option.SOME used}}
@


1.30.8.1
log
@branched from 1.30
@
text
@a22 4
 * Revision 1.30  1995/12/20  13:51:54  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.30.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a22 3
 * Revision 1.30.8.1  1997/05/12  10:32:54  hope
 * branched from 1.30
 *
@


1.30.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a22 3
 * Revision 1.30.8.1  1997/05/12  10:32:54  hope
 * branched from 1.30
 *
@


1.30.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a22 3
 * Revision 1.30.8.1  1997/05/12  10:32:54  hope
 * branched from 1.30
 *
@


1.30.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a22 3
 * Revision 1.30.8.1.1.1  1997/07/28  18:17:49  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.30.7.1
log
@branched from 1.30
@
text
@a22 4
 * Revision 1.30  1995/12/20  13:51:54  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.30.6.1
log
@branched from 1.30
@
text
@a22 4
 * Revision 1.30  1995/12/20  13:51:54  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.30.6.1.1.1
log
@branched from 1.30.6.1
@
text
@a22 3
 * Revision 1.30.6.1  1996/12/17  17:46:33  hope
 * branched from 1.30
 *
@


1.30.5.1
log
@branched from 1.30
@
text
@a22 4
 * Revision 1.30  1995/12/20  13:51:54  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.30.4.1
log
@branched from 1.30
@
text
@a22 4
 * Revision 1.30  1995/12/20  13:51:54  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.30.4.1.1.1
log
@branched from 1.30.4.1
@
text
@a22 3
 * Revision 1.30.4.1  1996/11/14  12:47:50  hope
 * branched from 1.30
 *
@


1.30.3.1
log
@branched from 1.30
@
text
@a22 4
 * Revision 1.30  1995/12/20  13:51:54  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.30.2.1
log
@branched from 1.30
@
text
@a22 4
 * Revision 1.30  1995/12/20  13:51:54  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.30.1.1
log
@branched from 1.30
@
text
@a22 4
 * Revision 1.30  1995/12/20  13:51:54  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.29
log
@Changing instruction datatype
@
text
@d23 3
a148 1
    structure Option = MirTypes.Option
d370 1
a370 1
                           STACKOP(PUSH, reg, Option.PRESENT position)
d372 1
a372 1
                           STACKOP(POP, reg, Option.PRESENT position_after)
d374 1
a374 1
                           ALLOCATE_STACK(oper, reg, amount, Option.PRESENT position)
d431 2
a432 1
                                                stack_allocated = MirTypes.Option.PRESENT used}}
@


1.28
log
@Modify to use a tree instead of an association list when determining stack requirements
@
text
@d23 3
d249 1
a249 1
                                 MirProcedure.I ({branches, except, ...}, opcode)::instructions) =
d294 1
a294 1
                    case except of
d312 1
a312 1
                        reach (maximum_used_after', visited', except, exception_stack_positions')
a354 4
(*
        val _ = diagnostic (1, fn _ => $"adding stack offsets to blocks ")
*)

a356 1

d358 1
a358 1
              | add_to_opcodes (done, position, MirProcedure.I(annotation, opcode)::instructions) =
d376 5
a380 1
                  add_to_opcodes (MirProcedure.I(annotation, opcode_with_offset) :: done,
@


1.27
log
@Use pervasive Option.option for return values in NewMap
@
text
@d23 3
a221 6
        fun tagassoc (t, []) = Option.ABSENT
          | tagassoc (t, ((t',x)::l)) =
            if (t = t') (* MirTypes.equal_tag (t,t') *)
              then Option.PRESENT x
            else tagassoc (t,l)
          
d229 4
a232 5
         (case tagassoc (tag,visited) of
            Option.PRESENT previous_position =>
              if previous_position = stack_position 
                then
                  (0, visited)
d236 1
a236 1
          | _ => 
d261 3
a263 3
                      case opcode
                        of MirTypes.NEW_HANDLER _ =>
                           stack_position_after :: exception_stack_positions
d265 5
a269 5
                           (case exception_stack_positions
                              of _::rest => rest
                               | [] =>
                                 crash ("Badly nested OLD_HANDLER in block " ^
                                        MirTypes.print_tag tag ^ "."))
d325 1
a325 1
            used_by_opcodes ((tag, stack_position)::visited,
d336 1
a336 1
        used_by_block ([], 0, 0, [], start_tag)
d409 1
a409 1
              val positions = Map.apply (Map.from_list positions)
@


1.26
log
@Efficiency improvements
@
text
@d23 3
d325 2
a326 2
                Map.YES x => x
              | Map.NO =>
@


1.25
log
@Changes to procedurure and block annotations.
@
text
@d23 3
d137 1
d151 1
a151 1

d186 4
a189 2
        val _ = diagnostic (1, fn _ => $"analysing stack usage of procedure " ^^
                                       $(MirTypes.print_tag start_tag))
d216 6
d229 9
a237 15
          let
            val _ = diagnostic(2, fn _ => $"block " ^^ $(MirTypes.print_tag tag))
            val previous_position = Lists.assoc (tag, visited)
          in
            if previous_position = stack_position then
            (
              diagnostic(2, fn _ => $"visited before with " ^^ $(MLWorks.Integer.makestring previous_position));
              (0, visited)
            )
            else
              crash ("The block tagged " ^ MirTypes.print_tag tag ^
                     " has been reached with inconsistent stack positions.")
          end

        handle Lists.Assoc =>
d331 1
a331 1
          end
d353 1
a353 1

d355 1
@


1.24
log
@Add field to MirTypes.PROC_PARAMS.
@
text
@d23 3
d241 1
a241 1
                                 MirProcedure.I ({branches, except, exits, ...}, opcode)::instructions) =
d413 1
a413 2
            val {exits,
                 uses_stack,
a414 1
                 registers,
d416 1
a416 1
                   {leaf, registers_used, spill_sizes, loop_entry, ...}} = annotation
d418 1
a418 3
            {exits = exits,
             nr_registers = nr_registers,
             registers = registers,
d420 1
a420 4
             parameters = MirTypes.PROC_PARAMS {leaf = leaf,
                                                registers_used = registers_used,
                                                spill_sizes = spill_sizes,
                                                loop_entry = loop_entry,
@


1.23
log
@Changed the annotation of raise instructions to model the fact that
the raise might reach _any_ of the nexted continuation blocks.
@
text
@d23 4
d414 2
a415 1
                 parameters = MirTypes.PROC_PARAMS {leaf, registers_used, spill_sizes, ...}} = annotation
d424 1
@


1.23.1.1
log
@Fork for bug fixing
@
text
@a22 4
 *  Revision 1.23  1993/08/17  14:58:11  richard
 *  Changed the annotation of raise instructions to model the fact that
 *  the raise might reach _any_ of the nexted continuation blocks.
 *
@


1.22
log
@structure Option.
@
text
@d23 3
d196 1
a196 1
         *               when that exceptionis raised.
d279 20
a298 18
                    case except
                      of MirProcedure.Option.ABSENT => (maximum_used_after', visited')
                       | MirProcedure.Option.PRESENT tag =>
                         case exception_stack_positions'
                           of position::_ =>
                              let
                                val (used, visited'') =
                                  used_by_block (visited',
                                                 position,
                                                 maximum_used_after',
                                                 exception_stack_positions',
                                                 tag)
                              in
                                (if used > maximum_used_after' then used else maximum_used_after', visited'')
                              end
                            | [] => 
                              crash ("The exception block " ^ MirTypes.print_tag tag ^ " was reached " ^
                                     "without a stack position in force.")
@


1.21
log
@Removed Integer parameter
@
text
@d23 3
d352 1
a352 1
                           STACKOP(PUSH, reg, PRESENT position)
d354 1
a354 1
                           STACKOP(POP, reg, PRESENT position_after)
d356 1
a356 1
                           ALLOCATE_STACK(oper, reg, amount, PRESENT position)
d414 1
a414 1
                                                stack_allocated = MirTypes.PRESENT used}}
@


1.20
log
@Map substructure is now MirTypes.Map
Signature revisions
@
text
@d23 4
a96 1
require "../utils/integer";
a108 1
  structure Integer		: INTEGER
d210 1
a210 1
              diagnostic(2, fn _ => $"visited before with " ^^ $(Integer.makestring previous_position));
@


1.19
log
@Efficiency changes to use mononewmap for registers and tags
@
text
@d23 3
d118 1
a118 1
    structure Map = MirTypes.Debugger_Types.Datatypes.NewMap
d170 1
a170 1
        val block_map_fn = MirTypes.Map.tryApply block_map
d299 2
a300 2
                MirTypes.Map.YES x => x
              | MirTypes.Map.NO =>
d367 2
a368 2
	MirTypes.Map.map add_to_block block_map
	handle MirTypes.Map.Undefined => crash ("Block does not have a starting stack position.")
d386 1
a386 1
              val positions = MirTypes.Map.apply (MirTypes.Map.from_list positions)
@


1.18
log
@Got rid of some handles using tryApply and co
@
text
@d23 3
d167 1
a167 1
        val block_map_fn = Map.tryApply block_map
d296 2
a297 2
                Map.YES x => x
              | Map.NO =>
d364 2
a365 2
	Map.map add_to_block block_map
	handle Map.Undefined => crash ("Block does not have a starting stack position.")
d383 1
a383 1
              val positions = Map.apply (Map.from_list' MirTypes.order_tag positions)
@


1.17
log
@Removed some unncesessary intermediate lists which
were being built.
@
text
@d23 4
d164 1
a164 1
        val block_map_fn = Map.apply block_map
d291 5
a295 3
            val MirProcedure.B (annotation, instructions) = block_map_fn tag
              handle Map.Undefined =>
                crash ("Block " ^ MirTypes.print_tag tag ^ " was reached but not found.")
@


1.16
log
@Removed some redundant structures and sharing
@
text
@d23 3
a349 3
              handle Map.Undefined =>
                crash ("Block " ^ MirTypes.print_tag tag ^ " does not have a starting stack position.")

d351 1
a351 1
            (tag, MirProcedure.B (annotation, new_instructions))
d355 2
a356 11
(*
        Map.from_list' MirTypes.order_tag (map add_to_block (Map.to_list block_map))
*)
	Map.fold
	(fn (tree, x, y) =>
	 let
	   val (dom, ran) = add_to_block(x, y)
	 in
	   Map.define(tree, dom, ran)
	 end)
	(Map.empty' MirTypes.order_tag, block_map)
@


1.15
log
@Removed various uses of NewMap.to_list in favour of fold and union
@
text
@d23 3
a82 1
require "../utils/newmap";
a83 1
require "mirtypes";
a88 2

  structure MirTypes		: MIRTYPES
a93 1
  structure Map	        	: NEWMAP
d96 1
a96 2
  sharing MirTypes = MirProcedure.MirTypes = MirPrint.MirTypes
  sharing Map = MirProcedure.Map
d104 2
a106 1

d255 1
a255 1
                    ((maximum_used_after, visited), MirProcedure.Set.set_to_list branches)
@


1.14
log
@Added registers annotation to procedures.
@
text
@d23 3
d357 1
d359 9
@


1.13
log
@Improved use of Map.
@
text
@d23 3
d385 1
d390 1
@


1.12
log
@First version of the profiler
@
text
@d23 3
a115 7
    (*  == Ordering function for tags ==  *)

    fun tag_order (tag, tag') =
      if tag = tag' then Map.EQUAL
      else if MirTypes.order_tag (tag, tag') then Map.LESS
           else Map.GREATER

a116 1

d153 2
d280 1
a280 1
            val MirProcedure.B (annotation, instructions) = Map.apply block_map tag
d304 3
a306 2
     *  opcodes.  It is passed a Map.T of blocks and a Map.T from blocks to stack
     *  positions on entry and returns an updated Map.T of blocks.
d342 1
a342 1
              add_to_opcodes ([], Map.apply positions tag, instructions)
d351 1
a351 1
        Map.from_list tag_order (map add_to_block (Map.to_list block_map))
d369 1
a369 1
              val positions = Map.from_list tag_order positions
d381 1
d385 1
@


1.11
log
@Changed code to take advantage of uses_stack.  No analysis is performed
if the procedure does not contain stacking instruction.
@
text
@d23 4
d152 1
a152 1
    fun used_by_procedure (MirProcedure.P (_, start_tag, block_map)) =
d365 1
a365 1
    fun allocate (procedure as MirProcedure.P (annotation, start, block_map)) =
d394 1
a394 1
        MirProcedure.P (annotation', start, block_map')
@


1.10
log
@Corrected calculation of stack required in the presence of exceptions.
@
text
@d23 3
d363 11
a373 5
        val (used, positions) = used_by_procedure procedure

        val positions = Map.from_list tag_order positions

        val block_map' = add_offsets (positions, block_map)
d378 1
d382 1
@


1.9
log
@Rewrote in terms of MirProcedure annotated procedures and corrected
the algorithm so that it is no longer exponential on depth of block
nesting.
@
text
@d23 5
d182 1
d186 2
d189 1
d255 10
a264 5
                              used_by_block (visited,
                                             position,
                                             maximum_used_after,
                                             exception_stack_positions',
                                             tag)
@


1.8
log
@Changed stack allocation to cope with jumping to the exception
continuation block with the correct stack state.
@
text
@d8 3
a10 2
 *  Three passes are made over the procedure.  The first pass determines the
 *  total amount of static stack required by the procedure by tracing all
d12 2
a13 6
 *  in a loop is consistent).  The second path traces the control flow of
 *  individual blocks in order to determine the maximum value that the stack
 *  pointer could take on entry to the block.  This is done by iteration,
 *  choosing the most pessimistic prediction.  Finally, the blocks are
 *  remade with these most pessimistic stack offsets added to any stack
 *  operations.
a18 3
 *  2.  It may be possible to merge the first and second passes in some way.
 *      The third pass should remain separate in order to avoid rebuilding
 *      the procedure many times.
d23 4
d60 1
a60 1
require "mirtables";
a62 1
require "switches";
d68 8
a75 9
  structure MirTypes	: MIRTYPES
  structure MirPrint	: MIRPRINT
  structure Crash	: CRASH
  structure Lists	: LISTS
  structure MirTables	: MIRTABLES
  structure Switches	: SWITCHES
  structure Integer	: INTEGER
  structure Map	        : NEWMAP
  structure Diagnostic	: DIAGNOSTIC
d77 2
a78 3
  sharing MirTypes =
    MirTables.MirTypes =
    MirPrint.MirTypes
d84 1
a84 1
    structure MirTypes = MirTypes
d90 3
d94 1
a94 1
      Diagnostic.output level
d96 1
a96 1
       "MirOptimiser (StackAlloc): " :: (output_function verbosity))
d98 1
d100 1
d120 1
a120 2
        "MirOptimiser (StackAlloc): I don't know how to deal with \
         \non-word stack allocation."
d133 1
a133 1
    (*  === FIRST PASS: ANALYSE MAXIMUM STACK USAGE OF A PROCEDURE ===
d135 3
a137 2
     *  Returns the maximum number of words required by the procedure for
     *  its stack allocation.
d140 1
a140 1
    fun used_by_procedure (MirTypes.PROC (start_tag, parameters, block_list)) =
d143 2
a144 2
        val _ = diagnostic (1, fn _ => ["analysing stack usage of procedure ",
                                        MirTypes.print_tag start_tag])
a145 7
        (* Convert the blocks into a Map for fast access. *)

        val blocks =
          Map.from_list tag_order
          (map (fn MirTypes.BLOCK pair => pair) block_list)


d148 4
a151 3
         *  Returns the maximum amount of stack required by a block AND its
         *  successors for stack allocation.  The following parameters are
         *  required:
d154 1
a154 1
         *               on entry. This is used to check consistency.
d158 5
a165 2
         *    flow_state The flow state (see MirTables) on entry to the
         *               block.
d169 1
a169 2
        fun used_by_block (visited, stack_position, maximum_used,
                           flow_state, handler_stack_positions, tag) =
d180 1
a180 1
              0
d182 2
a183 5
              Crash.impossible
              ("MirOptimiser (StackAlloc): The block tagged " ^
               MirTypes.print_tag tag ^ " has been reached with different "^
               "stack positions.  This means that code with badly nested "^
               "stack operations within a loop has been generated.")
d194 3
a196 8
            val visited' = (tag, stack_position)::visited

            fun used_by_opcodes (_, maximum_used, _, _, []) = maximum_used
              | used_by_opcodes (stack_position,
                                 maximum_used,
                                 flow_state,
                                 handler_stack_positions,
                                 opcode::opcodes) =
d205 3
a207 5
                        Crash.impossible
                        ("MirOptimiser (StackAlloc): The stack position "^
                         "has gone negative in block " ^
                         MirTypes.print_tag tag ^ ".  There must be badly "^
                         "nested stack operations somewhere.")
d210 1
a210 1
                  val handler_stack_positions' =
d213 1
a213 1
                           stack_position_after :: handler_stack_positions
d215 1
a215 1
                           (case handler_stack_positions
d218 3
a220 5
                                 Crash.impossible
                                 ("MirOptimiser (StackAlloc): Badly nested "^
                                  "OLD_HANDLER in block " ^ MirTypes.print_tag
                                  tag ^ "."))
                         | _ => handler_stack_positions
d223 1
a223 2
                    if stack_position_after > maximum_used then
                      stack_position_after else maximum_used
d225 1
a225 4
                  val {flow_state = flow_state_after, next, successors, ...} =
                    MirTables.successors (flow_state, opcode)

                  val maximum_used_anywhere =
d227 1
a227 1
                    (fn (maximum, successor) =>
d229 19
a247 5
                       val used =
                         case successor
                           of (MirTables.NORMAL, tag) =>
                              used_by_block (visited',
                                             stack_position_after,
d249 1
a249 2
                                             flow_state_after,
                                             handler_stack_positions',
d251 3
a253 19
                            | (MirTables.EXCEPTION, tag) =>
                              case handler_stack_positions'
                                of position::_ =>
                                   used_by_block (visited',
                                                  position,
                                                  maximum_used_after,
                                                  flow_state_after,
                                                  handler_stack_positions',
                                                  tag)
                                 | [] => 
                                   Crash.impossible
                                   ("MirOptimiser (StackAlloc): An exception " ^
                                    "continuation (block " ^ MirTypes.print_tag
                                    tag ^ ") has been reached when no " ^
                                    "handlers were in force.")
                     in
                       if used > maximum then used else maximum
                     end)
                    (maximum_used_after, successors)
d255 5
a259 5
                  used_by_opcodes (stack_position_after,
                                   maximum_used_anywhere,
                                   flow_state_after,
                                   handler_stack_positions',
                                   opcodes)
d261 4
d266 2
a267 1
            used_by_opcodes (stack_position,
d269 2
a270 7
                             flow_state,
                             handler_stack_positions,
                             Map.apply blocks tag)
            handle Map.Undefined =>
              Crash.impossible
              ("MirOptimiser (StackAlloc): Block " ^ MirTypes.print_tag
               tag ^ " was reached but not found.")
d277 1
a277 2
        used_by_block ([], 0, 0, MirTables.procedure_entry_flow_state, [],
                       start_tag)
d283 1
a283 1
    (*  === SECOND PASS: ANALYSE STACK POSITION ON BLOCK ENTRY ===
a284 132
     *  This function takes a procedure and returns a Map.T of blocks to the
     *  most pessimistic stack position on entry to that block.
     *)

    fun entry_positions (MirTypes.PROC(start_tag, params, block_list)) =
      let

        val _ = diagnostic (1, fn _ => ["find stack positions in ",
                                        MirTypes.print_tag start_tag])

        (* Convert the blocks into a Map for fast access. *)

        val blocks =
          Map.from_list tag_order
          (map (fn MirTypes.BLOCK pair => pair) block_list)

  
         (*  == Find blocks reached with a stack position ==
          *
          *  Given a block and a stack position on entry, this function
          *  returns a list of blocks which could be reached and their
          *  positions on entry.
          *)

        fun reached_positions (position, flow_state, handler_stack_positions, opcodes) =
          let

            fun process (_, _, _, reached, []) = reached

              | process (position, flow_state, handler_stack_positions, reached, opcode::opcodes) =
                let
                  val position_after = position + (stack_effect opcode)

                  val handler_stack_positions' =
                      case opcode
                        of MirTypes.NEW_HANDLER _ =>
                           position_after :: handler_stack_positions
                         | MirTypes.OLD_HANDLER =>
                           (case handler_stack_positions
                              of _::rest => rest
                               | [] =>
                                 Crash.impossible
                                 ("MirOptimiser (StackAlloc): Badly nested "^
                                  "OLD_HANDLER in procedure " ^ MirTypes.print_tag
                                  start_tag ^ "."))
                         | _ => handler_stack_positions

                  val {flow_state = flow_state_after, next, successors, ...} =
                    MirTables.successors (flow_state, opcode)

                  val reached' =
                    let
                      fun honk (MirTables.NORMAL, tag) =
                          (tag, position, flow_state_after, handler_stack_positions')
                        | honk (MirTables.EXCEPTION, tag) =
                          case handler_stack_positions'
                            of position::_ =>
                               (tag, position, flow_state_after, handler_stack_positions')
                             | [] =>
                               Crash.impossible
                               ("MirOptimiser (StackAlloc): Exception continuation " ^
                                "reached without a handler in force.")
                    in
                      (map honk successors) @@ reached
                    end
                in
                  process (position_after, flow_state_after,
                           handler_stack_positions', reached', opcodes)
                end

          in
            process (position, flow_state, handler_stack_positions, [], opcodes)
          end


        (*  == Process reachable blocks until all done ==
         *
         *  This function calls reached_positions repeatedly with its own
         *  results until the most pessimistic stack positions for each
         *  block are obtained.  This is guaranteed to terminate if we made
         *  it through the first pass (see above) which checks the
         *  consistency of the stack pointer within loops.
         *)

        fun iterate (processed, []) = processed

          | iterate (processed, (tag, position, flow_state, handler_stack_positions)::rest) =
            let

              (* Has the block been processed before?  If not, assume it was *)
              (* processed with a stack position of -1 so it gets processed. *)

              val previous_position = Map.apply processed tag
                handle Map.Undefined => ~1

            in

              if position > previous_position then

                let
                  val reached =
                    reached_positions (position, flow_state, handler_stack_positions, Map.apply blocks tag)
                  val processed' =
                    Map.define (processed, tag, position)
                in
                  iterate (processed', reached @@ rest)
                end

                handle Map.Undefined =>
                  Crash.impossible
                  ("MirOptimiser (StackAlloc): Block " ^ MirTypes.print_tag tag ^ " was reached but not found.")

              else

                iterate (processed, rest)

            end

      in

        (* Start the process running by asking it to analyse the first block *)
        (* with stack position zero. *)

        iterate (Map.empty tag_order,
                 [(start_tag, 0, MirTables.procedure_entry_flow_state, [])])

      end



    (*  === PASS 3: ADD OFFSETS TO PROCEDURE ===
     *
d286 2
a287 2
     *  opcodes.  It is passed a procedure and a Map.T from blocks to stack
     *  positions on entry.
d290 1
a290 2
    fun add_offsets (positions,
                     MirTypes.PROC(start_tag, params, block_list)) =
d293 1
a293 3
        val _ = diagnostic (1, fn _ =>
                            ["adding stack offsets to procedure ",
                             MirTypes.print_tag start_tag])
d295 1
a295 1
        fun add_to_block (MirTypes.BLOCK(tag, opcodes)) =
d299 1
a299 1
              | add_to_opcodes (done, position, opcode::opcodes) =
d309 1
a309 1
                          STACKOP(PUSH, reg, PRESENT position)
d317 1
a317 1
                  add_to_opcodes (opcode_with_offset :: done,
d319 1
a319 1
                                  opcodes)
d322 2
a323 4
            val new_opcodes =
              add_to_opcodes ([],
                              Map.apply positions tag,
                              opcodes)
d325 1
a325 3
                Crash.impossible
                ("MirOptimiser (StackAlloc): Block " ^ MirTypes.print_tag
                 tag ^ " does not have a starting stack position.")
d328 1
a328 1
            MirTypes.BLOCK(tag, new_opcodes)
d332 1
a332 1
        MirTypes.PROC(start_tag, params, map add_to_block block_list)
d340 1
a340 1
     *  Applies the three passes to the procedure and fills in the procedure
d344 1
a344 1
    fun allocate procedure =
d346 1
a346 1
        val used = used_by_procedure procedure
d348 1
a348 1
        val positions = entry_positions procedure
d350 1
a350 1
        val procedure_with_offsets = add_offsets (positions, procedure)
d352 1
a352 1
        val procedure_with_params =
d354 2
a355 4
            val MirTypes.PROC(start_tag,
                              MirTypes.PROC_PARAMS
                              {leaf, registers_used, spill_sizes, ...},
                              blocks) = procedure_with_offsets
d357 5
a361 7
            MirTypes.PROC(start_tag,
                          MirTypes.PROC_PARAMS
                          {leaf = leaf,
                           registers_used = registers_used,
                           spill_sizes = spill_sizes,
                           stack_allocated = MirTypes.PRESENT used},
                          blocks)
d365 1
a365 1
        procedure_with_params
a366 1

@


1.8.1.1
log
@Experimental version using MirProcedure annotated procedures.
@
text
@a28 4
 *  Revision 1.8  1992/01/31  10:02:50  richard
 *  Changed stack allocation to cope with jumping to the exception
 *  continuation block with the correct stack state.
 *
d62 1
a62 1
require "mirprocedure";
d65 1
d71 9
a79 9
  structure MirTypes		: MIRTYPES
  structure MirPrint		: MIRPRINT
  structure Crash		: CRASH
  structure Lists		: LISTS
  structure MirProcedure	: MIRPROCEDURE
  structure Switches		: SWITCHES
  structure Integer		: INTEGER
  structure Map	        	: NEWMAP
  structure Diagnostic		: DIAGNOSTIC
d81 3
a83 2
  sharing MirTypes = MirProcedure.MirTypes = MirPrint.MirTypes
  sharing Map = MirProcedure.Map
a89 1
    structure MirProcedure = MirProcedure
d120 2
a121 1
        "MirOptimiser (StackAlloc): I don't know how to deal with non-word stack allocation."
d140 1
a140 1
    fun used_by_procedure (MirProcedure.P (_, start_tag, block_map)) =
d143 2
a144 1
        val _ = diagnostic (1, fn _ => ["analysing stack usage of procedure ", MirTypes.print_tag start_tag])
d146 1
d148 5
d167 2
d172 2
a173 1
        fun used_by_block (visited, stack_position, maximum_used, handler_stack_positions, tag) =
d184 1
a184 1
              (previous_position, visited)
d201 4
a204 3
            fun used_by_opcodes (visited, _, maximum_used, _, []) = (maximum_used, visited)
              | used_by_opcodes (visited,
                                 stack_position,
d206 1
d208 1
a208 1
                                 MirProcedure.I ({exits, branches, except, ...}, opcode)::instructions) =
d242 4
a245 1
                  val (maximum_used_after', visited') =
d247 1
a247 1
                    (fn ((maximum, visited), tag) =>
d249 24
a272 6
                       val (used, visited') =
                         used_by_block (visited,
                                        stack_position_after,
                                        maximum_used_after,
                                        handler_stack_positions',
                                        tag)
d274 1
a274 1
                       (if used > maximum then used else maximum, visited')
d276 1
a276 23
                    ((maximum_used_after, visited), MirProcedure.Set.set_to_list branches)

                  val (maximum_used_after'', visited'') =
                    case except
                      of MirProcedure.Option.ABSENT => (maximum_used_after', visited')
                       | MirProcedure.Option.PRESENT tag => 
                         case handler_stack_positions'
                           of position::_ =>
                              let
                                val (used, visited'') =
                                  used_by_block (visited',
                                                 position,
                                                 maximum_used_after',
                                                 handler_stack_positions',
                                                 tag)
                              in
                                (if used > maximum_used_after' then used else maximum_used_after', visited'')
                              end
                            | [] => 
                              Crash.impossible
                              ("Stack Allocator: An exception block tagged " ^ MirTypes.print_tag tag ^
                               " has been reached when no handlers were in force.")

d278 3
a280 3
                  used_by_opcodes (visited'',
                                   stack_position_after,
                                   maximum_used_after'',
d282 1
a282 1
                                   if exits then [] else instructions)
a283 6

            val MirProcedure.B (_, instructions) =
              Map.apply block_map tag
              handle Map.Undefined =>
                Crash.impossible
                ("MirOptimiser (StackAlloc): Block " ^ MirTypes.print_tag tag ^ " was reached but not found.")
d285 1
a285 2
            used_by_opcodes ((tag, stack_position)::visited,
                             stack_position,
d287 1
d289 5
a293 1
                             instructions)
d300 2
a301 1
        used_by_block ([], 0, 0, [], start_tag)
d307 132
d446 2
a447 1
    fun add_offsets (positions, MirProcedure.P (annotation, start_tag, block_map)) =
d454 1
a454 1
        fun add_to_block (tag, MirProcedure.B (annotation, instructions)) =
d457 2
a458 2
            fun add_to_instructions (done, _, []) = rev done
              | add_to_instructions (done, position, MirProcedure.I (annotation, opcode)::instructions) =
d468 1
a468 1
                           STACKOP(PUSH, reg, PRESENT position)
d476 3
a478 1
                  add_to_instructions (MirProcedure.I (annotation, opcode_with_offset) :: done, position_after, instructions)
d481 4
a484 2
            val new_instructions =
              add_to_instructions ([], Map.apply positions tag, instructions)
d489 1
d491 1
a491 1
            (tag, MirProcedure.B (annotation, new_instructions))
a493 1
        val new_block_list = map add_to_block (Map.to_list block_map)
d495 1
a495 1
        MirProcedure.P (annotation, start_tag, Map.from_list tag_order new_block_list)
d509 1
a509 1
        val (used, visited) = used_by_procedure procedure
d511 1
a511 1
        val positions = Map.from_list tag_order visited
d513 1
a513 2
        val MirProcedure.P (annotation, start_tag, blocks) =
          add_offsets (positions, procedure)
d515 16
a530 1
        val {exits, parameters = MirTypes.PROC_PARAMS {leaf, registers_used, spill_sizes, ...}} = annotation
d532 1
a532 7
        MirProcedure.P ({exits = exits,
                         parameters = MirTypes.PROC_PARAMS {leaf = leaf,
                                                            registers_used = registers_used,
                                                            spill_sizes = spill_sizes,
                                                            stack_allocated = MirTypes.PRESENT used}},
                         start_tag,
                         blocks)
@


1.7
log
@A complete rewrite.  See documentation at the start of the file.
@
text
@d28 4
a31 1
 *  $Log:	_stackallocator.sml,v $
d173 1
a173 1
                           flow_state, tag) =
d203 1
a203 1
            fun used_by_opcodes (_, maximum_used, _, []) = maximum_used
d207 1
d224 14
d250 23
a272 5
                         used_by_block (visited',
                                        stack_position_after,
                                        maximum_used_after,
                                        flow_state_after,
                                        successor)
d281 1
d288 1
d300 1
a300 1
        used_by_block ([], 0, 0, MirTables.procedure_entry_flow_state,
d333 1
a333 1
        fun reached_positions (position, flow_state, opcodes) =
d336 1
a336 1
            fun process (_, _, reached, []) = reached
d338 1
a338 1
              | process (position, flow_state, reached, opcode::opcodes) =
d342 14
d360 14
a373 3
                    (map (fn tag =>
                          (tag, position, flow_state_after)) successors) @@
                    reached
d376 1
a376 1
                           reached', opcodes)
d380 1
a380 1
            process (position, flow_state, [], opcodes)
d395 1
a395 1
          | iterate (processed, (tag, position, flow_state)::rest) =
d410 1
a410 2
                    reached_positions (position, flow_state,
                                       Map.apply blocks tag)
d419 1
a419 3
                  ("MirOptimiser (StackAlloc): Block " ^ 
                   MirTypes.print_tag tag ^ " was reached " ^
                   "but not found.")
d433 1
a433 1
                 [(start_tag, 0, MirTables.procedure_entry_flow_state)])
@


1.6
log
@Added extra documentation and a safeguard against procedures with
no exits points.
@
text
@d6 11
a16 7
 *  Description
 *  -----------
 *  The stack allocator analyses an MIR procedure to determine how much
 *  space is required by the stack allocating instruction within it.  This
 *  amount is entered into the procedure parameters so that the procedure
 *  can allocate the space in one go on procedure entry, and use the offsets
 *  attached to the instructions as positions within this space.
a17 7
 *  The amount of space required is obtained by tracing the execution of the
 *  procedure, keeping track of the current stack position and the maximum
 *  required to far.  When the flow of execution meets the worst case is
 *  assumed.  (For example, if two branches of a procedure come together,
 *  one of which contains a PUSH and a POP, the other of which contains no
 *  stack instructions, then the amount required is one word.)
 *
d21 4
a24 7
 *      determined at run-time.  At the moment loops in the MIR which
 *      allocate more stack on each iteration will cause this module to
 *      loop.
 *  2.  This module cannot cope with procedures which have no exit points,
 *      as the maximum amount of stack on exit is taken as the amount
 *      required by the procedure.  This condition causes a Crash to be
 *      raised at the moment.
d29 4
d58 1
a58 1
require "../utils/balancedtree";
a62 1
require "_proceduremap";
d75 1
a75 1
  structure Tree	: BALANCEDTREE
d98 10
a107 1
    (*  == Stack State ==
d109 2
a110 2
     *  The state keeps track of the current stack pointer and the maximum
     *  value reached so far.
d113 2
a114 1
    datatype state = STATE of {current : int, maximum : int}
d116 22
a137 1
    fun push (STATE {current, maximum}, amount) =
d139 119
a257 1
	val current = current + amount
d259 6
a264 2
	STATE {current = current,
	       maximum = if current>maximum then current else maximum}
a266 8
    fun pop (STATE {current, maximum}, amount) =
      if amount > current then
	Crash.impossible
	("MirOptimiser (StackAlloc): Unbalaced stack --- too many " ^
	 "pops.")
      else
	STATE {current = current - amount,
	       maximum = maximum}
d269 1
a269 2

    (*  === PROCEDURE MAPPING STRUCTURE ===
d271 2
a272 2
     *  This is passed as a parameter to the generalized proceduremap
     *  functor.
d275 2
a276 1
    structure ProcedureMapping_ : PROCEDUREMAPPING =
d278 2
a279 1
      struct
d281 1
a281 1
	structure MirTypes = MirTypes
d283 3
a285 1
	type state = state
d287 7
a293 5
	(*  == Modification Function ==
	 *
	 *  Translates some instructions into stack state operations and fills
	 *  in the stack offset field of ALLOCATE_STACK.
	 *)
d295 2
a296 3
	local
	  open MirTypes
	in
d298 1
a298 5
	  fun function (state as STATE {current, ...},
			ALLOCATE_STACK(ALLOC, reg, amount, _)) =
	      (diagnostic (2, fn _ => ["push ", Integer.makestring amount]);
	       [(ALLOCATE_STACK(ALLOC, reg, amount, PRESENT current),
		 push (state, amount))])
d300 3
a302 4
	    | function (state as STATE {current, ...},
			STACKOP(PUSH, reg, _)) =
	      (diagnostic (2, fn _ => ["push 1"]);
	       [(STACKOP(PUSH, reg, PRESENT current), push (state, 1))])
d304 2
a305 3
	    | function (state, opcode as DEALLOCATE_STACK(ALLOC, amount)) =
	      (diagnostic (2, fn _ => ["pop ", Integer.makestring amount]);
	       [(opcode, pop (state, amount))])
d307 8
a314 7
	    | function (state, opcode as STACKOP(POP, reg, _)) =
	      let
		val _ = diagnostic (2, fn _ => ["pop 1"])
		val state' as STATE {current, ...} = pop (state, 1)
	      in
		[(STACKOP(POP, reg, PRESENT current), state')]
	      end
d316 3
a318 4
	    | function (_, ALLOCATE_STACK _) =
	      Crash.unimplemented
	      ("MirOptimiser (StackAlloc): I don't know how to deal with " ^
	       "non-word allocation.")
a319 4
	    | function (_, DEALLOCATE_STACK _) =
	      Crash.unimplemented
	      ("MirOptimiser (StackAlloc): I don't know how to deal with " ^
	       "non-word allocation.")
d321 8
a328 1
	    | function (state, opcode) = [(opcode, state)]
d330 1
a330 1
	end
d332 2
d335 2
a336 4
	(*  == Meet and Choose ==
	 *
	 *  The most pessimistic state is one which requires more stack space.
	 *)
d338 2
a339 7
	fun meet (STATE {current, maximum},
		  STATE {current = current', maximum = maximum'}) =
          (
            diagnostic (3, fn _ => ["meet (", Integer.makestring current,
                                    ",", Integer.makestring maximum, ") and (",
                                    Integer.makestring current', ",",
                                    Integer.makestring maximum', ")"]);
d341 1
a341 3
            STATE {current = if current>current' then current else current',
                   maximum = if maximum>maximum' then maximum else maximum'}
          )
d343 1
a343 7
	fun choose (STATE {current, maximum},
		    STATE {current = current', maximum = maximum'}) =
          (
            diagnostic (3, fn _ => ["choose (", Integer.makestring current,
                                    ",", Integer.makestring maximum, ") and (",
                                    Integer.makestring current', ",",
                                    Integer.makestring maximum', ")"]);
d345 9
a353 2
            current' > current orelse maximum' > maximum
          )
d355 5
a359 1
      end
d361 1
d363 1
a363 5
    (*  === THE MAPPING STRUCTURE ===
     *
     *  This is the application of the ProcedureMapping functor to the above
     *  structure.
     *)
d365 1
a365 8
    structure ProcedureMap_ = ProcedureMap (
      structure ProcedureMapping = ProcedureMapping_
      structure MirTypes = MirTypes
      structure Tree = Tree
      structure Crash = Crash
      structure MirTables = MirTables
      structure Switches = Switches
    )
d367 1
d369 11
a379 1
    (*  === ALLOCATE STACK FOR A PROCEDURE ===
d381 3
a383 1
     *  This is the function exported.
d386 2
a387 1
    fun allocate (procedure as MirTypes.PROC(start_tag, _, _)) =
a388 2
	val _ = diagnostic (1, fn _ => ["processing procedure ",
					MirTypes.print_tag start_tag])
d390 3
a392 1
	val start_state = STATE {current = 0, maximum = 0}
d394 2
a395 8
	val (procedure, end_states) =
	  case ProcedureMap_.apply (start_state, procedure)
            of (_, []) =>
              Crash.impossible
              ("MirOptimiser (StackAlloc): Procedure " ^
               MirTypes.print_tag start_tag ^ " cannot be analysed because " ^
               "it has no exit points.")
             | other_result => other_result
d397 4
a400 4
        val _ = diagnostic (3, fn _ => "End maxima:" ::
                            (map (fn STATE {maximum, ...} =>
                                  " " ^ Integer.makestring maximum)
                             end_states))
d402 18
a419 5
	val stack_required =
	  Lists.reducel
	  (fn (total, STATE {maximum, ...}) =>
	   if maximum > total then maximum else total)
	  (0, end_states)
d421 8
a428 2
        val _ = diagnostic (3, fn _ => ["Stack required: ",
                                        Integer.makestring stack_required])
d430 3
a432 1
	val MirTypes.PROC(start_tag, params, blocks) = procedure
a433 11
	val params =
	  let
	    val MirTypes.PROC_PARAMS {leaf, registers_used, spill_sizes, ...} =
	      params
	  in
	    MirTypes.PROC_PARAMS
	    {leaf = leaf,
	     registers_used = registers_used,
	     spill_sizes = spill_sizes,
	     stack_allocated = MirTypes.PRESENT stack_required}
	  end
d435 2
a437 1
	MirTypes.PROC(start_tag, params, blocks)
d439 34
d474 2
@


1.5
log
@Added offsets to POP instructions as well as PUSH instructions.
I'm not sure why I didn't do this before.
@
text
@d1 53
a53 1
(* stackallocator.sml the functor *)
a54 5
(* $Log:	_stackallocator.sml,v $
Revision 1.4  91/11/19  16:05:50  richard
Changed debugging output to use the Diagnostic module, which
prevents the debugging output strings being constructed even
if they aren't printed.
a55 16
Revision 1.3  91/11/08  16:06:28  richard
Added offset argument to STACKOPs.

Revision 1.2  91/11/07  16:10:46  richard
The ProcedureMap structure is built inside this functor, so that extra
processing can take place. Also added debugging output.

Revision 1.1  91/10/29  16:41:57  richard
Initial revision

Revision 1.1  91/10/29  12:16:47  richard
Initial revision

Copyright (C) 1991 Harlequin Ltd.
*)

d197 5
a201 2
	  STATE {current = if current>current' then current else current',
		 maximum = if maximum>maximum' then maximum else maximum'}
d203 4
d209 5
a213 1
	  current' > current orelse maximum' > maximum
d215 3
d250 7
a256 1
	  ProcedureMap_.apply (start_state, procedure)
d258 5
d268 3
@


1.4
log
@Changed debugging output to use the Diagnostic module, which
prevents the debugging output strings being constructed even
if they aren't printed.
@
text
@d4 5
d136 7
a142 3
	    | function (state, opcode as STACKOP(POP, _, _)) =
	      (diagnostic (2, fn _ => ["pop 1"]);
	       [(opcode, pop (state, 1))])
@


1.3
log
@Added offset argument to STACKOPs.
@
text
@d4 3
d20 1
a21 1
require "../utils/print";
a40 1
  structure Print	: PRINT
d43 1
d54 1
d57 1
a57 1
    (* == Debugging information output == *)
d59 4
a62 4
    fun info message =
      if !Switches.stackallocator_debug then
	Print.print ("MIR Optimiser (StackAlloc): "^message^"\n")
      else ();
d118 1
a118 1
	      (info ("push " ^ Integer.makestring amount);
d124 1
a124 1
	      (info "push 1";
d128 1
a128 1
	      (info ("pop " ^ Integer.makestring amount);
d132 1
a132 1
	      (info "pop 1";
d188 1
a188 1
    fun allocate procedure =
d190 3
@


1.2
log
@The ProcedureMap structure is built inside this functor, so that extra
processing can take place. Also added debugging output.
@
text
@d4 4
d118 2
a119 1
	    | function (state, opcode as STACKOP(PUSH, reg)) =
d121 1
a121 1
	       [(opcode, push (state, 1))])
d127 1
a127 1
	    | function (state, opcode as STACKOP(POP, reg)) =
@


1.1
log
@Initial revision
@
text
@d4 3
d13 2
d17 2
d20 4
a23 1
require "proceduremap";
d29 1
d32 5
d38 3
a40 1
) : PROCEDUREMAPPING =
d42 2
d49 8
d83 2
a84 1
    (*  == Modification Function ==
d86 2
a87 2
     *  Translates some instructions into stack state operations and fills
     *  in the stack offset field of ALLOCATE_STACK.
d90 1
a90 3
    local
      open MirTypes
    in
d92 1
a92 4
      fun function (state as STATE {current, ...},
		    ALLOCATE_STACK(ALLOC, reg, amount, _)) =
	  [(ALLOCATE_STACK(ALLOC, reg, amount, PRESENT current),
	    push (state, amount))]
d94 1
a94 2
	| function (state, opcode as STACKOP(PUSH, reg)) =
	  [(opcode, push (state, 1))]
d96 1
a96 2
	| function (state, opcode as DEALLOCATE_STACK(ALLOC, amount)) =
	  [(opcode, pop (state, amount))]
d98 5
a102 2
	| function (state, opcode as STACKOP(POP, reg)) =
	  [(opcode, pop (state, 1))]
d104 3
a106 4
	| function (_, ALLOCATE_STACK _) =
	  Crash.unimplemented
	  ("MirOptimiser (StackAlloc): I don't know how to deal with " ^
	   "non-word allocation.")
d108 5
a112 4
	| function (_, DEALLOCATE_STACK _) =
	  Crash.unimplemented
	  ("MirOptimiser (StackAlloc): I don't know how to deal with " ^
	   "non-word allocation.")
d114 3
a116 1
	| function (state, opcode) = [(opcode, state)]
d118 3
a120 1
    end
d122 3
d126 4
a129 4
    (*  == Meet and Choose ==
     *
     *  The most pessimistic state is one which requires more stack space.
     *)
d131 4
a134 4
    fun meet (STATE {current, maximum},
	      STATE {current = current', maximum = maximum'}) =
      STATE {current = if current>current' then current else current',
	     maximum = if maximum>maximum' then maximum else maximum'}
d136 1
a136 3
    fun choose (STATE {current, maximum},
		STATE {current = current', maximum = maximum'}) =
      current' > current orelse maximum' > maximum
d138 1
d140 19
a158 1
    (*  == Start state ==
d160 2
a161 1
     *  The initial stack is set to zero.
d164 8
a171 1
    val start = STATE {current = 0, maximum = 0}
d174 1
a174 1
    (*  == Postprocessing ==
d176 1
a176 2
     *  At the end of processing, take the most pessimistic stack size on
     *  procedure exit and put it into the procedure parameters.
d179 1
a179 5
    fun finish (states,
		MirTypes.PROC (start_tag,
			       MirTypes.PROC_PARAMS
			       {leaf, registers_used, spill_sizes, ...},
			       blocks)) =
d181 5
d190 15
a204 1
	  (0, states)
d206 3
a208 7
	MirTypes.PROC (start_tag,
		       MirTypes.PROC_PARAMS
		       {leaf = leaf,
			registers_used = registers_used,
			spill_sizes = spill_sizes,
			stack_allocated = MirTypes.PRESENT stack_required},
		       blocks)
@
