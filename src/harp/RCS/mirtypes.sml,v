head	1.85;
access;
symbols
	MLW_daveb_inline_1_4_99:1.85.1
	MLWorks_21c0_1999_03_25:1.85
	MLWorks_20c1_1998_08_20:1.84
	MLWorks_20c0_1998_08_04:1.84
	MLWorks_20b2c2_1998_06_19:1.84
	MLWorks_20b2_Windows_1998_06_12:1.84
	MLWorks_20b1c1_1998_05_07:1.84
	MLWorks_20b0_1998_04_07:1.84
	MLWorks_20b0_1998_03_20:1.84
	MLWorks_20m2_1998_02_16:1.84
	MLWorks_20m1_1997_10_23:1.84
	MLWorks_11r1:1.82.1.1.1.1.1
	MLWorks_workspace_97:1.84.2
	MLWorks_dt_wizard:1.84.1
	MLWorks_11c0_1997_09_09:1.82.1.1.1.1
	MLWorks_10r3:1.82.1.1.3
	MLWorks_10r2_551:1.82.1.1.2
	MLWorks_11:1.82.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.82.1.1
	MLWorks_20m0_1997_06_20:1.83
	MLWorks_1_0_r2c2_1997_06_14:1.82.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.82.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.82.1
	MLWorks_BugFix_1997_04_24:1.82
	MLWorks_1_0_r2_Win32_1997_04_11:1.82
	MLWorks_1_0_r2_Unix_1997_04_04:1.82
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.81.6.1.1
	MLWorks_gui_1996_12_18:1.81.7
	MLWorks_1_0_Win32_1996_12_17:1.81.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.81.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.81.4.1
	MLWorks_1_0_Irix_1996_11_28:1.81.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.81.5
	MLWorks_1_0_Unix_1996_11_14:1.81.4
	MLWorks_Open_Beta2_1996_10_11:1.81.3
	MLWorks_License_dev:1.81.2
	MLWorks_1_open_beta_1996_09_13:1.81.1
	MLWorks_Open_Beta_1996_08_22:1.81
	MLWorks_Beta_1996_07_02:1.81
	MLWorks_Beta_1996_06_07:1.81
	MLWorks_Beta_1996_06_06:1.81
	MLWorks_Beta_1996_06_05:1.81
	MLWorks_Beta_1996_06_03:1.81
	MLWorks_Beta_1996_05_31:1.81
	MLWorks_Beta_1996_05_30:1.81
	ML_beta_release_12/08/94:1.71
	ML_beta_release_03/08/94:1.71
	ML_revised_beta_release_25/05/94:1.70
	ML_final_beta_release_02/03/94:1.68
	mlworks-28-01-1994:1.68
	Release:1.66
	mlworks-beta-01-09-1993:1.66
	MLWorks-1-0-4-29/01/1993:1.61
	MLWorks-1-0-3-21/12/1992:1.59
	MLWorks-1-0-2-15/12/1992:1.59
	MLWorks-1-0-1-04/12/1992:1.58
	checkpoint_17_08_92:1.54
	Ten15_release_19-08-91:1.8
	ten15_release:1.3;
locks; strict;
comment	@ * @;


1.85
date	99.02.02.16.01.21;	author mitchell;	state Exp;
branches
	1.85.1.1;
next	1.84;

1.84
date	97.07.31.12.57.13;	author jont;	state Exp;
branches
	1.84.1.1
	1.84.2.1;
next	1.83;

1.83
date	97.05.01.12.37.40;	author jont;	state Exp;
branches;
next	1.82;

1.82
date	97.01.16.12.33.34;	author matthew;	state Exp;
branches
	1.82.1.1;
next	1.81;

1.81
date	96.05.14.10.16.44;	author matthew;	state Exp;
branches
	1.81.1.1
	1.81.2.1
	1.81.3.1
	1.81.4.1
	1.81.5.1
	1.81.6.1
	1.81.7.1;
next	1.80;

1.80
date	96.02.26.12.48.36;	author jont;	state Exp;
branches;
next	1.79;

1.79
date	96.02.02.12.20.12;	author jont;	state Exp;
branches;
next	1.78;

1.78
date	95.12.20.12.41.49;	author jont;	state Exp;
branches;
next	1.77;

1.77
date	95.01.04.12.59.40;	author matthew;	state Exp;
branches;
next	1.76;

1.76
date	94.11.23.13.59.47;	author matthew;	state Exp;
branches;
next	1.75;

1.75
date	94.11.11.14.04.44;	author jont;	state Exp;
branches;
next	1.74;

1.74
date	94.09.30.12.44.00;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	94.09.14.13.50.05;	author matthew;	state Exp;
branches;
next	1.72;

1.72
date	94.08.25.13.31.34;	author matthew;	state Exp;
branches;
next	1.71;

1.71
date	94.07.21.15.50.11;	author matthew;	state Exp;
branches;
next	1.70;

1.70
date	94.05.12.12.40.40;	author richard;	state Exp;
branches;
next	1.69;

1.69
date	94.03.09.14.56.59;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	94.01.17.18.29.04;	author daveb;	state Exp;
branches;
next	1.67;

1.67
date	93.11.04.16.29.56;	author jont;	state Exp;
branches;
next	1.66;

1.66
date	93.07.29.14.18.32;	author nosa;	state Exp;
branches
	1.66.1.1;
next	1.65;

1.65
date	93.04.27.10.58.57;	author richard;	state Exp;
branches;
next	1.64;

1.64
date	93.03.10.18.01.09;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	93.03.04.09.56.22;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	93.03.01.14.06.26;	author matthew;	state Exp;
branches;
next	1.61;

1.61
date	93.01.28.09.46.25;	author jont;	state Exp;
branches;
next	1.60;

1.60
date	93.01.04.17.00.39;	author jont;	state Exp;
branches;
next	1.59;

1.59
date	92.12.08.19.30.24;	author jont;	state Exp;
branches;
next	1.58;

1.58
date	92.12.01.12.47.30;	author daveb;	state Exp;
branches;
next	1.57;

1.57
date	92.10.29.17.30.04;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	92.08.26.13.29.49;	author jont;	state Exp;
branches;
next	1.55;

1.55
date	92.08.24.13.10.37;	author richard;	state Exp;
branches;
next	1.54;

1.54
date	92.06.29.08.07.27;	author clive;	state Exp;
branches;
next	1.53;

1.53
date	92.06.18.16.12.49;	author richard;	state Exp;
branches;
next	1.52;

1.52
date	92.06.16.19.14.45;	author jont;	state Exp;
branches;
next	1.51;

1.51
date	92.05.06.17.14.29;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	92.04.14.08.56.01;	author clive;	state Exp;
branches;
next	1.49;

1.49
date	92.02.27.15.34.33;	author richard;	state Exp;
branches;
next	1.48;

1.48
date	92.02.07.12.47.47;	author richard;	state Exp;
branches;
next	1.47;

1.47
date	92.01.16.11.19.17;	author clive;	state Exp;
branches;
next	1.46;

1.46
date	92.01.14.13.47.43;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	91.12.02.13.57.47;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	91.11.20.12.20.34;	author jont;	state Exp;
branches;
next	1.43;

1.43
date	91.11.14.15.20.52;	author richard;	state Exp;
branches;
next	1.42;

1.42
date	91.11.14.10.51.03;	author richard;	state Exp;
branches;
next	1.41;

1.41
date	91.11.08.16.09.01;	author richard;	state Exp;
branches;
next	1.40;

1.40
date	91.10.28.15.16.47;	author richard;	state Exp;
branches;
next	1.39;

1.39
date	91.10.28.11.23.09;	author davidt;	state Exp;
branches;
next	1.38;

1.38
date	91.10.24.10.40.33;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	91.10.21.09.29.24;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	91.10.17.14.17.15;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	91.10.16.14.14.11;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	91.10.15.15.10.34;	author richard;	state Exp;
branches;
next	1.33;

1.33
date	91.10.11.13.43.08;	author richard;	state Exp;
branches;
next	1.32;

1.32
date	91.10.11.09.55.58;	author richard;	state Exp;
branches;
next	1.31;

1.31
date	91.10.10.13.44.42;	author richard;	state Exp;
branches;
next	1.30;

1.30
date	91.10.04.11.31.58;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	91.10.03.11.22.25;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	91.10.03.11.06.12;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	91.10.03.10.57.04;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	91.10.02.11.02.58;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	91.10.01.09.55.18;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	91.09.30.10.03.12;	author richard;	state Exp;
branches;
next	1.23;

1.23
date	91.09.25.14.54.29;	author richard;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	91.09.24.10.41.32;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	91.09.23.15.08.35;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	91.09.23.10.38.30;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	91.09.20.15.30.27;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	91.09.19.15.52.08;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	91.09.17.13.49.48;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	91.09.17.10.43.15;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	91.09.10.14.27.59;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	91.09.05.15.56.11;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	91.09.03.16.34.59;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	91.09.03.13.53.22;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	91.08.30.16.33.43;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.08.29.14.02.28;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.08.22.16.39.14;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.08.15.14.15.10;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.08.09.17.04.18;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.08.02.16.35.12;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.08.01.17.18.39;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.07.31.18.02.23;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.07.30.14.07.54;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.07.26.17.29.59;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.07.25.15.05.11;	author jont;	state Exp;
branches;
next	;

1.23.1.1
date	91.09.26.12.42.24;	author richard;	state Exp;
branches;
next	;

1.66.1.1
date	93.07.29.14.18.32;	author jont;	state Exp;
branches;
next	;

1.81.1.1
date	96.09.13.11.14.31;	author hope;	state Exp;
branches;
next	;

1.81.2.1
date	96.10.07.16.04.57;	author hope;	state Exp;
branches;
next	;

1.81.3.1
date	96.10.17.11.23.11;	author hope;	state Exp;
branches;
next	;

1.81.4.1
date	96.11.14.12.47.30;	author hope;	state Exp;
branches
	1.81.4.1.1.1;
next	;

1.81.4.1.1.1
date	96.11.28.14.59.02;	author hope;	state Exp;
branches;
next	;

1.81.5.1
date	96.11.22.18.07.33;	author hope;	state Exp;
branches;
next	;

1.81.6.1
date	96.12.17.17.46.17;	author hope;	state Exp;
branches
	1.81.6.1.1.1;
next	;

1.81.6.1.1.1
date	97.02.24.11.35.53;	author hope;	state Exp;
branches;
next	;

1.81.7.1
date	96.12.18.09.40.15;	author hope;	state Exp;
branches;
next	;

1.82.1.1
date	97.05.12.10.32.36;	author hope;	state Exp;
branches
	1.82.1.1.1.1
	1.82.1.1.2.1
	1.82.1.1.3.1;
next	;

1.82.1.1.1.1
date	97.07.28.18.18.20;	author daveb;	state Exp;
branches
	1.82.1.1.1.1.1.1;
next	;

1.82.1.1.1.1.1.1
date	97.10.07.11.43.21;	author jkbrook;	state Exp;
branches;
next	;

1.82.1.1.2.1
date	97.09.08.17.11.54;	author daveb;	state Exp;
branches;
next	;

1.82.1.1.3.1
date	97.09.09.14.07.30;	author daveb;	state Exp;
branches;
next	;

1.84.1.1
date	97.09.10.19.22.22;	author brucem;	state Exp;
branches;
next	;

1.84.2.1
date	97.09.11.20.53.37;	author daveb;	state Exp;
branches;
next	;

1.85.1.1
date	99.04.01.17.56.10;	author daveb;	state Exp;
branches;
next	;


desc
@Abstract description of the mir
@


1.85
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* mirtypes.sml the signature *)
(*
$Log: mirtypes.sml,v $
 * Revision 1.84  1997/07/31  12:57:13  jont
 * [Bug #30215]
 * Remove BIC, and replace by INTTAG instruction
 *
 * Revision 1.83  1997/05/01  12:37:40  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.82  1997/01/16  12:33:34  matthew
 * Allow multiple tags for tagged instructions
 *
 * Revision 1.81  1996/05/14  10:16:44  matthew
 * Adding NOT32 MIR instruction
 *
 * Revision 1.80  1996/02/26  12:48:36  jont
 * mononewmap becomes monomap
 *
 * Revision 1.79  1996/02/02  12:20:12  jont
 * Add ADDW, SUBW for untagged integer operations
 * with register cleaning on overflow
 *
Revision 1.78  1995/12/20  12:41:49  jont
Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend

Revision 1.77  1995/01/04  12:59:40  matthew
require "../debugger/runtime_env";
\\nRenaming debugger_env to runtime_env

Revision 1.76  1994/11/23  13:59:47  matthew
Adding ALLOC_VECTOR

Revision 1.75  1994/11/11  14:04:44  jont
Add immediate store operations

Revision 1.74  1994/09/30  12:44:00  jont
Remove handler register concept

Revision 1.73  1994/09/14  13:50:05  matthew
Abstraction of debug information

Revision 1.72  1994/08/25  13:31:34  matthew
Remove various bits of annotation

Revision 1.71  1994/07/21  15:50:11  matthew
Added function argument register lists to BRANCH_AND_LINK, TAIL_CALL and ENTER
Changed loop_entry in procedure parameters to be a tag list, so we can have lots.

Revision 1.70  1994/05/12  12:40:40  richard
Add loop entry point to procedure parameters.

Revision 1.69  1994/03/09  14:56:59  jont
Adding load offset instruction

Revision 1.68  1994/01/17  18:29:04  daveb
Removed unnecessary exceptions from closures.

Revision 1.67  1993/11/04  16:29:56  jont
Added INTERRUPT instruction

Revision 1.66  1993/07/29  14:18:32  nosa
Debugger Environments for local and closure variable inspection
in the debugger;
new stack spill slots;
structure Option.

Revision 1.65  1993/04/27  10:58:57  richard
Changed PROFILE instruction to INTERCEPT.

Revision 1.64  1993/03/10  18:01:09  matthew
Signature revisions

Revision 1.63  1993/03/04  09:56:22  matthew
Removed (commented out) options.
Options & Info changes.

Revision 1.62  1993/03/01  14:06:26  matthew
Changed representation of value to include MLVALUEs

Revision 1.61  1993/01/28  09:46:25  jont
Added default options

Revision 1.60  1993/01/04  17:00:39  jont
Added code printing controls to options

Revision 1.59  1992/12/08  19:30:24  jont
Removed a number of duplicated signatures and structures

Revision 1.58  1992/12/01  12:47:30  daveb
Changes to propagate compiler options as parameters instead of references.

Revision 1.57  1992/10/29  17:30:04  jont
Added Map structure for mononewmaps to allow efficient implementation
of lookup tables for integer based values

Revision 1.56  1992/08/26  13:29:49  jont
Removed some redundant structures and sharing

Revision 1.55  1992/08/24  13:10:37  richard
Added NULLARY opcode type and ALLOC_BYTEARRAY.

Revision 1.54  1992/06/29  08:07:27  clive
Added type annotation information at application points

Revision 1.53  1992/06/18  16:12:49  richard
Added parameter to RAISE once again.

Revision 1.52  1992/06/16  19:14:45  jont
Expanded refs section of mir_code to allow for interpretive stuff

Revision 1.51  1992/05/06  17:14:29  jont
Added int_of_tag function

Revision 1.50  1992/04/14  08:56:01  clive
First version of the profiler

Revision 1.49  1992/02/27  15:34:33  richard
Changed the virtual register types to be structures of signature
VIRTUALREGISTER.

Revision 1.48.1.1  1992/02/27  15:34:33  richard
This version of MirTypes supplied monomorphic virtual register sets
as abstract types.

Revision 1.48  1992/02/07  12:47:47  richard
Added `hash_*_register'.
Abolished PRESERVE_ALL_REGS and PREVIOUS_ENVIRONMENT.

Revision 1.47  1992/01/16  11:19:17  clive
Alloc may now have a register argument for allocating arrays

Revision 1.46  1992/01/14  13:47:43  jont
Raise no longer has a parameter

Revision 1.45  1991/12/02  13:57:47  jont
Added tail call operation

Revision 1.44  91/11/20  12:20:34  jont
Added exception generating fp opcodes

Revision 1.43  91/11/14  15:20:52  richard
Added CALL_C opcode.

Revision 1.42  91/11/14  10:51:03  richard
Removed references to fp_double registers.

Revision 1.41  91/11/08  16:09:01  richard
Added FSTREF, FLDREF and an offset argument to STACKOPs.

Revision 1.40  91/10/28  15:16:47  richard
Changed the form of the allocation instructions yet again. This
time they're a bit more orthogonal.

Revision 1.39  91/10/28  11:23:09  davidt
ALLOCATE doesn't have a scratch register or a proc_ref any more.

Revision 1.38  91/10/24  10:40:33  jont
Added BTA and BNT for tagged value testing

Revision 1.37  91/10/21  09:29:24  jont
New local and external reference code

Revision 1.36  91/10/17  14:17:15  jont
New style ALLOC opcodes

Revision 1.35  91/10/16  14:14:11  jont
Added parameter to heap allocation to indicate position in closure
of call_c function
Updated to reflect new simplified module structure

Revision 1.34  91/10/15  15:10:34  richard
Added ALLOC_PAIR.

Revision 1.33  91/10/11  13:43:08  richard
Added DEALLOC_STACK.

Revision 1.32  91/10/11  09:55:58  richard
Parameters removed from ENTER and added to the
procedure type. Parameters for spill, stack, and register
usage added.

Revision 1.31  91/10/10  13:44:42  richard
Removed RESTORE_REGS and PRESERVE_REGS and replaced with parameterized
ENTER and PREVIOUS_ENVIRONMENT. Parameterized RAISE.

Revision 1.30  91/10/04  11:31:58  jont
Added new PROC type

Revision 1.29  91/10/03  11:22:25  jont
New code structure

Revision 1.28  91/10/03  11:06:12  jont
Added tag to refs

Revision 1.27  91/10/03  10:57:04  jont
Changed CODE structure to enable easier handling of code, values
and load time semantics

Revision 1.26  91/10/02  11:02:58  jont
Removed real register options, these are being done elsewhere

Revision 1.25  91/10/01  09:55:18  richard
Added ordering functions on gc, non_gc, fp and fp_double registers so
that they can be used in tables.

Revision 1.24  91/09/30  10:03:12  richard
Added an ordering function on the any_register type.

Revision 1.23  91/09/25  14:54:29  richard
Added register conversion functions.

Revision 1.22  91/09/24  10:41:32  richard
Added tag equality function.

Revision 1.21  91/09/23  15:08:35  richard
Added an ordering function on block tags to allow use of lookup tables.

Revision 1.20  91/09/23  10:38:30  richard
Added NEW_HANDLER, OLD_HANDLER, and RAISE directives.

Revision 1.19  91/09/20  15:30:27  jont
Added PRESERVE_ALL_REGS.

Revision 1.18  91/09/19  15:52:08  jont
Added MODV

Revision 1.17  91/09/17  13:49:48  jont
Changed branches to target bl_dest

Revision 1.16  91/09/17  10:43:15  jont
Added ALLOCA for stack allocated items

Revision 1.15  91/09/10  14:27:59  jont
Added new type symbolic, and extra constructor GP_IMM_SYMB for
values not yet known

Revision 1.14  91/09/05  15:56:11  jont
Added LDREF and STREF to assist optimiser deduce available expressions

Revision 1.13  91/09/03  16:34:59  jont
Added LDB, STB

Revision 1.12  91/09/03  13:53:22  jont
Added PRESERVE_REGS and RESTORE_REGS. Removed ENTER_NO_CALLS
and EXIT_NO_CALLS

Revision 1.11  91/08/30  16:33:43  jont
Changed format for floating point operations to allow register colouring

Revision 1.10  91/08/29  14:02:28  jont
Slight change to ALLOC

Revision 1.9  91/08/22  16:39:14  jont
New ALLOC_REF
Removed data flow hints, these can be deduced.

Revision 1.8  91/08/15  14:15:10  jont
Updated for later version of HARP

Revision 1.7  91/08/09  17:04:18  jont
Added EXT_REF type

Revision 1.6  91/08/02  16:35:12  jont
Added a comment opcode to allow information to be passed through

Revision 1.5  91/08/01  17:18:39  jont
Added new opcodes for local reference and FN_CALL as required by the
loader

Revision 1.4  91/07/31  18:02:23  jont
Added some new instructions to indicate leaf procedures

Revision 1.3  91/07/30  14:07:54  jont
Minor changes

Revision 1.2  91/07/26  17:29:59  jont
Changed some types to allow register colouring information plus
more general purpose operands

Revision 1.1  91/07/25  15:05:11  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/set";
require "../utils/monomap";
require "../debugger/debugger_types";
require "virtualregister";


signature MIRTYPES =
  sig
    structure Set : SET
    structure Map : MONOMAP
    structure Debugger_Types : DEBUGGER_TYPES

    eqtype SCon

    structure GC	: VIRTUALREGISTER
    structure NonGC	: VIRTUALREGISTER
    structure FP	: VIRTUALREGISTER
    sharing GC.Set.Text = NonGC.Set.Text = FP.Set.Text
    datatype any_register =
      GC of GC.T |
      NON_GC of NonGC.T |
      FLOAT of FP.T

    val order_any_reg : any_register * any_register -> bool

    (* offset of spill slot N from the frame pointer *)
    datatype SlotInfo = SIMPLE of int | DEBUG of Debugger_Types.RuntimeEnv.Offset ref * string

    (* Symbolic values *)
    datatype symbolic =
      GC_SPILL_SIZE |
      NON_GC_SPILL_SIZE |
      GC_SPILL_SLOT of SlotInfo |
      NON_GC_SPILL_SLOT of SlotInfo |
      FP_SPILL_SLOT of SlotInfo

    (* Operands *)
    datatype gp_operand =
      GP_GC_REG of GC.T
    | GP_NON_GC_REG of NonGC.T
    | GP_IMM_INT of int (* For real ints, represented with run time tags *)
    | GP_IMM_ANY of int (* For other values *)
    | GP_IMM_SYMB of symbolic (* For unknown (macro) values *)
    exception NotAnyRegister
    val gp_to_any : gp_operand -> any_register
    val any_to_gp : any_register -> gp_operand
    datatype reg_operand =
      GC_REG of GC.T
    | NON_GC_REG of NonGC.T
    val reg_to_any : reg_operand -> any_register
    val any_to_reg : any_register -> reg_operand
    datatype fp_operand =
      FP_REG of FP.T
    val fp_to_any : fp_operand -> any_register
    val any_to_fp : any_register -> fp_operand
    (* Addresses in store *)
    eqtype tag
    sharing type tag = Map.object
    val init_tag: unit -> unit
    val new_tag: unit -> tag
    val int_of_tag : tag -> int
    val print_tag: tag -> string
    val print_tag_list: tag list -> string
    val order_tag: tag * tag -> bool
    val equal_tag: tag * tag -> bool
    datatype bl_dest = TAG of tag | REG of reg_operand
    (* Operations *)
    datatype binary_op =
      ADDU |
      SUBU |
      MULU |
      MUL32U |
      AND |
      OR | 
      EOR | 
      LSR | 
      ASL | 
      ASR

    datatype tagged_binary_op =
      ADDS |
      SUBS |

      (* Handle overflow specially for these *)
      (* (because traps are hard) *)
      ADD32S |
      SUB32S |

      MULS |
      DIVS |
      MODS |

      MUL32S |
      DIV32S |
      MOD32S |

      (* These can raise Div *)
      DIVU |
      MODU |
      DIV32U |
      MOD32U

    datatype unary_op = 
      MOVE |
      INTTAG |
      NOT | 
      NOT32
    datatype tagged_binary_fp_op = FADDV | FSUBV | FMULV | FDIVV
    datatype binary_fp_op = FADD | FSUB | FMUL | FDIV
    datatype tagged_unary_fp_op =
      FABSV |
      FNEGV |
      FSQRTV |
      FLOGEV |
      FETOXV
    datatype unary_fp_op =
      FMOVE |
      FABS |
      FNEG |
      FINT |
      FSQRT |
      FLOG10 |
      FLOG2 |
      FLOGE |
      FLOGEP1 |
      F10TOX |
      F2TOX |
      FETOX |
      TETOXM1 |
      FSIN |
      FCOS |
      FTAN |
      FASIN |
      FACOS |
      FATAN
    datatype stack_op = PUSH | POP
    datatype store_op = LD | ST | LDB | STB | LDREF | STREF
    datatype store_fp_op = FLD | FST | FSTREF | FLDREF
    datatype int_to_float = ITOF
    datatype float_to_int = FTOI
    datatype branch = BRA (* Branch to basic block *)
    datatype cond_branch =
      BTA | (* Branch on tagged *)
      BNT | (* Branch on not tagged *)
      BEQ |
      BNE | (* Branch on eq/not eq *)
      BHI | (* Unsigned > *)
      BLS | (* Unsigned <= *)
      BHS | (* Unsigned >= *)
      BLO | (* Unsigned < *)
      BGT | (* Signed > *)
      BLE | (* Signed <= *)
      BGE | (* Signed >= *)
      BLT   (* Signed < *)
    datatype fcond_branch =
      FBEQ |
      FBNE | (* Branch on eq/not eq *)
      FBLE | (* Signed <= *)
      FBLT   (* Signed < *)
    datatype branch_and_link = BLR
    datatype tail_call = TAIL
    datatype computed_goto = CGT
    datatype allocate =
      ALLOC |
      ALLOC_VECTOR |
      ALLOC_REAL |
      ALLOC_STRING |
      ALLOC_BYTEARRAY |
      ALLOC_REF
    datatype adr = LEA | LEO
    datatype nullary_op = CLEAN

    datatype opcode =
      TBINARY of tagged_binary_op * tag list * reg_operand * gp_operand * gp_operand |
      BINARY of binary_op * reg_operand * gp_operand * gp_operand |
      UNARY of unary_op * reg_operand * gp_operand |
      NULLARY of nullary_op * reg_operand |
      TBINARYFP of tagged_binary_fp_op * tag list * fp_operand * fp_operand *
      fp_operand |
      TUNARYFP of tagged_unary_fp_op * tag list * fp_operand * fp_operand |
      BINARYFP of binary_fp_op * fp_operand * fp_operand * fp_operand |
      UNARYFP of unary_fp_op * fp_operand * fp_operand |
      STACKOP of stack_op * reg_operand * int option |
      STOREOP of store_op * reg_operand * reg_operand * gp_operand |
      IMMSTOREOP of store_op * gp_operand * reg_operand * gp_operand | (* For CISCs only *)
      STOREFPOP of store_fp_op * fp_operand * reg_operand * gp_operand |
      REAL of int_to_float * fp_operand * gp_operand |
      FLOOR of float_to_int * tag * reg_operand * fp_operand |
      BRANCH of branch * bl_dest |
      TEST of cond_branch * tag * gp_operand * gp_operand |
      FTEST of fcond_branch * tag * fp_operand * fp_operand |
      (* Added set of argument registers *)
      BRANCH_AND_LINK of branch_and_link * bl_dest * Debugger_Types.Backend_Annotation * any_register list |
      (* Added set of argument registers *)
      TAIL_CALL of tail_call * bl_dest * any_register list |
      CALL_C |
      SWITCH of computed_goto * reg_operand * tag list |
      ALLOCATE of allocate * reg_operand * gp_operand |
      ALLOCATE_STACK of allocate * reg_operand * int * int option |
      DEALLOCATE_STACK of allocate * int |
      ADR of adr * reg_operand * tag |
      (* Interception *)
      INTERCEPT |
      (* Interruption *)
      INTERRUPT |
      (* Information points *)
      ENTER of any_register list | (* Entry point for procedure *)
      RTS | (* Return point from procedure *)
      NEW_HANDLER of reg_operand (* Pointer to the frame *) *
	tag (* tag on continuation point *) | (* Set handler inside function *)
      OLD_HANDLER | (* Restore previous handler *)
      RAISE of reg_operand | (* Raise the current handler (special call) *)
      COMMENT of string

    datatype refs = REFS of
      (tag * int) list *		(* internal references *)
      {requires : (string * int) list,		(* external references *)
       vars : (string * int) list, (* interpretive environment vars *)
       exns : (string * int) list, (* interpretive environment exns *)
       strs : (string * int) list, (* interpretive environment strs *)
       funs : (string * int) list} (* interpretive environment funs *)

    datatype valspec =
      SCON of SCon
    | MLVALUE of MLWorks.Internal.Value.ml_value

    datatype value =
      VALUE of tag * valspec

    datatype block = BLOCK of tag * opcode list

    datatype procedure_parameters = PROC_PARAMS of
      {spill_sizes	: {gc		: int,
                           non_gc	: int,
                           fp		: int} option,
       old_spill_sizes	: {gc		: int,
                           non_gc	: int,
                           fp		: int} option,
       stack_allocated	: int option}

    datatype procedure = PROC of
      string *          (* Procedure name *)
      tag *		(* tag of the procedure entry block *)
      procedure_parameters *
      block list *		(* procedure code *)
      Debugger_Types.RuntimeEnv.RuntimeEnv    (* runtime environment for code *)

    datatype mir_code = CODE of
      refs *
      value list *
      procedure list list	(* list of recursive procedure sets *)

  end
@


1.85.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.85  1999/02/02  16:01:21  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.84
log
@[Bug #30215]
Remove BIC, and replace by INTTAG instruction
@
text
@d4 4
a290 1
require "../basics/ident";
@


1.84.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.84  1997/07/31  12:57:13  jont
 * [Bug #30215]
 * Remove BIC, and replace by INTTAG instruction
 *
@


1.84.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.84  1997/07/31  12:57:13  jont
 * [Bug #30215]
 * Remove BIC, and replace by INTTAG instruction
 *
@


1.83
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
a359 1
      BIC | (* AND-NOT *)
d390 1
@


1.82
log
@Allow multiple tags for tagged instructions
@
text
@d4 3
d464 1
a464 1
      STACKOP of stack_op * reg_operand * int MLWorks.Option.option |
d480 1
a480 1
      ALLOCATE_STACK of allocate * reg_operand * int * int MLWorks.Option.option |
d516 1
a516 1
                           fp		: int} MLWorks.Option.option,
d519 2
a520 2
                           fp		: int} MLWorks.Option.option,
       stack_allocated	: int MLWorks.Option.option}
@


1.82.1.1
log
@branched from 1.82
@
text
@a3 3
 * Revision 1.82  1997/01/16  12:33:34  matthew
 * Allow multiple tags for tagged instructions
 *
@


1.82.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.82.1.1  1997/05/12  10:32:36  hope
 * branched from 1.82
 *
@


1.82.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.82.1.1  1997/05/12  10:32:36  hope
 * branched from 1.82
 *
@


1.82.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.82.1.1  1997/05/12  10:32:36  hope
 * branched from 1.82
 *
@


1.82.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.82.1.1.1.1  1997/07/28  18:18:20  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.81
log
@Adding NOT32 MIR instruction
@
text
@d4 3
d341 1
a341 1
    val print_tag_opt: tag MLWorks.Option.option -> string
d347 12
a358 15
    ADD |
    SUB |
    MULU |
    MULS |
    DIVU |
    DIVS |
    MODU |
    MODS |
    AND |
    OR | 
    BIC | (* AND-NOT *)
    EOR | 
    LSR | 
    ASL | 
    ASR
d360 21
a380 10
    ADDV |
    SUBV |
    MULV |
    DIVV |
    MODV |
    ADDW |
    SUBW |
    MULW |
    DIVW |
    MODW
d452 1
a452 1
      TBINARY of tagged_binary_op * tag MLWorks.Option.option * reg_operand * gp_operand * gp_operand |
d456 1
a456 1
      TBINARYFP of tagged_binary_fp_op * tag MLWorks.Option.option * fp_operand * fp_operand *
d458 1
a458 1
      TUNARYFP of tagged_unary_fp_op * tag MLWorks.Option.option * fp_operand * fp_operand |
@


1.81.7.1
log
@branched from 1.81
@
text
@a3 3
 * Revision 1.81  1996/05/14  10:16:44  matthew
 * Adding NOT32 MIR instruction
 *
@


1.81.6.1
log
@branched from 1.81
@
text
@a3 3
 * Revision 1.81  1996/05/14  10:16:44  matthew
 * Adding NOT32 MIR instruction
 *
@


1.81.6.1.1.1
log
@branched from 1.81.6.1
@
text
@a3 3
 * Revision 1.81.6.1  1996/12/17  17:46:17  hope
 * branched from 1.81
 *
@


1.81.5.1
log
@branched from 1.81
@
text
@a3 3
 * Revision 1.81  1996/05/14  10:16:44  matthew
 * Adding NOT32 MIR instruction
 *
@


1.81.4.1
log
@branched from 1.81
@
text
@a3 3
 * Revision 1.81  1996/05/14  10:16:44  matthew
 * Adding NOT32 MIR instruction
 *
@


1.81.4.1.1.1
log
@branched from 1.81.4.1
@
text
@a3 3
 * Revision 1.81.4.1  1996/11/14  12:47:30  hope
 * branched from 1.81
 *
@


1.81.3.1
log
@branched from 1.81
@
text
@a3 3
 * Revision 1.81  1996/05/14  10:16:44  matthew
 * Adding NOT32 MIR instruction
 *
@


1.81.2.1
log
@branched from 1.81
@
text
@a3 3
 * Revision 1.81  1996/05/14  10:16:44  matthew
 * Adding NOT32 MIR instruction
 *
@


1.81.1.1
log
@branched from 1.81
@
text
@a3 3
 * Revision 1.81  1996/05/14  10:16:44  matthew
 * Adding NOT32 MIR instruction
 *
@


1.80
log
@mononewmap becomes monomap
@
text
@d4 3
d372 3
a374 2
    MOVE |
    NOT
@


1.79
log
@Add ADDW, SUBW for untagged integer operations
with register cleaning on overflow
@
text
@d4 4
d273 1
a273 1
require "../utils/mononewmap";
d282 1
a282 1
    structure Map : MONONEWMAP
@


1.78
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d4 4
d357 7
a363 1
    MODV
@


1.77
log
@require "../debugger/runtime_env";
\\nRenaming debugger_env to runtime_env
@
text
@d4 4
a265 1
require "../utils/option";
a274 1
    structure Option : OPTION
d327 1
a327 1
    val print_tag_opt: tag Option.opt -> string
d423 1
a423 1
      TBINARY of tagged_binary_op * tag Option.opt * reg_operand * gp_operand * gp_operand |
d427 1
a427 1
      TBINARYFP of tagged_binary_fp_op * tag Option.opt * fp_operand * fp_operand *
d429 1
a429 1
      TUNARYFP of tagged_unary_fp_op * tag Option.opt * fp_operand * fp_operand |
d432 1
a432 1
      STACKOP of stack_op * reg_operand * int Option.opt |
d448 1
a448 1
      ALLOCATE_STACK of allocate * reg_operand * int * int Option.opt |
d484 5
a488 2
                           fp		: int} Option.opt,
       stack_allocated	: int Option.opt}
@


1.76
log
@Adding ALLOC_VECTOR
@
text
@d4 3
d490 1
a490 1
      Debugger_Types.RuntimeEnv.debugger_env    (* runtime environment for code *)
@


1.75
log
@Add immediate store operations
@
text
@d4 3
d409 1
@


1.74
log
@Remove handler register concept
@
text
@d4 3
d425 1
@


1.73
log
@Abstraction of debug information
@
text
@d4 3
d445 2
a446 1
      NEW_HANDLER of tag | (* Set handler inside function *)
@


1.72
log
@Remove various bits of annotation
@
text
@d4 3
a252 1
require "../debugger/debugger_env";
a261 1
    structure RuntimeEnv : DEBUGGER_ENVIRONMENT_TYPE
d276 3
d283 3
a285 4
      GC_SPILL_SLOT of ((int,int) Option.option ref * string,int) Option.option |  
      (* offset of spill slot N from the frame pointer *)
      NON_GC_SPILL_SLOT of ((int,int) Option.option ref * string,int) Option.option |  
      FP_SPILL_SLOT of ((int,int) Option.option ref * string,int) Option.option 
d475 1
a475 1
      RuntimeEnv.debugger_env    (* runtime environment for code *)
@


1.71
log
@Added function argument register lists to BRANCH_AND_LINK, TAIL_CALL and ENTER
Changed loop_entry in procedure parameters to be a tag list, so we can have lots.
@
text
@d4 4
d462 1
a462 5
      {leaf		: bool,
       registers_used	: {gc		: GC.T Set.Set,
                           non_gc	: NonGC.T Set.Set,
                           fp		: FP.T Set.Set} Option.opt,
       spill_sizes	: {gc		: int,
d465 1
a465 2
       stack_allocated	: int Option.opt,
       loop_entry	: tag list}
@


1.70
log
@Add loop entry point to procedure parameters.
@
text
@d4 3
d418 4
a421 2
      BRANCH_AND_LINK of branch_and_link * bl_dest * Debugger_Types.Backend_Annotation |
      TAIL_CALL of tail_call * bl_dest |
d433 1
a433 1
      ENTER | (* Entry point for procedure *)
d466 1
a466 1
       loop_entry	: tag Option.opt}
@


1.69
log
@Adding load offset instruction
@
text
@d4 3
d460 2
a461 1
       stack_allocated	: int Option.opt}
@


1.68
log
@Removed unnecessary exceptions from closures.
@
text
@d4 3
d391 1
a391 1
    datatype adr = LEA
@


1.67
log
@Added INTERRUPT instruction
@
text
@d4 3
d297 1
d392 1
a392 1
      TBINARY of tagged_binary_op * tag * reg_operand * gp_operand * gp_operand |
d396 1
a396 1
      TBINARYFP of tagged_binary_fp_op * tag * fp_operand * fp_operand *
d398 1
a398 1
      TUNARYFP of tagged_unary_fp_op * tag * fp_operand * fp_operand |
@


1.66
log
@Debugger Environments for local and closure variable inspection
in the debugger;
new stack spill slots;
structure Option.
@
text
@d4 6
d415 2
@


1.66.1.1
log
@Fork for bug fixing
@
text
@a3 6
Revision 1.66  1993/07/29  14:18:32  nosa
Debugger Environments for local and closure variable inspection
in the debugger;
new stack spill slots;
structure Option.

@


1.65
log
@Changed PROFILE instruction to INTERCEPT.
@
text
@d4 3
d225 1
d228 1
d236 1
d238 1
a241 2
    datatype 'a Opt = PRESENT of 'a | ABSENT

d257 4
a260 3
      GC_SPILL_SLOT of int |  (* offset of spill slot N from the frame pointer *)
      NON_GC_SPILL_SLOT of int |
      FP_SPILL_SLOT of int
d391 1
a391 1
      STACKOP of stack_op * reg_operand * int Opt |
d404 1
a404 1
      ALLOCATE_STACK of allocate * reg_operand * int * int Opt |
d438 1
a438 1
                           fp		: FP.T Set.Set} Opt,
d441 2
a442 2
                           fp		: int} Opt,
       stack_allocated	: int Opt}
d448 2
a449 1
      block list		(* procedure code *)
@


1.64
log
@Signature revisions
@
text
@d4 3
d401 2
a402 2
      (* Profile *)
      PROFILER of reg_operand | 
@


1.63
log
@Removed (commented out) options.
Options & Info changes.
@
text
@d4 4
d219 1
d230 1
a230 30
(*
    (* The options type controls code generation in both the mir phase
       and the machine phase. *)
    datatype back_end_listing_options =
      BELO of {
	show_absyn      : bool,
	show_lambda     : bool,
	show_match      : bool,
        show_opt_lambda : bool,
        show_environ    : bool,
        show_mir        : bool,
        show_opt_mir    : bool,
        show_mach       : bool
    }

    datatype options =
      OPTIONS of {
        info_opts             : Debugger_Types.Info.options,
        list_opts             : back_end_listing_options,
        debug                 : bool,
        profile               : bool,
        trace                 : bool,
        debug_warnings        : bool,
        opt_leaf_fns          : bool,
        opt_tail_calls        : bool,
        opt_self_calls        : bool
      }

    val default_options : options
*)
d417 1
a417 1
      SCON of Debugger_Types.Datatypes.Ident.SCon
@


1.62
log
@Changed representation of value to include MLVALUEs
@
text
@d4 3
d225 1
d254 1
@


1.61
log
@Added default options
@
text
@d4 3
d435 6
a440 1
    datatype value = VALUE of tag * Debugger_Types.Datatypes.Ident.SCon
@


1.60
log
@Added code printing controls to options
@
text
@d4 3
d245 2
@


1.59
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d218 12
d233 1
@


1.58
log
@Changes to propagate compiler options as parameters instead of references.
@
text
@d4 3
a202 1
require "../main/info";
a211 1
    structure Info: INFO
d217 1
a217 1
        info_opts             : Info.options,
@


1.57
log
@Added Map structure for mononewmaps to allow efficient implementation
of lookup tables for integer based values
@
text
@d4 4
d200 1
d210 15
@


1.56
log
@Removed some redundant structures and sharing
@
text
@d4 3
d195 1
d203 1
d248 1
@


1.55
log
@Added NULLARY opcode type and ALLOC_BYTEARRAY.
@
text
@d4 3
a190 1

a191 2
require "../utils/text";
require "../basics/ident";
d198 1
a198 1

a200 4
    structure Set	: SET
    structure Ident	: IDENT
    structure Text	: TEXT

d206 1
a206 1
    sharing Text = GC.Text = NonGC.Text = FP.Text
d384 1
a384 1
    datatype value = VALUE of tag * Ident.SCon
@


1.54
log
@Added type annotation information at application points
@
text
@d4 3
d339 1
a340 1

d342 1
d348 1
@


1.53
log
@Added parameter to RAISE once again.
@
text
@d4 3
d189 1
d196 2
d357 1
a357 1
      BRANCH_AND_LINK of branch_and_link * bl_dest |
@


1.52
log
@Expanded refs section of mir_code to allow for interpretive stuff
@
text
@d4 3
d366 1
a366 1
      RAISE (*of reg_operand*) | (* Raise the current handler (special call) *)
@


1.51
log
@Added int_of_tag function
@
text
@d4 3
d368 5
a372 1
      (string * int) list		(* external references *)
@


1.50
log
@First version of the profiler
@
text
@d4 3
d234 1
@


1.49
log
@Changed the virtual register types to be structures of signature
VIRTUALREGISTER.
@
text
@d4 4
d349 2
d378 1
@


1.48
log
@Added `hash_*_register'.
Abolished PRESERVE_ALL_REGS and PREVIOUS_ENVIRONMENT.
@
text
@d4 8
d169 1
d171 1
d173 1
a174 3
signature MIRTYPES = sig
  structure Set : SET
  structure Ident : IDENT
d176 2
a177 1
  datatype 'a Opt = PRESENT of 'a | ABSENT
d179 3
d183 1
a183 23
  (* registers *)
  eqtype gc_register and non_gc_register and fp_register
  datatype any_register =
    GC of gc_register |
    NON_GC of non_gc_register |
    FLOAT of fp_register
  val new_gc_register: unit -> gc_register
  val new_non_gc_register: unit -> non_gc_register
  val new_fp_register: unit -> fp_register
  val init_gc_register: unit -> unit
  val order_gc_register: gc_register * gc_register -> bool
  val hash_gc_register: gc_register -> int
  val print_gc_register: gc_register -> string
  val init_non_gc_register: unit -> unit
  val order_non_gc_register: non_gc_register * non_gc_register -> bool
  val hash_non_gc_register: non_gc_register -> int
  val print_non_gc_register: non_gc_register -> string
  val init_fp_register: unit -> unit
  val order_fp_register: fp_register * fp_register -> bool
  val hash_fp_register: fp_register -> int
  val print_fp_register: fp_register -> string
  val init_counters: unit -> unit
  val order_any_reg : any_register * any_register -> bool
d185 8
a192 7
  (* Symbolic values *)
  datatype symbolic =
    GC_SPILL_SIZE |
    NON_GC_SPILL_SIZE |
    GC_SPILL_SLOT of int |  (* offset of spill slot N from the frame pointer *)
    NON_GC_SPILL_SLOT of int |
    FP_SPILL_SLOT of int
d194 123
a316 113
  (* Operands *)
  datatype gp_operand =
    GP_GC_REG of gc_register
  | GP_NON_GC_REG of non_gc_register
  | GP_IMM_INT of int (* For real ints, represented with run time tags *)
  | GP_IMM_ANY of int (* For other values *)
  | GP_IMM_SYMB of symbolic (* For unknown (macro) values *)
  exception NotAnyRegister
  val gp_to_any : gp_operand -> any_register
  val any_to_gp : any_register -> gp_operand
  datatype reg_operand =
    GC_REG of gc_register
  | NON_GC_REG of non_gc_register
  val reg_to_any : reg_operand -> any_register
  val any_to_reg : any_register -> reg_operand
  datatype fp_operand =
    FP_REG of fp_register
  val fp_to_any : fp_operand -> any_register
  val any_to_fp : any_register -> fp_operand
  (* Addresses in store *)
  eqtype tag
  val init_tag: unit -> unit
  val new_tag: unit -> tag
  val print_tag: tag -> string
  val order_tag: tag * tag -> bool
  val equal_tag: tag * tag -> bool
  datatype bl_dest = TAG of tag | REG of reg_operand
  (* Operations *)
  datatype binary_op =
  ADD |
  SUB |
  MULU |
  MULS |
  DIVU |
  DIVS |
  MODU |
  MODS |
  AND |
  OR | 
  BIC | (* AND-NOT *)
  EOR | 
  LSR | 
  ASL | 
  ASR
  datatype tagged_binary_op =
  ADDV |
  SUBV |
  MULV |
  DIVV |
  MODV
  datatype unary_op = 
  MOVE |
  NOT
  datatype tagged_binary_fp_op = FADDV | FSUBV | FMULV | FDIVV
  datatype binary_fp_op = FADD | FSUB | FMUL | FDIV
  datatype tagged_unary_fp_op =
    FABSV |
    FNEGV |
    FSQRTV |
    FLOGEV |
    FETOXV
  datatype unary_fp_op =
    FMOVE |
    FABS |
    FNEG |
    FINT |
    FSQRT |
    FLOG10 |
    FLOG2 |
    FLOGE |
    FLOGEP1 |
    F10TOX |
    F2TOX |
    FETOX |
    TETOXM1 |
    FSIN |
    FCOS |
    FTAN |
    FASIN |
    FACOS |
    FATAN
  datatype stack_op = PUSH | POP
  datatype store_op = LD | ST | LDB | STB | LDREF | STREF
  datatype store_fp_op = FLD | FST | FSTREF | FLDREF
  datatype int_to_float = ITOF
  datatype float_to_int = FTOI
  datatype branch = BRA (* Branch to basic block *)
  datatype cond_branch =
    BTA | (* Branch on tagged *)
    BNT | (* Branch on not tagged *)
    BEQ |
    BNE | (* Branch on eq/not eq *)
    BHI | (* Unsigned > *)
    BLS | (* Unsigned <= *)
    BHS | (* Unsigned >= *)
    BLO | (* Unsigned < *)
    BGT | (* Signed > *)
    BLE | (* Signed <= *)
    BGE | (* Signed >= *)
    BLT   (* Signed < *)
  datatype fcond_branch =
    FBEQ |
    FBNE | (* Branch on eq/not eq *)
    FBLE | (* Signed <= *)
    FBLT   (* Signed < *)
  datatype branch_and_link = BLR
  datatype tail_call = TAIL
  datatype computed_goto = CGT
  datatype allocate =
    ALLOC |
    ALLOC_REAL |
    ALLOC_STRING |
    ALLOC_REF
d318 1
a318 1
  datatype adr = LEA
d320 32
a351 32
  datatype opcode =
    TBINARY of tagged_binary_op * tag * reg_operand * gp_operand * gp_operand |
    BINARY of binary_op * reg_operand * gp_operand * gp_operand |
    UNARY of unary_op * reg_operand * gp_operand |
    TBINARYFP of tagged_binary_fp_op * tag * fp_operand * fp_operand *
    fp_operand |
    TUNARYFP of tagged_unary_fp_op * tag * fp_operand * fp_operand |
    BINARYFP of binary_fp_op * fp_operand * fp_operand * fp_operand |
    UNARYFP of unary_fp_op * fp_operand * fp_operand |
    STACKOP of stack_op * reg_operand * int Opt |
    STOREOP of store_op * reg_operand * reg_operand * gp_operand |
    STOREFPOP of store_fp_op * fp_operand * reg_operand * gp_operand |
    REAL of int_to_float * fp_operand * gp_operand |
    FLOOR of float_to_int * tag * reg_operand * fp_operand |
    BRANCH of branch * bl_dest |
    TEST of cond_branch * tag * gp_operand * gp_operand |
    FTEST of fcond_branch * tag * fp_operand * fp_operand |
    BRANCH_AND_LINK of branch_and_link * bl_dest |
    TAIL_CALL of tail_call * bl_dest |
    CALL_C |
    SWITCH of computed_goto * reg_operand * tag list |
    ALLOCATE of allocate * reg_operand * gp_operand |
    ALLOCATE_STACK of allocate * reg_operand * int * int Opt |
    DEALLOCATE_STACK of allocate * int |
    ADR of adr * reg_operand * tag |
    (* Information points *)
    ENTER | (* Entry point for procedure *)
    RTS | (* Return point from procedure *)
    NEW_HANDLER of tag | (* Set handler inside function *)
    OLD_HANDLER | (* Restore previous handler *)
    RAISE (*of reg_operand*) | (* Raise the current handler (special call) *)
    COMMENT of string
d353 3
a355 3
  datatype refs = REFS of
    (tag * int) list *		(* internal references *)
    (string * int) list		(* external references *)
d357 1
a357 1
  datatype value = VALUE of tag * Ident.SCon
d359 1
a359 1
  datatype block = BLOCK of tag * opcode list
d361 9
a369 9
  datatype procedure_parameters = PROC_PARAMS of
    {leaf		: bool,
     registers_used	: {gc		: gc_register Set.Set,
			   non_gc	: non_gc_register Set.Set,
			   fp		: fp_register Set.Set} Opt,
     spill_sizes	: {gc		: int,
			   non_gc	: int,
			   fp		: int} Opt,
     stack_allocated	: int Opt}
d371 4
a374 4
  datatype procedure = PROC of
    tag *		(* tag of the procedure entry block *)
    procedure_parameters *
    block list		(* procedure code *)
d376 4
a379 4
  datatype mir_code = CODE of
    refs *
    value list *
    procedure list list	(* list of recursive procedure sets *)
d381 1
a381 1
end
@


1.47
log
@Alloc may now have a register argument for allocating arrays
@
text
@d4 3
d182 1
d186 1
d190 1
a345 1
    PRESERVE_ALL_REGS |
a346 1
    PREVIOUS_ENVIRONMENT | (* Restore caller environment *)
@


1.46
log
@Raise no longer has a parameter
@
text
@d4 3
d334 1
a334 1
    ALLOCATE of allocate * reg_operand * int |
@


1.45
log
@Added tail call operation
@
text
@d3 4
a6 1
$Log:	mirtypes.sml,v $
d342 1
a342 1
    RAISE of reg_operand | (* Raise the current handler (special call) *)
@


1.44
log
@Added exception generating fp opcodes
@
text
@d4 3
d296 2
a297 1
  datatype branch_and_link = BSR | BLR
d325 1
@


1.43
log
@Added CALL_C opcode.
@
text
@d4 3
d241 1
d243 6
d272 2
a273 1
  datatype int_to_float = ITOF | FTOI
d307 3
d315 2
a316 1
    CONVOP of int_to_float * fp_operand * gp_operand |
@


1.42
log
@Removed references to fp_double registers.
@
text
@d4 3
d306 1
@


1.41
log
@Added FSTREF, FLDREF and an offset argument to STACKOPs.
@
text
@d4 3
d154 1
a154 1
  eqtype gc_register and non_gc_register and fp_register and fp_double_register
d158 1
a158 2
    FLOAT of fp_register |
    DOUBLE of fp_double_register
a161 1
  val new_fp_double_register: unit -> fp_double_register
a170 3
  val init_fp_double_register: unit -> unit
  val order_fp_double_register: fp_double_register * fp_double_register -> bool
  val print_fp_double_register: fp_double_register -> string
d180 1
a180 2
    FP_SPILL_SLOT of int |
    FP_DOUBLE_SPILL_SLOT of int
d330 1
a330 2
			   fp		: fp_register Set.Set,
			   fp_double	: fp_double_register Set.Set} Opt,
d333 1
a333 2
			   fp		: int,
			   fp_double	: int} Opt,
@


1.40
log
@Changed the form of the allocation instructions yet again. This
time they're a bit more orthogonal.
@
text
@d4 4
d261 1
a261 1
  datatype store_fp_op = FLD | FST
d298 1
a298 1
    STACKOP of stack_op * reg_operand |
@


1.39
log
@ALLOCATE doesn't have a scratch register or a proc_ref any more.
@
text
@d4 3
d284 1
a284 2
    ALLOC_REF |
    ALLOC_STACK
a285 3
  datatype deallocate =
    DEALLOC_STACK

d304 2
a305 1
    DEALLOCATE of deallocate * int |
@


1.38
log
@Added BTA and BNT for tagged value testing
@
text
@d4 3
a288 4
  datatype proc_ref =
    REG_REF of reg_operand |
    CLOSURE_REF of reg_operand * int

d304 1
a304 2
    ALLOCATE of
    allocate * reg_operand * int (*size*) * reg_operand * proc_ref |
@


1.37
log
@New local and external reference code
@
text
@d4 3
d255 2
@


1.36
log
@New style ALLOC opcodes
@
text
@d4 3
d315 2
a316 2
    tag list *		(* internal references *)
    string list		(* external references *)
@


1.35
log
@Added parameter to heap allocation to indicate position in closure
of call_c function
Updated to reflect new simplified module structure
@
text
@d4 5
d278 4
d297 2
a298 1
    ALLOCATE of allocate * reg_operand * int (*size*) * int (*call_c*) |
@


1.34
log
@Added ALLOC_PAIR.
@
text
@d4 3
d266 1
a266 2
    ALLOC_STACK |
    ALLOC_PAIR
d288 1
a288 1
    ALLOCATE of allocate * reg_operand * int |
a300 2
  datatype fn_call = FN_CALL of tag * tag (* Loader level function call *)

a301 1
    tag *
a326 1
    fn_call *
d329 1
a329 2
    procedure list list *	(* list of recursive procedure sets *)
    procedure			(* loader set-up procedure *)
@


1.33
log
@Added DEALLOC_STACK.
@
text
@d4 3
d263 2
a264 1
    ALLOC_STACK
@


1.32
log
@Parameters removed from ENTER and added to the
procedure type. Parameters for spill, stack, and register
usage added.
@
text
@d4 5
d261 4
d283 1
@


1.31
log
@Removed RESTORE_REGS and PRESERVE_REGS and replaced with parameterized
ENTER and PREVIOUS_ENVIRONMENT. Parameterized RAISE.
@
text
@d4 4
d117 1
d147 5
a151 1
    NON_GC_SPILL_SIZE
d257 1
d276 1
a276 1
    ENTER of {leaf : bool} | (* Entry point for procedure *)
d283 2
a284 2
    COMMENT of string | (* Allows comments in the harp *)
    END (* The code ends here *)
d296 12
d310 1
d318 1
a318 1
    block
@


1.30
log
@Added new PROC type
@
text
@d4 3
d266 1
a266 2
    ENTER | (* Entry point for procedure *)
    PRESERVE_REGS of reg_operand list * fp_operand list |
d269 1
a269 1
    RESTORE_REGS  of reg_operand list * fp_operand list |
d272 1
a272 1
    RAISE | (* Raise the current handler *)
@


1.29
log
@New code structure
@
text
@d4 3
d274 6
a279 1
  datatype refs = REFS of tag * tag list * string list
d281 1
d283 12
a294 2
  datatype mir_code =
    CODE of fn_call * refs * value list * block list list * block
@


1.28
log
@Added tag to refs
@
text
@d4 3
d275 1
a275 1
    CODE of fn_call * refs * value list * block list Set.Set * block
@


1.27
log
@Changed CODE structure to enable easier handling of code, values
and load time semantics
@
text
@d4 4
d268 1
a268 1
  datatype refs = REFS of tag list * string list
@


1.26
log
@Removed real register options, these are being done elsewhere
@
text
@d4 3
d91 1
d95 1
a260 5
    (* Data *)
    VALUE of Ident.SCon |
    LOC_REF of tag list |
    EXT_REF of string list |
    FN_CALL of tag * tag | (* Loader level function call *)
d263 3
d267 2
a268 1
  datatype mir_code = CODE of block list
@


1.25
log
@Added ordering functions on gc, non_gc, fp and fp_double registers so
that they can be used in tables.
@
text
@d4 4
d92 3
a94 1
  datatype 'a Opt = ABSENT | PRESENT of 'a
a101 9
  datatype real_gc_reg =
    GC_REAL of gc_register |
    GC_SPILL of int
  datatype real_non_gc_reg =
    NON_GC_REAL of non_gc_register |
    NON_GC_SPILL of int
  datatype real_fp_reg =
    FP_REAL of fp_register |
    FP_SPILL of int
a120 3
  (* Immediates *)
  eqtype fp_immediate and fp_double_immediate

d128 2
a129 2
    GP_GC_REG of gc_register * real_gc_reg Opt
  | GP_NON_GC_REG of non_gc_register * real_non_gc_reg Opt
d137 2
a138 2
    GC_REG of gc_register * real_gc_reg Opt
  | NON_GC_REG of non_gc_register * real_non_gc_reg Opt
d142 1
a142 1
    FP_REG of fp_register * real_fp_reg Opt
@


1.24
log
@Added an ordering function on the any_register type.
@
text
@d4 3
d110 1
d113 1
d116 1
d119 1
@


1.23
log
@Added register conversion functions.
@
text
@d4 3
d115 1
@


1.23.1.1
log
@This branch is a revision of the operand and register datatypes, leaving
this file much simplified and potentially leading to great simplification
of the code generator and optimiser modules. I have make a new branch
because converting the code generator (Mir_Cg) will take too long and
hold up more important work. There are corresponding branches for the
MirOptimiser and sub-modules.
@
text
@a3 3
Revision 1.23  91/09/25  14:54:29  richard
Added register conversion functions.

d80 1
a80 4

signature MIRTYPES =
sig

d82 30
d113 2
d116 4
d121 20
a140 10
  (*  === ADDRESSES IN STORE (CODE LABELS) ===
   *
   *  These are used to label blocks of code and data. A fresh tag is
   *  produced each time fresh_tag is called. The same sequence of
   *  tags can be generated twice by calling reset_fresh_tag followed
   *  by fresh_tag any number of times. Ordering and equality
   *  functions are provided on tags to allow them to be used in
   *  efficient look-up tables.
   *)

d142 7
a148 61
  val reset_fresh_tag : unit -> unit
  val fresh_tag : unit -> tag
  val order_tag : tag * tag -> bool
  val equal_tag : tag * tag -> bool
  val print_tag : tag -> string



  (*  === OPERANDS ===  *)


  (*  == Virtual registers ==
   *
   *  An indefinite supply of virtual registers is available. A fresh
   *  register is returned by fresh_virtual_register each time it is
   *  called. The same sequence of registers can be generated twice by
   *  calling reset_fresh_register followed by fresh_virtual_register
   *  any number of times.
   *)

  eqtype virtual_register
  val reset_fresh_counter : unit -> unit
  val fresh_virtual_register : unit -> virtual_register
  val print_virtual_register : virtual_register -> string


  (*  == Immediate values ==  *)

  (* These are the types of floating-point immediate operands. *)

  eqtype fp_immediate and fp_double_immediate

  (* Symbolic values are replaced by immediate values in the final *)
  (* stages of compilation. They represent values which cannot be *)
  (* known by earlier stages. *)

  datatype symbol_name =
    SPILL_SIZE


  (*  == Typed operands ==
   *
   *  These correspond to the register formats available in HARP.
   *)

  datatype untyped_operand =
    REG of virtual_register |
    INT of int |
    ANY of int |
    SYMBOL of symbol_name

  datatype operand =
    GC of untyped_operand |
    NON_GC of untyped_operand |
    FLOAT of untyped_operand |
    DOUBLE of untyped_operand



  (*  === OPERATIONS ===  *)

a164 1

a170 1

a173 1

a174 1

a194 1

a195 1

a196 1

a197 1

d199 1
a199 3

  datatype branch = BRA

a210 1

d216 1
a216 3

  datatype branch_and_link = BSR

a217 1

a223 1

a224 1

d226 19
a244 25

    TBINARY	of tagged_binary_op * tag * operand * operand * operand |
    BINARY	of binary_op * operand * operand * operand |
    UNARY	of unary_op * operand * operand |
    BINARYFP	of binary_fp_op * operand * operand * operand |
    UNARYFP	of unary_fp_op * operand * operand |
    STACKOP	of stack_op * operand |
    STOREOP	of store_op * operand * operand * operand |
    STOREFPOP	of store_fp_op * operand * operand * operand |
    CONVOP	of int_to_float * operand * operand |
    BRANCH_REG	of branch * operand |
    BRANCH	of branch * tag |
    TEST	of cond_branch * tag * operand * operand |
    FTEST	of fcond_branch * tag * operand * operand |
    LINK_REG	of branch_and_link * operand |
    LINK	of branch_and_link * tag |
    SWITCH	of computed_goto * operand * tag list |
    ALLOCATE	of allocate * operand * int |
    ADR		of adr * operand * tag |

    (* Information points: These are directives which do not expand *)
    (* directly into code but are used by later stages in compilation. *)

    ENTER | 			(* Entry point for procedure *)
    PRESERVE_REGS of operand list |
d246 5
a250 6
    RTS | 			(* Return point from procedure *)
    RESTORE_REGS of operand list |
    NEW_HANDLER	of tag |	(* Set handler inside function *)
    OLD_HANDLER |		(* Restore previous handler *)
    RAISE |			(* Raise the current handler *)

d252 6
a257 9

    VALUE	of Ident.SCon |
    LOC_REF	of tag list |
    EXT_REF	of string list |
    FN_CALL	of tag * tag |	(* Loader level function call *)
    COMMENT	of string |	(* Allows comments in the harp *)

    END		(* The code ends here *)

a258 1

a259 1

@


1.22
log
@Added tag equality function.
@
text
@d4 3
d128 3
d134 2
d138 2
@


1.21
log
@Added an ordering function on block tags to allow use of lookup tables.
@
text
@d4 3
d136 1
@


1.20
log
@Added NEW_HANDLER, OLD_HANDLER, and RAISE directives.
@
text
@d4 3
d132 1
@


1.19
log
@Added PRESERVE_ALL_REGS.
@
text
@d4 3
a224 5
(*
    INIT of any_register | (* Register is initialised here *)
    USE of any_register | (* Register is used here *)
    DISCARD of any_register | (* Register is not used after here *)
*)
d230 3
@


1.18
log
@Added MODV
@
text
@d4 3
d228 2
a229 1
    PRESERVE_REGS |
d231 1
a231 1
    RESTORE_REGS |
@


1.17
log
@Changed branches to target bl_dest
@
text
@d4 3
d145 2
a146 1
  DIVV
@


1.16
log
@Added ALLOCA for stack allocated items
@
text
@d4 3
d207 1
a207 1
    BRANCH of branch * tag |
@


1.15
log
@Added new type symbolic, and extra constructor GP_IMM_SYMB for
values not yet known
@
text
@d4 4
d187 6
a192 1
  datatype allocate = ALLOC | ALLOC_REAL | ALLOC_STRING | ALLOC_REF
d219 1
a219 1
    EXIT | (* Return point from procedure *)
@


1.14
log
@Added LDREF and STREF to assist optimiser deduce available expressions
@
text
@d4 3
d91 5
d102 1
@


1.13
log
@Added LDB, STB
@
text
@d4 3
d152 1
a152 1
  datatype store_op = LD | ST | LDB | STB
@


1.12
log
@Added PRESERVE_REGS and RESTORE_REGS. Removed ENTER_NO_CALLS
and EXIT_NO_CALLS
@
text
@d4 4
d149 1
a149 1
  datatype store_op = LD | ST
d182 1
a182 1
    CONVOP of int_to_float * fp_operand * reg_operand |
@


1.11
log
@Changed format for floating point operations to allow register colouring
@
text
@d4 3
d193 1
a193 1
    ENTER_NO_CALLS | (* Entry point for leaf procedure *)
d195 1
a195 1
    EXIT_NO_CALLS | (* Return point from procedure *)
@


1.10
log
@Slight change to ALLOC
@
text
@d4 3
d58 3
d87 2
a88 4
  datatype fp_double_operand =
    FP_DOUBLE_REG of fp_double_register
  | FP_DOUBLE_IMM of fp_double_immediate

d122 1
a140 7
  datatype calc_op =
    TBCALC of tagged_binary_op |
    BCALC of binary_op |
    NCALC of tagged_binary_op | (* For negate *)
    UCALC of unary_op |
    BFCALC of binary_fp_op |
    UFCALC of unary_fp_op
d170 2
a171 2
    BINARYFP of binary_fp_op * fp_register * fp_register * fp_register |
    UNARYFP of unary_fp_op * fp_register * fp_register |
d174 2
a175 2
    STOREFPOP of store_fp_op * fp_register * reg_operand * gp_operand |
    CONVOP of int_to_float * fp_register * reg_operand |
d178 1
a178 1
    FTEST of fcond_branch * tag * fp_register * fp_register |
@


1.9
log
@New ALLOC_REF
Removed data flow hints, these can be deduced.
@
text
@d4 4
d183 1
a183 1
    ALLOCATE of allocate * gc_register * int |
@


1.8
log
@Updated for later version of HARP
@
text
@d4 3
d162 1
a162 1
  datatype allocate = ALLOC | ALLOC_REAL | ALLOC_STRING
d182 1
d186 1
@


1.7
log
@Added EXT_REF type
@
text
@d4 3
a73 3
  datatype fp_operand =
    FP_REG of fp_register
  | FP_IMM of fp_immediate
d88 6
a93 3
  MUL |
  DIV |
  REM |
d96 1
d98 8
a105 5
  SHL | 
  SHR | 
  SHRL |
  DIVL |
  REML
d107 1
a107 4
  CMP |
  CMPL |
  MOV |
  NEG |
d109 20
a128 2
  datatype binary_fp_op = ADDF | SUBF | MULF | DIVF
  datatype unary_fp_op = MOVF | CMPF | NEGF
d130 1
d132 1
d137 2
a138 2
  datatype store_op = LDX | STX
  datatype store_fp_op = LDXF | STXF
d140 2
a141 2
  datatype branch =
    BRA | (* Branch to basic block *)
d151 7
a157 6
    BLT | (* Signed < *)
    BVS | (* Integer overflow *)
    BVC | (* Not integer overflow *)
    BMI | (* Signed negative *)
    BPL (* Signed positive *)
  datatype branch_and_link = BL | BLR
d162 1
d165 2
a166 2
    BINARYFP of binary_fp_op * fp_register * fp_operand * fp_operand |
    UNARYFP of unary_fp_op * fp_register * fp_operand |
d172 2
d182 2
a183 3
    ENTER of int | (* Entry point for procedure with n locals *)
    ENTER_NO_CALLS of int |
    (* Entry point for procedure with n locals and no calls *)
@


1.6
log
@Added a comment opcode to allow information to be passed through
@
text
@d4 3
d54 1
a54 1
  val print_fp_register: gc_register -> string
d56 1
a56 1
  val print_fp_double_register: gc_register -> string
d106 1
a106 1
  datatype unary_fp_op = MOVF | CMPF
d162 1
@


1.5
log
@Added new opcodes for local reference and FN_CALL as required by the
loader
@
text
@d4 4
d160 1
@


1.4
log
@Added some new instructions to indicate leaf procedures
@
text
@d4 3
d153 3
a155 1
    VALUE of (tag * Ident.SCon) list |
@


1.3
log
@Minor changes
@
text
@d4 3
d143 6
a148 3
    ENTER of int * reg_operand |
    (* Entry point for procedure, with n locals and arg reg *)
    EXIT of reg_operand | (* Return point from procedure, result in reg *)
@


1.2
log
@Changed some types to allow register colouring information plus
more general purpose operands
@
text
@d4 4
d53 2
a54 1
  | GP_IMM of int
d134 1
a134 1
    SWITCH of computed_goto * non_gc_register * tag list |
d144 2
a145 1
    VALUE of (tag * Ident.SCon) list
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d14 1
d22 6
d47 2
a48 2
    GP_GC_REG of gc_register
  | GP_NON_GC_REG of non_gc_register
d51 2
a52 2
    GC_REG of gc_register
  | NON_GC_REG of non_gc_register
a71 1
  RSB |
d119 1
a119 1
    BINARY of binary_op * reg_operand * reg_operand * gp_operand |
d121 1
a121 1
    BINARYFP of binary_fp_op * fp_register * fp_register * fp_operand |
a139 79


(*
  datatype opcode =
    (* Binary integer ops *)
    ADD of reg_operand * reg_operand * gp_operand |
    SUB of reg_operand * reg_operand * gp_operand |
    MUL of reg_operand * reg_operand * gp_operand |
    DIV of reg_operand * reg_operand * gp_operand | (* Goes with REM below *)
    RSB of reg_operand * reg_operand * gp_operand |
    (* Reverse subtract. Only one operand position may be immediate *)
    REM of reg_operand * reg_operand * gp_operand |
    (* Remainder, same sign as divisor *)
    AND of reg_operand * reg_operand * gp_operand |
    OR of reg_operand * reg_operand * gp_operand |
    EOR of reg_operand * reg_operand * gp_operand |
    SHL of reg_operand * reg_operand * gp_operand |
    SHR of reg_operand * reg_operand * gp_operand | (* Arithmetic shift *)
    SHRL of reg_operand * reg_operand * gp_operand | (* Logical shift *)
    DIVL of reg_operand * reg_operand * gp_operand | (* Unsigned division *)
    REML of reg_operand * reg_operand * gp_operand |
    (* Unsigned mod for above *)
    (* Unary operations *)
    CMP of reg_operand * gp_operand | (* Signed compare *)
    CMPL of reg_operand * gp_operand | (* Unsigned compare *)
    MOV of reg_operand * gp_operand |
    NEG of reg_operand * gp_operand |
    NOT of reg_operand * gp_operand |
    (* Stack operations *)
    PUSH of reg_operand |
    POP of reg_operand |
    (* Data transfer *)
    LD of reg_operand * reg_operand |
    LDV of reg_operand * string | (* Load from external variable *)
    LDL | (* Load from local variable (on stack) *)
    LDX of reg_operand * reg_operand * gp_operand | (* Load indexed *)
    LDVX of reg_operand * string * gp_operand |
    (* Load indexed from external *)
    LDLX | (* Load indexed from local *)
    ST of reg_operand * reg_operand |
    STV of reg_operand * string | (* Store to external variable *)
    STL | (* Store to local variable *)
    STX of reg_operand * reg_operand * gp_operand | (* Store indexed *)
    STVX of reg_operand * string * gp_operand | (* Store indexed to external *)
    STLX | (* Store indexed to local *)
    (* Type conversion *)
    ITOF of non_gc_register * fp_register | (* Integer to float *)
    ITOD of non_gc_register * fp_double_register | (* Integer to double *)
    FTOI of non_gc_register * fp_register | (* Float to integer *)
    DTOI of non_gc_register * fp_double_register | (* Double to integer *)
    FTOD of fp_register * fp_double_register | (* Float to double *)
    DTOF of fp_register * fp_double_register | (* Double to float *)
    (* Control flow *)
    NOOP | (* No operation *)
    BRA of tag | (* Branch to basic block *)
    BEQ of tag |
    BNE of tag | (* Branch on eq/not eq *)
    BHI of tag | (* Unsigned > *)
    BLS of tag | (* Unsigned <= *)
    BHS of tag | (* Unsigned >= *)
    BLO of tag | (* Unsigned < *)
    BGT of tag | (* Signed > *)
    BLE of tag | (* Signed <= *)
    BGE of tag | (* Signed >= *)
    BLT of tag | (* Signed < *)
    BVS of tag | (* Integer overflow *)
    BVC of tag | (* Not integer overflow *)
    BMI of tag | (* Signed negative *)
    BPL of tag | (* Signed positive *)
    BL of tag * reg_operand | (* Branch and link with arg *)
    BLR of reg_operand * reg_operand | (* Branch and link via reg with arg *)
    CGT of non_gc_register * tag list | (* Computed goto *)
    (* Information points *)
    INIT of any_register | (* Register is initialised here *)
    USE of any_register | (* Register is used here *)
    ENTER of int * reg_operand |
    (* Entry point for procedure, with n locals and arg reg *)
    EXIT of reg_operand | (* Return point from procedure, result in reg *)
  *)
@
