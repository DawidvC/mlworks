head	1.77;
access;
symbols
	MLW_daveb_inline_1_4_99:1.77.3
	MLWorks_21c0_1999_03_25:1.77
	MLWorks_20c1_1998_08_20:1.77
	MLWorks_20c0_1998_08_04:1.77
	MLWorks_20b2c2_1998_06_19:1.77
	MLWorks_20b2_Windows_1998_06_12:1.77
	MLWorks_20b1c1_1998_05_07:1.77
	MLWorks_20b0_1998_04_07:1.77
	MLWorks_20b0_1998_03_20:1.77
	MLWorks_20m2_1998_02_16:1.77
	MLWorks_20m1_1997_10_23:1.77
	MLWorks_11r1:1.75.1.1.1.1.1
	MLWorks_workspace_97:1.77.2
	MLWorks_dt_wizard:1.77.1
	MLWorks_11c0_1997_09_09:1.75.1.1.1.1
	MLWorks_10r3:1.75.1.1.3
	MLWorks_10r2_551:1.75.1.1.2
	MLWorks_11:1.75.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.75.1.1
	MLWorks_20m0_1997_06_20:1.77
	MLWorks_1_0_r2c2_1997_06_14:1.75.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.75.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.75.1
	MLWorks_BugFix_1997_04_24:1.75
	MLWorks_1_0_r2_Win32_1997_04_11:1.75
	MLWorks_1_0_r2_Unix_1997_04_04:1.75
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.72.3.1.1
	MLWorks_gui_1996_12_18:1.72.4
	MLWorks_1_0_Win32_1996_12_17:1.72.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.72.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.72.1.1
	MLWorks_1_0_Irix_1996_11_28:1.72.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.72.2
	MLWorks_1_0_Unix_1996_11_14:1.72.1
	MLWorks_Open_Beta2_1996_10_11:1.71.3
	MLWorks_License_dev:1.71.2
	MLWorks_1_open_beta_1996_09_13:1.71.1
	MLWorks_Open_Beta_1996_08_22:1.71
	MLWorks_Beta_1996_07_02:1.71
	MLWorks_Beta_1996_06_07:1.71
	MLWorks_Beta_1996_06_06:1.71
	MLWorks_Beta_1996_06_05:1.71
	MLWorks_Beta_1996_06_03:1.71
	MLWorks_Beta_1996_05_31:1.71
	MLWorks_Beta_1996_05_30:1.71
	ML_beta_release_12/08/94:1.61
	ML_beta_release_03/08/94:1.61
	ML_revised_beta_release_25/05/94:1.59
	ML_final_beta_release_02/03/94:1.58
	mlworks-28-01-1994:1.58
	Release:1.56
	mlworks-beta-01-09-1993:1.56
	MLWorks-1-0-4-29/01/1993:1.51
	MLWorks-1-0-3-21/12/1992:1.51
	MLWorks-1-0-2-15/12/1992:1.51
	MLWorks-1-0-1-04/12/1992:1.51
	checkpoint_17_08_92:1.46;
locks; strict;
comment	@ * @;


1.77
date	97.05.19.10.39.49;	author matthew;	state Exp;
branches
	1.77.1.1
	1.77.2.1
	1.77.3.1;
next	1.76;

1.76
date	97.05.01.13.10.47;	author jont;	state Exp;
branches;
next	1.75;

1.75
date	97.01.27.16.46.44;	author jont;	state Exp;
branches
	1.75.1.1;
next	1.74;

1.74
date	97.01.16.12.12.54;	author matthew;	state Exp;
branches;
next	1.73;

1.73
date	96.12.18.12.53.09;	author matthew;	state Exp;
branches;
next	1.72;

1.72
date	96.11.06.11.08.51;	author matthew;	state Exp;
branches
	1.72.1.1
	1.72.2.1
	1.72.3.1
	1.72.4.1;
next	1.71;

1.71
date	96.05.07.11.05.58;	author jont;	state Exp;
branches
	1.71.1.1
	1.71.2.1
	1.71.3.1;
next	1.70;

1.70
date	96.04.29.14.48.27;	author matthew;	state Exp;
branches;
next	1.69;

1.69
date	95.12.20.13.39.05;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	95.05.31.11.21.01;	author matthew;	state Exp;
branches;
next	1.67;

1.67
date	94.11.11.14.24.16;	author jont;	state Exp;
branches;
next	1.66;

1.66
date	94.09.30.12.50.11;	author jont;	state Exp;
branches;
next	1.65;

1.65
date	94.09.23.14.47.05;	author jont;	state Exp;
branches;
next	1.64;

1.64
date	94.09.13.11.40.14;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	94.09.05.14.50.44;	author jont;	state Exp;
branches;
next	1.62;

1.62
date	94.08.25.13.37.50;	author matthew;	state Exp;
branches;
next	1.61;

1.61
date	94.07.21.16.23.46;	author matthew;	state Exp;
branches;
next	1.60;

1.60
date	94.07.13.10.50.03;	author jont;	state Exp;
branches;
next	1.59;

1.59
date	94.05.12.12.51.10;	author richard;	state Exp;
branches;
next	1.58;

1.58
date	93.11.05.10.27.50;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	93.11.03.09.42.05;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	93.08.17.12.11.46;	author richard;	state Exp;
branches
	1.56.1.1;
next	1.55;

1.55
date	93.08.03.14.47.10;	author richard;	state Exp;
branches;
next	1.54;

1.54
date	93.07.29.15.16.33;	author nosa;	state Exp;
branches;
next	1.53;

1.53
date	93.04.27.13.44.01;	author richard;	state Exp;
branches;
next	1.52;

1.52
date	93.03.10.18.26.36;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	92.11.03.15.00.11;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	92.09.01.14.10.46;	author richard;	state Exp;
branches;
next	1.49;

1.49
date	92.08.28.15.20.03;	author davidt;	state Exp;
branches;
next	1.48;

1.48
date	92.08.26.15.36.40;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	92.08.24.13.37.29;	author richard;	state Exp;
branches;
next	1.46;

1.46
date	92.06.29.09.56.53;	author clive;	state Exp;
branches;
next	1.45;

1.45
date	92.06.19.10.21.54;	author richard;	state Exp;
branches;
next	1.44;

1.44
date	92.06.17.10.08.50;	author richard;	state Exp;
branches;
next	1.43;

1.43
date	92.06.15.12.02.38;	author richard;	state Exp;
branches;
next	1.42;

1.42
date	92.06.10.15.07.11;	author richard;	state Exp;
branches;
next	1.41;

1.41
date	92.06.09.15.34.38;	author richard;	state Exp;
branches;
next	1.40;

1.40
date	92.06.04.13.22.55;	author richard;	state Exp;
branches;
next	1.39;

1.39
date	92.05.27.13.38.00;	author richard;	state Exp;
branches;
next	1.38;

1.38
date	92.05.05.11.57.25;	author richard;	state Exp;
branches;
next	1.37;

1.37
date	92.04.29.13.24.04;	author richard;	state Exp;
branches;
next	1.36;

1.36
date	92.04.16.14.13.35;	author richard;	state Exp;
branches;
next	1.35;

1.35
date	92.04.13.15.19.12;	author clive;	state Exp;
branches;
next	1.34;

1.34
date	92.04.09.16.01.18;	author richard;	state Exp;
branches;
next	1.33;

1.33
date	92.04.09.14.42.18;	author richard;	state Exp;
branches;
next	1.32;

1.32
date	92.03.05.16.10.06;	author richard;	state Exp;
branches;
next	1.31;

1.31
date	92.03.02.11.35.54;	author richard;	state Exp;
branches;
next	1.30;

1.30
date	92.02.21.13.31.55;	author richard;	state Exp;
branches;
next	1.29;

1.29
date	92.02.10.16.55.24;	author richard;	state Exp;
branches;
next	1.28;

1.28
date	92.01.30.15.36.04;	author richard;	state Exp;
branches;
next	1.27;

1.27
date	92.01.10.16.44.04;	author richard;	state Exp;
branches;
next	1.26;

1.26
date	91.12.04.12.05.52;	author richard;	state Exp;
branches;
next	1.25;

1.25
date	91.11.29.14.48.29;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	91.11.26.12.42.33;	author richard;	state Exp;
branches;
next	1.23;

1.23
date	91.11.19.15.37.36;	author richard;	state Exp;
branches;
next	1.22;

1.22
date	91.11.14.10.45.25;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	91.11.07.11.36.18;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	91.10.25.15.14.35;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	91.10.18.14.54.11;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	91.10.17.15.54.08;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	91.10.16.16.10.24;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	91.10.16.12.12.12;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	91.10.15.14.31.01;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	91.10.14.15.31.01;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	91.10.11.14.41.17;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	91.10.11.11.04.46;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	91.10.10.14.48.33;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	91.10.10.13.20.03;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	91.10.10.10.12.36;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	91.10.08.15.24.45;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	91.10.07.16.23.09;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.10.04.13.02.22;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	91.10.03.15.32.13;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	91.10.02.14.18.24;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.10.01.15.41.31;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.09.30.12.47.17;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	91.09.27.15.03.52;	author richard;	state Exp;
branches;
next	;

1.56.1.1
date	93.08.17.12.11.46;	author jont;	state Exp;
branches;
next	1.56.1.2;

1.56.1.2
date	93.11.02.16.25.41;	author jont;	state Exp;
branches;
next	;

1.71.1.1
date	96.09.13.11.14.07;	author hope;	state Exp;
branches;
next	;

1.71.2.1
date	96.10.07.16.04.36;	author hope;	state Exp;
branches;
next	;

1.71.3.1
date	96.10.17.11.22.50;	author hope;	state Exp;
branches;
next	;

1.72.1.1
date	96.11.14.12.47.05;	author hope;	state Exp;
branches
	1.72.1.1.1.1;
next	;

1.72.1.1.1.1
date	96.11.28.14.58.41;	author hope;	state Exp;
branches;
next	;

1.72.2.1
date	96.11.22.18.07.11;	author hope;	state Exp;
branches;
next	;

1.72.3.1
date	96.12.17.17.45.55;	author hope;	state Exp;
branches
	1.72.3.1.1.1;
next	;

1.72.3.1.1.1
date	97.02.24.11.35.27;	author hope;	state Exp;
branches;
next	;

1.72.4.1
date	96.12.18.09.39.54;	author hope;	state Exp;
branches;
next	;

1.75.1.1
date	97.05.12.10.32.15;	author hope;	state Exp;
branches
	1.75.1.1.1.1
	1.75.1.1.2.1
	1.75.1.1.3.1;
next	;

1.75.1.1.1.1
date	97.07.28.18.18.00;	author daveb;	state Exp;
branches
	1.75.1.1.1.1.1.1;
next	;

1.75.1.1.1.1.1.1
date	97.10.07.11.42.57;	author jkbrook;	state Exp;
branches;
next	;

1.75.1.1.2.1
date	97.09.08.17.11.33;	author daveb;	state Exp;
branches;
next	;

1.75.1.1.3.1
date	97.09.09.14.07.10;	author daveb;	state Exp;
branches;
next	;

1.77.1.1
date	97.09.10.19.21.54;	author brucem;	state Exp;
branches;
next	;

1.77.2.1
date	97.09.11.20.53.09;	author daveb;	state Exp;
branches;
next	;

1.77.3.1
date	99.04.01.17.55.57;	author daveb;	state Exp;
branches;
next	;


desc
@Allocation of virtual to real registers and resulting code modification.
@


1.77
log
@Generate better code for moves from FP spills to FP registers
@
text
@(*  ==== REGISTER ALLOCATOR ====
 *           FUNCTOR
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  WARNING: THIS FILE CONTAINS SOME HIGHLY IMPERATIVE ML AND MAY OFFEND
 *  YOUR SENSIBILITIES.  ENTER AT YOUR OWN RISK.  It's also a bit wide.
 *
 *  The register colourer uses an array of adjacency lists to represent the
 *  clash graphs, and generates hash tables mapping virtual registers to
 *  contiguous integers to index this array and others.  Colours and spill
 *  slots are allocated at the same time, and both are used as colours, so
 *  more than one value may share a spill slot if they do not clash.
 *
 *  Revision Log
 *  ------------
 *  $Log: _registerallocator.sml,v $
 * Revision 1.76  1997/05/01  13:10:47  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.75  1997/01/27  16:46:44  jont
 * [Bug #0]
 * Pass name of function to colourer so we don't try too hard on setups and functors
 *
 * Revision 1.74  1997/01/16  12:12:54  matthew
 * Renaming MIR arithmetic primitives
 *
 * Revision 1.73  1996/12/18  12:53:09  matthew
 * Adding fp_preferences
 *
 * Revision 1.72  1996/11/06  11:08:51  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.71  1996/05/07  11:05:58  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.70  1996/04/29  14:48:27  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.69  1995/12/20  13:39:05  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
 *  Revision 1.68  1995/05/31  11:21:01  matthew
 *  Adding debugging reserved registers
 *
 *  Revision 1.67  1994/11/11  14:24:16  jont
 *  Add immediate store operations
 *
 *  Revision 1.66  1994/09/30  12:50:11  jont
 *  Remove handler register concept
 *
 *  Revision 1.65  1994/09/23  14:47:05  jont
 *  Control unspill behaviour with MachSpec.do_unspilling
 *
 *  Revision 1.64  1994/09/13  11:40:14  matthew
 *  Abstraction of debug information
 *
 *  Revision 1.63  1994/09/05  14:50:44  jont
 *  Reduce spill requirement to two registers.
 *
 *  Revision 1.62  1994/08/25  13:37:50  matthew
 *  Simplified annotations
 *
 *  Revision 1.61  1994/07/21  16:23:46  matthew
 *  Added function argument register lists to BRANCH_AND_LINK, TAIL_CALL and ENTER
 *
 *  Revision 1.60  1994/07/13  10:50:03  jont
 *  Fix to avoid lr unspilling alloc
 *
 *  Revision 1.59  1994/05/12  12:51:10  richard
 *  Add field to MirTypes.PROC_PARAMS.
 *
 *  Revision 1.58  1993/11/05  10:27:50  jont
 *  Added handling of INTERRUPT instruction
 *
 *  Revision 1.57  1993/11/03  09:42:05  matthew
 *  Removed erroneous sharing constraint
 *
 *  Revision 1.56  1993/08/17  12:11:46  richard
 *  Changed the annotation of raise instructions to model the fact that
 *  the raise might reach _any_ of the nexted continuation blocks.
 *
 *  Revision 1.55  1993/08/03  14:47:10  richard
 *  Added some extra diagnostics.
 *
 *  Revision 1.54  1993/07/29  15:16:33  nosa
 *  Extra stack spills for local and closure variable inspection
 *  in the debugger;
 *  structure Option.
 *
 *  Revision 1.53  1993/04/27  13:44:01  richard
 *  Changed PROFILE instruction to INTERCEPT.
 *
 *  Revision 1.52  1993/03/10  18:26:36  matthew
 *  Map substructure is now MirTypes.Map
 *
 *  Revision 1.51  1992/11/03  15:00:11  jont
 *  Efficiency changes to use mononewmap for registers and tags
 *
 *  Revision 1.50  1992/09/01  14:10:46  richard
 *  Added missing resiter substitution for PROFILER opcode
 *
 *  Revision 1.49  1992/08/28  15:20:03  davidt
 *  Removed some unncesessary intermediate lists which
 *  were being built.
 *
 *  Revision 1.48  1992/08/26  15:36:40  jont
 *  Removed some redundant structures and sharing
 *
 *  Revision 1.47  1992/08/24  13:37:29  richard
 *  Added NULLARY opcode type and ALLOC_BYTEARRAY.
 *
 *  Revision 1.46  1992/06/29  09:56:53  clive
 *  Added type annotation information at application points
 *
 *  Revision 1.45  1992/06/19  10:21:54  richard
 *  Added parameter to RAISE once again.
 *
 *  Revision 1.44  1992/06/17  10:08:50  richard
 *  Hints are no longer passed to the graphs.
 *
 *  Revision 1.43  1992/06/15  12:02:38  richard
 *  Rewrote spill generating code for speed.
 *
 *  Revision 1.42  1992/06/10  15:07:11  richard
 *  TENTATIVE CHECKIN.  Reworked spill slot allocation.
 *  Needs testing and revising.
 *
 *  Revision 1.41  1992/06/09  15:34:38  richard
 *  Calculated the sets of registers used properly.
 *
 *  Revision 1.40  1992/06/04  13:22:55  richard
 *  Removed register graph and colouring code to a general register
 *  colouring functor.
 *
 *  Revision 1.39  1992/05/27  13:38:00  richard
 *  Changed register Sets to Packs.  There is scope for the elimination
 *  of register hash tables using packed registers.
 *
 *  Revision 1.38  1992/05/05  11:57:25  richard
 *  Removed `first' annotation from instructions.
 *
 *  Revision 1.37  1992/04/29  13:24:04  richard
 *  Hints provided by the register preallocator are now used when building
 *  the register hash tables to reduce the size of the matrices.
 *
 *  Revision 1.36  1992/04/16  14:13:35  richard
 *  Changed the adjacency matrix to an array of adjacency lists.  This
 *  speeds up colouring for the sparse case (which is quite common) at the
 *  slight cost of building the lists.  This is often a big win.
 *  Added show_timings.
 *
 *  Revision 1.35  1992/04/13  15:19:12  clive
 *  First version of the profiler
 *
 *  Revision 1.34  1992/04/09  16:01:18  richard
 *  Removed obsolete Switches structure.
 *
 *  Revision 1.33  1992/04/09  14:42:18  richard
 *  Removed a left-over diagnostic message.
 *
 *  Revision 1.32  1992/03/05  16:10:06  richard
 *  Changed to return an annotated procedure as well as taking one as
 *  parameter.  This is to make it easier to pass the result to
 *  the stack allocator.
 *
 *  Revision 1.31  1992/03/02  11:35:54  richard
 *  The functor now uses MirProcedure annotated procedures rather than the
 *  MirOptTypes version.  It also takes the register clash lists as
 *  parameters instead of working them out from the procedure annotations.
 *  (They are now generated by MirVariable, see revision 1.29.)  Also, a
 *  new assignment class, RESERVED, has been added to cope with reserved
 *  registers more elegantly.
 *
 *  Revision 1.30  1992/02/21  13:31:55  richard
 *  Corrected spill slot counting.
 *
 *  Revision 1.29  1992/02/10  16:55:24  richard
 *  Complete rewrite using imperative ML features to gain efficiency.
 *
 *)


require "../basis/__int";

require "../utils/diagnostic";
require "../utils/lists";
require "../utils/crash";
require "mirtables";
require "mirprint";
require "mirprocedure";
require "mirregisters";
require "registercolourer";
require "registerallocator";


functor RegisterAllocator (
  structure MirProcedure	: MIRPROCEDURE
  structure Diagnostic		: DIAGNOSTIC
  structure MirRegisters	: MIRREGISTERS
  structure MirTables		: MIRTABLES
  structure MirPrint		: MIRPRINT
  structure Lists		: LISTS
  structure Crash		: CRASH

  structure GCColourer		: REGISTERCOLOURER
  sharing GCColourer.Register = MirRegisters.MirTypes.GC
  structure NonGCColourer	: REGISTERCOLOURER
  sharing NonGCColourer.Register = MirRegisters.MirTypes.NonGC
  structure FPColourer		: REGISTERCOLOURER
  sharing FPColourer.Register = MirRegisters.MirTypes.FP

  sharing MirProcedure.MirTypes = MirPrint.MirTypes = MirRegisters.MirTypes = MirTables.MirTypes
  sharing MirProcedure.Text = Diagnostic.Text

) : REGISTERALLOCATOR =

  struct
    structure MirTypes = MirRegisters.MirTypes
    structure Set = MirTypes.Set
    structure MirProcedure = MirProcedure
    structure Diagnostic = Diagnostic
    structure Map = MirTypes.Map
    structure MachSpec = MirRegisters.MachSpec

    val do_unspilling = MachSpec.do_unspilling

    val do_diagnostics = false

    fun diagnostic (level, output_function) =
      if do_diagnostics then 
        Diagnostic.output level
        (fn verbosity => "RegisterAllocator: " :: (output_function verbosity))
      else ()

    fun crash message = Crash.impossible ("RegisterAllocator: " ^ message)

    type Graph =
      {gc     : GCColourer.Graph,
       non_gc : NonGCColourer.Graph,
       fp     : FPColourer.Graph}

    fun empty ({gc = nr_gc,    non_gc = nr_non_gc,    fp = nr_fp},make_debugging_code) =
      {gc     = GCColourer.empty (nr_gc,make_debugging_code),
       non_gc = NonGCColourer.empty (nr_non_gc,make_debugging_code),
       fp     = FPColourer.empty (nr_fp,make_debugging_code)}

    fun clash {gc, non_gc, fp} ({gc = gc_defined, non_gc = non_gc_defined, fp = fp_defined},
                                {gc = gc_referenced, non_gc = non_gc_referenced, fp = fp_referenced},
                                {gc = gc_live,    non_gc = non_gc_live,    fp = fp_live}) =
      (GCColourer.clash    (gc,     gc_defined,     gc_referenced,     gc_live);
       NonGCColourer.clash (non_gc, non_gc_defined, non_gc_referenced, non_gc_live);
       FPColourer.clash    (fp,     fp_defined,     fp_referenced,     fp_live))



    (*  === SUBSTITUTE COLOURS FOR REGISTERS IN A PROCEDURE ===
     *
     *  This function rewrites the procedure in terms of the colours (real
     *  register aliases) assigned to the virtual registers by the colouring
     *  algorithm.  It also inserts code to load and store values in spill
     *  slots as necessary.  It is quite long because it needs to match
     *  against many of the possible instruction patterns and identify which
     *  registers are inputs and which outputs.
     *)

    local

      val frame = MirTypes.GC_REG MirRegisters.fp
      
      val gc_temporaries     = MLWorks.Internal.Array.arrayoflist (#gc MirRegisters.temporary)
      val non_gc_temporaries = MLWorks.Internal.Array.arrayoflist (#non_gc MirRegisters.temporary)
      val fp_temporaries     = MLWorks.Internal.Array.arrayoflist (#fp MirRegisters.temporary)

      fun generate_spills (instructions, []) = instructions
        | generate_spills (instructions, f::fs) =
          generate_spills (MirProcedure.I {defined      = MirProcedure.empty,
                                           referenced   = MirProcedure.empty,
                                           branches     = Set.empty_set,
                                           excepts      = [],
                                           opcode = f ()} :: 
                           instructions, fs)
    in
      
      fun substitute ({gc = gc_assign, non_gc = non_gc_assign, fp = fp_assign},
                      {gc = gc_spills, non_gc = non_gc_spills, fp = fp_spills},
                      {gc = gc_spills', non_gc = non_gc_spills', fp = fp_spills'}) =

        if gc_spills + non_gc_spills + fp_spills + gc_spills' + non_gc_spills' + fp_spills' = 0 then

          let

            val message =
              "The register colourers said that there were no spills, but I've found one."

            val substitute_opcode =
              MirProcedure.substitute
              {gc     = fn r => case gc_assign r
                                  of GCColourer.REGISTER r => r
                                   | GCColourer.SPILL _ => crash message,
               non_gc = fn r => case non_gc_assign r
                                  of NonGCColourer.REGISTER r => r
                                   | NonGCColourer.SPILL _ => crash message,
               fp     = fn r => case fp_assign r
                                  of FPColourer.REGISTER r => r
                                   | FPColourer.SPILL _ => crash message}
          in

            fn (tag, MirProcedure.B (annotation, instructions)) =>
            (MirProcedure.B
             (annotation,
              Lists.reducer
              (fn (MirProcedure.I {defined, referenced, branches, excepts, opcode}, instructions) =>
               let
                 val instruction =
                   MirProcedure.I {defined      = MirProcedure.empty,
                                   referenced   = MirProcedure.empty,
                                   branches     = branches,
                                   excepts       = excepts,
                                   opcode       = substitute_opcode opcode}
               in
                 instruction :: instructions
               end)
              (instructions, [])))
          end

        else

          let
            val gc_slots     = MLWorks.Internal.Array.array (gc_spills, MirTypes.GC.new ())
            val non_gc_slots = MLWorks.Internal.Array.array (non_gc_spills, MirTypes.NonGC.new ())
            val fp_slots     = MLWorks.Internal.Array.array (fp_spills, MirTypes.FP.new ())

            local
              open MirTypes
              open MLWorks.Internal.Array nonfix sub
            in
	      fun bad_spill () = crash "spill found to be register or other problem"

              fun gc_in (instructions, r, t) =
                case gc_assign r
                  of GCColourer.REGISTER _ => instructions
                   | GCColourer.SPILL slot =>
                     (update (gc_slots, slot, sub (gc_temporaries, t));
                      (fn () => STOREOP (LDREF, GC_REG (sub (gc_slots, slot)),
                        frame, GP_IMM_SYMB (GC_SPILL_SLOT (MirTypes.SIMPLE (slot+gc_spills'))))) 
                      :: instructions)

              fun non_gc_in (instructions, r, t) =
                case non_gc_assign r
                  of NonGCColourer.REGISTER _ => instructions
                   | NonGCColourer.SPILL slot =>
                     (update (non_gc_slots, slot, sub (non_gc_temporaries, t));
                      (fn () => STOREOP (LDREF, NON_GC_REG (sub (non_gc_slots, slot)),
                       frame, GP_IMM_SYMB (NON_GC_SPILL_SLOT (MirTypes.SIMPLE (slot+non_gc_spills'))))) 
                      :: instructions)

              fun fp_in (instructions, FP_REG r, t) =
                case fp_assign r
                  of FPColourer.REGISTER _ => instructions
                   | FPColourer.SPILL slot =>
                     (update (fp_slots, slot, sub (fp_temporaries, t));
                      (fn () => STOREFPOP (FLDREF, FP_REG (sub (fp_slots, slot)),
                        frame, GP_IMM_SYMB (FP_SPILL_SLOT (MirTypes.SIMPLE (slot+fp_spills'))))) 
                      :: instructions)

	      fun gc_spill r =
		case gc_assign r of
		  GCColourer.REGISTER _ => bad_spill()
		| GCColourer.SPILL slot => slot

	      fun reg_spill(GC_REG r) = gc_spill r
		| reg_spill _ = bad_spill()

	      fun gp_spill(GP_GC_REG r) = gc_spill r
		| gp_spill _ = bad_spill()

	      fun add_spill(instructions, r, s, t) =
		let
		  val slot1 = reg_spill r
		  val slot2 = reg_spill s
		  val slot3 = gp_spill t
		in
		  (fn () => BINARY(ADDU, GC_REG(sub(gc_slots, slot1)),
				   GP_GC_REG(sub(gc_slots, slot2)),
				   GP_GC_REG(sub(gc_slots, slot3)))) :: instructions
		end

	      fun reg_in (instructions, GC_REG r, t) = gc_in (instructions, r, t)
		| reg_in (instructions, NON_GC_REG r, t) = non_gc_in (instructions, r, t)

              fun gp_in (instructions, GP_GC_REG r, t) = gc_in (instructions, r, t)
                | gp_in (instructions, GP_NON_GC_REG r, t) = non_gc_in (instructions, r, t)
                | gp_in (instructions, _, t) = instructions

              fun gc_out (instructions, r, t) =
                case gc_assign r
                  of GCColourer.REGISTER _ => instructions
                   | GCColourer.SPILL slot =>
                     (update (gc_slots, slot, sub (gc_temporaries, t));
                      (fn () => STOREOP (STREF, GC_REG (sub (gc_slots, slot)),
                          frame, GP_IMM_SYMB (GC_SPILL_SLOT (MirTypes.SIMPLE (slot+gc_spills'))))) 
                      :: instructions)

              fun non_gc_out (instructions, r, t) =
                case non_gc_assign r
                  of NonGCColourer.REGISTER _ => instructions
                   | NonGCColourer.SPILL slot =>
                     (update (non_gc_slots, slot, sub (non_gc_temporaries, t));
                      (fn () => STOREOP (STREF, NON_GC_REG (sub (non_gc_slots, slot)),
                       frame, GP_IMM_SYMB (NON_GC_SPILL_SLOT (MirTypes.SIMPLE (slot+non_gc_spills'))))) 
                      :: instructions)

              fun fp_out (instructions, FP_REG r, t) =
                case fp_assign r
                  of FPColourer.REGISTER _ => instructions
                   | FPColourer.SPILL slot =>
                     (update (fp_slots, slot, sub (fp_temporaries, t));
                      (fn () => STOREFPOP (FSTREF, FP_REG (sub (fp_slots, slot)),
                       frame, GP_IMM_SYMB (FP_SPILL_SLOT (MirTypes.SIMPLE (slot+fp_spills'))))) 
                      :: instructions)

              fun reg_out (instructions, GC_REG r, t) = gc_out (instructions, r, t)
                | reg_out (instructions, NON_GC_REG r, t) = non_gc_out (instructions, r, t)

              fun gp_out (instructions, GP_GC_REG r, t) = gc_out (instructions, r, t)
                | gp_out (instructions, GP_NON_GC_REG r, t) = non_gc_out (instructions, r, t)
                | gp_out (instructions, _, t) = instructions

	    end

	    val substitute_opcode =
	      MirProcedure.substitute
              {gc     = fn r => case gc_assign r
                                  of GCColourer.REGISTER r => r
                                   | GCColourer.SPILL n => MLWorks.Internal.Array.sub (gc_slots, n),
               non_gc = fn r => case non_gc_assign r
                                  of NonGCColourer.REGISTER r => r
                                   | NonGCColourer.SPILL n => MLWorks.Internal.Array.sub (non_gc_slots, n),
               fp     = fn r => case fp_assign r
                                  of FPColourer.REGISTER r => r
                                   | FPColourer.SPILL n => MLWorks.Internal.Array.sub (fp_slots, n)}

            local
              open MirTypes
            in
	      val ref_opcode = ref (COMMENT "")

	      fun is_gc_spill r =
		case gc_assign r
                  of GCColourer.REGISTER _ => false
                   | GCColourer.SPILL _ => true

	      fun is_non_gc_spill r =
                case non_gc_assign r
                  of NonGCColourer.REGISTER _ => false
                   | NonGCColourer.SPILL _ => true

	      fun is_reg_spill(GC_REG r) = is_gc_spill r
		| is_reg_spill(NON_GC_REG r) = is_non_gc_spill r

	      fun is_gp_spill(GP_GC_REG r) = is_gc_spill r
		| is_gp_spill(GP_NON_GC_REG r) = is_non_gc_spill r
		| is_gp_spill _ = false

	      fun same_reg_and_gp_spill(r, g) =
		is_reg_spill r andalso is_gp_spill g andalso
		reg_spill r = gp_spill g

	      fun do_store_spill(LD, _, _, _) = bad_spill()
		| do_store_spill(LDREF, _, _, _) = bad_spill()
		| do_store_spill(LDB, _, _, _) = bad_spill()
		| do_store_spill(store, in0, in1, in2) =
		  if is_reg_spill in0 then
		    if is_reg_spill in1 then
		      if is_gp_spill in2 then
			((*output(std_out, "STOREOP with three real spills\n");*)
			 ref_opcode :=
			 STOREOP(store, in0, in1, GP_IMM_INT 0);
			 (reg_in(gp_in (add_spill(reg_in([], in0, 1), in1, in1, in2), in2, 1), in1, 0),
			  [
			   let
			     val slot = reg_spill in1
			   in
			     fn () => NULLARY(CLEAN, GC_REG(MLWorks.Internal.Array.sub(gc_slots, slot)))
			   end]))
		      else
			(reg_in (reg_in (gp_in ([], in2, 1), in1, 1), in0, 0), [])
		    else
		      (reg_in (reg_in (gp_in ([], in2, 1), in1, 1), in0, 0), [])
		  else
		    (reg_in (reg_in (gp_in ([], in2, 1), in1, 0), in0, 0), [])

              fun spill (TBINARY (_, _, out0, in1, in2))     =
		if same_reg_and_gp_spill(out0, in2) then
		  ((*output(std_out, "Found reg_out and gp_in in same spill slot (TBINARY)\n");*)
		   (gp_in (gp_in ([], in2, 0), in1, 1), reg_out ([], out0, 0)))
		else
		  (gp_in (gp_in ([], in2, 1), in1, 0), reg_out ([], out0, 0))
                | spill (BINARY (_, out0, in1, in2))         =
		  if same_reg_and_gp_spill(out0, in2) then
		    ((*output(std_out, "Found reg_out and gp_in in same spill slot (BINARY)\n");*)
		     (gp_in (gp_in ([], in2, 0), in1, 1), reg_out ([], out0, 0)))
		  else
		    (gp_in (gp_in ([], in2, 1), in1, 0), reg_out ([], out0, 0))
                | spill (TBINARYFP (_, _, out0, in1, in2))   = (fp_in (fp_in ([], in2, 2), in1, 1), fp_out ([], out0, 0))
                | spill (BINARYFP (_, out0, in1, in2))       = (fp_in (fp_in ([], in2, 2), in1, 1), fp_out ([], out0, 0))
                | spill (UNARY (_, out0, in1))               = (gp_in ([], in1, 1), reg_out ([], out0, 0))
                | spill (NULLARY (_, out0))                  = ([], reg_out ([], out0, 0))
                (* Special treatment for FP moves *)
                | spill (UNARYFP (FMOVE, out0 as FP_REG r1, in1 as FP_REG r2))         = 
                    (case (fp_assign r1, fp_assign r2) of
                       (FPColourer.REGISTER r, FPColourer.SPILL n) => 
                         (* Put a spill into a register *)
                         (ref_opcode :=
                          STOREFPOP (FLDREF, FP_REG r, frame, GP_IMM_SYMB (FP_SPILL_SLOT (MirTypes.SIMPLE (n + fp_spills'))));
                          ([],[]))
                     | (FPColourer.SPILL n, FPColourer.REGISTER r) =>
                         (ref_opcode :=
                          STOREFPOP (FSTREF, FP_REG r, frame, GP_IMM_SYMB (FP_SPILL_SLOT (MirTypes.SIMPLE (n + fp_spills'))));
                          ([],[]))
                     | _ => (fp_in ([], in1, 1), fp_out ([], out0, 0)))
                | spill (UNARYFP (_, out0, in1))             = (fp_in ([], in1, 1), fp_out ([], out0, 0))
                | spill (TUNARYFP (_, _, out0, in1))         = (fp_in ([], in1, 1), fp_out ([], out0, 0))
                | spill (STACKOP (PUSH, in0, _))             = (reg_in ([], in0, 0), [])
                | spill (STACKOP (POP, out0, _))             = ([], reg_out ([], out0, 0))
                | spill (STOREOP (store as (ST, in0, in1, in2)))        =
		  do_store_spill store
                | spill (STOREOP (store as (STREF, in0, in1, in2)))     =
		  do_store_spill store
                | spill (STOREOP (store as (STB, in0, in1, in2)))       =
		  do_store_spill store
                | spill (STOREOP (LD, out0, in1, in2))       =
		  if same_reg_and_gp_spill(out0, in2) then
		    ((*output(std_out, "Found reg_out and gp_in in same spill slot (LD)\n");*)
		     (reg_in (gp_in ([], in2, 0), in1, 1), reg_out ([], out0, 0)))
		  else
		    (reg_in (gp_in ([], in2, 1), in1, 0), reg_out ([], out0, 0))
                | spill (STOREOP (LDREF, out0, in1, in2))    =
		  if same_reg_and_gp_spill(out0, in2) then
		    ((*output(std_out, "Found reg_out and gp_in in same spill slot (LDREF)\n");*)
		     (reg_in (gp_in ([], in2, 0), in1, 1), reg_out ([], out0, 0)))
		  else
		    (reg_in (gp_in ([], in2, 1), in1, 0), reg_out ([], out0, 0))
                | spill (STOREOP (LDB, out0, in1, in2))      =
		  if same_reg_and_gp_spill(out0, in2) then
                    ((*output(std_out, "Found reg_out and gp_in in same spill slot (LDB)\n");*)
		     (reg_in (gp_in ([], in2, 0), in1, 1), reg_out ([], out0, 0)))
		  else (reg_in (gp_in ([], in2, 1), in1, 0), reg_out ([], out0, 0))
                | spill (IMMSTOREOP _)                       = Crash.impossible"Immediate store on spilling architecture"
                | spill (STOREFPOP (FST, in0, in1, in2))     = (fp_in (reg_in (gp_in ([], in2, 1), in1, 0), in0, 0), [])
                | spill (STOREFPOP (FSTREF, in0, in1, in2))  = (fp_in (reg_in (gp_in ([], in2, 1), in1, 0), in0, 0), [])
                | spill (STOREFPOP (FLD, out0, in1, in2))    = (reg_in (gp_in ([], in2, 1), in1, 0), fp_out ([], out0, 0))
                | spill (STOREFPOP (FLDREF, out0, in1, in2)) = (reg_in (gp_in ([], in2, 1), in1, 0), fp_out ([], out0, 0))
                | spill (REAL (_, out0, in1))                = (gp_in ([], in1, 1), fp_out ([], out0, 0))
                | spill (FLOOR (_, _, out0, in1))            = (fp_in ([], in1, 1), reg_out ([], out0, 0))
                | spill (BRANCH (_, REG in0))                = (reg_in ([], in0, 0), [])
                | spill (BRANCH (_, TAG _))                  = ([], [])
                | spill (TEST (_, _, in0, in1))              = (gp_in (gp_in ([], in0, 0), in1, 1), [])
                | spill (FTEST (_, _, in0, in1))             = (fp_in (fp_in ([], in0, 0), in1, 1), [])
                | spill (BRANCH_AND_LINK (_, REG in0,_,_))   = (reg_in ([], in0, 0), [])
                | spill (BRANCH_AND_LINK (_, TAG _,_,_))     = ([], [])
                | spill (TAIL_CALL (_, REG in0,_))           = (reg_in ([], in0, 0), [])
                | spill (TAIL_CALL (_, TAG _,_))             = ([], [])
                | spill (CALL_C)                             = ([], [])
                | spill (SWITCH (_, in0, _))                 = (reg_in ([], in0, 0), [])
                | spill (ALLOCATE (_, out0, in1))            = (gp_in ([], in1, 1), reg_out ([], out0, 0))
                | spill (ALLOCATE_STACK (_, out0, _, _))     = ([], reg_out ([], out0, 0))
                | spill (DEALLOCATE_STACK _)                 = ([], [])
                | spill (ADR (_, out0, _))                   = ([], reg_out ([], out0, 0))
                | spill (INTERCEPT)                          = ([], [])
                | spill (INTERRUPT)                          = ([], [])
                | spill (ENTER _)                              = ([], [])
                | spill (RTS)                                = ([], [])
                | spill (NEW_HANDLER(frame, tag))            = (reg_in([], frame, 0), [])
                | spill (OLD_HANDLER)                        = ([], [])
                | spill (RAISE in0)                          = (reg_in ([], in0, 0), [])
                | spill (COMMENT _)                          = ([], [])

            end
            (* Simple check here if we have a move of something to itself *)
            fun is_null_move (MirTypes.UNARYFP (MirTypes.FMOVE, MirTypes.FP_REG r1, MirTypes.FP_REG r2)) =
              fp_assign r1 = fp_assign r2
              | is_null_move (MirTypes.UNARY (MirTypes.MOVE, MirTypes.GC_REG r1, MirTypes.GP_GC_REG r2)) =
              gc_assign r1 = gc_assign r2
              | is_null_move _ = false

          in
	    if do_unspilling then
	      fn (tag, MirProcedure.B (annotation, instructions)) =>
	      (MirProcedure.B
	       (annotation,
		Lists.reducer
		(fn (MirProcedure.I {defined, referenced, branches, excepts, opcode}, instructions) =>
                 if is_null_move opcode then instructions
                 else
		 let
		   val _ = ref_opcode := opcode
		   val (loads, stores) = spill opcode

		   val instruction =
		     MirProcedure.I {defined      = MirProcedure.empty,
                                     referenced   = MirProcedure.empty,
                                     branches     = branches,
                                     excepts      = excepts,
                                     opcode       = substitute_opcode (!ref_opcode)}
		 in
		   generate_spills (instruction :: generate_spills (instructions, stores), loads)
		 end)
		(instructions, [])))
	    else
	      let
		val substitute_opcode =
		  MirProcedure.substitute
		  {gc     =
		   fn r => case gc_assign r of
		     GCColourer.REGISTER r => r
		   | GCColourer.SPILL n =>
		       MirTypes.GC.pack((#gc MirRegisters.pack_next)+n),
		   non_gc =
		   fn r => case non_gc_assign r of
		     NonGCColourer.REGISTER r => r
		   | NonGCColourer.SPILL n =>
		       MirTypes.NonGC.pack((#non_gc MirRegisters.pack_next)+n),
		   fp     =
		   fn r => case fp_assign r of
		     FPColourer.REGISTER r => r
		   | FPColourer.SPILL n =>
		       MirTypes.FP.pack((#fp MirRegisters.pack_next)+n)}
	      in
		fn (tag, MirProcedure.B (annotation, instructions)) =>
		(MirProcedure.B
		 (annotation,
		  Lists.reducer
		  (fn (MirProcedure.I {defined, referenced, branches, excepts, opcode}, instructions) =>
                   if is_null_move opcode then instructions
                   else
                     let
                       val instruction =
                         MirProcedure.I {defined      = MirProcedure.empty,
                                         referenced   = MirProcedure.empty,
                                         branches     = branches,
                                         excepts      = excepts,
                                         opcode       = substitute_opcode opcode}
                     in
                       instruction :: instructions
                     end)
		  (instructions, [])))
	      end
          end

    end

    fun block_preferences (MirProcedure.B (_,instructions),acc) =
      Lists.reducel
      (fn ((acc1,acc2), MirProcedure.I {opcode = MirTypes.UNARY (MirTypes.MOVE,
                                                                 MirTypes.GC_REG r1,
                                                                 MirTypes.GP_GC_REG r2),
                                ...}) =>
       ((r1,r2) :: acc1,acc2)
        | ((acc1,acc2), MirProcedure.I {opcode = MirTypes.UNARYFP (MirTypes.FMOVE,
                                                                   MirTypes.FP_REG r1,
                                                                   MirTypes.FP_REG r2),
                                        ...}) =>
       (acc1, (r1,r2) :: acc2)
        | (acc,_) => acc)
      (acc,instructions)

    (*  === PERFORM REGISTER ALLOCATION ===
     *
     *  This is the top level exported function.  Details inside.
     *)

    fun analyse (procedure as MirProcedure.P (annotation, name, start, block_map),
                 {gc = gc_graph, non_gc = non_gc_graph, fp = fp_graph},
                 {gc = gc_spills', non_gc = non_gc_spills', fp = fp_spills'},
                 make_debug_code) =
      let
        val _ = diagnostic (1, fn _ => ["procedure ", MirTypes.print_tag start, ": ", name])

        val {uses_stack,
             nr_registers,
             parameters = MirTypes.PROC_PARAMS {stack_allocated, ...}} = annotation

        (* Find all the register pairs involved in moves *)
        (* Reversing seems to give better results *)
        local
          val (gcs,fps) =
            (Map.fold 
             (fn (acc,_,block) =>
              block_preferences (block,acc))
             (([],[]),block_map))
        in
          val gc_preferences = rev gcs
          val fp_preferences = rev fps
        end

        val ({assign = gc_assign,     nr_spills = gc_spills},
             {assign = non_gc_assign, nr_spills = non_gc_spills},
             {assign = fp_assign,     nr_spills = fp_spills}) =
          (GCColourer.colour (gc_graph,gc_preferences,make_debug_code, name),
           NonGCColourer.colour (non_gc_graph,[],make_debug_code, name),
           FPColourer.colour (fp_graph,fp_preferences,make_debug_code, name))

        val _ = diagnostic (2, fn _ => ["rewriting procedure"])

        val substitute = 
          let
            val num_spills = gc_spills + non_gc_spills + fp_spills
            val _ = 
              if num_spills > 0 
                then
                  diagnostic (2, fn _ => [Int.toString num_spills,
                                          " spills for ", name])
              else ()
          in
              substitute ({gc = gc_assign, non_gc = non_gc_assign, fp = fp_assign},
                          {gc = gc_spills, non_gc = non_gc_spills, fp = fp_spills},
                          {gc = gc_spills', non_gc = non_gc_spills', fp = fp_spills'})
          end

        val blocks =
          Map.map substitute block_map

        val spill_sizes = SOME {gc = gc_spills+gc_spills', 
                                                   non_gc = non_gc_spills+non_gc_spills', 
                                                   fp = fp_spills+fp_spills'}
      in

        MirProcedure.P ({nr_registers = nr_registers,
                         uses_stack = uses_stack,
                         parameters = MirTypes.PROC_PARAMS
                                      {stack_allocated = stack_allocated,
				       old_spill_sizes = NONE,
				       (* This will be filled in later *)
                                       spill_sizes = spill_sizes}},
                        name,
                        start,
                        blocks)
      end

  end
@


1.77.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a19 3
 * Revision 1.77  1997/05/19  10:39:49  matthew
 * Generate better code for moves from FP spills to FP registers
 *
@


1.77.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a19 3
 * Revision 1.77  1997/05/19  10:39:49  matthew
 * Generate better code for moves from FP spills to FP registers
 *
@


1.77.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a19 3
 * Revision 1.77  1997/05/19  10:39:49  matthew
 * Generate better code for moves from FP spills to FP registers
 *
@


1.76
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d20 4
d515 13
a533 21
(*
		  if is_reg_spill in0 then
		    if is_reg_spill in1 then
		      if is_gp_spill in2 then
			((*output(std_out, "STOREOP with three real spills\n");*)
			 ref_opcode :=
			 STOREOP(ST, in0, in1, GP_GC_IMM 0);
			 (reg_in(gp_in (add_spill(reg_in([], in0, 1), in1, in1, in2), in2, 1), in1, 0),
			  [
			   let
			     val slot = reg_spill in1
			   in
			     fn () => NULLARY(CLEAN, GC_REG(MLWorks.Internal.Array.sub(gc_slots, slot)))
			   end]))
		      else
			(reg_in (reg_in (gp_in ([], in2, 1), in1, 1), in0, 0), [])
		    else
		      (reg_in (reg_in (gp_in ([], in2, 1), in1, 1), in0, 0), [])
		  else
		    (reg_in (reg_in (gp_in ([], in2, 1), in1, 0), in0, 0), [])
*)
a535 3
(*
		  (reg_in (reg_in (gp_in ([], in2, 2), in1, 1), in0, 0), [])
*)
a537 3
(*
		  (reg_in (reg_in (gp_in ([], in2, 2), in1, 1), in0, 0), [])
*)
d552 1
a552 1
		    ((*output(std_out, "Found reg_out and gp_in in same spill slot (LDB)\n");*)
d554 2
a555 4
		  else
		    (reg_in (gp_in ([], in2, 1), in1, 0), reg_out ([], out0, 0))
                | spill (IMMSTOREOP _)                       =
		  Crash.impossible"Immediate store on spilling architecture"
d566 4
a569 4
                | spill (BRANCH_AND_LINK (_, REG in0,_,_))       = (reg_in ([], in0, 0), [])
                | spill (BRANCH_AND_LINK (_, TAG _,_,_))         = ([], [])
                | spill (TAIL_CALL (_, REG in0,_))             = (reg_in ([], in0, 0), [])
                | spill (TAIL_CALL (_, TAG _,_))               = ([], [])
d586 6
d600 2
d610 1
a610 1
                                     excepts       = excepts,
d641 12
a652 10
		   let
		     val instruction =
		       MirProcedure.I {defined      = MirProcedure.empty,
                                       referenced   = MirProcedure.empty,
                                       branches     = branches,
                                       excepts       = excepts,
                                       opcode       = substitute_opcode opcode}
		   in
		     instruction :: instructions
		   end)
d662 2
a663 2
                                                        MirTypes.GC_REG r1,
                                                        MirTypes.GP_GC_REG r2),
@


1.75
log
@[Bug #0]
Pass name of function to colourer so we don't try too hard on setups and functors
@
text
@d20 4
d732 1
a732 1
        val spill_sizes = MLWorks.Option.SOME {gc = gc_spills+gc_spills', 
d741 1
a741 1
				       old_spill_sizes = MLWorks.Option.NONE,
@


1.75.1.1
log
@branched from 1.75
@
text
@a19 4
 * Revision 1.75  1997/01/27  16:46:44  jont
 * [Bug #0]
 * Pass name of function to colourer so we don't try too hard on setups and functors
 *
@


1.75.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a19 3
 * Revision 1.75.1.1  1997/05/12  10:32:15  hope
 * branched from 1.75
 *
@


1.75.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a19 3
 * Revision 1.75.1.1  1997/05/12  10:32:15  hope
 * branched from 1.75
 *
@


1.75.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a19 3
 * Revision 1.75.1.1  1997/05/12  10:32:15  hope
 * branched from 1.75
 *
@


1.75.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a19 3
 * Revision 1.75.1.1.1.1  1997/07/28  18:18:00  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.74
log
@Renaming MIR arithmetic primitives
@
text
@d20 3
d704 3
a706 3
          (GCColourer.colour (gc_graph,gc_preferences,make_debug_code),
           NonGCColourer.colour (non_gc_graph,[],make_debug_code),
           FPColourer.colour (fp_graph,fp_preferences,make_debug_code))
@


1.73
log
@Adding fp_preferences
@
text
@d20 3
d378 1
a378 1
		  (fn () => BINARY(ADD, GC_REG(sub(gc_slots, slot1)),
@


1.72
log
@[Bug #1728]
__integer becomes __int
@
text
@d20 4
d651 1
a651 1
    fun block_gc_preferences (MirProcedure.B (_,instructions),acc) =
d653 1
a653 1
      (fn (acc, MirProcedure.I {opcode = MirTypes.UNARY (MirTypes.MOVE,
d657 7
a663 2
      (r1,r2) :: acc
      | (acc,_) => acc)
d684 10
a693 5
        val gc_preferences =
          rev (Map.fold 
               (fn (acc,_,block) =>
                block_gc_preferences (block,acc))
               ([],block_map))
d700 1
a700 1
           FPColourer.colour (fp_graph,[],make_debug_code))
@


1.72.4.1
log
@branched from 1.72
@
text
@a19 4
 * Revision 1.72  1996/11/06  11:08:51  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.72.3.1
log
@branched from 1.72
@
text
@a19 4
 * Revision 1.72  1996/11/06  11:08:51  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.72.3.1.1.1
log
@branched from 1.72.3.1
@
text
@a19 3
 * Revision 1.72.3.1  1996/12/17  17:45:55  hope
 * branched from 1.72
 *
@


1.72.2.1
log
@branched from 1.72
@
text
@a19 4
 * Revision 1.72  1996/11/06  11:08:51  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.72.1.1
log
@branched from 1.72
@
text
@a19 4
 * Revision 1.72  1996/11/06  11:08:51  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.72.1.1.1.1
log
@branched from 1.72.1.1
@
text
@a19 3
 * Revision 1.72.1.1  1996/11/14  12:47:05  hope
 * branched from 1.72
 *
@


1.71
log
@Array moving to MLWorks.Array
@
text
@d20 3
d171 1
a171 1
require "../basis/__integer";
@


1.71.3.1
log
@branched from 1.71
@
text
@a19 3
 * Revision 1.71  1996/05/07  11:05:58  jont
 * Array moving to MLWorks.Array
 *
@


1.71.2.1
log
@branched from 1.71
@
text
@a19 3
 * Revision 1.71  1996/05/07  11:05:58  jont
 * Array moving to MLWorks.Array
 *
@


1.71.1.1
log
@branched from 1.71
@
text
@a19 3
 * Revision 1.71  1996/05/07  11:05:58  jont
 * Array moving to MLWorks.Array
 *
@


1.70
log
@Removing MLWorks.Integer
@
text
@d20 3
d255 3
a257 3
      val gc_temporaries     = Array.arrayoflist (#gc MirRegisters.temporary)
      val non_gc_temporaries = Array.arrayoflist (#non_gc MirRegisters.temporary)
      val fp_temporaries     = Array.arrayoflist (#fp MirRegisters.temporary)
d314 3
a316 3
            val gc_slots     = Array.array (gc_spills, MirTypes.GC.new ())
            val non_gc_slots = Array.array (non_gc_spills, MirTypes.NonGC.new ())
            val fp_slots     = Array.array (fp_spills, MirTypes.FP.new ())
d320 1
a320 1
              open Array nonfix sub
d420 1
a420 1
                                   | GCColourer.SPILL n => Array.sub (gc_slots, n),
d423 1
a423 1
                                   | NonGCColourer.SPILL n => Array.sub (non_gc_slots, n),
d426 1
a426 1
                                   | FPColourer.SPILL n => Array.sub (fp_slots, n)}
d469 1
a469 1
			     fn () => NULLARY(CLEAN, GC_REG(Array.sub(gc_slots, slot)))
d512 1
a512 1
			     fn () => NULLARY(CLEAN, GC_REG(Array.sub(gc_slots, slot)))
@


1.69
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d20 4
d165 2
d690 1
a690 1
                  diagnostic (2, fn _ => [MLWorks.Integer.makestring num_spills,
@


1.68
log
@Adding debugging reserved registers
@
text
@d20 3
d696 1
a696 1
        val spill_sizes = MirTypes.Option.PRESENT {gc = gc_spills+gc_spills', 
d705 2
@


1.67
log
@Add immediate store operations
@
text
@d20 3
a160 1
require "../utils/timer";
a176 1
  structure Timer		: TIMER
a199 2
    val show_timings = ref false

d203 4
a206 2
      Diagnostic.output level
      (fn verbosity => "RegisterAllocator: " :: (output_function verbosity))
d208 1
a208 2
    fun crash message =
      Crash.impossible ("RegisterAllocator: " ^ message)
a209 1

d215 4
a218 4
    fun empty ({gc = nr_gc,    non_gc = nr_non_gc,    fp = nr_fp}) =
      {gc     = GCColourer.empty nr_gc,
       non_gc = NonGCColourer.empty nr_non_gc,
       fp     = FPColourer.empty nr_fp}
d249 6
a254 6
          generate_spills (MirProcedure.I ({defined      = MirProcedure.empty,
					    referenced   = MirProcedure.empty,
                                            branches     = Set.empty_set,
                                            except       = [],
                                            (* exits        = false, *)
                                            side_effects = false}, f ()) :: instructions, fs)
d285 1
a285 1
              (fn (MirProcedure.I ({defined, referenced, branches, except, (* exits,*) side_effects}, opcode), instructions) =>
d288 5
a292 7
                   MirProcedure.I ({defined      = MirProcedure.empty,
                                    referenced   = MirProcedure.empty,
                                    branches     = branches,
                                    except       = except,
                                    (* exits        = exits,*)
                                    side_effects = side_effects},
                                   substitute_opcode opcode)
d419 1
a419 1
	      val ref_opcode = ref (COMMENT"")
d576 1
a576 1
		(fn (MirProcedure.I ({defined, referenced, branches, except, (* exits,*) side_effects}, opcode), instructions) =>
d582 5
a586 7
		     MirProcedure.I ({defined      = MirProcedure.empty,
				      referenced   = MirProcedure.empty,
				      branches     = branches,
				      except       = except,
				      (* exits        = exits, *)
				      side_effects = side_effects},
		     substitute_opcode (!ref_opcode))
d615 1
a615 1
		  (fn (MirProcedure.I ({defined, referenced, branches, except, side_effects}, opcode), instructions) =>
d618 5
a622 6
		       MirProcedure.I({defined      = MirProcedure.empty,
				       referenced   = MirProcedure.empty,
				       branches     = branches,
				       except       = except,
				       side_effects = side_effects},
		       substitute_opcode opcode)
d634 4
a637 3
      (fn (acc,MirProcedure.I (_,MirTypes.UNARY (MirTypes.MOVE,
                                                 MirTypes.GC_REG r1,
                                                 MirTypes.GP_GC_REG r2))) =>
d649 2
a650 1
                 {gc = gc_spills', non_gc = non_gc_spills', fp = fp_spills'}) =
d652 1
a652 22
        val _ = 
          if do_diagnostics
            then diagnostic (1, fn _ => ["procedure ", MirTypes.print_tag start, ": ", name])
          else ()

        val _ = 
          if do_diagnostics 
            then
              Diagnostic.output_fn 4
              (fn (_, out) =>
               let
                 fun p (out, s) = (output (out, s); out)
               in
                 p (out, "GC graph\n");
                 GCColourer.print p out gc_graph;
                 p (out, "NonGC graph\n");
                 NonGCColourer.print p out non_gc_graph;
                 p (out, "FP graph\n");
                 FPColourer.print p out fp_graph;
                 ()
               end)
          else ()
d669 5
a673 9
          Timer.xtime ("Colouring", !show_timings, fn () =>
                       (GCColourer.colour (gc_graph,gc_preferences),
                        NonGCColourer.colour (non_gc_graph,[]),
                        FPColourer.colour (fp_graph,[])))

        val _ = 
          if do_diagnostics
            then diagnostic (2, fn _ => ["rewriting procedure"])
          else ()
d691 1
a691 2
          Timer.xtime("Rewrite", !show_timings, fn () =>
            Map.map substitute block_map)
@


1.66
log
@Remove handler register concept
@
text
@d20 3
d540 2
@


1.65
log
@Control unspill behaviour with MachSpec.do_unspilling
@
text
@d20 3
d561 1
a561 1
                | spill (NEW_HANDLER _)                      = ([], [])
@


1.64
log
@Abstraction of debug information
@
text
@d20 3
d189 3
d354 2
a355 2
				  GP_GC_REG(sub(gc_slots, slot2)),
				  GP_GC_REG(sub(gc_slots, slot3)))) :: instructions
d358 2
a359 2
              fun reg_in (instructions, GC_REG r, t) = gc_in (instructions, r, t)
                | reg_in (instructions, NON_GC_REG r, t) = non_gc_in (instructions, r, t)
d399 1
a399 1
            end
d401 2
a402 2
            val substitute_opcode =
              MirProcedure.substitute
d566 60
a625 22
            fn (tag, MirProcedure.B (annotation, instructions)) =>
            (MirProcedure.B
             (annotation,
              Lists.reducer
              (fn (MirProcedure.I ({defined, referenced, branches, except, (* exits,*) side_effects}, opcode), instructions) =>
               let
		 val _ = ref_opcode := opcode
                 val (loads, stores) = spill opcode

                 val instruction =
                   MirProcedure.I ({defined      = MirProcedure.empty,
                                    referenced   = MirProcedure.empty,
                                    branches     = branches,
                                    except       = except,
                                    (* exits        = exits, *)
                                    side_effects = side_effects},
                                   substitute_opcode (!ref_opcode))
               in
                 generate_spills (instruction :: generate_spills (instructions, stores), loads)
               end)
              (instructions, [])))

@


1.63
log
@Reduce spill requirement to two registers.
@
text
@d20 3
a185 1
    structure Option = MirTypes.RuntimeEnv.Option
d309 1
a309 1
                        frame, GP_IMM_SYMB (GC_SPILL_SLOT (Option.SOME2(slot+gc_spills'))))) 
d318 1
a318 1
                       frame, GP_IMM_SYMB (NON_GC_SPILL_SLOT (Option.SOME2(slot+non_gc_spills'))))) 
d327 1
a327 1
                        frame, GP_IMM_SYMB (FP_SPILL_SLOT (Option.SOME2(slot+fp_spills'))))) 
d365 1
a365 1
                          frame, GP_IMM_SYMB (GC_SPILL_SLOT (Option.SOME2(slot+gc_spills'))))) 
d374 1
a374 1
                       frame, GP_IMM_SYMB (NON_GC_SPILL_SLOT (Option.SOME2(slot+non_gc_spills'))))) 
d383 1
a383 1
                       frame, GP_IMM_SYMB (FP_SPILL_SLOT (Option.SOME2(slot+fp_spills'))))) 
d671 3
a673 1
        val spill_sizes = MirTypes.Option.PRESENT {gc = gc_spills+gc_spills', non_gc = non_gc_spills+non_gc_spills', fp = fp_spills+fp_spills'}
@


1.62
log
@Simplified annotations
@
text
@d20 3
d237 1
a237 1
                                            referenced   = MirProcedure.empty,
d299 2
d328 22
d408 6
d415 52
a466 2
              fun spill (TBINARY (_, _, out0, in1, in2))     = (gp_in (gp_in ([], in2, 2), in1, 1), reg_out ([], out0, 0))
                | spill (BINARY (_, out0, in1, in2))         = (gp_in (gp_in ([], in2, 2), in1, 1), reg_out ([], out0, 0))
d475 55
a529 10
                | spill (STOREOP (ST, in0, in1, in2))        = (reg_in (reg_in (gp_in ([], in2, 2), in1, 1), in0, 0), [])
                | spill (STOREOP (STREF, in0, in1, in2))     = (reg_in (reg_in (gp_in ([], in2, 2), in1, 1), in0, 0), [])
                | spill (STOREOP (STB, in0, in1, in2))       = (reg_in (reg_in (gp_in ([], in2, 2), in1, 1), in0, 0), [])
                | spill (STOREOP (LD, out0, in1, in2))       = (reg_in (gp_in ([], in2, 2), in1, 1), reg_out ([], out0, 0))
                | spill (STOREOP (LDREF, out0, in1, in2))    = (reg_in (gp_in ([], in2, 2), in1, 1), reg_out ([], out0, 0))
                | spill (STOREOP (LDB, out0, in1, in2))      = (reg_in (gp_in ([], in2, 2), in1, 1), reg_out ([], out0, 0))
                | spill (STOREFPOP (FST, in0, in1, in2))     = (fp_in (reg_in (gp_in ([], in2, 2), in1, 1), in0, 0), [])
                | spill (STOREFPOP (FSTREF, in0, in1, in2))  = (fp_in (reg_in (gp_in ([], in2, 2), in1, 1), in0, 0), [])
                | spill (STOREFPOP (FLD, out0, in1, in2))    = (reg_in (gp_in ([], in2, 2), in1, 1), fp_out ([], out0, 0))
                | spill (STOREFPOP (FLDREF, out0, in1, in2)) = (reg_in (gp_in ([], in2, 2), in1, 1), fp_out ([], out0, 0))
d564 1
d574 1
a574 1
                                   substitute_opcode opcode)
@


1.61
log
@Added function argument register lists to BRANCH_AND_LINK, TAIL_CALL and ENTER
@
text
@d20 3
d184 2
d234 1
a234 1
                           referenced   = MirProcedure.empty,
d237 1
a237 1
                                            exits        = false,
a241 1
                      {gc = gc_slot,   non_gc = non_gc_slot,   fp = fp_slot},
d269 1
a269 1
              (fn (MirProcedure.I ({defined, referenced, branches, except, exits, side_effects}, opcode), instructions) =>
d276 1
a276 1
                                    exits        = exits,
a282 1

d434 1
a434 1
              (fn (MirProcedure.I ({defined, referenced, branches, except, exits, side_effects}, opcode), instructions) =>
d443 1
a443 1
                                    exits        = exits,
d455 8
a462 1

d473 22
a494 1
        val _ = diagnostic (1, fn _ => ["procedure ", MirTypes.print_tag start, ": ", name])
d496 3
a498 13
        val _ = Diagnostic.output_fn 4
          (fn (_, out) =>
           let
             fun p (out, s) = (output (out, s); out)
           in
             p (out, "GC graph\n");
             GCColourer.print p out gc_graph;
             p (out, "NonGC graph\n");
             NonGCColourer.print p out non_gc_graph;
             p (out, "FP graph\n");
             FPColourer.print p out fp_graph;
             ()
           end)
d500 7
a506 6
        val {exits,
             uses_stack,
             nr_registers,
             registers,
             parameters = MirTypes.PROC_PARAMS {leaf, stack_allocated,
                                                loop_entry, ...}} = annotation
d512 8
a519 3
                       (GCColourer.colour gc_graph,
                        NonGCColourer.colour non_gc_graph,
                        FPColourer.colour fp_graph))
a520 2
        val _ = diagnostic (2, fn _ => ["rewriting procedure"])

d523 7
a529 3
            val gc_empty = MirTypes.GC.Map.empty
            val non_gc_empty = MirTypes.NonGC.Map.empty
            val fp_empty = MirTypes.FP.Map.empty
a530 1
            if gc_spills + non_gc_spills + fp_spills = 0 then
a531 1
                          {gc = gc_empty,   non_gc = non_gc_empty,   fp = fp_empty},
a533 34
            else
              let
                val gc_slot =
                  MirTypes.GC.Map.apply
                  (MirTypes.GC.Pack.reduce
                   (fn (map, r) =>
                    case gc_assign r
                      of GCColourer.REGISTER _ => map
                       | GCColourer.SPILL s => MirTypes.GC.Map.define (map, r, s))
                   (MirTypes.GC.Map.empty, #gc registers))

                val non_gc_slot =
                  MirTypes.NonGC.Map.apply
                  (MirTypes.NonGC.Pack.reduce
                   (fn (map, r) =>
                    case non_gc_assign r
                      of NonGCColourer.REGISTER _ => map
                       | NonGCColourer.SPILL s => MirTypes.NonGC.Map.define (map, r, s))
                   (MirTypes.NonGC.Map.empty, #non_gc registers))

                val fp_slot =
                  MirTypes.FP.Map.apply
                  (MirTypes.FP.Pack.reduce
                   (fn (map, r) =>
                    case fp_assign r
                      of FPColourer.REGISTER _ => map
                       | FPColourer.SPILL s => MirTypes.FP.Map.define (map, r, s))
                   (MirTypes.FP.Map.empty, #fp registers))
              in
                substitute ({gc = gc_assign, non_gc = non_gc_assign, fp = fp_assign},
                            {gc = gc_slot,   non_gc = non_gc_slot,   fp = fp_slot},
                            {gc = gc_spills, non_gc = non_gc_spills, fp = fp_spills},
                            {gc = gc_spills', non_gc = non_gc_spills', fp = fp_spills'})
              end
a539 39
        val registers_used =
          MirTypes.Option.PRESENT
          {gc =
             let
               val set = MirTypes.GC.Pack.reduce
                 (fn (set, r) =>
                  case gc_assign r
                    of GCColourer.REGISTER r => Set.add_member (r, set)
                     | _ => set)
                 (Set.empty_set, #gc registers)
             in
               if gc_spills = 0 then set else 
                 Set.union (set, Set.list_to_set (#gc MirRegisters.temporary))
             end,
           non_gc =
             let
               val set = MirTypes.NonGC.Pack.reduce
                 (fn (set, r) =>
                  case non_gc_assign r
                    of NonGCColourer.REGISTER r => Set.add_member (r, set)
                     | _ => set)
                 (Set.empty_set, #non_gc registers)
             in
               if non_gc_spills = 0 then set else 
                 Set.union (set, Set.list_to_set (#non_gc MirRegisters.temporary))
             end,
           fp =
             let
               val set = MirTypes.FP.Pack.reduce
                 (fn (set, r) =>
                  case fp_assign r
                    of FPColourer.REGISTER r => Set.add_member (r, set)
                     | _ => set)
                 (Set.empty_set, #fp registers)
             in
               if fp_spills = 0 then set else 
                 Set.union (set, Set.list_to_set (#fp MirRegisters.temporary))
             end}

d543 1
a543 3
        MirProcedure.P ({exits = exits,
                         nr_registers = nr_registers,
                         registers = registers,
d546 2
a547 5
                                      {leaf =  leaf,
                                       registers_used = registers_used,
                                       stack_allocated = stack_allocated,
                                       spill_sizes = spill_sizes,
                                       loop_entry = loop_entry}},
a553 3



@


1.60
log
@Fix to avoid lr unspilling alloc
@
text
@d20 3
d405 4
a408 4
                | spill (BRANCH_AND_LINK (_, REG in0,_))       = (reg_in ([], in0, 0), [])
                | spill (BRANCH_AND_LINK (_, TAG _,_))         = ([], [])
                | spill (TAIL_CALL (_, REG in0))             = (reg_in ([], in0, 0), [])
                | spill (TAIL_CALL (_, TAG _))               = ([], [])
d417 1
a417 1
                | spill (ENTER)                              = ([], [])
@


1.59
log
@Add field to MirTypes.PROC_PARAMS.
@
text
@d20 3
d219 3
a221 3
      val gc_temporaries     = Array.arrayoflist (MirTypes.GC.Pack.to_list    (#gc MirRegisters.temporary))
      val non_gc_temporaries = Array.arrayoflist (MirTypes.NonGC.Pack.to_list (#non_gc MirRegisters.temporary))
      val fp_temporaries     = Array.arrayoflist (MirTypes.FP.Pack.to_list    (#fp MirRegisters.temporary))
d556 1
a556 1
                 Set.union (set, Set.list_to_set (MirTypes.GC.Pack.to_list (#gc MirRegisters.temporary)))
d568 1
a568 1
                 Set.union (set, Set.list_to_set (MirTypes.NonGC.Pack.to_list (#non_gc MirRegisters.temporary)))
d580 1
a580 1
                 Set.union (set, Set.list_to_set (MirTypes.FP.Pack.to_list (#fp MirRegisters.temporary)))
@


1.58
log
@Added handling of INTERRUPT instruction
@
text
@d20 3
d477 2
a478 1
             parameters = MirTypes.PROC_PARAMS {leaf, stack_allocated, ...}} = annotation
d591 2
a592 1
                                       spill_sizes = spill_sizes}},
@


1.57
log
@Removed erroneous sharing constraint
@
text
@d20 3
d407 1
@


1.56
log
@Changed the annotation of raise instructions to model the fact that
the raise might reach _any_ of the nexted continuation blocks.
@
text
@d20 4
a154 1
  sharing MirRegisters.MirTypes.Set = MirTables.Set
@


1.56.1.1
log
@Fork for bug fixing
@
text
@a19 4
 *  Revision 1.56  1993/08/17  12:11:46  richard
 *  Changed the annotation of raise instructions to model the fact that
 *  the raise might reach _any_ of the nexted continuation blocks.
 *
@


1.56.1.2
log
@Removed no longer necessary sharing constraint
@
text
@a19 3
 *  Revision 1.56.1.1  1993/08/17  12:11:46  jont
 *  Fork for bug fixing
 *
d155 1
a155 1
(*  sharing MirRegisters.MirTypes.Set = MirTables.Set*)
@


1.55
log
@Added some extra diagnostics.
@
text
@d20 3
d216 1
a216 1
                                            except       = MirProcedure.Option.ABSENT,
@


1.54
log
@Extra stack spills for local and closure variable inspection
in the debugger;
structure Option.
@
text
@d20 5
d445 14
@


1.53
log
@Changed PROFILE instruction to INTERCEPT.
@
text
@d20 3
d154 1
d215 2
a216 1
                      {gc = gc_spills, non_gc = non_gc_spills, fp = fp_spills}) =
d218 1
a218 1
        if gc_spills + non_gc_spills + fp_spills = 0 then
d223 1
a223 1
              "The regiseter colourers said that there were no spills, but I've found one."
d276 2
a277 1
                                         frame, GP_IMM_SYMB (GC_SPILL_SLOT slot))) :: instructions)
d285 2
a286 1
                                         frame, GP_IMM_SYMB (NON_GC_SPILL_SLOT slot))) :: instructions)
d294 2
a295 1
                                           frame, GP_IMM_SYMB (FP_SPILL_SLOT slot))) :: instructions)
d310 2
a311 1
                                         frame, GP_IMM_SYMB (GC_SPILL_SLOT slot))) :: instructions)
d319 2
a320 1
                                         frame, GP_IMM_SYMB (NON_GC_SPILL_SLOT slot))) :: instructions)
d328 2
a329 1
                                           frame, GP_IMM_SYMB (FP_SPILL_SLOT slot))) :: instructions)
d436 2
a437 1
                 {gc = gc_graph, non_gc = non_gc_graph, fp = fp_graph}) =
d466 2
a467 1
                          {gc = gc_spills, non_gc = non_gc_spills, fp = fp_spills})
d499 2
a500 1
                            {gc = gc_spills, non_gc = non_gc_spills, fp = fp_spills})
d509 1
a509 1
          MirTypes.PRESENT
d547 1
a547 1
        val spill_sizes = MirTypes.PRESENT {gc = gc_spills, non_gc = non_gc_spills, fp = fp_spills}
@


1.52
log
@Map substructure is now MirTypes.Map
@
text
@d20 3
d381 1
a381 1
                | spill (PROFILER out0)                      = ([], reg_out ([], out0, 0))
@


1.51
log
@Efficiency changes to use mononewmap for registers and tags
@
text
@d20 3
d147 2
a148 1
    structure Map = MirTypes.Debugger_Types.Datatypes.NewMap
d489 1
a489 1
            MirTypes.Map.map substitute block_map)
@


1.50
log
@Added missing resiter substitution for PROFILER opcode
@
text
@d20 3
d440 3
a442 3
            val gc_empty = Map.empty' MirTypes.GC.order
            val non_gc_empty = Map.empty' MirTypes.NonGC.order
            val fp_empty = Map.empty' MirTypes.FP.order
d451 1
a451 1
                  Map.apply
d456 2
a457 2
                       | GCColourer.SPILL s => Map.define (map, r, s))
                   (Map.empty' MirTypes.GC.order, #gc registers))
d460 1
a460 1
                  Map.apply
d465 2
a466 2
                       | NonGCColourer.SPILL s => Map.define (map, r, s))
                   (Map.empty' MirTypes.NonGC.order, #non_gc registers))
d469 1
a469 1
                  Map.apply
d474 2
a475 2
                       | FPColourer.SPILL s => Map.define (map, r, s))
                   (Map.empty' MirTypes.FP.order, #fp registers))
d485 1
a485 1
            Map.map substitute block_map)
@


1.49
log
@Removed some unncesessary intermediate lists which
were being built.
@
text
@d20 4
d371 1
a371 1
                | spill (PROFILER _)                         = ([], [])
@


1.48
log
@Removed some redundant structures and sharing
@
text
@d20 3
d220 1
a220 2
            (tag,
             MirProcedure.B
a377 1

d379 1
a379 2
            (tag,
             MirProcedure.B
d478 1
a478 2
            Map.from_list' MirTypes.order_tag
            (map substitute (Map.to_list block_map)))
@


1.47
log
@Added NULLARY opcode type and ALLOC_BYTEARRAY.
@
text
@d20 3
a94 1
require "../utils/set";
a97 1
require "../utils/newmap";
a100 1
require "mirtypes";
a106 2

  structure MirTypes		: MIRTYPES
a111 2
  structure Map			: NEWMAP
  structure Set			: SET
d117 1
a117 1
  sharing GCColourer.Register = MirTypes.GC
d119 1
a119 1
  sharing NonGCColourer.Register = MirTypes.NonGC
d121 1
a121 1
  sharing FPColourer.Register = MirTypes.FP
d123 2
a124 2
  sharing MirTypes = MirProcedure.MirTypes = MirPrint.MirTypes = MirRegisters.MirTypes = MirTables.MirTypes
  sharing Set = MirTypes.Set = MirRegisters.Set = MirTables.Set = MirProcedure.Set
d130 2
a131 2

    structure MirTypes = MirTypes
d134 1
a134 1

d478 2
a479 2
            MirProcedure.Map.from_list' MirTypes.order_tag
            (map substitute (MirProcedure.Map.to_list block_map)))
@


1.46
log
@Added type annotation information at application points
@
text
@d20 3
d338 1
@


1.45
log
@Added parameter to RAISE once again.
@
text
@d20 3
d355 2
a356 2
                | spill (BRANCH_AND_LINK (_, REG in0))       = (reg_in ([], in0, 0), [])
                | spill (BRANCH_AND_LINK (_, TAG _))         = ([], [])
@


1.44
log
@Hints are no longer passed to the graphs.
@
text
@d20 3
d90 1
d96 1
d367 1
a367 1
                | spill (RAISE)                              = ([], [])
@


1.43
log
@Rewrote spill generating code for speed.
@
text
@d20 3
d143 4
a146 5
    fun empty ({gc = nr_gc,    non_gc = nr_non_gc,    fp = nr_fp},
               {gc = gc_hints, non_gc = non_gc_hints, fp = fp_hints}) =
      {gc     = GCColourer.empty    (nr_gc,     gc_hints),
       non_gc = NonGCColourer.empty (nr_non_gc, non_gc_hints),
       fp     = FPColourer.empty    (nr_fp,     fp_hints)}
@


1.42
log
@TENTATIVE CHECKIN.  Reworked spill slot allocation.
Needs testing and revising.
@
text
@d20 4
d147 1
d149 3
a151 3
      (GCColourer.clash    (gc,     gc_defined,     gc_live);
       NonGCColourer.clash (non_gc, non_gc_defined, non_gc_live);
       FPColourer.clash    (fp,     fp_defined,     fp_live))
d169 12
a180 16
      val gc_temporaries     = MirTypes.GC.Pack.to_list    (#gc MirRegisters.temporary)
      val non_gc_temporaries = MirTypes.NonGC.Pack.to_list (#non_gc MirRegisters.temporary)
      val fp_temporaries     = MirTypes.FP.Pack.to_list    (#fp MirRegisters.temporary)

      fun annotate_simply opcode =
        MirProcedure.I ({defined      = {gc     = MirTypes.GC.Pack.empty,
                                         non_gc = MirTypes.NonGC.Pack.empty,
                                         fp     = MirTypes.FP.Pack.empty},
                         referenced   = {gc     = MirTypes.GC.Pack.empty,
                                         non_gc = MirTypes.NonGC.Pack.empty,
                                         fp     = MirTypes.FP.Pack.empty},
                         branches     = Set.empty_set,
                         except       = MirProcedure.Option.ABSENT,
                         exits        = false,
                         side_effects = false}, opcode)

d186 27
a212 28
        let
          val gc_slots     = Array.array (gc_spills, MirTypes.GC.new ())
          val non_gc_slots = Array.array (non_gc_spills, MirTypes.NonGC.new ())
          val fp_slots     = Array.array (fp_spills, MirTypes.FP.new ())

          val substitute_opcode =
            MirProcedure.substitute
            {gc     = fn r => case gc_assign r
                                of GCColourer.REGISTER r => r
                                 | GCColourer.SPILL n => Array.sub (gc_slots, n),
             non_gc = fn r => case non_gc_assign r
                                of NonGCColourer.REGISTER r => r
                                 | NonGCColourer.SPILL n => Array.sub (non_gc_slots, n),
             fp     = fn r => case fp_assign r
                                of FPColourer.REGISTER r => r
                                 | FPColourer.SPILL n => Array.sub (fp_slots, n)}

          fun spill_type (slots, slot, temporaries, union, reduce, reduce', load, store)
                         (loads, stores, defined, referenced) =
            (Lists.reducel
             (fn (t::ts, slot) => (Array.update (slots, slot, t); ts)
               |  _            => crash "Run out of temporaries")
             (temporaries,
              reduce
              (fn (both, r) => ((slot r) :: both) handle Map.Undefined => both)
              ([], union (defined, referenced)));
             (reduce'
              (fn (loads, r) =>
d214 8
a221 1
                 val s = slot r
d223 139
a361 34
                 load  (Array.sub (slots, s), slot r) :: loads
               end handle Map.Undefined => loads)
              (loads, referenced),
              reduce'
              (fn (stores, r) =>
               let
                 val s = slot r
               in
                 store (Array.sub (slots, s), slot r) :: stores
               end handle Map.Undefined => stores)
              (stores, defined)))

          local
            val spill_gc =
              spill_type
              (gc_slots, gc_slot, gc_temporaries,
               MirTypes.GC.Pack.union, MirTypes.GC.Pack.reduce, MirTypes.GC.Pack.reduce,
               fn (r, s) => let open MirTypes in STOREOP (LDREF, GC_REG r, frame, GP_IMM_SYMB (GC_SPILL_SLOT s)) end,
               fn (r, s) => let open MirTypes in STOREOP (STREF, GC_REG r, frame, GP_IMM_SYMB (GC_SPILL_SLOT s)) end)

            val spill_non_gc =
              spill_type
              (non_gc_slots, non_gc_slot, non_gc_temporaries,
               MirTypes.NonGC.Pack.union, MirTypes.NonGC.Pack.reduce, MirTypes.NonGC.Pack.reduce,
               fn (r, s) => let open MirTypes in STOREOP (LDREF, NON_GC_REG r, frame, GP_IMM_SYMB (NON_GC_SPILL_SLOT s)) end,
               fn (r, s) => let open MirTypes in STOREOP (STREF, NON_GC_REG r, frame, GP_IMM_SYMB (NON_GC_SPILL_SLOT s)) end)

            val spill_fp =
              spill_type
              (fp_slots, fp_slot, fp_temporaries,
               MirTypes.FP.Pack.union, MirTypes.FP.Pack.reduce, MirTypes.FP.Pack.reduce,
               fn (r, s) => let open MirTypes in STOREFPOP (FLDREF, FP_REG r, frame, GP_IMM_SYMB (FP_SPILL_SLOT s)) end,
               fn (r, s) => let open MirTypes in STOREFPOP (FSTREF, FP_REG r, frame, GP_IMM_SYMB (FP_SPILL_SLOT s)) end)
          in
d363 1
a363 9
            fun spill ({gc = gc_defined, non_gc = non_gc_defined, fp = fp_defined},
                       {gc = gc_referenced, non_gc = non_gc_referenced, fp = fp_referenced}) =
              let
                val (loads, stores)     = spill_gc ([], [], gc_defined, gc_referenced)
                val (loads', stores')   = spill_non_gc (loads, stores, non_gc_defined, non_gc_referenced)
                val (loads'', stores'') = spill_fp (loads', stores', fp_defined, fp_referenced)
              in
                (loads'', stores'')
              end
d365 1
a365 1
          end
d367 8
a374 1
        in
d376 12
a387 28
          fn (tag, MirProcedure.B (annotation, instructions)) =>
          (tag,
           MirProcedure.B
           (annotation,
            Lists.reducer
            (fn (MirProcedure.I ({defined, referenced, branches, except, exits, side_effects}, opcode), instructions) =>
             let
               val (loads, stores) = spill (defined, referenced)

               val loads' = map annotate_simply loads
               val stores' = map annotate_simply stores

               val instruction =
                 MirProcedure.I ({defined      = {gc     = MirTypes.GC.Pack.empty,
                                                  non_gc = MirTypes.NonGC.Pack.empty,
                                                  fp     = MirTypes.FP.Pack.empty},
                                  referenced   = {gc     = MirTypes.GC.Pack.empty,
                                                  non_gc = MirTypes.NonGC.Pack.empty,
                                                  fp     = MirTypes.FP.Pack.empty},
                                  branches     = branches,
                                  except       = except,
                                  exits        = exits,
                                  side_effects = side_effects},
                                 substitute_opcode opcode)
             in
               (loads' @@ (instruction :: stores')) @@ instructions
             end)
            (instructions, [])))
d389 1
a389 1
        end
d423 3
a425 26
            val gc_slot =
              Map.apply
              (MirTypes.GC.Pack.reduce
               (fn (map, r) =>
                case gc_assign r
                  of GCColourer.REGISTER _ => map
                   | GCColourer.SPILL s => Map.define (map, r, s))
               (Map.empty' MirTypes.GC.order, #gc registers))

            val non_gc_slot =
              Map.apply
              (MirTypes.NonGC.Pack.reduce
               (fn (map, r) =>
                case non_gc_assign r
                  of NonGCColourer.REGISTER _ => map
                   | NonGCColourer.SPILL s => Map.define (map, r, s))
               (Map.empty' MirTypes.NonGC.order, #non_gc registers))

            val fp_slot =
              Map.apply
              (MirTypes.FP.Pack.reduce
               (fn (map, r) =>
                case fp_assign r
                  of FPColourer.REGISTER _ => map
                   | FPColourer.SPILL s => Map.define (map, r, s))
               (Map.empty' MirTypes.FP.order, #fp registers))
d427 37
a463 3
            substitute ({gc = gc_assign, non_gc = non_gc_assign, fp = fp_assign},
                        {gc = gc_slot,   non_gc = non_gc_slot,   fp = fp_slot},
                        {gc = gc_spills, non_gc = non_gc_spills, fp = fp_spills})
@


1.41
log
@Calculated the sets of registers used properly.
@
text
@d20 3
d96 1
d160 1
a160 6
    fun substitute_block {gc = gc_assign, non_gc = non_gc_assign, fp = fp_assign}
                         (tag, MirProcedure.B (annotation, instructions)) =
      let
        val gc_temporaries     = MirTypes.GC.Pack.to_list    (#gc MirRegisters.temporary)
        val non_gc_temporaries = MirTypes.NonGC.Pack.to_list (#non_gc MirRegisters.temporary)
        val fp_temporaries     = MirTypes.FP.Pack.to_list    (#fp MirRegisters.temporary)
d162 88
a249 3
        fun substitute (opcodes, MirProcedure.I ({branches, exits, except, side_effects, ...}, opcode)) =
          let
            open MirTypes
d251 9
a259 2
            val loads = ref []
            val stores = ref []
a260 172
            val gc_temporaries = ref gc_temporaries
            val non_gc_temporaries = ref non_gc_temporaries
            val fp_temporaries = ref fp_temporaries

            val frame = GC_REG MirRegisters.fp

            fun gc_temporary () =
              case (!gc_temporaries)
                of t::ts => (gc_temporaries := ts; t)
                 | [] =>
                   crash "Run out of GC temporaries."

            fun non_gc_temporary () =
              case (!non_gc_temporaries)
                of t::ts => (non_gc_temporaries := ts; t)
                 | [] =>
                   crash "Run out of NON_GC temporaries."

            fun fp_temporary () =
              case (!fp_temporaries)
                of t::ts => (fp_temporaries := ts; t)
                 | [] =>
                   crash "Run out of FLOAT temporaries."

            datatype direction = IN | OUT

            fun sub_gc (gc, direction) =
              case gc_assign gc
                of GCColourer.REGISTER r => r
                 | GCColourer.SPILL s =>
                   let
                     val t = gc_temporary ()
                   in
                     (case direction
                        of IN  => loads  := STOREOP(LDREF, GC_REG t, frame, GP_IMM_SYMB(GC_SPILL_SLOT s)) :: (!loads)
                         | OUT => stores := STOREOP(STREF, GC_REG t, frame, GP_IMM_SYMB(GC_SPILL_SLOT s)) :: (!stores));
                     t
                   end

            fun sub_non_gc (non_gc, direction) =
              case non_gc_assign non_gc
                of NonGCColourer.REGISTER r => r
                 | NonGCColourer.SPILL s =>
                   let
                     val t = non_gc_temporary ()
                   in
                     (case direction
                        of IN  => loads  := STOREOP(LDREF, NON_GC_REG t, frame, GP_IMM_SYMB(NON_GC_SPILL_SLOT s)) :: (!loads)
                         | OUT => stores := STOREOP(STREF, NON_GC_REG t, frame, GP_IMM_SYMB(NON_GC_SPILL_SLOT s)) :: (!stores));
                     t
                   end

            fun sub_fp (FP_REG fp, direction) =
              case fp_assign fp
                of FPColourer.REGISTER r => FP_REG r
                 | FPColourer.SPILL s =>
                   let
                     val t = fp_temporary ()
                   in
                     (case direction
                        of IN  => loads  := STOREFPOP(FLDREF, FP_REG t, frame, GP_IMM_SYMB(FP_SPILL_SLOT s)) :: (!loads)
                         | OUT => stores := STOREFPOP(FSTREF, FP_REG t, frame, GP_IMM_SYMB(FP_SPILL_SLOT s)) :: (!stores));
                     FP_REG t
                   end

            fun sub_gp (GP_GC_REG r, direction)     = GP_GC_REG (sub_gc (r, direction))
              | sub_gp (GP_NON_GC_REG r, direction) = GP_NON_GC_REG (sub_non_gc (r, direction))
              | sub_gp (operand, _) = operand

            fun sub_reg (GC_REG r, direction)     = GC_REG (sub_gc (r, direction))
              | sub_reg (NON_GC_REG r, direction) = NON_GC_REG (sub_non_gc (r, direction))

            fun sub_op (TBINARY(operator, tag, reg, gp1, gp2)) =
                TBINARY(operator, tag, sub_reg (reg, OUT), sub_gp (gp1, IN), sub_gp (gp2, IN))
              | sub_op (BINARY(operator, reg, gp1, gp2)) =
                BINARY(operator, sub_reg (reg, OUT), sub_gp (gp1, IN), sub_gp (gp2, IN))
              | sub_op (UNARY(operator, reg, gp)) =
                UNARY(operator, sub_reg (reg, OUT), sub_gp (gp, IN))
              | sub_op (BINARYFP(operator, fp1, fp2, fp3)) =
                BINARYFP(operator, sub_fp (fp1, OUT), sub_fp (fp2, IN), sub_fp (fp3, IN))
              | sub_op (UNARYFP(operator, fp1, fp2)) =
                UNARYFP(operator, sub_fp (fp1, OUT), sub_fp (fp2, IN))
              | sub_op (TBINARYFP(operator, tag, fp1, fp2, fp3)) =
                TBINARYFP(operator, tag, sub_fp (fp1, OUT), sub_fp (fp2, IN), sub_fp (fp3, IN))
              | sub_op (TUNARYFP(operator, tag, fp1, fp2)) =
                TUNARYFP(operator, tag, sub_fp (fp1, OUT), sub_fp (fp2, IN))
              | sub_op (STACKOP(PUSH, reg, offset)) =
                STACKOP(PUSH, sub_reg (reg, IN), offset)
              | sub_op (STACKOP(POP, reg, offset)) =
                STACKOP(POP, sub_reg (reg, OUT), offset)
              | sub_op (STOREOP(LD, reg1, reg2, gp)) =
                STOREOP(LD, sub_reg (reg1, OUT), sub_reg (reg2, IN), sub_gp (gp, IN))
              | sub_op (STOREOP(LDB, reg1, reg2, gp)) =
                STOREOP(LDB, sub_reg (reg1, OUT), sub_reg (reg2, IN), sub_gp (gp, IN))
              | sub_op (STOREOP(LDREF, reg1, reg2, gp)) =
                STOREOP(LDREF, sub_reg (reg1, OUT), sub_reg (reg2, IN), sub_gp (gp, IN))
              | sub_op (STOREOP(ST, reg1, reg2, gp)) =
                STOREOP(ST, sub_reg (reg1, IN), sub_reg (reg2, IN), sub_gp (gp, IN))
              | sub_op (STOREOP(STB, reg1, reg2, gp)) =
                STOREOP(STB, sub_reg (reg1, IN), sub_reg (reg2, IN), sub_gp (gp, IN))
              | sub_op (STOREOP(STREF, reg1, reg2, gp)) =
                STOREOP(STREF, sub_reg (reg1, IN), sub_reg (reg2, IN), sub_gp (gp, IN))
              | sub_op (STOREFPOP(FLD, fp, reg, gp)) =
                STOREFPOP(FLD, sub_fp (fp, OUT), sub_reg (reg, IN), sub_gp (gp, IN))
              | sub_op (STOREFPOP(FLDREF, fp, reg, gp)) =
                STOREFPOP(FLDREF, sub_fp (fp, OUT), sub_reg (reg, IN), sub_gp (gp, IN))
              | sub_op (STOREFPOP(FST, fp, reg, gp)) =
                STOREFPOP(FST, sub_fp (fp, IN), sub_reg (reg, IN), sub_gp (gp, IN))
              | sub_op (STOREFPOP(FSTREF, fp, reg, gp)) =
                STOREFPOP(FSTREF, sub_fp (fp, IN), sub_reg (reg, IN), sub_gp (gp, IN))
              | sub_op (REAL(operator, fp, gp)) =
                REAL(operator, sub_fp (fp, OUT), sub_gp (gp, IN))
              | sub_op (FLOOR(operator, tag, reg, fp)) =
                FLOOR(operator, tag, sub_reg (reg, OUT), sub_fp (fp, IN))
              | sub_op (BRANCH(operator, REG reg)) =
                BRANCH(operator, REG (sub_reg (reg, IN)))
              | sub_op (opcode as BRANCH _) = opcode
              | sub_op (TEST(operator, tag, gp1, gp2)) =
                TEST(operator, tag, sub_gp (gp1, IN), sub_gp (gp2, IN))
              | sub_op (FTEST(operator, tag, fp1, fp2)) =
                FTEST(operator, tag, sub_fp (fp1, IN), sub_fp (fp2, IN))
              | sub_op (BRANCH_AND_LINK(operator, REG reg)) =
                BRANCH_AND_LINK(operator, REG (sub_reg (reg, IN)))
              | sub_op (opcode as BRANCH_AND_LINK _) = opcode
              | sub_op (TAIL_CALL(operator, REG reg)) =
                TAIL_CALL(operator, REG (sub_reg (reg, IN)))
              | sub_op (opcode as TAIL_CALL _) = opcode
              | sub_op (SWITCH(operator, reg, tags)) =
                SWITCH(operator, sub_reg (reg, IN), tags)
              | sub_op (ALLOCATE(operator, reg, i)) =
                ALLOCATE(operator, sub_reg (reg, OUT), sub_gp (i, IN))
              | sub_op (ALLOCATE_STACK(operator, reg, i, offset)) =
                ALLOCATE_STACK(operator, sub_reg (reg, OUT), i, offset)
              | sub_op (opcode as DEALLOCATE_STACK _) = opcode
              | sub_op (ADR(operator, reg, tag)) =
                ADR(operator, sub_reg (reg, OUT), tag)
              | sub_op RAISE = RAISE
              | sub_op CALL_C = CALL_C
              | sub_op ENTER = ENTER
              | sub_op (PROFILER reg) = PROFILER (sub_reg(reg,OUT))
              | sub_op RTS = RTS
              | sub_op(opcode as NEW_HANDLER _) = opcode
              | sub_op OLD_HANDLER = OLD_HANDLER
              | sub_op(opcode as COMMENT _) = opcode

            val new_opcode =
              MirProcedure.I ({defined      = {gc     = MirTypes.GC.Pack.empty,
                                               non_gc = MirTypes.NonGC.Pack.empty,
                                               fp     = MirTypes.FP.Pack.empty},
                               referenced   = {gc     = MirTypes.GC.Pack.empty,
                                               non_gc = MirTypes.NonGC.Pack.empty,
                                               fp     = MirTypes.FP.Pack.empty},
                               branches     = branches,
                               except       = except,
                               exits        = exits,
                               side_effects = side_effects},
                              sub_op opcode)

            fun annotate_simply opcode =
              MirProcedure.I ({defined      = {gc     = MirTypes.GC.Pack.empty,
                                               non_gc = MirTypes.NonGC.Pack.empty,
                                               fp     = MirTypes.FP.Pack.empty},
                               referenced   = {gc     = MirTypes.GC.Pack.empty,
                                               non_gc = MirTypes.NonGC.Pack.empty,
                                               fp     = MirTypes.FP.Pack.empty},
                               branches     = Set.empty_set,
                               except       = MirProcedure.Option.ABSENT,
                               exits        = false,
                               side_effects = false},
                               opcode)
          in
            ((map annotate_simply (!stores)) @@ (new_opcode :: (map annotate_simply (!loads)))) @@ opcodes
d262 31
a292 3
      in
        (tag, MirProcedure.B (annotation, rev (Lists.reducel substitute ([], instructions))))
      end
d294 1
d296 4
d310 6
d325 35
d363 1
a363 9
            (map
             (substitute_block {gc = gc_assign, non_gc = non_gc_assign, fp = fp_assign})
             (MirProcedure.Map.to_list block_map)))

        val {exits,
             uses_stack,
             nr_registers,
             registers,
             parameters = MirTypes.PROC_PARAMS {leaf, stack_allocated, ...}} = annotation
@


1.40
log
@Removed register graph and colouring code to a general register
colouring functor.
@
text
@d20 4
d358 3
a360 3
        val ({assign = gc_assign,     nr_spills = gc_spills,     used = gc_used},
             {assign = non_gc_assign, nr_spills = non_gc_spills, used = non_gc_used},
             {assign = fp_assign,     nr_spills = fp_spills,     used = fp_used}) =
d377 1
d382 36
a417 3
          {gc     = Set.list_to_set (MirTypes.GC.Pack.to_list gc_used),
           non_gc = Set.list_to_set (MirTypes.NonGC.Pack.to_list non_gc_used),
           fp     = Set.list_to_set (MirTypes.FP.Pack.to_list fp_used)}
d424 1
@


1.39
log
@Changed register Sets to Packs.  There is scope for the elimination
of register hash tables using packed registers.
@
text
@d20 4
a68 1
require "../utils/array";
a70 1
require "../utils/hashtable";
a71 1
require "../utils/integer";
a90 4
  structure Array		: ARRAY
  structure GCHashTable		: HASHTABLE
  structure NonGCHashTable	: HASHTABLE
  structure FPHashTable		: HASHTABLE
a91 1
  structure Integer		: INTEGER
d94 7
a103 4
  sharing type GCHashTable.Key = MirTypes.GC.T
  sharing type NonGCHashTable.Key = MirTypes.NonGC.T
  sharing type FPHashTable.Key = MirTypes.FP.T
  sharing type GCHashTable.Value = NonGCHashTable.Value = FPHashTable.Value = int
a114 3

    (*  === UTILITY FUNCTIONS ===  *)

a121 277
    fun iterate f [] = ()
      | iterate f (x::xs) = (f x; iterate f xs)

    fun first 0 _ = []
      | first n [] = []
      | first n (x::xs) = x::(first (n-1) xs)


    (*  === ADD CLASH CLIQUE TO ADJACENCY LIST ARRAY ===
     *
     *  Add edges from all the vertices in the `from' list to all those in
     *  the `to' list by attaching the vertex to the front of the adjacency
     *  lists of each other vertex.
     *)

    fun clique _ ([], _) = ()
      | clique adjacent (from, to) =
        let
          fun tangle [] = ()
            | tangle (edge::edges) =
              let
                fun weave [] = ()
                  | weave (edge'::edges') =
                    (Array.update (adjacent, edge, edge' :: Array.sub (adjacent, edge));
                     Array.update (adjacent, edge', edge :: Array.sub (adjacent, edge'));
                     weave edges')
              in
                weave to;
                tangle edges
              end
        in
          tangle from
        end

    fun ordered_vertices adjacent =
      let
        fun degree (list, 0) = list
          | degree (list, n) = degree ((n-1, Lists.length (Array.sub (adjacent, n-1)))::list, n-1)
        fun order ((_, degree:int), (_, degree':int)) = degree > degree'
      in
        map #1 (Lists.qsort order (degree ([], Array.length adjacent)))
      end



    (*  === THE REGISTERS ===
     *
     *  These values determine which registers will be used for colouring.
     *  At present, a fixed number of temporaries are reserved for the
     *  purposes of spilling, and are not used for colouring.  (See notes in
     *  header comment.)
     *)

    val gc_temporaries = first 3 (#gc MirRegisters.temporary)
    val non_gc_temporaries = []
    val fp_temporaries = first 2 (#fp MirRegisters.temporary)

    local
      fun colour_array (colour_list, temporaries) =
        Array.arrayoflist (Lists.difference (colour_list, temporaries))
    in
      val gc_colours     = colour_array (MirTypes.GC.Pack.to_list    (#gc MirRegisters.general_purpose), gc_temporaries)
      val non_gc_colours = colour_array (MirTypes.NonGC.Pack.to_list (#non_gc MirRegisters.general_purpose), non_gc_temporaries)
      val fp_colours     = colour_array (MirTypes.FP.Pack.to_list    (#fp MirRegisters.general_purpose), fp_temporaries)
    end



    (*  === BUILD HASH TABLES FOR REGISTERS ===
     *
     *  Every virtual register defined (and therefore used) in the procedure
     *  is mapped on to an integer by a hash table.  (Registers which have
     *  hints indicating that they may share a real register are mapped onto
     *  the same integer.)  This integer is then used as a vertex index to
     *  the adjacency matrix.  The integers chosen are contiguous.  This
     *  function builds the hash tables from the lists of register cliques,
     *  and also stores number of registers the nr_*_regs reference cells.
     *)

    val nr_gc_regs = ref 0
    val nr_non_gc_regs = ref 0
    val nr_fp_regs = ref 0

    fun build_tables ((gc, non_gc, fp), (gc_hints, non_gc_hints, fp_hints)) =
    (
      nr_gc_regs := 0;
      nr_non_gc_regs := 0;
      nr_fp_regs := 0;
      GCHashTable.clear ();
      NonGCHashTable.clear ();
      FPHashTable.clear ();

      iterate (fn (r,r') =>
               GCHashTable.update (r, GCHashTable.lookup r')
               handle GCHashTable.Lookup _ =>
                 GCHashTable.update (r', GCHashTable.lookup r)
                 handle GCHashTable.Lookup _ =>
                   (GCHashTable.update (r,  !nr_gc_regs);
                    GCHashTable.update (r', !nr_gc_regs);
                    nr_gc_regs := !nr_gc_regs + 1)) gc_hints;

      iterate (fn (defined, _) =>
               iterate (fn reg => ((GCHashTable.lookup reg; ())
                                   handle GCHashTable.Lookup _ =>
                                     (GCHashTable.update (reg, !nr_gc_regs);
                                      nr_gc_regs := !nr_gc_regs + 1))) defined) gc;

      iterate (fn (r,r') =>
               NonGCHashTable.update (r, NonGCHashTable.lookup r')
               handle NonGCHashTable.Lookup _ =>
                 NonGCHashTable.update (r', NonGCHashTable.lookup r)
                 handle NonGCHashTable.Lookup _ =>
                   (NonGCHashTable.update (r,  !nr_non_gc_regs);
                    NonGCHashTable.update (r', !nr_non_gc_regs);
                    nr_non_gc_regs := !nr_non_gc_regs + 1)) non_gc_hints;

      iterate (fn (defined, _) =>
               iterate (fn reg => ((NonGCHashTable.lookup reg; ())
                                   handle NonGCHashTable.Lookup _ =>
                                     (NonGCHashTable.update (reg, !nr_non_gc_regs);
                                      nr_non_gc_regs := !nr_non_gc_regs + 1))) defined) non_gc;

      iterate (fn (r,r') =>
               FPHashTable.update (r, FPHashTable.lookup r')
               handle FPHashTable.Lookup _ =>
                 FPHashTable.update (r', FPHashTable.lookup r)
                 handle FPHashTable.Lookup _ =>
                   (FPHashTable.update (r,  !nr_fp_regs);
                    FPHashTable.update (r', !nr_fp_regs);
                    nr_fp_regs := !nr_fp_regs + 1)) fp_hints;

      iterate (fn (defined, _) =>
               iterate (fn reg => ((FPHashTable.lookup reg; ())
                                   handle FPHashTable.Lookup _ =>
                                     (FPHashTable.update (reg, !nr_fp_regs);
                                      nr_fp_regs := !nr_fp_regs + 1))) defined) fp;
      let
        val gc_inverse     = Array.array (!nr_gc_regs,     MirTypes.GC.new ())
        and non_gc_inverse = Array.array (!nr_non_gc_regs, MirTypes.NonGC.new ())
        and fp_inverse     = Array.array (!nr_fp_regs,     MirTypes.FP.new ())
      in        
        iterate (fn (defined, _) =>
                 iterate (fn reg => Array.update (gc_inverse, GCHashTable.lookup reg, reg)) defined) gc;
        iterate (fn (defined, _) =>
                 iterate (fn reg => Array.update (non_gc_inverse, NonGCHashTable.lookup reg, reg)) defined) non_gc;
        iterate (fn (defined, _) =>
                 iterate (fn reg => Array.update (fp_inverse, FPHashTable.lookup reg, reg)) defined) fp;
        (gc_inverse, non_gc_inverse, fp_inverse)
      end
      handle GCHashTable.Lookup _    => crash "No GC inverse"
           | NonGCHashTable.Lookup _ => crash "No non GC inverse"
           | FPHashTable.Lookup _    => crash "No FP inverse"
    )



    (*  === BUILD MATRICES ===
     *
     *  This function constructs adjacency matrices for the three register
     *  types, and adds the cliques from the lists passed as parameter.
     *)

    fun build_matrices (gc, non_gc, fp) =
      let
        val gc_matrix     = Array.array (!nr_gc_regs, [])
        and non_gc_matrix = Array.array (!nr_non_gc_regs, [])
        and fp_matrix     = Array.array (!nr_fp_regs, [])
      in
        iterate (fn (defined, live) =>
                 clique gc_matrix (map GCHashTable.lookup defined,
                                   map GCHashTable.lookup live)) gc;
        iterate (fn (defined, live) =>
                 clique non_gc_matrix (map NonGCHashTable.lookup defined,
                                       map NonGCHashTable.lookup live)) non_gc;
        iterate (fn (defined, live) =>
                 clique fp_matrix (map FPHashTable.lookup defined,
                                   map FPHashTable.lookup live)) fp;
        (gc_matrix, non_gc_matrix, fp_matrix)
      end
      handle GCHashTable.Lookup reg =>
             crash (MirPrint.gc_register reg ^ " doesn't have a hash table entry.")
           | NonGCHashTable.Lookup reg => 
             crash (MirPrint.non_gc_register reg ^ " doesn't have a hash table entry.")
           | FPHashTable.Lookup reg => 
             crash (MirPrint.fp_register reg ^ " doesn't have a hash table entry.")



    (*  === COLOUR A MATRIX ===
     *
     *  To colour a matrix the matrix, an array of colours which could be
     *  used, an array to fill in with the colour assignments, and the
     *  number of vertices in the matrix are required.
     *
     *  The colouring algorithm is priority based.  The most connected
     *  vertex is coloured first, as it is likely to be the most difficult
     *  to colour, and perhaps the most used.  The algorithm is basically:
     *
     *  for each vertex in order of connectedness:
     *    make all colours and spill slots available
     *    for each neighbour of the vertex:
     *      make its colour or spill slot unavailable, if it has one
     *    find an available colour, or, failing that, a spill slot
     *    assign it to the vertex
     *)

    datatype 'a assignment = COLOUR of int | SPILL of int | UNASSIGNED | RESERVED of 'a

    fun colour (matrix, colours, assignments, nr_vertices) =
      let
        val nr_colours = Array.length colours
        val _ = diagnostic (3, fn _ => [Integer.makestring nr_colours, " colours"])
        val available = Array.array (nr_colours, true)
        val available_spill = Array.array (nr_vertices, true)
        val nr_spills = ref 0

        fun fill_array (array, value) =
          let
            fun fill 0 = ()
              | fill n =
                (Array.update (array, n-1, value);
                 fill (n-1))
          in
            fill (Array.length array)
          end

          (* Scan the neighbours of a vertex, disallowing their colours *)
          (* and spill slots. *)

          fun neighbours [] = ()
            | neighbours (vertex::vertices) =
              ((case Array.sub (assignments, vertex)
                  of COLOUR c => Array.update (available, c, false)
                   | SPILL s =>  Array.update (available_spill, s, false)
                   | RESERVED _ => ()
                   | UNASSIGEND  => ());
               neighbours vertices)

          fun find_spill 0 = crash "Couldn't find a spill slot."
            | find_spill n =
              let
                val spill = nr_vertices - n
              in
                if Array.sub (available_spill, spill) then
                (if spill >= (!nr_spills) then nr_spills := spill+1 else ();
                 SPILL spill)
                else find_spill (n-1)
              end

          fun find_colour 0 = find_spill nr_vertices
            | find_colour n =
              let
                val colour = nr_colours - n
              in
                if Array.sub (available, colour) then COLOUR colour
                else find_colour (n-1)
              end

        fun colour' [] = ()
          | colour' (vertex::vertices) =
            ((case Array.sub (assignments, vertex)
                of UNASSIGNED => 
                   (diagnostic (3, fn _ => ["clearing available array"]);
                    fill_array (available, true);
                    fill_array (available_spill, true);
                    diagnostic (3, fn _ => ["finding neigbours of ", Integer.makestring vertex]);
                    neighbours (Array.sub (matrix, vertex));
                    diagnostic (3, fn _ => ["finding free colour"]);
                    Array.update (assignments, vertex, find_colour nr_colours))
                 | _ => ());
             colour' vertices)

      in
        colour' (ordered_vertices matrix);
        !nr_spills
      end

d123 16
a138 6
    (*  === BUILD INITIAL ASSIGNMENT ARRAYS ===
     *
     *  This function build the assignment arrays for passing to the
     *  colouring function (above).  Some virtual registers are already
     *  assigned to real register aliases, so they are `precoloured' here.
     *)
a139 45
    fun initial_assignments () =
      let
        fun find (array, reg) =
          let
            fun find' 0 = RESERVED reg
              | find' n =
                if Array.sub (array, n-1) = reg then COLOUR (n-1)
                else find' (n-1)
          in
            find' (Array.length array)
          end
      in
        {gc_assignments =
            let
              val array = Array.array (!nr_gc_regs, UNASSIGNED)
              fun self reg =
                Array.update (array, GCHashTable.lookup reg, find (gc_colours, reg))
                handle GCHashTable.Lookup _ => ()
            in
              iterate self (MirTypes.GC.Pack.to_list (#gc MirRegisters.preassigned));
              array
            end,

          non_gc_assignments =
            let
              val array = Array.array (!nr_non_gc_regs, UNASSIGNED)
              fun self reg =
                Array.update (array, NonGCHashTable.lookup reg, find (non_gc_colours, reg))
                handle NonGCHashTable.Lookup _ => ()
            in
              iterate self (MirTypes.NonGC.Pack.to_list (#non_gc MirRegisters.preassigned));
              array
            end,

          fp_assignments =
            let
              val array = Array.array (!nr_fp_regs, UNASSIGNED)
              fun self reg =
                Array.update (array, FPHashTable.lookup reg, find (fp_colours, reg))
                handle FPHashTable.Lookup _ => ()
            in
              iterate self (MirTypes.FP.Pack.to_list (#fp MirRegisters.preassigned));
              array
            end}
      end
d152 1
a152 1
    fun substitute_block (gc_assignments, non_gc_assignments, fp_assignments)
d155 4
d193 11
a203 18
              let
                val reg_number = GCHashTable.lookup gc
              in
                case Array.sub(gc_assignments, reg_number)
                  of COLOUR c => Array.sub (gc_colours, c)
                   | RESERVED r => r
                   | SPILL s =>
                     let
                       val t = gc_temporary ()
                     in
                       (case direction
                          of IN  => loads  := STOREOP(LDREF, GC_REG t, frame, GP_IMM_SYMB(GC_SPILL_SLOT s)) :: (!loads)
                           | OUT => stores := STOREOP(STREF, GC_REG t, frame, GP_IMM_SYMB(GC_SPILL_SLOT s)) :: (!stores));
                       t
                     end
                   | UNASSIGNED => crash (MirPrint.gc_register gc ^ " hasn't been assigned a real register.")
              end
              handle GCHashTable.Lookup _ => gc
d206 11
a216 18
              let
                val reg_number = NonGCHashTable.lookup non_gc
              in
                case Array.sub(non_gc_assignments, reg_number)
                  of COLOUR c => Array.sub (non_gc_colours, c)
                   | RESERVED r => r
                   | SPILL s =>
                     let
                       val t = non_gc_temporary ()
                     in
                       (case direction
                          of IN  => loads  := STOREOP(LDREF, NON_GC_REG t, frame, GP_IMM_SYMB(NON_GC_SPILL_SLOT s)) :: (!loads)
                           | OUT => stores := STOREOP(STREF, NON_GC_REG t, frame, GP_IMM_SYMB(NON_GC_SPILL_SLOT s)) :: (!stores));
                       t
                     end
                   | UNASSIGNED => crash (MirPrint.non_gc_register non_gc ^ " hasn't been assigned a real register.")
              end
              handle NonGCHashTable.Lookup _ => non_gc
d219 11
a229 18
              let
                val reg_number = FPHashTable.lookup fp
              in
                case Array.sub(fp_assignments, reg_number)
                  of COLOUR c => FP_REG (Array.sub (fp_colours, c))
                   | RESERVED r => FP_REG r
                   | SPILL s =>
                     let
                       val t = fp_temporary ()
                     in
                       (case direction
                          of IN  => loads  := STOREFPOP(FLDREF, FP_REG t, frame, GP_IMM_SYMB(FP_SPILL_SLOT s)) :: (!loads)
                           | OUT => stores := STOREFPOP(FSTREF, FP_REG t, frame, GP_IMM_SYMB(FP_SPILL_SLOT s)) :: (!stores));
                       FP_REG t
                     end
                   | UNASSIGNED => crash (MirPrint.fp_register fp ^ " hasn't been assigned a real register.")
              end
              handle FPHashTable.Lookup _ => FP_REG fp
d349 2
a350 3
    fun analyse (procedure as MirProcedure.P (annotation, name,start, block_map),
                 {gc = gc_cliques, non_gc = non_gc_clique, fp = fp_cliques},
                 {gc = gc_hints, non_gc = non_gc_hints, fp = fp_hints}) =
d352 1
a352 1
        val _ = diagnostic (1, fn _ => ["procedure ", MirTypes.print_tag start])
d354 7
a360 5
        val cliques =
          Timer.xtime ("Cliques", !show_timings, fn () =>
            (map (fn (d,r) => (MirTypes.GC.Pack.to_list d,    MirTypes.GC.Pack.to_list r))    gc_cliques,
             map (fn (d,r) => (MirTypes.NonGC.Pack.to_list d, MirTypes.NonGC.Pack.to_list r)) non_gc_clique,
             map (fn (d,r) => (MirTypes.FP.Pack.to_list d,    MirTypes.FP.Pack.to_list r))    fp_cliques))
a361 79
        val hints = (gc_hints, non_gc_hints, fp_hints)

        val _ = diagnostic (2, fn _ => ["building register hash tables"])
        val (gc_inverse, non_gc_inverse, fp_inverse) =
          Timer.xtime ("Tables", !show_timings, fn () => build_tables (cliques, hints))

        val _ = diagnostic (2, fn _ => ["building clash matrices"])
        val (gc_matrix, non_gc_matrix, fp_matrix) =
          Timer.xtime ("Matrices", !show_timings, fn () => build_matrices cliques)

        val _ =
          let
            fun wibble a 0 = []
              | wibble a n =
                Integer.makestring (n-1) :: " is " :: MirPrint.gc_register (Array.sub (a, n-1)) :: "\n" ::
                (wibble a (n-1))
          in
            diagnostic(3, fn _ => "Register hashes:\n" :: (wibble gc_inverse (!nr_gc_regs)));
            diagnostic(3, fn _ => "Colour numbers:\n" :: (wibble gc_colours (Array.length gc_colours)))
          end

        val _ = diagnostic (2, fn _ => ["setting up initial assignments"])
        val {gc_assignments, non_gc_assignments, fp_assignments} = initial_assignments ()

        val (gc_spills, non_gc_spills, fp_spills) =
          Timer.xtime("Colouring", !show_timings, fn () =>
            ((diagnostic (2, fn _ => ["colouring GC registers"]);
              colour (gc_matrix, gc_colours, gc_assignments, !nr_gc_regs)),
             (diagnostic (2, fn _ => ["colouring Non GC registers"]);
              colour (non_gc_matrix, non_gc_colours, non_gc_assignments, !nr_non_gc_regs)),
             (diagnostic (2, fn _ => ["colouring FP registers"]);
              colour (fp_matrix, fp_colours, fp_assignments, !nr_fp_regs))))

        val _ = diagnostic (2, fn _ => ["working out which registers were used"])
        val registers_used =
          let
            fun used (assignments, colours, temporaries) =
              let
                fun used' (0, false, set) = set
                  | used' (0, true, set) = Set.union (set, Set.list_to_set temporaries)
                  | used' (n, spills, set) =
                    case Array.sub (assignments, n-1)
                      of COLOUR c   => used' (n-1, spills, Set.add_member (Array.sub (colours, c), set))
                       | RESERVED r => used' (n-1, spills, Set.add_member (r, set))
                       | SPILL s    => used' (n-1, true, set)
                       | UNASSIGNED => crash "There are still some unassigned registers."
              in
                used' (Array.length assignments, false, Set.empty_set)
              end
          in
            {gc     = used (gc_assignments, gc_colours, gc_temporaries),
             non_gc = used (non_gc_assignments, non_gc_colours, non_gc_temporaries),
             fp     = used (fp_assignments, fp_colours, fp_temporaries)}
          end

        val _ =
          let
            fun grunge assignments =
              let
                val length = Array.length assignments
                  
                fun wobble 0 = []
                  | wobble n =
                    MirPrint.gc_register (Array.sub (gc_inverse, n-1)) ::
                    " -> " ::
                    (case Array.sub (assignments, n-1)
                       of UNASSIGNED => "unassigned"
                        | RESERVED _ => "reserved"
                        | COLOUR c => MirPrint.gc_register (Array.sub (gc_colours, c))
                        | SPILL s => "spill " ^ Integer.makestring s) ::
                       "\n" ::
                       wobble (n-1)
              in
                wobble length
              end
          in
            diagnostic (3, fn _ => grunge gc_assignments)
          end

d365 1
a365 5
            MirProcedure.Map.from_list
            (fn (tag, tag') =>
             if tag=tag' then MirProcedure.Map.EQUAL else
               if MirTypes.order_tag (tag,tag') then MirProcedure.Map.LESS else
                 MirProcedure.Map.GREATER)
d367 1
a367 1
             (substitute_block (gc_assignments, non_gc_assignments, fp_assignments))
d374 8
a383 5
        (* Clear the hash tables so that their contents can be garbage collected. *)
        GCHashTable.clear ();
        NonGCHashTable.clear ();
        FPHashTable.clear ();

d389 1
a389 1
                                       registers_used = MirTypes.PRESENT registers_used,
d391 4
a394 4
                                       spill_sizes = MirTypes.PRESENT {gc = gc_spills, non_gc = non_gc_spills, fp = fp_spills}}},
        name,
        start,
        blocks)
@


1.38
log
@Removed `first' annotation from instructions.
@
text
@d20 3
d184 2
a185 2
      fun colour_array (colour_set, temporaries) =
        Array.arrayoflist (Lists.difference ((Set.set_to_list colour_set), temporaries))
d187 3
a189 3
      val gc_colours     = colour_array (#gc MirRegisters.general_purpose, gc_temporaries)
      val non_gc_colours = colour_array (#non_gc MirRegisters.general_purpose, non_gc_temporaries)
      val fp_colours     = colour_array (#fp MirRegisters.general_purpose, fp_temporaries)
d430 1
a430 1
              iterate self (Set.set_to_list (#gc MirRegisters.preassigned));
d441 1
a441 1
              iterate self (Set.set_to_list (#non_gc MirRegisters.preassigned));
d452 1
a452 1
              iterate self (Set.set_to_list (#fp MirRegisters.preassigned));
d645 6
a650 6
              MirProcedure.I ({defined      = {gc     = MirTypes.GC.Set.empty,
                                               non_gc = MirTypes.NonGC.Set.empty,
                                               fp     = MirTypes.FP.Set.empty},
                               referenced   = {gc     = MirTypes.GC.Set.empty,
                                               non_gc = MirTypes.NonGC.Set.empty,
                                               fp     = MirTypes.FP.Set.empty},
d658 6
a663 6
              MirProcedure.I ({defined      = {gc     = MirTypes.GC.Set.empty,
                                               non_gc = MirTypes.NonGC.Set.empty,
                                               fp     = MirTypes.FP.Set.empty},
                               referenced   = {gc     = MirTypes.GC.Set.empty,
                                               non_gc = MirTypes.NonGC.Set.empty,
                                               fp     = MirTypes.FP.Set.empty},
d690 3
a692 3
            (map (fn (d,r) => (MirTypes.GC.Set.to_list d,    MirTypes.GC.Set.to_list r))    gc_cliques,
             map (fn (d,r) => (MirTypes.NonGC.Set.to_list d, MirTypes.NonGC.Set.to_list r)) non_gc_clique,
             map (fn (d,r) => (MirTypes.FP.Set.to_list d,    MirTypes.FP.Set.to_list r))    fp_cliques))
d785 4
a788 1
        val {exits, uses_stack, parameters = MirTypes.PROC_PARAMS {leaf, stack_allocated, ...}} = annotation
d797 1
@


1.37
log
@Hints provided by the register preallocator are now used when building
the register hash tables to reduce the size of the matrices.
@
text
@d20 4
a647 3
                               first	    = {gc     = MirTypes.GC.Set.empty,
                                               non_gc = MirTypes.NonGC.Set.empty,
                                               fp     = MirTypes.FP.Set.empty},
a658 3
                                               non_gc = MirTypes.NonGC.Set.empty,
                                               fp     = MirTypes.FP.Set.empty},
                               first	    = {gc     = MirTypes.GC.Set.empty,
@


1.36
log
@Changed the adjacency matrix to an array of adjacency lists.  This
speeds up colouring for the sparse case (which is quite common) at the
slight cost of building the lists.  This is often a big win.
Added show_timings.
@
text
@d20 6
d190 6
a195 5
     *  is mapped onto a distinct integer by a hash table.  This integer is
     *  then used as a vertex index to the adjacency matrix.  The integers
     *  chosen are contiguous.  This function builds the hash tables from
     *  the lists of register cliques, and also stores number of registers
     *  the nr_*_regs reference cells.
d202 1
a202 1
    fun build_tables (gc, non_gc, fp) =
d211 9
d225 10
d240 10
d644 3
d660 3
d682 2
a683 1
                 {gc = gc_cliques, non_gc = non_gc_clique, fp = fp_cliques}) =
d693 2
d697 1
a697 1
          Timer.xtime ("Tables", !show_timings, fn () => build_tables cliques)
@


1.35
log
@First version of the profiler
@
text
@d11 5
a15 7
 *  The register colourer uses adjacency matrices to represent the clash
 *  graphs, and generates hash tables mapping virtual registers to
 *  contiguous integers to index the matrices.  A true in the matrix
 *  indicates that the registers clash and must be assigned a different
 *  colour (real register alias) or spill slot.  Colours and spill slots are
 *  allocated at the same time, and both are used as colours, so more than
 *  one value may share a spill slot if they do not clash.
d20 3
d58 1
d83 1
d101 2
a115 9
    fun alist_of_array array =
      let
        fun quenkzex (done, 0) = done
          | quenkzex (done, n) =
            quenkzex ((n-1, Array.sub (array, n-1))::done, n-1)
      in
        quenkzex ([], Array.length array)
      end

d121 1
a121 2

    (*  === ADJACENCY MATRIX ABSTRACT TYPE ===
d123 3
a125 9
     *  The adjacency matrix is used to represent the clash graph which is
     *  coloured in order to allocate the registers.  The matrix is stored
     *  as a single array whos (i,j)th element is stored at a position
     *  calculated by the function `index' (see below).  The function
     *  `clique' adds edges between a number of vertices, and the number of
     *  edges connected to each vertex is counted as this is done.  A list
     *  of vertices in descending order of connectedness is given by the
     *  function `ordered_vertices'.  The function `adjacent' tests the
     *  adjacency of two vertices.
d128 18
a145 3
    abstype matrix = MATRIX of {adjacent : bool Array.array, degree : int Array.array}
    with
      local
d147 5
a151 2
        fun index (small, large) = small + (large * (large-1)) div 2

d153 1
a153 42

        fun matrix size =
          (diagnostic (3, fn _ => ["Constructing matrix of size ", Integer.makestring size]);
           MATRIX {adjacent = Array.array (index(0, size), false),
                   degree   = Array.array (size, 0)})

        fun clique _ ([], _) = ()
          | clique (MATRIX {adjacent, degree}) (from, to) =
            let
              fun tangle [] = ()
                | tangle (edge::edges) =
                  let
                    fun weave [] = ()
                      | weave (edge'::edges') =
                        (Array.update (degree, edge, Array.sub (degree, edge)+1);
                         Array.update (degree, edge', Array.sub (degree, edge')+1);
                         if edge < edge' then Array.update (adjacent, index(edge, edge'), true)
                         else if edge > edge' then Array.update (adjacent, index(edge', edge), true)
                              else ();
                         weave edges')
                  in
                    weave to;
                    tangle edges
                  end
            in
              diagnostic (3, fn _ => "Adding clique" :: ((map (fn i => " " ^ Integer.makestring i) from) @@
                                                         " ->" :: (map (fn i => " " ^ Integer.makestring i) to)));
              tangle from
            end

        fun adjacent (MATRIX {adjacent, ...}, edge, edge') =
          if edge < edge' then Array.sub (adjacent, index (edge, edge'))
          else if edge > edge' then Array.sub (adjacent, index (edge', edge))
               else true

        fun ordered_vertices (MATRIX {degree, ...}) =
          let
            fun order ((_, degree), (_, degree')) = degree > degree'
          in
            map #1 (Lists.qsort order (alist_of_array degree))
          end

a154 1
    end
d247 3
a249 3
        val gc_matrix     = matrix (!nr_gc_regs)
        and non_gc_matrix = matrix (!nr_non_gc_regs)
        and fp_matrix     = matrix (!nr_fp_regs)
d309 2
a310 3
        fun colour' [] = ()
          | colour' (vertex::vertices) =
            let
d312 8
a319 1
              val _ = diagnostic (3, fn _ => ["colouring vertex ", Integer.makestring vertex])
d321 10
a330 2
              (* Scan the neighbours of a vertex, disallowing their colours *)
              (* and spill slots. *)
d332 8
a339 35
              fun neighbours 0 = ()
                | neighbours n =
                  (if adjacent (matrix, vertex, n-1) then
                     (diagnostic (3, fn _ => [Integer.makestring (n-1), " is a neigbour"]);
                      case Array.sub (assignments, n-1)
                        of COLOUR c =>
                           (diagnostic (3, fn _ => ["It has colour ", Integer.makestring c]);
                            Array.update (available, c, false))
                         | RESERVED _ => diagnostic (3, fn _ => ["It is reserved"])
                         | SPILL s =>
                           (diagnostic (3, fn _ => ["It is spilled to slot ", Integer.makestring s]);
                            Array.update (available_spill, s, false))
                         | UNASSIGNED => diagnostic (3, fn _ => ["It is unassigned"]))
                   else ();
                   neighbours (n-1))

              fun find_spill 0 = crash "Couldn't find a spill slot."
                | find_spill n =
                  let
                    val spill = nr_vertices - n
                  in
                    if Array.sub (available_spill, spill) then
                    (if spill >= (!nr_spills) then nr_spills := spill+1 else ();
                     SPILL spill)
                    else find_spill (n-1)
                  end
                  
              fun find_colour 0 = find_spill nr_vertices
                | find_colour n =
                  let
                    val colour = nr_colours - n
                  in
                    if Array.sub (available, colour) then COLOUR colour
                    else find_colour (n-1)
                  end
d341 3
a343 9
            in
              case Array.sub (assignments, vertex)

                   (* If a vertex has yet to be assigned, set the contents *)
                   (* of the available arrays to true then scan through the *)
                   (* neighbours making adjacent colours and spill slots *)
                   (* unavailable.  Then look through the available array to *)
                   (* find somewhere to put the register. *)

d349 1
a349 1
                    neighbours nr_vertices;
d352 2
a353 3
                 | _ => ();
              colour' vertices
            end
d643 1
d645 5
a649 3
          (map (fn (d,r) => (MirTypes.GC.Set.to_list d,    MirTypes.GC.Set.to_list r))    gc_cliques,
           map (fn (d,r) => (MirTypes.NonGC.Set.to_list d, MirTypes.NonGC.Set.to_list r)) non_gc_clique,
           map (fn (d,r) => (MirTypes.FP.Set.to_list d,    MirTypes.FP.Set.to_list r))    fp_cliques)
d651 3
a653 1
        val (gc_inverse, non_gc_inverse, fp_inverse) = build_tables cliques
d655 2
a656 1
        val (gc_matrix, non_gc_matrix, fp_matrix) = build_matrices cliques
d673 7
a679 6
          ((diagnostic (2, fn _ => ["colouring GC registers"]);
            colour (gc_matrix, gc_colours, gc_assignments, !nr_gc_regs)),
           (diagnostic (2, fn _ => ["colouring Non GC registers"]);
            colour (non_gc_matrix, non_gc_colours, non_gc_assignments, !nr_non_gc_regs)),
           (diagnostic (2, fn _ => ["colouring FP registers"]);
            colour (fp_matrix, fp_colours, fp_assignments, !nr_fp_regs)))
d729 9
a737 10
          MirProcedure.Map.from_list
          (fn (tag, tag') =>
           if tag=tag' then MirProcedure.Map.EQUAL else
             if MirTypes.order_tag (tag,tag') then MirProcedure.Map.LESS else
               MirProcedure.Map.GREATER)
          (map
           (substitute_block (gc_assignments, non_gc_assignments, fp_assignments))
           (MirProcedure.Map.to_list block_map))

        val _ = diagnostic (2, fn _ => ["done"])
@


1.34
log
@Removed obsolete Switches structure.
@
text
@d22 3
d650 1
d694 1
a694 1
    fun analyse (procedure as MirProcedure.P (annotation, start, block_map),
d803 3
a805 2
                        start,
                        blocks)
d809 3
@


1.33
log
@Removed a left-over diagnostic message.
@
text
@d22 3
a56 1
require "switches";
a66 1
  structure Switches		: SWITCHES
a93 1
    structure Switches = Switches
d784 1
a784 1
        val {exits, parameters = MirTypes.PROC_PARAMS {leaf, stack_allocated, ...}} = annotation
d793 1
@


1.32
log
@Changed to return an annotated procedure as well as taking one as
parameter.  This is to make it easier to pass the result to
the stack allocator.
@
text
@d22 5
d731 1
a731 2
                  | used' (0, true, set) =
                    (diagnostic (0, fn _ => ["adding in those temporaries"]); Set.union (set, Set.list_to_set temporaries))
@


1.31
log
@The functor now uses MirProcedure annotated procedures rather than the
MirOptTypes version.  It also takes the register clash lists as
parameters instead of working them out from the procedure annotations.
(They are now generated by MirVariable, see revision 1.29.)  Also, a
new assignment class, RESERVED, has been added to cope with reserved
registers more elegantly.
@
text
@d22 8
d74 1
a74 1
  sharing Set = MirTypes.Set = MirRegisters.Set = MirTables.Set
d473 1
a473 1
                         (tag, MirProcedure.B (_, instructions)) =
d475 1
a475 1
        fun substitute (opcodes, MirProcedure.I (_, opcode)) =
d647 25
a671 1
            val new_opcode = sub_op opcode
d673 1
a673 1
            ((!stores) @@ (new_opcode :: (!loads))) @@ opcodes
d676 1
a676 1
        MirTypes.BLOCK(tag, rev (Lists.reducel substitute ([], instructions)))
d685 1
a685 1
    fun analyse (procedure as MirProcedure.P ({parameters, ...}, start, block_map),
a766 2
        val MirTypes.PROC_PARAMS {leaf, stack_allocated, ...} = parameters

d769 8
a776 3
          map
          (substitute_block (gc_assignments, non_gc_assignments, fp_assignments))
          (MirProcedure.Map.to_list block_map)
d779 2
d783 1
a783 2
        (* Clear the hash tables so that their contents can be garbage *)
        (* collected. *)
d788 8
a795 8
        MirTypes.PROC(start,
                      MirTypes.PROC_PARAMS
                      {leaf =  leaf,
                       registers_used = MirTypes.PRESENT registers_used,
                       stack_allocated = stack_allocated,
                       spill_sizes = MirTypes.PRESENT {gc = gc_spills, non_gc = non_gc_spills, fp = fp_spills}},
                      blocks)

@


1.30
log
@Corrected spill slot counting.
@
text
@d22 3
d40 1
a40 1
require "miropttypes";
d50 1
a50 1
  structure MirOptTypes		: MIROPTTYPES
d65 6
a70 5
  sharing MirTypes = MirOptTypes.MirTypes = MirPrint.MirTypes = MirRegisters.MirTypes = MirTables.MirTypes
  sharing Set = MirTypes.Set = MirOptTypes.Set = MirRegisters.Set = MirTables.Set
  sharing type GCHashTable.Key = MirTypes.gc_register
  sharing type NonGCHashTable.Key = MirTypes.non_gc_register
  sharing type FPHashTable.Key = MirTypes.fp_register
d78 1
a78 1
    structure MirOptTypes = MirOptTypes
a199 48
    (*  === EXTRACT REGISTER CLIQUES FROM PROCEDURE ===
     *
     *  This function examines the register annotations of a procedure and
     *  produces a tuples of lists:
     *   ([(gc_defined, gc_live), ...], <same for non_gc>, <same for float>)
     *  Each tuple in the list is a list of registers defined plus a list of
     *  registers live at the time (i.e., the registers they clash with).
     *  Duplicates are not removed from the lists --- this will be done in
     *  an efficient way by the matrix building process later on.
     *)

    fun extract_registers procedure =
      let
        fun block cliques (MirOptTypes.BLOCK (_, opcodes)) =
          let
            fun opcode (_, (_, MirOptTypes.REGS_UNKNOWN, _)) =
                crash "I've been handed a procedure without live register annotation."
              | opcode ((gc, non_gc, fp), (code, MirOptTypes.REGS live, _)) =
                let
                  fun register ((gc, non_gc, fp), MirTypes.GC reg) =
                      if Set.is_member (reg, #gc MirRegisters.reserved) then (gc, non_gc, fp)
                      else (reg::gc, non_gc, fp)
                    | register ((gc, non_gc, fp), MirTypes.NON_GC reg) =
                      if Set.is_member (reg, #non_gc MirRegisters.reserved) then (gc, non_gc, fp)
                      else (gc, reg::non_gc, fp)
                    | register ((gc, non_gc, fp), MirTypes.FLOAT reg) =
                      if Set.is_member (reg, #fp MirRegisters.reserved) then (gc, non_gc, fp)
                      else (gc, non_gc, reg::fp)
                      
                  val (gc_live, non_gc_live, fp_live) =
                    Lists.reducel register (([], [], []), Set.set_to_list live)

                  val (gc_defined, non_gc_defined, fp_defined) =
                    Lists.reducel register (([], [], []), Set.set_to_list (MirTables.defined_by code))
                in
                  (if gc_defined = []     then gc     else (gc_defined, gc_live)::gc,
                   if non_gc_defined = [] then non_gc else (non_gc_defined, non_gc_live)::non_gc,
                   if fp_defined = []     then fp     else (fp_defined, fp_live)::fp)
                end
          in
            Lists.reducel opcode (cliques, opcodes)
          end
      in
        MirOptTypes.proc_fold block ([], [], []) procedure
      end



d239 3
a241 3
        val gc_inverse     = Array.array (!nr_gc_regs,     MirTypes.new_gc_register ())
        and non_gc_inverse = Array.array (!nr_non_gc_regs, MirTypes.new_non_gc_register ())
        and fp_inverse     = Array.array (!nr_fp_regs,     MirTypes.new_fp_register ())
d308 1
a308 1
    datatype assignment = COLOUR of int | SPILL of int | UNASSIGNED
d345 1
d409 9
a417 1
        exception Reserved
a421 9
              fun find reg =
                let
                  fun find' 0 = raise Reserved
                    | find' n =
                      if Array.sub (gc_colours, n-1) = reg then (n-1)
                      else find' (n-1)
                in
                  find' (Array.length gc_colours)
                end
d423 1
a423 1
                Array.update (array, GCHashTable.lookup reg, COLOUR (find reg))
a424 1
                     | Reserved => ()
a432 9
              fun find reg =
                let
                  fun find' 0 = raise Reserved
                    | find' n =
                      if Array.sub (non_gc_colours, n-1) = reg then (n-1)
                      else find' (n-1)
                in
                  find' (Array.length non_gc_colours)
                end
d434 1
a434 1
                Array.update (array, NonGCHashTable.lookup reg, COLOUR (find reg))
a435 1
                     | Reserved => ()
a443 9
              fun find reg =
                let
                  fun find' 0 = raise Reserved
                    | find' n =
                      if Array.sub (fp_colours, n-1) = reg then (n-1)
                      else find' (n-1)
                in
                  find' (Array.length fp_colours)
                end
d445 1
a445 1
                Array.update (array, FPHashTable.lookup reg, COLOUR (find reg))
a446 1
                     | Reserved => ()
d465 1
a465 1
                         (MirOptTypes.BLOCK(tag, triples)) =
d467 1
a467 1
        fun substitute (opcodes, (opcode, _, _)) =
d506 1
d526 1
d546 1
d644 1
a644 1
        MirTypes.BLOCK(tag, rev (Lists.reducel substitute ([], triples)))
d653 2
a654 1
    fun analyse (procedure as MirOptTypes.PROC(start_tag, _, _)) =
d656 5
a660 3
        val _ = diagnostic (1, fn _ => ["procedure ", MirTypes.print_tag start_tag])
        val _ = diagnostic (2, fn _ => ["extracting registers from procedure"])
        val cliques = extract_registers procedure
d694 2
a695 1
                  | used' (0, true, set) = Set.union (set, Set.list_to_set temporaries)
d698 3
a700 3
                      of COLOUR c =>
                         used' (n-1, spills, Set.add_member (Array.sub (colours, c), set))
                       | SPILL s => used' (n-1, true, set)
d723 1
a734 1
        val MirOptTypes.PROC (start_tag, parameters, _) = procedure
d741 1
a741 1
          (MirOptTypes.blocks procedure)
d746 2
a747 1
        (* Clear the hash tables so that they can be garbage collected. *)
d752 1
a752 1
        MirTypes.PROC(start_tag,
@


1.29
log
@Complete rewrite using imperative ML features to gain efficiency.
@
text
@d21 4
a24 1
 *  $Log$
d402 1
a402 1
                    (if spill > (!nr_spills) then nr_spills := spill else ();
@


1.28
log
@More than one register can now be spilled at once.
@
text
@d2 1
a2 1
 *            FUNCTOR
d8 2
a9 7
 *  The RegisterGraphs module is invoked to generate information about the
 *  use of registers in the procedure.  The interference graphs produced are
 *  then coloured with the real register aliases.  If this fails the Spill
 *  module is invoked to reduce the number of clashes of some register with
 *  the other registers and the whole process is tried again.  Once every
 *  virtual register has a real register assigned the procedure is rebuilt
 *  substituting the real register alaises.
d11 7
a17 3
 *  Notes
 *  -----
 *  It's all pretty inefficient really.
a18 6
 *  References
 *  ----------
 *  [1] Register Allocation & Spilling via Graph Coloring
 *      G J Chaitin
 *      Proc. of SIGPLAN '82 Symp. on Compiler Construction pp98-105
 *
d21 1
a21 105
 *  $Log: _registerallocator.sml,v $
 *  Revision 1.27  1992/01/10  16:44:04  richard
 *  Added a sensible error message for the exception NoMapping.
 *
 *  Revision 1.26  1991/12/04  12:05:52  richard
 *  Rewrote the register allocator to do incremental colouring and spilling
 *  rather than trying to allocate the registers in two sweeps.  This was
 *  a fundamentally incorrect algorithm.
 *
 *  Revision 1.25  91/11/29  14:48:29  richard
 *  Changed the register allocator to allocate from the set of
 *  general_purpose register rather than the complete set of
 *  registers.
 *  
 *  Revision 1.24  91/11/26  12:42:33  richard
 *  Reimplemented this module in terms of the InterferenceGraph module.
 *  
 *  Revision 1.23  91/11/19  15:37:36  richard
 *  Changed debugging output to use the Diagnostic module, which
 *  prevents the debugging output strings being constructed even
 *  if they aren't printed.
 *  
 *  Revision 1.22  91/11/14  10:45:25  richard
 *  Removed references to fp_double registers.
 *  
 *  Revision 1.21  91/11/07  11:36:18  richard
 *  Various changes to do with the interface to the Substitute module.
 *  
 *  Revision 1.20  91/10/25  15:14:35  richard
 *  Removed much code concerned with graph generation a new
 *  RegisterGraphs module, and tidied up the remainder.
 *  
 *  Revision 1.19  91/10/18  14:54:11  richard
 *  Added another graph to avoid sharing of registers which are used
 *  simultaneously.
 *  
 *  Revision 1.18  91/10/17  15:54:08  richard
 *  Uncoloured registers are now allocated real registers, but spill
 *  instructions are not yet generated, so the code is illegal in this
 *  case.
 *  
 *  Revision 1.17  91/10/16  16:10:24  richard
 *  Register colouring experimentation.
 *  
 *  Revision 1.16  91/10/16  12:12:12  richard
 *  Simplified some of the code involving records.
 *  Implemented forbidden colours (corrupted registers) around procedure
 *  calls.
 *  
 *  Revision 1.15  91/10/15  14:31:01  richard
 *  Converted tuples to records where possible. This makes the code
 *  much clearer. A lot of code which belongs elsewhere has been moved out
 *  to other modules.
 *  
 *  Revision 1.14  91/10/14  15:31:01  richard
 *  Changed the way preassigned registers are input into the colouring
 *  process so that they are not returned as used unless they really
 *  are used. Made first steps towards colouring around procedure calls.
 *  
 *  Revision 1.13  91/10/11  14:41:17  richard
 *  Added a rather hacked bit of code to pass out the sets of registers
 *  used by a procedure. Will fix this properly later.
 *  
 *  Revision 1.12  91/10/11  11:04:46  richard
 *  Slight alterations to cope with new MirTypes.
 *  
 *  Revision 1.11  91/10/10  14:48:33  richard
 *  Uses ordered lists of real registers rather than sets. The order
 *  indicates allocation preferences.
 *  
 *  Revision 1.9  91/10/10  10:12:36  richard
 *  Changed names of closure and argument registers. Not complete.
 *  
 *  Revision 1.8  91/10/08  15:24:45  richard
 *  Adapted allocator to use new version of the graph module which is more
 *  efficient when building graphs. Started work on spill allocation.
 *  
 *  Revision 1.7  91/10/07  16:23:09  richard
 *  Changed dependency on MachRegisters to MachSpec.
 *  
 *  Revision 1.6  91/10/04  13:02:22  richard
 *  Changed dependency on MachTypes to MachRegisters to remove target
 *  machine dependence. Other minor tidying.
 *  
 *  Revision 1.5  91/10/03  15:32:13  richard
 *  The virtual registers are now coloured with more virtual registers, which
 *  are then substituted in the procedure. Tables are returned with the
 *  modified code which map the new virtual registers on to real machine
 *  registers. The idea is that the code is still tractable by the other
 *  optimisation modules in this state.
 *  
 *  Revision 1.4  91/10/02  14:18:24  richard
 *  Included actual machine registers. Further development of register
 *  allocation including graphs for spill heuristics.
 *  
 *  Revision 1.3  91/10/01  15:41:31  richard
 *  Rewrote clash graph generator. It now generates separate graphs for the
 *  different types of registers. These will, after all, have to be assigned
 *  to differnt real registers.
 *  
 *  Revision 1.2  91/09/30  12:47:17  richard
 *  Simple register allocation within a single block.
 *  
 *  Revision 1.1  91/09/27  15:03:52  richard
 *  Initial revision
d24 1
a24 1
 
d26 1
a26 1
require "../utils/table";
d29 1
d31 1
a31 1
require "../utils/counter";
a32 1
require "mirregisters";
a33 1
require "mirtypes";
a34 1
require "spill";
d36 2
a37 4
require "registergraphs";
require "interferencegraph";
require "substitute";
require "registerclique";
a42 2
  structure RegisterGraphs	: REGISTERGRAPHS
  structure IGraph		: INTERFERENCEGRAPH
d45 2
a46 1
  structure MirPrint		: MIRPRINT
d49 1
a49 2
  structure RegisterClique	: REGISTERCLIQUE
  structure Spill		: SPILL
a50 1
  structure Table		: TABLE
d53 3
d57 1
a57 2
  structure Switches		: SWITCHES
  structure Diagnostic		: DIAGNOSTIC
d59 6
a64 8
  sharing MirTypes =
    MirOptTypes.MirTypes =
    MirPrint.MirTypes =
    MirRegisters.MirTypes =
    MirTables.MirTypes =
    Spill.MirTypes =
    RegisterGraphs.MirTypes =
    RegisterClique.MirTypes
a65 21
  sharing Set =
    MirOptTypes.Set = 
    MirTypes.Set =
    MirRegisters.Set =
    RegisterGraphs.Set

  sharing Table =
    MirTables.Table

  sharing Array =
    IGraph.Array

  sharing MirOptTypes =
    RegisterGraphs.MirOptTypes =
    RegisterClique.MirOptTypes =
    Spill.MirOptTypes

  sharing IGraph =
    RegisterGraphs.InterferenceGraph =
    Spill.InterferenceGraph

d68 1
a68 1
struct
d70 4
a73 4
  structure MirOptTypes = MirOptTypes
  structure MirTypes = MirTypes
  structure Switches = Switches
  structure Diagnostic = Diagnostic
d76 1
a76 1
  (*  == Diagnostic output ==  *)
d78 3
a80 4
  fun diagnostic (level, output_function) =
    Diagnostic.output level
    (fn verbosity =>
     "MirOptimiser (RegAlloc): " :: (output_function verbosity))
d82 2
a83 11
  fun diagnostic_graphs (message, RegisterGraphs.GRAPHS {gc, non_gc, fp}) =
    (diagnostic (4, fn _ =>
		 ["\n  GC ", message, ": "] @@
		 (IGraph.strings_of_graph_lists MirPrint.gc_register gc));
     diagnostic (4, fn _ =>
		 ["\n  NON_GC ", message, ": "] @@
		 (IGraph.strings_of_graph_lists
		  MirPrint.non_gc_register non_gc));
     diagnostic (4, fn _ =>
		 ["\n  FP ", message, ": "] @@
		 (IGraph.strings_of_graph_lists MirPrint.fp_register fp)))
d85 2
a86 14
  fun diagnostic_assignments (message, {gc, non_gc, fp}) =
    let
      fun p (message', printer, assigned) =
	diagnostic (3, fn _ => [message, " ", message', "\n  assigned:"] @@
		    (map
		     (fn (virtual,real) =>
		      "\n    " ^ printer virtual ^
		      " := " ^ printer real)
		     assigned))
    in
      p ("GC:", MirPrint.gc_register, gc);
      p ("NON_GC:", MirPrint.non_gc_register, non_gc);
      p ("FP:", MirPrint.fp_register, fp)
    end
d88 8
a95 9
  fun diagnostic_sharers {gc, non_gc, fp} =
    let
      fun p (printer, message, list) =
	diagnostic (3, fn _ => message :: map (fn r => " " ^ printer r) list)
    in
      p (MirPrint.gc_register, "GC sharers", gc);
      p (MirPrint.non_gc_register, "NON_GC sharers", non_gc);
      p (MirPrint.fp_register, "FP sharers", fp)
    end
d97 3
a101 1
  (*  === MISCELLANEOUS DATA ===  *)
d103 12
d116 3
a118 7
  (*  == Precolours ==
   *
   *  The precolours are fed to the graph colourer to ensure that the
   *  preassigned registers are mapped onto themselves. They will then
   *  be correctly mapped onto their preassigned machine registers by
   *  the assignment tables in MirRegisters.
   *)
d120 1
a120 9
  val precolours =
    let
      val self_alist =
	(map (fn virtual => (virtual, virtual))) o Set.set_to_list
    in
      {gc	= self_alist (#gc MirRegisters.preassigned),
       non_gc	= self_alist (#non_gc MirRegisters.preassigned),
       fp	= self_alist (#fp MirRegisters.preassigned)}
    end
d122 1
d124 4
a127 4
  (*  == A handy type resolver ==
   *
   *  Useful for resoving flex records.
   *)
d129 23
a151 17
  fun resolve_record {gc, non_gc, fp} = ()


  (*  == Table Specifications ==
   *
   *  Useful shorthand for parameters to Table.
   *)

  local
    open Table
    open MirTypes
  in
    val tablespec =
      {gc	   = TableSpec {order = order_gc_register, eq = op=},
       non_gc	   = TableSpec {order = order_non_gc_register, eq = op=},
       fp	   = TableSpec {order = order_fp_register, eq = op=}}
  end
d153 4
d158 6
d165 2
a166 14
  (*  === COLOUR CHOOSER ===
   *
   *  The colour chooser is called by the graph colourer to decide which
   *  colour (real register alias) to assign to each vertex (virtual
   *  register).  A decision made here can affect the rest of the colouring
   *  process, and so the choice should be carefully made.  If the chooser
   *  fails to colour a vertex it raises the exception NoColouring.
   *
   *  NOTES:
   *    1.  At the moment the first colour not adjacent to the vertex is
   *        chosen.  This is not very intelligent: register use should be
   *        spread across as many registers as possible without spilling,
   *        or, on the SPARC, causing a register window save if unnecessary.
   *)
a167 1
  exception NoColouring of MirTypes.any_register
a168 3
  fun choose_from {available, live_across_calls, corrupted_by_callee, cons}
                  {vertex, state, adjacent, length} =
    let
d170 7
a176 1
      (* Is a colour in the adjacent array? *)
d178 3
a180 14
      fun in_adjacent colour =
	let
	  fun found 0 = false
	    | found n =
	      case Array.sub (adjacent, length-n)
		of IGraph.COLOUR colour' =>
		   colour = colour' orelse found (n-1)
		 | _ => 
		   Crash.impossible
		   ("MirOptimiser (RegAlloc): Empty slot in adjacent " ^
		    "colour array.")
	in
	  found length
	end
d182 3
a184 12
      (* Find the first colour not adjacent and not corruptible if the *)
      (* register is live across calls. *)

      fun find_not_adjacent [] = raise NoColouring (cons vertex)
	| find_not_adjacent (colour::colours) =
	  if in_adjacent colour then
	    find_not_adjacent colours
	  else if (Set.is_member (vertex, live_across_calls) andalso
		   Set.is_member (colour, corrupted_by_callee)) then
	    find_not_adjacent colours
	  else
	    IGraph.COLOUR colour
d186 3
a188 1
      (find_not_adjacent (Set.set_to_list available), ())
d193 10
a202 7
  (*  === COLOUR CLASH GRAPHS USING ALIAS REGISTERS ===
   *
   *  Calls Graph.colour on each of the clash graphs, and then merges
   *  the preassigned registers to the assignments generated. The
   *  preassigned registers are always mapped to themselves, not to
   *  alias registers.
   *)
d204 20
a223 6
  fun colour_graphs {live = RegisterGraphs.GRAPHS live,
		     precolours,
		     live_across_calls =
		       RegisterGraphs.SETS live_across_calls} =
    let
      val _ = resolve_record precolours
d225 13
a237 1
      val _ = diagnostic (2, fn _ => ["colouring GC graph"])
a238 19
      val gc_assigned =
	let
	  val choose =
	    choose_from
	    {available = #gc MirRegisters.general_purpose,
	     live_across_calls = #gc live_across_calls,
	     corrupted_by_callee = #gc MirRegisters.corrupted_by_callee,
	     cons = MirTypes.GC}
	in
	  case IGraph.colour {graph   = #gc live,
			      colours = #gc precolours,
			      choose  = choose,
			      state   = ()}
	    of (assigned, []) => assigned
	     | _ => 
	       Crash.impossible
	       ("MirOptimiser (RegAlloc): The colouring algorithm failed "^
		"to colour all the GC registers or raise an exception.")
	end
a239 1
      val _ = diagnostic (2, fn _ => ["colouring NON_GC graph"])
d241 9
a249 19
      val non_gc_assigned =
	let
	  val choose =
	    choose_from
	    {available = #non_gc MirRegisters.general_purpose,
	     live_across_calls = #non_gc live_across_calls,
	     corrupted_by_callee = #non_gc MirRegisters.corrupted_by_callee,
	     cons = MirTypes.NON_GC}
	in
	  case IGraph.colour {graph   = #non_gc live,
			      colours = #non_gc precolours,
			      choose  = choose,
			      state   = ()}
	    of (assigned, []) => assigned
	     | _ => 
	       Crash.impossible
	       ("MirOptimiser (RegAlloc): The colouring algorithm failed "^
		"to colour all the NON_GC registers or raise an exception.")
	end
d251 3
a253 1
      val _ = diagnostic (2, fn _ => ["colouring FP graph"])
d255 8
a262 19
      val fp_assigned =
	let
	  val choose =
	    choose_from
	    {available = #fp MirRegisters.general_purpose,
	     live_across_calls = #fp live_across_calls,
	     corrupted_by_callee = #fp MirRegisters.corrupted_by_callee,
	     cons = MirTypes.FLOAT}
	in
	  case IGraph.colour {graph   = #fp live,
			      colours = #fp precolours,
			      choose  = choose,
			      state   = ()}
	    of (assigned, []) => assigned
	     | _ => 
	       Crash.impossible
	       ("MirOptimiser (RegAlloc): The colouring algorithm failed "^
		"to colour all the FLOAT registers or raise an exception.")
	end
d264 32
a295 1
    in
a296 3
      {gc = gc_assigned,
       non_gc = non_gc_assigned,
       fp = fp_assigned}
a297 1
    end
d299 5
d305 23
a328 6
  (*  === SPILL REGISTERS IN PROCEDURE ===
   *
   *  This function spills some registers in a given procedure, updating the
   *  graphs as it does so.  It also removes the spilled registers from the
   *  live_across_calls sets.
   *)
a329 4
  fun spill {graphs = RegisterGraphs.GRAPHS record,
             live_across_calls = RegisterGraphs.SETS live_across_calls,
             registers, procedure} =
    let
d331 17
a347 2
      val _ = diagnostic (2, fn _ => "spilling" ::
                          (map (fn r => " " ^ MirPrint.any_reg r) registers))
d349 1
a349 2
      (* The chosen register will not be live across any calls once it is *)
      (* spilled, so remove it from the live_across_calls sets. *)
d351 7
a357 16
      val live_across_calls' =
        let
          fun partition (gc, non_gc, fp, []) = {gc = gc, non_gc = non_gc, fp = fp}
            | partition (gc, non_gc, fp, (MirTypes.GC register)::registers) =
              partition (register::gc, non_gc, fp, registers)
            | partition (gc, non_gc, fp, (MirTypes.NON_GC register)::registers) =
              partition (gc, register::non_gc, fp, registers)
            | partition (gc, non_gc, fp, (MirTypes.FLOAT register)::registers) =
              partition (gc, non_gc, register::fp, registers)
              
          val register_lists = partition ([], [], [], registers)
        in
          {gc     = Set.setdiff (#gc live_across_calls, Set.list_to_set (#gc register_lists)),
           non_gc = Set.setdiff (#non_gc live_across_calls, Set.list_to_set (#non_gc register_lists)),
           fp     = Set.setdiff (#fp live_across_calls, Set.list_to_set (#fp register_lists))}
        end
d359 9
a367 1
      (* NOTE: the following instruction updates the graphs. *)
d369 3
a371 4
      val procedure' = Spill.insert_spill_code {live = record,
                                                procedure = procedure,
                                                registers = registers}
    in
d373 1
a373 2
      {live_across_calls = RegisterGraphs.SETS live_across_calls',
       procedure = procedure'}
d375 2
a376 1
    end
d378 14
d393 19
d413 2
d416 5
a420 9
  (*  === ITERATIVE REGISTER COLOURING ===
   *
   *  This function attempts to assign real registers to virtual registers
   *  by colouring the graph produced by running RegisterGraphs.generate
   *  over a procedure.  If this fails it decides which register to spill
   *  and spills it.  The Spill module modifies the graph, making it easier
   *  to colour, and another attempt is made.  This process continues until
   *  a colouring is found.
   *)
d422 11
a432 2
  fun iterate_colour {precolours, graphs, live_across_calls,
		      procedure, unspilled} =
d434 4
a437 4
    (colour_graphs {live = graphs,
		    precolours = precolours,
		    live_across_calls = live_across_calls},
     procedure)
a438 2
    handle NoColouring register =>
      let
d440 6
a445 2
	val _ = diagnostic (2, fn _ => ["failed to colour ",
					MirPrint.any_reg register])
d447 24
a470 1
	(* Choose a register to spill. *)
d472 20
a491 7
	val (new_spill, unspilled') =
	  case unspilled
	    of spill::unspilled' => (spill, unspilled')
	     | _ => 
	       Crash.impossible
	       ("MirOptimiser (RegAlloc): I've run out of register to "^
		"spill and _still_ can't find a colouring!")
d493 21
a513 1
        (* NOTE: the following instruction updates the graphs. *)
a514 4
        val {live_across_calls = live_across_calls',
             procedure = procedure'} =
          spill {graphs = graphs, live_across_calls = live_across_calls,
                 registers = [new_spill], procedure = procedure}
d516 9
a524 1
      in
d526 6
a531 5
	iterate_colour {precolours = precolours,
			graphs = graphs,
			live_across_calls = live_across_calls',
			procedure = procedure',
			unspilled = unspilled'}
d533 2
a534 1
      end
d536 3
d540 1
a540 1
  (*  === ANALYSE AND ASSIGN REGISTERS FOR A PROCEDURE ===  *)
d542 5
a546 2
  fun analyse (procedure as MirOptTypes.PROC(start_tag, _, _)) =
    let
d548 5
a552 2
      val _ = diagnostic (1, fn _ => ["procedure ",
				      MirTypes.print_tag start_tag])
d554 5
a558 2
      (* Build interference graphs, inter alia, from the live variable *)
      (* information. *)
d560 1
a560 1
      val _ = diagnostic (2, fn _ => ["building graphs"])
d562 18
a579 2
      val {live, live_across_calls, registers_used} =
	RegisterGraphs.generate procedure
d581 18
a598 1
      val _ = diagnostic_graphs ("live graph", live)
d600 18
a617 16
      val procedure_with_empty_spill_areas =
	let
	  val MirOptTypes.PROC
	      (start_tag,
	       MirTypes.PROC_PARAMS
	       {leaf, registers_used, stack_allocated, ...},
	       blocks) = procedure
	in
	  MirOptTypes.PROC
	  (start_tag,
	   MirTypes.PROC_PARAMS
	   {leaf = leaf, registers_used = registers_used,
	    stack_allocated = stack_allocated,
	    spill_sizes = MirTypes.PRESENT {gc = 0, non_gc = 0, fp = 0}},
	   blocks)
	end
d619 3
a621 3
      (* Intersect the sets of precoloured virtual registers with the *)
      (* sets of registers actually used in the procedure, so that only *)
      (* they are mentioned. *)
d623 2
a624 9
      val precolours =
	let
	  val RegisterGraphs.SETS used = registers_used
	  fun filter used (virtual, alias) = Set.is_member (virtual, used)
	in
	  {gc     = Lists.filterp (filter (#gc used)) (#gc precolours),
	   non_gc = Lists.filterp (filter (#non_gc used)) (#non_gc precolours),
	   fp     = Lists.filterp (filter (#fp used)) (#fp precolours)}
	end
d626 71
a696 1
      (* Construct a list of registers which could possibly be spilled. *)
d698 7
a704 3
      val spillable =
	let
	  val RegisterGraphs.SETS {gc, non_gc, fp} = registers_used
a705 7
	  val used =
	    (map MirTypes.GC (Set.set_to_list gc)) @@
	    (map MirTypes.NON_GC (Set.set_to_list non_gc)) @@
	    (map MirTypes.FLOAT (Set.set_to_list fp))
	in
	  Lists.difference (used, [MirTypes.GC MirRegisters.fp])
	end
d707 4
a710 2
      (* Perform an initial pass over the procedure to discover register *)
      (* cliques, and try to eliminate them. *)
d712 9
a720 9
      val {live_across_calls, procedure = procedure_without_cliques} =
        let
          val clique_regs = RegisterClique.find procedure_with_empty_spill_areas
        in
          spill {procedure = procedure_with_empty_spill_areas,
                 graphs = live,
                 live_across_calls = live_across_calls,
                 registers = clique_regs}
        end
d722 10
a731 2
      (* Colour the graphs, assigning all of the registers to real *)
      (* register aliases, spilling registers if necessary. *)
d733 2
a734 6
      val (assigned, procedure_with_spills) =
	iterate_colour {procedure = procedure_without_cliques,
			precolours = precolours,
			graphs = live,
			live_across_calls = live_across_calls,
			unspilled = spillable}
d736 7
a742 1
      val _ = diagnostic_assignments ("assignments of ", assigned)
d744 21
a764 2
      (* Insert the used register information into the procedure *)
      (* parameters, and set up empty spill areas. *)
d766 22
a787 18
      val procedure_with_params =
	let
	  val MirOptTypes.PROC
	      (start_tag,
	       MirTypes.PROC_PARAMS {leaf, spill_sizes, stack_allocated, ...},
	       blocks) = procedure_with_spills
	in
	  MirOptTypes.PROC
	  (start_tag,
	   MirTypes.PROC_PARAMS
	   {leaf = leaf, spill_sizes = spill_sizes,
	    stack_allocated = stack_allocated,
	    registers_used = MirTypes.PRESENT
	    {gc     = Set.list_to_set (map #2 (#gc assigned)),
	     non_gc = Set.list_to_set (map #2 (#non_gc assigned)),
	     fp     = Set.list_to_set (map #2 (#fp assigned))}},
	   blocks)
	end
d789 2
a790 7
      (* Build tables for the register substitution. *)
    
      val tables =
	{gc = Table.table_of_alist (#gc assigned, #gc tablespec),
	 non_gc = Table.table_of_alist (#non_gc assigned,
					#non_gc tablespec),
	 fp = Table.table_of_alist (#fp assigned, #fp tablespec)}
d792 5
a796 1
    in
d798 2
a799 2
      (* Substitute the real register aliases for the virtual registers *)
      (* in the procedure. *)
d801 4
a804 7
      MirOptTypes.proc_map
      (MirOptTypes.block_map
       (fn (opcode, registers, successors) =>
	(MirTables.substitute_registers tables opcode,
	 registers,
	 successors)))
      procedure_with_params
d806 7
a812 4
      handle MirTables.NoMapping reg =>
        Crash.impossible
        ("MirOptimiser (RegAlloc): Virtual register " ^ MirPrint.any_reg reg ^
         " has not been assigned to a real register.")
d814 1
a814 1
    end
d816 1
a816 3


end
@


1.27
log
@Added a sensible error message for the exception NoMapping.
@
text
@d18 1
a18 3
 *  At the moment the first register that is not coloured is the one which
 *  is spilled.  In fact, the `least used' (according to some measure)
 *  should be spilled.
d29 3
d152 1
d165 1
d181 2
a182 1
    RegisterGraphs.MirTypes
d198 1
d455 50
d531 1
a531 1
	val (spill, unspilled') =
a538 26
	val _ = diagnostic (2, fn _ => ["spilling ",
					MirPrint.any_reg register])

	(* The chosen register will not be live across any calls once it is *)
	(* spilled, so remove it from the live_across_calls sets. *)

	val live_across_calls' =
	  let
	    val RegisterGraphs.SETS sets = live_across_calls
	  in
	    RegisterGraphs.SETS
	    (case spill
	       of MirTypes.GC register =>
		 {gc = Set.setdiff (#gc sets, Set.singleton register),
		  non_gc = #non_gc sets,
		  fp = #fp sets}
		| MirTypes.NON_GC register =>
		  {gc = #gc sets,
		   non_gc = Set.setdiff (#non_gc sets, Set.singleton register),
		   fp = #fp sets}
		| MirTypes.FLOAT register => 
		  {gc = #gc sets,
		   non_gc = #non_gc sets,
		   fp = Set.setdiff (#fp sets, Set.singleton register)})
	  end

d541 4
a544 8
	val procedure' =
	  let
	    val RegisterGraphs.GRAPHS record = graphs
	  in
	    Spill.insert_spill_code {live = record,
				     procedure = procedure,
				     register = spill}
	  end
d550 1
a550 1
			live_across_calls = live_across_calls,
d557 1
a557 3
  (*  === ANALYSE AND ASSIGN REGISTERS FOR A PROCEDURE ===
   *
   *)
d620 13
d637 1
a637 1
	iterate_colour {procedure = procedure_with_empty_spill_areas,
@


1.26
log
@Rewrote the register allocator to do incremental colouring and spilling
rather than trying to allocate the registers in two sweeps.  This was
a fundamentally incorrect algorithm.
@
text
@d30 6
a35 1
 *  $Log:	_registerallocator.sml,v $
d651 5
@


1.25
log
@Changed the register allocator to allocate from the set of
general_purpose register rather than the complete set of
registers.
@
text
@d10 5
a14 4
 *  then coloured with the real register aliases, and any uncoloured
 *  registers are assigned to share with other registers.  The Substitute
 *  module is then invoked to build the new procedure using the aliases and
 *  insert any spill code necessary.
d16 5
a20 11
 *  Notes for future work
 *  ---------------------
 *  At present uncoloured registers are assigned to share the same real
 *  register for all time, and this decision is made by a separate function
 *  (`assign_uncoloured') after the colouring process, and it is left up to
 *  the Substitute module to produce the appropriate spill code.  A much
 *  better way to do this would be to give up colouring as soon as a vertex
 *  cannot be coloured, insert spill code for some vertex, then try to
 *  colour again.  The spill code could then make free use of virtual
 *  registers with short lifetimes, and a better overall colouring would be
 *  acheived.  See [1].
d22 2
d31 5
d141 1
a152 1
  structure Substitute		: SUBSTITUTE
d158 1
d160 1
d170 1
a170 1
    MirRegisters.MirTypes = 
d172 2
a173 2
    RegisterGraphs.MirTypes =
    Substitute.MirTypes
d181 3
a186 3
  sharing MirTypes =
    RegisterGraphs.MirTypes

d189 1
a189 1
    Substitute.MirOptTypes
d192 2
a193 1
    RegisterGraphs.InterferenceGraph
d281 4
d286 12
d303 2
a304 1
   *  process, and so the choice should be carefully made.
d307 1
a307 6
   *
   *    1.  The frame pointer is NEVER assigned, as it is used to access the
   *        register spill areas.  The frame pointer is only ever
   *        preassigned by the tables in MirRegisters.
   *
   *    2.  At the moment the first colour not adjacent to the vertex is
d313 3
a315 1
  fun choose_from {available, live_across_calls, corrupted_by_callee}
d339 1
a339 1
      fun find_not_adjacent [] = IGraph.NONE
d371 1
a371 1
      val (gc_assigned, gc_unassigned) =
d377 2
a378 1
	     corrupted_by_callee = #gc MirRegisters.corrupted_by_callee}
d380 9
a388 5
	  IGraph.colour
	  {graph   = #gc live,
	   colours = #gc precolours,
	   choose  = choose,
	   state   = ()}
d393 1
a393 1
      val (non_gc_assigned, non_gc_unassigned) =
d399 2
a400 1
	     corrupted_by_callee = #non_gc MirRegisters.corrupted_by_callee}
d402 9
a410 5
	  IGraph.colour
	  {graph   = #non_gc live,
	   colours = #non_gc precolours,
	   choose  = choose,
	   state   = ()}
d415 1
a415 1
      val (fp_assigned, fp_unassigned) =
d421 2
a422 1
	     corrupted_by_callee = #fp MirRegisters.corrupted_by_callee}
d424 9
a432 5
	  IGraph.colour
	  {graph   = #fp live,
	   colours = #fp precolours,
	   choose  = choose,
	   state   = ()}
d437 3
a439 6
      {assigned = {gc = gc_assigned,
		   non_gc = non_gc_assigned,
		   fp = fp_assigned},
       unassigned = {gc = gc_unassigned,
		     non_gc = non_gc_unassigned,
		     fp = fp_unassigned}}
d445 1
a445 1
  (*  === ASSIGN UNCOLOURED REGISTERS ===
d447 6
a452 10
   *  Registers which cannot be coloured in the live graph are assigned to
   *  the same alias as some other virtual register.
   *
   *  This function also calculates lists of virtual registers which share
   *  the same real register and which are live at the same time.  These are
   *  the registers for which spill code will have to be inserted.
   *
   *  The restrictions on registers corrupted across procedure calls are
   *  also lifted.  The Substitute module will insert the necessary PUSH and
   *  POP instructions.
d455 2
a456 4
  fun assign_uncoloured {assigned, unassigned, used} =
    let
      val _ = resolve_record assigned
      val _ = resolve_record unassigned
d458 4
a461 6
      (* Colour the `used' graph with the real register assignments.  This *)
      (* graph should never be constraining enough that all the registers *)
      (* can be coloured --- it only records which registers are used *)
      (* simultaneously.  Note that the registers already assigned by the *)
      (* first colouring are passed to the colourer here so that they retain *)
      (* their assigments. *)
d463 2
a464 14
      val assigned =
	case colour_graphs {live = used,
			    precolours = assigned,
			    live_across_calls =
			    RegisterGraphs.SETS
			    {gc = Set.empty_set,
			     non_gc = Set.empty_set,
			     fp = Set.empty_set}}
	  of {assigned, unassigned = {gc = [], non_gc = [], fp = []}} =>
	     assigned
	   | _ => 
	     Crash.impossible
	     ("MirOptimiser (RegAlloc): The second colouring pass failed "^
	      "to assign all the registers.")
d466 2
a467 2
      (* Find the list of registers which share the same real register while *)
      (* live. *)
d469 1
a469 13
      fun find_sharers (previously_unassigned, assigned) =
	let
	  val shared_real =
	    map #2 (Lists.filterp
		    (fn (virtual, _) =>
		     Lists.member (virtual, previously_unassigned))
		    assigned)
	in
	  map #1 (Lists.filterp
		  (fn (_, real) =>
		   Lists.member (real, shared_real))
		  assigned)
	end
d471 7
a477 5
      val sharers =
	{gc     = find_sharers (#gc unassigned, #gc assigned),
	 non_gc = find_sharers (#non_gc unassigned, #non_gc assigned),
	 fp     = find_sharers (#fp unassigned, #fp assigned)}
    in
d479 2
a480 2
      {assigned = assigned,
       sharers = sharers}
d482 2
a483 1
    end
d485 19
d505 1
d507 20
d537 2
a538 1
      (* Generate the various graphs for the procedure *)
d540 3
a542 1
      val {live, used, live_across_calls, registers_used} =
a545 1
      val _ = diagnostic_graphs ("used graph", used)
d547 16
a562 3
      (* Intersect the sets of precoloured virtual registers with the sets *)
      (* of registers actually used in the procedure, so that only they are *)
      (* mentioned. *)
d564 4
d578 1
a578 2
      (* Colour the graphs, assigning the main bulk of the registers *)
      (* to real register aliases. *)
d580 3
a582 4
      val {assigned, unassigned} =
	colour_graphs {live = live,
		       precolours = precolours,
		       live_across_calls = live_across_calls}
d584 7
a590 1
      val _ = diagnostic_assignments ("first assignments of ", assigned)
d592 2
a593 2
      (* Assign any registers which are left over, sharing the real *)
      (* register aliases between virtual registers. *)
d595 6
a600 4
      val {assigned, sharers} =
	assign_uncoloured {assigned = assigned,
			   unassigned = unassigned,
			   used = used}
d602 1
a602 2
      val _ = diagnostic_assignments ("final assignments of ", assigned)
      val _ = diagnostic_sharers sharers
d604 2
a605 1
      val MirOptTypes.PROC(start_tag, params, new_blocks) = procedure
d607 1
a607 1
      val new_params =
d609 4
a612 2
	  val MirTypes.PROC_PARAMS
	      {leaf, spill_sizes, stack_allocated, ...} = params
d614 10
a623 8
	  MirTypes.PROC_PARAMS
	  {leaf = leaf,
	   registers_used = MirTypes.PRESENT
	   {gc = Set.list_to_set (map #2 (#gc assigned)),
	    non_gc = Set.list_to_set (map #2 (#non_gc assigned)),
	    fp = Set.list_to_set (map #2 (#fp assigned))},
	   spill_sizes = spill_sizes,
	   stack_allocated = stack_allocated}
d626 7
a632 1
      val new_procedure = MirOptTypes.PROC(start_tag, new_params, new_blocks)
d636 2
a637 2
      Substitute.substitute {assigned = assigned,
			     sharers = sharers} new_procedure
d639 8
d648 1
@


1.24
log
@Reimplemented this module in terms of the InterferenceGraph module.
@
text
@d34 3
d259 2
a260 1
      val self_alist = map (fn (virtual,real) => (virtual,virtual))
d284 10
a293 2
   *  At the moment the first colour not adjacent to the vertex is chosen.
   *  This is not very intelligent.
d330 1
a330 1
      (find_not_adjacent available, ())
d356 1
a356 1
	    {available = #gc MirRegisters.machine_register_aliases,
d373 1
a373 1
	    {available = #non_gc MirRegisters.machine_register_aliases,
d390 1
a390 1
	    {available = #fp MirRegisters.machine_register_aliases,
d501 1
@


1.23
log
@Changed debugging output to use the Diagnostic module, which
prevents the debugging output strings being constructed even
if they aren't printed.
@
text
@d1 122
a122 1
(* registerallocator.sml the functor *)
d124 1
a124 88
(* $Log:	_registerallocator.sml,v $
Revision 1.22  91/11/14  10:45:25  richard
Removed references to fp_double registers.

Revision 1.21  91/11/07  11:36:18  richard
Various changes to do with the interface to the Substitute module.

Revision 1.20  91/10/25  15:14:35  richard
Removed much code concerned with graph generation a new
RegisterGraphs module, and tidied up the remainder.

Revision 1.19  91/10/18  14:54:11  richard
Added another graph to avoid sharing of registers which are used
simultaneously.

Revision 1.18  91/10/17  15:54:08  richard
Uncoloured registers are now allocated real registers, but spill
instructions are not yet generated, so the code is illegal in this
case.

Revision 1.17  91/10/16  16:10:24  richard
Register colouring experimentation.

Revision 1.16  91/10/16  12:12:12  richard
Simplified some of the code involving records.
Implemented forbidden colours (corrupted registers) around procedure
calls.

Revision 1.15  91/10/15  14:31:01  richard
Converted tuples to records where possible. This makes the code
much clearer. A lot of code which belongs elsewhere has been moved out
to other modules.

Revision 1.14  91/10/14  15:31:01  richard
Changed the way preassigned registers are input into the colouring
process so that they are not returned as used unless they really
are used. Made first steps towards colouring around procedure calls.

Revision 1.13  91/10/11  14:41:17  richard
Added a rather hacked bit of code to pass out the sets of registers
used by a procedure. Will fix this properly later.

Revision 1.12  91/10/11  11:04:46  richard
Slight alterations to cope with new MirTypes.

Revision 1.11  91/10/10  14:48:33  richard
Uses ordered lists of real registers rather than sets. The order
indicates allocation preferences.

Revision 1.9  91/10/10  10:12:36  richard
Changed names of closure and argument registers. Not complete.

Revision 1.8  91/10/08  15:24:45  richard
Adapted allocator to use new version of the graph module which is more
efficient when building graphs. Started work on spill allocation.

Revision 1.7  91/10/07  16:23:09  richard
Changed dependency on MachRegisters to MachSpec.

Revision 1.6  91/10/04  13:02:22  richard
Changed dependency on MachTypes to MachRegisters to remove target
machine dependence. Other minor tidying.

Revision 1.5  91/10/03  15:32:13  richard
The virtual registers are now coloured with more virtual registers, which
are then substituted in the procedure. Tables are returned with the
modified code which map the new virtual registers on to real machine
registers. The idea is that the code is still tractable by the other
optimisation modules in this state.

Revision 1.4  91/10/02  14:18:24  richard
Included actual machine registers. Further development of register
allocation including graphs for spill heuristics.

Revision 1.3  91/10/01  15:41:31  richard
Rewrote clash graph generator. It now generates separate graphs for the
different types of registers. These will, after all, have to be assigned
to differnt real registers.

Revision 1.2  91/09/30  12:47:17  richard
Simple register allocation within a single block.

Revision 1.1  91/09/27  15:03:52  richard
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

a126 1
require "../utils/graph";
a130 1
require "../machine/machspec";
d138 1
d146 1
a152 3
  structure MachSpec		: MACHSPEC
  structure Graph		: GRAPH
  structure Table		: TABLE
d155 1
a156 1
  structure Counter		: COUNTER
a167 6
  sharing Table =
    Graph.Table =
    MirTables.Table =
    RegisterGraphs.Table =
    Substitute.Table

a169 1
    Graph.Set =
d174 2
a175 2
  sharing Graph =
    RegisterGraphs.Graph
d184 2
a185 1
  sharing MachSpec = MirRegisters.MachSpec
a192 2
  structure MachSpec = MachSpec
  structure Table = Table
d201 2
a202 1
    (fn verbosity => "MirOptimiser (RegAlloc):" :: (output_function verbosity))
d204 11
a214 7
  fun diagnostic_graphs (message, RegisterGraphs.CLASH {gc, non_gc, fp}) =
    (diagnostic (4, fn _ => ["\n  GC ", message, ": ",
			     Graph.print (MirPrint.gc_register, gc)]);
     diagnostic (4, fn _ => ["\n  NON_GC ", message, ": ",
			     Graph.print (MirPrint.non_gc_register, non_gc)]);
     diagnostic (4, fn _ => ["\n  FP ", message, ": ",
			     Graph.print (MirPrint.fp_register, fp)]))
d216 1
a216 2
  fun diagnostic_assignments {assigned = {gc = a, non_gc = b, fp = c},
			      unassigned = {gc = w, non_gc = x, fp = y}} =
d218 2
a219 2
      fun p (message, printer, assigned, unassigned) =
	diagnostic (3, fn _ => [message, "\n  assigned:"] @@
d224 1
a224 3
		     (Table.alist_of_table assigned)) @@
		    ["\n  unassigned: ",
		     Lists.to_string printer unassigned])
d226 3
a228 3
      p ("GC:", MirPrint.gc_register, a, w);
      p ("NON_GC:", MirPrint.non_gc_register, b, x);
      p ("FP:", MirPrint.fp_register, c, y)
d231 9
d242 1
d273 50
d331 4
a334 2
  fun colour_graphs {live = RegisterGraphs.CLASH live,
		     forbidden = RegisterGraphs.TABLE forbidden} =
d336 2
d341 13
a353 6
	Graph.colour Graph.GREEDY
	{graph		= #gc live,
	 colours	= #gc MirRegisters.machine_register_aliases,
	 ordering	= MirTypes.order_gc_register,
	 precoloured	= #gc precolours,
	 forbidden	= #gc forbidden}
d358 13
a370 6
	Graph.colour Graph.GREEDY
	{graph		= #non_gc live,
	 colours	= #non_gc MirRegisters.machine_register_aliases,
	 ordering	= MirTypes.order_non_gc_register,
	 precoloured	= #non_gc precolours,
	 forbidden	= #non_gc forbidden}
d375 13
a387 6
	Graph.colour Graph.GREEDY
	{graph		= #fp live,
	 colours	= #fp MirRegisters.machine_register_aliases,
	 ordering	= MirTypes.order_fp_register,
	 precoloured	= #fp precolours,
	 forbidden	= #fp forbidden}
d404 10
a413 7
   *  Registers which cannot be coloured (i.e. cannot be fitted into the
   *  machine registers) are assigned to the same alias register as other
   *  registers. The value in the alias register must be saved (spilled) while
   *  it is being used for the other value. It is best if the original value is
   *  not referenced during the lifetime of the new value (the values won't
   *  have to be swapped), so the reference graph is used to decide which alias
   *  register to share.
d416 1
a416 3
  fun assign_uncoloured {assigned, unassigned,
			 reference = RegisterGraphs.CLASH reference,
			 simultaneous = RegisterGraphs.CLASH simultaneous} =
d421 6
a426 4
      (* Polymorphic assign function. In addition to the parameters above *)
      (* this function is passed the list of machine register aliases, so *)
      (* that it can choose one, and a register printing function for *)
      (* debugging output. *)
d428 14
a441 3
      fun assign (assigned, unassigned, reference_graph,
		  aliases, simultaneous, printer) =
	let
d443 2
a444 6
	  fun choose_list (table, shared, []) = (table, shared)
	    | choose_list (table, already_shared, reg::regs) =
	      let
		val _ =
		  diagnostic (2, fn _ => ["Choosing shared register for ",
					  printer reg])
d446 7
a452 57
		(* Map those registers which have been assigned *)
		(* aliases in list to their aliases. *)
		fun alias_regs_of list =
		  Lists.reducel
		  (fn (list, reg) =>
		   (Table.lookup (reg, table)) :: list
		   handle Table.Lookup => list)
		  ([], list)

		(* Look up which registers are used at the same time *)
		(* as the register, and remove these from the *)
		(* available choices. *)
		val regs_used_simultaneously =
		  Set.set_to_list (Graph.adjacent (reg, simultaneous))

		val available_choices =
		  Lists.difference
		  (aliases, alias_regs_of regs_used_simultaneously)

		(* Finds the first available choice which is not in l *)
		fun not_in l =
		  Lists.findp
		  (fn x => not (Lists.member(x,l)))
		  available_choices

		(* Find out which aliases are going to be referenced *)
		(* during the lifetime of the register. Avoid if *)
		(* possible. *)
		val referenced_alias_regs =
		  alias_regs_of (Set.set_to_list
				 (Graph.adjacent (reg, reference_graph)))

		val chosen =
		  (diagnostic (2, fn _ => ["trying unreferenced..."]);
		   not_in referenced_alias_regs)
		  handle Lists.Find =>
		    (diagnostic (2, fn _ => ["trying unshared..."]);
		     not_in already_shared)
		    handle Lists.Find =>
		      (diagnostic (2, fn _ => ["trying random..."]);
		       Lists.nth (Counter.read_counter (), available_choices))
		      handle Lists.Nth =>
			(Counter.reset_counter 0;
			 Lists.nth (Counter.read_counter (),
				    available_choices))
			 handle Lists.Nth =>
			   Crash.impossible
			   ("MirOptimiser (RegAlloc): Can't choose "^
			    "a register to share.")

		val _ = diagnostic (2, fn _ => ["chosen ", printer chosen])
	      in
		choose_list (Table.overwrite ((reg, chosen), table),
			     chosen::already_shared,
			     regs)
	      end
	      
d454 4
a457 1
	  choose_list (assigned, [], unassigned)
d460 4
a463 18
      val gc = assign (#gc assigned,
		       #gc unassigned,
		       #gc reference,
		       #gc MirRegisters.general_purpose,
		       #gc simultaneous,
		       MirPrint.gc_register)
      val non_gc = assign (#non_gc assigned,
			   #non_gc unassigned,
			   #non_gc reference,
			   #non_gc MirRegisters.general_purpose,
			   #non_gc simultaneous,
			   MirPrint.non_gc_register)
      val fp = assign (#fp assigned,
		       #fp unassigned,
		       #fp reference,
		       #fp MirRegisters.general_purpose,
		       #fp simultaneous,
		       MirPrint.fp_register)
d465 4
a468 6
      {assigned = {gc = #1 gc,
		   non_gc = #1 non_gc,
		   fp = #1 fp},
       shared = {gc = #2 gc,
		 non_gc = #2 non_gc,
		 fp = #2 fp}}
a472 1

d485 1
a485 1
      val {live, reference, forbidden, simultaneous} =
d490 14
d508 3
a510 1
	colour_graphs {live = live, forbidden = forbidden}
d512 1
a512 2
      val _ = diagnostic_assignments {assigned = assigned,
				      unassigned = unassigned}
d517 1
a517 1
      val {assigned, shared} =
d520 1
a520 2
			   reference = reference,
			   simultaneous = simultaneous}
d522 3
a530 2
	  fun used_virtual table =
	    Set.list_to_set (map #2 (Table.alist_of_table table))
d535 3
a537 3
	     {gc = used_virtual (#gc assigned),
	      non_gc = used_virtual (#non_gc assigned),
	      fp = used_virtual (#fp assigned)},
d546 2
a547 1
      Substitute.substitute (assigned, shared) new_procedure
@


1.22
log
@Removed references to fp_double registers.
@
text
@d4 3
d91 1
a95 1
require "../utils/print";
a123 1
  structure Print		: PRINT
d127 1
d171 1
d174 1
a174 1
  (*  === DEBUGGING INFORMATION OUTPUT ===  *)
d176 3
a178 4
  fun info message =
    if !Switches.registerallocator_debug then
      Print.print ("MIR Optimiser (RegAlloc): " ^ message ^ "\n")
    else ();
d180 7
a186 11
  fun info_graphs (message, RegisterGraphs.CLASH {gc, non_gc, fp}) =
    if !Switches.registerallocator_graphs then
    (
      info ("\n  GC " ^ message ^ ": " ^
	    Graph.print (MirPrint.gc_register, gc));
      info ("\n  NON_GC " ^ message ^ ": " ^
	    Graph.print (MirPrint.non_gc_register, non_gc));
      info ("\n  FP " ^ message ^ ": " ^
	    Graph.print (MirPrint.fp_register, fp))
    )
    else ();
d188 17
a204 21
  fun info_assignments {assigned = {gc = a, non_gc = b, fp = c},
			unassigned = {gc = w, non_gc = x, fp = y}} =
    if !Switches.registerallocator_debug then
      let
	fun p (message, printer, assigned, unassigned) =
	  info (message ^ "\n  assigned:" ^
		(Lists.reducel op^
		 ("",
		  map
		  (fn (virtual,real) =>
		   "\n    " ^ printer virtual ^
		   " := " ^ printer real)
		  (Table.alist_of_table assigned))) ^
		"\n  unassigned: " ^
		(Lists.to_string printer unassigned))
      in
	p ("GC:", MirPrint.gc_register, a, w);
	p ("NON_GC:", MirPrint.non_gc_register, b, x);
	p ("FP:", MirPrint.fp_register, c, y)
      end
    else ();
d249 1
a249 1
      val _ = info "colouring GC graph"
d259 1
a259 1
      val _ = info "colouring NON_GC graph"
d269 1
a269 1
      val _ = info "colouring FP graph"
d323 2
a324 1
		  info ("Choosing shared register for " ^ printer reg)
d359 1
a359 1
		  (info "trying unreferenced...";
d362 1
a362 1
		    (info "trying unshared...";
d365 1
a365 1
		      (info "trying random...";
d376 1
a376 1
		val _ = info ("chosen " ^ printer chosen)
d424 2
a425 1
      val _ = info ("procedure " ^ MirTypes.print_tag start_tag)
d432 1
a432 1
      val _ = info_graphs ("live graph", live)
d440 2
a441 2
      val _ = info_assignments {assigned = assigned,
				unassigned = unassigned}
@


1.21
log
@Various changes to do with the interface to the Substitute module.
@
text
@d4 3
d177 1
a177 1
  fun info_graphs (message, RegisterGraphs.CLASH {gc, non_gc, fp, fp_double}) =
d185 1
a185 3
	    Graph.print (MirPrint.fp_register, fp));
      info ("\n  FP_DOUBLE " ^ message ^ ": " ^
	    Graph.print (MirPrint.fp_double_register, fp_double))
d189 2
a190 3
  fun info_assignments {assigned = {gc = a, non_gc = b, fp = c, fp_double = d},
			unassigned =
			{gc = w, non_gc = x, fp = y, fp_double = z}} =
d207 1
a207 2
	p ("FP:", MirPrint.fp_register, c, y);
	p ("FP_DOUBLE:", MirPrint.fp_double_register, d, z)
d230 1
a230 2
       fp	= self_alist (#fp MirRegisters.preassigned),
       fp_double= self_alist (#fp_double MirRegisters.preassigned)}
d239 1
a239 1
  fun resolve_record {gc, non_gc, fp, fp_double} = ()
a283 10
      val _ = info "colouring FP_DOUBLE graph"

      val (fp_double_assigned, fp_double_unassigned) =
	Graph.colour Graph.GREEDY
	{graph		= #fp_double live,
	 colours	= #fp_double MirRegisters.machine_register_aliases,
	 ordering	= MirTypes.order_fp_double_register,
	 precoloured	= #fp_double precolours,
	 forbidden	= #fp_double forbidden}

d288 1
a288 2
		   fp = fp_assigned,
		   fp_double = fp_double_assigned},
d291 1
a291 2
		     fp = fp_unassigned,
		     fp_double = fp_double_unassigned}}
a408 6
      val fp_double = assign (#fp_double assigned,
			      #fp_double unassigned,
			      #fp_double reference,
			      #fp_double MirRegisters.general_purpose,
			      #fp_double simultaneous,
			      MirPrint.fp_double_register)
d412 1
a412 2
		   fp = #1 fp,
		   fp_double = #1 fp_double},
d415 1
a415 2
		 fp = #2 fp,
		 fp_double = #2 fp_double}}
d469 1
a469 2
	      fp = used_virtual (#fp assigned),
	      fp_double = used_virtual (#fp_double assigned)},
@


1.20
log
@Removed much code concerned with graph generation a new
RegisterGraphs module, and tidied up the remainder.
@
text
@d4 4
d100 1
d107 1
d128 2
a129 1
    RegisterGraphs.MirTypes
d134 2
a135 1
    RegisterGraphs.Table
d151 2
a152 1
    RegisterGraphs.MirOptTypes
a244 49
  (*  === APPLY REGISTER SUBSTITUTIONS TO PROCEDURE ===
   *
   *  Returns a procedure with all referenced to registers changed
   *  according to the mappings in the four tables.
   *)

  fun substitute (tables,
		  MirTypes.PROC_PARAMS
		  {spill_sizes = MirTypes.PRESENT spill_sizes, ...}) =
    let
      val _ = resolve_record tables

      val _ = info ("substituting new registers")

      fun subst (opcode, regs, succs) =
	let
	  open MirTypes

	  fun sym GC_SPILL_SIZE = GP_IMM_INT(#gc spill_sizes)
	    | sym NON_GC_SPILL_SIZE = GP_IMM_INT(#non_gc spill_sizes)
	    | sym _ =
	      Crash.impossible
	      ("MirOptimiser (RegAlloc): Unknown symbolic GP operand in " ^
	       "in input MIR code.")

	  val new_opcode =
	    MirTables.substitute_registers (tables, sym) opcode
	    handle MirTables.NoMapping reg =>
	      Crash.impossible
	      ("MirOptimiser (RegAlloc): " ^
	       MirPrint.any_reg reg ^ " has not been assigned.")
	in
	  (new_opcode, regs, succs)
	end


    in

      MirOptTypes.proc_map (MirOptTypes.block_map subst)

    end

  | substitute _ =
    Crash.impossible
    ("MirOptimiser (RegAlloc): substitute has been passed an "^
     "incomplete procedure parameters record.")



d338 1
a338 1
	  fun choose_list (table, _, []) = table
d405 24
d430 8
a437 26

      {gc = assign (#gc assigned,
		    #gc unassigned,
		    #gc reference,
		    #gc MirRegisters.machine_register_aliases,
		    #gc simultaneous,
		    MirPrint.gc_register),
       non_gc = assign (#non_gc assigned,
			#non_gc unassigned,
			#non_gc reference,
			#non_gc MirRegisters.machine_register_aliases,
			#non_gc simultaneous,
			MirPrint.non_gc_register),
       fp = assign (#fp assigned,
		    #fp unassigned,
		    #fp reference,
		    #fp MirRegisters.machine_register_aliases,
		    #fp simultaneous,
		    MirPrint.fp_register),
       fp_double = assign (#fp_double assigned,
			   #fp_double unassigned,
			   #fp_double reference,
			   #fp_double MirRegisters.machine_register_aliases,
			   #fp_double simultaneous,
			   MirPrint.fp_double_register)}

d447 1
a447 4
  fun analyse (procedure as
	       MirOptTypes.PROC(start_tag,
				MirTypes.PROC_PARAMS {leaf, ...},
				_)) =
d471 1
a471 1
      val all_assigned =
d477 3
a479 1
      val params =
d481 2
d493 2
a494 5
	   spill_sizes = MirTypes.PRESENT {gc=0,
					   non_gc=0,
					   fp=0,
					   fp_double=0},
	   stack_allocated = MirTypes.PRESENT 0}
d497 1
a497 2
      val MirOptTypes.PROC(_, _, blocks) =
	substitute (assigned, params) procedure
d501 1
a501 1
      MirOptTypes.PROC(start_tag, params, blocks)
@


1.19
log
@Added another graph to avoid sharing of registers which are used
simultaneously.
@
text
@d4 4
d95 1
d101 1
d117 28
a144 4
  sharing MirTypes = MirOptTypes.MirTypes =
    MirPrint.MirTypes = MirRegisters.MirTypes = MirTables.MirTypes
  sharing Table = Graph.Table = MirOptTypes.Table = MirTables.Table
  sharing Set = MirOptTypes.Set = Graph.Set = MirTypes.Set = MirRegisters.Set
d165 2
a166 2
  fun info_graphs (message, {gc, non_gc, fp, fp_double}) =
    if !Switches.registerallocator_debug then
d179 3
a181 1
  fun info_colours {gc, non_gc, fp, fp_double} =
d183 18
a200 15
    let
      fun p(m,f,(x,x')) =
	info (m ^ "\n" ^
	      (Lists.reducel op^
	       ("",
		map
		(fn (r,c) => f r ^ " := " ^ f c ^ "\n")
		(Table.alist_of_table x))) ^
	      "uncoloured: " ^ (Lists.to_string f x'))
    in
      p ("GC colours:", MirPrint.gc_register, gc);
      p ("NON_GC colours:", MirPrint.non_gc_register, non_gc);
      p ("FP colours:", MirPrint.fp_register, fp);
      p ("FP_DOUBLE colours:", MirPrint.fp_double_register, fp_double)
    end
a207 37
  (* Table specification for the four register types. *)

  local
    open Table
  in
    val tablespec =
    {gc		= TableSpec {order = MirTypes.order_gc_register, eq = op=},
     non_gc	= TableSpec {order = MirTypes.order_non_gc_register, eq = op=},
     fp		= TableSpec {order = MirTypes.order_fp_register, eq = op=},
     fp_double	= TableSpec {order = MirTypes.order_fp_double_register, eq = op=}}
  end


  (*  == The empty graphs ==
   *
   *  These are empty graphs for the register types. They are set up
   *  as `buildable' because a lot of vertices are added when the
   *  procedure is scanned, and the graphs are not examined until they
   *  are coloured at the end.
   *)

  val empty_graphs =
    {gc		= Graph.empty Graph.BUILDABLE,
     non_gc	= Graph.empty Graph.BUILDABLE,
     fp		= Graph.empty Graph.BUILDABLE,
     fp_double	= Graph.empty Graph.BUILDABLE}


  (*  == The empty forbidden tables ==  *)

  val empty_tables =
    {gc		= Table.empty_table (#gc tablespec),
     non_gc	= Table.empty_table (#non_gc tablespec),
     fp		= Table.empty_table (#fp tablespec),
     fp_double	= Table.empty_table (#fp_double tablespec)}


a235 45
  (*  === MISCELLANEOUS UTILITY FUNCTIONS ===  *)


  (*  == Partition register types ==
   *
   *  Divides a list of any_registers into a record of lists of the four
   *  register types.
   *)

  local
    open MirTypes
  in

    val empty_partition = {gc = [], non_gc = [], fp = [], fp_double = []}

    fun partition (lists, []) = lists

      | partition ({gc, non_gc, fp, fp_double}, (GC reg)::rest) =
	partition ({gc = reg::gc,
		    non_gc = non_gc,
		    fp = fp,
		    fp_double = fp_double}, rest)

      | partition ({gc, non_gc, fp, fp_double}, (NON_GC reg)::rest) =
	partition ({gc = gc,
		    non_gc = reg::non_gc,
		    fp = fp,
		    fp_double = fp_double}, rest)

      | partition ({gc, non_gc, fp, fp_double}, (FLOAT reg)::rest) =
	partition ({gc = gc,
		    non_gc = non_gc,
		    fp = reg::fp,
		    fp_double = fp_double}, rest)

      | partition ({gc, non_gc, fp, fp_double}, (DOUBLE reg)::rest) =
	partition ({gc = gc,
		    non_gc = non_gc,
		    fp = fp,
		    fp_double = reg::fp_double}, rest)

  end



d263 4
d285 1
a285 1
  (*  === AUGMENT CLASH GRAPHS WITH REGISTER SET ===
a286 171
   *  The register set indicates which registers are live at the same time.
   *  The clash graphs for the four register types have edges added between
   *  the registers, indicating that they cannot share the same real
   *  register.
   *)

  fun augment_clash_graphs graphs live =
    let
      val _ = resolve_record graphs
      val _ = resolve_record live

      fun augment graph live =
	Graph.add_many_to_many Graph.add_edge
	(graph, live, live)

    in
      {gc	= augment (#gc graphs) (#gc live),
       non_gc	= augment (#non_gc graphs) (#non_gc live),
       fp	= augment (#fp graphs) (#fp live),
       fp_double= augment (#fp_double graphs) (#fp_double live)}
    end



  (*  === AUGMENT REFERENCE GRAPHS WITH REGISTER SETS ===
   *
   *  The reference graphs keep track of which registers are
   *  referenced during the lifetime of which other registers. This
   *  allows the register spiller to make good decisisons.
   *)

  fun augment_reference_graphs graphs (live, referenced) =
    let
      val _ = resolve_record graphs
      val _ = resolve_record live
      val _ = resolve_record referenced

      fun augment graph (live, referenced) =
	Graph.add_many_to_many Graph.add_directed_edge
	(graph, live, referenced)

    in
      {gc	= augment (#gc graphs) (#gc live, #gc referenced),
       non_gc	= augment (#non_gc graphs) (#non_gc live, #non_gc referenced),
       fp	= augment (#fp graphs) (#fp live, #fp referenced),
       fp_double= augment (#fp_double graphs) (#fp_double live,
					       #fp_double referenced)}
    end



  (*  === AUGMENT THE FORBIDDEN TABLE ===
   *
   *  Since a procedure may corrupt registers, the registers live
   *  across a procedure call must have the corrupted registers
   *  forbidden as colours. This function adds the corrupted registers
   *  to a table of forbidden colours for each register in the live
   *  set.
   *)

  fun augment_forbidden_tables tables (live, forbidden) =
    let
      val _ = resolve_record tables
      val _ = resolve_record live
      val _ = resolve_record forbidden

      fun augment table (live, forbidden) =
	let
	    
	  fun add_forbidden (table, register) =
	    let
	      val already_forbidden =
		Table.lookup (register, table)
		handle Table.Lookup => Set.empty_set

	      val forbidden =
		Set.union (already_forbidden, forbidden)
	    in
	      Table.overwrite ((register, forbidden), table)
	    end
	in
	  Lists.reducel add_forbidden (table, live)
	end

    in
      {gc	= augment (#gc tables) (#gc live, #gc forbidden),
       non_gc	= augment (#non_gc tables) (#non_gc live, #non_gc forbidden),
       fp	= augment (#fp tables) (#fp live, #fp forbidden),
       fp_double= augment (#fp_double tables) (#fp_double live,
					       #fp_double forbidden)}
    end



  (*  === GENERATE CLASH GRAPHS IN A PROCEDURE ===
   *
   *  For an entire procedure, add register clashes in all blocks to the
   *  clash graphs.
   *
   *  Three records (containing graphs for each register type) are
   *  generated:
   *    clash		Keep track of which registers are live at the
   *  			same time and should therefore be assigned to
   *  			different registers if possible.
   *    reference	A directed graph with edges from registers to
   *  			the registers referenced during their
   *  			lifetime. When a register has to be shared
   *  			these should be avoided if possible.
   *    forbidden	A table which prevents the use of machine
   *  			registers corrupted by subroutines if a
   *  			register is live across a call instruction.
   *    simultaneous	A graph with edges between registers which are
   *  			used simultaneously and therefore can't share
   *  			the same machine register.
   *)

  val generate =
    let
      fun process {live, reference, forbidden, simultaneous}
	          (opcode, MirOptTypes.REGS(live_regs,referenced_regs), _) =
	  let
(*******)
	    val live_regs =
	      case opcode
		of MirTypes.ALLOCATE(_,_,_,reg,_) =>
		  Set.add_member (MirTypes.reg_to_any reg, live_regs)
		| _ => live_regs
(*******)
	    val parted_live_regs =
	      partition (empty_partition, Set.set_to_list live_regs)

	    val parted_referenced_regs =
	      partition (empty_partition, Set.set_to_list referenced_regs)

	  in
	    {live = augment_clash_graphs live parted_live_regs,

	     reference = augment_reference_graphs reference
	                 (parted_live_regs, parted_referenced_regs),

	     forbidden =
	       case opcode
		 of MirTypes.BRANCH_AND_LINK _ =>
		    augment_forbidden_tables forbidden
		    (parted_live_regs, MirRegisters.corrupted_by_callee)
		  | _ =>
		    forbidden,

	     simultaneous =
	       augment_clash_graphs simultaneous parted_referenced_regs}

	  end

	| process _ _ =
	  Crash.impossible
	  ("MirOptimiser (RegAlloc): I've found an opcode without " ^
	   "live register information.")

    in
      MirOptTypes.proc_fold
      (MirOptTypes.block_fold process)
      {live = empty_graphs,
       reference = empty_graphs,
       forbidden = empty_tables,
       simultaneous = empty_graphs}
    end



  (*  === COLOUR CLASH GRAPHS USING FRESH REGISTERS ===
   *
d290 1
a290 1
   *  fresh registers.
d293 2
a294 1
  fun colour_graphs (graphs, forbidden_tables) =
a295 3
      val _ = resolve_record graphs
      val _ = resolve_record forbidden_tables

d298 1
a298 1
      val gc_assignments =
d300 1
a300 1
	{graph		= #gc graphs,
d304 1
a304 1
	 forbidden	= #gc forbidden_tables}
d308 1
a308 1
      val non_gc_assignments =
d310 1
a310 1
	{graph		= #non_gc graphs,
d314 1
a314 1
	 forbidden	= #non_gc forbidden_tables}
d318 1
a318 1
      val fp_assignments =
d320 1
a320 1
	{graph		= #fp graphs,
d324 1
a324 1
	 forbidden	= #fp forbidden_tables}
d328 1
a328 1
      val fp_double_assignments =
d330 1
a330 1
	{graph		= #fp_double graphs,
d334 1
a334 1
	 forbidden	= #fp_double forbidden_tables}
d338 8
a345 4
      {gc = gc_assignments,
       non_gc = non_gc_assignments,
       fp = fp_assignments,
       fp_double = fp_double_assignments}
d353 7
a359 8
   *  Registers which cannot be coloured (i.e. cannot be fitted into
   *  the machine registers) are assigned to the same fresh register
   *  as other registers. The value in the fresh register must be
   *  saved on the stack (spilled) while it is being used for the
   *  other value. It is best if the original value is not referenced
   *  during the lifetime of the new value (the values won't have to
   *  be swapped), so the reference graph is used to decide which
   *  fresh register to share.
d362 3
a364 1
  fun assign_uncoloured (colours, reference_graphs, simultaneous) =
d366 2
a367 3
      val _ = resolve_record colours
      val _ = resolve_record reference_graphs
      val _ = resolve_record simultaneous
d369 7
a375 5
      fun assign ((assigned, unassigned),
		  reference_graph,
		  aliases,
		  simultaneous,
		  printer) =
d378 1
a378 1
	  fun choose_list (table, shared, []) = (table, shared)
d381 2
a382 2
		val _ = info ("Choosing shared register for " ^
			      printer reg)
d444 1
d446 4
a449 2
      {gc = assign (#gc colours,
		    #gc reference_graphs,
d453 3
a455 2
       non_gc = assign (#non_gc colours,
			#non_gc reference_graphs,
d459 3
a461 2
       fp = assign (#fp colours,
		    #fp reference_graphs,
d465 3
a467 2
       fp_double = assign (#fp_double colours,
			   #fp_double reference_graphs,
d471 1
d477 3
a479 1
  (*  === TEST HARNESS ===  *)
d481 4
a484 3
  fun analyse (proc as MirOptTypes.PROC(start_tag,
					MirTypes.PROC_PARAMS {leaf, ...},
					_)) =
d486 1
d489 1
a489 4
      val {live = clash_graphs,
	   reference = ref_graphs,
	   forbidden = forbidden_tables,
	   simultaneous = simultaneous} = generate proc
d491 2
a492 4
(*
      val _ = info_graphs ("clash graph", clash_graphs)
      val _ = info_graphs ("ref graph", ref_graphs)
*)
d494 1
a494 3
      val colours = colour_graphs (clash_graphs, forbidden_tables)
      val _ = info_colours colours
      val assignments = assign_uncoloured (colours, ref_graphs, simultaneous)
d496 2
d499 2
a500 4
      val assigned = {gc = #1 (#gc assignments),
		      non_gc = #1 (#non_gc assignments),
		      fp = #1 (#fp assignments),
		      fp_double = #1 (#fp_double assignments)}
d502 2
a503 5
      val spill_sizes = MirTypes.PRESENT
	{gc = Lists.length (#2 (#gc assignments)),
	 non_gc = Lists.length (#2 (#non_gc assignments)),
	 fp = Lists.length (#2 (#fp assignments)),
	 fp_double = Lists.length (#2 (#fp_double assignments))}
d505 2
a506 2
      fun used_virtual table =
	Set.list_to_set (map #2 (Table.alist_of_table table))
d508 6
d515 17
a531 9
	MirTypes.PROC_PARAMS
	{leaf = leaf,
	 registers_used = MirTypes.PRESENT
	 {gc = used_virtual (#gc assigned),
	  non_gc = used_virtual (#non_gc assigned),
	  fp = used_virtual (#fp assigned),
	  fp_double = used_virtual (#fp_double assigned)},
	 spill_sizes = spill_sizes,
	 stack_allocated = MirTypes.PRESENT 0}
d534 1
a534 1
	substitute (assigned, params) proc
@


1.18
log
@Uncoloured registers are now allocated real registers, but spill
instructions are not yet generated, so the code is illegal in this
case.
@
text
@d4 5
d293 1
a293 1
      val _ = info ("Register substitution")
d295 2
d428 16
d446 1
a446 1
  fun proc_generate graphs (proc as MirOptTypes.PROC(start_tag, _, _)) =
d448 2
a449 4
      val _ = info ("procedure " ^ MirTypes.print_tag start_tag)

      fun process (live_graphs, reference_graphs, forbidden_table)
	          (opcode, MirOptTypes.REGS(live,referenced), succs) =
d452 1
a452 1
	    val live =
d455 2
a456 2
		  Set.add_member (MirTypes.reg_to_any reg, live)
		| _ => live
d458 2
a459 2
	    val parted_live =
	      partition (empty_partition, Set.set_to_list live)
d461 2
a462 2
	    val parted_refd =
	      partition (empty_partition, Set.set_to_list referenced)
d464 2
a465 2
	    val new_live_graphs =
	      augment_clash_graphs live_graphs parted_live
d467 2
a468 4
	    val new_reference_graphs =
	      augment_reference_graphs
	      reference_graphs
	      (parted_live, parted_refd)
d470 11
a480 9
	    val new_forbidden_table =
	      case opcode
		of MirTypes.BRANCH_AND_LINK _ =>
		   augment_forbidden_tables forbidden_table
		   (parted_live, MirRegisters.corrupted_by_callee)
		 | _ =>
		   forbidden_table
	  in
	    (new_live_graphs, new_reference_graphs, new_forbidden_table)
d489 6
a494 1
      MirOptTypes.proc_fold (MirOptTypes.block_fold process) graphs proc
d512 1
a512 1
      val _ = info "Colouring GC graph"
d522 1
a522 1
      val _ = info "Colouring NON_GC graph"
d532 1
a532 1
      val _ = info "Colouring FP graph"
d542 1
a542 1
      val _ = info "Colouring FP_DOUBLE graph"
d575 1
a575 1
  fun assign_uncoloured (colours, reference_graphs) =
d579 1
d584 1
d589 1
a589 1
	    | choose_list (table, shared, reg::regs) =
d591 23
d617 1
a617 1
		  aliases
d619 6
a624 2
		val _ = info ("Choosing shared register for " ^
			      printer reg)
a625 13
		val adjacent =
		  let
		    fun l (done, []) = done
		      | l (done, reg::regs) =
			l (Table.lookup (reg, table)::done, regs)
			handle Table.Lookup =>
			  l (done, regs)
		  in
		    l ([],
		       Set.set_to_list (Graph.adjacent
					(reg, reference_graph)))
		  end

d628 1
a628 1
		   not_in adjacent)
d631 1
a631 1
		     not_in shared)
d634 1
a634 1
		       Lists.nth (Counter.read_counter (), aliases))
d637 2
a638 1
			 Lists.nth (Counter.read_counter (), aliases))
d647 1
a647 1
			     chosen::shared,
d658 1
d663 1
d668 1
d673 1
d686 1
a686 1
      val _ = info "Generating clash and reference graphs..."
d688 4
a691 2
      val (clash_graphs, ref_graphs, forbidden_tables) =
	proc_generate (empty_graphs, empty_graphs, empty_tables) proc
d693 4
a696 2
(*      val _ = info_graphs ("clash graph", clash_graphs)
      val _ = info_graphs ("ref graph", ref_graphs)*)
d700 1
a700 1
      val assignments = assign_uncoloured (colours, ref_graphs)
@


1.17
log
@Register colouring experimentation.
@
text
@d4 3
d85 1
d104 1
d120 1
a122 7
  val show_info = true;		(* false to disable debugging output *)
  val show_code = false;	(* false to disable listings *)
  val show_graphs = false;	(* false to disable graph output *)
  val show_assign = true;	(* false to disable assignments *)



d126 1
a126 1
    if show_info then
a129 5
  fun code_info message =
    if show_code then
      Print.print (message ^ "\n")
    else ();

d131 1
a131 1
    if show_graphs then
d145 1
a145 1
    if show_assign then
d430 7
d549 1
a549 10

  (*  == Choose a register to share ==
   *
   *  Given a list of the fresh virtual registers, a list of the fresh
   *  registers which have been shared already, a graph of references, and
   *  the register which needs assigning this function tries to make a
   *  good decision and returns a new list of assignments.
   *)

  fun choose_register (fresh, shared, references, reg) =
d551 2
a552 1
      val referenced = Graph.adjacent (reg, references)
d554 5
a558 2
      (* The best choice is a register which is not referenced during *)
      (* the lifetime of reg. *)
d560 7
a566 7
      val really_good_choice =
	Lists.findp
	(fn reg' => not (Set.is_member (reg', referenced)))
	fresh
    in
      really_good_choice
    end
d568 2
a569 1
    handle Lists.Find =>
d571 12
a582 2
      (* The second best choice is a fresh register which hasn't *)
      (* been shared yet. *)
d584 16
a599 3
      Lists.findp
      (fn reg' => not (Lists.member (reg', shared)))
      fresh
d601 28
a628 1
      handle Lists.Find =>
a629 1
	(* The final choice is some random fresh register *)
a630 1
	Lists.nth (Counter.read_counter (), fresh)
a631 3
	handle Lists.Nth =>
	  (Counter.reset_counter 0;
	   Lists.nth (Counter.read_counter (), fresh)
a632 7
	   handle Lists.Nth =>
	     Crash.impossible
	     ("MirOptimiser (RegAlloc): Something is wrong with the "^
	      "function that chooses a spill register to share."))



d644 2
a645 2
      val _ = info_graphs ("clash graph", clash_graphs)
      val _ = info_graphs ("ref graph", ref_graphs)
a647 1

d649 1
a650 4
      val assignments = {gc = #1 (#gc colours),
			 non_gc = #1 (#non_gc colours),
			 fp = #1 (#fp colours),
			 fp_double = #1 (#fp_double colours)}
d652 4
a655 5
      val unassigned = {gc = #2  (#gc colours),
			non_gc = #2 (#non_gc colours),
			fp = #2 (#fp colours),
			fp_double = #2 (#fp_double colours)}
    in
d657 5
a661 5
      case unassigned
	of {gc = [], non_gc = [], fp = [], fp_double = []} =>
	   let
	     fun used_virtual table =
	       Set.list_to_set (map #2 (Table.alist_of_table table))
d663 2
a664 11
	     val params =
	       MirTypes.PROC_PARAMS
	       {leaf = leaf,
		registers_used = MirTypes.PRESENT
		{gc = used_virtual (#gc assignments),
		 non_gc = used_virtual (#non_gc assignments),
		 fp = used_virtual (#fp assignments),
		 fp_double = used_virtual (#fp_double assignments)},
		spill_sizes = MirTypes.PRESENT
		{gc = 0, non_gc = 0, fp = 0, fp_double = 0},
		stack_allocated = MirTypes.PRESENT 0}
d666 10
a675 3
	     val MirOptTypes.PROC(_, _, blocks) =
	       substitute (assignments, params) proc
	   in
d677 2
a678 1
	     MirOptTypes.PROC(start_tag, params, blocks)
d680 1
a680 1
	   end
d682 1
a682 15
	 | {gc = ipple,...} =>
	     (map
	      (fn reg =>
	       let
		 val choose =
		   choose_register (#gc MirRegisters.machine_register_aliases,
				    [],
				    #gc ref_graphs,
				    reg)
	       in
		 info ("Chosen " ^ MirPrint.gc_register choose ^
		       " for unassigned register " ^
		       MirPrint.gc_register reg)
	       end)
	      ipple;
a683 1
	      Crash.unimplemented "Spong!")
d685 1
@


1.16
log
@Simplified some of the code involving records.
Implemented forbidden colours (corrupted registers) around procedure
calls.
@
text
@d4 5
d140 1
a140 1
	    Graph.print (MirTypes.print_gc_register, gc));
d142 1
a142 1
	    Graph.print (MirTypes.print_non_gc_register, non_gc));
d144 1
a144 1
	    Graph.print (MirTypes.print_fp_register, fp));
d146 1
a146 1
	    Graph.print (MirTypes.print_fp_double_register, fp_double))
d162 4
a165 4
      p ("GC colours:", MirTypes.print_gc_register, gc);
      p ("NON_GC colours:", MirTypes.print_non_gc_register, non_gc);
      p ("FP colours:", MirTypes.print_fp_register, fp);
      p ("FP_DOUBLE colours:", MirTypes.print_fp_double_register, fp_double)
d620 5
d627 5
a631 17
      case colours
	of {gc = (_,[]), non_gc = (_,[]), fp = (_,[]), fp_double = (_,[])} =>
	  let
	    fun used_virtual table =
	      Set.list_to_set (map #2 (Table.alist_of_table table))
	      
	    val params =
	      MirTypes.PROC_PARAMS
	      {leaf = leaf,
	       registers_used = MirTypes.PRESENT
	       {gc = used_virtual (#gc assignments),
		non_gc = used_virtual (#non_gc assignments),
		fp = used_virtual (#fp assignments),
		fp_double = used_virtual (#fp_double assignments)},
	       spill_sizes = MirTypes.PRESENT
	       {gc = 0, non_gc = 0, fp = 0, fp_double = 0},
	       stack_allocated = MirTypes.PRESENT 0}
d633 11
a643 3
	    val MirOptTypes.PROC(_, _, blocks) =
	      substitute (assignments, params) proc
	  in
d645 3
a647 1
	    MirOptTypes.PROC(start_tag, params, blocks)
d649 1
a649 1
	  end
d651 1
a651 3
	 | _ =>
	     Crash.unimplemented
	     ("MirOptimiser (RegAlloc): Register spilling not implemented.")
d653 17
@


1.15
log
@Converted tuples to records where possible. This makes the code
much clearer. A lot of code which belongs elsewhere has been moved out
to other modules.
@
text
@d4 5
d99 1
a99 1
  sharing Set = MirOptTypes.Set = Graph.Set = MirTypes.Set
d155 1
a155 1
	      (Lists.to_string f x'))
d197 9
d225 4
d230 1
d232 2
d330 1
a330 4
  fun augment_clash_graphs {gc = gc_graph,
			    non_gc = non_gc_graph,
			    fp = fp_graph,
			    fp_double = fp_double_graph} registers =
d332 2
a333 2
      val {gc, non_gc, fp, fp_double} =
	partition (empty_partition, Set.set_to_list registers)
d335 4
a338 1
      val add = Graph.add_many_to_many Graph.add_edge
d340 4
a343 4
      {gc	= add (gc_graph, gc, gc),
       non_gc	= add (non_gc_graph, non_gc, non_gc),
       fp	= add (fp_graph, fp, fp),
       fp_double= add (fp_double_graph, fp_double, fp_double)}
d355 1
a355 5
  fun augment_reference_graphs {gc = gc_graph,
				non_gc = non_gc_graph,
				fp = fp_graph,
				fp_double = fp_double_graph}
                                (live, referenced) =
d357 3
d361 3
a363 1
      val add = Graph.add_many_to_many Graph.add_directed_edge
d365 7
a371 5
      val {gc = gc_live,
	   non_gc = non_gc_live,
	   fp = fp_live,
	   fp_double = fp_double_live} =
	partition (empty_partition, Set.set_to_list live)
a372 5
      val {gc = gc_ref,
	   non_gc = non_gc_ref,
	   fp = fp_ref,
	   fp_double = fp_double_ref} =
	partition (empty_partition, Set.set_to_list referenced)
d374 34
d409 5
a413 4
      {gc	= add (gc_graph, gc_live, gc_ref),
       non_gc	= add (non_gc_graph, non_gc_live, non_gc_ref),
       fp	= add (fp_graph, fp_live, fp_ref),
       fp_double= add (fp_double_graph, fp_double_live, fp_double_ref)}
d428 1
a428 1
      fun process (live_graphs, reference_graphs)
d430 3
a432 2
	(augment_clash_graphs live_graphs live,
	 augment_reference_graphs reference_graphs (live, referenced))
d434 22
d475 1
a475 1
  fun colour_graphs {gc, non_gc, fp, fp_double} =
d477 2
d484 1
a484 1
	{graph		= gc,
d488 1
a488 1
	 forbidden	= Table.empty_table (#gc tablespec)}
d494 1
a494 1
	{graph		= non_gc,
d498 1
a498 1
	 forbidden	= Table.empty_table (#non_gc tablespec)}
d504 1
a504 1
	{graph		= fp,
d508 1
a508 1
	 forbidden	= Table.empty_table (#fp tablespec)}
d514 1
a514 1
	{graph		= fp_double,
d518 1
a518 1
	 forbidden	= Table.empty_table (#fp_double tablespec)}
d601 2
a602 2
      val (clash_graphs, ref_graphs) =
	proc_generate (empty_graphs, empty_graphs) proc
d607 1
a607 1
      val colours = colour_graphs clash_graphs
@


1.14
log
@Changed the way preassigned registers are input into the colouring
process so that they are not returned as used unless they really
are used. Made first steps towards colouring around procedure calls.
@
text
@d4 5
d67 1
d81 1
d92 2
a93 2
    MirPrint.MirTypes = MirRegisters.MirTypes
  sharing Table = Graph.Table = MirOptTypes.Table
d95 1
d109 2
d126 13
d140 18
a158 1
  (*  === DATA TYPES ===  *)
a159 5
  type clash_graphs =
    MirTypes.gc_register Graph.T *
    MirTypes.non_gc_register Graph.T *
    MirTypes.fp_register Graph.T *
    MirTypes.fp_double_register Graph.T
d161 1
d164 1
a164 1
  (*  === MISCELLANEOUS DATA ===  *)
d166 9
d176 1
d179 4
a182 2
   *  These are empty graphs for the various register types with
   *  ordering functions installed.
d186 4
a189 4
    (Graph.empty Graph.BUILDABLE,
     Graph.empty Graph.BUILDABLE,
     Graph.empty Graph.BUILDABLE,
     Graph.empty Graph.BUILDABLE)
d192 1
a192 2

  (*  === REGISTER ASSIGNMENTS ===
d194 4
a197 10
   *  The register allocator produces a MirOptTypes.procedure with the
   *  registers altered and a table mapping virtual to real registers.
   *  The procedure can then be run through other optimisation stages,
   *  provided that they don't create new registers. Here, a table
   *  mapping fresh virtual to real registers is created, and it is
   *  these fresh virtual registers which are allocated, rather than
   *  the real ones.
   *
   *  Most of the data values are tuples in the following order:
   *  gc, non_gc, fp, fp_double
d200 9
a208 1
  local
a209 4
    (* The preassigned registers are those which are always mapped *)
    (* onto the same real register. They are incorporated into the *)
    (* assignment tables, and are in a tuple in the order: gc, non_gc, *)
    (* fp, fp_double, as usual. *)
a210 13
    val preassigned =
      ([(MirRegisters.caller_arg,	MachSpec.caller_arg),
	(MirRegisters.caller_closure,	MachSpec.caller_closure),
	(MirRegisters.fp,		MachSpec.fp),
	(MirRegisters.sp,		MachSpec.sp),
	(MirRegisters.handler,		MachSpec.handler),
	(MirRegisters.global,		MachSpec.global)] @@
       (if not MirRegisters.automatic_callee then [] else
	  [(MirRegisters.callee_arg,	MachSpec.callee_arg),
	   (MirRegisters.callee_closure,MachSpec.callee_closure)]),
       [],
       [],
       [])
a211 1
  in
a212 76
    val gc_tablespec =
      Table.TableSpec {order = MirTypes.order_gc_register, eq = op=}
    val non_gc_tablespec =
      Table.TableSpec {order = MirTypes.order_non_gc_register, eq = op=}
    val fp_tablespec =
      Table.TableSpec {order = MirTypes.order_fp_register, eq = op=}
    val fp_double_tablespec =
      Table.TableSpec {order = MirTypes.order_fp_double_register, eq = op=}

    (* The precolours are virtual register to virtual register *)
    (* mappings fed to the graph colourer and ensure that certain *)
    (* virtual registers (the preassigned registers, see above) are *)
    (* always mapped to the same real registers. precolours is a tuple *)
    (* of tables which map these virtual registers onto themselves. *)

    val precolours =
      let
	val map_self = map (fn (virtual,real) => (virtual,virtual))
      in
	(Table.table_of_alist ((map_self (#1 preassigned)),
			       gc_tablespec),
	 Table.table_of_alist ((map_self (#2 preassigned)),
			       non_gc_tablespec),
	 Table.table_of_alist ((map_self (#3 preassigned)),
			       fp_tablespec),
	 Table.table_of_alist ((map_self (#4 preassigned)),
			       fp_double_tablespec))
      end


    (* A tuple of four table which map virtual onto real registers, *)
    (* for use by the final code generator. *)

    val virtual_to_real =
      (Table.table_of_alist
       ((#1 preassigned) @@
	map (fn r => (MirTypes.new_gc_register(), r)) MachSpec.gcs,
	gc_tablespec),

       Table.table_of_alist
       ((#2 preassigned) @@
	map (fn r => (MirTypes.new_non_gc_register(), r)) MachSpec.non_gcs,
	non_gc_tablespec),

       Table.table_of_alist
       ((#3 preassigned) @@
	map (fn r => (MirTypes.new_fp_register(), r)) MachSpec.fps,
	fp_tablespec),

       Table.table_of_alist
       ((#4 preassigned) @@
	map (fn r => (MirTypes.new_fp_double_register(), r))
	MachSpec.fp_doubles,
	fp_double_tablespec))


    (* A tuple of four lists containing the lists of virtual registers *)
    (* which correspond to real registers. These are used to `colour' *)
    (* for the virtual registers from the input code. *)

    val fresh_registers =
      (map #1 (Table.alist_of_table (#1 virtual_to_real)),
       map #1 (Table.alist_of_table (#2 virtual_to_real)),
       map #1 (Table.alist_of_table (#3 virtual_to_real)),
       map #1 (Table.alist_of_table (#4 virtual_to_real)))

    (* These are exported tables *)
    val gc_assign	= #1 virtual_to_real
    val non_gc_assign	= #2 virtual_to_real
    val fp_assign	= #3 virtual_to_real
    val fp_double_assign= #4 virtual_to_real

  end



d218 1
a218 1
   *  Divides a list of any_registers into a tuple of lists of the four
d226 2
a228 8
      | partition ((gc, non_gc, fp, fp_double), (GC reg)::rest) =
	partition ((reg::gc, non_gc, fp, fp_double), rest)
      | partition ((gc, non_gc, fp, fp_double), (NON_GC reg)::rest) =
	partition ((gc, reg::non_gc, fp, fp_double), rest)
      | partition ((gc, non_gc, fp, fp_double), (FLOAT reg)::rest) =
	partition ((gc, non_gc, reg::fp, fp_double), rest)
      | partition ((gc, non_gc, fp, fp_double), (DOUBLE reg)::rest) =
	partition ((gc, non_gc, fp, reg::fp_double), rest)
d230 5
a234 1
  end
d236 5
d242 5
a246 6
  (*  == Add edges from one to many ==
   *
   *  Adds edges from a single vertex to all the vertices in a
   *  list, using the function supplied. (This allows directed or
   *  undirected edges to be added.)
   *)
d248 5
a252 8
  fun add_edges add_function (graph, vertex, vertices') =
    let
      fun add (graph, []) = graph
	| add (graph, vertex'::vertices') =
	  add (add_function (graph, (vertex,vertex')), vertices')
    in
      add (graph, vertices')
    end
d254 1
a255 4
  (*  == Add edges between all vertices in a list ==
   *
   *  The edges are undirected(!)
   *)
a256 9
  fun add_net (graph, vertices) =
    let
      fun add (graph, []) = graph
	| add (graph, vertex'::vertices') =
	  add (add_edges Graph.add_edge (graph, vertex', vertices),
	       vertices')
    in
      add (graph, vertices)
    end
a257 2


d264 3
a266 2
  fun substitute (gc_table, non_gc_table, fp_table, fp_double_table)
		 procedure =
a267 1

d270 1
a270 4

      (*  == Substitute opcodes in a block ==  *)

      fun sub_block (MirOptTypes.BLOCK(tag, opcodes)) =
a271 4

	  val _ = info ("block " ^ MirTypes.print_tag tag)


d274 3
a276 42

	  (*  == Operand substitution functions ==
	   *
	   *  These look up the fresh register version of each operand type.
	   *)

	  fun sub_gp operand =
	    let
	      fun s (GP_GC_REG r) =
		  GP_GC_REG (Table.lookup (r, gc_table))
		| s (GP_NON_GC_REG r) =
		  GP_NON_GC_REG (Table.lookup (r, non_gc_table))
		| s operand = operand
	    in
	      s operand
	      handle Table.Lookup =>
		Crash.impossible
		("MirOptimiser (RegAlloc): Operand " ^
		 MirPrint.gp_operand operand ^ "in block " ^
		 MirTypes.print_tag tag ^ " has not been assigned a " ^
		 "fresh register.")
	    end

	  fun sub_reg operand =
	    let
	      fun s (GC_REG r) =
		  GC_REG (Table.lookup (r, gc_table))
		| s (NON_GC_REG r) =
		  NON_GC_REG (Table.lookup (r, non_gc_table))
	    in
	      s operand
	      handle Table.Lookup =>
		Crash.impossible
		("MirOptimiser (RegAlloc): Operand " ^
		 MirPrint.reg_operand operand ^ "in block " ^
		 MirTypes.print_tag tag ^ " has not been assigned a " ^
		 "fresh register.")
	    end

	  fun sub_fp (operand as (FP_REG r)) =
	    FP_REG (Table.lookup (r, fp_table))
	    handle Table.Lookup =>
d278 2
a279 4
	      ("MirOptimiser (RegAlloc): Operand " ^
	       MirPrint.fp_operand operand ^ "in block " ^
	       MirTypes.print_tag tag ^ " has not been assigned a " ^
	       "fresh register.")
d281 2
a282 79
	  fun sub_fp_double _ =
	    Crash.unimplemented ("MirOptimiser (RegAlloc): sub_fp_double")


	  (*  == Substitute registers in an opcode ==
	   *
	   *  Long and tedious.
	   *)

	  fun sub_op (TBINARY(operator, tag, reg, gp1, gp2)) =
	      TBINARY(operator, tag, sub_reg reg, sub_gp gp1, sub_gp gp2)

	    | sub_op (BINARY(operator, reg, gp1, gp2)) =
	      BINARY(operator, sub_reg reg, sub_gp gp1, sub_gp gp2)

	    | sub_op (UNARY(operator, reg, gp)) =
	      UNARY(operator, sub_reg reg, sub_gp gp)

	    | sub_op (BINARYFP(operator, fp1, fp2, fp3)) =
	      BINARYFP(operator, sub_fp fp1, sub_fp fp2, sub_fp fp3)

	    | sub_op (UNARYFP(operator, fp1, fp2)) =
	      UNARYFP(operator, sub_fp fp1, sub_fp fp2)

	    | sub_op (STACKOP(operator, reg)) =
	      STACKOP(operator, sub_reg reg)

	    | sub_op (STOREOP(operator, reg1, reg2, gp)) =
	      STOREOP(operator, sub_reg reg1, sub_reg reg2, sub_gp gp)

	    | sub_op (STOREFPOP(operator, fp, reg, gp)) =
	      STOREFPOP(operator, sub_fp fp, sub_reg reg, sub_gp gp)

	    | sub_op (CONVOP(operator, fp, gp)) =
	      CONVOP(operator, sub_fp fp, sub_gp gp)

	    | sub_op (BRANCH(operator, REG reg)) =
	      BRANCH(operator, REG (sub_reg reg))

	    | sub_op (TEST(operator, tag, gp1, gp2)) =
	      TEST(operator, tag, sub_gp gp1, sub_gp gp2)

	    | sub_op (FTEST(operator, tag, fp1, fp2)) =
	      FTEST(operator, tag, sub_fp fp1, sub_fp fp2)

	    | sub_op (BRANCH_AND_LINK(operator, REG reg)) =
	      BRANCH_AND_LINK(operator, REG (sub_reg reg))

	    | sub_op (SWITCH(operator, reg, tags)) =
	      SWITCH(operator, sub_reg reg, tags)

	    | sub_op (ALLOCATE(operator, reg, i)) =
	      ALLOCATE(operator, sub_reg reg, i)

	    | sub_op (ADR(operator, reg, tag)) =
	      ADR(operator, sub_reg reg, tag)

	    | sub_op (RAISE reg) =
	      RAISE(sub_reg reg)

	    | sub_op opcode = opcode


	  (*  === Substitute registers in annotated opcode ===
	   *
	   *  The live registers are invalidated by this, of course.
	   *)

	  fun sub_annotated_op (opcode, _, successors) =
	    (sub_op opcode, MirOptTypes.REGS_UNKNOWN, successors)


	  (* This is the neat part, just map onto the opcodes. *)

	  val new_block =
	    MirOptTypes.BLOCK(tag, map sub_annotated_op opcodes)

	  val _ = code_info (MirOptTypes.print_block new_block)

d284 1
a284 1
	  new_block
d287 1
d290 1
a290 1
      MirOptTypes.proc_map sub_block procedure
d294 4
d305 2
a306 1
   *  the registers (vertices).
d309 4
a312 2
  fun augment_clash_graphs (gc_graph, non_gc_graph, fp_graph, fp_double_graph)
                           registers =
d314 4
a317 2
      val (gc, non_gc, fp, fp_double) =
	partition (([], [], [], []), Set.set_to_list registers)
d319 4
a322 4
      (add_net(gc_graph, gc),
       add_net(non_gc_graph, non_gc),
       add_net(fp_graph, fp),
       add_net(fp_double_graph, fp_double))
a331 4
   *
   *  This function takes a tuple of reference graphs, a set of live
   *  registers and a set of referenced registers and adds _directed_
   *  edges from the live to the referenced registers.
d334 5
a338 3
  fun augment_reference_graphs
      (gc_graph, non_gc_graph, fp_graph, fp_double_graph)
      (live, referenced) =
d341 1
a341 5
      fun add (graph, live, referenced) =
	Lists.reducel
	(fn (graph, live_reg) =>
	 add_edges Graph.add_directed_edge (graph, live_reg, referenced))
	(graph, live)
d343 5
a347 2
      val (gc_live, non_gc_live, fp_live, fp_double_live) =
	partition (([], [], [], []), Set.set_to_list live)
d349 5
a353 2
      val (gc_ref, non_gc_ref, fp_ref, fp_double_ref) =
	partition (([], [], [], []), Set.set_to_list referenced)
d356 4
a359 4
      (add (gc_graph, gc_live, gc_ref),
       add (non_gc_graph, non_gc_live, non_gc_ref),
       add (fp_graph, fp_live, fp_ref),
       add (fp_double_graph, fp_double_live, fp_double_ref))
d364 1
a364 1
  (*  === GENERATE CLASH GRAPHS IN A BLOCK ===
d366 1
a366 1
   *  For a single block, add register clashes within that block to the
d370 1
a370 1
  fun block_generate graphs (MirOptTypes.BLOCK(tag, opcodes)) =
d372 1
d374 4
a377 1
      val _ = info ("block " ^ MirTypes.print_tag tag)
d379 1
a379 10
      fun process (graphs, []) = graphs

	| process ((live_graphs, reference_graphs),
		   (opcode, MirOptTypes.REGS(live,referenced), succs)::rest) =
	  process
	  ((augment_clash_graphs live_graphs live,
	    augment_reference_graphs reference_graphs (live, referenced)),
	   rest)

	| process _ =
d381 2
a382 3
	  ("MirOptimiser (RegAlloc): I've been given code which has not "^
	   "been analysed for live registers. MirRegisters should be "^
	   "applied before RegisterAllocator.")
d385 1
a385 1
      process (graphs, opcodes)
a388 5
  (*  === GENERATE CLASH GRAPHS IN A PROCEDURE ===
   *
   *  For an entire procedure, add register clashes in all blocks to the
   *  clash graphs.
   *)
a389 8
  fun proc_generate graphs (proc as MirOptTypes.PROC(start_tag, _, _)) =
    (
      info ("procedure " ^ MirTypes.print_tag start_tag);
      MirOptTypes.proc_fold block_generate graphs proc
    )



d398 1
a398 1
  fun colour_graphs (gc, non_gc, fp, fp_double) =
d406 1
a406 1
	 colours	= #1 fresh_registers,
d408 2
a409 2
	 precoloured	= #1 precolours,
	 forbidden	= Table.empty_table gc_tablespec}
d416 1
a416 1
	 colours	= #2 fresh_registers,
d418 2
a419 2
	 precoloured	= #2 precolours,
	 forbidden	= Table.empty_table non_gc_tablespec}
d426 1
a426 1
	 colours	= #3 fresh_registers,
d428 2
a429 2
	 precoloured	= #3 precolours,
	 forbidden	= Table.empty_table fp_tablespec}
d436 1
a436 1
	 colours	= #4 fresh_registers,
d438 2
a439 2
	 precoloured	= #4 precolours,
	 forbidden	= Table.empty_table fp_double_tablespec}
d443 4
a446 4
      (gc_assignments,
       non_gc_assignments,
       fp_assignments,
       fp_double_assignments)
d516 3
a518 1
  fun analyse (proc as MirOptTypes.PROC(start_tag, _, _)) =
d522 1
a522 2
      val (clash_graphs as (gc,non_gc,fp,fp_double),
	   ref_graphs as (gc_ref, non_gc_ref, fp_ref, fp_double_ref)) =
d525 2
a526 9
      val _ =
	info ("\n  GC clash graph: " ^
	      Graph.print (MirTypes.print_gc_register, gc) ^
	      "\n  NON_GC clash graph: " ^ 
	      Graph.print (MirTypes.print_non_gc_register, non_gc) ^
	      "\n  FP clash graph: " ^
	      Graph.print (MirTypes.print_fp_register, fp) ^
	      "\n  FP_DOUBLE clash graph: " ^
	      Graph.print (MirTypes.print_fp_double_register, fp_double))
d528 1
a528 9
      val _ =
	info ("\n  GC reference graph: " ^
	      Graph.print (MirTypes.print_gc_register, gc_ref) ^
	      "\n  NON_GC reference graph: " ^ 
	      Graph.print (MirTypes.print_non_gc_register, non_gc_ref) ^
	      "\n  FP reference graph: " ^
	      Graph.print (MirTypes.print_fp_register, fp_ref) ^
	      "\n  FP_DOUBLE reference graph: " ^
	      Graph.print (MirTypes.print_fp_double_register, fp_double_ref))
d530 1
a530 8
      fun p(m,f,(x,x')) =
	info (m ^ "\n" ^
	      (Lists.reducel op^
	       ("",
		map
		(fn (r,c) => f r ^ " := " ^ f c ^ "\n")
		(Table.alist_of_table x))) ^
	      (Lists.to_string f x'))
d532 5
a536 1
      val _ = info "Colouring graphs..."
d538 17
a554 2
      val (gc,non_gc,fp,fp_double) =
	colour_graphs clash_graphs
d556 3
a558 1
      val _ = info "Printing assignments..."
d560 1
a560 4
      val _ = p ("GC colours:", MirTypes.print_gc_register, gc)
      val _ = p ("NON_GC colours:", MirTypes.print_non_gc_register, non_gc)
      val _ = p ("FP colours:", MirTypes.print_fp_register, fp)
      val _ = p ("FP_DOUBLE colours:", MirTypes.print_fp_double_register, fp_double)
d562 1
a562 1
      val assignments = (#1 gc, #1 non_gc, #1 fp, #1 fp_double)
d564 3
a566 29
    in
      if #2 gc = [] andalso #2 non_gc = []
	andalso #2 fp = [] andalso #2 fp_double = [] then
	let
	  val used =
	    {gc = Set.list_to_set (map #2 (Table.alist_of_table (#1 assignments))),
	     non_gc = Set.list_to_set (map #2 (Table.alist_of_table (#2 assignments))),
	     fp = Set.list_to_set (map #2 (Table.alist_of_table (#3 assignments))),
	     fp_double = Set.list_to_set (map #2 (Table.alist_of_table (#4 assignments)))}

	  val MirOptTypes.PROC(start_tag,
			       MirTypes.PROC_PARAMS {leaf,
						     registers_used,
						     spill_sizes,
						     stack_allocated},
			       blocks) =
	    substitute assignments proc
	in
	  MirOptTypes.PROC(start_tag,
			   MirTypes.PROC_PARAMS
			   {leaf = leaf,
			    registers_used = MirTypes.PRESENT used,
			    spill_sizes = spill_sizes,
			    stack_allocated = stack_allocated},
			   blocks)
	end
      else
	Crash.unimplemented
	("MirOptimiser (RegAlloc): Register spilling not implemented.")
@


1.13
log
@Added a rather hacked bit of code to pass out the sets of registers
used by a procedure. Will fix this properly later.
@
text
@d4 4
d154 3
d159 1
a159 12
  val gc_preassignments =
    [(MirRegisters.caller_arg,		MachSpec.caller_arg),
     (MirRegisters.caller_closure,	MachSpec.caller_closure),
     (MirRegisters.fp,			MachSpec.fp),
     (MirRegisters.sp,			MachSpec.sp),
     (MirRegisters.handler,		MachSpec.handler),
     (MirRegisters.global,		MachSpec.global)] @@
    if MirRegisters.automatic_callee then
      [(MirRegisters.callee_arg,	MachSpec.callee_arg),
       (MirRegisters.callee_closure,	MachSpec.callee_closure)]
    else
      []
d161 4
a164 1
  val preassigned_gc_registers = map #1 gc_preassignments
d166 13
a178 2
  val fresh_gc_registers =
    map (fn _ => MirTypes.new_gc_register()) MachSpec.gcs
d180 1
a180 5
  val gc_assign =
    Table.table_of_alist
    (gc_preassignments @@
     (Lists.zip (fresh_gc_registers, MachSpec.gcs)),
     Table.TableSpec { order = MirTypes.order_gc_register, eq = op= })
d182 8
a189 2
  val fresh_non_gc_registers =
    map (fn _ => MirTypes.new_non_gc_register()) MachSpec.non_gcs
d191 5
a195 4
  val non_gc_assign =
    Table.table_of_alist
    ((Lists.zip (fresh_non_gc_registers, MachSpec.non_gcs)),
     Table.TableSpec { order = MirTypes.order_non_gc_register, eq = op= })
d197 13
a209 2
  val fresh_fp_registers =
    map (fn _ => MirTypes.new_fp_register()) MachSpec.fps
a210 4
  val fp_assign =
    Table.table_of_alist
    ((Lists.zip (fresh_fp_registers, MachSpec.fps)),
     Table.TableSpec { order = MirTypes.order_fp_register, eq = op= })
d212 2
a213 2
  val fresh_fp_double_registers =
    map (fn _ => MirTypes.new_fp_double_register()) MachSpec.fp_doubles
d215 5
a219 4
  val fp_double_assign =
    Table.table_of_alist
    ((Lists.zip (fresh_fp_double_registers, MachSpec.fp_doubles)),
     Table.TableSpec { order = MirTypes.order_fp_double_register, eq = op= })
d221 4
d226 4
d231 27
d320 2
d446 3
a492 3

      val gc_without_preassigned =
	Lists.difference (gc, preassigned_gc_registers)
d494 1
a494 1
      (add_net(gc_graph, gc_without_preassigned),
a596 8
      val (gc_table, gc_left) =
	Graph.colour
	Graph.GREEDY
	(gc, fresh_gc_registers, MirTypes.order_gc_register)

      (* Add the preassigned registers to the assignments, mapping *)
      (* them onto themselves. *)

d598 6
a603 4
	(Lists.reducel
	 (fn (table, reg) => Table.add_new ((reg, reg), table))
	 (gc_table, preassigned_gc_registers),
	 gc_left)
d608 6
a613 3
	Graph.colour
	Graph.GREEDY
	(non_gc, fresh_non_gc_registers, MirTypes.order_non_gc_register)
d618 6
a623 3
	Graph.colour
	Graph.GREEDY
	(fp, fresh_fp_registers, MirTypes.order_fp_register)
d628 7
a634 5
	Graph.colour
	Graph.GREEDY
	(fp_double,
	 fresh_fp_double_registers,
	 MirTypes.order_fp_double_register)
@


1.12
log
@Slight alterations to cope with new MirTypes.
@
text
@d4 3
d83 1
a83 1
  sharing Set = MirOptTypes.Set = Graph.Set
a701 1

d704 23
a726 1
	substitute assignments proc
@


1.11
log
@Uses ordered lists of real registers rather than sets. The order
indicates allocation preferences.
@
text
@d4 4
d100 3
a102 1
    if show_info then print ("MIR Optimiser (RegAlloc): "^message) else ();
d105 3
a107 1
    if show_code then print message else ();
d515 1
a515 1
  fun proc_generate graphs (proc as MirOptTypes.PROC(start_tag, _)) =
d647 1
a647 1
  fun analyse (proc as MirOptTypes.PROC(start_tag, _)) =
@


1.10
log
@Changed register names for register window machines and removed
RESTORE_REGS and PRESERVE_REGS.
@
text
@d76 1
a76 1
  sharing Set = MirOptTypes.Set = MachSpec.Set = Graph.Set
d141 12
a152 1
  local
d154 1
a154 8
    val machine_gc_registers =
      Set.set_to_list MachSpec.gcs
    val machine_non_gc_registers =
      Set.set_to_list MachSpec.non_gcs
    val machine_fp_registers =
      Set.set_to_list MachSpec.fps
    val machine_fp_double_registers =
      Set.set_to_list MachSpec.fp_doubles
d156 2
a157 1
  in
d159 5
a163 12
    val gc_preassignments =
      [(MirRegisters.caller_arg,	MachSpec.caller_arg),
       (MirRegisters.caller_closure,	MachSpec.caller_closure),
       (MirRegisters.fp,		MachSpec.fp),
       (MirRegisters.sp,		MachSpec.sp),
       (MirRegisters.handler,		MachSpec.handler),
       (MirRegisters.global,		MachSpec.global)] @@
      if MirRegisters.automatic_callee then
	[(MirRegisters.callee_arg,	MachSpec.callee_arg),
	 (MirRegisters.callee_closure,	MachSpec.callee_closure)]
      else
	[]
d165 2
a166 1
    val preassigned_gc_registers = map #1 gc_preassignments
d168 4
a171 4
    val fresh_gc_registers =
      map
      (fn _ => MirTypes.new_gc_register())
      machine_gc_registers
d173 2
a174 5
    val gc_assign =
      Table.table_of_alist
      (gc_preassignments @@
       (Lists.zip (fresh_gc_registers, machine_gc_registers)),
       Table.TableSpec { order = MirTypes.order_gc_register, eq = op= })
d176 4
a179 4
    val fresh_non_gc_registers =
      map
      (fn _ => MirTypes.new_non_gc_register())
      machine_non_gc_registers
d181 2
a182 4
    val non_gc_assign =
      Table.table_of_alist
      ((Lists.zip (fresh_non_gc_registers, machine_non_gc_registers)),
       Table.TableSpec { order = MirTypes.order_non_gc_register, eq = op= })
d184 4
a187 22
    val fresh_fp_registers =
      map
      (fn _ => MirTypes.new_fp_register())
      machine_fp_registers

    val fp_assign =
      Table.table_of_alist
      ((Lists.zip (fresh_fp_registers, machine_fp_registers)),
       Table.TableSpec { order = MirTypes.order_fp_register, eq = op= })

    val fresh_fp_double_registers =
      map
      (fn _ => MirTypes.new_fp_double_register())
      machine_fp_double_registers

    val fp_double_assign =
      Table.table_of_alist
      ((Lists.zip (fresh_fp_double_registers, machine_fp_double_registers)),
       Table.TableSpec { order = MirTypes.order_fp_double_register, eq = op= })


  end
@


1.9
log
@Changed names of closure and argument registers. Not complete.
@
text
@d4 3
d154 15
d176 1
a176 6
      ([(MirRegisters.caller_arg,	MachSpec.caller_arg),
	(MirRegisters.caller_closure,	MachSpec.caller_closure),
	(MirRegisters.fp,	MachSpec.fp),
	(MirRegisters.sp,	MachSpec.sp),
	(MirRegisters.handler,	MachSpec.handler),
	(MirRegisters.global,	MachSpec.global)] @@
a209 7
    val preassigned_gc_registers =
      [MirRegisters.caller_arg,
       MirRegisters.caller_closure,
       MirRegisters.fp,
       MirRegisters.sp,
       MirRegisters.handler,
       MirRegisters.global]
a399 6

	    | sub_op (PRESERVE_REGS(regs, fps)) =
	      PRESERVE_REGS(map sub_reg regs, map sub_fp fps)

	    | sub_op (RESTORE_REGS(regs, fps)) =
	      RESTORE_REGS(map sub_reg regs, map sub_fp fps)
@


1.8
log
@Adapted allocator to use new version of the graph module which is more
efficient when building graphs. Started work on spill allocation.
@
text
@d4 4
d158 2
a159 2
      ([(MirRegisters.fn_arg,	MachSpec.fn_arg),
	(MirRegisters.cl_arg,	MachSpec.cl_arg),
d198 2
a199 2
      [MirRegisters.fn_arg,
       MirRegisters.cl_arg,
@


1.7
log
@Changed dependency on MachRegisters to MachSpec.
@
text
@d4 3
d42 1
d64 1
d116 4
a119 4
    (Graph.empty MirTypes.order_gc_register,
     Graph.empty MirTypes.order_non_gc_register,
     Graph.empty MirTypes.order_fp_register,
     Graph.empty MirTypes.order_fp_double_register)
d242 1
a242 1
	  add (add_function ((vertex,vertex'), graph), vertices')
d499 2
d527 5
a531 2
  val proc_generate =
    MirOptTypes.proc_fold block_generate
d545 3
d549 3
a551 1
	Graph.colour Graph.GREEDY (gc, fresh_gc_registers)
d553 3
d562 2
d565 3
a567 1
	Graph.colour Graph.GREEDY (non_gc, fresh_non_gc_registers)
d569 2
d572 3
a574 1
	Graph.colour Graph.GREEDY (fp, fresh_fp_registers)
d576 2
d579 5
a583 1
	Graph.colour Graph.GREEDY (fp_double, fresh_fp_double_registers)
d595 11
d608 7
d616 41
d661 1
a661 1
      val _ = info ("procedure " ^ MirTypes.print_tag start_tag)
d696 2
d701 2
a708 7

(*      val (sgc, snon_gc, sfp, sfp_double) =
	(allocate_spills (gc, gc_ref, fresh_gc_registers, MirTypes.order_gc_register, MirTypes.print_gc_register),
	 allocate_spills (gc, gc_ref, fresh_gc_registers, MirTypes.order_gc_register, MirTypes.print_gc_register),
	 allocate_spills (gc, gc_ref, fresh_gc_registers, MirTypes.order_gc_register, MirTypes.print_gc_register),
	 allocate_spills (gc, gc_ref, fresh_gc_registers, MirTypes.order_gc_register, MirTypes.print_gc_register))
*)
@


1.6
log
@Changed dependency on MachTypes to MachRegisters to remove target
machine dependence. Other minor tidying.
@
text
@d4 4
d39 1
a39 1
require "../machine/machregisters";
d53 1
a53 1
  structure MachRegisters	: MACHREGISTERS
d64 1
a64 1
  sharing Set = MirOptTypes.Set = MachRegisters.Set
d72 1
a72 1
  structure MachRegisters = MachRegisters
d132 1
a132 1
      Set.set_to_list MachRegisters.gcs
d134 1
a134 1
      Set.set_to_list MachRegisters.non_gcs
d136 1
a136 1
      Set.set_to_list MachRegisters.fps
d138 1
a138 1
      Set.set_to_list MachRegisters.fp_doubles
d149 6
a154 6
      ([(MirRegisters.fn_arg,	MachRegisters.fn_arg),
	(MirRegisters.cl_arg,	MachRegisters.cl_arg),
	(MirRegisters.fp,	MachRegisters.fp),
	(MirRegisters.sp,	MachRegisters.sp),
	(MirRegisters.handler,	MachRegisters.handler),
	(MirRegisters.global,	MachRegisters.global)] @@
d563 3
d570 2
d614 7
@


1.5
log
@The virtual registers are now coloured with more virtual registers, which
are then substituted in the procedure. Tables are returned with the
modified code which map the new virtual registers on to real machine
registers. The idea is that the code is still tractable by the other
optimisation modules in this state.
@
text
@d4 7
d35 1
a35 1
require "../machine/machtypes";
d45 11
a55 11
  structure MirTypes	: MIRTYPES
  structure MirOptTypes	: MIROPTTYPES
  structure MirPrint	: MIRPRINT
  structure MirRegisters: MIRREGISTERS
  structure MachTypes	: MACHTYPES
  structure Graph	: GRAPH
  structure Table	: TABLE
  structure Set		: SET
  structure Lists	: LISTS
  structure Print	: PRINT
  structure Crash	: CRASH
d60 1
a60 1
  sharing Set = MirOptTypes.Set = MachTypes.Set
d68 1
d73 1
a73 1
  val show_code = true;		(* false to disable listings *)
a88 3
  type ''virtual_register assignment =
    (''virtual_register, MachTypes.Sparc_Reg) Table.table

d113 2
a114 1
  (*  == The real registers ==
d127 8
a134 4
    val machine_gc_registers = Set.set_to_list MachTypes.gc_registers
    val machine_non_gc_registers = Set.set_to_list MachTypes.non_gc_registers
    val machine_fp_registers = [] (******)
    val machine_fp_double_registers = [] (******)
d143 1
a143 1
    val gc_real_table =
d145 6
a150 6
      ([(MirRegisters.fn_arg,	MachTypes.fn_arg),
	(MirRegisters.cl_arg,	MachTypes.cl_arg),
	(MirRegisters.fp,	MachTypes.fp),
	(MirRegisters.sp,	MachTypes.sp),
	(MirRegisters.handler,	MachTypes.handler),
	(MirRegisters.global,	MachTypes.global)] @@
d159 1
a159 1
    val non_gc_real_table =
d169 1
a169 1
    val fp_real_table =
d179 1
a179 1
    val fp_double_real_table =
d608 6
a613 2
      (substitute assignments proc,
       (gc_real_table, non_gc_real_table, fp_real_table, fp_double_real_table))
@


1.4
log
@Included actual machine registers. Further development of register
allocation including graphs for spill heuristics.
@
text
@d4 4
d60 2
d81 3
d110 7
a116 1
   *  NOTE: These are hacked for debugging purposes.
d119 1
a119 5
  val real_registers =
    (Set.set_to_list MachTypes.spillable_regs,
     Set.set_to_list MachTypes.non_gc_registers,
     [],
     [])
d121 4
a124 7
  val preassigned_gc_registers =
    [MirRegisters.fn_arg,
     MirRegisters.cl_arg,
     MirRegisters.fp,
     MirRegisters.sp,
     MirRegisters.handler,
     MirRegisters.global]
d126 1
a126 10
  val preassignments =
    Table.table_of_alist
    ([(MirRegisters.fn_arg,	MachTypes.fn_arg),
      (MirRegisters.cl_arg,	MachTypes.cl_arg),
      (MirRegisters.fp,	MachTypes.fp),
      (MirRegisters.sp,	MachTypes.sp),
      (MirRegisters.handler,	MachTypes.handler),
      (MirRegisters.global,	MachTypes.global)],
     Table.TableSpec { order = MirTypes.order_gc_register,
		       eq = op= })
d128 4
d133 10
d144 42
d246 164
d511 1
a511 1
  (*  === COLOUR CLASH GRAPHS USING MACHINE REGISTERS ===
d513 4
d519 4
a522 7
  fun colour_graphs (gc, non_gc, fp, fp_double)
                    (gc_reg, non_gc_reg, fp_reg, fp_double_reg) =
    (Graph.colour Graph.GREEDY (gc, gc_reg),
     Graph.colour Graph.GREEDY (non_gc, non_gc_reg),
     Graph.colour Graph.GREEDY (fp, fp_reg),
     Graph.colour Graph.GREEDY (fp_double, fp_double_reg))
     
d524 5
d530 2
d533 16
d582 1
a582 1
		(fn (r,c) => f r ^ " := " ^ MachTypes.reg_to_string c ^ "\n")
d587 1
a587 1
	colour_graphs clash_graphs real_registers
d594 2
d597 4
a600 1
      proc
@


1.3
log
@Rewrote clash graph generator. It now generates separate graphs for the
different types of registers. These will, after all, have to be assigned
to differnt real registers.
@
text
@d4 5
d24 2
d37 2
d46 2
a47 1
  sharing MirTypes = MirOptTypes.MirTypes = MirPrint.MirTypes
d49 1
a49 1
  sharing Set = MirOptTypes.Set
d99 1
a99 1
  (*  == The available registers ==
d101 1
a101 2
   *  This is only a temporary feature. These are the lists of registers
   *  available for allocation from the graphs above.
d105 4
a108 4
    (["green", "globular", "goofy", "gaffer", "goon", "gnome"],
     ["noon", "noodle", "nonce", "nibble", "noddy", "nodule"],
     ["fudge", "foople", "fungus", "feeple", "fig", "fan"],
     ["doobry", "dungeon", "dark", "discipline", "doctor"])
d110 7
d118 10
d129 62
d198 2
a199 2
  fun augment_graphs (gc_graph, non_gc_graph, fp_graph, fp_double_graph)
                     registers =
d201 2
a202 1
      open MirTypes
d204 8
a211 2
      (* Divide a list of any_registers into a tuple of lists of the four *)
      (* register types. *)
a212 9
      fun partition (lists, []) = lists
	| partition ((gc, non_gc, fp, fp_double), (GC reg)::rest) =
	  partition ((reg::gc, non_gc, fp, fp_double), rest)
	| partition ((gc, non_gc, fp, fp_double), (NON_GC reg)::rest) =
	  partition ((gc, reg::non_gc, fp, fp_double), rest)
	| partition ((gc, non_gc, fp, fp_double), (FLOAT reg)::rest) =
	  partition ((gc, non_gc, reg::fp, fp_double), rest)
	| partition ((gc, non_gc, fp, fp_double), (DOUBLE reg)::rest) =
	  partition ((gc, non_gc, fp, reg::fp_double), rest)
a213 2
      (* Add edges from a list of registers to all registers in another *)
      (* list. *)
d215 10
a224 11
      fun add_edges (graph, _, []) = graph
	| add_edges (graph, regs', reg::regs) =
	  let
	    val new_graph =
	      Lists.reducel
	      (fn (graph,reg') =>
	       Graph.add_edge((reg',reg), Graph.add_vertex(reg', graph)))
	      (graph, regs')
	  in
	    add_edges (new_graph, regs', regs)
	  end
d226 4
a229 2
      val (gc, non_gc, fp, fp_double) =
	partition (([], [], [], []), Set.set_to_list registers)
d231 12
d244 4
a247 4
      (add_edges(gc_graph, gc, gc),
       add_edges(non_gc_graph, non_gc, non_gc),
       add_edges(fp_graph, fp, fp),
       add_edges(fp_double_graph, fp_double, fp_double))
d263 6
a268 2
	| process (graphs, (opcode, MirOptTypes.REGS(live,_), succs)::rest) =
	  process (augment_graphs graphs live, rest)
d287 2
a288 2
  fun proc_generate graphs proc =
    MirOptTypes.proc_fold block_generate empty_graphs proc
d292 14
d310 4
a313 2
      val block = MirOptTypes.get_block proc start_tag
      val (gc,non_gc,fp,fp_double) = block_generate empty_graphs block
d315 9
a323 1
	info ("GC graph: " ^ (Graph.print (MirTypes.print_gc_register, gc)))
d325 25
a349 5
	info ("NON_GC graph: " ^ (Graph.print (MirTypes.print_non_gc_register, non_gc)))
      val _ =
	info ("FP graph: " ^ (Graph.print (MirTypes.print_fp_register, fp)))
      val _ =
	info ("FP_DOUBLE graph: " ^ (Graph.print (MirTypes.print_fp_double_register, fp_double)))
@


1.2
log
@Simple register allocation within a single block.
@
text
@d4 3
d63 1
a63 1
  val empty_register_graph = Graph.empty MirTypes.order_any_reg
d65 5
d71 41
a111 1
  fun analyse_block (MirOptTypes.BLOCK(tag, opcodes)) =
d113 1
a113 1
      fun analyse_ops (graph, []) = graph
d115 2
a116 4
	| analyse_ops (_, (_, MirOptTypes.REGS_UNKNOWN, _)::_) =
	  Crash.impossible
	  ("MirOptimiser (RegAlloc): I've been given code which doesn't "^
	   "have the live register information attached.")
d118 9
a126 2
        | analyse_ops (graph, (_, MirOptTypes.REGS registers, _)::rest) =
	let
d128 2
a129 1
	  val regs' = Set.set_to_list registers
d131 11
a141 4
	  fun add_edges (graph, []) = graph
	    | add_edges (graph, reg::regs) =
	      let
		val graph_with_reg = Graph.add_vertex(reg, graph)
d143 2
a144 11
		val graph_with_edges =
		  Lists.reducel
		  (fn (graph,reg') =>
		   if reg=reg' then
		     graph
		   else
		     Graph.add_edge((reg,reg'),graph))
		  (graph_with_reg, regs')
	      in
		add_edges (graph_with_edges, regs)
	      end
d146 6
a151 1
	  val new_graph = add_edges (graph, regs')
a152 3
	in
	  analyse_ops (new_graph, rest)
	end
d154 21
d176 1
a176 1
      analyse_ops (empty_register_graph, opcodes)
d180 5
d186 7
d196 1
a196 5
      val graph = analyse_block block
      val _ = info ("Clash graph: " ^ (Graph.print (MirPrint.any_reg, graph)))
      val registers =
	["Red", "Orange", "Yellow", "Green", "Blue"]
      val (table, leftover) = Graph.colour Graph.GREEDY (graph,registers)
d198 1
a198 4
	info ("Assignments: " ^
	      (Lists.to_string
	       (fn(x,y) => MirPrint.any_reg x ^ " -> " ^ y)
	       (MirOptTypes.Table.alist_of_table table)))
d200 6
a205 2
	info ("Unassigned: " ^
	      (Lists.to_string MirPrint.any_reg leftover))
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
(* $Log$
d12 5
d26 1
d29 4
d34 3
a36 2
  sharing MirTypes = MirOptTypes.MirTypes
  sharing Table = Graph.Table
d45 80
a124 1
  fun analyse x = x
@
