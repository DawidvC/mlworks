head	1.45;
access;
symbols
	MLW_daveb_inline_1_4_99:1.45.1
	MLWorks_21c0_1999_03_25:1.45
	MLWorks_20c1_1998_08_20:1.44
	MLWorks_20c0_1998_08_04:1.44
	MLWorks_20b2c2_1998_06_19:1.44
	MLWorks_20b2_Windows_1998_06_12:1.44
	MLWorks_20b1c1_1998_05_07:1.44
	MLWorks_20b0_1998_04_07:1.44
	MLWorks_20b0_1998_03_20:1.44
	MLWorks_20m2_1998_02_16:1.44
	MLWorks_20m1_1997_10_23:1.44
	MLWorks_11r1:1.44.5.1.1.1.1
	MLWorks_workspace_97:1.44.7
	MLWorks_dt_wizard:1.44.6
	MLWorks_11c0_1997_09_09:1.44.5.1.1.1
	MLWorks_10r3:1.44.5.1.3
	MLWorks_10r2_551:1.44.5.1.2
	MLWorks_11:1.44.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.44.5.1
	MLWorks_20m0_1997_06_20:1.44
	MLWorks_1_0_r2c2_1997_06_14:1.44.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.44.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.44.5
	MLWorks_BugFix_1997_04_24:1.44
	MLWorks_1_0_r2_Win32_1997_04_11:1.44
	MLWorks_1_0_r2_Unix_1997_04_04:1.44
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.44.3.1.1
	MLWorks_gui_1996_12_18:1.44.4
	MLWorks_1_0_Win32_1996_12_17:1.44.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.44.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.44.1.1
	MLWorks_1_0_Irix_1996_11_28:1.44.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.44.2
	MLWorks_1_0_Unix_1996_11_14:1.44.1
	MLWorks_Open_Beta2_1996_10_11:1.41.3
	MLWorks_License_dev:1.41.2
	MLWorks_1_open_beta_1996_09_13:1.41.1
	MLWorks_Open_Beta_1996_08_22:1.41
	MLWorks_Beta_1996_07_02:1.39
	MLWorks_Beta_1996_06_07:1.39
	MLWorks_Beta_1996_06_06:1.39
	MLWorks_Beta_1996_06_05:1.39
	MLWorks_Beta_1996_06_03:1.39
	MLWorks_Beta_1996_05_31:1.39
	MLWorks_Beta_1996_05_30:1.39
	ML_beta_release_12/08/94:1.27
	ML_beta_release_03/08/94:1.27
	ML_revised_beta_release_25/05/94:1.24
	ML_final_beta_release_02/03/94:1.23
	mlworks-28-01-1994:1.21
	Release:1.19
	mlworks-beta-01-09-1993:1.19
	MLWorks-1-0-4-29/01/1993:1.14
	MLWorks-1-0-3-21/12/1992:1.13
	MLWorks-1-0-2-15/12/1992:1.13
	MLWorks-1-0-1-04/12/1992:1.13
	checkpoint_17_08_92:1.7;
locks; strict;
comment	@ * @;


1.45
date	98.08.24.11.27.49;	author jont;	state Exp;
branches
	1.45.1.1;
next	1.44;

1.44
date	96.11.06.11.22.14;	author matthew;	state Exp;
branches
	1.44.1.1
	1.44.2.1
	1.44.3.1
	1.44.4.1
	1.44.5.1
	1.44.6.1
	1.44.7.1;
next	1.43;

1.43
date	96.10.30.19.23.22;	author io;	state Exp;
branches;
next	1.42;

1.42
date	96.10.30.19.21.23;	author io;	state Exp;
branches;
next	1.41;

1.41
date	96.08.05.17.10.17;	author andreww;	state Exp;
branches
	1.41.1.1
	1.41.2.1
	1.41.3.1;
next	1.40;

1.40
date	96.08.01.12.01.38;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	96.04.30.16.11.04;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	96.04.29.15.04.15;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	96.03.19.14.37.47;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	96.02.23.17.13.24;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	96.02.22.13.17.55;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	95.12.27.11.57.16;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	95.08.10.14.53.02;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	95.03.17.14.40.01;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	95.03.02.11.35.28;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	95.02.17.11.40.58;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	95.01.30.11.14.26;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	94.09.13.10.06.13;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	94.06.22.11.32.38;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	94.06.14.15.46.15;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	94.06.10.15.52.18;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	94.05.05.13.48.46;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	94.02.28.07.39.16;	author nosa;	state Exp;
branches;
next	1.22;

1.22
date	94.02.25.15.57.31;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	93.12.09.19.27.11;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	93.09.22.16.01.05;	author nosa;	state Exp;
branches;
next	1.19;

1.19
date	93.07.12.08.56.17;	author nosa;	state Exp;
branches
	1.19.1.1;
next	1.18;

1.18
date	93.05.18.13.42.16;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	93.03.11.12.04.43;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.03.04.12.12.36;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.03.02.17.14.08;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	92.12.07.16.38.37;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.11.26.19.17.21;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	92.11.26.16.53.23;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.11.18.12.06.21;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.10.09.14.10.00;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.10.05.15.16.11;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	92.09.10.10.00.56;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	92.07.20.16.45.32;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.07.16.16.29.26;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.07.06.14.09.13;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	92.06.30.10.17.10;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.06.30.09.42.03;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.06.30.09.34.46;	author clive;	state Exp;
branches;
next	1.1;

1.1
date	92.06.29.11.08.27;	author clive;	state Exp;
branches;
next	;

1.19.1.1
date	93.07.12.08.56.17;	author jont;	state Exp;
branches;
next	;

1.41.1.1
date	96.09.13.11.11.13;	author hope;	state Exp;
branches;
next	;

1.41.2.1
date	96.10.07.16.01.59;	author hope;	state Exp;
branches;
next	;

1.41.3.1
date	96.10.17.11.20.14;	author hope;	state Exp;
branches;
next	;

1.44.1.1
date	96.11.14.12.43.49;	author hope;	state Exp;
branches
	1.44.1.1.1.1;
next	;

1.44.1.1.1.1
date	96.11.28.14.55.44;	author hope;	state Exp;
branches;
next	;

1.44.2.1
date	96.11.22.18.04.15;	author hope;	state Exp;
branches;
next	;

1.44.3.1
date	96.12.17.17.43.12;	author hope;	state Exp;
branches
	1.44.3.1.1.1;
next	;

1.44.3.1.1.1
date	97.02.24.11.31.56;	author hope;	state Exp;
branches;
next	;

1.44.4.1
date	96.12.18.09.37.10;	author hope;	state Exp;
branches;
next	;

1.44.5.1
date	97.05.12.10.29.20;	author hope;	state Exp;
branches
	1.44.5.1.1.1
	1.44.5.1.2.1
	1.44.5.1.3.1;
next	;

1.44.5.1.1.1
date	97.07.28.18.15.13;	author daveb;	state Exp;
branches
	1.44.5.1.1.1.1.1;
next	;

1.44.5.1.1.1.1.1
date	97.10.07.11.40.17;	author jkbrook;	state Exp;
branches;
next	;

1.44.5.1.2.1
date	97.09.08.17.08.40;	author daveb;	state Exp;
branches;
next	;

1.44.5.1.3.1
date	97.09.09.14.03.48;	author daveb;	state Exp;
branches;
next	;

1.44.6.1
date	97.09.10.19.18.20;	author brucem;	state Exp;
branches;
next	;

1.44.7.1
date	97.09.11.20.49.16;	author daveb;	state Exp;
branches;
next	;

1.45.1.1
date	99.04.01.17.53.10;	author daveb;	state Exp;
branches;
next	;


desc
@Initial version
@


1.45
log
@[Bug #70168]
Resolve overloading when printing types if necessary
@
text
@(* _debugger_types the functor *)
(*
$Log: _debugger_types.sml,v $
 * Revision 1.44  1996/11/06  11:22:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.43  1996/10/30  19:23:22  io
 * [Bug #1614]
 * removing toplevel String.
 *
 * Revision 1.42  1996/10/30  19:21:23  io
 * [Bug #1614]
 * removing toplevel String.
 *
 * Revision 1.41  1996/08/05  17:10:17  andreww
 * [Bug #1521]
 * Porpagating changes to typechecker/_types.sml
 *
 * Revision 1.40  1996/08/01  12:01:38  jont
 * [Bug #1503]
 * Add field to FUNINFO to say if arg actually saved
 *
 * Revision 1.39  1996/04/30  16:11:04  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.38  1996/04/29  15:04:15  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.37  1996/03/19  14:37:47  matthew
 * Changed type of Map.merge
 *
 * Revision 1.36  1996/02/23  17:13:24  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.35  1996/02/22  13:17:55  jont
 * Replacing Map with NewMap
 *
 * Revision 1.34  1995/12/27  11:57:16  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.33  1995/08/10  14:53:02  daveb
Replaced redundant construction of int_type.

Revision 1.32  1995/03/17  14:40:01  matthew
Replacing make_string with Integer.makestring

Revision 1.31  1995/03/02  11:35:28  matthew
Removed Options structure, changes type of augment_information

Revision 1.30  1995/02/17  11:40:58  daveb
Replaced string_tyvar with IdentPrint.printTyVar.

Revision 1.29  1995/01/30  11:14:26  matthew
Renaming debugger_env to runtime_env

Revision 1.28  1994/09/13  10:06:13  matthew
Abstraction of debug information

Revision 1.27  1994/06/22  11:32:38  jont
Ensure debug info can be cleared when required

Revision 1.26  1994/06/14  15:46:15  daveb
Removed Jon's fix - overloading should be resolved by the time this is
called.

Revision 1.25  1994/06/10  15:52:18  jont
Fix printing of overloaded types in lambda calculus

Revision 1.24  1994/05/05  13:48:46  daveb
META_OVERLOADED takes an extra argument.

Revision 1.23  1994/02/28  07:39:16  nosa
Deleted compiler option debug_polyvariables in Debugger_Types.INFO.

Revision 1.22  1994/02/25  15:57:31  daveb
Removed string_information function, added clear_information.

Revision 1.21  1993/12/09  19:27:11  jont
Added copyright message

Revision 1.20  1993/09/22  16:01:05  nosa
Record compiler option debug_polyvariables in Debugger_Types.INFO
for recompilation purposes.

Revision 1.19  1993/07/12  08:56:17  nosa
Debugger Environments for local and closure variable inspection
in the debugger.

Revision 1.18  1993/05/18  13:42:16  jont
Removed integer parameter

Revision 1.17  1993/03/11  12:04:43  matthew
Signature revisions

Revision 1.16  1993/03/04  12:12:36  matthew
Options & Info changes

Revision 1.15  1993/03/02  17:14:08  matthew
empty_rec_type to empty_rectype

Revision 1.14  1992/12/07  16:38:37  jont
Anel's last changes

Revision 1.13  1992/11/26  19:17:21  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.12  1992/11/26  16:53:23  clive
Changed the function to print debugger information

Revision 1.11  1992/11/18  12:06:21  clive
Added a to_string function for debug information

Revision 1.10  1992/10/09  14:10:00  clive
Tynames now have a slot recording their definition point

Revision 1.9  1992/10/05  15:16:11  richard
Added empty_information.

Revision 1.8  1992/09/10  10:00:56  richard
Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.

Revision 1.7  1992/07/20  16:45:32  clive
More work on the debugger

Revision 1.6  1992/07/16  16:29:26  clive
Added an error element to the type

Revision 1.5  1992/07/06  14:09:13  clive
Changes when implementing call point annotation

Revision 1.4  1992/06/30  10:17:10  clive
Forgot the signature constraint

Revision 1.2  1992/06/30  09:34:46  clive
I forget the Integer structure argument

Revision 1.1  1992/06/29  11:08:27  clive
Initial revision

 * Copyright (c) 1993 Harlequin Ltd.
*)

require "../basis/__int";

require "../typechecker/types";
require "../basics/identprint";
require "../utils/crash";
require "runtime_env";

require "debugger_types";

functor Debugger_Types(
  structure Types : TYPES
  structure Crash : CRASH
  structure IdentPrint : IDENTPRINT
  structure RuntimeEnv : RUNTIMEENV

  sharing Types.Datatypes.Ident = IdentPrint.Ident
  sharing Types.Options = IdentPrint.Options
) : DEBUGGER_TYPES =

  struct

    structure Datatypes = Types.Datatypes
    structure NewMap = Datatypes.NewMap
    structure Ident = Datatypes.Ident
    structure Symbol = Ident.Symbol
    structure Options = IdentPrint.Options
    structure RuntimeEnv = RuntimeEnv

    type ('a,'b) Map = ('a,'b) NewMap.map
    type Type = Datatypes.Type
    type Instance = Datatypes.Instance
    type Tyname = Datatypes.Tyname

    type printOptions = Options.print_options

    (* Datatype that gives a method for calculating the output type from the
       input type *)

    datatype Recipe =

      SELECT of int * Recipe  | (* Select from a record *)
      MAKERECORD of (string * Recipe) list |

      NOP |  (* Just the parameter type *)
      ERROR of string |

      FUNARG of Recipe | (* Argument of the funtype *)
      FUNRES of Recipe | (* Result of this function type *)
      MAKEFUNTYPE of Recipe * Recipe |

      DECONS of int * Recipe | (* For the types in a constructor *)
      MAKECONSTYPE of Recipe list * Types.Datatypes.Tyname

    type Backend_Annotation = Recipe

    datatype FunInfo = 
      FUNINFO of
      {ty : Type,
       is_leaf : bool,
       has_saved_arg : bool,
       annotations : (int * Backend_Annotation) list, (* Sub function annotations *)
       runtime_env : RuntimeEnv.RuntimeEnv, (* Variable debug info *)
       is_exn : bool}

    datatype information =
     INFO of (string,FunInfo) NewMap.map

    val empty_information = INFO (Datatypes.NewMap.empty' ((op<):string*string->bool))
              
    fun augment_information (debug,INFO info, INFO more_info) =
      if debug
        then INFO (Datatypes.NewMap.union (info, more_info))
      else
        (* Add in information for exceptions.  Undefine any new stuff *)
        (* Exceptions always have debug info generated *)
	INFO(Datatypes.NewMap.fold
	     (fn (info, name, funinfo as FUNINFO {is_exn,...}) =>
              if is_exn then NewMap.define (info,name,funinfo)
              else NewMap.undefine(info, name))
             (info, more_info))
      
    fun clear_information (name, INFO (info)) =
      INFO (NewMap.undefine (info, name))

    val null_backend_annotation = NOP
    val empty_runtime_env = RuntimeEnv.EMPTY

    fun print_backend_annotation options NOP = "Nop"

      | print_backend_annotation options (ERROR s) = "Error: " ^ s

      | print_backend_annotation options (SELECT(x,recipe)) =
        "Select{" ^ Int.toString x ^ "," ^ 
                       print_backend_annotation options recipe ^ "}"
      | print_backend_annotation options (MAKERECORD(recipes)) =
        let
          fun join [] = ""
            | join [(name,h)] = name ^ "=" ^ print_backend_annotation
                                                     options h
            | join ((name,h)::t) = name ^ "=" ^ print_backend_annotation 
                                                      options h ^ "," ^ join t
        in
          "MakeRecord{" ^ join recipes ^ "}"
        end

      | print_backend_annotation options (FUNARG x) = 
        "Funarg{" ^ print_backend_annotation options x ^ "}"
      | print_backend_annotation options (FUNRES x) = 
        "Funres{" ^ print_backend_annotation options x ^ "}"
      | print_backend_annotation options (MAKEFUNTYPE(from,to)) =
        "(" ^ print_backend_annotation options from ^ " -> " ^ 
              print_backend_annotation options to ^ ")"
        
      | print_backend_annotation options (DECONS(n,recipe)) =
        "DeCons{" ^ Int.toString n ^ "," ^ 
                           print_backend_annotation options recipe ^ "}"
      | print_backend_annotation options (MAKECONSTYPE(recipe_list,tyname)) =
        let
          fun join [] = ""
            | join [x] = x
            | join (h::t) = h ^ "," ^ join t
        in
          "MakeConsType{" ^ 
          Types.debug_print_type options (Types.Datatypes.CONSTYPE([],tyname))
          ^
          (case recipe_list of
             [] => ""
           | _ => "," ^ join(map (fn x => print_backend_annotation options x)
                              recipe_list)) ^ 
          "}"
        end

    local
      fun tostring options print_recipes (name,FUNINFO {annotations,...}) =
        if print_recipes
          then
            concat (name ::
                     map 
                     (fn (i,recipe) => 
                      "\n   " ^ Int.toString i ^ ":" ^ 
                       print_backend_annotation options recipe)
                     (rev annotations))
        else name
    in
      fun print_information options (INFO debug_info,print_recipes) =
        map (tostring options print_recipes) 
                                  (NewMap.to_list_ordered debug_info)
      fun print_function_information options
        (name,INFO debug_info,print_recipes) =
        case NewMap.tryApply' (debug_info,name) of
          SOME info => tostring options print_recipes
                                                              (name,info)
            | _ => "No info for " ^ name
    end

    val print_type = Types.debug_print_type

    (* A few useful type definitions for the optimiser to use *)
  fun make_pair(ty1,ty2) =
    Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "1"),
                         ty1,
                         Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "2"),
                                              ty2,
                                              Types.empty_rectype))

    val null_type = Datatypes.NULLTYPE
    val int_type = Types.int_type
    val int_pair_type = make_pair(int_type,int_type)
    val string_type = Datatypes.CONSTYPE([],Types.string_tyname)
    val string_pair_type = make_pair(string_type,string_type)
    val string_list_type = Datatypes.CONSTYPE([string_type],Types.list_tyname)
    val exn_type = Datatypes.CONSTYPE([],Types.exn_tyname)

  (* Utility to print the type of an expression - modifed the version 
     from _types to allow printing the different FN's within a piece of
     lambda code *)
      
    fun string_metatyvar (t as Datatypes.METATYVAR (_,eq,imp),metastack) =
      let 
	val (how_deep,metastack') = find_depth (t,metastack)
        val alpha = "meta-" ^ (Int.toString how_deep) 
	val eq_bit = if eq then "'" else ""
	val imp_bit = if imp then "_" else ""
      in
	("'"^ eq_bit ^ imp_bit ^ alpha,metastack')
      end 
      | string_metatyvar _ = Crash.impossible "string_metatyvar in _debugger_types"        

    and string_overloaded _ = Crash.impossible "string_overloaded in _debugger_types"

    and find_depth (Datatypes.METATYVAR(code,_,_),metastack) = 
      let
        fun find_depth' [] = (length metastack + 1,code::metastack)
          | find_depth'(code'::rest) = 
            if code = code'
              then (length rest + 1,metastack)
            else find_depth' rest
      in
        find_depth' metastack
      end

      | find_depth _ = Crash.impossible "find_depth in _debugger_types"        

    and string_metarec _ = Crash.impossible "string_metarec in _debugger_types"        

    and string_constype options (t as (Datatypes.CONSTYPE ([],name)),stack,acc_string)  =
      if acc_string = "" 
        then
          (Types.print_name options name,stack)
      else
        ("(" ^ acc_string ^ ")" ^ (Types.print_name options name),stack)
	| string_constype options (Datatypes.CONSTYPE (h::t,name),stack,acc_string) =
	  let 
	    val (s,stack') = string_types options (h,stack)
	  in
	    if acc_string = "" then 
	      string_constype options (Datatypes.CONSTYPE (t, name), stack', s)
	    else
	      string_constype options (Datatypes.CONSTYPE (t,name),
			               stack',acc_string ^ ", " ^ s)
	  end
      
      | string_constype _ _ = Crash.impossible "string_constype in _debugger_types"        

    and string_types options (t as (Datatypes.METATYVAR (ref(_,Datatypes.NULLTYPE,_),_,_)),stack) =
	string_metatyvar (t,stack)
	| string_types options (Datatypes.METATYVAR (ref(_,t,_),_,_),stack) =
	  string_types options (t,stack)
	| string_types options (t as (Datatypes.META_OVERLOADED {1=ref Datatypes.NULLTYPE,...}), stack) =
(*
	  string_overloaded (t,stack)
*)
	  let
	    fun error_fn _ = Crash.impossible"_debugger_types: string_types"
	    val _ = Types.resolve_overloading(true, t, error_fn)
	  in
	    string_types options(t, stack)
	  end
	| string_types options
	    (Datatypes.META_OVERLOADED {1=ref t,...},stack) =
	  string_types options (t,stack)
	| string_types options (Datatypes.METARECTYPE (ref (_,true,t as Datatypes.METARECTYPE _,_,_)),stack) = 
          string_types options (t,stack)
	| string_types options (t as (Datatypes.METARECTYPE (ref (_,true,_,_,_))),stack) =
	  string_metarec (t,stack)
	| string_types options (Datatypes.METARECTYPE (ref(_,_,t,_,_)),stack) =
	  string_types options (t,stack)
	| string_types options (Datatypes.DEBRUIJN n,stack) =
          ("Debruijn found",stack)
	| string_types options (Datatypes.TYVAR (_,t),stack) =
	  ((IdentPrint.printTyVar t),stack)
	| string_types options (Datatypes.NULLTYPE,stack) = ("Nulltype ",stack)
	| string_types options (Datatypes.FUNTYPE (a,r),stack) =
	  let
	    val (s,m) = string_types options (a,stack)
	    val (s',m') = string_types options (r,m)
	  in
	    ("(" ^ s ^ ") -> " ^ s',m')
	  end
	| string_types options (t as (Datatypes.CONSTYPE _),stack) =
	  string_constype options (t,stack,"")
	| string_types options (Datatypes.RECTYPE amap,stack) =
	  let
	    val stack_ref = ref stack
	    fun ref_printer t =
	      let 
		val ref stack = stack_ref
		val (s,new_stack) = string_types options (t,stack)
	      in
		(stack_ref := new_stack;
		 s)
	      end
	    val comma_rec_string = NewMap.string
	      (fn x => "," ^ (IdentPrint.printLab x))
	      ref_printer
	      {start="", domSep=" : ", itemSep="", finish=""}
	      amap
	    fun rec_list([]) = []
	      | rec_list(_::t) = t
	  in
	    ("{"^ (implode (rec_list(explode comma_rec_string))) ^ "}",
	     !stack_ref)
          end

    (* Set runtime_env and leafness *)
    fun set_proc_data (name,is_leaf,has_saved_arg,runtime_env,INFO debug_map) =
      (case NewMap.tryApply' (debug_map, name) of
         SOME 
         (FUNINFO {ty,annotations,is_exn,...}) =>
           (INFO (NewMap.define(debug_map, 
                                name,
                                (FUNINFO
                                 {ty=ty,
                                  is_leaf=is_leaf,
				  has_saved_arg=has_saved_arg,
                                  annotations=annotations,
                                  runtime_env=runtime_env,
                                  is_exn=is_exn}))))
       | _ => 
           (INFO (NewMap.define(debug_map, 
                                name,
                                (FUNINFO
                                 {ty=null_type,
                                  is_leaf=is_leaf,
				  has_saved_arg=has_saved_arg,
                                  annotations=nil,
                                  runtime_env=runtime_env,
                                  is_exn=false})))))

    fun add_debug_info (INFO map,name,funinfo) = INFO (NewMap.define (map,name,funinfo))

    fun lookup_debug_info (INFO map,name) = NewMap.tryApply' (map,name)

    (* Maybe this shouldn't add entries for NOPs as this can be made the default *)
    (* The lookup function should be defined here also *)

    fun add_annotation (name,count,debug,INFO debug_map) =
      case NewMap.tryApply'(debug_map, name) of
        SOME (FUNINFO {ty,is_leaf,has_saved_arg,annotations,runtime_env, is_exn}) =>
          INFO (NewMap.define
                (debug_map, name, 
                 FUNINFO {ty=ty,
                          is_leaf=is_leaf,
			  has_saved_arg=has_saved_arg,
                          annotations=(count,debug)::annotations,
                          runtime_env=runtime_env,
                          is_exn=is_exn}))
      | _ => INFO debug_map

  (* Conversion to and from lists *)

    fun debug_info_to_list (INFO map) =
      NewMap.to_list map

    fun debug_info_from_list list =
      INFO (NewMap.from_list ((op<):string*string->bool, op=) list)
  end
@


1.45.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.45  1998/08/24  11:27:49  jont
 * [Bug #70168]
 * Resolve overloading when printing types if necessary
 *
@


1.44
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d378 1
d380 7
@


1.44.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.44  1996/11/06  11:22:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.44  1996/11/06  11:22:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.5.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/11/06  11:22:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.44.5.1  1997/05/12  10:29:20  hope
 * branched from 1.44
 *
@


1.44.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.44.5.1  1997/05/12  10:29:20  hope
 * branched from 1.44
 *
@


1.44.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.44.5.1  1997/05/12  10:29:20  hope
 * branched from 1.44
 *
@


1.44.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.44.5.1.1.1  1997/07/28  18:15:13  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.44.4.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/11/06  11:22:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.3.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/11/06  11:22:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.3.1.1.1
log
@branched from 1.44.3.1
@
text
@a3 3
 * Revision 1.44.3.1  1996/12/17  17:43:12  hope
 * branched from 1.44
 *
@


1.44.2.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/11/06  11:22:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.1.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/11/06  11:22:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.1.1.1.1
log
@branched from 1.44.1.1
@
text
@a3 3
 * Revision 1.44.1.1  1996/11/14  12:43:49  hope
 * branched from 1.44
 *
@


1.43
log
@[Bug #1614]
removing toplevel String.
@
text
@d4 4
d145 1
a145 1
require "../basis/__integer";
@


1.42
log
@[Bug #1614]
removing toplevel String.
@
text
@d4 4
a145 1
require "../utils/lists";
a152 1
  structure Lists : LISTS
d333 1
a333 1
        fun find_depth' [] = (Lists.length metastack + 1,code::metastack)
d336 1
a336 1
              then (Lists.length rest + 1,metastack)
@


1.41
log
@[Bug #1521]
Porpagating changes to typechecker/_types.sml
@
text
@d4 4
d206 1
a206 1
    val empty_information = INFO (Datatypes.NewMap.empty' MLWorks.String.<)
d275 1
a275 1
            String.implode (name ::
d289 1
a289 1
          MLWorks.Option.SOME info => tostring options print_recipes
d411 1
a411 1
	    ("{"^ (String.implode (rec_list(String.explode comma_rec_string))) ^ "}",
d418 1
a418 1
         MLWorks.Option.SOME 
d449 1
a449 1
        MLWorks.Option.SOME (FUNINFO {ty,is_leaf,has_saved_arg,annotations,runtime_env, is_exn}) =>
d466 1
a466 1
      INFO (NewMap.from_list (MLWorks.String.< , op =) list)
@


1.41.3.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/08/05  17:10:17  andreww
 * [Bug #1521]
 * Porpagating changes to typechecker/_types.sml
 *
@


1.41.2.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/08/05  17:10:17  andreww
 * [Bug #1521]
 * Porpagating changes to typechecker/_types.sml
 *
@


1.41.1.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/08/05  17:10:17  andreww
 * [Bug #1521]
 * Porpagating changes to typechecker/_types.sml
 *
@


1.40
log
@[Bug #1503]
Add field to FUNINFO to say if arg actually saved
@
text
@d4 4
d222 1
a222 1
    fun print_backend_annotation NOP = "Nop"
d224 1
a224 1
      | print_backend_annotation (ERROR s) = "Error: " ^ s
d226 4
a229 3
      | print_backend_annotation (SELECT(x,recipe)) =
        "Select{" ^ Int.toString x ^ "," ^ print_backend_annotation recipe ^ "}"
      | print_backend_annotation (MAKERECORD(recipes)) =
d232 4
a235 2
            | join [(name,h)] = name ^ "=" ^ print_backend_annotation h
            | join ((name,h)::t) = name ^ "=" ^ print_backend_annotation h ^ "," ^ join t
d240 7
a246 6
      | print_backend_annotation (FUNARG x) = 
        "Funarg{" ^ print_backend_annotation x ^ "}"
      | print_backend_annotation (FUNRES x) = 
        "Funres{" ^ print_backend_annotation x ^ "}"
      | print_backend_annotation (MAKEFUNTYPE(from,to)) =
        "(" ^ print_backend_annotation from ^ " -> " ^ print_backend_annotation to ^ ")"
d248 4
a251 3
      | print_backend_annotation (DECONS(n,recipe)) =
        "DeCons{" ^ Int.toString n ^ "," ^ print_backend_annotation recipe ^ "}"
      | print_backend_annotation (MAKECONSTYPE(recipe_list,tyname)) =
d258 2
a259 1
          Types.debug_print_type (Types.Datatypes.CONSTYPE([],tyname)) ^
d262 2
a263 1
           | _ => "," ^ join(map print_backend_annotation recipe_list)) ^ 
d268 1
a268 1
      fun tostring print_recipes (name,FUNINFO {annotations,...}) =
d274 2
a275 1
                      "\n   " ^ Int.toString i ^ ":" ^ print_backend_annotation recipe)
d279 5
a283 3
      fun print_information (INFO debug_info,print_recipes) =
        map (tostring print_recipes) (NewMap.to_list_ordered debug_info)
      fun print_function_information (name,INFO debug_info,print_recipes) =
d285 2
a286 1
          MLWorks.Option.SOME info => tostring print_recipes (name,info)
d290 1
a290 1
    fun print_type ty = Types.debug_print_type ty
@


1.39
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d190 1
d397 1
a397 1
    fun set_proc_data (name,is_leaf,runtime_env,INFO debug_map) =
d400 1
a400 1
         (FUNINFO {ty,is_leaf,annotations,is_exn,...}) =>
d406 1
d415 2
a416 1
                                  is_leaf=false,
d430 1
a430 1
        MLWorks.Option.SOME (FUNINFO {ty,is_leaf,annotations,runtime_env, is_exn}) =>
d435 1
a448 1

@


1.38
log
@Removing MLWorks.Integer
@
text
@d4 3
d253 1
a253 1
            implode (name ::
d385 1
a385 1
	    ("{"^ (implode (rec_list(explode comma_rec_string))) ^ "}",
@


1.37
log
@Changed type of Map.merge
@
text
@d4 3
d120 2
d213 1
a213 1
        "Select{" ^ MLWorks.Integer.makestring x ^ "," ^ print_backend_annotation recipe ^ "}"
d231 1
a231 1
        "DeCons{" ^ MLWorks.Integer.makestring n ^ "," ^ print_backend_annotation recipe ^ "}"
d253 1
a253 1
                      "\n   " ^ MLWorks.Integer.makestring i ^ ":" ^ print_backend_annotation recipe)
d290 1
a290 1
        val alpha = "meta-" ^ (MLWorks.Integer.makestring how_deep) 
@


1.36
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d4 3
d187 1
a187 1
        then INFO (Datatypes.NewMap.merge (fn (x,y) => y) (info, more_info))
@


1.35
log
@Replacing Map with NewMap
@
text
@d4 3
d142 1
a142 1
    type ('a,'b) Map = ('a,'b) NewMap.T
d178 1
a178 1
     INFO of (string,FunInfo) NewMap.T
@


1.34
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d363 5
a367 5
	    val comma_rec_string = Datatypes.Mapping.print_map
	      (amap,
	       fn x => "," ^ (IdentPrint.printLab x),
	       ref_printer,
	       " : ")
@


1.33
log
@Replaced redundant construction of int_type.
@
text
@d4 3
a124 1
  sharing Types.Datatypes.Option = RuntimeEnv.Option
@


1.32
log
@Replacing make_string with Integer.makestring
@
text
@d4 3
d260 1
a260 1
    val int_type = Datatypes.CONSTYPE([],Types.int_tyname)
@


1.31
log
@Removed Options structure, changes type of augment_information
@
text
@d4 3
d268 1
a268 11
    fun make_string n =
      let 
	val rep =  n div 26
	val char_no = 96 + (n mod 26)
	fun rep_chars (~1,c,s) = s
          | rep_chars (rep,c,s) = rep_chars (rep-1,c,c^s)
      in
	rep_chars (rep,chr char_no,"")
      end
    
    and string_metatyvar (t as Datatypes.METATYVAR (_,eq,imp),metastack) =
d271 1
a271 1
        val alpha = "meta-" ^ (make_string how_deep) 
@


1.30
log
@Replaced string_tyvar with IdentPrint.printTyVar.
@
text
@d4 3
d128 1
d133 2
d168 3
a170 6
    fun augment_information (Options.OPTIONS
			     {compiler_options=Options.COMPILEROPTIONS
			      {debug, debug_variables, debug_polyvariables, generate_moduler, ...}, ...},
			     INFO info, INFO more_info) =
      if debug orelse debug_polyvariables orelse debug_variables orelse generate_moduler then
	INFO (Datatypes.NewMap.merge (fn (x,y) => y) (info, more_info))
d172 2
d176 1
a176 1
              if is_exn then NewMap.define (info,name,funinfo) (* Huh? *)
d322 1
a322 3
    and string_types
	  options
	  (t as (Datatypes.METATYVAR (ref(_,Datatypes.NULLTYPE,_),_,_)),stack) =
d326 1
a326 3
	| string_types options
	    (t as (Datatypes.META_OVERLOADED {1=ref Datatypes.NULLTYPE,...}),
	     stack) =
d331 2
a332 2
	| string_types options (Datatypes.METARECTYPE (ref (_,true,t as Datatypes.METARECTYPE _,_,_)),
                        stack) = string_types options (t,stack)
d349 1
a349 1
	| string_types options (t as (Datatypes.CONSTYPE (_)),stack) =
d397 4
d416 7
@


1.29
log
@Renaming debugger_env to runtime_env
@
text
@d4 3
a269 2
    and string_tyvar (Ident.TYVAR (id,_,_)) = Ident.Symbol.symbol_name id
      
d339 1
a339 1
	  ((string_tyvar t),stack)
@


1.28
log
@Abstraction of debug information
@
text
@d4 3
d97 1
a97 1
require "debugger_env";
d131 2
a132 2
      Select of int * Recipe  | (* Select from a record *)
      MakeRecord of (string * Recipe) list |
d134 2
a135 2
      Nop |  (* This is it *)
      Error |
d137 3
a139 3
      Funarg of Recipe | (* Argument of the funtype *)
      Funres of Recipe | (* Result of this function type *)
      MakeFunType of Recipe * Recipe |
d141 2
a142 2
      DeCons of int * Recipe | (* For the types in a constructor *)
      MakeConsType of Recipe list * Types.Datatypes.Tyname
d146 8
d155 1
a155 2
      INFO of (string, (Type * bool * 
               (int * Backend_Annotation) list) * RuntimeEnv.debugger_env * bool) NewMap.T
d167 4
a170 6
	     (fn (info, name, (_, _, false)) =>
	      ((*output(std_out, "Clearing debug info for " ^ name ^ "\n");*)
	       NewMap.undefine(info, name))
	      | x =>
		  NewMap.define x)
	     (info, more_info))
d175 2
a176 2
    val null_backend_annotation = Nop
    val empty_debugger_env = RuntimeEnv.EMPTY
d178 1
a178 1
    fun print_backend_annotation Nop = "Nop"
d180 1
a180 1
      | print_backend_annotation Error = "Error"
d182 1
a182 1
      | print_backend_annotation (Select(x,recipe)) =
d184 1
a184 1
      | print_backend_annotation (MakeRecord(recipes)) =
d193 1
a193 1
      | print_backend_annotation (Funarg x) = 
d195 1
a195 1
      | print_backend_annotation (Funres x) = 
d197 1
a197 1
      | print_backend_annotation (MakeFunType(from,to)) =
d200 1
a200 1
      | print_backend_annotation (DeCons(n,recipe)) =
d202 1
a202 1
      | print_backend_annotation (MakeConsType(recipe_list,tyname)) =
d216 19
d371 39
@


1.27
log
@Ensure debug info can be cleared when required
@
text
@d4 3
d103 1
a103 1
  structure Debugger_Env : DEBUGGER_ENVIRONMENT_TYPE
d107 1
a107 1
  sharing Types.Datatypes.Option = Debugger_Env.Option
d117 1
a117 1
    structure Debugger_Env = Debugger_Env
d145 1
a145 1
               (int * Backend_Annotation) list) * Debugger_Env.debugger_env * bool) NewMap.T
d168 1
a168 1
    val empty_debugger_env = Debugger_Env.EMPTY
@


1.26
log
@Removed Jon's fix - overloading should be resolved by the time this is
called.
@
text
@d4 4
d142 1
a142 1
               (int * Backend_Annotation) list) * Debugger_Env.debugger_env) NewMap.T
d146 14
a159 2
    fun augment_information (INFO info, INFO more_info) =
      INFO (Datatypes.NewMap.merge (fn (x,(y,runtime_env)) => (y,runtime_env)) (info, more_info))
@


1.25
log
@Fix printing of overloaded types in lambda calculus
@
text
@d4 3
a210 2
    fun error_fn _ = Crash.impossible"string_overloaded in _debugger_types"

d234 1
a234 5
    and string_overloaded options (t, stack) =
      (*Crash.impossible "string_overloaded in _debugger_types"*)
      (Types.resolve_overloading(true, t, error_fn);
       output(std_out, "Resolved overloading once\n");
       string_types options (t, stack))
d271 54
a324 54
      options
      (t as (Datatypes.METATYVAR (ref(_,Datatypes.NULLTYPE,_),_,_)),stack) =
      string_metatyvar (t,stack)
      | string_types options (Datatypes.METATYVAR (ref(_,t,_),_,_),stack) =
	string_types options (t,stack)
      | string_types options
	(t as (Datatypes.META_OVERLOADED {1=ref Datatypes.NULLTYPE,...}),
	 stack) =
	(string_overloaded options (t, stack))
      | string_types options
	(Datatypes.META_OVERLOADED {1=ref t,...},stack) =
	string_types options (t,stack)
      | string_types options (Datatypes.METARECTYPE (ref (_,true,t as Datatypes.METARECTYPE _,_,_)),
			      stack) = string_types options (t,stack)
      | string_types options (t as (Datatypes.METARECTYPE (ref (_,true,_,_,_))),stack) =
	string_metarec (t,stack)
      | string_types options (Datatypes.METARECTYPE (ref(_,_,t,_,_)),stack) =
	string_types options (t,stack)
      | string_types options (Datatypes.DEBRUIJN n,stack) =
	("Debruijn found",stack)
      | string_types options (Datatypes.TYVAR (_,t),stack) =
	((string_tyvar t),stack)
      | string_types options (Datatypes.NULLTYPE,stack) = ("Nulltype ",stack)
      | string_types options (Datatypes.FUNTYPE (a,r),stack) =
	let
	  val (s,m) = string_types options (a,stack)
	  val (s',m') = string_types options (r,m)
	in
	  ("(" ^ s ^ ") -> " ^ s',m')
	end
      | string_types options (t as (Datatypes.CONSTYPE (_)),stack) =
	string_constype options (t,stack,"")
      | string_types options (Datatypes.RECTYPE amap,stack) =
	let
	  val stack_ref = ref stack
	  fun ref_printer t =
	    let 
	      val ref stack = stack_ref
	      val (s,new_stack) = string_types options (t,stack)
	    in
	      (stack_ref := new_stack;
	       s)
	    end
	  val comma_rec_string = Datatypes.Mapping.print_map
	    (amap,
	     fn x => "," ^ (IdentPrint.printLab x),
	     ref_printer,
	     " : ")
	  fun rec_list([]) = []
	    | rec_list(_::t) = t
	in
	  ("{"^ (implode (rec_list(explode comma_rec_string))) ^ "}",
	   !stack_ref)
	end
@


1.24
log
@META_OVERLOADED takes an extra argument.
@
text
@d4 3
d208 2
d233 5
a237 1
    and string_overloaded _ = Crash.impossible "string_overloaded in _debugger_types"
d274 54
a327 54
	  options
	  (t as (Datatypes.METATYVAR (ref(_,Datatypes.NULLTYPE,_),_,_)),stack) =
	string_metatyvar (t,stack)
	| string_types options (Datatypes.METATYVAR (ref(_,t,_),_,_),stack) =
	  string_types options (t,stack)
	| string_types options
	    (t as (Datatypes.META_OVERLOADED {1=ref Datatypes.NULLTYPE,...}),
	     stack) =
	  string_overloaded (t,stack)
	| string_types options
	    (Datatypes.META_OVERLOADED {1=ref t,...},stack) =
	  string_types options (t,stack)
	| string_types options (Datatypes.METARECTYPE (ref (_,true,t as Datatypes.METARECTYPE _,_,_)),
                        stack) = string_types options (t,stack)
	| string_types options (t as (Datatypes.METARECTYPE (ref (_,true,_,_,_))),stack) =
	  string_metarec (t,stack)
	| string_types options (Datatypes.METARECTYPE (ref(_,_,t,_,_)),stack) =
	  string_types options (t,stack)
	| string_types options (Datatypes.DEBRUIJN n,stack) =
          ("Debruijn found",stack)
	| string_types options (Datatypes.TYVAR (_,t),stack) =
	  ((string_tyvar t),stack)
	| string_types options (Datatypes.NULLTYPE,stack) = ("Nulltype ",stack)
	| string_types options (Datatypes.FUNTYPE (a,r),stack) =
	  let
	    val (s,m) = string_types options (a,stack)
	    val (s',m') = string_types options (r,m)
	  in
	    ("(" ^ s ^ ") -> " ^ s',m')
	  end
	| string_types options (t as (Datatypes.CONSTYPE (_)),stack) =
	  string_constype options (t,stack,"")
	| string_types options (Datatypes.RECTYPE amap,stack) =
	  let
	    val stack_ref = ref stack
	    fun ref_printer t =
	      let 
		val ref stack = stack_ref
		val (s,new_stack) = string_types options (t,stack)
	      in
		(stack_ref := new_stack;
		 s)
	      end
	    val comma_rec_string = Datatypes.Mapping.print_map
	      (amap,
	       fn x => "," ^ (IdentPrint.printLab x),
	       ref_printer,
	       " : ")
	    fun rec_list([]) = []
	      | rec_list(_::t) = t
	  in
	    ("{"^ (implode (rec_list(explode comma_rec_string))) ^ "}",
	     !stack_ref)
          end
@


1.23
log
@Deleted compiler option debug_polyvariables in Debugger_Types.INFO.
@
text
@d4 3
d270 3
a272 1
	| string_types options (t as (Datatypes.META_OVERLOADED (ref Datatypes.NULLTYPE,_)),stack) =
d274 2
a275 1
	| string_types options (Datatypes.META_OVERLOADED (ref t,_),stack) =
@


1.22
log
@Removed string_information function, added clear_information.
@
text
@d4 3
d104 1
a104 1
    type Instance = Datatypes.instance
d129 1
a129 1
               (int * Backend_Annotation) list) * Debugger_Env.debugger_env) NewMap.T * bool
d131 1
a131 1
    val empty_information = INFO ((Datatypes.NewMap.empty' MLWorks.String.<),false)
d133 2
a134 3
    fun augment_information (INFO (info,b1), INFO (more_info,b2)) =
      INFO (Datatypes.NewMap.merge (fn (x,(y,runtime_env)) => (y,runtime_env)) (info, more_info),
            b2)
d136 2
a137 2
    fun clear_information (name, INFO (info,b)) =
      INFO (NewMap.undefine (info, name), b)
d289 1
a289 1
	| string_types options (t as (Datatypes.CONSTYPE (_,_)),stack) =
@


1.21
log
@Added copyright message
@
text
@d4 3
d134 3
a178 18

    fun string_information options (INFO (mapping,_)) =
      let
        val assoc = Datatypes.NewMap.to_list_ordered mapping
      in
        implode
        (map 
           (fn (name,((ty,leaf,annotations),_)) =>
            implode[name," ",Types.print_type options ty,
                    implode (map (fn (offset,annotation) =>
                          implode["\n",
                                  MLWorks.Integer.makestring offset,
                                  " ",
                                  print_backend_annotation annotation,
                                  " "]) annotations),
                    "\n"])
           assoc)
      end
@


1.20
log
@Record compiler option debug_polyvariables in Debugger_Types.INFO
for recompilation purposes.
@
text
@d4 4
d65 1
@


1.19
log
@Debugger Environments for local and closure variable inspection
in the debugger.
@
text
@d4 4
d93 1
d118 1
a118 1
               (int * Backend_Annotation) list) * Debugger_Env.debugger_env) NewMap.T
d120 1
a120 1
    val empty_information = INFO (Datatypes.NewMap.empty' MLWorks.String.<)
d122 3
a124 2
    fun augment_information (INFO info, INFO more_info) =
      INFO (Datatypes.NewMap.merge (fn (x,(y,runtime_env)) => (y,runtime_env)) (info, more_info))
d169 1
a169 1
    fun string_information options (INFO mapping) =
d268 1
a268 1
	  (t as (Datatypes.METATYVAR (ref(_,Datatypes.NULLTYPE),_,_)),stack) =
d270 1
a270 1
	| string_types options (Datatypes.METATYVAR (ref(_,t),_,_),stack) =
@


1.19.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.19  1993/07/12  08:56:17  nosa
Debugger Environments for local and closure variable inspection
in the debugger.

@


1.18
log
@Removed integer parameter
@
text
@d4 3
d63 1
d72 1
d76 1
d86 1
d112 2
a113 2
      INFO of (string, Datatypes.Type * bool * 
               (int * Backend_Annotation) list) Datatypes.NewMap.T
d118 1
a118 1
      INFO (Datatypes.NewMap.merge (fn (x,y) => y) (info, more_info))
d121 1
d169 1
a169 1
           (fn (name,(ty,leaf,annotations)) =>
d189 1
@


1.17
log
@Signature revisions
@
text
@d4 3
a55 1
require "../utils/integer";
a64 1
  structure Integer : INTEGER
d120 1
a120 1
        "Select{" ^ Integer.makestring x ^ "," ^ print_backend_annotation recipe ^ "}"
d138 1
a138 1
        "DeCons{" ^ Integer.makestring n ^ "," ^ print_backend_annotation recipe ^ "}"
d165 1
a165 1
                                  Integer.makestring offset,
@


1.16
log
@Options & Info changes
@
text
@d4 3
a54 1
require "../utils/newmap";
a62 2
  structure Map : NEWMAP
  structure IdentPrint : IDENTPRINT
d66 1
d75 1
a75 1
    structure Map = Map
d80 3
d151 2
@


1.15
log
@empty_rec_type to empty_rectype
@
text
@d4 3
d68 1
a68 1
  sharing Types.Info = IdentPrint.Info
d77 1
a77 1
    structure Info = IdentPrint.Info
@


1.14
log
@Anel's last changes
@
text
@d4 3
d169 1
a169 1
                                              Types.empty_rec_type))
@


1.13
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d244 1
a244 1
	| string_types options (t as (Datatypes.META_OVERLOADED (ref Datatypes.NULLTYPE)),stack) =
d246 1
a246 1
	| string_types options (Datatypes.META_OVERLOADED (ref t),stack) =
@


1.12
log
@Changed the function to print debugger information
@
text
@d4 3
d45 1
d50 10
a59 8
                       structure Types : TYPES
                       structure Map : NEWMAP
                       structure IdentPrint : IDENTPRINT
                       structure Integer : INTEGER
                       structure Crash : CRASH

                         sharing Types.Datatypes.Ident = IdentPrint.Ident
                         ) : DEBUGGER_TYPES =
d67 1
d104 1
a104 1
      | print_backend_annotation(Select(x,recipe)) =
d106 1
a106 1
      | print_backend_annotation(MakeRecord(recipes)) =
d119 1
a119 1
      | print_backend_annotation(MakeFunType(from,to)) =
d131 1
a131 1
          Types.print_type(Types.Datatypes.CONSTYPE([],tyname)) ^
d138 1
a138 1
    fun string_information(INFO mapping) =
d145 1
a145 1
            implode[name," ",Types.print_type ty,
a168 8
    fun extract_list_element_type(Datatypes.METATYVAR(ref(_,ty),_,_),other) = extract_list_element_type(ty,other)
      | extract_list_element_type(Datatypes.CONSTYPE([el],ty'),default) =
                                  if ty' = Types.list_tyname
                                    then el
                                  else default
      | extract_list_element_type (ty,_) = (output(std_out,"*** WARNING: Found " ^ Types.print_type ty ^ 
                                                   " in extract_list_elem\n");
                                            Datatypes.NULLTYPE)
d175 1
a175 9
    fun print_name (Datatypes.TYNAME (_,name,_,ref eq,_,_)) = 
      if eq 
        then
          name ^ "[t]"
      else
        name ^ "[f]"
      | print_name (Datatypes.METATYNAME{1=ref tyfun, 2=name, ...}) = name
        
    and make_string n =
a199 8
    and length x =
      let
        fun length'([],acc) = acc
          | length'(_::t,acc) = length'(t,1+acc)
      in
        length'(x,1)
      end

d202 1
a202 1
        fun find_depth' [] = (length metastack,code::metastack)
d205 1
a205 1
              then (length rest,metastack)
d215 1
a215 1
    and string_constype (t as (Datatypes.CONSTYPE ([],name)),stack,acc_string)  =
d218 1
a218 1
          (print_name name,stack)
d220 2
a221 2
        ("(" ^ acc_string ^ ")" ^ (print_name name),stack)
	| string_constype (Datatypes.CONSTYPE (h::t,name),stack,acc_string) =
d223 1
a223 1
	    val (s,stack') = string_types (h,stack)
d226 1
a226 1
	      string_constype (Datatypes.CONSTYPE (t, name), stack', s)
d228 2
a229 2
	      string_constype (Datatypes.CONSTYPE (t,name),
			       stack',acc_string ^ ", " ^ s)
d232 1
a232 1
      | string_constype _ = Crash.impossible "string_constype in _debugger_types"        
d234 3
a236 1
    and string_types (t as (Datatypes.METATYVAR (ref(_,Datatypes.NULLTYPE),_,_)),stack) =
d238 3
a240 3
	| string_types (Datatypes.METATYVAR (ref(_,t),_,_),stack) =
	  string_types (t,stack)
	| string_types (t as (Datatypes.META_OVERLOADED (ref Datatypes.NULLTYPE)),stack) =
d242 5
a246 5
	| string_types (Datatypes.META_OVERLOADED (ref t),stack) =
	  string_types (t,stack)
	| string_types (Datatypes.METARECTYPE (ref (_,true,t as Datatypes.METARECTYPE _,_,_)),
                        stack) = string_types (t,stack)
	| string_types (t as (Datatypes.METARECTYPE (ref (_,true,_,_,_))),stack) =
d248 3
a250 3
	| string_types (Datatypes.METARECTYPE (ref(_,_,t,_,_)),stack) =
	  string_types (t,stack)
	| string_types (Datatypes.DEBRUIJN n,stack) =
d252 1
a252 1
	| string_types (Datatypes.TYVAR (_,t),stack) =
d254 2
a255 2
	| string_types (Datatypes.NULLTYPE,stack) = ("Nulltype ",stack)
	| string_types (Datatypes.FUNTYPE (a,r),stack) =
d257 2
a258 2
	    val (s,m) = string_types (a,stack)
	    val (s',m') = string_types (r,m)
d262 3
a264 3
	| string_types (t as (Datatypes.CONSTYPE (_,_)),stack) =
	  string_constype (t,stack,"")
	| string_types (Datatypes.RECTYPE amap,stack) =
d270 1
a270 1
		val (s,new_stack) = string_types(t,stack)
a285 1

@


1.11
log
@Added a to_string function for debug information
@
text
@d4 3
d138 4
a141 3
            name ^
            implode (map (fn (offset,annotation) =>
                          implode[Integer.makestring offset,
d144 2
a145 2
                                  " "]) annotations) ^
            "\n")
@


1.10
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d127 17
@


1.9
log
@Added empty_information.
@
text
@d4 3
d152 1
a152 1
    fun print_name (Datatypes.TYNAME (_,name,_,ref eq,_)) = 
@


1.8
log
@Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.
@
text
@d4 4
d76 2
@


1.7
log
@More work on the debugger
@
text
@d4 3
d69 7
@


1.6
log
@Added an error element to the type
@
text
@d4 3
d24 2
d32 3
a34 1
                       structure Integer : INTEGER) : DEBUGGER_TYPES =
d36 3
d43 2
d106 26
d133 126
d260 1
@


1.5
log
@Changes when implementing call point annotation
@
text
@d4 3
d31 1
a31 1
    structure Types = Types
d40 1
a40 1
      MakeRecord of Recipe list |
d43 1
d58 2
d65 2
a66 2
            | join [h] = print_backend_annotation h
            | join (h::t) = print_backend_annotation h ^ "," ^ join t
d88 4
a91 1
          "," ^ join(map print_backend_annotation recipe_list) ^ "}"
@


1.4
log
@Forgot the signature constraint
@
text
@d4 3
d17 1
d23 1
d29 1
d62 1
a62 1
          "Recipe{" ^ join recipes ^ "}"
d80 3
a82 1
          "MakeConsType{" ^ Types.print_type(Types.Datatypes.CONSTYPE([],tyname)) ^ "," ^ join(map print_backend_annotation recipe_list)
@


1.3
log
@and the structure argument
@
text
@d15 2
d19 1
a19 1
                       structure Integer : INTEGER)  =
d40 1
a40 2
      MakeConsType of Recipe list * Recipe |
      ConcreteType of Types.Datatypes.Tyname 
d52 2
a53 1
          fun join [h] = print_backend_annotation h
d68 1
a68 2
      | print_backend_annotation (ConcreteType(name)) = Types.print_type(Types.Datatypes.CONSTYPE([],name))
      | print_backend_annotation (MakeConsType(recipe_list,recipe)) =
d74 1
a74 1
          "MakeConsType{" ^ print_backend_annotation recipe ^ "," ^ join(map print_backend_annotation recipe_list)
@


1.2
log
@I forget the Integer structure argument
@
text
@d4 3
d16 2
a17 2
                       Types : TYPES
                       Integer : INTEGER)  =
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log: $
d9 1
d12 3
a14 1
functor Debugger_Types(Types : TYPES)  =
d24 1
d26 2
d29 2
a30 1
      Funarg of Recipe | (* Arguemnt of the funtype *)
d32 1
a32 3
      DeCons of Types.Datatypes.Tyname * int * Recipe | (* For the types in a constructor *)
      ConcreteType of Types.Datatypes.Tyname |
      MakeConsType of Recipe list * Recipe
d34 4
d43 1
d46 8
d58 5
a62 3
      | print_backend_annotation (DeCons(tyname,n,recipe)) =
        "DeCons{" ^ Types.print_type(Types.Datatypes.CONSTYPE([],tyname)) ^ "," ^ Integer.makestring n ^ "," ^
        print_backend_annotation recipe ^ "}"
@
