head	1.35;
access;
symbols
	MLW_daveb_inline_1_4_99:1.35.1
	MLWorks_21c0_1999_03_25:1.35
	MLWorks_20c1_1998_08_20:1.35
	MLWorks_20c0_1998_08_04:1.35
	MLWorks_20b2c2_1998_06_19:1.35
	MLWorks_20b2_Windows_1998_06_12:1.35
	MLWorks_20b1c1_1998_05_07:1.35
	MLWorks_20b0_1998_04_07:1.35
	MLWorks_20b0_1998_03_20:1.35
	MLWorks_20m2_1998_02_16:1.34
	MLWorks_20m1_1997_10_23:1.34
	MLWorks_11r1:1.32.1.1.1.1.1
	MLWorks_workspace_97:1.34.2
	MLWorks_dt_wizard:1.34.1
	MLWorks_11c0_1997_09_09:1.32.1.1.1.1
	MLWorks_10r3:1.32.1.1.3
	MLWorks_10r2_551:1.32.1.1.2
	MLWorks_11:1.32.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.32.1.1
	MLWorks_20m0_1997_06_20:1.34
	MLWorks_1_0_r2c2_1997_06_14:1.32.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.32.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.32.1
	MLWorks_BugFix_1997_04_24:1.32
	MLWorks_1_0_r2_Win32_1997_04_11:1.32
	MLWorks_1_0_r2_Unix_1997_04_04:1.32
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.29.3.1.1
	MLWorks_gui_1996_12_18:1.29.4
	MLWorks_1_0_Win32_1996_12_17:1.29.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.29.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.29.1.1
	MLWorks_1_0_Irix_1996_11_28:1.29.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.29.2
	MLWorks_1_0_Unix_1996_11_14:1.29.1
	MLWorks_Open_Beta2_1996_10_11:1.28.1
	MLWorks_License_dev:1.27.2
	MLWorks_1_open_beta_1996_09_13:1.27.1
	MLWorks_Open_Beta_1996_08_22:1.27
	MLWorks_Beta_1996_07_02:1.26
	MLWorks_Beta_1996_06_07:1.26
	MLWorks_Beta_1996_06_06:1.26
	MLWorks_Beta_1996_06_05:1.26
	MLWorks_Beta_1996_06_03:1.26
	MLWorks_Beta_1996_05_31:1.26
	MLWorks_Beta_1996_05_30:1.26
	ML_beta_release_12/08/94:1.9
	ML_beta_release_03/08/94:1.9
	ML_revised_beta_release_25/05/94:1.7
	ML_final_beta_release_02/03/94:1.5
	mlworks-28-01-1994:1.4
	Release:1.3
	mlworks-beta-01-09-1993:1.3;
locks; strict;
comment	@ * @;


1.35
date	98.02.19.19.32.35;	author mitchell;	state Exp;
branches
	1.35.1.1;
next	1.34;

1.34
date	97.05.21.16.26.56;	author jont;	state Exp;
branches
	1.34.1.1
	1.34.2.1;
next	1.33;

1.33
date	97.05.01.13.08.34;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	97.03.27.16.21.38;	author stephenb;	state Exp;
branches
	1.32.1.1;
next	1.31;

1.31
date	97.03.26.16.22.16;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	97.01.06.11.09.58;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	96.11.06.11.22.06;	author matthew;	state Exp;
branches
	1.29.1.1
	1.29.2.1
	1.29.3.1
	1.29.4.1;
next	1.28;

1.28
date	96.10.02.15.17.31;	author andreww;	state Exp;
branches
	1.28.1.1;
next	1.27;

1.27
date	96.08.05.16.53.23;	author andreww;	state Exp;
branches
	1.27.1.1
	1.27.2.1;
next	1.26;

1.26
date	96.05.28.09.43.47;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	96.05.01.10.09.00;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	96.04.29.15.04.02;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	96.03.20.14.15.55;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	96.03.08.12.04.03;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	96.02.22.14.24.01;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	95.12.27.13.31.40;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	95.11.21.11.24.04;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	95.11.15.11.07.55;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	95.07.25.14.07.21;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	95.07.19.12.11.52;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	95.03.08.10.50.20;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	95.02.28.15.28.53;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	95.02.02.10.57.55;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	95.01.20.12.15.01;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	94.12.15.12.38.48;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	94.09.22.13.58.40;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	94.06.09.15.49.06;	author nickh;	state Exp;
branches;
next	1.8;

1.8
date	94.06.09.09.20.00;	author nosa;	state Exp;
branches;
next	1.7;

1.7
date	94.05.05.16.18.43;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	94.04.13.13.43.34;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.02.28.09.03.06;	author nosa;	state Exp;
branches;
next	1.4;

1.4
date	93.09.22.12.43.35;	author nosa;	state Exp;
branches;
next	1.3;

1.3
date	93.08.10.14.45.05;	author nosa;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	93.08.05.09.57.10;	author nosa;	state Exp;
branches;
next	1.1;

1.1
date	93.07.30.15.48.03;	author nosa;	state Exp;
branches;
next	;

1.3.1.1
date	93.08.10.14.45.05;	author jont;	state Exp;
branches;
next	;

1.27.1.1
date	96.09.13.11.11.09;	author hope;	state Exp;
branches;
next	;

1.27.2.1
date	96.10.07.16.01.55;	author hope;	state Exp;
branches;
next	;

1.28.1.1
date	96.10.17.11.20.09;	author hope;	state Exp;
branches;
next	;

1.29.1.1
date	96.11.14.12.43.44;	author hope;	state Exp;
branches
	1.29.1.1.1.1;
next	;

1.29.1.1.1.1
date	96.11.28.14.55.40;	author hope;	state Exp;
branches;
next	;

1.29.2.1
date	96.11.22.18.04.11;	author hope;	state Exp;
branches;
next	;

1.29.3.1
date	96.12.17.17.43.07;	author hope;	state Exp;
branches
	1.29.3.1.1.1;
next	;

1.29.3.1.1.1
date	97.02.24.11.31.47;	author hope;	state Exp;
branches;
next	;

1.29.4.1
date	96.12.18.09.37.06;	author hope;	state Exp;
branches;
next	;

1.32.1.1
date	97.05.12.10.29.15;	author hope;	state Exp;
branches
	1.32.1.1.1.1
	1.32.1.1.2.1
	1.32.1.1.3.1;
next	;

1.32.1.1.1.1
date	97.07.28.18.15.06;	author daveb;	state Exp;
branches
	1.32.1.1.1.1.1.1;
next	;

1.32.1.1.1.1.1.1
date	97.10.07.11.40.13;	author jkbrook;	state Exp;
branches;
next	;

1.32.1.1.2.1
date	97.09.08.17.08.35;	author daveb;	state Exp;
branches;
next	;

1.32.1.1.3.1
date	97.09.09.14.03.44;	author daveb;	state Exp;
branches;
next	;

1.34.1.1
date	97.09.10.19.18.15;	author brucem;	state Exp;
branches;
next	;

1.34.2.1
date	97.09.11.20.49.10;	author daveb;	state Exp;
branches;
next	;

1.35.1.1
date	99.04.01.17.53.08;	author daveb;	state Exp;
branches;
next	;


desc
@Local and closure variable inspection in the debugger.
@


1.35
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _debugger_print.sml the functor *)
(*
 * $Log: _debugger_print.sml,v $
 * Revision 1.34  1997/05/21  16:26:56  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
 * Revision 1.33  1997/05/01  13:08:34  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.32  1997/03/27  16:21:38  stephenb
 * [Bug #1414]
 * Added an temporary (and ugly) hack that hides the problem
 * of local variables being displayed when they shouldn't.
 * Just to make this clear: this change doesn't fix this bug,
 * it only hides the problem from the user until such time
 * as the bug is fixed properly.
 *
 * Revision 1.31  1997/03/26  16:22:16  matthew
 * Adding handler for Lists.Nth exception
 *
 * Revision 1.30  1997/01/06  11:09:58  matthew
 * Adding LOCAL_FUNCTION clause.
 *
 * Revision 1.29  1996/11/06  11:22:06  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.28  1996/10/02  15:17:31  andreww
 * [Bug #1592]
 * threading level argument in tynames.
 *
 * Revision 1.27  1996/08/05  16:53:23  andreww
 * [Bug #1521]
 * propagating changes made to typechecker/_types.sml
 *
 * Revision 1.26  1996/05/28  09:43:47  daveb
 * Removed MLWorks.RawIO.
 *
 * Revision 1.25  1996/05/01  10:09:00  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.24  1996/04/29  15:04:02  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.23  1996/03/20  14:15:55  matthew
 * Changed type of Runtime.environment
 *
 * Revision 1.22  1996/03/08  12:04:03  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
 * Revision 1.21  1996/02/22  14:24:01  jont
 * Replacing Map with NewMap
 *
 * Revision 1.20  1995/12/27  13:31:40  jont
 * Removing Option in favour of MLWorks.Option
 *
 * Revision 1.19  1995/11/21  11:24:04  jont
 * Fix printing of reals in local variable debugging
 *
 * Revision 1.18  1995/11/15  11:07:55  jont
 * Modify type printing in stack frames
 *
 * Revision 1.17  1995/07/25  14:07:21  jont
 * Add stuff for WORDs
 *
 * Revision 1.16  1995/07/19  12:11:52  jont
 * Add CHAR to Tag type
 *
 * Revision 1.15  1995/03/08  10:50:20  matthew
 * Making debugger platform independent
 *
 * Revision 1.13  1995/02/02  10:57:55  matthew
 * More work on debugger
 *
 * Revision 1.12  1995/01/20  12:15:01  matthew
 * Renaming debugger_env to runtime_env
 *
 * Revision 1.11  1994/12/15  12:38:48  matthew
 * Fiddling
 *
 * Revision 1.10  1994/09/22  13:58:40  matthew
 * Abstraction of debug information
 *
 * Revision 1.9  1994/06/09  15:49:06  nickh
 * New runtime directory structure.
 *
 * Revision 1.8  1994/06/09  09:20:00  nosa
 * Simplifications in debugger environment printing;
 * altered HANDLE environment printing.
 *
 * Revision 1.7  1994/05/05  16:18:43  daveb
 * Datatypes.META_OVERLOADED takes extra arguments.
 *
 * Revision 1.6  1994/04/13  13:43:34  jont
 * Fix inexhaustive bindings
 *
 * Revision 1.5  1994/02/28  09:03:06  nosa
 * Modules Debugger : Dynamic Type Name Instantiation.
 *
 * Revision 1.4  1993/09/22  12:43:35  nosa
 * Polymorphic debugger.
 *
 * Revision 1.3  1993/08/10  14:45:05  nosa
 * print_env now returns list used in inspector invocation in debugger-window.
 *
 * Revision 1.2  1993/08/05  09:57:10  nosa
 * Changed type of print_env.
 *
 * Revision 1.1  1993/07/30  15:48:03  nosa
 * Initial revision
 *

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";
require "../basis/__text_io";

require "../utils/crash";
require "../utils/lists";
require "../main/options";
require "../typechecker/types";
require "../rts/gen/tags";
require "debugger_utilities";
require "runtime_env";
require "debugger_print";

functor DebuggerPrint (
    structure Lists : LISTS
    structure Crash : CRASH
    structure Options : OPTIONS
    structure Types : TYPES
    structure Tags : TAGS
    structure RuntimeEnv : RUNTIMEENV
    structure DebuggerUtilities : DEBUGGER_UTILITIES

    sharing type RuntimeEnv.Type = Types.Datatypes.Type
    sharing type Options.options = Types.Options.options
    sharing type Types.Options.print_options = Options.print_options
    sharing type Types.Datatypes.Instance = RuntimeEnv.Instance
    sharing type Types.Datatypes.Tyfun = RuntimeEnv.Tyfun
) : DEBUGGER_PRINT =
  struct
    structure Options = Options
    structure Datatypes = Types.Datatypes
    structure RuntimeEnv = RuntimeEnv
    structure NewMap = Datatypes.NewMap
    structure Ident = Datatypes.Ident

    structure Value = MLWorks.Internal.Value
    structure Frame = Value.Frame

    val frame_double = MLWorks.Internal.Runtime.environment "debugger frame double"

(*
    fun make_real_from_spill(frame, offset) =
      let
	val r = ref 0.0
	val ptr = make_pointer(frame, offset)
      in
	Value.unsafe_record_update(!r, 1, Value.unsafe_record_sub(ptr, 0));
	Value.unsafe_record_update(!r, 2, Value.unsafe_record_sub(ptr, 1));
	Value.cast(!)r
      end
*)

    val do_debug = false
    val do_debug_print_env = false
    val do_spill_debug = false
    val debug_out = TextIO.stdErr

    val my_debug = false
    fun debug s = if my_debug then TextIO.output (debug_out,"  # " ^ s ^ "\n") else ()

    local
      exception Finished of string
      val initial_value = Value.cast 0

      (* instances are passed around as an extra argument at runtime :
       ZERO : no instance(useful in self-calls and mutual-recursion)
       ONE (i) : the ith instances of type variables of the function
       TWO (i,i') : the i'th instance of the ith instance
       (for types with some polymorphic signature constraint)

       This object is constructed by the Lambda Translator.
       *)

      open RuntimeEnv

      type Substitution = ((int * Type * Instance) ref * Type) list

      fun is_builtin_typename typename =
        (Lists.member(typename,
                      ["bool","int","real","string","list","ref",
                       "exn","ml_value","array","vector","bytearray","dynamic","type_rep"]))

      fun print_tag (CONSTRUCTOR (tag)) = ": " ^ tag
        | print_tag (INT(tag)) = "int: " ^ tag
        | print_tag (REAL(tag)) = "real: " ^ tag
        | print_tag (STRING(tag)) = "string: " ^ tag
        | print_tag (CHAR(tag)) = "char: " ^ tag
        | print_tag (WORD(tag)) = "word: " ^ tag
        | print_tag DYNAMIC = "<dynamic>"
        | print_tag DEFAULT = "<default>"

      fun debug_print env =
        let
	  fun print_spill_type RuntimeEnv.GC = "(GC)"
	    | print_spill_type RuntimeEnv.NONGC = "(NONGC)"
	    | print_spill_type RuntimeEnv.FP = "(FP)"

          fun print_offset NONE = ""
            | print_offset (SOME(ref(OFFSET2(spill_ty, offset)))) =
              ":OFFSET2" ^ print_spill_type spill_ty ^
	      Int.toString offset ^ "\n" ^ " = "
            | print_offset (SOME(ref(OFFSET1 offset))) =
              ":OFFSET1" ^ Int.toString offset ^ "\n" ^ " = "

          fun debug_print (LET(envs,env)) indent =
            (TextIO.output(debug_out,"\n"^indent^"LET ");
             ignore(map (fn (RuntimeEnv.VARINFO (name,(ref ty,_),offset),env) =>
                  (TextIO.output(debug_out,"\n" ^ indent ^ "  val " ^ name ^ ":" ^
                          Types.extra_debug_print_type ty ^ print_offset offset);
                   debug_print env (indent^" "))
           | (_,env) => debug_print env (indent^" ")) envs);
             TextIO.output(debug_out,"\n"^indent^"IN ");
             debug_print env (indent^" ");
             TextIO.output(debug_out,"\n"^indent^"END "))
            | debug_print (FN(name,env,offset,_)) indent =
              (TextIO.output(debug_out,"\n"^indent^"FN "^name^" "
                      ^print_offset (SOME(offset)));
               debug_print env (indent^" "))
            | debug_print (APP(env1,env2,opt)) indent =
              (TextIO.output(debug_out,"\n"^indent^"APP ");
               ignore(case opt of
                  NONE => ""
                | SOME(n) => ":"^Int.toString n);
                  TextIO.output(debug_out,"\n"^indent^"(");
                  debug_print env1 (indent^" ");
                  TextIO.output(debug_out,"\n"^indent^")");
                  TextIO.output(debug_out,"\n"^indent^"(");
                  debug_print env2 (indent^" ");
                  TextIO.output(debug_out,"\n"^indent^")"))
            | debug_print (RAISE(env)) indent =
              (TextIO.output(debug_out,"\n"^indent^"RAISE ");
               debug_print env (indent^" "))
            | debug_print (SELECT(n,env)) indent =
              (TextIO.output(debug_out,"\n"^indent^"SELECT:"^Int.toString n);
               debug_print env (indent^" "))
            | debug_print (STRUCT(envs)) indent =
              (TextIO.output(debug_out,"\n"^indent^"STRUCT ");
               ignore(map (fn env => debug_print env (indent^" ")) envs);
               ())
            | debug_print (LIST(envs)) indent =
              (TextIO.output(debug_out,"\n"^indent^"LIST ");
               ignore(map (fn env => debug_print env (indent^" ")) envs);
               ())
            | debug_print (SWITCH(env,offset,apps,envs)) indent =
              (TextIO.output(debug_out,"\n"^indent^"SWITCH "
                      ^print_offset (SOME(offset))^":"^
                      Int.toString apps);
               debug_print env (indent^" ");
               TextIO.output(debug_out,"\n"^indent^"IN ");
               ignore(map (fn (tag,env) =>
                    (TextIO.output(debug_out,"\n"^indent^"TAG:"^print_tag tag^" ");
                     debug_print env (indent^" "))) envs);
               TextIO.output(debug_out,"\n"^indent^"END "))
            | debug_print (HANDLE(env1,offset,apps,apps',env2)) indent =
              (TextIO.output(debug_out,"\n"^indent^"HANDLE "
                      ^print_offset (SOME(offset))^":"^
                      Int.toString apps^":"^
                      Int.toString apps');
              debug_print env1 (indent^" ");
              TextIO.output(debug_out,"\n"^indent^"IN ");
              debug_print env2 (indent^" ");
              TextIO.output(debug_out,"\n"^indent^"END "))
            | debug_print (EMPTY) indent = TextIO.output(debug_out,"\n"^indent^"EMPTY")
            | debug_print (BUILTIN) indent = TextIO.output(debug_out,"\n"^indent^"BUILTIN")
        in
          debug_print env ""
        end

      (* substitute type variables for correponding types in a type
       (unsafe to do this imperatively) *)
      fun subst_type(substs,ty) =
        let
          fun substitute_type(ty as Datatypes.TYVAR(tyv as
                                                    ref(_,Datatypes.NULLTYPE,_),_)) =
            (Lists.assoc(tyv,substs)
             handle Lists.Assoc => ty)
            | substitute_type(Datatypes.TYVAR(ref (_,ty,_),_)) =
              substitute_type(ty)
            | substitute_type(ty as Datatypes.METATYVAR(tyv as
                                                        ref(_,Datatypes.NULLTYPE,_),
                                                        _,_)) =
              (Lists.assoc(tyv,substs)
               handle Lists.Assoc => ty)
            | substitute_type(Datatypes.METATYVAR (ref (_,ty,_),_,_)) =
              substitute_type(ty)
            | substitute_type(ty as Datatypes.META_OVERLOADED
                              {1=ref Datatypes.NULLTYPE,...}) = ty
            | substitute_type(Datatypes.META_OVERLOADED {1=ref ty,...}) =
              substitute_type(ty)
            | substitute_type(Datatypes.METARECTYPE
                              (ref (_,true,
                                    ty as Datatypes.METARECTYPE _,_,_))) =
              substitute_type(ty)
            | substitute_type(Datatypes.METARECTYPE (ref (_,_,ty,_,_))) =
              substitute_type(ty)
            | substitute_type((Datatypes.RECTYPE amap)) =
              Datatypes.RECTYPE(NewMap.map
				substitute_type_map
				amap)
            | substitute_type(Datatypes.FUNTYPE(arg,res)) =
              Datatypes.FUNTYPE(substitute_type(arg),substitute_type(res))
            | substitute_type(Datatypes.CONSTYPE (tylist,tyname)) =
              Datatypes.CONSTYPE(map substitute_type tylist,tyname)
            | substitute_type(ty as Datatypes.DEBRUIJN(_,_,_,SOME(tyv))) =
              (Lists.assoc(tyv,substs)
               handle Lists.Assoc => ty)
            | substitute_type ty = ty

	  and substitute_type_map(_, ty) = substitute_type ty

        in
          substitute_type(ty)
        end

      (* instantiate a type using instance passed to function at runtime *)
      (* Objects of this type are constructed in _lambda *)

      fun instantiate_instance (instance,offset,tyvar) =
        (case instance of
          Datatypes.NO_INSTANCE => Crash.impossible "1:instantiate_instance:debugger_print"
        | Datatypes.SIGNATURE_INSTANCE _ => Crash.impossible "2:instantiate_instance:debugger_print"
        | Datatypes.INSTANCE instance_list =>
            (case offset of
               Datatypes.ZERO =>
                 (debug "No instance"; Datatypes.METATYVAR (tyvar,false,false))
             | Datatypes.ONE inst =>
                 (* Find the n-1 th instantiation *)
                 (debug "One instance"; Datatypes.METATYVAR (Lists.nth (inst-1, rev instance_list), false, false))
             | Datatypes.TWO (inst,inst') =>
                 (* Find a sub instantiation -- does this ever happen? *)
                 (debug "Double instance";
                  case Lists.nth (inst-1, rev instance_list) of
                    tyvar as ref (_,ty,instances) =>
                      (case ty of
                         Datatypes.NULLTYPE => instantiate_instance (instances,Datatypes.ONE inst',tyvar)
                       | _ =>
                           let
                             val tyvars = Types.all_tyvars(ty)
                             val tys = map (fn tyvar as ref (_,_,instances) =>
                                            instantiate_instance (instances,Datatypes.ONE inst',tyvar)) tyvars
                           in
                             Lists.reducel
                             (fn (ty,tyvar) =>
                              subst_type ([tyvar],ty))
                             (ty,Lists.zip (tyvars,tys))
                           end))))

      (* Should only have OFFSET2s by now (real stack offsets) *)
      fun fetch_offset (ref (OFFSET2 spill_info)) = spill_info
        | fetch_offset _ = Crash.impossible "fetch_offset:debugger_print"

    in
      fun print_env ((present_frame,env,present_ty),print_value,options,windowing,frames) =
        let
          val result : string ref = ref ""(*"\nprint_env entered with ty = " ^ Types.extra_debug_print_type present_ty ^ "\n"*)
          fun output' str = result := (!result) ^ str

          local
            val windowing_info:
              (string * (Type * Value.ml_value * string)) list ref = ref []
          in
            val (accumulate_windowing_info,return_windowing_info) =
              if windowing then
                (fn info =>
                 windowing_info := info::(!windowing_info),
                 fn () => rev(!windowing_info))
              else
                (fn _ => (),
                 fn _ => nil)
          end

          val Options.OPTIONS{print_options,...} = options

          val _ =
            if not (Frame.frame_allocations present_frame) then
              raise Finished("No stack allocations \n")
            else ()

          val apps = ref 0

          (* First spill appears to indicate how far the function call has progressed *)
          val (fnstr,env,first_spill,bound_tyvars) =
           case env of
             FN (name,env,ref(OFFSET2(_, offset)),bound_tyvars) =>
               ("fn " ^ name,env,Value.cast (Frame.frame_offset(present_frame,offset)) : int,bound_tyvars)
           (* What does this mean? *)
           | FN (name,env,ref (OFFSET1 1),_) =>
               raise Finished("Nothing useful to print : No Code Transfer \n")
           | EMPTY => raise Finished("")
           | _ => Crash.impossible "print_env:debugger_print"

          val _ =
            if do_debug_print_env then
              (TextIO.output(debug_out,"Debug printing env ...\n");
               debug_print env;
               TextIO.output(debug_out,"\n first spill = "^
                      Int.toString first_spill^"\n"))
            else ()

          (*
           * At the time of writing, the INTERCEPT slot comes before
           * the code that clears some of the spill slots that the
           * debugger needs to access.  Consequently, bogus values
           * can be read from the uninitialised spill slots.  Fortunately
           * on MIPS/I386, the stack slots are initialised with 0 as a
           * by product of the entry code which ensures that stack slots have
           * a GC friendly value in them.  On a SPARC, std %g0 is used to
           * initialise the slots and this means that %g1 gets shoved
           * into some slots.  Fortunately %g1 is the heap limit and so
           * is rather a large value.  The following hack ignores
           * the call code value if it is larger than some arbitrary 
           * small limit.  Remove this hack if/when bug 1414 is fixed
           * properly.
           *)
          val arbitraryUpperBound = 8192
          val _ =
            if first_spill = 0 orelse first_spill > arbitraryUpperBound
            then raise Finished("Nothing useful to print : No calls made \n")
            else ()

          (* Where does this get built? *)
          datatype type_function = TYFUN of (int * type_function) list
          exception TyfunInstantiation of string
          exception ValenvInstantiation of string

          type tyfun_substitution = (Datatypes.Tyfun ref * Datatypes.Tyfun ref) list


          val tfs : tyfun_substitution ref = ref []
          val ves : (Datatypes.Valenv ref * Datatypes.Valenv ref) list ref = ref []
          val dummy_false = ref(false)
          val dummy_ve = ref(Datatypes.empty_valenv)

          fun type_spills (tyfun,Datatypes.CONSTYPE(tys,tyn)) =
            let
              val (tyn, tyfun) = tyname_spills (tyfun,tyn)
              val (tys, tyfun) =
                Lists.reducel
                (fn ((tys,tyfun),ty) =>
                 let
                   val (ty, tyfun) = type_spills(tyfun,ty)
                 in
                   (ty::tys, tyfun)
                 end) ((nil, tyfun), tys)
            in
              (Datatypes.CONSTYPE(tys, tyn), tyfun)
            end
            | type_spills (tyfun,Datatypes.FUNTYPE(ty1,ty2)) =
              let
                val (ty1, tyfun) = type_spills (tyfun,ty1)
                val (ty2, tyfun) = type_spills (tyfun,ty2)
              in
                (Datatypes.FUNTYPE(ty1,ty2), tyfun)
              end
            | type_spills (tyfun,Datatypes.RECTYPE map) =
              let
                val (map, tyfun) =
                  NewMap.fold
		  (fn ((map, tyfun), lab, ty) =>
                   let
                     val (ty, tyfun) = type_spills (tyfun,ty)
                   in
                     (NewMap.define'(map, (lab,ty)), tyfun)
                   end)
		  ((NewMap.empty' Ident.lab_lt, tyfun), map)
              in
                (Datatypes.RECTYPE(map), tyfun)
              end
            | type_spills (tyfun,Datatypes.METATYVAR(ref(n,ty,i),b1,b2)) =
              let
                val (ty, tyfun) = type_spills (tyfun,ty)
              in
                (Datatypes.METATYVAR(ref(n,ty,i),b1,b2), tyfun)
              end
            | type_spills
              (tyfun,Datatypes.META_OVERLOADED(ref(ty),tv,valid,loc)) =
              let
                val (ty, tyfun) = type_spills(tyfun,ty)
              in
                (Datatypes.META_OVERLOADED(ref(ty),tv,valid,loc), tyfun)
              end
            | type_spills (tyfun,Datatypes.TYVAR(ref(n,ty,i),id)) =
              let
                val (ty, tyfun) = type_spills(tyfun,ty)
              in
                (Datatypes.TYVAR(ref(n,ty,i),id), tyfun)
              end
            | type_spills (tyfun,Datatypes.METARECTYPE(ref(n,b1,ty,b2,b3))) =
              let
                val (ty, tyfun) = type_spills(tyfun,ty)
              in
                (Datatypes.METARECTYPE(ref(n,b1,ty,b2,b3)), tyfun)
              end
            | type_spills (tyfun,ty) = (ty, tyfun)
          and typescheme_spills (tyfun,Datatypes.SCHEME(n,(ty,i))) =
            let
              val (ty, tyfun) = type_spills (tyfun,ty)
            in
              (Datatypes.SCHEME(n,(ty,i)), tyfun)
            end
            | typescheme_spills (tyfun,Datatypes.UNBOUND_SCHEME(ty,i)) =
              let
                val (ty, tyfun) = type_spills (tyfun,ty)
              in
                (Datatypes.UNBOUND_SCHEME(ty,i), tyfun)
              end
            | typescheme_spills (tyfun,sch) = (sch, tyfun)
          and tyname_spills (tyfun,tyname) =
            let
              fun tyname_spills'
                (m as Datatypes.METATYNAME(tf as ref(Datatypes.NULL_TYFUN(_)),name,n,b,
                                           ve' as ref(Datatypes.VE(n',ve)),abs)) =
                if NewMap.is_empty ve then
                  (Datatypes.METATYNAME(Lists.assoc(tf,!tfs),name,n,b,ve',abs),tyfun)
                  handle Lists.Assoc =>
                    let
                      val ((spill,tyfun),tyfun') =
                        (case tyfun of
                          TYFUN (spill::spills) => (spill, TYFUN spills)
                        | _ => raise TyfunInstantiation name)
                      val _ = debug ("spill for: " ^ name ^ " = " ^ Int.toString spill)
                    in
                      (case spill of
                         ~1 => Crash.impossible "~1:tyname_spills':debugger_print"
                       | ~2 => Crash.impossible "~2:tyname_spills':debugger_print"
                       | ~3 => Crash.impossible "~3:tyname_spills':debugger_print"
                       | ~4 => Crash.impossible "~4:tyname_spills':debugger_print"
                       | ~5 =>
                           (TextIO.output(debug_out,"WARNING: tyfun instantiation incomplete because of a previous compilation\n");m)
                       | ~6 => Crash.impossible "~6:tyname_spills':debugger_print"
                       | _ =>
                           let
                             val tf' = ref (Types.fetch_tyfun_instantiation spill)
                             val _ =
                               if do_spill_debug then
                                 debug ("tf = "^Types.string_tyfun (!tf') ^
                                        "\nspill = " ^ Int.toString spill)
                               else ()
                             val old_tfs = !tfs
                             val old_ves = !ves
                             val _ = (tfs := nil;
                                      ves := nil)
                             val tf'' = case tyname_spills
                               (tyfun,Datatypes.METATYNAME(tf',"",0,dummy_false,
                                                           dummy_ve,dummy_false)) of
                               (Datatypes.METATYNAME(ref(tf''),_,_,_,_,_),_) => tf''
                             | _ => Crash.impossible"tyname_spills':debugger_print"
                             val _ =
                               if do_debug then
                                 TextIO.output(debug_out,"\n instantiation completed for spill "
                                        ^Int.toString spill^"\n")
                               else ()
                           in
                             (tfs := (tf,tf')::old_tfs;
                              ves := old_ves;
                              tf' := tf'';
                              Datatypes.METATYNAME(tf',name,n,b,ve',abs))
                           end,
                         tyfun')
                    end
                else
		  ((Datatypes.METATYNAME(tf,name,n,b,Lists.assoc(ve',!ves),abs), tyfun)
		   handle Lists.Assoc =>
		     let
		       val ve'' = ref(Datatypes.VE(n',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
		       val (map, tyfun) =
			 (ves := (ve',ve'')::(!ves);
			  NewMap.fold (fn ((map,tyfun),valid,sch) =>
				       let
					 val (sch, tyfun) = typescheme_spills (tyfun,sch)
				       in
					 (NewMap.define(map,valid,sch), tyfun)
				       end)
			  ((NewMap.empty (Ident.valid_lt, Ident.valid_eq), tyfun), ve))
		     in
		       (ve'' := Datatypes.VE(n',map);
			(Datatypes.METATYNAME(tf,name,n,b,ve'',abs), tyfun))
		     end)
                | tyname_spills' (Datatypes.METATYNAME(ref(Datatypes.ETA_TYFUN(tyn)),name,n,b,
						       ve' as ref(Datatypes.VE(n',ve)),abs)) =
		  let
		    val (tyn, tyfun) = tyname_spills' tyn
		    val tf = ref(Datatypes.ETA_TYFUN(tyn))
		  in
		    ((Datatypes.METATYNAME(tf,name,n,b,Lists.assoc(ve',!ves),abs), tyfun)
		     handle Lists.Assoc =>
		       let
			 val ve'' = ref(Datatypes.VE(n',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
			 val (map, tyfun) =
			   (ves := (ve',ve'')::(!ves);
			    NewMap.fold (fn ((map,tyfun),valid,sch) =>
					 let
					   val (sch, tyfun) = typescheme_spills (tyfun,sch)
					 in
					   (NewMap.define(map,valid,sch), tyfun)
					 end)
			    ((NewMap.empty (Ident.valid_lt, Ident.valid_eq), tyfun), ve))
		       in
			 (ve'' := Datatypes.VE(n',map);
			  (Datatypes.METATYNAME(tf,name,n,b,ve'',abs), tyfun))
		       end)
		  end
		| tyname_spills' (Datatypes.METATYNAME(ref(Datatypes.TYFUN(ty,n)),name,n',b,
						       ve' as ref(Datatypes.VE(n'',ve)),abs)) =
		  let
		    val (ty, tyfun) = type_spills (tyfun,ty)
		    val tf = ref(Datatypes.TYFUN(ty,n))
		  in
		    ((Datatypes.METATYNAME(tf,name,n,b,Lists.assoc(ve',!ves),abs), tyfun)
		     handle Lists.Assoc =>
		       let
			 val ve'' = ref(Datatypes.VE(n'',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
			 val (map, tyfun) =
			   (ves := (ve',ve'')::(!ves);
			    NewMap.fold (fn ((map,tyfun),valid,sch) =>
					 let
					   val (sch, tyfun) = typescheme_spills (tyfun,sch)
					 in
					   (NewMap.define(map,valid,sch), tyfun)
					 end)
			    ((NewMap.empty (Ident.valid_lt, Ident.valid_eq), tyfun), ve))
		       in
			 (ve'' := Datatypes.VE(n'',map);
			  (Datatypes.METATYNAME(tf,name,n',b,ve'',abs), tyfun))
		       end)
		  end
		| tyname_spills'
                  (Datatypes.TYNAME(id,namestring,n,b,
                                    ve1 as ref(Datatypes.VE(n1,ve2)),
                                    s',abs,
                                    ve3 as ref(Datatypes.VE(n2,ve4)),
                                    lev)) =
		  let
		    val _ =
		      if Datatypes.NewMap.is_empty ve4 andalso 
                             not (is_builtin_typename namestring) then
			raise ValenvInstantiation namestring
		      else ()
		    val (ve',ve,n') = (ve3,ve4,n2)
		  in
		    ((Datatypes.TYNAME(id,namestring,n,b,
                                       Lists.assoc(ve',!ves),s',abs,ve3,lev),
                                       tyfun)
		     handle Lists.Assoc =>
		       let
			 val ve'' = ref(Datatypes.VE(n',NewMap.empty 
                                                     (Ident.valid_lt, 
                                                      Ident.valid_eq)))
			 val (map, tyfun) =
			   (ves := (ve',ve'')::(!ves);
			    NewMap.fold
			    (fn ((map,tyfun),valid,sch) =>
			     let
			       val (sch, tyfun) = typescheme_spills (tyfun,sch)
			     in
			       (NewMap.define(map,valid,sch), tyfun)
			     end)
			    ((NewMap.empty (Ident.valid_lt, Ident.valid_eq),
                              tyfun), ve))
		       in
			 (ve'' := Datatypes.VE(n',map);
			  (Datatypes.TYNAME(id,namestring,n,b,ve'',s',abs,
                                            ve',lev), tyfun))
		       end)
		  end
            in
              tyname_spills' tyname
            end

          val substs_ref : Substitution ref = ref []

	  fun print_env_type(LET _) = "LET\n"
	    | print_env_type(FN(str, _, _, info)) =
	      (case info of
		 USER_FUNCTION =>  "FN(USER_FUNCTION)"
               | LOCAL_FUNCTION => "FN(LOCAL_FUNCTION)"
	       | INTERNAL_FUNCTION => "FN(INTERNAL_FUNCTION)"
	       | FUNINFO _ => "FN(FUNINFO)") ^ " for " ^ str
	    | print_env_type(APP _) = "APP"
	    | print_env_type(RAISE _) = "RAISE"
	    | print_env_type(SELECT _) = "SELECT"
	    | print_env_type(STRUCT _) = "STRUCT"
	    | print_env_type(LIST _) = "LIST"
	    | print_env_type(SWITCH _) = "SWITCH"
	    | print_env_type(HANDLE _) = "HANDLE"
	    | print_env_type(EMPTY) = "EMPTY"
	    | print_env_type(BUILTIN) = "BUILTIN"

          (* look up parent frames for polymorphic instances *)
          fun instantiate_type ([], ty) = (debug "Out of frames"; subst_type (!substs_ref,ty))
            | instantiate_type ((frame,env,frame_ty)::frames, ty) =
              let
                (* Substitute in *)
                val ty = subst_type (!substs_ref,ty)
                val tyvars = Types.all_tyvars ty
              in
                (* Are we done yet? *)
                case tyvars of
                  [] => (debug "instantiate_type done"; ty)
                | _ =>
                    case env of
                      FN (_,_,_,RuntimeEnv.FUNINFO (bound_tyvars,offset)) =>
                        let
			  val _ = debug"instantiate_type: FN"
                          (* The tyvars we are interested in *)
                          val bound_tyvars =
			    Lists.filterp
			    (fn tyv => Lists.member(tyv,tyvars))
			    bound_tyvars
                          val _ = if Lists.length bound_tyvars > 0 then
                            print("Found " ^ Int.toString (Lists.length bound_tyvars) ^ "\n")
                            else ()
                          (* fetch runtime instance of function *)
                          (* The function offset gets set as a side effect of the relevant variable offset being set *)
                          val offset =
			    Value.cast (Frame.frame_offset (frame,#2(fetch_offset offset)))
			  (* This should never be outside the GC area *)
                          (* Fill in their instantiations *)
                          val _ =
                            substs_ref :=
                              Lists.reducel
                              (fn (substs,tyvar as ref(_,_,instance)) =>
                               (tyvar,instantiate_instance (instance,offset,tyvar)) :: substs)
                              (!substs_ref,bound_tyvars)
                        in
                          (* and continue *)
                          instantiate_type (frames, ty)
                        end
                    (* Continue if no information *)
                    | env =>
			let
			  val _ = debug"instantiate_type: not FN"
			  val _ = debug(print_env_type env)
			in
			  instantiate_type (frames, ty)
			end
              end


          (* print runtime environment;
             reflects particular sequence and control transfers taken at runtime *)
	  val seen_tyvars = ref(Types.no_tyvars)

          fun print_env((LET (envs, env)), indent, ns, spill) =
           (case env of
              LET(envs',env) => print_env((LET (envs@@envs',env)), indent, ns, spill)
            | _ =>
                (ignore(map
                 (fn (RuntimeEnv.VARINFO (name,(ref ty,ref (RuntimeEnv.RUNTIMEINFO(_,spills))),offset),env) =>
                  (let
                    val ty =
                      if Types.isFunType ty then ty
                      else
                        let
                          val tyfun =
                            TYFUN
                            (map (fn (tf as ref(Datatypes.NULL_TYFUN(_)),spill) =>
                                  (if do_spill_debug then
                                     (TextIO.output(debug_out,name^ ":spill:" ^
                                             Int.toString
					     (#1(Value.cast (Frame.frame_offset
                                                             (present_frame,#2(fetch_offset spill)))
						 :int * type_function)) ^ "\n")
				     (* offset should always be in gc area *)
                                     )
                                   else ();
                                     Value.cast (Frame.frame_offset
                                                 (present_frame,#2(fetch_offset spill)))
				     (* This should all be in the GC area *))
                          | _ => Crash.impossible "spills:print_env:debugger_print") spills)
                        in
                          #1(type_spills(tyfun,ty))
                          handle TyfunInstantiation(tyname) =>
                            (if do_debug
                               then TextIO.output(debug_out,"WARNING: Tyfun Instantiation failed in "^tyname^" in "^name^"\n")
                             else ();
                             ty)
                               | ValenvInstantiation(tyname) =>
                                   (if do_debug
                                      then TextIO.output(debug_out,"WARNING: Valenv Instantiation failed in "^tyname^
                                                  " in "^name^"\n")
                                    else ();
                                    ty)
                        end
                    val (ty,inst_ty) =
                      case Types.all_tyvars ty of
                        nil =>
			  (ty,NONE)
                      | tyvars =>
                          (* Attempt to instantiate the type *)
			  let
			    val _ =
			      case frames of
				[] => debug"Instantiating with no frames"
			      | _ => debug"Instantiating with some frames"
			  in
                          (instantiate_type (frames, ty),
                           SOME ty)
			  end
                    (* print_env must be invoked before print_value here! *)
                    val _ = print_env(env, (indent ^ " "), ns, spill)
                    val (value,value_string) =
                      case offset of
                        NONE => (initial_value,"unavailable")
                      | SOME (ref (OFFSET2(spill_ty, offset))) =>
                          let
                            val value =
			      if Types.real_typep ty then
				case spill_ty of
				  RuntimeEnv.GC =>
				    Frame.frame_offset (present_frame,offset)
				| RuntimeEnv.FP =>
				    Frame.frame_double(present_frame, offset)
				| RuntimeEnv.NONGC =>
				    Crash.impossible"print_env:NONGC"
			      else
				Frame.frame_offset (present_frame,offset)
                            val _ =
                              if do_debug then
                                if Types.isFunType ty
                                  then ()
                                else
				  let
				    val (type_str, tyvars) =
				      Types.print_type_with_seen_tyvars
				      (options, ty, !seen_tyvars)
				    val _ = seen_tyvars := tyvars
				  in
                                    TextIO.output
				      (debug_out," type: " ^ type_str ^ "\n")
				  end
                              else ();
                          in
                            (value,print_value (ty,value))
                          end
                      | _ => Crash.impossible "LET:print_env:debugger_print"
                    val _ =
                      output'("\n" ^ indent ^ "val " ^ name ^ " : " ^
                              (case inst_ty of
                                 SOME ty =>
				   Types.print_type options ty
                               | NONE =>
				   Types.print_type options ty) ^
				 " = " ^ value_string)
                  in
                    accumulate_windowing_info(name,(ty,value,value_string))
                  end)
               | (_,env) => print_env(env, (indent ^ " "), ns, spill))
                 envs);
                 print_env(env, (indent ^ " "), ns, spill)))
            | print_env((FN (name,_,_,_)), indent, _, _) =
              (* Why is this a crash -- should the FN case be a separate type? *)
              Crash.impossible "FN:print_env:debugger_print"
            | print_env((APP(BUILTIN,env,NONE)), indent, ns, spill) =
              print_env(env, indent, ns, spill)
            | print_env(APP(env1,env2,SOME(apps')), indent, ns, spill) =
              let
                val old_apps = !apps
                val _ = apps := apps'
                val _ = print_env(env1, indent, ns, spill)
                val new_apps = !apps
                val _ = apps := old_apps
                val _ = print_env(env2, indent, ns, spill)
                val _ = apps := new_apps
              in
                (apps := !apps + 1;
                 if !apps = spill then
                   raise Finished(!result)
                 else
                   ())
              end
            | print_env((APP(env1,env2,NONE)), indent, ns, spill) =
              let
                fun print_envs()=
                    (print_env(env1, indent, ns, spill);
                     print_env(env2, indent, ns, spill))
              in
                (apps := !apps + 1;
                 (* increment before print_envs - in step with mir_cg *)
                 if !apps = spill then
                   let
                     val _ = print_envs()
                     handle Finished _ =>
                       Crash.impossible "Finished:APP:print_env:debugger_print"
                   in
                     (apps := spill;
                      raise Finished(!result))
                   end
                 else
                   print_envs())
              end
            | print_env((RAISE(env)), indent, ns, spill) =
              (apps := !apps + 1;
               (* increment before print_env - in step with mir_cg *)
               if !apps = spill then
                 let
                   val _ =
                     print_env(env, (indent ^ " "), ns, spill)
                     handle Finished _ =>
                       Crash.impossible "Finished:RAISE:print_env:debugger_print"
                 in
                   (apps := spill;
                    raise Finished(!result))
                 end
               else
                 print_env(env, (indent ^ " "), ns, spill))
            | print_env((SELECT(n,env)), indent, ns, spill) =
              print_env(env, indent, (n::ns), spill)
            | print_env((STRUCT(envs)), indent, ns, spill) =
              (case ns of
                 nil => (ignore(map (fn env => print_env(env, indent, ns, spill)) envs); ())
               | n::ns =>
                   print_env((Lists.nth(n,envs)), indent, ns, spill))
            | print_env((LIST(envs)), indent, ns, spill) =
              (ignore(map (fn env => print_env(env, indent, ns, spill)) envs); ())
            | print_env((SWITCH(env,ref(OFFSET2(spill_ty, offset)),apps',envs)), indent, ns, spill) =
              let
                val old_apps = !apps
                val _ =
                  (apps := apps';
                   print_env(env, (indent ^ " "), ns, spill))
                val new_apps = !apps
                val which_switch = Value.cast (Frame.frame_offset (present_frame,offset)) : int
		(* This is always from the GC area *)
                val (tag,which_env) = Lists.nth (which_switch,envs)
                val _ = output'("\n" ^ indent ^ "switching on " ^  print_tag tag)
                val old_tfs = !tfs
                val old_ves = !ves
                val envsstr =
                  (apps := old_apps;
                   tfs := []; ves := [];
                   print_env(which_env, (indent ^ " "), ns, spill))
                  handle exn => (tfs := old_tfs; ves := old_ves; raise exn)
                val _ = tfs := old_tfs
                val _ = ves := old_ves
              in
                apps := new_apps
              end
            | print_env((HANDLE(env1,ref(offset),
                                apps',apps'',env2)), indent, ns, spill) =
               let
                 val old_tfs = !tfs
                 val old_ves = !ves
                 val _ = (tfs := []; ves := [])
                 val old_apps = !apps
                 val _ = apps := apps'
                 val spill' = case offset of
		   OFFSET2(spill_ty, offset) =>
		     (case spill_ty of
			RuntimeEnv.FP => Frame.frame_double(present_frame,offset)
		      | _ => Frame.frame_offset(present_frame,offset))
		 | OFFSET1 _ => Crash.impossible "OFFSET1 in HANDLE print_env" (* spill *)
                 val spill' : int = Value.cast spill'
                 val _ =
                   if do_debug then
                     TextIO.output(debug_out,"  handle spill = " ^
                            Int.toString spill' ^ "\n")
                   else
                     ()
                 val _ = print_env(env1, (indent ^ " "), ns, spill')
                         handle Finished _ => ()
               in
                 (tfs := old_tfs;
                  ves := old_ves;
                  if !apps = spill then
                   raise Finished(!result)
                  else
                    apps := apps'')
               end
            | print_env((EMPTY), _, _, _) = ()
            | print_env((BUILTIN), _, _, _) = ()
            | print_env(_, _, _, _) = Crash.impossible "print_env:print_env:debugger_print"

        in
           (fnstr ^ ((print_env(env, (" "), nil, first_spill); !result ^ "\n")
                     handle Finished str => str ^ "\n"),
            return_windowing_info())
        end
      handle Finished(str) => (str,[])
           | Lists.Nth => ("Can't display information for this frame\n",[])

    end


  end
@


1.35.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.35  1998/02/19  19:32:35  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.34
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@d4 4
d226 1
a226 1
             map (fn (RuntimeEnv.VARINFO (name,(ref ty,_),offset),env) =>
d230 1
a230 1
           | (_,env) => debug_print env (indent^" ")) envs;
d240 1
a240 1
               (case opt of
d257 1
a257 1
               map (fn env => debug_print env (indent^" ")) envs;
d261 1
a261 1
               map (fn env => debug_print env (indent^" ")) envs;
d269 1
a269 1
               map (fn (tag,env) =>
d271 1
a271 1
                     debug_print env (indent^" "))) envs;
d767 1
a767 1
                (map
d868 1
a868 1
                 envs;
d930 1
a930 1
                 nil => (map (fn env => print_env(env, indent, ns, spill)) envs; ())
d934 1
a934 1
              (map (fn env => print_env(env, indent, ns, spill)) envs; ())
@


1.34.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.34  1997/05/21  16:26:56  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.34.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.34  1997/05/21  16:26:56  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.33
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d118 1
d171 1
a171 1
    val debug_out = MLWorks.IO.std_err
d174 1
a174 1
    fun debug s = if my_debug then MLWorks.IO.output (debug_out,"  # " ^ s ^ "\n") else ()
d221 1
a221 1
            (MLWorks.IO.output(debug_out,"\n"^indent^"LET ");
d223 1
a223 1
                  (MLWorks.IO.output(debug_out,"\n" ^ indent ^ "  val " ^ name ^ ":" ^
d227 1
a227 1
             MLWorks.IO.output(debug_out,"\n"^indent^"IN ");
d229 1
a229 1
             MLWorks.IO.output(debug_out,"\n"^indent^"END "))
d231 1
a231 1
              (MLWorks.IO.output(debug_out,"\n"^indent^"FN "^name^" "
d235 1
a235 1
              (MLWorks.IO.output(debug_out,"\n"^indent^"APP ");
d239 1
a239 1
                  MLWorks.IO.output(debug_out,"\n"^indent^"(");
d241 2
a242 2
                  MLWorks.IO.output(debug_out,"\n"^indent^")");
                  MLWorks.IO.output(debug_out,"\n"^indent^"(");
d244 1
a244 1
                  MLWorks.IO.output(debug_out,"\n"^indent^")"))
d246 1
a246 1
              (MLWorks.IO.output(debug_out,"\n"^indent^"RAISE ");
d249 1
a249 1
              (MLWorks.IO.output(debug_out,"\n"^indent^"SELECT:"^Int.toString n);
d252 1
a252 1
              (MLWorks.IO.output(debug_out,"\n"^indent^"STRUCT ");
d256 1
a256 1
              (MLWorks.IO.output(debug_out,"\n"^indent^"LIST ");
d260 1
a260 1
              (MLWorks.IO.output(debug_out,"\n"^indent^"SWITCH "
d264 1
a264 1
               MLWorks.IO.output(debug_out,"\n"^indent^"IN ");
d266 1
a266 1
                    (MLWorks.IO.output(debug_out,"\n"^indent^"TAG:"^print_tag tag^" ");
d268 1
a268 1
               MLWorks.IO.output(debug_out,"\n"^indent^"END "))
d270 1
a270 1
              (MLWorks.IO.output(debug_out,"\n"^indent^"HANDLE "
d275 1
a275 1
              MLWorks.IO.output(debug_out,"\n"^indent^"IN ");
d277 3
a279 3
              MLWorks.IO.output(debug_out,"\n"^indent^"END "))
            | debug_print (EMPTY) indent = MLWorks.IO.output(debug_out,"\n"^indent^"EMPTY")
            | debug_print (BUILTIN) indent = MLWorks.IO.output(debug_out,"\n"^indent^"BUILTIN")
d409 1
a409 1
              (MLWorks.IO.output(debug_out,"Debug printing env ...\n");
d411 1
a411 1
               MLWorks.IO.output(debug_out,"\n first spill = "^
d544 1
a544 1
                           (MLWorks.IO.output(debug_out,"WARNING: tyfun instantiation incomplete because of a previous compilation\n");m)
d565 1
a565 1
                                 MLWorks.IO.output(debug_out,"\n instantiation completed for spill "
d726 1
a726 1
                            MLWorks.IO.output (MLWorks.IO.std_out,"Found " ^ Int.toString (Lists.length bound_tyvars) ^ "\n")
d774 1
a774 1
                                     (MLWorks.IO.output(debug_out,name^ ":spill:" ^
d790 1
a790 1
                               then MLWorks.IO.output(debug_out,"WARNING: Tyfun Instantiation failed in "^tyname^" in "^name^"\n")
d795 1
a795 1
                                      then MLWorks.IO.output(debug_out,"WARNING: Valenv Instantiation failed in "^tyname^
d844 1
a844 1
                                    MLWorks.IO.output
d971 1
a971 1
                     MLWorks.IO.output(debug_out,"  handle spill = " ^
@


1.32
log
@[Bug #1414]
Added an temporary (and ugly) hack that hides the problem
of local variables being displayed when they shouldn't.
Just to make this clear: this change doesn't fix this bug,
it only hides the problem from the user until such time
as the bug is fixed properly.
@
text
@d4 8
d208 2
a209 2
          fun print_offset MLWorks.Option.NONE = ""
            | print_offset (MLWorks.Option.SOME(ref(OFFSET2(spill_ty, offset)))) =
d212 1
a212 1
            | print_offset (MLWorks.Option.SOME(ref(OFFSET1 offset))) =
d227 1
a227 1
                      ^print_offset (MLWorks.Option.SOME(offset)));
d232 2
a233 2
                  MLWorks.Option.NONE => ""
                | MLWorks.Option.SOME(n) => ":"^Int.toString n);
d256 1
a256 1
                      ^print_offset (MLWorks.Option.SOME(offset))^":"^
d266 1
a266 1
                      ^print_offset (MLWorks.Option.SOME(offset))^":"^
d314 1
a314 1
            | substitute_type(ty as Datatypes.DEBRUIJN(_,_,_,MLWorks.Option.SOME(tyv))) =
d798 1
a798 1
			  (ty,MLWorks.Option.NONE)
d808 1
a808 1
                           MLWorks.Option.SOME ty)
d814 2
a815 2
                        MLWorks.Option.NONE => (initial_value,"unavailable")
                      | MLWorks.Option.SOME (ref (OFFSET2(spill_ty, offset))) =>
d850 1
a850 1
                                 MLWorks.Option.SOME ty =>
d852 1
a852 1
                               | MLWorks.Option.NONE =>
d864 1
a864 1
            | print_env((APP(BUILTIN,env,MLWorks.Option.NONE)), indent, ns, spill) =
d866 1
a866 1
            | print_env(APP(env1,env2,MLWorks.Option.SOME(apps')), indent, ns, spill) =
d882 1
a882 1
            | print_env((APP(env1,env2,MLWorks.Option.NONE)), indent, ns, spill) =
@


1.32.1.1
log
@branched from 1.32
@
text
@a3 8
 * Revision 1.32  1997/03/27  16:21:38  stephenb
 * [Bug #1414]
 * Added an temporary (and ugly) hack that hides the problem
 * of local variables being displayed when they shouldn't.
 * Just to make this clear: this change doesn't fix this bug,
 * it only hides the problem from the user until such time
 * as the bug is fixed properly.
 *
@


1.32.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.32.1.1  1997/05/12  10:29:15  hope
 * branched from 1.32
 *
@


1.32.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.32.1.1  1997/05/12  10:29:15  hope
 * branched from 1.32
 *
@


1.32.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.32.1.1  1997/05/12  10:29:15  hope
 * branched from 1.32
 *
@


1.32.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.32.1.1.1.1  1997/07/28  18:15:06  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.31
log
@Adding handler for Lists.Nth exception
@
text
@d4 3
d402 16
d419 3
a421 3
            case first_spill of
              0 => raise Finished("Nothing useful to print : No calls made \n")
            | _ => ()
@


1.30
log
@Adding LOCAL_FUNCTION clause.
@
text
@d4 3
d963 1
@


1.29
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d656 1
@


1.29.4.1
log
@branched from 1.29
@
text
@a3 4
 * Revision 1.29  1996/11/06  11:22:06  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.29.3.1
log
@branched from 1.29
@
text
@a3 4
 * Revision 1.29  1996/11/06  11:22:06  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.29.3.1.1.1
log
@branched from 1.29.3.1
@
text
@a3 3
 * Revision 1.29.3.1  1996/12/17  17:43:07  hope
 * branched from 1.29
 *
@


1.29.2.1
log
@branched from 1.29
@
text
@a3 4
 * Revision 1.29  1996/11/06  11:22:06  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.29.1.1
log
@branched from 1.29
@
text
@a3 4
 * Revision 1.29  1996/11/06  11:22:06  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.29.1.1.1.1
log
@branched from 1.29.1.1
@
text
@a3 3
 * Revision 1.29.1.1  1996/11/14  12:43:44  hope
 * branched from 1.29
 *
@


1.28
log
@[Bug #1592]
threading level argument in tynames.
@
text
@d4 4
d95 1
a95 1
require "../basis/__integer";
@


1.28.1.1
log
@branched from 1.28
@
text
@a3 4
 * Revision 1.28  1996/10/02  15:17:31  andreww
 * [Bug #1592]
 * threading level argument in tynames.
 *
@


1.27
log
@[Bug #1521]
propagating changes made to typechecker/_types.sml
@
text
@d4 4
d599 6
a604 4
		| tyname_spills' (Datatypes.TYNAME(id,namestring,n,b,ve1 as ref(Datatypes.VE(n1,ve2)),
						   s',
						   abs,
						   ve3 as ref(Datatypes.VE(n2,ve4)))) =
d607 2
a608 1
		      if Datatypes.NewMap.is_empty ve4 andalso not (is_builtin_typename namestring) then
d613 3
a615 1
		    ((Datatypes.TYNAME(id,namestring,n,b,Lists.assoc(ve',!ves),s',abs,ve3),tyfun)
d618 3
a620 1
			 val ve'' = ref(Datatypes.VE(n',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
d630 2
a631 1
			    ((NewMap.empty (Ident.valid_lt, Ident.valid_eq), tyfun), ve))
d634 2
a635 1
			  (Datatypes.TYNAME(id,namestring,n,b,ve'',s',abs,ve'), tyfun))
@


1.27.2.1
log
@branched from 1.27
@
text
@a3 4
 * Revision 1.27  1996/08/05  16:53:23  andreww
 * [Bug #1521]
 * propagating changes made to typechecker/_types.sml
 *
@


1.27.1.1
log
@branched from 1.27
@
text
@a3 4
 * Revision 1.27  1996/08/05  16:53:23  andreww
 * [Bug #1521]
 * propagating changes made to typechecker/_types.sml
 *
@


1.26
log
@Removed MLWorks.RawIO.
@
text
@d4 3
d784 1
a784 1
				      (print_options, ty, !seen_tyvars)
d799 1
a799 1
				   Types.print_type print_options ty
d801 1
a801 1
				   Types.print_type print_options ty) ^
@


1.25
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d784 2
a785 6
                                  ((* MLWorks.IO.output(debug_out,
                                          implode ["  offset : ",Int.toString offset, "\n",
                                                   "  value : "]);
                                  Value.print(MLWorks.Internal.Value.DEFAULT, MLWorks.RawIO.std_err,value);
                                  MLWorks.IO.output (debug_out,"\n"); *)
                                  MLWorks.IO.output (debug_out,"  type: " ^ (*Types.debug_print_type ty*)type_str ^ "\n"))
@


1.24
log
@Removing MLWorks.Integer
@
text
@d4 3
d134 1
a134 1
    fun debug s = if my_debug then output (debug_out,"  # " ^ s ^ "\n") else ()
d181 1
a181 1
            (output(debug_out,"\n"^indent^"LET ");
d183 1
a183 1
                  (output(debug_out,"\n" ^ indent ^ "  val " ^ name ^ ":" ^
d187 1
a187 1
             output(debug_out,"\n"^indent^"IN ");
d189 1
a189 1
             output(debug_out,"\n"^indent^"END "))
d191 1
a191 1
              (output(debug_out,"\n"^indent^"FN "^name^" "
d195 1
a195 1
              (output(debug_out,"\n"^indent^"APP ");
d199 1
a199 1
                  output(debug_out,"\n"^indent^"(");
d201 2
a202 2
                  output(debug_out,"\n"^indent^")");
                  output(debug_out,"\n"^indent^"(");
d204 1
a204 1
                  output(debug_out,"\n"^indent^")"))
d206 1
a206 1
              (output(debug_out,"\n"^indent^"RAISE ");
d209 1
a209 1
              (output(debug_out,"\n"^indent^"SELECT:"^Int.toString n);
d212 1
a212 1
              (output(debug_out,"\n"^indent^"STRUCT ");
d216 1
a216 1
              (output(debug_out,"\n"^indent^"LIST ");
d220 1
a220 1
              (output(debug_out,"\n"^indent^"SWITCH "
d224 1
a224 1
               output(debug_out,"\n"^indent^"IN ");
d226 1
a226 1
                    (output(debug_out,"\n"^indent^"TAG:"^print_tag tag^" ");
d228 1
a228 1
               output(debug_out,"\n"^indent^"END "))
d230 1
a230 1
              (output(debug_out,"\n"^indent^"HANDLE "
d235 1
a235 1
              output(debug_out,"\n"^indent^"IN ");
d237 3
a239 3
              output(debug_out,"\n"^indent^"END "))
            | debug_print (EMPTY) indent = output(debug_out,"\n"^indent^"EMPTY")
            | debug_print (BUILTIN) indent = output(debug_out,"\n"^indent^"BUILTIN")
d369 1
a369 1
              (output(debug_out,"Debug printing env ...\n");
d371 1
a371 1
               output(debug_out,"\n first spill = "^
d488 1
a488 1
                           (output(debug_out,"WARNING: tyfun instantiation incomplete because of a previous compilation\n");m)
d509 1
a509 1
                                 output(debug_out,"\n instantiation completed for spill "
d660 1
a660 1
                            output (std_out,"Found " ^ Int.toString (Lists.length bound_tyvars) ^ "\n")
d708 1
a708 1
                                     (output(debug_out,name^ ":spill:" ^
d724 1
a724 1
                               then output(debug_out,"WARNING: Tyfun Instantiation failed in "^tyname^" in "^name^"\n")
d729 1
a729 1
                                      then output(debug_out,"WARNING: Valenv Instantiation failed in "^tyname^
d778 1
a778 1
                                  ((* output(debug_out,
d782 2
a783 2
                                  output (debug_out,"\n"); *)
                                  output (debug_out,"  type: " ^ (*Types.debug_print_type ty*)type_str ^ "\n"))
d909 1
a909 1
                     output(debug_out,"  handle spill = " ^
@


1.23
log
@Changed type of Runtime.environment
@
text
@d4 3
d75 2
d173 1
a173 1
	      MLWorks.Integer.makestring offset ^ "\n" ^ " = "
d175 1
a175 1
              ":OFFSET1" ^ MLWorks.Integer.makestring offset ^ "\n" ^ " = "
d195 1
a195 1
                | MLWorks.Option.SOME(n) => ":"^MLWorks.Integer.makestring n);
d206 1
a206 1
              (output(debug_out,"\n"^indent^"SELECT:"^MLWorks.Integer.makestring n);
d219 1
a219 1
                      MLWorks.Integer.makestring apps);
d229 2
a230 2
                      MLWorks.Integer.makestring apps^":"^
                      MLWorks.Integer.makestring apps');
d369 1
a369 1
                      MLWorks.Integer.makestring first_spill^"\n"))
d477 1
a477 1
                      val _ = debug ("spill for: " ^ name ^ " = " ^ MLWorks.Integer.makestring spill)
d493 1
a493 1
                                        "\nspill = " ^ MLWorks.Integer.makestring spill)
d507 1
a507 1
                                        ^MLWorks.Integer.makestring spill^"\n")
d657 1
a657 1
                            output (std_out,"Found " ^ MLWorks.Integer.makestring (Lists.length bound_tyvars) ^ "\n")
d706 1
a706 1
                                             MLWorks.Integer.makestring
d776 1
a776 1
                                          implode ["  offset : ",MLWorks.Integer.makestring offset, "\n",
d907 1
a907 1
                            MLWorks.Integer.makestring spill' ^ "\n")
@


1.22
log
@Converted the types Dynamic and Type to the new identifier naming scheme.
@
text
@d4 3
d103 2
a104 1
    structure Frame = MLWorks.Internal.Value.Frame
d106 1
a106 1
    val frame_double = MLWorks.Internal.Value.cast(MLWorks.Internal.Runtime.environment"debugger frame double")
d114 3
a116 3
	MLWorks.Internal.Value.unsafe_record_update(!r, 1, MLWorks.Internal.Value.unsafe_record_sub(ptr, 0));
	MLWorks.Internal.Value.unsafe_record_update(!r, 2, MLWorks.Internal.Value.unsafe_record_sub(ptr, 1));
	MLWorks.Internal.Value.cast(!)r
d130 1
a130 1
      val initial_value = MLWorks.Internal.Value.cast 0
d327 1
a327 1
              (string * (Type * MLWorks.Internal.Value.ml_value * string)) list ref = ref []
d352 1
a352 1
               ("fn " ^ name,env,Frame.frame_offset(present_frame,offset),bound_tyvars)
d657 1
a657 1
			    Frame.frame_offset (frame,#2(fetch_offset offset))
d702 3
a704 3
					     (#1(Frame.frame_offset
						 (present_frame,#2(fetch_offset spill))
						 :int * type_function))^"\n")
d708 2
a709 2
                                     Frame.frame_offset
                                     (present_frame,#2(fetch_offset spill))
d773 1
a773 2
                                  MLWorks.Internal.Value.print(MLWorks.Internal.Value.DEFAULT,
                                                               MLWorks.RawIO.std_err,value);
d868 1
a868 1
                val which_switch = Frame.frame_offset (present_frame,offset)
d898 1
@


1.21
log
@Replacing Map with NewMap
@
text
@d4 3
d144 1
a144 1
                       "exn","ml_value","array","vector","bytearray","Dynamic","Type"]))
@


1.20
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d257 3
a259 2
              Datatypes.RECTYPE (Datatypes.Mapping.mapit
                                 (amap,substitute_type))
d268 3
d399 1
a399 1
            | type_spills (tyfun,Datatypes.RECTYPE(map)) =
d402 2
a403 2
                  Datatypes.Mapping.Fold
                  (fn lab => fn ty => fn (map,tyfun) =>
d407 3
a409 2
                     (Datatypes.Mapping.add((lab,ty),map,Ident.lab_order),tyfun)
                   end) (Datatypes.Mapping.empty_map, tyfun) map
@


1.19
log
@Fix printing of reals in local variable debugging
@
text
@d4 3
d81 5
a85 6
    sharing RuntimeEnv.Option = Types.Datatypes.Option
       sharing type RuntimeEnv.Type = Types.Datatypes.Type
       sharing type Options.options = Types.Options.options
       sharing type Types.Options.print_options = Options.print_options
       sharing type Types.Datatypes.Instance = RuntimeEnv.Instance
       sharing type Types.Datatypes.Tyfun = RuntimeEnv.Tyfun
d155 2
a156 2
          fun print_offset Option.ABSENT = ""
            | print_offset (Option.PRESENT(ref(OFFSET2(spill_ty, offset)))) =
d159 1
a159 1
            | print_offset (Option.PRESENT(ref(OFFSET1 offset))) =
d174 1
a174 1
                      ^print_offset (Option.PRESENT(offset)));
d179 2
a180 2
                  Option.ABSENT => ""
                | Option.PRESENT(n) => ":"^MLWorks.Integer.makestring n);
d203 1
a203 1
                      ^print_offset (Option.PRESENT(offset))^":"^
d213 1
a213 1
                      ^print_offset (Option.PRESENT(offset))^":"^
d260 1
a260 1
            | substitute_type(ty as Datatypes.DEBRUIJN(_,_,_,Option.PRESENT(tyv))) =
d714 1
a714 1
			  (ty,Option.ABSENT)
d724 1
a724 1
                           Option.PRESENT ty)
d730 2
a731 2
                        Option.ABSENT => (initial_value,"unavailable")
                      | Option.PRESENT (ref (OFFSET2(spill_ty, offset))) =>
d771 1
a771 1
                                 Option.PRESENT ty =>
d773 1
a773 1
                               | Option.ABSENT =>
d785 1
a785 1
            | print_env((APP(BUILTIN,env,Option.ABSENT)), indent, ns, spill) =
d787 1
a787 1
            | print_env(APP(env1,env2,Option.PRESENT(apps')), indent, ns, spill) =
d803 1
a803 1
            | print_env((APP(env1,env2,Option.ABSENT)), indent, ns, spill) =
@


1.18
log
@Modify type printing in stack frames
@
text
@d4 3
d94 14
d149 4
d154 3
a156 2
            | print_offset (Option.PRESENT(ref(OFFSET2 offset))) =
              ":OFFSET2" ^ MLWorks.Integer.makestring offset ^ "\n" ^ " = "
d300 1
a300 1
      fun fetch_offset (ref (OFFSET2 offset)) = offset
d335 1
a335 1
             FN (name,env,ref(OFFSET2(offset)),bound_tyvars) =>
d639 3
a641 1
                          val offset = Frame.frame_offset (frame,fetch_offset offset)
d684 5
a688 11
                                             MLWorks.Integer.makestring (#1(Frame.frame_offset
                                                                            (present_frame,fetch_offset spill)
                                                                            :int * type_function))^"\n")
                                     (* This can be too verbose *)
(*
                                     output (debug_out, "value : ");
                                     MLWorks.Internal.Value.print(MLWorks.Internal.Value.DEFAULT,
                                                                  MLWorks.RawIO.std_err,Frame.frame_offset
                                                                  (present_frame,fetch_offset spill));
                                     output (debug_out, "\n")
*)
d692 2
a693 1
                                     (present_frame,fetch_offset spill))
d729 1
a729 1
                      | Option.PRESENT (ref (OFFSET2 offset)) =>
d731 11
a741 1
                            val value = Frame.frame_offset (present_frame,offset)
d845 1
a845 1
            | print_env((SWITCH(env,ref(OFFSET2(offset)),apps',envs)), indent, ns, spill) =
d853 1
d877 5
a881 2
                                    OFFSET2(offset) => Frame.frame_offset (present_frame,offset)
                                  | OFFSET1 _ => Crash.impossible "OFFSET1 in HANDLE print_env" (* spill *)
@


1.17
log
@Add stuff for WORDs
@
text
@d4 3
d99 1
a99 1
    local 
d108 1
a108 1
       
d130 1
a130 1
      fun debug_print env = 
d138 1
a138 1
          fun debug_print (LET(envs,env)) indent = 
d140 1
a140 1
             map (fn (RuntimeEnv.VARINFO (name,(ref ty,_),offset),env) => 
d148 1
a148 1
            | debug_print (FN(name,env,offset,_)) indent = 
d152 1
a152 1
            | debug_print (APP(env1,env2,opt)) indent = 
d154 1
a154 1
               (case opt of 
d163 1
a163 1
            | debug_print (RAISE(env)) indent = 
d166 1
a166 1
            | debug_print (SELECT(n,env)) indent = 
d169 1
a169 1
            | debug_print (STRUCT(envs)) indent = 
d173 1
a173 1
            | debug_print (LIST(envs)) indent = 
d183 1
a183 1
               map (fn (tag,env) => 
d187 1
a187 1
            | debug_print (HANDLE(env1,offset,apps,apps',env2)) indent = 
d201 1
a201 1
      
d204 1
a204 1
      fun subst_type(substs,ty) = 
d206 1
a206 1
          fun substitute_type(ty as Datatypes.TYVAR(tyv as 
d210 1
a210 1
            | substitute_type(Datatypes.TYVAR(ref (_,ty,_),_)) = 
d212 1
a212 1
            | substitute_type(ty as Datatypes.METATYVAR(tyv as 
d214 1
a214 1
                                                        _,_)) = 
d217 1
a217 1
            | substitute_type(Datatypes.METATYVAR (ref (_,ty,_),_,_)) = 
d219 1
a219 1
            | substitute_type(ty as Datatypes.META_OVERLOADED 
d223 1
a223 1
            | substitute_type(Datatypes.METARECTYPE 
d225 1
a225 1
                                    ty as Datatypes.METARECTYPE _,_,_))) = 
d227 1
a227 1
            | substitute_type(Datatypes.METARECTYPE (ref (_,_,ty,_,_))) = 
d243 1
a243 1
      
d247 1
a247 1
      fun instantiate_instance (instance,offset,tyvar) = 
d253 1
a253 1
               Datatypes.ZERO => 
d265 1
a265 1
                       | _ => 
d268 1
a268 1
                             val tys = map (fn tyvar as ref (_,_,instances) => 
d271 2
a272 2
                             Lists.reducel 
                             (fn (ty,tyvar) => 
d282 1
a282 1
      fun print_env ((present_frame,env,present_ty),print_value,options,windowing,frames) = 
d284 1
a284 1
          val result : string ref = ref ""
d291 3
a293 3
            val (accumulate_windowing_info,return_windowing_info) = 
              if windowing then 
                (fn info => 
d304 1
a304 1
            if not (Frame.frame_allocations present_frame) then 
d311 1
a311 1
          val (fnstr,env,first_spill,bound_tyvars) = 
d313 1
a313 1
             FN (name,env,ref(OFFSET2(offset)),bound_tyvars) => 
d316 1
a316 1
           | FN (name,env,ref (OFFSET1 1),_) => 
d321 2
a322 2
          val _ = 
            if do_debug_print_env then 
d329 1
a329 1
          val _ = 
d422 1
a422 1
              fun tyname_spills' 
d474 95
a568 95
                     ((Datatypes.METATYNAME(tf,name,n,b,Lists.assoc(ve',!ves),abs), tyfun)
                      handle Lists.Assoc =>
                        let
                          val ve'' = ref(Datatypes.VE(n',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
                          val (map, tyfun) =
                           (ves := (ve',ve'')::(!ves);
                            NewMap.fold (fn ((map,tyfun),valid,sch) =>
                                         let
                                           val (sch, tyfun) = typescheme_spills (tyfun,sch)
                                         in
                                           (NewMap.define(map,valid,sch), tyfun)
                                         end)
                            ((NewMap.empty (Ident.valid_lt, Ident.valid_eq), tyfun), ve))
                        in
                          (ve'' := Datatypes.VE(n',map);
                           (Datatypes.METATYNAME(tf,name,n,b,ve'',abs), tyfun))
                        end)
                   | tyname_spills' (Datatypes.METATYNAME(ref(Datatypes.ETA_TYFUN(tyn)),name,n,b,
                                                          ve' as ref(Datatypes.VE(n',ve)),abs)) =
                     let
                       val (tyn, tyfun) = tyname_spills' tyn
                       val tf = ref(Datatypes.ETA_TYFUN(tyn))
                     in
                       ((Datatypes.METATYNAME(tf,name,n,b,Lists.assoc(ve',!ves),abs), tyfun)
                        handle Lists.Assoc =>
                          let
                            val ve'' = ref(Datatypes.VE(n',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
                            val (map, tyfun) =
                              (ves := (ve',ve'')::(!ves);
                               NewMap.fold (fn ((map,tyfun),valid,sch) =>
                                            let
                                              val (sch, tyfun) = typescheme_spills (tyfun,sch)
                                            in
                                              (NewMap.define(map,valid,sch), tyfun)
                                            end)
                               ((NewMap.empty (Ident.valid_lt, Ident.valid_eq), tyfun), ve))
                          in
                            (ve'' := Datatypes.VE(n',map);
                             (Datatypes.METATYNAME(tf,name,n,b,ve'',abs), tyfun))
                          end)
                     end
                   | tyname_spills' (Datatypes.METATYNAME(ref(Datatypes.TYFUN(ty,n)),name,n',b,
                                                          ve' as ref(Datatypes.VE(n'',ve)),abs)) =
                     let
                       val (ty, tyfun) = type_spills (tyfun,ty)
                       val tf = ref(Datatypes.TYFUN(ty,n))
                     in
                       ((Datatypes.METATYNAME(tf,name,n,b,Lists.assoc(ve',!ves),abs), tyfun)
                        handle Lists.Assoc =>
                          let
                            val ve'' = ref(Datatypes.VE(n'',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
                            val (map, tyfun) =
                              (ves := (ve',ve'')::(!ves);
                               NewMap.fold (fn ((map,tyfun),valid,sch) =>
                                            let
                                              val (sch, tyfun) = typescheme_spills (tyfun,sch)
                                            in
                                              (NewMap.define(map,valid,sch), tyfun)
                                            end)
                               ((NewMap.empty (Ident.valid_lt, Ident.valid_eq), tyfun), ve))
                          in
                            (ve'' := Datatypes.VE(n'',map);
                             (Datatypes.METATYNAME(tf,name,n',b,ve'',abs), tyfun))
                          end)
                     end
                  | tyname_spills' (Datatypes.TYNAME(id,namestring,n,b,ve1 as ref(Datatypes.VE(n1,ve2)),
                                                     s',
                                                     abs,
                                                     ve3 as ref(Datatypes.VE(n2,ve4)))) =
                     let
                       val _ =
                         if Datatypes.NewMap.is_empty ve4 andalso not (is_builtin_typename namestring) then
                           raise ValenvInstantiation namestring
                         else ()
                       val (ve',ve,n') = (ve3,ve4,n2)
                     in
                       ((Datatypes.TYNAME(id,namestring,n,b,Lists.assoc(ve',!ves),s',abs,ve3),tyfun)
                        handle Lists.Assoc =>
                          let
                            val ve'' = ref(Datatypes.VE(n',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
                            val (map, tyfun) =
                              (ves := (ve',ve'')::(!ves);
                               NewMap.fold 
                               (fn ((map,tyfun),valid,sch) =>
                                let
                                  val (sch, tyfun) = typescheme_spills (tyfun,sch)
                                in
                                  (NewMap.define(map,valid,sch), tyfun)
                                end)
                               ((NewMap.empty (Ident.valid_lt, Ident.valid_eq), tyfun), ve))
                          in
                            (ve'' := Datatypes.VE(n',map);
                             (Datatypes.TYNAME(id,namestring,n,b,ve'',s',abs,ve'), tyfun))
                          end)
                     end
d575 16
d593 1
a593 1
            | instantiate_type ((frame,env,frame_ty)::frames, ty) = 
d597 1
a597 1
                val tyvars = Types.all_tyvars(ty)
d602 1
a602 1
                | _ => 
d604 1
a604 1
                      FN (_,_,_,RuntimeEnv.FUNINFO (bound_tyvars,offset)) => 
d606 1
d608 5
a612 2
                          val bound_tyvars = Lists.filterp (fn tyv => Lists.member(tyv,tyvars)) bound_tyvars
                          val _ = if Lists.length bound_tyvars > 0 then 
d619 3
a621 3
                          val _ = 
                            substs_ref := 
                              Lists.reducel 
d630 7
a636 1
                    | _ => instantiate_type (frames, ty)
d640 10
a649 8
          (* print runtime environment; 
             reflects particular sequence and control transfers taken at runtime *)             
          fun print_env (LET (envs, env)) indent ns spill =
           (case env of 
              LET(envs',env) => print_env (LET (envs@@envs',env)) indent ns spill
            | _ => 
                (map 
                 (fn (RuntimeEnv.VARINFO (name,(ref ty,ref (RuntimeEnv.RUNTIMEINFO(_,spills))),offset),env) => 
d655 1
a655 1
                          val tyfun = 
d679 1
a679 1
                            (if do_debug 
d684 1
a684 1
                                   (if do_debug 
d690 1
a690 1
                    val (ty,inst_ty) = 
d692 3
a694 2
                        nil => (ty,Option.ABSENT)
                      | tyvars => 
d696 6
d703 2
a704 1
                           Option.PRESENT(ty))
d706 1
a706 1
                    val _ = print_env env (indent ^ " ") ns spill
d708 1
a708 1
                      case offset of 
d710 1
a710 1
                      | Option.PRESENT (ref (OFFSET2 offset)) => 
d714 1
a714 1
                              if do_debug then 
d718 6
d730 2
a731 1
                                  output (debug_out,"  type: " ^ Types.debug_print_type ty ^ "\n"))
d740 5
a744 3
                                 Option.PRESENT ty => Types.print_type print_options ty ^ " : "
                               | Option.ABSENT => "") ^
                              Types.print_type print_options ty ^ " = " ^ value_string)
d748 1
a748 1
               | (_,env) => print_env env (indent ^ " ") ns spill)
d750 2
a751 2
                 print_env env (indent ^ " ") ns spill))
            | print_env (FN (name,_,_,_)) indent _ _ =
d754 4
a757 4
            | print_env (APP(BUILTIN,env,Option.ABSENT)) indent ns spill = 
              print_env env indent ns spill
            | print_env (APP(env1,env2,Option.PRESENT(apps'))) indent ns spill = 
              let 
d760 1
a760 1
                val _ = print_env env1 indent ns spill
d763 1
a763 1
                val _ = print_env env2 indent ns spill
d772 2
a773 2
            | print_env (APP(env1,env2,Option.ABSENT)) indent ns spill = 
              let 
d775 2
a776 2
                    (print_env env1 indent ns spill;
                     print_env env2 indent ns spill)
d780 2
a781 2
                 if !apps = spill then 
                   let 
d783 1
a783 1
                     handle Finished _ => 
d792 1
a792 1
            | print_env (RAISE(env)) indent ns spill = 
d796 4
a799 4
                 let 
                   val _ = 
                     print_env env (indent ^ " ") ns spill
                     handle Finished _ => 
d806 11
a816 11
                 print_env env (indent ^ " ") ns spill)
            | print_env (SELECT(n,env)) indent ns spill = 
              print_env env indent (n::ns) spill
            | print_env (STRUCT(envs)) indent ns spill = 
              (case ns of 
                 nil => (map (fn env => print_env env indent ns spill) envs; ())
               | n::ns => 
                   print_env (Lists.nth(n,envs)) indent ns spill)
            | print_env (LIST(envs)) indent ns spill = 
              (map (fn env => print_env env indent ns spill) envs; ())
            | print_env (SWITCH(env,ref(OFFSET2(offset)),apps',envs)) indent ns spill = 
d819 1
a819 1
                val _ = 
d821 1
a821 1
                   print_env env (indent ^ " ") ns spill)
d828 1
a828 1
                val envsstr = 
d831 1
a831 1
                   print_env which_env (indent ^ " ") ns spill)
d838 2
a839 2
            | print_env (HANDLE(env1,ref(offset),
                                apps',apps'',env2)) indent ns spill =
d850 2
a851 2
                   if do_debug then 
                     output(debug_out,"  handle spill = " ^ 
d855 1
a855 1
                 val _ = print_env env1 (indent ^ " ") ns spill'
d865 3
a867 3
            | print_env (EMPTY) _ _ _ = ()
            | print_env (BUILTIN) _ _ _ = ()
            | print_env _ _ _ _ = Crash.impossible "print_env:print_env:debugger_print"
d870 1
a870 1
           (fnstr ^ ((print_env env (" ") nil first_spill; !result ^ "\n")
@


1.16
log
@Add CHAR to Tag type
@
text
@d4 3
d123 1
@


1.15
log
@Making debugger platform independent
@
text
@d3 44
a46 41
$Log: _debugger_print.sml,v $
# Revision 1.13  1995/02/02  10:57:55  matthew
# More work on debugger
#
# Revision 1.12  1995/01/20  12:15:01  matthew
# Renaming debugger_env to runtime_env
#
# Revision 1.11  1994/12/15  12:38:48  matthew
# Fiddling
#
# Revision 1.10  1994/09/22  13:58:40  matthew
# Abstraction of debug information
#
# Revision 1.9  1994/06/09  15:49:06  nickh
# New runtime directory structure.
#
# Revision 1.8  1994/06/09  09:20:00  nosa
# Simplifications in debugger environment printing;
# altered HANDLE environment printing.
#
# Revision 1.7  1994/05/05  16:18:43  daveb
# Datatypes.META_OVERLOADED takes extra arguments.
#
# Revision 1.6  1994/04/13  13:43:34  jont
# Fix inexhaustive bindings
#
# Revision 1.5  1994/02/28  09:03:06  nosa
# Modules Debugger : Dynamic Type Name Instantiation.
#
# Revision 1.4  1993/09/22  12:43:35  nosa
# Polymorphic debugger.
#
# Revision 1.3  1993/08/10  14:45:05  nosa
# print_env now returns list used in inspector invocation in debugger-window.
#
# Revision 1.2  1993/08/05  09:57:10  nosa
# Changed type of print_env.
#
# Revision 1.1  1993/07/30  15:48:03  nosa
# Initial revision
#
d119 1
@


1.14
log
@Added debugging code
Changes to MLWorks.Internal.Value.Frame
@
text
@d271 1
a271 1
      fun print_env ((present_frame,env,present_ty),print_value,fetch_value,options,windowing,frames) = 
d303 1
a303 1
               ("fn " ^ name,env,fetch_value(present_frame,offset),bound_tyvars)
d341 1
a341 1
                (fn ((tys,tyfun),ty)=>
d361 1
a361 1
                  (fn lab=>fn ty=>fn (map,tyfun) =>
a578 1
                          val _ = debug ("Found frame " ^ DebuggerUtilities.frame_name frame)
d767 1
a767 1
                val which_switch = fetch_value (present_frame,offset)
d791 1
a791 1
                                    OFFSET2(offset)=>fetch_value (present_frame,offset)
@


1.13
log
@More work on debugger
@
text
@d4 3
d80 3
a82 1
    val do_debug = true
d84 1
a84 1
    val do_spill_debug = true
d87 1
a87 1
    val my_debug = true
d235 1
a235 26
(*
      fun instantiate_instance (Datatypes.NO_INSTANCE,_,_) = 
        Crash.impossible "1:instantiate_instance:debugger_print"
        | instantiate_instance(Datatypes.SIGNATURE_INSTANCE _,_,_) = 
          Crash.impossible "2:instantiate_instance:debugger_print"
        | instantiate_instance (_, Datatypes.ZERO, tyvar) = (* No instantiation *)
          Datatypes.METATYVAR (tyvar,false,false)
        | instantiate_instance (instance as Datatypes.INSTANCE instances, Datatypes.ONE inst,_) = 
          Datatypes.METATYVAR (Lists.nth (inst-1,rev instances),false,false)
        | instantiate_instance (instance as Datatypes.INSTANCE instances,Datatypes.TWO (inst,inst'),tyv) = 
          (case Lists.nth (inst-1,rev instances) of
             tyvar as ref(_,ty,instances) =>
               (case ty of
                  Datatypes.NULLTYPE => instantiate_instance (instances,Datatypes.ONE inst',tyvar)
                | _ => 
                    let
                      val tyvars = Types.all_tyvars(ty)
                      val tys = map (fn tyvar as ref(_,_,instances) => 
                                     instantiate_instance (instances,Datatypes.ONE inst',tyvar)) tyvars
                    in
                      Lists.reducel 
                      (fn (ty,tyvar) => 
                       subst_type([tyvar],ty))
                      (ty,Lists.zip(tyvars,tys))
                    end))
*)             
d243 1
a243 1
                 Datatypes.METATYVAR (tyvar,false,false)
d245 1
d248 1
d290 1
a290 3
          val Options.OPTIONS{print_options,
                              compiler_options = 
                              Options.COMPILEROPTIONS{debug_polyvariables,...},...} = options
d293 1
a293 1
            if not (MLWorks.Internal.Value.frame_allocations present_frame) then 
d577 1
a577 5
                      (* Continue if no information *)
                      FN (_,_,_,Option.ABSENT) => 
                        (debug ("Skip frame " ^ DebuggerUtilities.frame_name frame); 
                         instantiate_type (frames, ty))
                    | FN (_,_,_,Option.PRESENT (RuntimeEnv.FUNINFO (bound_tyvars,offset))) => 
d582 3
d587 1
a587 1
                          val offset = MLWorks.Internal.Value.frame_offset (frame,fetch_offset offset)
d592 1
a592 1
                              (fn (substs,tyvar as ref(_,_,instance)) => 
d599 1
d622 1
a622 1
                                             MLWorks.Integer.makestring (#1(MLWorks.Internal.Value.frame_offset
d629 1
a629 1
                                                                  MLWorks.RawIO.std_err,MLWorks.Internal.Value.frame_offset
d635 1
a635 1
                                     MLWorks.Internal.Value.frame_offset
d641 3
a643 2
                            (output(debug_out,
                                    "WARNING: Tyfun Instantiation failed in "^tyname^" in "^name^"\n");
d646 4
a649 2
                                   (output(debug_out,"WARNING: Valenv Instantiation failed in "^tyname^
                                           " in "^name^"\n");
d666 1
a666 1
                            val value = MLWorks.Internal.Value.frame_offset (present_frame,offset)
@


1.12
log
@Renaming debugger_env to runtime_env
@
text
@d4 3
d77 3
a79 2
    val do_debug = false
    val do_spill_debug = false
d82 1
a82 1
    val my_debug = false
d117 1
a117 1
            | print_offset (Option.PRESENT(ref(OFFSET2(offset)))) =
d119 1
a119 1
            | print_offset (Option.PRESENT(ref(OFFSET1(offset)))) =
d285 1
a285 1
      fun fetch_offset (Option.PRESENT (ref (OFFSET2 offset))) = offset
a318 4
          val present_value : MLWorks.Internal.Value.T ref = ref initial_value

          val present_value_string : string ref = ref ""

d325 1
a325 1
           | FN (name,env,ref(OFFSET1(1)),_) => 
d331 1
a331 1
            if do_debug then 
d440 3
a442 3
                          TYFUN (spill::spills) => (spill, TYFUN (spills))
                        | _ => raise TyfunInstantiation(name))
                      val _ = debug ("spill for " ^ name ^ ": " ^ MLWorks.Integer.makestring spill)
d450 1
a450 1
                           (output(debug_out,"\nWARNING: tyfun instantiation incomplete because of a previous compilation\n");m)
d454 1
a454 1
                             val tf' = ref(Types.fetch_tyfun_instantiation spill)
d457 2
a458 2
                                 (output(debug_out,"\ntf = "^Types.string_tyfun (!tf')^
                                         "\nspill = "^MLWorks.Integer.makestring spill))
d607 1
d641 1
a641 1
                                     (output(debug_out,"\n"^name^":spill:"^
d643 5
a647 2
                                                                            (present_frame,fetch_offset(Option.PRESENT(spill)))
                                                                            :int * type_function))^"\n value : ");
d650 4
a653 1
                                                                  (present_frame,fetch_offset(Option.PRESENT(spill)))))
d656 1
a656 1
                                     (present_frame,fetch_offset(Option.PRESENT(spill))))
d678 24
a701 1
                    val _ = 
d706 1
a706 24
                                 Types.print_type print_options ty ^ " = " ^ 
                                 (present_value_string := 
                                  (case offset of 
                                     Option.ABSENT => 
                                       (present_value := initial_value;
                                        if Types.isFunType(ty) then "fn"
                                        else "unavailable")
                                   | Option.PRESENT(ref(OFFSET2(offset))) => 
                                       (present_value := MLWorks.Internal.Value.frame_offset
                                        (present_frame,offset);
                                        if do_debug then 
                                          if Types.isFunType(ty) then ()
                                          else
                                            (output(debug_out,"\n offset : " ^ 
                                                    MLWorks.Integer.makestring offset ^ "\n value : ");
                                             MLWorks.Internal.Value.print(MLWorks.Internal.Value.DEFAULT,
                                                                          MLWorks.RawIO.std_err,!present_value))
                                        else ();
                                          if Types.isFunType(ty) then "fn"
                                          else
                                            print_value(ty,!present_value)
                                            handle _ => " _ [Uncaught Exception]")
                                   | _ => Crash.impossible "LET:print_env:debugger_print");
                                     !present_value_string))
d708 1
a708 2
                    accumulate_windowing_info(name,
                                              (ty,!present_value,!present_value_string))
@


1.11
log
@Fiddling
@
text
@d4 3
d47 2
a48 1
require "debugger_env";
d58 2
a73 2
    open RuntimeEnv

d78 3
a80 1
     
d83 1
a83 1
      val initial_value = MLWorks.Internal.Value.cast(0)
d94 15
a108 13
      datatype instance = 
        ZERO
      | ONE of int
      | TWO of int * int

      type substitution = ((int * Type * Instance) ref * Type) list

      fun print_tag (CONSTRUCTOR(tag)) = "CONSTRUCTOR "^tag
        | print_tag (INT(tag)) = "INT "^tag
        | print_tag (REAL(tag)) = "REAL "^tag
        | print_tag (STRING(tag)) = "STRING "^tag
        | print_tag DYNAMIC = "DYNAMIC"
        | print_tag DEFAULT = "DEFAULT"
d120 1
a120 1
             map (fn (RuntimeEnv.VARINFO (Option.PRESENT(name,(ref ty,_),offset)),env) => 
d184 1
a184 1
      fun S_type(S,ty) = 
d188 1
a188 1
            (Lists.assoc(tyv,S)
d195 1
a195 1
              (Lists.assoc(tyv,S)
d217 1
a217 1
              (Lists.assoc(tyv,S)
d225 12
a236 9
      fun instantiate_type (Datatypes.NO_INSTANCE,_,_) = 
        Crash.impossible "1:instantiate_type:debugger_print"
        | instantiate_type(Datatypes.SIGNATURE_INSTANCE(_),_,_) = 
          Crash.impossible "2:instantiate_type:debugger_print"
        | instantiate_type (_,ZERO,tyvar) = Datatypes.METATYVAR(tyvar,false,false)
        | instantiate_type(instance as Datatypes.INSTANCE(instances),ONE(inst),_) = 
          Datatypes.METATYVAR(Lists.nth(inst-1,rev instances),false,false)
        | instantiate_type(instance as Datatypes.INSTANCE(instances),TWO(inst,inst'),tyv) = 
          (case Lists.nth(inst-1,rev instances) of
d239 1
a239 1
                  Datatypes.NULLTYPE => instantiate_type (instances,ONE(inst'),tyvar)
d244 1
a244 1
                                     instantiate_type (instances,ONE(inst'),tyvar)) tyvars
d248 1
a248 1
                       S_type([tyvar],ty))
d251 33
a283 10
             
      fun fetch_offset(Option.ABSENT) = 
        Crash.impossible "ABSENT:fetch_offset:debugger_print"
        | fetch_offset(Option.PRESENT(ref(OFFSET1 _))) = 
          Crash.impossible "OFFSET1:fetch_offset:debugger_print"
        | fetch_offset(Option.PRESENT(ref(OFFSET2(offset)))) = 
          (if do_debug then 
             output(debug_out,"\n offset:"
                    ^MLWorks.Integer.makestring offset^"\n")
           else ();offset)
d285 1
a285 1
      fun print_env ((present_frame,env),print_value,fetch_value,options,windowing,frames) = 
d287 2
a288 2
          val result : string ref = ref("")
          fun output' str = result := (!result)^str
d291 2
a292 2
            val windowing_info : (string * (Type * MLWorks.Internal.Value.ml_value 
                                            * string)) list ref = ref([])
d309 2
a310 2
            if not (MLWorks.Internal.Value.frame_allocations(present_frame)) then 
              raise Finished("\nNo stack allocations \n")
d313 1
a313 1
          val apps = ref(0)
d315 1
a315 1
          val present_value : MLWorks.Internal.Value.T ref = ref(initial_value)
d319 1
d322 5
a326 5
             FN(name,env,ref(OFFSET2(offset)),bound_tyvars) => 
               ("\nfn "^name,
                env,fetch_value(present_frame,offset),bound_tyvars)
           | FN(name,env,ref(OFFSET1(1)),_) => 
               raise Finished("\n Nothing useful to print : No Code Transfer \n")
d332 5
a336 11
              (output(debug_out,"\n debug printing env ...\n");
               debug_print env)
            else
              ()

          val _ = 
            if do_debug then 
              output(debug_out,"\n first spill = "^
                     MLWorks.Integer.makestring first_spill^"\n")
            else
              ()
d340 1
a340 1
              0 => raise Finished("\n Nothing useful to print : No calls made \n")
d343 1
d439 4
a442 7
                        case tyfun of
                          TYFUN(spill::spills) => (spill, TYFUN(spills))
                        | _ => raise TyfunInstantiation(name)
                      val _ =
                        if do_spill_debug then 
                          output(debug_out,"\n spill for "^name^"\n")
                        else ()
d548 13
a560 1
                   | tyname_spills' (Datatypes.TYNAME(id,s,n,b,ve1 as ref(Datatypes.VE(n1,ve2)),s',abs,ve3 as ref(Datatypes.VE(n2,ve4)))) =
d562 11
a572 8
                            val _ =
                              if Datatypes.NewMap.is_empty ve4 andalso 
                                not(Lists.member(s,["bool","int","real","string","list","ref","exn","ml_value","array","vector","bytearray","Dynamic","Type"])) then
                                raise ValenvInstantiation(s)
                              else ()
                            val (ve',ve,n') = 
                              (*if Datatypes.NewMap.is_empty ve4 then 
                              else (ve1,ve2,n1)*) (ve3,ve4,n2)
d574 7
a580 21
                     ((Datatypes.TYNAME(id,s,n,b,Lists.assoc(ve',!ves),s',abs,ve3),tyfun)
                      handle Lists.Assoc =>
                        let
                          val ve'' = ref(Datatypes.VE(n',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
                          val (map, tyfun) =
                            (ves := (ve',ve'')::(!ves);
                             NewMap.fold (fn ((map,tyfun),valid,sch) =>
                                          let
                                            val (sch, tyfun) = typescheme_spills (tyfun,sch)
                                          in
                                            (NewMap.define(map,valid,sch), tyfun)
                                          end)
                             ((NewMap.empty (Ident.valid_lt, Ident.valid_eq), tyfun), ve))
                        in
                          (ve'' := Datatypes.VE(n',map);
                           (Datatypes.TYNAME(id,s,n,b,ve'',s',abs,ve'), tyfun))
                       end)
                          end
              in
                tyname_spills' tyname
              end
d582 1
a582 3
          val S : substitution ref = ref(nil)
          val tyvars : 
            ((int * Datatypes.Type * Datatypes.Instance) ref * int) list ref = ref([])
d585 5
a589 55
          fun instantiate_type' nil ty = S_type(!S,ty)
            | instantiate_type' ((frame,env)::frames) ty = 
              let 
                fun frame_name frame = 
                  let
                    open MLWorks.Internal.Value
                    val closure = frame_sub (frame, 9)
                    val primary = primary closure
                  in
                      code_name (sub (closure, if primary = Tags.PAIRPTR then 0 else 1))
                  end
                (*val _ = 
                  if do_debug then 
                    output(debug_out,"\n frames:\n")
                  else ()
                val _ = 
                     if do_debug then 
                       (map (fn (frame,_) => output(debug_out,frame_name frame^",")) 
                        ((frame,env)::frames);())
                     else ()*)
              fun output_tyvar tyv = 
                let 
                  fun length nil = 0
                    | length ((_,n)::_) = n+1
                  fun output_tyvar indent (tyvar as ref(n,t,Datatypes.INSTANCE(i))) = 
                   (output(debug_out,"\n "^indent^"tyvar"
                            ^MLWorks.Integer.makestring (Lists.assoc(tyvar,!tyvars)))
                    handle Lists.Assoc => 
                      let val length = length (!tyvars)
                      in
                        (output(debug_out,"\n "^indent^MLWorks.Integer.makestring (length)
                                ^":: n = "^MLWorks.Integer.makestring n^", t = "
                                ^Types.print_type print_options t^",i = ");
                        tyvars := (tyvar,length)::(!tyvars);
                        output(debug_out,"\n "^indent^"instances...");
                        map (output_tyvar (indent^" ")) i; 
                        output(debug_out,"\n "^indent^"...instances"))
                      end)
                    | output_tyvar indent (tyvar as ref(n,t,Datatypes.NO_INSTANCE)) = 
                     (output(debug_out,"\n "^indent^"tyvar"
                            ^MLWorks.Integer.makestring (Lists.assoc(tyvar,!tyvars)))
                      handle Lists.Assoc => 
                        let val length = length (!tyvars)
                        in
                          (output(debug_out,"\n "^indent^MLWorks.Integer.makestring (length)
                                  ^":: n = "^MLWorks.Integer.makestring n^", t = "
                                  ^Types.print_type print_options t^",i = ");
                          tyvars := (tyvar,length)::(!tyvars))
                        end)
                    | output_tyvar _ _ = Crash.impossible "output_tyvar:debugger"
                in
                  output_tyvar "" (tyv)
                end

                val ty = S_type(!S,ty)
d592 1
d594 1
a594 1
                  nil => ty
d597 5
a601 2
                      FN(_,_,_,Option.ABSENT) => instantiate_type' frames ty
                    | FN(_,_,_,Option.PRESENT(RuntimeEnv.FUNINFO (bound_tyvars,offset))) => 
d603 6
a608 26
                          val _ = 
                            if do_debug then 
                              (output(debug_out,"\nbound_tyvars:\n");
                               map output_tyvar bound_tyvars;
                               output(debug_out,"\ntyvars:\n");
                               map output_tyvar tyvars; ())
                            else ()
                          val bound_tyvars = 
                            Lists.filterp (fn tyv => 
                                           Lists.member(tyv,tyvars))
                            bound_tyvars
                          (* fetch runtime instance of function... *)
                          val offset = MLWorks.Internal.Value.frame_offset
                            (frame,fetch_offset(offset))
                          val _ = 
                            if do_debug then 
                              (MLWorks.Internal.Value.print(MLWorks.Internal.Value.DEFAULT,
                                                         MLWorks.RawIO.std_err,offset);
                               output(debug_out,":"^frame_name frame^"\n");
                               output(debug_out,":bound_tyvars:"))
                            else ()
                          val output_tyvar = 
                            if do_debug then 
                              fn tyvar => output_tyvar tyvar
                            else
                              fn _ => ()
d610 5
a614 8
                            S := 
                            Lists.reducel 
                            (fn (S,tyvar as 
                                 ref(_,_,instance)) => 
                             (output_tyvar tyvar;
                             (tyvar,instantiate_type
                              (instance,offset,tyvar)))::S)
                            (!S,bound_tyvars)
d616 2
a617 1
                          instantiate_type' frames ty
d619 1
a619 1
                    | _ => instantiate_type' frames ty
d625 1
a625 1
          fun print_env (LET(envs,env)) indent ns spill =
d627 1
a627 1
              LET(envs',env) => print_env (LET(envs@@envs',env)) indent ns spill
d630 1
a630 1
                 (fn (RuntimeEnv.VARINFO (Option.PRESENT(name,(ref ty,ref (RuntimeEnv.RUNTIMEINFO(_,spills))),offset)),env) => 
d633 1
a633 1
                      if Types.isFunType(ty) then ty
d654 3
a656 5
                            (if do_debug then
                               output(debug_out,"\nWARNING: Tyfun Instantiation failed in "^tyname^
                                      " in "^name^"\n")
                             else ();
                               ty)
d658 3
a660 5
                                   (if do_debug then
                                      output(debug_out,"\nWARNING: Valenv Instantiation failed in "^tyname
                                             ^" in "^name^"\n")
                                    else ();
                                      ty)
d662 2
a663 2
                    val (ty,ty') = 
                      case Types.all_tyvars(ty) of
d666 2
a667 1
                          (instantiate_type' frames ty,
d670 1
a670 1
                    val _ = print_env env (indent^" ") ns spill
d672 5
a676 5
                      output'("\n"^indent^"val "^name^" : "^
                              (case ty' of
                                 Option.PRESENT(ty)=> Types.print_type print_options ty^" : "
                               | Option.ABSENT => "")^
                                 Types.print_type print_options ty^" = "^
d689 2
a690 2
                                            (output(debug_out,"\n offset : "^
                                                    MLWorks.Integer.makestring offset^"\n value : ");
d704 1
a704 1
               | (_,env) => print_env env (indent^" ") ns spill)
d706 3
a708 2
                 print_env env (indent^" ") ns spill))
            | print_env (FN(name,_,_,_)) indent _ _ =
d724 1
a724 3
                   (output'("\n"^indent^
                            "****** CONTROL TRANSFER ******\n");
                    raise Finished(!result))
a742 2
                      output'("\n"^indent^
                                  "****** CONTROL TRANSFER ******\n");
d754 1
a754 1
                     print_env env (indent^" ") ns spill
a758 1
                    output'("\n"^indent^"****** CONTROL TRANSFER ******\n");
d762 1
a762 1
                 print_env env (indent^" ") ns spill)
d777 1
a777 1
                   print_env env (indent^" ") ns spill)
d781 1
a781 1
                val _ = output'("\n"^indent^"switching on "^print_tag tag)
d787 1
a787 1
                   print_env which_env (indent^" ") ns spill)
d804 1
a804 1
                                  | OFFSET1(_)=>spill
d807 2
a808 2
                     output(debug_out,"\n handle spill = "^
                            MLWorks.Integer.makestring spill'^"\n")
d811 1
a811 1
                 val _ = print_env env1 (indent^" ") ns spill'
d826 2
a827 2
           (fnstr^((print_env env (" ") nil first_spill; !result^"\n")
                   handle Finished(str) => str^"\n"),
@


1.10
log
@Abstraction of debug information
@
text
@d4 3
d69 5
d76 1
a76 1
      exception finished of string
d78 172
a249 2
      val do_debug : bool ref = ref(false)
      val do_spill_debug : bool ref = ref(false)
d255 1
d269 1
a272 76
          fun print_tag (CONSTRUCTOR(tag)) = "CONSTRUCTOR "^tag
            | print_tag (INT(tag)) = "INT "^tag
            | print_tag (REAL(tag)) = "REAL "^tag
            | print_tag (STRING(tag)) = "STRING "^tag
            | print_tag DYNAMIC = "DYNAMIC"
            | print_tag DEFAULT = "DEFAULT"
          fun debug_print env = 
            let
              fun print_offset Option.ABSENT = ""
                | print_offset (Option.PRESENT(ref(OFFSET2(offset)))) =
                  ":OFFSET2" ^ MLWorks.Integer.makestring offset ^ "\n" ^ " = "
                | print_offset (Option.PRESENT(ref(OFFSET1(offset)))) =
                  ":OFFSET1" ^ MLWorks.Integer.makestring offset ^ "\n" ^ " = "
              fun debug_print (LET(envs,env)) indent = 
                (output(std_out,"\n"^indent^"LET ");
                 map (fn (RuntimeEnv.VARINFO (Option.PRESENT(name,(ref ty,_),offset)),env) => 
                      (output(std_out,"\n" ^ indent ^ "  val " ^ name ^ ":" ^
                              Types.extra_debug_print_type ty ^ print_offset offset);
                       debug_print env (indent^" "))
                        | (_,env) => debug_print env (indent^" ")) envs;
                 output(std_out,"\n"^indent^"IN ");
                 debug_print env (indent^" ");
                 output(std_out,"\n"^indent^"END "))
                | debug_print (FN(name,env,offset,_)) indent = 
                  (output(std_out,"\n"^indent^"FN "^name^" "
                          ^print_offset (Option.PRESENT(offset)));
                   debug_print env (indent^" "))
                | debug_print (APP(env1,env2,opt)) indent = 
                  (output(std_out,"\n"^indent^"APP ");
                   (case opt of 
                      Option.ABSENT => ""
                    | Option.PRESENT(n) => ":"^MLWorks.Integer.makestring n);
                   output(std_out,"\n"^indent^"(");
                   debug_print env1 (indent^" ");
                   output(std_out,"\n"^indent^")");
                   output(std_out,"\n"^indent^"(");
                   debug_print env2 (indent^" ");
                   output(std_out,"\n"^indent^")"))
                | debug_print (RAISE(env)) indent = 
                  (output(std_out,"\n"^indent^"RAISE ");
                   debug_print env (indent^" "))
                | debug_print (SELECT(n,env)) indent = 
                  (output(std_out,"\n"^indent^"SELECT:"^MLWorks.Integer.makestring n);
                   debug_print env (indent^" "))
                | debug_print (STRUCT(envs)) indent = 
                  (output(std_out,"\n"^indent^"STRUCT ");
                   map (fn env => debug_print env (indent^" ")) envs;
                   ())
                | debug_print (LIST(envs)) indent = 
                  (output(std_out,"\n"^indent^"LIST ");
                   map (fn env => debug_print env (indent^" ")) envs;
                   ())
                | debug_print (SWITCH(env,offset,apps,envs)) indent =
                  (output(std_out,"\n"^indent^"SWITCH "
                          ^print_offset (Option.PRESENT(offset))^":"^
                          MLWorks.Integer.makestring apps);
                   debug_print env (indent^" ");
                   output(std_out,"\n"^indent^"IN ");
                   map (fn (tag,env) => 
                        (output(std_out,"\n"^indent^"TAG:"^print_tag tag^" ");
                         debug_print env (indent^" "))) envs;
                   output(std_out,"\n"^indent^"END "))
                | debug_print (HANDLE(env1,offset,apps,apps',env2)) indent = 
                  (output(std_out,"\n"^indent^"HANDLE "
                          ^print_offset (Option.PRESENT(offset))^":"^
                          MLWorks.Integer.makestring apps^":"^
                          MLWorks.Integer.makestring apps');
                   debug_print env1 (indent^" ");
                   output(std_out,"\n"^indent^"IN ");
                   debug_print env2 (indent^" ");
                   output(std_out,"\n"^indent^"END "))
                | debug_print (EMPTY) indent = output(std_out,"\n"^indent^"EMPTY")
                | debug_print (BUILTIN) indent = output(std_out,"\n"^indent^"BUILTIN")
            in
              debug_print env ""
            end
d276 1
a276 1
              raise finished("\nNo stack allocations \n")
d278 1
d280 3
a282 2
          val present_value : MLWorks.Internal.Value.T ref = 
            ref(initial_value)
d284 1
d291 2
a292 2
               raise finished("\n Nothing useful to print : No Code Transfer \n")
           | EMPTY => raise finished("")
d294 1
d296 2
a297 2
            if !do_debug then 
              (output(std_out,"\n debug printing env ...\n");
d301 1
d303 2
a304 2
            if !do_debug then 
              output(std_out,"\n first spill = "^
d308 1
d311 1
a311 1
              0 => raise finished("\n Nothing useful to print : No calls made \n")
d317 1
d321 20
a340 5
            val tfs : tyfun_substitution ref = ref []
            val ves : (Datatypes.Valenv ref * Datatypes.Valenv ref) list ref = ref []
            val dummy_false = ref(false)
            val dummy_ve = ref(Datatypes.empty_valenv)
            fun type_spills (tyfun,Datatypes.CONSTYPE(tys,tyn)) =
d342 10
a351 4
                val (tyn, tyfun) = tyname_spills (tyfun,tyn)
                val (tys, tyfun) =
                  Lists.reducel
                  (fn ((tys,tyfun),ty)=>
d353 1
a353 1
                     val (ty, tyfun) = type_spills(tyfun,ty)
d355 2
a356 2
                     (ty::tys, tyfun)
                   end) ((nil, tyfun), tys)
d358 1
a358 1
                (Datatypes.CONSTYPE(tys, tyn), tyfun)
d360 1
a360 47
              | type_spills (tyfun,Datatypes.FUNTYPE(ty1,ty2)) =
                let
                  val (ty1, tyfun) = type_spills (tyfun,ty1)
                  val (ty2, tyfun) = type_spills (tyfun,ty2)
                in
                  (Datatypes.FUNTYPE(ty1,ty2), tyfun)
                end
              | type_spills (tyfun,Datatypes.RECTYPE(map)) =
                let
                  val (map, tyfun) =
                    Datatypes.Mapping.Fold
                    (fn lab=>fn ty=>fn (map,tyfun) =>
                     let
                       val (ty, tyfun) = type_spills (tyfun,ty)
                     in
                       (Datatypes.Mapping.add((lab,ty),map,Ident.lab_order),tyfun)
                     end) (Datatypes.Mapping.empty_map, tyfun) map
                in
                  (Datatypes.RECTYPE(map), tyfun)
                end
              | type_spills (tyfun,Datatypes.METATYVAR(ref(n,ty,i),b1,b2)) =
                let
                  val (ty, tyfun) = type_spills (tyfun,ty)
                in
                  (Datatypes.METATYVAR(ref(n,ty,i),b1,b2), tyfun)
                end
              | type_spills
		  (tyfun,Datatypes.META_OVERLOADED(ref(ty),tv,valid,loc)) =
                let
                  val (ty, tyfun) = type_spills(tyfun,ty)
                in
                  (Datatypes.META_OVERLOADED(ref(ty),tv,valid,loc), tyfun)
                end
              | type_spills (tyfun,Datatypes.TYVAR(ref(n,ty,i),id)) =
                let
                  val (ty, tyfun) = type_spills(tyfun,ty)
                in
                  (Datatypes.TYVAR(ref(n,ty,i),id), tyfun)
                end
              | type_spills (tyfun,Datatypes.METARECTYPE(ref(n,b1,ty,b2,b3))) =
                let
                  val (ty, tyfun) = type_spills(tyfun,ty)
                in
                  (Datatypes.METARECTYPE(ref(n,b1,ty,b2,b3)), tyfun)
                end
              | type_spills (tyfun,ty) = (ty, tyfun)
            and typescheme_spills (tyfun,Datatypes.SCHEME(n,(ty,i))) =
d364 20
a383 1
                (Datatypes.SCHEME(n,(ty,i)), tyfun)
d385 8
a392 8
              | typescheme_spills (tyfun,Datatypes.UNBOUND_SCHEME(ty,i)) =
                let
                  val (ty, tyfun) = type_spills (tyfun,ty)
                in
                  (Datatypes.UNBOUND_SCHEME(ty,i), tyfun)
                end
              | typescheme_spills (tyfun,sch) = (sch, tyfun)
            and tyname_spills (tyfun,tyname) =
d394 62
a455 55
                fun tyname_spills' 
                  (m as Datatypes.METATYNAME(tf as ref(Datatypes.NULL_TYFUN(_)),name,n,b,
                                             ve' as ref(Datatypes.VE(n',ve)),abs)) =
                  if NewMap.is_empty ve then
                    (Datatypes.METATYNAME(Lists.assoc(tf,!tfs),name,n,b,ve',abs),tyfun)
                    handle Lists.Assoc =>
                       let
                         val ((spill,tyfun),tyfun') =
                           case tyfun of
                             TYFUN(spill::spills) => (spill, TYFUN(spills))
                           | _ => raise TyfunInstantiation(name)
                         val _ =
                           if !do_spill_debug then 
                              output(std_out,"\n spill for "^name^"\n")
                           else ()
                       in
                        (case spill of
                           ~1 => Crash.impossible "~1:tyname_spills':debugger_print"
                         | ~2 => Crash.impossible "~2:tyname_spills':debugger_print"
                         | ~3 => Crash.impossible "~3:tyname_spills':debugger_print"
                         | ~4 => Crash.impossible "~4:tyname_spills':debugger_print"
                         | ~5 =>
                             (output(std_out,"\nWARNING: tyfun instantiation incomplete because of a previous compilation\n");m)
                         | ~6 => Crash.impossible "~6:tyname_spills':debugger_print"
                         | _ =>
                             let
                               val tf' = ref(Types.fetch_tyfun_instantiation spill)
                               val _ =
                                 if !do_spill_debug then
                                   (output(std_out,"\ntf = "^Types.string_tyfun (!tf')^
                                                   "\nspill = "^MLWorks.Integer.makestring spill))
                                 else ()
                               val old_tfs = !tfs
                               val old_ves = !ves
                               val _ = (tfs := nil;
                                        ves := nil)
                               val tf'' = case tyname_spills
				 (tyfun,Datatypes.METATYNAME(tf',"",0,dummy_false,
							     dummy_ve,dummy_false)) of
				 (Datatypes.METATYNAME(ref(tf''),_,_,_,_,_),_) => tf''
			       | _ => Crash.impossible"tyname_spills':debugger_print"
                               val _ =
                                 if !do_debug then
                                   output(std_out,"\n instantiation completed for spill "
                                          ^MLWorks.Integer.makestring spill^"\n")
                                 else ()
                             in
                               (tfs := (tf,tf')::old_tfs;
                                ves := old_ves;
                                tf' := tf'';
                                Datatypes.METATYNAME(tf',name,n,b,ve',abs))
                             end,
                           tyfun')
                       end
                   else
d524 2
a525 1
                              if Datatypes.NewMap.is_empty ve4 andalso not(Lists.member(s,["bool","int","real","string","list","ref","exn","ml_value","array","vector","bytearray","Dynamic","Type"])) then
a553 14
          (* instances are passed around as an extra argument at runtime :
           ZERO : no instance(useful in self-calls and mutual-recursion)
           ONE(i) : the ith instances of type variables of the function
           TWO(i,i') : the i'th instance of the ith instance
                       (for types with some polymorphic signature constraint)

           This object is constructed by the Lambda Translator.
           *)
          datatype instance = 
              ZERO
            | ONE of int
            | TWO of int * int
          type substitution = ((int * Type * Instance) ref * Type) list

a557 76
          (* substitute type variables for correponding types in a type
             (unsafe to do this imperatively) *)
          fun S_type(S,ty) = 
            let
              fun substitute_type(ty as Datatypes.TYVAR(tyv as 
                                                         ref(_,Datatypes.NULLTYPE,_),_)) =
                (Lists.assoc(tyv,S)
                 handle Lists.Assoc => ty)
                | substitute_type(Datatypes.TYVAR(ref (_,ty,_),_)) = 
                  substitute_type(ty)
                | substitute_type(ty as Datatypes.METATYVAR(tyv as 
                                                             ref(_,Datatypes.NULLTYPE,_),
                                                             _,_)) = 
                  (Lists.assoc(tyv,S)
                   handle Lists.Assoc => ty)
                | substitute_type(Datatypes.METATYVAR (ref (_,ty,_),_,_)) = 
                  substitute_type(ty)
                | substitute_type(ty as Datatypes.META_OVERLOADED 
                                  {1=ref Datatypes.NULLTYPE,...}) = ty
                | substitute_type(Datatypes.META_OVERLOADED {1=ref ty,...}) =
                  substitute_type(ty)
                | substitute_type(Datatypes.METARECTYPE 
                                  (ref (_,true,
                                        ty as Datatypes.METARECTYPE _,_,_))) = 
                  substitute_type(ty)
                | substitute_type(Datatypes.METARECTYPE (ref (_,_,ty,_,_))) = 
                  substitute_type(ty)
                | substitute_type((Datatypes.RECTYPE amap)) =
                  Datatypes.RECTYPE (Datatypes.Mapping.mapit
                                     (amap,substitute_type))
                | substitute_type(Datatypes.FUNTYPE(arg,res)) =
                  Datatypes.FUNTYPE(substitute_type(arg),substitute_type(res))
                | substitute_type(Datatypes.CONSTYPE (tylist,tyname)) =
                  Datatypes.CONSTYPE(map substitute_type tylist,tyname)
                | substitute_type(ty as Datatypes.DEBRUIJN(_,_,_,Option.PRESENT(tyv))) =
                  (Lists.assoc(tyv,S)
                   handle Lists.Assoc => ty)
                | substitute_type ty = ty
            in
              substitute_type(ty)
            end

          (* instantiate a type using instance passed to function at runtime *)
          fun instantiate_type (Datatypes.NO_INSTANCE,_,_) = 
                  Crash.impossible "1:instantiate_type:debugger_print"
            | instantiate_type(Datatypes.SIGNATURE_INSTANCE(_),_,_) = 
                  Crash.impossible "2:instantiate_type:debugger_print"
            | instantiate_type (_,ZERO,tyvar) = Datatypes.METATYVAR(tyvar,false,false)
            | instantiate_type(instance as Datatypes.INSTANCE(instances),ONE(inst),_) = 
              Datatypes.METATYVAR(Lists.nth(inst-1,rev instances),false,false)
            | instantiate_type(instance as Datatypes.INSTANCE(instances),TWO(inst,inst'),tyv) = 
             (case Lists.nth(inst-1,rev instances) of
                tyvar as ref(_,ty,instances) =>
                  (case ty of
                     Datatypes.NULLTYPE => instantiate_type (instances,ONE(inst'),tyvar)
                   | _ => 
                       let
                         val tyvars = Types.all_tyvars(ty)
                         val tys = map (fn tyvar as ref(_,_,instances) => 
                                        instantiate_type (instances,ONE(inst'),tyvar)) tyvars
                       in
                         Lists.reducel 
                         (fn (ty,tyvar) => 
                          S_type([tyvar],ty))
                         (ty,Lists.zip(tyvars,tys))
                       end))

          fun fetch_offset(Option.ABSENT) = 
            Crash.impossible "ABSENT:fetch_offset:debugger_print"
            | fetch_offset(Option.PRESENT(ref(OFFSET1 _))) = 
              Crash.impossible "OFFSET1:fetch_offset:debugger_print"
            | fetch_offset(Option.PRESENT(ref(OFFSET2(offset)))) = 
              (if !do_debug then 
                 output(std_out,"\n offset:"
                        ^MLWorks.Integer.makestring offset^"\n")
               else ();offset)
d571 2
a572 2
                  if !do_debug then 
                    output(std_out,"\n frames:\n")
d575 2
a576 2
                     if !do_debug then 
                       (map (fn (frame,_) => output(std_out,frame_name frame^",")) 
d584 1
a584 1
                   (output(std_out,"\n "^indent^"tyvar"
d589 1
a589 1
                        (output(std_out,"\n "^indent^MLWorks.Integer.makestring (length)
d593 1
a593 1
                        output(std_out,"\n "^indent^"instances...");
d595 1
a595 1
                        output(std_out,"\n "^indent^"...instances"))
d598 1
a598 1
                     (output(std_out,"\n "^indent^"tyvar"
d603 1
a603 1
                          (output(std_out,"\n "^indent^MLWorks.Integer.makestring (length)
d624 2
a625 2
                            if !do_debug then 
                              (output(std_out,"\nbound_tyvars:\n");
d627 1
a627 1
                               output(std_out,"\ntyvars:\n");
d638 1
a638 1
                            if !do_debug then 
d640 3
a642 3
                                                         MLWorks.RawIO.std_out,offset);
                               output(std_out,":"^frame_name frame^"\n");
                               output(std_out,":bound_tyvars:"))
d645 1
a645 1
                            if !do_debug then 
d673 77
a749 76
                      (let
                        val ty =
                          if Types.isFunType(ty) then ty
                          else
                            let
                              val tyfun = TYFUN(
                              map (fn (tf as ref(Datatypes.NULL_TYFUN(_)),spill) =>
                               (if !do_spill_debug then
                                  (output(std_out,"\n"^name^":spill:"^
                                         MLWorks.Integer.makestring (#1(MLWorks.Internal.Value.frame_offset
                                             (present_frame,fetch_offset(Option.PRESENT(spill)))
                                             :int * type_function))^"\n value : ");
                                    MLWorks.Internal.Value.print(MLWorks.Internal.Value.DEFAULT,
                                                MLWorks.RawIO.std_out,MLWorks.Internal.Value.frame_offset
                                                     (present_frame,fetch_offset(Option.PRESENT(spill)))))
                                else ();
                                MLWorks.Internal.Value.frame_offset
                                                     (present_frame,fetch_offset(Option.PRESENT(spill))))
                               | _ => Crash.impossible "spills:print_env:debugger_print") spills)
                            in
                            #1(type_spills(tyfun,ty))
                              handle TyfunInstantiation(tyname) =>
                                (if !do_debug then
                                   output(std_out,"\nWARNING: Tyfun Instantiation failed in "^tyname^
                                          " in "^name^"\n")
                                 else ();
                                 ty)
                            | ValenvInstantiation(tyname) =>
                                (if !do_debug then
                                   output(std_out,"\nWARNING: Valenv Instantiation failed in "^tyname
                                          ^" in "^name^"\n")
                                 else ();
                                 ty)
                            end
                        val (ty,ty') = 
                          case Types.all_tyvars(ty) of
                            nil => (ty,Option.ABSENT)
                          | tyvars => 
                              (instantiate_type' frames ty,
                               Option.PRESENT(ty))
                        (* print_env must be invoked before print_value here! *)
                        val _ = print_env env (indent^" ") ns spill
                        val _ = output'(
                          "\n"^indent^"val "^name^" : "^
                          (case ty' of
                             Option.PRESENT(ty)=> Types.print_type print_options ty^" : "
                           | Option.ABSENT => "")^
                             Types.print_type print_options ty^" = "^
                           (present_value_string := 
                            (case offset of 
                               Option.ABSENT => 
                                 (present_value := initial_value;
                                  if Types.isFunType(ty) then "fn"
                                  else "unavailable")
                             | Option.PRESENT(ref(OFFSET2(offset))) => 
                                 (present_value := MLWorks.Internal.Value.frame_offset
                                  (present_frame,offset);
                                  if !do_debug then 
                                  if Types.isFunType(ty) then ()
                                  else
                                   (output(std_out,"\n offset : "^
                                           MLWorks.Integer.makestring offset^"\n value : ");
                                    MLWorks.Internal.Value.print(MLWorks.Internal.Value.DEFAULT,
                                                         MLWorks.RawIO.std_out,!present_value))
                                  else ();
                                  if Types.isFunType(ty) then "fn"
                                  else
                                    print_value(ty,!present_value)
                                    handle _ => " _ [Uncaught Exception]")
                             | _ => Crash.impossible "LET:print_env:debugger_print");
                               !present_value_string))
                      in
                        accumulate_windowing_info(name,
                                                   (ty,!present_value,!present_value_string))
                      end)
                   | (_,env) => print_env env (indent^" ") ns spill)
d770 1
a770 1
                    raise finished(!result))
d785 2
a786 2
                     handle finished _ => 
                       Crash.impossible "finished:APP:print_env:debugger_print"
d791 1
a791 1
                      raise finished(!result))
d803 2
a804 2
                     handle finished _ => 
                       Crash.impossible "finished:RAISE:print_env:debugger_print"
d808 1
a808 1
                    raise finished(!result))
d855 2
a856 2
                   if !do_debug then 
                     output(std_out,"\n handle spill = "^
d861 1
a861 1
                         handle finished _ => ()
d866 1
a866 1
                   raise finished(!result)
d876 1
a876 1
                   handle finished(str) => str^"\n"),
d879 1
a879 1
      handle finished(str) => (str,[])
a884 1

@


1.9
log
@New runtime directory structure.
@
text
@d4 3
d44 1
a44 1
functor RuntimeEnv(
d50 3
a52 3
    structure RuntimeEnv_type : DEBUGGER_ENVIRONMENT_TYPE
    sharing RuntimeEnv_type.Option = Types.Datatypes.Option
       sharing type RuntimeEnv_type.Type = Types.Datatypes.Type
d55 3
a57 3
       sharing type Types.Datatypes.Instance = RuntimeEnv_type.Instance
       sharing type Types.Datatypes.Tyfun = RuntimeEnv_type.Tyfun
) : DEBUGGER_ENVIRONMENT =
d61 1
a61 1
    structure RuntimeEnv_type = RuntimeEnv_type
d65 1
a65 1
    open RuntimeEnv_type
d102 4
a105 4
                | print_offset (Option.PRESENT(ref(Option.SOME2(offset)))) =
                  ":SOME2"^MLWorks.Integer.makestring offset^"\n"^" = "
                | print_offset (Option.PRESENT(ref(Option.SOME1(offset)))) =
                  ":SOME1"^MLWorks.Integer.makestring offset^"\n"^" = "
d108 3
a110 4
                 map (fn (Option.PRESENT(name,ref (ty,_,_),offset),
                          env) => 
                      (output(std_out,"\n"^indent^"  val "^name^":"^
                              Types.extra_debug_print_type ty^print_offset offset);
d180 1
a180 1
             FN(name,env,ref(Option.SOME2(offset)),bound_tyvars) => 
d183 1
a183 1
           | FN(name,env,ref(Option.SOME1(1)),_) => 
d528 3
a530 3
            | fetch_offset(Option.PRESENT(ref(Option.SOME1(_)))) = 
              Crash.impossible "SOME1:fetch_offset:debugger_print"
            | fetch_offset(Option.PRESENT(ref(Option.SOME2(offset)))) = 
d598 1
a598 1
                    | FN(_,_,_,Option.PRESENT(bound_tyvars,offset)) => 
d649 1
a649 2
                 (fn (Option.PRESENT(name,ref (ty,_,spills),offset),
                      env) => 
a653 2
                            (*if name = "FUNCTION RETURN" then ty
                            else*)
d704 1
a704 1
                             | Option.PRESENT(ref(Option.SOME2(offset))) => 
d797 1
a797 1
            | print_env (SWITCH(env,ref(Option.SOME2(offset)),apps',envs)) indent ns spill = 
d828 2
a829 2
                                    Option.SOME2(offset)=>fetch_value (present_frame,offset)
                                  | Option.SOME1(_)=>spill
@


1.8
log
@Simplifications in debugger environment printing;
altered HANDLE environment printing.
@
text
@d4 4
d37 1
a37 1
require "../rts/tags";
@


1.7
log
@Datatypes.META_OVERLOADED takes extra arguments.
@
text
@d4 3
d64 1
d68 2
d166 1
a166 1
              raise finished "\nNo stack allocations \n"
d178 2
a179 2
               raise finished "\n Nothing useful to print : No Code Transfer \n"
           | EMPTY => raise finished ""
d189 1
a189 1
              output(std_out,"\n first_spill = "^
d195 1
a195 1
              0 => raise finished "\n Nothing useful to print : No calls made \n"
a197 4
          val print_str : bool ref = ref false
          infix ^^
          fun str1^^str2 = if !print_str then str1^str2 else str1
          
a289 4
                         val _ =
                           if !do_debug then 
                              output(std_out,"\n spill for "^name^"\n")
                           else ()
d294 4
d311 1
a311 1
                                 if !do_debug then
d638 1
a638 1
          fun print_env (LET(envs,env)) indent ns str spill =
d640 1
a640 1
              LET(envs',env) => print_env (LET(envs@@envs',env)) indent ns str spill
d642 3
a644 6
              let
                val letstr = "\n"^indent^"let "
                val expstr = 
                 Lists.reducel 
                 (fn (str',(Option.PRESENT(name,ref (ty,_,spills),offset),
                           env)) => 
d649 2
d654 1
a654 1
                               (if !do_debug then
d687 4
a690 1
                        val str'' = str'^"\n"^indent^"  val "^name^" : "^
d694 1
a694 6
                             Types.print_type print_options ty^" = "
                        (* print_env' must be invoked before print_value here! *)
                        val envstr = print_env' env (indent^"    ") ns 
                          (fn()=>str()^letstr^str'') spill
                        val envstr = 
                          (str'' ^ 
d717 1
a717 2
                               !present_value_string))^^
                          (" = "^envstr)
d719 2
a720 4
                        (print_str := true;
                         accumulate_windowing_info(name,
                                                   (ty,!present_value,!present_value_string));
                         envstr)
d722 8
a729 34
                   | (str',(_,env)) => 
                       let
                         val old_print_str = !print_str
                         val envstr =                              
                           str'^^("\n"^indent^"  val ? = "^print_env' env (indent^"   ") ns 
                                   (fn()=>
                                    let
                                      val new_print_str = !print_str
                                      val _ = print_str := old_print_str
                                      val str = str()^^(letstr^str'^"\n"^indent^"  val ? = ")
                                    in
                                      (print_str := new_print_str;
                                       str)
                                    end) spill)
                       in
                         (print_str := (old_print_str orelse (!print_str));
                          envstr)
                       end) ("",envs)
                val str' = "" ^^ (letstr ^ expstr ^ ("\n"^indent^"in"))
                val old_print_str = !print_str
                val envstr = 
                (str'^^print_env' (env) (indent^" ") ns (fn()=>str()^str') spill)
                val new_print_str = !print_str
                val envstr = 
                  envstr ^ (print_str := old_print_str;
                            ""^^("\n"^indent^"end(let)"))
              in
                (print_str := (old_print_str orelse new_print_str);
                 ""^^envstr)
              end)
            | print_env (FN(name,_,_,_)) indent _ _ _ = "\n"^indent^"fn "^name^" "
            | print_env (APP(BUILTIN,env,Option.ABSENT)) indent ns str spill = 
              print_env env indent ns str spill
            | print_env (APP(env1,env2,Option.PRESENT(apps'))) indent ns str spill = 
d733 1
a733 5
                val env1str = 
                  "" ^^ (("\n"^indent^"(")^
                  print_env' env1 indent ns (fn()=>str()^"\n"^indent^"(") spill ^ 
                  "\n"^indent^")")
                val old_print_str = !print_str
d736 1
a736 3
                val env2str = 
                    env1str ^^ ("\n"^indent^"(" ^
                    print_env' env2 indent ns (fn()=>str()^env1str) spill ^ "\n"^indent^")")
d739 7
a745 8
                (print_str := (old_print_str orelse (!print_str));
                 ""^^
                 (apps := !apps + 1;
                  if !apps = spill then 
                    raise finished(str()^env2str^"\n"^indent^
                                   "****** CONTROL TRANSFER ******\n")
                  else
                    env2str))
d747 1
a747 1
            | print_env (APP(env1,env2,Option.ABSENT)) indent ns str spill = 
d750 2
a751 13
                  let 
                    val env1str = 
                      ""^^("\n"^indent^"("^
                      print_env' env1 indent ns (fn()=>str()^"\n"^indent^"(") spill ^ 
                      "\n"^indent^")") 
                    val old_print_str = !print_str
                    val env2str = 
                      env1str ^^ ("\n"^indent^"(" ^
                       print_env' env2 indent ns (fn()=>str()^env1str) spill ^ "\n"^indent^")")
                  in
                    (print_str := (old_print_str orelse (!print_str));
                     ""^^env2str)
                  end
d757 1
a757 1
                     val envsstr = print_envs()
d762 3
a764 2
                      raise finished(str()^envsstr^"\n"^indent^
                                  "****** CONTROL TRANSFER ******\n"))
d769 1
a769 4
            | print_env (RAISE(env)) indent ns str spill = 
              let
                val raisestr = "\n"^indent^"raise"
              in
d771 1
a771 1
               (* increment before print_env' - in step with mir_cg *)
d774 2
a775 3
                   val raisestr = fn()=>str()^raisestr
                   val envstr = 
                     print_env' env (indent^" ") ns raisestr spill
d780 2
a781 2
                    raise finished((raisestr()^^envstr)^
                                 "\n"^indent^"****** CONTROL TRANSFER ******\n"))
d784 4
a787 6
                 ""^^(raisestr ^ 
                      print_env'(env) (indent^" ") ns (fn()=>str()^raisestr) spill))
              end
            | print_env (SELECT(n,env)) indent ns str spill = 
              print_env env indent (n::ns) str spill
            | print_env (STRUCT(envs)) indent ns str spill = 
d789 1
a789 9
                 nil => Lists.reducel 
                   (fn (str',env) => str'^
                    let
                      val old_print_str = !print_str
                      val envstr = print_env' env indent ns (fn()=>str()^str') spill
                    in
                      (print_str := (old_print_str orelse (!print_str));
                       envstr)
                    end) ("",envs)
d791 4
a794 12
                   print_env' (Lists.nth(n,envs)) indent ns str spill)
            | print_env (LIST(envs)) indent ns str spill = 
              Lists.reducel 
                   (fn (str',env) => str'^
                    let
                      val old_print_str = !print_str
                      val envstr = print_env' env indent ns (fn()=>str()^str') spill
                    in
                      (print_str := (old_print_str orelse (!print_str));
                       envstr)
                    end) ("",envs)
            | print_env (SWITCH(env,ref(Option.SOME2(offset)),apps',envs)) indent ns str spill = 
d797 1
a797 2
                val switchstr = "\n"^indent^"switch "
                val envstr = 
d799 1
a799 2
                   switchstr^^print_env' env (indent^" ") ns (fn()=>str()^switchstr) spill)
                val old_print_str = !print_str
d803 1
a803 2
                val envstr = envstr^"\n"^indent^"in("^"switching on "
                                 ^print_tag tag^")"
d809 1
a809 3
                   envstr^print_env' which_env
                              (indent^" ") ns (fn()=>str()^envstr) spill
                              ^"\n"^indent^"end(switch)")
d814 1
a814 3
                (apps := new_apps;
                 print_str := (old_print_str orelse (!print_str));
                 ""^^envsstr)
d817 1
a817 1
                                apps',apps'',env2)) indent ns str spill =
d824 1
a824 3
                 val handlestr = "\n"^indent^"handle"
                 val env1str = print_env' env1 (indent^" ") ns (fn()=>str()) 
                                 (case offset of
d826 9
a834 2
                                  | Option.SOME1(offset)=>spill)
                                 handle finished(str) => (print_str :=true;str)
d836 6
a841 17
                 if !apps = spill then
                   (tfs := old_tfs;
                    ves := old_ves;
                    raise finished(""^^env1str))
                 else
                     let
                       val env1str = handlestr^env1str^"\n"^indent^"in(\n"
                       val env2str = 
                         (apps := old_apps;
                          print_env' env2 (indent^" ") ns (fn()=>str()^env1str) spill)
                         handle exn => (tfs := old_tfs; ves := old_ves; raise exn)
                       val _ = tfs := old_tfs
                       val _ = ves := old_ves
                     in
                        (apps := apps'';
                         ""^^(env1str^env2str^"\n"^indent^"end(handle)"))
                      end
d843 3
a845 7
            | print_env (EMPTY) _ _ _ _ = ""
            | print_env (BUILTIN) _ _ _ _ = ""
            | print_env _ _ _ _ _ = Crash.impossible "print_env:print_env:debugger_print"

          and print_env' env indent ns str spill = 
            (print_str := false;
             print_env env indent ns str spill)
d848 2
a849 2
           (fnstr^(print_env env (" ") nil (fn()=>"") first_spill
                  handle finished(envstr) => envstr),
@


1.6
log
@Fix inexhaustive bindings
@
text
@d4 3
d246 2
a247 1
              | type_spills (tyfun,Datatypes.META_OVERLOADED(ref(ty),v)) =
d251 1
a251 1
                  (Datatypes.META_OVERLOADED(ref(ty),v), tyfun)
d469 2
a470 2
                                  (ref Datatypes.NULLTYPE,_)) = ty
                | substitute_type(Datatypes.META_OVERLOADED (ref ty,_)) =
@


1.5
log
@Modules Debugger : Dynamic Type Name Instantiation.
@
text
@d4 3
d313 5
a317 3
                               val (Datatypes.METATYNAME(ref(tf''),_,_,_,_,_),_) =
                                 tyname_spills(tyfun,Datatypes.METATYNAME(tf',"",0,dummy_false,
                                                                          dummy_ve,dummy_false))
@


1.4
log
@Polymorphic debugger.
@
text
@d4 3
d39 2
a40 1
       sharing type Types.Datatypes.instance = RuntimeEnv_type.Instance
d46 2
d66 1
a66 1
                 fn () => !windowing_info)
d69 1
a69 1
                 fn () => nil)
d84 3
a86 2
                  ":"^MLWorks.Integer.makestring offset^"\n"^" = "
                | print_offset _ = Crash.impossible "print_offset:debug_print:debugger_print"
d89 1
a89 1
                 map (fn (Option.PRESENT(name,ref (ty,_),offset),
d92 1
a92 1
                              Types.print_type print_options ty^print_offset offset);
d137 1
a137 1
                | debug_print (HANDLE(env1,offset,apps,env2)) indent = 
d140 2
a141 1
                          MLWorks.Integer.makestring apps);
a147 1
                | debug_print _ _ = Crash.impossible "debug_print:debugger_print"
d154 1
a154 1
              raise finished "\n No stack allocations \n"
d190 234
d440 2
a441 2
            ((int * Datatypes.Type * Datatypes.instance) ref * int) list ref = ref([])
          exception No_parent_frame of Type
a479 4
              val result = (if !do_debug then 
                              output(std_out,"\n substitute_type ... \n")
                            else ();
                            substitute_type(ty))
d481 1
a481 3
              (if !do_debug then 
                 output(std_out,"\n ... substitute_type \n")
               else ();result)
d492 1
a492 1
            | instantiate_type(instance as Datatypes.INSTANCE(instances),TWO(inst,inst'),_) = 
d509 9
d519 1
a519 9
          fun instantiate_type' nil ty = 
            let 
              val ty = S_type(!S,ty)
            in
              case Types.all_tyvars(ty) of
                nil => ty
              | _ => 
                  raise No_parent_frame(ty)
            end
d530 1
a530 1
                val _ = 
d534 1
a534 1
                   val _ = 
d538 1
a538 1
                     else ()
a571 9
                fun fetch_offset(Option.ABSENT) = 
                     Crash.impossible "ABSENT:fetch_offset:debugger_print"
                  | fetch_offset(Option.PRESENT(ref(Option.SOME1(_)))) = 
                    Crash.impossible "SOME1:fetch_offset:debugger_print"
                  | fetch_offset(Option.PRESENT(ref(Option.SOME2(offset)))) = 
                    (if !do_debug then 
                       output(std_out,"\n offset:"
                            ^MLWorks.Integer.makestring offset^"\n")
                     else ();offset)
d624 1
d627 1
a627 1
          fun print_env (LET(envs,env)) indent ns str =
d629 1
a629 1
              LET(envs',env) => print_env (LET(envs@@envs',env)) indent ns str
d635 1
a635 1
                 (fn (str',(Option.PRESENT(name,ref (ty,_),offset),
d638 33
d675 2
a676 6
                              if debug_polyvariables then
                                (instantiate_type' frames ty
                                 handle No_parent_frame(ty) => ty,
                                 Option.PRESENT(ty))
                              else
                                (ty,Option.ABSENT)
d681 1
a681 1
                          Types.print_type print_options ty^" = "
d684 1
a684 1
                          (fn()=>str()^letstr^str'')
d694 9
a702 3
                                 (if !do_debug then 
                                    output(std_out,"\n offset : "^
                                           MLWorks.Integer.makestring offset^"\n")
a703 2
                                  present_value := MLWorks.Internal.Value.frame_offset
                                  (present_frame,offset);
d706 2
a707 1
                                    print_value(ty,!present_value))
d721 1
a721 1
                           str'^^("\n"^indent^"  val ? = "^print_env' env (indent^" ") ns 
d730 1
a730 1
                                    end))
d735 1
a735 1
                val str' = "" ^^ (letstr ^ expstr ^ ("\n"^indent^"in\n"))
d738 1
a738 1
                (str'^^print_env' (env) (indent^" ") ns (fn()=>str()^str'))
d747 4
a750 4
            | print_env (FN(name,_,_,_)) indent _ _ = "\n"^indent^"fn "^name^" "
            | print_env (APP(BUILTIN,env,Option.ABSENT)) indent ns str = 
              print_env env indent ns str
            | print_env (APP(env1,env2,Option.PRESENT(apps'))) indent ns str = 
d756 1
a756 1
                  print_env' env1 indent ns (fn()=>str()^"\n"^indent^"(") ^ 
d763 1
a763 1
                    print_env' env2 indent ns (fn()=>str()^env1str) ^ "\n"^indent^")")
d769 1
a769 1
                  if !apps = first_spill then 
d775 1
a775 1
            | print_env (APP(env1,env2,Option.ABSENT)) indent ns str = 
d781 1
a781 1
                      print_env' env1 indent ns (fn()=>str()^"\n"^indent^"(") ^ 
d786 1
a786 1
                           print_env' env2 indent ns (fn()=>str()^env1str) ^ "\n"^indent^")")
d793 2
a794 1
                 if !apps = first_spill then 
d800 3
a802 2
                   raise finished(str()^envsstr^"\n"^indent^
                                  "****** CONTROL TRANSFER ******\n")
d807 1
a807 1
            | print_env (RAISE(env)) indent ns str =  
d812 2
a813 1
               if !apps = first_spill then
d817 1
a817 1
                     print_env' env (indent^" ") ns raisestr
d821 3
a823 2
                  raise finished((raisestr()^^envstr)^
                                 "\n"^indent^"****** CONTROL TRANSFER ******\n")
d827 1
a827 1
                      print_env'(env) (indent^" ") ns (fn()=>str()^raisestr)))
d829 3
a831 2
            | print_env (SELECT(n,env)) indent ns str = print_env env indent (n::ns) str
            | print_env (STRUCT(envs)) indent ns str = 
d837 1
a837 1
                      val envstr = print_env' env indent ns (fn()=>str()^str')
d843 2
a844 2
                   print_env' (Lists.nth(n,envs)) indent ns str)
            | print_env (LIST(envs)) indent ns str = 
d849 1
a849 1
                      val envstr = print_env' env indent ns (fn()=>str()^str')
d854 1
a854 1
            | print_env (SWITCH(env,ref(Option.SOME2(offset)),apps',envs)) indent ns str = 
d860 1
a860 1
                   switchstr^^print_env' env (indent^" ") ns (fn()=>str()^switchstr))
d867 2
d871 1
d873 5
a877 1
                              (indent^" ") ns (fn()=>str()^envstr)^"\n"^indent^"end(switch)")
d883 2
a884 1
            | print_env (HANDLE(env1,ref(Option.SOME2(offset)),apps',env2)) indent ns str = 
d886 3
d892 5
a896 2
                 val env1str = print_env' env1 (indent^" ") ns (fn()=>str())
                 val which_switch = fetch_value (present_frame,offset)
d898 6
a903 5
                 case which_switch of
                   1 => ""^^env1str                     
                 | 2 => 
                     let 
                       val new_apps = !apps
d907 4
a910 1
                          print_env' env2 (indent^" ") ns (fn()=>str()^env1str))
d912 1
a912 1
                        (apps := new_apps;
a914 1
                 | _ => Crash.impossible "HANDLE:print_env:debugger_print"
d916 3
a918 3
            | print_env (EMPTY) _ _ _ = ""
            | print_env (BUILTIN) _ _ _ = ""
            | print_env _ _ _ _ = Crash.impossible "print_env:print_env:debugger_print"
d920 1
a920 1
          and print_env' env indent ns str = 
d922 1
a922 1
             print_env env indent ns str)
d925 1
a925 1
           (fnstr^(print_env env (" ") nil (fn()=>"")
d927 1
a927 1
            rev(return_windowing_info()))
@


1.3
log
@print_env now returns list used in inspector invocation in debugger-window.
@
text
@d4 3
d21 1
d30 1
a32 1
       sharing type RuntimeEnv_type.spill = int
d36 1
d47 2
d50 1
a50 1
      fun print_env ((present_frame,env),print_value,fetch_value,options,windowing) = 
d65 3
a67 1
          val Options.OPTIONS{print_options,...} = options
d79 1
a79 1
                | print_offset _ = Crash.impossible "print_offset:debug_print:debugger"
d82 1
a82 1
                 map (fn (Option.PRESENT(name,ref ty,offset),
d91 1
a91 1
                | debug_print (FN(name,env,offset)) indent = 
d140 1
a140 1
                | debug_print _ _ = Crash.impossible "debug_print:debugger"
d151 1
a151 1
            ref(MLWorks.Internal.Value.cast(0))
d153 1
a153 1
          val (fnstr,env,first_spill) = 
d155 1
a155 1
             FN(name,env,ref(Option.SOME2(offset))) => 
d157 2
a158 2
                env,fetch_value(present_frame,offset))
           | FN(name,env,ref(Option.SOME1(1))) => 
a159 1
               (*(output(std_out,"\nfn "^name^" ");(env,0))*)
d161 13
a173 3
           | _ => Crash.impossible "print_env:debugger"
          (*val _ = output(std_out,"\n first_spill = "^
           MLWorks.Integer.makestring first_spill^"\n")*)
d183 216
d407 1
a407 1
                 (fn (str',(Option.PRESENT(name,ref ty,offset),
d409 46
a454 31
                      (
                                  let
                                    val str'' = str'^"\n"^indent^"  val "^name^":"^
                                      Types.print_type print_options ty^" = "
                                    val envstr = print_env' env (indent^"    ") ns 
                                                       (fn()=>str()^letstr^str'')
                                    val envstr = 
                                   (str'' ^ 
                                    (present_value_string := 
                                  (case offset of 
                                     Option.ABSENT => 
                                       (present_value := MLWorks.Internal.Value.cast(0);
                                        if Types.isFunType(ty) then "fn"
                                        else "unavailable")
                                   | Option.PRESENT(ref(Option.SOME2(offset))) => 
                                      ((*output(std_out,"\n offset : "^
                                        MLWorks.Integer.makestring offset^"\n");*)
                                       (*if Types.isFunType(ty) then ""
                                       else*)
                                       present_value := MLWorks.Internal.Value.frame_offset
                                                              (present_frame,offset);
                                       print_value(ty,!present_value))
                                   | _ => Crash.impossible "LET:print_env:debugger");
                                     !present_value_string))^^
                                     (" = "^envstr)
                                  in
                                    (print_str := true;
                                     accumulate_windowing_info(name,
                                          (ty,!present_value,!present_value_string));
                                     envstr)
                                  end)
d459 1
a459 1
                           str'^^print_env' env (indent^" ") ns 
d464 1
a464 1
                                      val str = str()^^(letstr^str')
d468 1
a468 1
                                    end)
d485 1
a485 1
            | print_env (FN(name,_,_)) indent _ _ = "\n"^indent^"fn "^name^" "
d534 2
a535 1
                     handle finished _ => Crash.impossible "finished:APP:print_env"
d553 2
a554 1
                     handle finished _ => Crash.impossible "finished:RAISE:print_env"
d630 1
a630 1
                 | _ => Crash.impossible "HANDLE:print_env:debugger"
d634 1
a634 1
            | print_env _ _ _ _ = Crash.impossible "print_env:print_env:debugger"
@


1.3.1.1
log
@Fork for bug fixing
@
text
@a3 3
# Revision 1.3  1993/08/10  14:45:05  nosa
# print_env now returns list used in inspector invocation in debugger-window.
#
@


1.2
log
@Changed type of print_env.
@
text
@d4 3
d43 15
a57 2
      fun print_env ((present_frame,env),print_value,fetch_value,options) = 
        let 
d141 3
d183 1
d185 4
a188 2
                                     Option.ABSENT => if Types.isFunType(ty) then "fn"
                                                      else "unavailable"
d194 5
a198 2
                                         print_value(ty,offset))
                                   | _ => Crash.impossible "LET:print_env:debugger"))^^
d201 4
a204 1
                                    (print_str := true;envstr)
d390 3
a392 2
           fnstr^(print_env env (" ") nil (fn()=>"")
                  handle finished(envstr) => envstr)
d394 1
a394 1
      handle finished(str) => str
@


1.1
log
@Initial revision
@
text
@d4 3
d125 1
a125 1
          val (env,first_spill) = 
d128 2
a129 2
               (output(std_out,"\nfn "^name);
                (env,fetch_value(present_frame,offset)))
d362 2
a363 3
          ((output(std_out,print_env env (" ") nil (fn()=>""))(*;
            Crash.impossible "finished:print_env"*))
           handle finished(envstr) => output(std_out,envstr))
d365 1
a365 1
      handle finished(str) => output(std_out,str)
@
