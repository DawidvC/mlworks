head	1.31;
access;
symbols
	ML_beta_release_12/08/94:1.31
	ML_beta_release_03/08/94:1.31
	ML_revised_beta_release_25/05/94:1.31
	ML_final_beta_release_02/03/94:1.30
	mlworks-28-01-1994:1.29
	Release:1.25
	mlworks-beta-01-09-1993:1.25
	MLWorks-1-0-4-29/01/1993:1.19
	MLWorks-1-0-3-21/12/1992:1.18
	MLWorks-1-0-2-15/12/1992:1.18
	MLWorks-1-0-1-04/12/1992:1.16
	checkpoint_17_08_92:1.6;
locks; strict;


1.31
date	94.05.05.15.27.24;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	94.02.22.03.14.13;	author nosa;	state Exp;
branches;
next	1.29;

1.29
date	93.12.09.19.27.08;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	93.11.30.12.21.23;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.09.03.10.41.40;	author nosa;	state Exp;
branches;
next	1.26;

1.26
date	93.09.02.17.07.53;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.05.18.18.41.18;	author jont;	state Exp;
branches
	1.25.1.1;
next	1.24;

1.24
date	93.04.29.10.19.59;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.03.10.16.59.36;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.03.04.13.11.12;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.03.02.17.45.31;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.02.04.16.15.20;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	92.12.22.15.00.54;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.12.09.15.55.22;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.12.07.17.09.59;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.12.01.16.46.32;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	92.11.26.15.29.14;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	92.11.17.13.08.52;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	92.11.16.15.34.01;	author clive;	state Exp;
branches;
next	1.12;

1.12
date	92.10.12.11.47.54;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.09.30.08.26.59;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.09.04.08.36.08;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	92.09.02.08.42.11;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.08.24.09.54.38;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.08.18.14.16.49;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.08.07.13.32.39;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.08.07.13.32.39;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	92.07.22.09.23.26;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.07.21.14.46.46;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.07.16.16.58.21;	author clive;	state Exp;
branches;
next	1.1;

1.1
date	92.07.09.09.43.35;	author clive;	state Exp;
branches;
next	;

1.25.1.1
date	93.05.18.18.41.18;	author jont;	state Exp;
branches;
next	1.25.1.2;

1.25.1.2
date	93.09.02.13.31.50;	author matthew;	state Exp;
branches;
next	;


desc
@Initial version
@


1.31
log
@Datatypes.META_OVERLOADED takes extra arguments.
@
text
@(* _debugger_type_utilities the functor *)
(*
$Log: _debugger_type_utilities.sml,v $
Revision 1.30  1994/02/22  03:14:13  nosa
Extra TYNAME valenv for Modules Debugger.

Revision 1.29  1993/12/09  19:27:08  jont
Added copyright message

Revision 1.28  1993/11/30  12:21:23  matthew
Added is_abs field to TYNAME and METATYNAME

Revision 1.27  1993/09/03  10:41:40  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.26  1993/09/02  17:07:53  matthew
Merging in bug fixes

Revision 1.25.1.2  1993/09/02  13:31:50  matthew
Added some debugging information

Revision 1.25  1993/05/18  18:41:18  jont
Removed integer parameter

Revision 1.24  1993/04/29  10:19:59  matthew
Renamed Debugger_Type_Utilities to DebuggerTypeUtilities

Revision 1.23  1993/03/10  16:59:36  matthew
Signature revisions

Revision 1.22  1993/03/04  13:11:12  matthew
Options & Info changes
Removed options param from generate_recipe

Revision 1.21  1993/03/02  17:45:31  matthew
Rationalised use of Mapping structure

Revision 1.20  1993/02/04  16:15:20  matthew
Changed functor parameter

Revision 1.19  1992/12/22  15:00:54  jont
Anel's last changes

Revision 1.18  1992/12/09  15:55:22  clive
Changed to error message to a better one

Revision 1.17  1992/12/07  17:09:59  clive
Added some debugging messages

Revision 1.16  1992/12/01  16:46:32  matthew
Removed "Can't generate debugging information" warning

Revision 1.15  1992/11/26  15:29:14  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.14  1992/11/17  13:08:52  matthew
Changed Error structure to Info

Revision 1.13  1992/11/16  15:34:01  clive
Changed the format of the error message

Revision 1.12  1992/10/12  11:47:54  clive
Tynames now have a slot recording their definition point

Revision 1.11  1992/09/30  08:26:59  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.10  1992/09/04  08:36:08  richard
Installed central error reporting mechanism.

Revision 1.9  1992/09/02  08:42:11  clive
Tidied up the wrong-type-found message

Revision 1.8  1992/08/24  09:54:38  clive
Added details about leafness to the debug information

Revision 1.7  1992/08/18  14:16:49  clive
Various improvements

Revision 1.6  1992/08/07  13:32:39  clive
New sharing constraints after lower level changes

Revision 1.5  1992/08/07  13:32:39  clive
Handles the propogation of types better

Revision 1.4  1992/07/22  09:23:26  clive
Periodical checking in - many improvements

Revision 1.3  1992/07/21  14:46:46  clive
More work on the debugger

Revision 1.2  1992/07/16  16:58:21  clive
Added utilites for the polymorphic deduction code

Revision 1.1  1992/07/09  09:43:35  clive
Initial revision

 * Copyright (c) 1993 Harlequin Ltd.
*)

require "debugger_types";
require "../utils/lists";
require "debugger_type_utilities";
require "../typechecker/types";

functor DebuggerTypeUtilities(
  structure Lists : LISTS
  structure Types : TYPES
  structure Debugger_Types : DEBUGGER_TYPES

  sharing type Types.Datatypes.Type = Debugger_Types.Type
  sharing type Types.Datatypes.Tyname = Debugger_Types.Tyname

                                ) : DEBUGGER_TYPE_UTILITIES =
  
  struct
    
    structure Debugger_Types = Debugger_Types
    structure Datatypes = Types.Datatypes
    structure Map = Datatypes.Mapping

    val debugging = ref(false)

    fun debug(x) = () (* output(std_out,x ^ "\n") *)
    fun generate_message x = ""

    fun slim_down_a_type(x as Datatypes.METATYVAR(ref(_,Datatypes.NULLTYPE,_),_,_)) = x
      | slim_down_a_type(Datatypes.METATYVAR(ref(_,ty,_),_,_)) = slim_down_a_type ty
      | slim_down_a_type(Datatypes.META_OVERLOADED {1=ref ty,...}) =
        slim_down_a_type ty
      | slim_down_a_type(x as Datatypes.TYVAR _) = x
      | slim_down_a_type(Datatypes.METARECTYPE(ref(_,_,ty,_,_))) = slim_down_a_type ty
      | slim_down_a_type(Datatypes.RECTYPE mapping) =
          Datatypes.RECTYPE(Datatypes.Mapping.mapit (mapping,slim_down_a_type))
      | slim_down_a_type(Datatypes.FUNTYPE(arg,res)) =
        Datatypes.FUNTYPE(slim_down_a_type arg,slim_down_a_type res)
      | slim_down_a_type(Datatypes.CONSTYPE(ty_list,tyname)) =
        Datatypes.CONSTYPE(map slim_down_a_type ty_list,tyname)
      | slim_down_a_type(x as Datatypes.DEBRUIJN _) = x
      | slim_down_a_type x = x
 
    fun cut_away_unnecessary_stuff(x as Datatypes.METATYVAR(ref(_,
                                                Datatypes.NULLTYPE,_),_,_)) = x
      | cut_away_unnecessary_stuff(Datatypes.METATYVAR(ref(_,x,_),_,_)) = 
        cut_away_unnecessary_stuff x
      | cut_away_unnecessary_stuff x = x

    exception CantGenerateRecipe
    exception FailGeneration

    fun get_arg_and_res_types(Datatypes.FUNTYPE (arg,res)) = (arg,res)
      | get_arg_and_res_types arg = (debug ("Not a function type " ^ Types.debug_print_type arg ^ "\n");
                                     raise CantGenerateRecipe)

    (* We walk the first argument, working out a position for each metatyvar that occurs;
       we then use the map to walk the second argument *)

    exception OverLoadedFound
    exception TyVarFound
    exception DeBruijnFound

    fun walk(assoc,ty,f) =
      walk'((ty,f Debugger_Types.Nop)::assoc,ty,f)

    and walk'(assoc,Datatypes.NULLTYPE,_) = assoc
      | walk'(assoc,Datatypes.META_OVERLOADED {1=ref ty,...}, f) =
	walk'(assoc,ty,f)
      | walk'(assoc,Datatypes.TYVAR _,_) = raise CantGenerateRecipe
      | walk'(assoc,var as Datatypes.METATYVAR(ref(_,Datatypes.NULLTYPE,_),_,_),f) = 
        (var,f Debugger_Types.Nop)::assoc
      | walk'(assoc,Datatypes.METATYVAR(ref(_,ty,_),_,_),f) = walk'(assoc,ty,f)
      | walk'(assoc,Datatypes.METARECTYPE(ref(_,_,ty,_,_)),f) = walk'(assoc,ty,f)
      | walk'(assoc,ty as (Datatypes.RECTYPE _),f) =
        let
          val range = Types.rectype_range ty
          val (assoc',_) = 
            Lists.reducel (fn ((assoc,count),ty) =>
                           (walk'(assoc,ty,fn x => f(Debugger_Types.Select(count,x))),count+1))
                           ((assoc,0),range)
        in
          assoc'
        end
      | walk'(assoc,Datatypes.FUNTYPE(arg,res),f) =
        walk(walk(assoc,arg,fn x => f(Debugger_Types.Funarg x)),res,fn x => f(Debugger_Types.Funres x))
      | walk'(assoc,ty as Datatypes.CONSTYPE(ty_list,name),f) =
        let
          val assoc' = (ty,f Debugger_Types.Nop)::assoc
          val (assoc'',_) = 
            Lists.reducel (fn ((assoc,count),ty) =>
                           (walk(assoc,ty,fn x => f(Debugger_Types.DeCons(count,x))),count+1))
            ((assoc',0),ty_list)
        in
          assoc''
        end
      | walk'(assoc,Datatypes.DEBRUIJN _,_) = raise DeBruijnFound

    fun generate_recipe (ty,recipe_for,name,warning_issued) =
      (case ty of
        Datatypes.NULLTYPE => (debug "Generating for NULLTYPE";
                               raise FailGeneration)
      | _ =>
          let
            val (arg,res) = get_arg_and_res_types(cut_away_unnecessary_stuff ty)
            val assoc = walk([],arg,fn x => x)
              
            exception Assoc
            
            fun do_assoc(x,y) =
              let
                fun eq(Datatypes.METATYVAR(n as ref(_,Datatypes.NULLTYPE,_),_,_),
                       Datatypes.METATYVAR(m as ref(_,Datatypes.NULLTYPE,_),_,_)) = m=n
                  | eq(arg as Datatypes.METATYVAR(ref(n,
                                  Datatypes.NULLTYPE,_),_,_),arg') = eq(arg',arg)
                  | eq(Datatypes.METATYVAR(ref(_,t,_),_,_),
                       arg' as Datatypes.METATYVAR(ref(n,Datatypes.NULLTYPE,_),_,_)) = 
                    eq(t,arg')
                  | eq(Datatypes.METATYVAR(ref(_,t,_),_,_),arg) = eq(t,arg)
                  | eq(arg,Datatypes.METATYVAR(ref(_,t,_),_,_)) = eq(arg,t)
                  | eq(Datatypes.META_OVERLOADED {1=ref ty,...}, arg') = eq(ty,arg')
                  | eq(arg',Datatypes.META_OVERLOADED {1=ref ty,...}) = eq(arg',ty)
                  | eq(Datatypes.TYVAR (_,Datatypes.Ident.TYVAR (sym,_,_)),
                       Datatypes.TYVAR (_,Datatypes.Ident.TYVAR (sym',_,_))) = 
                    sym=sym'
                  | eq(Datatypes.FUNTYPE(t,t'),Datatypes.FUNTYPE(s,s')) = eq(t,s) andalso eq(s,s')
                  | eq(Datatypes.METARECTYPE(ref(_,_,t,_,_)),arg) = eq(t,arg)
                  | eq(arg,Datatypes.METARECTYPE(ref(_,_,t,_,_))) = eq(arg,t)
                  | eq(Datatypes.CONSTYPE(args,Datatypes.TYNAME(n,_,_,_,_,_,_,_)),
                       Datatypes.CONSTYPE(args',Datatypes.TYNAME(m,_,_,_,_,_,_,_))) =
                    let
                      fun check ([],[]) = true
                        | check (_,[]) = false
                        | check([],_) = false
                        | check (h::t,a::b) = eq(h,a) andalso check(t,b)
                    in
                      (m=n) andalso check(args,args')
                    end
                  | eq(Datatypes.RECTYPE amap,Datatypes.RECTYPE amap') =
                    Datatypes.Mapping.eqmaps (amap,amap',eq)
                  | eq (x,y) = false
                    
                fun assoc'(x,[]) = raise Assoc
                  | assoc'(x,(h,a)::t) = 
                    if eq(x,h)
                      then a
                    else assoc'(x,t)
              in
                assoc'(x,y)
              end
            
            fun make_recipe arg =
              let
                val (found,recipe) = 
                  (true,do_assoc(arg,assoc)) 
                  handle Assoc => (false,Debugger_Types.Error)
              in
                if found
                  then (debug "Found in make_recipe";
                        recipe)
                else (debug "Not found in make_recipe";
                      make_recipe' arg)
              end
            
            and make_recipe'(arg as Datatypes.METATYVAR(ref(_,Datatypes.NULLTYPE,_),_,_)) =
              let
                val (found,recipe) = (true,do_assoc(arg,assoc)) handle Assoc => (false,Debugger_Types.Nop)
              in
                if found
                  then (debug "nulltype found" ; recipe)
                else (debug "nulltype not found" ; raise CantGenerateRecipe)
              end
              | make_recipe'(arg as Datatypes.METATYVAR(ref(_,ty,_),_,_)) = 
                (debug "metatyvar - going inside" ; 
                 make_recipe ty)
              | make_recipe'(Datatypes.META_OVERLOADED {1=ref ty,...}) =
		(debug "meta-overloaded"; 
                 make_recipe ty)
              | make_recipe'(arg as Datatypes.TYVAR _) =
                let
                  val (found,recipe) = (true,do_assoc(arg,assoc)) handle Assoc => (false,Debugger_Types.Nop)
                in
                  if found
                    then (debug "tyvar found" ; recipe)
                  else (debug "tyvar not found"; raise CantGenerateRecipe)
                end
              | make_recipe'(Datatypes.METARECTYPE(ref(_,_,ty,_,_))) = 
                (debug "meta-rectype";
                 make_recipe ty)
              | make_recipe'(ty as Datatypes.RECTYPE amap) =
                let
                  val _ = debug "rectype"
                  val domain = Types.rectype_domain ty
                  val range = Types.rectype_range ty
                in
                  Debugger_Types.MakeRecord
                  (map
                   (fn (Datatypes.Ident.LAB x,y) => (Datatypes.Ident.Symbol.symbol_name x,make_recipe y))
                   (Datatypes.Mapping.assoc amap))
                end
              | make_recipe'(Datatypes.FUNTYPE(from,to)) = 
                (debug "funtype";
                 Debugger_Types.MakeFunType(make_recipe from,make_recipe to))
              | make_recipe'(Datatypes.CONSTYPE(args,tyname)) = 
                (debug "constype";
                 Debugger_Types.MakeConsType(map make_recipe args,tyname))
              | make_recipe' _ = (debug "fail";
                                  raise CantGenerateRecipe)
                
            val result = case recipe_for
                           of Datatypes.NULLTYPE => 
                             (if ! debugging
                                then raise CantGenerateRecipe
                              else raise FailGeneration)
                            | _ => make_recipe recipe_for
                                
          in
            (result,warning_issued)
          end)
        handle FailGeneration => (Debugger_Types.Nop,warning_issued)
             | CantGenerateRecipe => 
          (debug "Handling CantGenerateRecipe" ; 
           if warning_issued
             then
               (Debugger_Types.Error,warning_issued)
           else
             (Debugger_Types.Error,true))

(*  Debugging function *)
(*
    val generate_recipe =
      fn (ty,recipe_for,name,warning_issued) =>
      (output(std_out,
              implode ["1:",Types.debug_print_type ty ^
                       "2:",Types.debug_print_type recipe_for ^ "\n"]);
       let
         val result = generate_recipe (ty,recipe_for,name,warning_issued)
         val _ = output(std_out,
                        implode ["Result:",Debugger_Types.print_backend_annotation (#1 result),"\n"])
       in
         result
       end)
*)
              
    exception RecipeApplicationProblem of string

    fun apply_recipe(recipe,start_type) =
      let
        fun apply_recipe' (Debugger_Types.Nop,x) = x
          | apply_recipe' (Debugger_Types.Error,_) = raise RecipeApplicationProblem 
            (generate_message "Error found")
          | apply_recipe' (_,ty as Datatypes.NULLTYPE) = raise RecipeApplicationProblem 
            (generate_message "Nulltype found")
          | apply_recipe' (x,Datatypes.METATYVAR(ref(_,ty,_),_,_)) = apply_recipe' (x,ty)
          | apply_recipe' (x,Datatypes.METARECTYPE(ref(_,_,ty,_,_))) = apply_recipe' (x,ty)
          | apply_recipe'(x,Datatypes.META_OVERLOADED {1=ref ty,...}) =
	    apply_recipe' (x,ty)
          | apply_recipe' (Debugger_Types.Select(arg,recipe'),ty as Datatypes.RECTYPE _) =
            let
              val range = Types.rectype_range ty
              fun select (0,h::t) = h
                | select (n,[]) = raise RecipeApplicationProblem 
                  (generate_message "Nil found before count is zero")
                | select (n,h::t) = select(n-1,t)
            in
              apply_recipe'(recipe',select(arg,range))
            end
          | apply_recipe'(Debugger_Types.MakeRecord args,ty) =
            let
              fun make_mapping ([],mapping) = mapping
                | make_mapping ((label,recipe)::rest,mapping) = 
                  make_mapping(rest,
                               Datatypes.Mapping.add((Datatypes.Ident.LAB
                                                      (Datatypes.Ident.Symbol.find_symbol label),
                                                      apply_recipe'(recipe,start_type)),
                               mapping,
                               Datatypes.Ident.lab_order))
            in
              Datatypes.RECTYPE(make_mapping (args,Datatypes.Mapping.empty_map))
            end
          | apply_recipe'(Debugger_Types.MakeConsType(args,ty_name),ty) =
            Datatypes.CONSTYPE(map (fn x => apply_recipe'(x,start_type)) args,ty_name)
          | apply_recipe'(Debugger_Types.DeCons(value,recipe),Datatypes.CONSTYPE(args,_)) =
            let
              fun select(_,[]) = raise RecipeApplicationProblem 
                (generate_message "Value too big in constype")
                | select(0,h::t) = h
                | select(n,h::t) = select(n-1,t)
            in
              apply_recipe'(recipe,select(value,args))
            end
          | apply_recipe'(Debugger_Types.Funarg(recipe),Datatypes.FUNTYPE(x,_)) =
            apply_recipe'(recipe,x)
          | apply_recipe'(Debugger_Types.Funres(recipe),Datatypes.FUNTYPE(_,x)) =
            apply_recipe'(recipe,x)
          | apply_recipe'(Debugger_Types.MakeFunType(recipe,recipe'),ty) =
            Datatypes.FUNTYPE(apply_recipe'(recipe,start_type),apply_recipe'(recipe',start_type))
          | apply_recipe' (recipe,_) = raise RecipeApplicationProblem 
            (generate_message ("Did not match any of the cases" ^ Debugger_Types.print_backend_annotation recipe))
      in
        apply_recipe'(recipe,start_type)
      end

    fun is_type_polymorphic (Datatypes.METATYVAR(ref(_,Datatypes.NULLTYPE,_),_,_)) = true
      | is_type_polymorphic (Datatypes.METATYVAR(ref(_,ty,_),_,_)) = is_type_polymorphic ty
      | is_type_polymorphic (Datatypes.NULLTYPE) = false
      | is_type_polymorphic (Datatypes.META_OVERLOADED {1=ref ty,...}) =
	is_type_polymorphic ty
      | is_type_polymorphic (Datatypes.TYVAR _) = true
      | is_type_polymorphic (Datatypes.METARECTYPE(ref(_,_,ty,_,_))) = is_type_polymorphic ty
      | is_type_polymorphic (ty as Datatypes.RECTYPE _) = 
        let
          val range = Types.rectype_range ty
        in
          Lists.exists is_type_polymorphic range
        end
      | is_type_polymorphic (Datatypes.FUNTYPE (a,b)) =
        is_type_polymorphic a orelse is_type_polymorphic b
      | is_type_polymorphic (Datatypes.CONSTYPE(args,_)) =
        Lists.exists is_type_polymorphic args
      | is_type_polymorphic (Datatypes.DEBRUIJN _) = true

        (* This function is supposed to check the argument type against that which is expected
         and to return the new instantiated type *)

    exception InValidMatch of string
    exception ForceInValidMatch

    fun check_type (input,ty) = 
      let
        val (argument_type,result_type) = get_arg_and_res_types(cut_away_unnecessary_stuff ty)

        fun debug x = () (* output(std_out,x()) *)

        fun match_types(x,y,env) =
          let
            val _ = debug(fn _ => "Matching the types\n")
            val _ = debug(fn _ => Types.debug_print_type(x) ^ "\n")
            val _ = debug(fn _ => Types.debug_print_type(y) ^ "\n")
          in
            match_types'(x,y,env)
          end

          and match_types'(Datatypes.CONSTYPE(args1,
                                              Datatypes.METATYNAME
                                              (ref(tyfun as (Datatypes.TYFUN _)),_,_,_,_,_)),
                        arg2,env) =
            (debug (fn _ => "first is tyfun\n");
             match_types(Types.apply(tyfun,args1),arg2,env))
          | match_types'(arg1,Datatypes.CONSTYPE(args2,
                                                 Datatypes.METATYNAME
                                                 (ref(tyfun as (Datatypes.TYFUN _)),_,_,_,_,_)),
                        env) =
            (debug(fn _ => "Second if tyfun\n");
             match_types(arg1,Types.apply(tyfun,args2),env))
          | match_types'(Datatypes.CONSTYPE(args1,
                                            Datatypes.METATYNAME
                                            (ref(Datatypes.ETA_TYFUN tyname),_,_,_,_,_)),
                        arg2,env) =
            (debug(fn _ => "First is eta_tyfun\n");
             match_types(Datatypes.CONSTYPE(args1,tyname),arg2,env))
          | match_types'(arg1,Datatypes.CONSTYPE(args2,
                                                 Datatypes.METATYNAME
                                                 (ref(Datatypes.ETA_TYFUN tyname),_,_,_,_,_)),
                        env) =
            (debug(fn _ => "second is eta_tyfun\n");
             match_types(arg1,Datatypes.CONSTYPE(args2,tyname),env))
          | match_types'(arg1,Datatypes.METATYVAR(
                                    name as ref(_,Datatypes.NULLTYPE,_),_,_),env) = 
            let
              val _ = debug(fn _ => "Looking up\n")
              val (found,value,env') = (true,Lists.assoc(name,env),env) 
                handle Lists.Assoc => (false,arg1,(name,arg1)::env)
              val _ = if found
                then debug(fn _ => "Found\n")
                      else debug(fn _ => "Not Found\n")
            in
              if found
                then
                  match_types(arg1,value,env)
              else
                env'
            end
            | match_types'(Datatypes.METATYVAR(ref(_,ty,_),_,_),arg2,env) = 
              (debug(fn _ => "1\n"); match_types(ty,arg2,env))
            | match_types'(arg1,Datatypes.METATYVAR(ref(_,ty,_),_,_),env) = 
              (debug(fn _ => "2\n");match_types(arg1,ty,env))
          | match_types'(Datatypes.META_OVERLOADED {1=ref ty,...},arg2,env) = 
            (debug(fn _ => "3\n");match_types(ty,arg2,env))
          | match_types'(arg1,Datatypes.META_OVERLOADED {1=ref ty,...},env) = 
            (debug(fn _ => "4\n");match_types(arg1,ty,env))
          | match_types'(Datatypes.METARECTYPE(ref(_,_,ty,_,_)),arg2,env) = 
            (debug(fn _ => "5\n");match_types(ty,arg2,env))
          | match_types'(arg1,Datatypes.METARECTYPE(ref(_,_,ty,_,_)),env) = 
            (debug(fn _ => "6\n");match_types(arg1,ty,env))
          | match_types'(Datatypes.NULLTYPE,Datatypes.NULLTYPE,env) = (debug(fn _ => "7\n");env)
          | match_types'(arg1 as Datatypes.DEBRUIJN x,Datatypes.DEBRUIJN y,env) = 
            (debug(fn _ => "8\n");
             if ((fn ty=>(#1(ty),#2(ty),#3(ty)))x)=((fn ty=>(#1(ty),#2(ty),#3(ty)))y)
               then env
             else (debug(fn _ => "Problem at DeBruijn\n");
                   raise ForceInValidMatch))
          | match_types'(Datatypes.CONSTYPE(args1,Datatypes.TYNAME(tyname1,_,_,_,_,_,_,_)),
                        Datatypes.CONSTYPE(args2,Datatypes.TYNAME(tyname2,_,_,_,_,_,_,_)),env) =
            (debug(fn _ => "9\n");
             if tyname1 = tyname2 
               andalso Lists.length args1 = Lists.length args2
               then
                 let 
                   val env'' = 
                     Lists.reducer (fn ((arg1,arg2),env) =>
                                    let
                                      val env' = match_types(arg1,arg2,env)
                                    in
                                      env'
                                    end)
                     (Lists.zip(args1,args2),env)
                 in
                   env''
                 end
             else (debug(fn _ => "At end of constype\n");
                   raise ForceInValidMatch))
          | match_types'(Datatypes.FUNTYPE(from,to), Datatypes.FUNTYPE(from',to'),env) =
            let
              val _ = debug(fn _ => "10\n");
              val env' = match_types(from,from',env)
              val env'' = match_types(to,to',env')
            in
              env''
            end
          | match_types'(ty as Datatypes.RECTYPE _,ty' as Datatypes.RECTYPE _,env) = 
               let
                 val _ = debug(fn _ => "11\n");
                 val domain = Types.rectype_domain ty
                 val range = Types.rectype_range ty
                 val domain' = Types.rectype_domain ty'
                 val range' = Types.rectype_range ty'
               in
                 if domain = domain'
                   then
                     let
                       val env' =
                         Lists.reducer (fn ((arg1,arg2),env) =>
                                        let
                                          val env' = match_types(arg1,arg2,env)
                                        in
                                          env'
                                        end)
                         (Lists.zip(range,range'),env)
                     in
                       env'
                     end
                 else (debug(fn _ => "at end of rectype\n");
                       raise ForceInValidMatch)
               end

            | match_types'(Datatypes.CONSTYPE(_,Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN _),_,_,_,_,_)),_,env) = env

            | match_types'(_,_,_) = (debug(fn _ => "Failed to match\n");
                                     raise ForceInValidMatch)

        fun substitute_for_meta(_,_,x as Datatypes.NULLTYPE) = x
          | substitute_for_meta(arg,result,
                                arg2 as Datatypes.METATYVAR(arg' as ref(_,
                                                        Datatypes.NULLTYPE,_),_,_)) =
            if arg=arg'
              then result
            else arg2
          | substitute_for_meta(x,y,Datatypes.METATYVAR(ref(_,ty,_),_,_)) = 
            substitute_for_meta(x,y,ty)
          | substitute_for_meta(x,y,Datatypes.META_OVERLOADED {1=ref ty,...}) =
	    substitute_for_meta(x,y,ty)
          | substitute_for_meta(x,y,arg as Datatypes.TYVAR _) = arg
          | substitute_for_meta(x,y,arg as Datatypes.METARECTYPE(ref(_,_,ty,_,_))) =
            substitute_for_meta(x,y,ty)
          | substitute_for_meta(x,y,Datatypes.RECTYPE(mapping)) =
            Datatypes.RECTYPE(Map.mapit(mapping,fn z => substitute_for_meta(x,y,z)))
          | substitute_for_meta(x,y,Datatypes.FUNTYPE(a,b)) = 
            Datatypes.FUNTYPE(substitute_for_meta(x,y,a),
                              substitute_for_meta(x,y,b))
            | substitute_for_meta(x,y,Datatypes.CONSTYPE(tys,tyname)) =
              Datatypes.CONSTYPE(map (fn z => substitute_for_meta(x,y,z)) tys,tyname)
          | substitute_for_meta(_,_,x as Datatypes.DEBRUIJN _) = x

          fun do_subs ([],x) = x
            | do_subs ((name,v)::rest,x) = do_subs(rest,substitute_for_meta(name,v,x))
              
          val result = 
            do_subs(match_types(input,argument_type,[]),ty)
            handle ForceInValidMatch => 
              raise InValidMatch
                (implode ["Expected Input type to have a different type (probably due to tail-call optimisation)\n",
                          "  Input:    ", Types.debug_print_type (input),
                          "\n  Expected: ", Types.debug_print_type (argument_type),"\n\n"])
      in
        if is_type_polymorphic (#1(get_arg_and_res_types result))
          then (debug (fn _ => "Type is polymorphic\n" ^ Types.debug_print_type(result) ^ "\n");
                raise InValidMatch
                  (implode 
                   ["Unexpected Input type to have a different type (probably due to tail-call optimisation)\n",
                    "   Input: ", Types.debug_print_type (input),
                    "\n  Expected: ", Types.debug_print_type (argument_type)]))
        else
          result
      end

  end
 
@


1.30
log
@Extra TYNAME valenv for Modules Debugger.
@
text
@d4 3
d130 2
a131 1
      | slim_down_a_type(Datatypes.META_OVERLOADED(ref ty,_)) = slim_down_a_type ty
d167 2
a168 1
      | walk'(assoc,Datatypes.META_OVERLOADED (ref ty,_),f) = walk'(assoc,ty,f)
d220 2
a221 2
                  | eq(Datatypes.META_OVERLOADED (ref ty,_), arg') = eq(ty,arg')
                  | eq(arg',Datatypes.META_OVERLOADED (ref ty,_)) = eq(arg',ty)
d274 4
a277 3
                                                                           make_recipe ty)
              | make_recipe'(Datatypes.META_OVERLOADED (ref ty,_)) = (debug "meta-overloaded"; 
                                                                    make_recipe ty)
d355 2
a356 1
          | apply_recipe'(x,Datatypes.META_OVERLOADED (ref ty,_)) = apply_recipe' (x,ty)
d406 2
a407 1
      | is_type_polymorphic (Datatypes.META_OVERLOADED(ref ty,_)) = is_type_polymorphic ty
d487 1
a487 1
          | match_types'(Datatypes.META_OVERLOADED(ref ty,_),arg2,env) = 
d489 1
a489 1
          | match_types'(arg1,Datatypes.META_OVERLOADED(ref ty,_),env) = 
d570 2
a571 1
          | substitute_for_meta(x,y,Datatypes.META_OVERLOADED(ref ty,_)) = substitute_for_meta(x,y,ty)
@


1.29
log
@Added copyright message
@
text
@d4 3
d223 2
a224 2
                  | eq(Datatypes.CONSTYPE(args,Datatypes.TYNAME(n,_,_,_,_,_,_)),
                       Datatypes.CONSTYPE(args',Datatypes.TYNAME(m,_,_,_,_,_,_))) =
d494 2
a495 2
          | match_types'(Datatypes.CONSTYPE(args1,Datatypes.TYNAME(tyname1,_,_,_,_,_,_)),
                        Datatypes.CONSTYPE(args2,Datatypes.TYNAME(tyname2,_,_,_,_,_,_)),env) =
@


1.28
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d4 3
d93 1
@


1.27
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d4 3
d216 2
a217 2
                  | eq(Datatypes.CONSTYPE(args,Datatypes.TYNAME(n,_,_,_,_,_)),
                       Datatypes.CONSTYPE(args',Datatypes.TYNAME(m,_,_,_,_,_))) =
d430 1
a430 1
                                              (ref(tyfun as (Datatypes.TYFUN _)),_,_,_,_)),
d436 1
a436 1
                                                 (ref(tyfun as (Datatypes.TYFUN _)),_,_,_,_)),
d442 1
a442 1
                                            (ref(Datatypes.ETA_TYFUN tyname),_,_,_,_)),
d448 1
a448 1
                                                 (ref(Datatypes.ETA_TYFUN tyname),_,_,_,_)),
d487 2
a488 2
          | match_types'(Datatypes.CONSTYPE(args1,Datatypes.TYNAME(tyname1,_,_,_,_,_)),
                        Datatypes.CONSTYPE(args2,Datatypes.TYNAME(tyname2,_,_,_,_,_)),env) =
d541 1
a541 1
            | match_types'(Datatypes.CONSTYPE(_,Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN _),_,_,_,_)),_,env) = env
@


1.26
log
@Merging in bug fixes
@
text
@d4 3
d115 2
a116 2
    fun slim_down_a_type(x as Datatypes.METATYVAR(ref(_,Datatypes.NULLTYPE),_,_)) = x
      | slim_down_a_type(Datatypes.METATYVAR(ref(_,ty),_,_)) = slim_down_a_type ty
d129 4
a132 2
    fun cut_away_unnecessary_stuff(x as Datatypes.METATYVAR(ref(_,Datatypes.NULLTYPE),_,_)) = x
      | cut_away_unnecessary_stuff(Datatypes.METATYVAR(ref(_,x),_,_)) = cut_away_unnecessary_stuff x
d155 1
a155 1
      | walk'(assoc,var as Datatypes.METATYVAR(ref(_,Datatypes.NULLTYPE),_,_),f) = 
d157 1
a157 1
      | walk'(assoc,Datatypes.METATYVAR(ref(_,ty),_,_),f) = walk'(assoc,ty,f)
d196 9
a204 7
                fun eq(Datatypes.METATYVAR(n as ref(_,Datatypes.NULLTYPE),_,_),
                       Datatypes.METATYVAR(m as ref(_,Datatypes.NULLTYPE),_,_)) = m=n
                  | eq(arg as Datatypes.METATYVAR(ref(n,Datatypes.NULLTYPE),_,_),arg') = eq(arg',arg)
                  | eq(Datatypes.METATYVAR(ref(_,t),_,_),
                       arg' as Datatypes.METATYVAR(ref(n,Datatypes.NULLTYPE),_,_)) = eq(t,arg')
                  | eq(Datatypes.METATYVAR(ref(_,t),_,_),arg) = eq(t,arg)
                  | eq(arg,Datatypes.METATYVAR(ref(_,t),_,_)) = eq(arg,t)
d249 1
a249 1
            and make_recipe'(arg as Datatypes.METATYVAR(ref(_,Datatypes.NULLTYPE),_,_)) =
d257 2
a258 1
              | make_recipe'(arg as Datatypes.METATYVAR(ref(_,ty),_,_)) = (debug "metatyvar - going inside" ; 
d337 1
a337 1
          | apply_recipe' (x,Datatypes.METATYVAR(ref(_,ty),_,_)) = apply_recipe' (x,ty)
d386 2
a387 2
    fun is_type_polymorphic (Datatypes.METATYVAR(ref(_,Datatypes.NULLTYPE),_,_)) = true
      | is_type_polymorphic (Datatypes.METATYVAR(ref(_,ty),_,_)) = is_type_polymorphic ty
d449 2
a450 1
          | match_types'(arg1,Datatypes.METATYVAR(name as ref(_,Datatypes.NULLTYPE),_,_),env) = 
d465 1
a465 1
            | match_types'(Datatypes.METATYVAR(ref(_,ty),_,_),arg2,env) = 
d467 1
a467 1
            | match_types'(arg1,Datatypes.METATYVAR(ref(_,ty),_,_),env) = 
d480 1
a480 1
             if x=y
d545 2
a546 1
                                arg2 as Datatypes.METATYVAR(arg' as ref(_,Datatypes.NULLTYPE),_,_)) =
d550 2
a551 1
          | substitute_for_meta(x,y,Datatypes.METATYVAR(ref(_,ty),_,_)) = substitute_for_meta(x,y,ty)
@


1.25
log
@Removed integer parameter
@
text
@d4 6
d304 16
@


1.25.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.25  1993/05/18  18:41:18  jont
Removed integer parameter

@


1.25.1.2
log
@Added some debugging information
@
text
@a300 16
(*  Debugging function *)
(*
    val generate_recipe =
      fn (ty,recipe_for,name,warning_issued) =>
      (output(std_out,
              implode ["1:",Types.debug_print_type ty ^
                       "2:",Types.debug_print_type recipe_for ^ "\n"]);
       let
         val result = generate_recipe (ty,recipe_for,name,warning_issued)
         val _ = output(std_out,
                        implode ["Result:",Debugger_Types.print_backend_annotation (#1 result),"\n"])
       in
         result
       end)
*)
              
@


1.24
log
@Renamed Debugger_Type_Utilities to DebuggerTypeUtilities
@
text
@d4 3
a81 1
require "../utils/integer";
a87 1
  structure Integer : INTEGER
@


1.23
log
@Signature revisions
@
text
@d4 3
d83 1
a83 1
functor Debugger_Type_Utilities(
@


1.22
log
@Options & Info changes
Removed options param from generate_recipe
@
text
@d4 4
d86 3
a88 1
  sharing Types.Datatypes = Debugger_Types.Datatypes
d94 1
a94 1
    structure Datatypes = Debugger_Types.Datatypes
@


1.21
log
@Rationalised use of Mapping structure
@
text
@d4 3
a89 1
    structure Info = Debugger_Types.Info
d162 1
a162 1
    fun generate_recipe options (ty,recipe_for,name,warning_issued) =
d286 1
a286 2
             ((* Info.error options (Info.WARNING, Info.Location.UNKNOWN, "Can't generate debugging information for " ^ name);*)
              (Debugger_Types.Error,true)))
@


1.20
log
@Changed functor parameter
@
text
@d4 3
d136 1
a136 1
      | walk'(assoc,Datatypes.RECTYPE(map),f) =
d138 1
a138 1
          val domain = Datatypes.Mapping.range map
d142 1
a142 1
                           ((assoc,0),domain)
d247 1
a247 1
              | make_recipe'(Datatypes.RECTYPE(amap)) =
d250 2
a251 2
                  val domain = Datatypes.Mapping.domain amap
                  val range = Datatypes.Mapping.range amap
d299 1
a299 1
          | apply_recipe' (Debugger_Types.Select(arg,recipe'),Datatypes.RECTYPE mapping) =
d301 1
a301 1
              val range = Datatypes.Mapping.range mapping
d351 1
a351 1
      | is_type_polymorphic (Datatypes.RECTYPE mapping) = 
d353 1
a353 1
          val range = Datatypes.Mapping.range mapping
d470 1
a470 1
          | match_types'(Datatypes.RECTYPE mapping,Datatypes.RECTYPE mapping',env) = 
d473 4
a476 4
                 val domain = Datatypes.Mapping.domain mapping
                 val range = Datatypes.Mapping.range mapping
                 val domain' = Datatypes.Mapping.domain mapping'
                 val range' = Datatypes.Mapping.range mapping'
@


1.19
log
@Anel's last changes
@
text
@d4 3
a67 1
require "../main/info";
d71 4
a74 5
structure Lists : LISTS
structure Types : TYPES
structure Integer : INTEGER
structure Debugger_Types : DEBUGGER_TYPES
structure Info : INFO
d76 2
a77 2
sharing Types.Datatypes = Debugger_Types.Datatypes
) : DEBUGGER_TYPE_UTILITIES =
d84 1
a84 1
    structure Info = Info
@


1.18
log
@Changed to error message to a better one
@
text
@d4 3
d92 1
a92 1
      | slim_down_a_type(Datatypes.META_OVERLOADED(ref ty)) = slim_down_a_type ty
d126 1
a126 1
      | walk'(assoc,Datatypes.META_OVERLOADED (ref ty),f) = walk'(assoc,ty,f)
d176 2
a177 2
                  | eq(Datatypes.META_OVERLOADED (ref ty), arg') = eq(ty,arg')
                  | eq(arg',Datatypes.META_OVERLOADED (ref ty)) = eq(arg',ty)
d230 1
a230 1
              | make_recipe'(Datatypes.META_OVERLOADED (ref ty)) = (debug "meta-overloaded"; 
d294 1
a294 1
          | apply_recipe'(x,Datatypes.META_OVERLOADED (ref ty)) = apply_recipe' (x,ty)
d344 1
a344 1
      | is_type_polymorphic (Datatypes.META_OVERLOADED(ref ty)) = is_type_polymorphic ty
d423 1
a423 1
          | match_types'(Datatypes.META_OVERLOADED(ref ty),arg2,env) = 
d425 1
a425 1
          | match_types'(arg1,Datatypes.META_OVERLOADED(ref ty),env) = 
d504 1
a504 1
          | substitute_for_meta(x,y,Datatypes.META_OVERLOADED(ref ty)) = substitute_for_meta(x,y,ty)
@


1.17
log
@Added some debugging messages
@
text
@d4 3
d521 1
a521 1
                (implode ["Unexpected Input type to have a different type (probably due to tail-call optimisation)\n",
@


1.16
log
@Removed "Can't generate debugging information" warning
@
text
@d4 3
d82 1
d282 4
a285 2
          | apply_recipe' (Debugger_Types.Error,_) = raise RecipeApplicationProblem "Error found"
          | apply_recipe' (_,ty as Datatypes.NULLTYPE) = raise RecipeApplicationProblem "Nulltype found"
d293 2
a294 1
                | select (n,[]) = raise RecipeApplicationProblem "Nil found before count is zero"
d316 2
a317 1
              fun select(_,[]) = raise RecipeApplicationProblem "Value too big in constype"
d330 1
a330 1
            ("Did not match any of the cases" ^ Debugger_Types.print_backend_annotation recipe)
@


1.15
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d270 1
a270 1
             (Info.error options (Info.WARNING, Info.Location.UNKNOWN, "Can't generate debugging information for " ^ name);
@


1.14
log
@Changed Error structure to Info
@
text
@d4 3
d98 1
a98 1
      | get_arg_and_res_types arg = (debug ("Not a function type " ^ Types.print_type arg ^ "\n");
d356 2
a357 2
            val _ = debug(fn _ => Types.print_type(x) ^ "\n")
            val _ = debug(fn _ => Types.print_type(y) ^ "\n")
d507 2
a508 2
                          "  Input:    ", Types.print_type (input),
                          "\n  Expected: ", Types.print_type (argument_type),"\n\n"])
d511 1
a511 1
          then (debug (fn _ => "Type is polymorphic\n" ^ Types.print_type(result) ^ "\n");
d515 2
a516 2
                    "   Input: ", Types.print_type (input),
                    "\n  Expected: ", Types.print_type (argument_type)]))
@


1.13
log
@Changed the format of the error message
@
text
@d4 3
d49 1
a49 1
require "../main/error";
d57 1
a57 1
structure Error : ERROR
d67 1
d139 1
a139 1
    fun generate_recipe(ty,recipe_for,name,warning_issued) =
d263 1
a263 2
             (Error.report
              (Error.ERROR (Error.WARNING, Error.Location.UNKNOWN, "Can't generate debugging information for " ^ name));
@


1.12
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d501 2
a502 2
                          "   Input: ", Types.print_type (input),
                          "\n  Expected: ", Types.print_type (argument_type)])
@


1.11
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d160 2
a161 2
                  | eq(Datatypes.CONSTYPE(args,Datatypes.TYNAME(n,_,_,_,_)),
                       Datatypes.CONSTYPE(args',Datatypes.TYNAME(m,_,_,_,_))) =
d335 2
a336 1
    exception InValidMatch
d410 3
a412 3
                   raise InValidMatch))
          | match_types'(Datatypes.CONSTYPE(args1,Datatypes.TYNAME(tyname1,_,_,_,_)),
                        Datatypes.CONSTYPE(args2,Datatypes.TYNAME(tyname2,_,_,_,_)),env) =
d430 1
a430 1
                   raise InValidMatch))
d462 1
a462 1
                       raise InValidMatch)
d468 1
a468 1
                                     raise InValidMatch)
d492 8
d501 9
a509 16
        (let
           val result = 
             do_subs(match_types(input,argument_type,[]),ty)
             handle InValidMatch => 
               (Error.report
                (Error.ERROR (Error.RECOVERABLE, Error.Location.UNKNOWN,
                              implode ["Unexpected Input type to a function (probably due to tail-call optimisation)\n\
                                       \  Input: ", Types.print_type (input),
                                       "\n  Expected: ", Types.print_type (argument_type)]));
                raise InValidMatch)
        in
          if is_type_polymorphic (#1(get_arg_and_res_types result))
            then (debug (fn _ => "Type is polymorphic\n" ^ Types.print_type(result) ^ "\n");
                  raise InValidMatch)
          else result
        end)
a510 1

@


1.10
log
@Installed central error reporting mechanism.
@
text
@d4 3
d222 4
a225 3
                  Debugger_Types.MakeRecord(Lists.zip 
                                            (map (fn Datatypes.Ident.LAB x => Datatypes.Ident.Symbol.symbol_name x) domain,
                                             map make_recipe range))
@


1.9
log
@Tidied up the wrong-type-found message
@
text
@d4 3
d37 1
d45 1
d249 2
a250 1
             (output(std_out,"*** Warning : Can't generate debugging information for " ^ name ^ "\n");
d489 6
a494 5
               (output(std_out,"Unexpected Input type to a function\n" ^
                       "Input: " ^ Types.print_type(input) ^
                       "\nExpected: " ^ Types.print_type(argument_type) ^ 
                       "\nProbably due to tail-call optimisation\n\n");
               raise InValidMatch)
@


1.8
log
@Added details about leafness to the debug information
@
text
@d4 3
d485 1
a485 1
                       "Expected: " ^ Types.print_type(argument_type) ^ 
@


1.7
log
@Various improvements
@
text
@d4 3
d480 4
a483 4
               (output(std_out,"Input type found to be \n" ^
                       Types.print_type(input) ^
                       "\nought to be\n" ^
                       Types.print_type(argument_type) ^ "\nProbably due to tail-call optimisation\n\n");
a495 6






@


1.6
log
@New sharing constraints after lower level changes
@
text
@d4 3
d47 1
a47 1
    fun debug(x) = (* output(std_out,x ^ "\n") *) ()
d474 8
a481 1
           val result = do_subs(match_types(input,argument_type,[]),ty)
d483 5
a487 11
           if is_type_polymorphic result
             then (debug (fn _ => "Type is polymorphic\n");
                   raise InValidMatch)
           else result
        end 
      handle InValidMatch => 
        (output(std_out,"Input type found to be \n" ^
                Types.print_type(input) ^
                "\nought to be\n" ^
                Types.print_type(argument_type) ^ "\nProbably due to tail-call optimisation\n\n");
         raise InValidMatch))
@


1.5
log
@Handles the propogation of types better
@
text
@d4 3
@


1.4
log
@Periodical checking in - many improvements
@
text
@d4 3
d125 2
a126 1
                  | eq(Datatypes.METATYVAR(ref(_,t),_,_),arg' as Datatypes.METATYVAR(ref(n,Datatypes.NULLTYPE),_,_)) = eq(t,arg')
d131 2
a132 1
                  | eq(Datatypes.TYVAR (_,Datatypes.Ident.TYVAR (sym,_,_)),Datatypes.TYVAR (_,Datatypes.Ident.TYVAR (sym',_,_))) = 
d237 51
a287 32
    fun apply_recipe (Debugger_Types.Nop,x) = x
      | apply_recipe (Debugger_Types.Error,_) = raise RecipeApplicationProblem "Error found"
      | apply_recipe (_,ty as Datatypes.NULLTYPE) = raise RecipeApplicationProblem "Nulltype found"
      | apply_recipe (x,Datatypes.METATYVAR(ref(_,ty),_,_)) = apply_recipe (x,ty)
      | apply_recipe (x,Datatypes.METARECTYPE(ref(_,_,ty,_,_))) = apply_recipe (x,ty)
      | apply_recipe(x,Datatypes.META_OVERLOADED (ref ty)) = apply_recipe (x,ty)
      | apply_recipe (Debugger_Types.Select(arg,recipe'),Datatypes.RECTYPE mapping) =
        let
          val range = Datatypes.Mapping.range mapping
          fun select (0,h::t) = h
            | select (n,[]) = raise RecipeApplicationProblem "Nil found before count is zero"
            | select (n,h::t) = select(n-1,t)
        in
          apply_recipe(recipe',select(arg,range))
        end
      | apply_recipe(Debugger_Types.MakeRecord args,ty) =
        let
          fun make_mapping ([],mapping) = mapping
            | make_mapping ((label,recipe)::rest,mapping) = 
              make_mapping(rest,
                           Datatypes.Mapping.add((Datatypes.Ident.LAB
                                                        (Datatypes.Ident.Symbol.find_symbol label),
                                                        apply_recipe(recipe,ty)),
                           mapping,
                           Datatypes.Ident.lab_order))
        in
          Datatypes.RECTYPE(make_mapping (args,Datatypes.Mapping.empty_map))
        end
      | apply_recipe(Debugger_Types.MakeConsType(args,ty_name),ty) =
        Datatypes.CONSTYPE(map (fn x => apply_recipe(x,ty)) args,ty_name)
      | apply_recipe (recipe,_) = raise RecipeApplicationProblem 
        ("Did not match any of the cases" ^ Debugger_Types.print_backend_annotation recipe)
d314 130
d445 1
a445 1
          | substitute_for_meta(Datatypes.METATYVAR(arg as ref(_,Datatypes.NULLTYPE),_,_),result,
d464 17
a480 63
        fun match_types(arg1,Datatypes.METATYVAR(name as ref(_,Datatypes.NULLTYPE),_,_),env) =
            ((name,arg1)::env,arg1)
          | match_types(Datatypes.METATYVAR(ref(_,ty),_,_),arg2,env) = match_types(ty,arg2,env)
          | match_types(arg1,Datatypes.METATYVAR(ref(_,ty),_,_),env) = match_types(arg1,ty,env)
          | match_types(Datatypes.META_OVERLOADED(ref ty),arg2,env) = match_types(ty,arg2,env)
          | match_types(arg1,Datatypes.META_OVERLOADED(ref ty),env) = match_types(arg1,ty,env)
          | match_types(Datatypes.METARECTYPE(ref(_,_,ty,_,_)),arg2,env) = match_types(ty,arg2,env)
          | match_types(arg1,Datatypes.METARECTYPE(ref(_,_,ty,_,_)),env) = match_types(arg1,ty,env)
          | match_types(Datatypes.NULLTYPE,Datatypes.NULLTYPE,env) = 
            (env,Datatypes.NULLTYPE)
          | match_types(arg1 as Datatypes.DEBRUIJN x,Datatypes.DEBRUIJN y,env) = 
            if x=y
              then (env,arg1)
            else raise InValidMatch
          | match_types(Datatypes.CONSTYPE(args1,tyname1),Datatypes.CONSTYPE(args2,tyname2),env) =
            if tyname1 = tyname2 andalso Lists.length args1 = Lists.length args2
              then
                let 
                  val (env'',arg'') = 
                    Lists.reducer (fn ((arg1,arg2),(env,sofar)) =>
                                   let
                                     val (env',arg') = match_types(arg1,arg2,env)
                                   in
                                     (env',arg'::sofar)
                                   end)
                    (Lists.zip(args1,args2),(env,[]))
                in
                  (env'',Datatypes.CONSTYPE(arg'',tyname1))
                end
            else raise InValidMatch
          | match_types(Datatypes.FUNTYPE(from,to), Datatypes.FUNTYPE(from',to'),env) =
            let
              val (env',from'') = match_types(from,from',env)
              val (env'',to'') = match_types(to,to',env')
            in
              (env'',Datatypes.FUNTYPE(from'',to''))
            end
          | match_types(Datatypes.RECTYPE mapping,Datatypes.RECTYPE mapping',env) = 
               let
                 val domain = Datatypes.Mapping.domain mapping
                 val range = Datatypes.Mapping.range mapping
                 val domain' = Datatypes.Mapping.domain mapping'
                 val range' = Datatypes.Mapping.range mapping'
               in
                 if domain = domain'
                   then
                     let
                       val (env',new_map) =
                         Lists.reducer (fn ((name,(arg1,arg2)),(env,sofar)) =>
                                        let
                                          val (env',arg') = match_types(arg1,arg2,env)
                                        in
                                          (env',Datatypes.Mapping.add((name,arg'),sofar,Datatypes.Ident.lab_order))
                                        end)
                         (Lists.zip(domain,Lists.zip(range,range')),(env,Datatypes.Mapping.empty_map))
                     in
                       (env',Datatypes.RECTYPE new_map)
                     end
                 else raise InValidMatch
               end
          | match_types(_,_,_) = raise InValidMatch
      in
        ty
d482 2
d486 6
@


1.3
log
@More work on the debugger
@
text
@d4 3
d36 2
d77 1
a77 1
      | walk'(assoc,Datatypes.TYVAR _,_) = raise TyVarFound
a209 4
                
            (* val _ = output(std_out,"Function type: " ^ Types.print_type ty ^ "\n")
               val _ = output(std_out,"Value type   : " ^ Types.print_type recipe_for ^ "\n") *)
              
d211 4
a214 1
                           of Datatypes.NULLTYPE => raise CantGenerateRecipe
a216 2
            (* val _ = output(std_out,"Recipe       : " ^ Debugger_Types.print_backend_annotation result ^ "\n") *)
              
d220 1
a220 1
        handle FailGeneration => (Debugger_Types.Error,warning_issued)
@


1.2
log
@Added utilites for the polymorphic deduction code
@
text
@d4 3
d31 1
d53 2
a54 1
    exception NotAFunctionType
d58 1
a58 1
                                   raise NotAFunctionType)
d101 2
a102 2
    fun generate_recipe(ty,recipe_for) =
      case recipe_for of
d104 1
a104 1
                               Debugger_Types.Nop)
a109 2
            exception CantGenerateRecipe

d114 2
a115 1
                fun eq(Datatypes.METATYVAR(ref(n,Datatypes.NULLTYPE),_,_),Datatypes.METATYVAR(ref(m,Datatypes.NULLTYPE),_,_)) = m=n
d127 2
a128 1
                  | eq(Datatypes.CONSTYPE(args,Datatypes.TYNAME(n,_,_,_,_)),Datatypes.CONSTYPE(args',Datatypes.TYNAME(m,_,_,_,_))) =
d169 1
a169 1
                else (debug "nulltype not found" ; Debugger_Types.Nop)
d181 1
a181 1
                  else (debug "tyvar not found"; Debugger_Types.Nop)
d210 1
a210 1
                           of Datatypes.NULLTYPE => Debugger_Types.Nop
d216 11
a226 4
            result
          end
        handle NotAFunctionType => (debug "Handling notafunctiontype"; Debugger_Types.Error)
             | CantGenerateRecipe => (debug "Handling CantGenerateRecipe" ; Debugger_Types.Error)
d281 2
a282 1
    fun check_type (x,_) = x
d284 88
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log: $
d13 1
d17 1
d19 4
a22 1
structure Debugger_Types : DEBUGGER_TYPES) : DEBUGGER_TYPE_UTILITIES =
d27 1
a27 2
    structure Types = Debugger_Types.Types
    structure Datatypes = Types.Datatypes
d149 1
a149 1
                  handle Assoc => (false,Debugger_Types.Nop)
d184 1
d187 3
a189 1
                  Debugger_Types.MakeRecord(map make_recipe range)
d205 1
a205 1
                           of Types.Datatypes.NULLTYPE => Debugger_Types.Nop
d213 60
a272 4
        handle NotAFunctionType => (debug "Handling notafunctiontype"; Debugger_Types.Nop)
             | CantGenerateRecipe => (debug "Handling CantGenerateRecipe" ; Debugger_Types.Nop)
                 
  end
@
