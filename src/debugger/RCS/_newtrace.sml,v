head	1.45;
access;
symbols
	MLW_daveb_inline_1_4_99:1.45.1
	MLWorks_21c0_1999_03_25:1.45
	MLWorks_20c1_1998_08_20:1.45
	MLWorks_20c0_1998_08_04:1.45
	MLWorks_20b2c2_1998_06_19:1.45
	MLWorks_20b2_Windows_1998_06_12:1.45
	MLWorks_20b1c1_1998_05_07:1.45
	MLWorks_20b0_1998_04_07:1.45
	MLWorks_20b0_1998_03_20:1.45
	MLWorks_20m2_1998_02_16:1.44
	MLWorks_20m1_1997_10_23:1.44
	MLWorks_11r1:1.41.5.1.1.1.1
	MLWorks_workspace_97:1.43.2
	MLWorks_dt_wizard:1.43.1
	MLWorks_11c0_1997_09_09:1.41.5.1.1.1
	MLWorks_10r3:1.41.5.1.3
	MLWorks_10r2_551:1.41.5.1.2
	MLWorks_11:1.41.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.41.5.1
	MLWorks_20m0_1997_06_20:1.43
	MLWorks_1_0_r2c2_1997_06_14:1.41.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.41.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.41.5
	MLWorks_BugFix_1997_04_24:1.41
	MLWorks_1_0_r2_Win32_1997_04_11:1.41
	MLWorks_1_0_r2_Unix_1997_04_04:1.41
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.41.3.1.1
	MLWorks_gui_1996_12_18:1.41.4
	MLWorks_1_0_Win32_1996_12_17:1.41.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.41.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.41.1.1
	MLWorks_1_0_Irix_1996_11_28:1.41.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.41.2
	MLWorks_1_0_Unix_1996_11_14:1.41.1
	MLWorks_Open_Beta2_1996_10_11:1.39.3
	MLWorks_License_dev:1.39.2
	MLWorks_1_open_beta_1996_09_13:1.39.1
	MLWorks_Open_Beta_1996_08_22:1.39
	MLWorks_Beta_1996_07_02:1.38
	MLWorks_Beta_1996_06_07:1.36
	MLWorks_Beta_1996_06_06:1.36
	MLWorks_Beta_1996_06_05:1.36
	MLWorks_Beta_1996_06_03:1.36
	MLWorks_Beta_1996_05_31:1.36
	MLWorks_Beta_1996_05_30:1.36
	ML_beta_release_12/08/94:1.10
	ML_beta_release_03/08/94:1.10
	ML_revised_beta_release_25/05/94:1.8
	ML_final_beta_release_02/03/94:1.7
	mlworks-28-01-1994:1.6
	Release:1.4
	mlworks-beta-01-09-1993:1.4;
locks; strict;
comment	@ * @;


1.45
date	98.03.20.16.13.28;	author jont;	state Exp;
branches
	1.45.1.1;
next	1.44;

1.44
date	97.09.18.14.38.48;	author brucem;	state Exp;
branches;
next	1.43;

1.43
date	97.05.16.17.24.09;	author jont;	state Exp;
branches
	1.43.1.1
	1.43.2.1;
next	1.42;

1.42
date	97.05.02.17.00.47;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	96.11.05.12.56.46;	author stephenb;	state Exp;
branches
	1.41.1.1
	1.41.2.1
	1.41.3.1
	1.41.4.1
	1.41.5.1;
next	1.40;

1.40
date	96.10.31.14.27.34;	author io;	state Exp;
branches;
next	1.39;

1.39
date	96.08.05.17.38.16;	author andreww;	state Exp;
branches
	1.39.1.1
	1.39.2.1
	1.39.3.1;
next	1.38;

1.38
date	96.06.27.11.47.54;	author stephenb;	state Exp;
branches;
next	1.37;

1.37
date	96.06.21.09.43.30;	author stephenb;	state Exp;
branches;
next	1.36;

1.36
date	96.05.16.13.01.12;	author stephenb;	state Exp;
branches;
next	1.35;

1.35
date	96.05.01.10.02.38;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	96.03.20.14.04.18;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	96.03.18.12.26.29;	author stephenb;	state Exp;
branches;
next	1.32;

1.32
date	96.03.15.12.06.25;	author stephenb;	state Exp;
branches;
next	1.31;

1.31
date	96.02.26.13.01.49;	author stephenb;	state Exp;
branches;
next	1.30;

1.30
date	96.02.23.17.57.44;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	96.02.22.14.15.38;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	96.02.19.15.07.01;	author stephenb;	state Exp;
branches;
next	1.27;

1.27
date	95.12.27.13.27.33;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	95.12.07.17.49.11;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	95.10.26.10.29.27;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	95.10.24.15.12.19;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	95.10.24.12.51.22;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	95.10.18.13.10.42;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	95.10.18.10.57.10;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	95.10.03.15.35.54;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	95.06.01.15.19.18;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	95.05.23.16.31.52;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	95.05.11.16.13.59;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	95.04.28.13.59.15;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	95.04.25.14.23.14;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	95.04.21.14.24.14;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	95.04.18.11.05.17;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	95.03.08.10.59.57;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	95.03.01.16.22.22;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	94.06.23.11.43.19;	author nickh;	state Exp;
branches;
next	1.9;

1.9
date	94.06.09.15.49.29;	author nickh;	state Exp;
branches;
next	1.8;

1.8
date	94.03.15.12.09.30;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	94.02.21.17.51.21;	author nosa;	state Exp;
branches;
next	1.6;

1.6
date	93.12.09.17.12.36;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.09.03.10.45.00;	author nosa;	state Exp;
branches;
next	1.4;

1.4
date	93.08.19.11.39.21;	author matthew;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	93.08.03.12.13.45;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.06.02.14.12.54;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.05.07.16.11.30;	author matthew;	state Exp;
branches;
next	;

1.4.1.1
date	93.08.19.11.39.21;	author jont;	state Exp;
branches;
next	;

1.39.1.1
date	96.09.13.11.11.14;	author hope;	state Exp;
branches;
next	;

1.39.2.1
date	96.10.07.16.02.00;	author hope;	state Exp;
branches;
next	;

1.39.3.1
date	96.10.17.11.20.15;	author hope;	state Exp;
branches;
next	;

1.41.1.1
date	96.11.14.12.43.50;	author hope;	state Exp;
branches
	1.41.1.1.1.1;
next	;

1.41.1.1.1.1
date	96.11.28.14.55.45;	author hope;	state Exp;
branches;
next	;

1.41.2.1
date	96.11.22.18.04.16;	author hope;	state Exp;
branches;
next	;

1.41.3.1
date	96.12.17.17.43.13;	author hope;	state Exp;
branches
	1.41.3.1.1.1;
next	;

1.41.3.1.1.1
date	97.02.24.11.31.57;	author hope;	state Exp;
branches;
next	;

1.41.4.1
date	96.12.18.09.37.11;	author hope;	state Exp;
branches;
next	;

1.41.5.1
date	97.05.12.10.29.21;	author hope;	state Exp;
branches
	1.41.5.1.1.1
	1.41.5.1.2.1
	1.41.5.1.3.1;
next	;

1.41.5.1.1.1
date	97.07.28.18.15.14;	author daveb;	state Exp;
branches
	1.41.5.1.1.1.1.1;
next	;

1.41.5.1.1.1.1.1
date	97.10.07.11.40.18;	author jkbrook;	state Exp;
branches;
next	;

1.41.5.1.2.1
date	97.09.08.17.08.42;	author daveb;	state Exp;
branches;
next	;

1.41.5.1.3.1
date	97.09.09.14.03.49;	author daveb;	state Exp;
branches;
next	;

1.43.1.1
date	97.09.10.19.18.21;	author brucem;	state Exp;
branches;
next	;

1.43.2.1
date	97.09.11.20.49.18;	author daveb;	state Exp;
branches;
next	;

1.45.1.1
date	99.04.01.17.53.11;	author daveb;	state Exp;
branches;
next	;


desc
@Tracing utilities
@


1.45
log
@[Bug #30090]
Remove MLWorks.IO in favour of print
@
text
@(*  Copyright (C) 1993 Harlequin Ltd
 *
 * (Low level) SML code that implements tracing and breakpointing.
 * Since it does both, "Trace" is arguably not a good name for the module,
 * but that is what it was called so we live with it.
 *
 * I assume that the file is called _newtrace.sml because it replaced
 * a _trace.sml - stephenb
 *
 * Revision Log
 * ------------
 *
 *  $Log: _newtrace.sml,v $
 * Revision 1.44  1997/09/18  14:38:48  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.43  1997/05/16  17:24:09  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.42  1997/05/02  17:00:47  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.41  1996/11/05  12:56:46  stephenb
 * [Bug #1441]
 * gather_recipes: remove the 4* stuff now that offsets are byte
 * offsets rather than word offsets.
 *
 * Revision 1.40  1996/10/31  14:27:34  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.39  1996/08/05  17:38:16  andreww
 * [Bug #1521]
 * Porpagating changes to typechecker/_types.sml
 *
 * Revision 1.38  1996/06/27  11:47:54  stephenb
 * Add some comments documenting the tracing code that Matthew wrote.
 * The code comment ratio is now moving in the right direction, but
 * there is still a lot of undocumented code here.
 *
 * Revision 1.37  1996/06/21  09:43:30  stephenb
 * Fix #1408.
 * Modified break_list and trace_list to they remove any existing intercepts
 * before installing the new ones.  This cures (in an inelegant way) the problem
 * of intercepts hanging around.
 *
 * Revision 1.36  1996/05/16  13:01:12  stephenb
 * Update wrt MLWorks.Debugger -> MLWorks.Internal.Debugger change.
 *
 * Revision 1.35  1996/05/01  10:02:38  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.34  1996/03/20  14:04:18  matthew
 * Changes for value polymorphism
 *
 * Revision 1.33  1996/03/18  12:26:29  stephenb
 * Fix bug #1148 -- quitting the debugger clears the breakpoints.
 * Fixed by adding some exception handlers to breakpoint_replacement
 * to ensure that the breakpoint is reinstalled even if an exception is thrown.
 *
 * Revision 1.32  1996/03/15  12:06:25  stephenb
 * Fix the long standing (i.e. since before I started working on the debugger)
 * bug that if you step in the debugger and keep stepping until you return
 * to the top level (i.e. the debugger is now out of the loop) all functions
 * still have step code enabled i.e. if you run anything it will immediately
 * call the debugger!
 *
 * Revision 1.31  1996/02/26  13:01:49  stephenb
 * Comment the recently changed step/break/next commands.
 * Also remove some redundant tests (famous last words!).
 *
 * Revision 1.30  1996/02/23  17:57:44  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.29  1996/02/22  14:15:38  jont
 * Replacing Map with NewMap
 *
 * Revision 1.28  1996/02/19  15:07:01  stephenb
 * Add "next" which makes it possible for the debugger to step over a
 * function call.  In order to add this, had to change the way stepping
 * and breakpointing is implemented.
 *
 * Revision 1.27  1995/12/27  13:27:33  jont
 * Removing Option in favour of MLWorks.Option
 *
 * Revision 1.26  1995/12/07  17:49:11  jont
 * Add more structure to the breakpoint table to allow
 * multiple skipping of breakpoints, and breakpoint hit counting
 *
 * Revision 1.25  1995/10/26  10:29:27  matthew
 * Adding untrace_all
 *
Revision 1.24  1995/10/24  15:12:19  daveb
Step function now skips setup functions.

Revision 1.23  1995/10/24  12:51:22  daveb
Removed get_stepping (it duplicated step_state).

Revision 1.22  1995/10/18  13:10:42  matthew
Adding type inference for returned values

Revision 1.21  1995/10/18  10:57:10  matthew
Merging trace_full and simple_trace functionality

Revision 1.20  1995/10/03  15:35:54  daveb
Added get_stepping.

Revision 1.19  1995/06/01  15:19:18  matthew
Adding trace_all function

Revision 1.18  1995/05/23  16:31:52  daveb
Split user_options into tool-specific and context-specific parts.

Revision 1.17  1995/05/11  16:13:59  matthew
Changing Scheme.generalises

Revision 1.16  1995/04/28  13:59:15  matthew
Changing uses of cast (again)

Revision 1.15  1995/04/25  14:23:14  matthew
Adding newline after trace output.

Revision 1.14  1995/04/21  14:24:14  matthew
Switching off debugger messages

Revision 1.13  1995/04/18  11:05:17  matthew
New step and breakpoint functionality

Revision 1.12  1995/03/08  10:59:57  matthew
Adding StackInterface structure

Revision 1.11  1995/03/01  16:22:22  matthew
Adding breakpoint function
Perhaps also working on type reconstruction

Revision 1.10  1994/06/23  11:43:19  nickh
Change bogus code test.

Revision 1.9  1994/06/09  15:49:29  nickh
New runtime directory structure.

Revision 1.8  1994/03/15  12:09:30  matthew
Added call to message_fn in untrace
;

Revision 1.7  1994/02/21  17:51:21  nosa
Boolean indicator for Monomorphic debugger decapsulation.

Revision 1.6  1993/12/09  17:12:36  matthew
 Added function replacement functions

Revision 1.5  1993/09/03  10:45:00  nosa
Instances in DEBRUIJNs for polymorphic debugger.

Revision 1.4  1993/08/19  11:39:21  matthew
Added message_fn parameter.
Report problems by calling message_fn rather than raising exceptions

Revision 1.3  1993/08/03  12:13:45  matthew
Changed format of tracing messages.

Revision 1.2  1993/06/02  14:12:54  matthew
Added untrace function

Revision 1.1  1993/05/07  16:11:30  matthew
Initial revision

 *
 *)

require "../basis/list";
require "../typechecker/types";
require "../typechecker/scheme";
require "../main/user_options";
require "../rts/gen/tags";
require "../interpreter/incremental";
require "../interpreter/shell_types";
require "../main/stack_interface";
require "debugger_utilities";
require "value_printer";

require "newtrace";

functor Trace (
  structure List : LIST
  structure Types : TYPES
  structure Scheme : SCHEME
  structure UserOptions : USER_OPTIONS
  structure Tags : TAGS
  structure Incremental : INCREMENTAL
  structure ShellTypes : SHELL_TYPES
  structure ValuePrinter : VALUE_PRINTER
  structure StackInterface : STACK_INTERFACE
  structure DebuggerUtilities : DEBUGGER_UTILITIES

  sharing ValuePrinter.Options = UserOptions.Options
  sharing Types.Datatypes = Scheme.Datatypes

  sharing type Incremental.Context = ShellTypes.Context
  sharing type UserOptions.Options.options = ShellTypes.Options.options
  sharing type Types.Options.options = UserOptions.Options.options
  sharing type UserOptions.user_tool_options = ShellTypes.user_options
  sharing type ValuePrinter.Type = Types.Datatypes.Type =
               DebuggerUtilities.Debugger_Types.Type
  sharing type ValuePrinter.DebugInformation =
               Incremental.InterMake.Compiler.DebugInformation =
               DebuggerUtilities.Debugger_Types.information
) : TRACE =
  struct
    structure Options = UserOptions.Options
    structure DebuggerTypes = DebuggerUtilities.Debugger_Types
    structure Datatypes = Types.Datatypes
    structure Value = MLWorks.Internal.Value
    structure Trace = MLWorks.Internal.Trace;
    structure Frame = Value.Frame
    structure Debugger = MLWorks.Internal.Debugger
    structure NewMap = Datatypes.NewMap

    type Type = Datatypes.Type
    type Context = Incremental.Context
    type UserOptions = UserOptions.user_tool_options

    fun print_entry (name,arg) = print (name ^ " " ^ arg ^ "\n")

    val do_debug = false
    fun debug s = if do_debug then print (s ^ "\n") else ()
    fun fdebug f = if do_debug then print (f() ^ "\n") else ()

    exception Value of string

    (* Functions from the runtime system *)
    local
      val env = MLWorks.Internal.Runtime.environment
    in
      (* apply_all applies an ML function to all code objects compiled with tracing on *)
      val apply_all : (Value.T -> unit) -> unit = env "trace ml apply all"
      val trace_code_intercept : Value.T * (Frame.frame -> unit) -> unit = env "trace code intercept"
      val trace_code_replace : Value.T * (Frame.frame -> unit) -> unit = env "trace code replace"
      val trace_set_code_loader_function : (Value.T -> unit) -> unit = env "trace set code loader function"
      val trace_unset_code_loader_function : (unit -> unit) -> unit = env "trace unset code loader function"
    end

    (* Hack about with a function string *)
    (* from ml_debugger *)
    fun get_name_and_location code_name =
      let
        fun aux1(#"[" ::l,acc) = (acc,l)
          | aux1(c::l,acc) = aux1(l,c::acc)
          | aux1([],acc) = (acc,[])
        fun aux2([#"]" ],acc) = acc
          | aux2(#"]" ::l,acc) = acc
          | aux2(c::l,acc) = aux2(l,c::acc)
          | aux2([],acc) = acc
        val (namechars,rest) = aux1(explode code_name,[])
        val locchars = aux2 (rest,[])
      in
        (implode (rev namechars),implode (rev locchars))
      end

    (* Simple function for removing the location information from a function name string *)
    fun strip_location s =
      let
        val len = size s
        fun strip n =
          if n = len then s
          else
            if MLWorks.String.ordof (s,n) = ord #"["
              then substring (* could raise Substring *) (s,0,n)
            else strip (n+1)
      in
        strip 0
      end

    fun get_code_string value =
      if
        Value.primary value = Tags.POINTER andalso
        #1 (Value.header value) = Tags.BACKPTR
        then
          Value.code_name value
      else
          raise Value "code_name: not a code item"

    fun get_code_name f =
      let
        val code_name = get_code_string f
        val (name,loc) = get_name_and_location code_name
      in
        name
      end

    (* What about META types? *)
    fun funarg (Datatypes.FUNTYPE (t,_)) = t
      | funarg _ = Datatypes.NULLTYPE

    fun funres (Datatypes.FUNTYPE (_,t)) = t
      | funres _ = Datatypes.NULLTYPE

    (* type reconstruction *)

    exception TypeReconstructionFailed of string

    fun assoc (a,[]) = NONE
      | assoc (a,(a',b)::rest) =
        if a = a' then SOME b
        else assoc (a,rest)

    fun infer_types (ty,[]) = ty
      | infer_types (ty,recipe::rest) =
        infer_types (DebuggerUtilities.apply_recipe (recipe,ty),rest)

    (* This scans down the stack and collects up recipes *)
    fun gather_recipes (frame,acc,debug_info) =
      let
        val (another,next,offset) = Frame.frame_next frame
      in
        if offset <> 0 (* It's an ML frame *)
          then
            let
              val frame_name = StackInterface.frame_name next
            in
              case DebuggerTypes.lookup_debug_info (debug_info,frame_name) of
                SOME (DebuggerTypes.FUNINFO {ty,annotations,...}) =>
                  let
                    val argty = funarg ty
                    val recipe =
                      case assoc (offset,annotations) of
                        SOME recipe => recipe
                      | _ => DebuggerTypes.NOP
                  in
                    if DebuggerUtilities.is_type_polymorphic argty
                      then
                        if another then gather_recipes (next,recipe::acc,debug_info)
                        else raise TypeReconstructionFailed "No more frames"
                    else
                      (argty,recipe::acc)
                  end
              | _ => gather_recipes (next,acc,debug_info)
            end
        else
            gather_recipes (next,acc,debug_info)
      end



    (* Return a reconstructed type *)
    fun reconstruct_type (frame,ty,debug_info) =
      if DebuggerUtilities.is_type_polymorphic ty
        then
          (infer_types (gather_recipes (frame,[],debug_info)))
          handle DebuggerUtilities.ApplyRecipe s =>
            (debug ("Recipe Application failed: " ^ s);
             ty)
               | TypeReconstructionFailed s =>
                   (debug ("Type Reconstruction Failed: " ^ s);
                    ty)
      else ty



    fun get_fun_types (f,debug_info) =
      let
        val name = get_code_string f
      in
        case DebuggerTypes.lookup_debug_info (debug_info,name)  of
          SOME (DebuggerTypes.FUNINFO {ty = Datatypes.FUNTYPE (dom,ran),...}) =>
            (dom,ran)
        | _ => (Datatypes.NULLTYPE,Datatypes.NULLTYPE)
      end



    (* This is kind of hacky, but if it doesn't work then nothing
     * disastrous happens.  Seems to be OK mind
     *)
    local
      open Datatypes
    in
      fun tyvars_of (ty,acc) =
        case ty of
          METATYVAR (ref (_,NULLTYPE,_),_,_) => ty :: acc
        | METATYVAR (ref (_,ty',_),_,_) => tyvars_of (ty',acc)
        | META_OVERLOADED (ref ty',_,_,_) => tyvars_of (ty',acc)
        | TYVAR _ => ty :: acc
        | METARECTYPE (ref (_,_,ty',_,_)) => tyvars_of (ty',acc)
        | RECTYPE labtys =>
          NewMap.fold (fn (acc, _, ty) => tyvars_of (ty,acc)) (acc,labtys)
        | FUNTYPE (ty1,ty2) => tyvars_of (ty2,tyvars_of (ty1,acc))
        | CONSTYPE (tylist,_) =>
          List.foldl tyvars_of acc tylist
        | DEBRUIJN _ => acc
        | NULLTYPE => acc
    end



    (* Need to replace any (meta)tyvars in the type by debruijns, so that
     * the Scheme functions will work.
     *)

    fun generalize (ty1,ty2) =
      let
        val ty = Datatypes.FUNTYPE (ty1,ty2)
        val tyvars = tyvars_of (ty,[])
      in
        case Scheme.make_scheme (tyvars,(ty,NONE)) of
          Datatypes.SCHEME (i,(Datatypes.FUNTYPE (ty1',ty2'),_)) => (ty1',ty2')
        | _ => (ty1,ty2)
      end



    (* Note that we insist on value polymorphism semantics here,
     * I don't think this matters much.
     * Just affects calls to Scheme.generalises* functions
     *)

    (* spec_type is an instantiation of gen_type *)
    (* try to instantiate ty in the same way *)
    fun instantiate_type (ty,gen_ty,spec_ty) =
      if not (DebuggerUtilities.is_type_polymorphic ty)
        then ty
      else
        (* the difficult bit *)
        let
(*
          val _ = output (std_out,
                          concat ["ty: ",Types.debug_print_type ty,
                                   "\ngen ty: ",Types.debug_print_type gen_ty,
                                   "\nspec ty: ",Types.debug_print_type spec_ty])
*)
          val (ty,gen_ty) = generalize (ty,gen_ty)
          val Options.OPTIONS{compat_options=Options.COMPATOPTIONS
                             {old_definition,...},...} =
            ShellTypes.get_current_options (!ShellTypes.shell_data_ref)
        in
          Scheme.apply_instantiation
            (ty, Scheme.generalises_map old_definition (gen_ty,spec_ty))
          handle Mismatch =>
            (debug ("Instantiation failed");
             ty)
        end



    (* As the name suggets, gets info on a frame.
     * The info is of the form :-
     *
     * (functionName:string, argumentValue:string, argumentType:Datatypes.Type)
     *
     * The functionName can be determined easily from the frame, the
     * argumentValue and argumentType require some type reconstruction.
     *)
    fun get_frame_info frame =
      let
        val shell_data = !ShellTypes.shell_data_ref
        val user_options = ShellTypes.get_user_options shell_data
        val options = ShellTypes.get_current_options shell_data
        val context = ShellTypes.get_current_context shell_data
        val name = StackInterface.frame_name frame
        val debug_info = Incremental.InterMake.current_debug_information ()
        val funinfo = DebuggerTypes.lookup_debug_info (debug_info,name)
        val (arg_string,ranty) =
          case funinfo of
            SOME (DebuggerTypes.FUNINFO {ty,...}) =>
              let
                val arg = StackInterface.frame_arg frame
                val arg_type = funarg ty
                val reconstructed_arg_type = reconstruct_type (frame,arg_type,debug_info)
                val final_type = Types.combine_types (reconstructed_arg_type,arg_type)
                  handle Types.CombineTypes =>
                    (fdebug (fn _ =>
                             concat ["Combine types fails for: ",
                                      name, "\n arg_type: ",
                                      Types.debug_print_type options arg_type,
                                      "\n reconstructed arg type: ",
                                      Types.debug_print_type options
                                      reconstructed_arg_type]);
                    arg_type)
                val ranty = instantiate_type (funres ty,arg_type,final_type)
                val print_options = UserOptions.new_print_options user_options
              in
                (ValuePrinter.stringify_value false (print_options,arg,final_type,debug_info),
                 ranty)
              end
          | _ => ("<Unknown arg>",Datatypes.NULLTYPE)
      in
        (strip_location name,arg_string,ranty)
      end




    (* Wacky tracing *)
    structure Test :
      sig
        val trace : Value.T * (('a -> 'b) * 'a * Frame.frame -> 'b) -> unit
        val replace : Value.T * ('c -> 'd) -> unit
      end =

      struct
        fun trace (cv, new) =
          let
            fun untraced_once f' a =
              (trace_code_intercept (cv, fn _ => trace (cv, new));
               f' a)

            val replacement =
              (fn frame =>
               StackInterface.set_frame_return_value
               (frame,
                Value.cast (new (untraced_once (Value.cast (StackInterface.frame_closure frame)),
                                 Value.cast (StackInterface.frame_arg frame),
                                 frame))))
          in
            trace_code_replace (cv, replacement)
          end

        fun replace (cv, new) =
          let
            val replacement =
              (fn frame =>
               StackInterface.set_frame_return_value
               (frame,
                Value.cast (new (Value.cast (StackInterface.frame_arg frame)))))
          in
            trace_code_replace (cv, replacement)
          end

      end



    (* Indentation *)
    val indent_level = ref 0

    fun outspaces 0 = ()
      | outspaces n = (print"  ";outspaces(n-1))



    (* "always" and "never" are used the trace_full_internal as the default
     * values for the tracing and breakpointing.  "always" is just a function
     * that always returns true, and "never" is one which always returns
     * false.  I've no idea why their type, though identical, is defined
     * twice - stephenb
     *)
    val always = ((Value.cast (fn _ => true)) : Value.T,
                  Datatypes.FUNTYPE (Datatypes.DEBRUIJN (0,false,false,
                                                         NONE),
                                     Types.bool_type))

    val never = ((Value.cast (fn _ => false)) : Value.T,
                  Datatypes.FUNTYPE (Datatypes.DEBRUIJN (0,false,false,NONE),
                                     Types.bool_type))



    (* Error is used to abort out of a trace_full_internal in the case
     * that any errors are detected.  Since all that is done with the
     * exception is to catch it and ignore it, an alternative would be
     * to write the body of trace_full_internal in a more functional
     * style - stephenb
     *)
    exception Error



    fun generalises (ty1,ty2) =
      let val Options.OPTIONS{compat_options=
                              Options.COMPATOPTIONS{old_definition,...},...}
        = ShellTypes.get_current_options (!ShellTypes.shell_data_ref)
      in
      Scheme.generalises old_definition (ty1,ty2)
                   handle Scheme.Mismatch => false
      end

    fun type_eq (ty1,ty2) = Types.type_eq (ty1,ty2,true,true)




    (* trace_full_internal implements conditional tracing and breakpointing.
     * It patches "fun_val" such that a) it displays a trace message whenever
     * "test_val" applied to the arguments returns true and b) breakpoints
     * whenever "break_val" applied to the arguments returns true.
     *
     * For example, using the latest shell interface to this function, then
     * assuming you've defined the ubiquitous factorial function fact you
     * could type :-
     *
     *   Shell.Trace.traceFull ("fact", fn _ => true, fn _ => false);
     *
     * and have it unconditionally trace the factorial function and not
     * breakpoint at all.  Alternately, if you are only interested in
     * tracing the function when the argument is less than 3, you could do
     *
     *   Shell.Trace.traceFull ("fact", fn n => n < 3, fn _ => false);
     *
     * The "entry_only" argument is a bit of a mystery, presumably it
     * controls whether the tracing/breakpointing is only attempted at
     * function entry only.  In the only current use of trace_full_internal
     * it is set to false.
     *
     * It isn't clear to me at the moment how this interacts with the
     * other tracing/breakpointing routines that have been updated
     * to cope with the introduction of the "next" command in the debugger.
     * My guess is that the interaction is not a good one - stephenb.
     *)

    fun trace_full_internal entry_only ((test_val,test_ty), (break_val,break_ty)) fun_val =
      let
        fun message_fn s = print(s ^ "\n")
        val shell_data = !ShellTypes.shell_data_ref
        val user_options = ShellTypes.get_user_options shell_data
        val options = ShellTypes.get_current_options shell_data
        fun do_error s = (message_fn s;raise Error)
      in
        if not (Types.isFunType test_ty)
          then do_error "Test function doesn't have function type"
        else ();
        if not (Types.isFunType break_ty)
          then do_error "Break function doesn't have function type"
        else ();
        let
          fun string_value (value,ty) =
            let
              val print_options = UserOptions.new_print_options user_options
              val debug_info = Incremental.InterMake.current_debug_information ()
            in
              ValuePrinter.stringify_value false (print_options,value,ty,debug_info)
            end
          val debug_info = Incremental.InterMake.current_debug_information ()
          val (fun_dom,_) = get_fun_types (fun_val,debug_info)
          val (test_dom,test_ran) = Types.argres test_ty
          val (break_dom,break_ran) = Types.argres break_ty
          val fun_name = strip_location (get_code_name fun_val)
          val _ =
            (* Tedious correctness checking *)
            (if generalises (test_dom,fun_dom)
               then ()
             else
               do_error
               (concat [fun_name ^ ": Test function domain not compatible with traced function domain:",
                        "\n  test domain: ", Types.debug_print_type options test_dom,
                        "\n  function domain: ", Types.debug_print_type
                                               options fun_dom, "\n"]);
             if type_eq (test_ran,Types.bool_type)
               then ()
             else
               do_error
               (concat [fun_name ^ ": Test function range not boolean",
                        "\n  test range: ", Types.debug_print_type options
                                test_ran, "\n"]);
             if generalises (break_dom,fun_dom)
               then ()
             else
               do_error
               (concat [fun_name ^ ": Break function domain not compatible with traced function domain:",
                         "\n  break domain: ", Types.debug_print_type
                                options break_dom,
                         "\n  function domain: ", Types.debug_print_type
                         options fun_dom, "\n"]);
             if type_eq (break_ran,Types.bool_type)
               then ()
             else
               do_error
               (concat [fun_name ^ ": Break function range not boolean:",
                         "\n  break range: ", Types.debug_print_type options break_ran,"\n"]))
        in
          Test.trace
          ((Value.cast fun_val),
           fn (f,a,frame) =>
           let
             (* val entry_only = true *)
             val do_output = ((Value.cast test_val) a) : bool
             val do_break = ((Value.cast break_val) a) : bool
           in
             if do_output
               then
                 if entry_only then
                   let
                     val (name,arg,_) = get_frame_info frame

                     val _ = print_entry (name,arg)
                     val _ =
                       if do_break
                         then
                           Debugger.break ("Function entry: " ^ name ^ " " ^ arg)
                       else ()
                   in
                     f a
                   end
                 else
                   let
                     val (name,arg,res_ty) = get_frame_info frame
                     val level = !indent_level
                     val _ = indent_level := (!indent_level) + 1
                     val _ = outspaces level
                     val _ = print_entry (name,arg)
                     val _ =
                       if do_break
                         then
                           Debugger.break ("Function entry: " ^ name ^ " " ^ arg)
                       else ()
                     val result = f a handle exn => (indent_level := level;raise exn)
                   in
                     indent_level := level;
                     outspaces level;
                     print (name ^ " returns " ^ string_value (result,res_ty) ^ "\n");
                     result
                   end
             else
               (if do_break
                  then
                    let
                      val (name,arg,_) = get_frame_info frame
                    in
                      Debugger.break ("Function entry: " ^ name ^ " " ^ arg)
                    end
                else ();
                  f a)
           end)
          handle Trace.Trace s =>
            message_fn ("Cannot trace " ^ fun_name ^ ": " ^ s)
        end
      end handle Error => ()



    (* Association lists of the functions that currently have breakpoints
     * set on them and/or which are being traced.  The value of the
     * association appears to a be a pair of function/type pairs where
     * the first controls whether tracing messages are output and the
     * second controls whether the function breakpoints.
     *)
    val traced_functions : (string * ((Value.T * Type) * (Value.T * Type))) list ref = ref []
    val broken_functions : (string * ((Value.T * Type) * (Value.T * Type))) list ref = ref []

    fun remove' (s,[],acc) = rev acc
      | remove' (s,(a,b)::c,acc) =
      if s = a then (rev acc) @@ c
      else remove' (s,c,(a,b)::acc)
    fun remove l s = l := remove' (s,!l,[])

    val remove_breakpoint = remove broken_functions
    val remove_traced = remove traced_functions

    fun trim (s,n) =
      if size s > n then substring (* could raise Substring *) (s,0,n) else s

    fun trace_function frame =
      let
	val (name,arg_string,_) = get_frame_info frame
      in
	print_entry (name, arg_string)
      end

    fun break_function frame =
      let
	val (name,arg_string,_) = get_frame_info frame
      in
	Debugger.break ("Entering: " ^ name ^ " " ^ arg_string)
      end

    fun assoc (name,[]) = NONE
      | assoc (name,(s,b) :: rest) =
      if size name >=  size s andalso substring (* could raise Substring *) (name,0,size s) = s
	then SOME b
      else assoc (name,rest)

    fun traceit code =
      let
	val name = Value.code_name code
      in
	case assoc (name,!traced_functions) of
	  SOME (f,g) =>
	    trace_full_internal false (f,g) code
	| _ => ()
      end

    (* frame_message is purely for the purposes of debugging the
     * debugger.  Sprinkle calls to this liberally around the
     * breakpoint, step and next code and all will become clear.
     *)
    fun frame_message (frame, message) =
      let val (name, arg_string, _) = get_frame_info frame in
	print( message);
	print( name);
	print( " ");
	print( arg_string);
	print( "\n")
      end

    datatype Stepping = OFF | LOGICALLY_ON | ON
    (*
     * The ON and OFF cases should be fairly obvious -- they indicate
     * whether all the code has been interecepted to do stepping (ON)
     * or not (OFF).
     *
     * The LOGICALLY_ON case is an ugly hack.  It is here as an artifact
     * of the way the tracer indicates to the debugger that it has
     * been called due to a step action -- it is effectively done via a
     * shared variable (ugh!).  This third case is used to fool the
     * debugger into thinking that stepping is enabled, even though
     * the code is not intercepted.
     *)

    val stepping_status = ref OFF

    (* The number of functions to step over before entering the debugger.
     * 0 means stop at the next function.
     *)
    val step_count = ref 0

    val intercepted_function = ref NONE

    (* Some sort of table of functions which have breakpoints set.
     * Presumably the domain of this should match that of broken_functions
     * and so they could be merged into one in the future? - stephenb
     *)
    val breakpoint_table =
      ref(NewMap.empty' ((op<):string*string->bool)) : (string, {hits: int, max: int, name: string}) NewMap.map ref

    fun is_a_break s = NewMap.tryApply'(!breakpoint_table, s)

    fun update_break(arg as {name, ...}) =
      breakpoint_table := NewMap.define'(!breakpoint_table, (name, arg))

    fun add_break{hits, max, name} =
      breakpoint_table :=
      NewMap.define'(!breakpoint_table,
		     (name, {hits=hits, max=max, name=name}))

    fun remove_break name =
      breakpoint_table := NewMap.undefine(!breakpoint_table, name)

    (* Note that this only installs the breakpoint if it is in the
     * list of breakpointed functions.  This suits the places it is
     * used since they either make sure the name is in the list or
     * make use of the fact that the breakpoint won't be added if it
     * is not.
     *)
    fun install_breakpoint (name, code) =
      case assoc (name,!broken_functions) of
	SOME _ =>
	  trace_code_replace (code, breakpoint_replacement)
      | NONE => ()

    (* This is is what is stuffed in the replacement slot of a function
     * so that the debugger is called when the function is hit.
     *
     * A replacement is used rather than a simple intercept so that
     * the "next" implementation can get in when the debugger is run
     * and alter the replacement/intercept so that this takes effect
     * after the debugger is exited and the function is restarted.
     *)
    and breakpoint_replacement frame =
      let
	val (name, arg_string, _) = get_frame_info frame
	val f = Value.cast (StackInterface.frame_closure frame)
	val a = Value.cast (StackInterface.frame_arg frame)
	val c = StackInterface.frame_code frame
      in
	(* nop out the intercept to avoid an infinite loop.  *)
	MLWorks.Internal.Trace.restore f;
	intercepted_function := SOME name;
	(Debugger.break ("Entering: " ^ name ^ " " ^ arg_string)
	 handle exn =>
	   (intercepted_function := NONE;
            install_breakpoint (name, c);
            raise exn));
	intercepted_function := NONE;
	(StackInterface.set_frame_return_value (frame, Value.cast (f a))
	 handle exn => (install_breakpoint (name, c);  raise exn));
	install_breakpoint (name, c)
      end

    and breakit code =
      let
	val name = Value.code_name code
      in
	install_breakpoint (name, code)
      end

    and restore_intercepts () =
      let
	fun restore code = (traceit code; breakit code)
      in
	Trace.restore_all ();
	step_count := 0;
	stepping_status := OFF;
	trace_set_code_loader_function restore;
	apply_all restore
      end

    fun restore_intercepts_if_not_stepping () =
      case !stepping_status of
	OFF => restore_intercepts ()
      | _   => ()

    fun reinstall function frame =
      let
	val code = StackInterface.frame_code frame
      in
	trace_code_replace (code, function)
      end

    (* This is what is stuffed in the intercept/replacement slot when
     * single stepping.
     *
     * A replacement is used rather than a simple intercept so that
     * the "next" implementation can get in when the debugger is run
     * and alter the replacement/intercept so that this takes effect
     * after the debugger is exited and the function is restarted.
     *)
    fun step_always_replacement frame =
      let
	val (name, arg_string, _) = get_frame_info frame
	val f = Value.cast (StackInterface.frame_closure frame)
	val a = Value.cast (StackInterface.frame_arg frame)
	val c = StackInterface.frame_code frame
      in
	restore_intercepts ();
	(* make sure that if there was a breakpoint/trace on the function
	 * restored by restore_intercepts, that it is nopped out ... *)
	MLWorks.Internal.Trace.restore f;
	(if !step_count > 0 then
	   step_count := !step_count - 1
	 else
	   (intercepted_function := SOME name;
	    stepping_status := LOGICALLY_ON;
	    Debugger.break ("Entering: " ^ name ^ " " ^ arg_string);
	    intercepted_function := NONE));
	   StackInterface.set_frame_return_value (frame, Value.cast (f a))
      end

    (* This is what is stuffed in an intercept/replacement slot after
     * "next" has been called to guarantee that debugger is called
     * on the first function after the one being stepped over.
     *)
    fun step_once_replacement frame =
      let
	val (name, arg_string, _) = get_frame_info frame
	val f = Value.cast (StackInterface.frame_closure frame)
	val a = Value.cast (StackInterface.frame_arg frame)
	val c = StackInterface.frame_code frame
      in
	restore_intercepts ();
	(* make sure that if there was a breakpoint/trace on the function
	 * restored by restore_intercepts, that it is nopped out ... *)
	MLWorks.Internal.Trace.restore f;
	intercepted_function := SOME name;
	stepping_status := LOGICALLY_ON;
	Debugger.break ("Entering: " ^ name ^ " " ^ arg_string);
	intercepted_function := NONE;
	StackInterface.set_frame_return_value (frame, Value.cast (f a))
      end

    (* Replace/intercept "code" with a "step" function.
     * If "code" is a setup function, then this is a nop since they
     * shouldn't be stepped.  If "code" is not currently being intercepted,
     * then it is replaced with the step function.  If "code" is currently
     * intercepted, then the interception is replaced by another
     * intercept which when run reinstalls the "step" function.
     *)
    fun replace_with step code =
      let
	val full_code_name = Value.code_name code
	val function_name = strip_location full_code_name
      in
	if function_name = "<Setup>" then
	  ()
	else
	  case !intercepted_function of
	    NONE =>
	      trace_code_replace (code, step)
	  | SOME name =>
	      if name = function_name
                then trace_code_intercept (code, reinstall step)
	      else trace_code_replace (code, step)
      end

    val make_code_step_always = replace_with step_always_replacement

    val make_code_step_once = replace_with step_once_replacement

    fun set_stepping b =
      if b then
	case !stepping_status of
	  ON => ()
	| _ =>
	    (apply_all make_code_step_always;
	     trace_set_code_loader_function make_code_step_always;
	     stepping_status := ON)
      else
	case !stepping_status of
	  OFF =>          ()
	| LOGICALLY_ON => stepping_status := OFF
	| ON =>           restore_intercepts ()

    fun make_all_code_step_once () =
      (apply_all make_code_step_once;
       stepping_status := ON)

    fun stepping () =
      case !stepping_status of
	OFF => false
      | _   => true

    fun set_step_count n =
        if n > 0
        then step_count := n-1
        else step_count := 0

    (* What the following does is reasonably clear, what isn't is
     * why it is needed.  I can only find one use of it in
     * _ml_debugger but I haven't investigated to see what use is made
     * of it - stephenb.
     *)
    fun step_through f a =
      let
	val _ = set_stepping true
	val result = f a handle exn => (set_stepping false; raise exn)
      in
	set_stepping false;
	result
      end

    fun tracealways code = trace_code_intercept (code,trace_function)

    (* Trace interface functions *)

    (* Note that we only change the intercept status of code if we are
     * not stepping.  Might be better to have separate functions for
     * setting the name refs and actually updating the relevant code objects.
     * Should ensure traced and broken functions are kept consistent with
     * each other
     *)

    fun update (name,data,list,acc) =
      case list of
	[] => (name,data)::acc
      | ((a,d)::rest) =>
	  if a = name then rev acc @@ ((a,data)::rest)
	  else update (name,data,rest,(a,d)::acc)

    fun trace name =
      let
	fun restore code = (traceit code; breakit code)
      in
	traced_functions := update (name,(always,never),!traced_functions,[]);
	remove_breakpoint name;
	if stepping () then
	  ()
	else
	  (trace_set_code_loader_function restore;
	   apply_all traceit)
      end

    fun trace_full (name,f,g) =
      let
	fun restore code = (traceit code; breakit code)
      in
	traced_functions := update (name,(f,g),!traced_functions,[]);
	remove_breakpoint name;
	if stepping () then
	  ()
	else
	  (trace_set_code_loader_function restore;
	   apply_all traceit)
      end

    (* Set a breakpoint on the function with the given name. *)

    fun break name =
      let
	fun restore code = (traceit code; breakit code)
      in
	broken_functions := update (name,(always,never),!broken_functions,[]);
	remove_traced name;
	trace_set_code_loader_function restore;
	apply_all breakit
      end

    val break = fn(arg as {hits, max, name}) =>
      (break name;
       add_break arg)

    (* Replace all the existing traced functions with those named in the
     * argument list.  IMHO this isn't a particularly good interface,
     * but it is what the GUI debugger currently expects.
     *
     * If the user is currently stepping, then you don't want to physically
     * overwrite the existing intercepts with trace intercepts,
     * so in this case all that it is done is to construct correct
     * the correct trace list and table so that the traced functions
     * will be restored when stepping is over.
     *
     * If the user isn't currently stepping, then the traced functions can
     * be updated straight away.  The method used to do this is not
     * particularly efficient or elegant, but since the whole debugger
     * will hopefully be rewritten soon I'm not spending much time on
     * it now - stephenb
     *)
    local
      fun addTrace (name, tfl) = (name, (always,never))::tfl
    in
      fun trace_list names =
	if stepping () then
	  let
	    val tfl = List.foldl addTrace [] names
	  in
	    traced_functions := tfl
	  end
	else
	  (traced_functions := [];
	   restore_intercepts ();
	   List.app trace names)
    end

    (* Replace all the existing breakpoints with those named in the
     * argument list.  IMHO this isn't a particularly good interface,
     * but it is what the GUI debugger currently expects.
     *
     * If the user is currently stepping, then you don't want to physically
     * overwrite the existing intercepts with breakpoint intercepts,
     * so in this case all that it is done is to construct correct
     * the correct breakpoint list and table so that the breakpoints
     * will be restored when stepping is over.
     *
     * If the user isn't currently stepping, then the breakpoints can
     * be updated straight away.  The method used to do this is not
     * particularly efficient or elegant, but since the whole debugger
     * will hopefully be rewritten soon I'm not spending much time on
     * it now - stephenb
     *)
    local
      val init = ([], NewMap.empty' ((op<):string*string->bool))

      fun addBreakpoint (bp as {hits, max, name}, (bpl, bpt)) =
	((name, (always,never))::bpl, NewMap.define (bpt, name, bp))

    in
      fun break_list name_hits_list =
	if stepping () then
	  let
	    val (bpl, bpt) = List.foldl addBreakpoint init name_hits_list
	  in
	    broken_functions := bpl;
	    breakpoint_table := bpt
	  end
	else
	  (broken_functions := [];
	   breakpoint_table := NewMap.empty' ((op<):string*string->bool);
	   restore_intercepts ();
	   List.app break name_hits_list)
    end

    fun untrace name =
      (remove_traced name;
       restore_intercepts_if_not_stepping ())

    fun unbreak name =
      (remove_breakpoint name;
       remove_break name;
       restore_intercepts_if_not_stepping ())

    fun untrace_all () =
      (traced_functions := [];
       restore_intercepts_if_not_stepping ())

    fun unbreak_all () =
      (broken_functions := [];
       breakpoint_table :=
       NewMap.empty' ((op<):string*string->bool);
       restore_intercepts_if_not_stepping ())

    fun breakpoints () =
      NewMap.range_ordered(!breakpoint_table)

    fun traces () = map #1 (!traced_functions)

    fun set_trace_all b =
      if b
        then apply_all tracealways
      else restore_intercepts ()

    (* "next" implements something that is a mixture of "next" and
     * "finish" in gdb.  The idea is that given a frame which has
     * just been intercepted (due to either step or breakpoint),
     * step over all (child) calls in the body of the code associated with
     * the frame and stop at the start of next (sibling) call.
     *
     * This would be relatively simple to do by inserting breakpoint
     * after the call instruction.  However, the approach taken here
     * is to use the existing intercept mechanism and use a
     * technique based on the way tracing is implemented i.e. the
     * flow of control is contorted.
     *)
    fun next frame =
      let
	val step_status_before_next_called = !stepping_status

	fun replacement frame =
	  let
	    val (name, arg_string, _) = get_frame_info frame
	    val f = Value.cast (StackInterface.frame_closure frame)
	    val a = Value.cast (StackInterface.frame_arg frame)
	    val c = StackInterface.frame_code frame
	    val _ = MLWorks.Internal.Trace.restore f
	  in
	    StackInterface.set_frame_return_value (frame, Value.cast (f a));
	    case step_status_before_next_called of
	      ON => set_stepping true
	    | _ =>  make_all_code_step_once ()
	  end

      in
	set_stepping false;
	trace_code_replace ((StackInterface.frame_code frame), replacement)
        handle Trace.Trace s =>
          (print( "Cannot step over ");
           print( strip_location (StackInterface.frame_name frame));
           print( ": ");
           print( s);
           print( "\n"))
      end

    (* Select from an object, with some checking for error cases *)
    (* A header of zero is possible if we are in a shared closure *)
    fun select field =
      if field < 0 then
        raise Value "select: negative field"
      else
        fn value =>
        let
          val primary = Value.primary value
        in
          if primary = Tags.PAIRPTR
            then
              if field >= 2
                then
                  raise Value "select: field >= 2 in pair"
              else
                Value.sub (value, field)
              else if primary = Tags.POINTER
                     then
                       let
                         val (secondary, length) = Value.header value
                       in
                         if (secondary = Tags.INTEGER0 andalso field=0)
                           orelse (secondary = Tags.INTEGER1 andalso field=0)
                           then
                             Value.sub (value, 1)
                         else
                           if secondary = Tags.RECORD then
                             if field >= length then
                               raise Value "select: field >= length in record"
                             else
                               Value.sub (value, field+1)
                           else
                             raise Value "select: invalid secondary"
                       end
                   else
                     raise Value "select: invalid primary"
        end

    fun get_function_string f =
      let
        val f : Value.T = Value.cast f
        val value = select 0 f
      in
        if
          Value.primary value = Tags.POINTER andalso
          #1 (Value.header value) = Tags.BACKPTR
          then
            Value.code_name value
        else
          raise Value "code_name: not a code item"
      end

    fun get_function_name f =
      let
        val code_name = get_function_string f
        val (name,loc) = get_name_and_location code_name
      in
        name
      end

  end
@


1.45.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a13 4
 * Revision 1.45  1998/03/20  16:13:28  jont
 * [Bug #30090]
 * Remove MLWorks.IO in favour of print
 *
@


1.44
log
@[Bug #30153]
Remove references to Old.
@
text
@d14 4
d543 1
a543 1
    | outspaces n = (MLWorks.IO.output(MLWorks.IO.std_out,"  ");outspaces(n-1))
@


1.43
log
@[Bug #30090]
Translate output std_out to print
@
text
@d14 4
a184 1
require "^.basis.__old";
@


1.43.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a13 4
 * Revision 1.43  1997/05/16  17:24:09  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.43.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a13 4
 * Revision 1.43  1997/05/16  17:24:09  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.42
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d14 4
d222 1
a222 3
    fun P s = MLWorks.IO.output (MLWorks.IO.std_out,s)

    fun print_entry (name,arg) = P (name ^ " " ^ arg ^ "\n")
d225 2
a226 2
    fun debug s = if do_debug then P (s ^ "\n") else ()
    fun fdebug f = if do_debug then P (f() ^ "\n") else ()
d300 1
a300 1
    
d305 1
a305 1
          
d309 1
a309 1
        
d324 1
a324 1
                    val recipe = 
d347 1
a347 1
        then 
d352 1
a352 1
               | TypeReconstructionFailed s => 
d432 1
a432 1
                             {old_definition,...},...} = 
d435 1
a435 1
          Scheme.apply_instantiation 
d437 1
a437 1
          handle Mismatch => 
d444 1
a444 1
    (* As the name suggets, gets info on a frame.  
d470 1
a470 1
                    (fdebug (fn _ => 
d508 1
a508 1
               StackInterface.set_frame_return_value 
d521 1
a521 1
               StackInterface.set_frame_return_value 
d535 1
a535 1
    fun outspaces 0 = () 
d542 1
a542 1
     * that always returns true, and "never" is one which always returns 
d550 1
a550 1
 
d572 1
a572 1
      Scheme.generalises old_definition (ty1,ty2) 
d591 1
a591 1
     * 
d611 1
a611 1
        fun message_fn s = MLWorks.IO.output (MLWorks.IO.std_out,s ^ "\n")
d636 1
a636 1
          val _ = 
d640 2
a641 2
             else 
               do_error 
d644 1
a644 1
                        "\n  function domain: ", Types.debug_print_type 
d648 2
a649 2
             else 
               do_error 
d656 1
a656 1
               do_error 
d658 1
a658 1
                         "\n  break domain: ", Types.debug_print_type 
d660 1
a660 1
                         "\n  function domain: ", Types.debug_print_type 
d665 1
a665 1
               do_error 
d684 1
a684 1
                     val _ = 
d690 1
a690 1
                     f a 
d699 1
a699 1
                     val _ = 
d708 1
a708 1
                     P (name ^ " returns " ^ string_value (result,res_ty) ^ "\n");
d729 8
a736 2
    local
      open Value
d738 5
a742 14
      (* Association lists of the functions that currently have breakpoints 
       * set on them and/or which are being traced.  The value of the
       * association appears to a be a pair of function/type pairs where
       * the first controls whether tracing messages are output and the
       * second controls whether the function breakpoints.
       *)
      val traced_functions : (string * ((Value.T * Type) * (Value.T * Type))) list ref = ref [] 
      val broken_functions : (string * ((Value.T * Type) * (Value.T * Type))) list ref = ref []

      fun remove' (s,[],acc) = rev acc
        | remove' (s,(a,b)::c,acc) =
          if s = a then (rev acc) @@ c
          else remove' (s,c,(a,b)::acc)
      fun remove l s = l := remove' (s,!l,[])
d744 2
a745 2
      val remove_breakpoint = remove broken_functions
      val remove_traced = remove traced_functions
d747 2
a748 3
    in
      fun trim (s,n) =
        if size s > n then substring (* could raise Substring *) (s,0,n) else s
d750 6
a755 6
      fun trace_function frame = 
        let
          val (name,arg_string,_) = get_frame_info frame
        in
          print_entry (name, arg_string)
        end
d757 6
a762 6
      fun break_function frame = 
        let
          val (name,arg_string,_) = get_frame_info frame
        in
          Debugger.break ("Entering: " ^ name ^ " " ^ arg_string)
        end
d764 5
d770 9
a778 5
      fun assoc (name,[]) = NONE
        | assoc (name,(s,b) :: rest) =
          if size name >=  size s andalso substring (* could raise Substring *) (name,0,size s) = s
            then SOME b
          else assoc (name,rest)
d780 12
d793 13
d807 1
a807 9
      fun traceit code = 
        let
          val name = Value.code_name code
        in
          case assoc (name,!traced_functions) of
            SOME (f,g) =>
              trace_full_internal false (f,g) code
          | _ => ()
        end
d809 4
d814 1
d816 6
d823 1
a823 12
      (* frame_message is purely for the purposes of debugging the
       * debugger.  Sprinkle calls to this liberally around the
       * breakpoint, step and next code and all will become clear.
       *)
      fun frame_message (frame, message) =
        let val (name, arg_string, _) = get_frame_info frame in
          MLWorks.IO.output (MLWorks.IO.std_out, message);
          MLWorks.IO.output (MLWorks.IO.std_out, name);
          MLWorks.IO.output (MLWorks.IO.std_out, " ");
          MLWorks.IO.output (MLWorks.IO.std_out, arg_string);
          MLWorks.IO.output (MLWorks.IO.std_out, "\n")
        end
d825 2
d828 19
d848 21
a868 95
      datatype Stepping = OFF | LOGICALLY_ON | ON
      (*
       * The ON and OFF cases should be fairly obvious -- they indicate
       * whether all the code has been interecepted to do stepping (ON)
       * or not (OFF).
       *
       * The LOGICALLY_ON case is an ugly hack.  It is here as an artifact
       * of the way the tracer indicates to the debugger that it has
       * been called due to a step action -- it is effectively done via a
       * shared variable (ugh!).  This third case is used to fool the
       * debugger into thinking that stepping is enabled, even though
       * the code is not intercepted.
       *)


      val stepping_status = ref OFF



      (* The number of functions to step over before entering the debugger.
       * 0 means stop at the next function.
       *)
      val step_count = ref 0


       
      val intercepted_function = ref NONE


      (* Some sort of table of functions which have breakpoints set.
       * Presumably the domain of this should match that of broken_functions
       * and so they could be merged into one in the future? - stephenb
       *)
      val breakpoint_table =
        ref(NewMap.empty' ((op<):string*string->bool)) : (string, {hits: int, max: int, name: string}) NewMap.map ref



      fun is_a_break s = NewMap.tryApply'(!breakpoint_table, s)



      fun update_break(arg as {name, ...}) =
        breakpoint_table := NewMap.define'(!breakpoint_table, (name, arg))



      fun add_break{hits, max, name} =
        breakpoint_table :=
        NewMap.define'(!breakpoint_table,
                       (name, {hits=hits, max=max, name=name}))



      fun remove_break name =
        breakpoint_table := NewMap.undefine(!breakpoint_table, name)




      (* Note that this only installs the breakpoint if it is in the
       * list of breakpointed functions.  This suits the places it is
       * used since they either make sure the name is in the list or
       * make use of the fact that the breakpoint won't be added if it
       * is not.
       *)
      fun install_breakpoint (name, code) =
        case assoc (name,!broken_functions) of
          SOME _ => 
            trace_code_replace (code, breakpoint_replacement)
        | NONE => ()



      (* This is is what is stuffed in the replacement slot of a function
       * so that the debugger is called when the function is hit.
       *
       * A replacement is used rather than a simple intercept so that
       * the "next" implementation can get in when the debugger is run
       * and alter the replacement/intercept so that this takes effect
       * after the debugger is exited and the function is restarted.
       *)
      and breakpoint_replacement frame =
        let
          val (name, arg_string, _) = get_frame_info frame
          val f = Value.cast (StackInterface.frame_closure frame)
          val a = Value.cast (StackInterface.frame_arg frame)
          val c = StackInterface.frame_code frame
        in
          (* nop out the intercept to avoid an infinite loop.  *)
          MLWorks.Internal.Trace.restore f;
          intercepted_function := SOME name;
          (Debugger.break ("Entering: " ^ name ^ " " ^ arg_string)
           handle exn =>
            (intercepted_function := NONE;
d871 5
a875 5
          intercepted_function := NONE;
          (StackInterface.set_frame_return_value (frame, Value.cast (f a))
           handle exn => (install_breakpoint (name, c);  raise exn));
          install_breakpoint (name, c)
        end
d877 6
d884 10
d895 4
a898 6
      and breakit code = 
        let
          val name = Value.code_name code
        in
          install_breakpoint (name, code)
        end
d900 6
d907 28
d936 21
a956 10
      and restore_intercepts () =
        let
          fun restore code = (traceit code; breakit code)
        in
          Trace.restore_all ();
          step_count := 0;
          stepping_status := OFF;
          trace_set_code_loader_function restore;
          apply_all restore
        end
d958 20
a977 95
        

      fun restore_intercepts_if_not_stepping () =
        case !stepping_status of
          OFF => restore_intercepts ()
        | _   => ()



      fun reinstall function frame =
        let
          val code = StackInterface.frame_code frame
        in
          trace_code_replace (code, function)
        end



      (* This is what is stuffed in the intercept/replacement slot when
       * single stepping.
       *
       * A replacement is used rather than a simple intercept so that
       * the "next" implementation can get in when the debugger is run
       * and alter the replacement/intercept so that this takes effect
       * after the debugger is exited and the function is restarted.
       *)
      fun step_always_replacement frame =
        let
          val (name, arg_string, _) = get_frame_info frame
          val f = Value.cast (StackInterface.frame_closure frame)
          val a = Value.cast (StackInterface.frame_arg frame)
          val c = StackInterface.frame_code frame
        in
          restore_intercepts ();
          (* make sure that if there was a breakpoint/trace on the function
           * restored by restore_intercepts, that it is nopped out ... *)
          MLWorks.Internal.Trace.restore f;
          (if !step_count > 0 then
             step_count := !step_count - 1
           else
             (intercepted_function := SOME name;
              stepping_status := LOGICALLY_ON;
              Debugger.break ("Entering: " ^ name ^ " " ^ arg_string);
              intercepted_function := NONE));
          StackInterface.set_frame_return_value (frame, Value.cast (f a))
        end




      (* This is what is stuffed in an intercept/replacement slot after
       * "next" has been called to guarantee that debugger is called
       * on the first function after the one being stepped over.
       *)
      fun step_once_replacement frame =
        let
          val (name, arg_string, _) = get_frame_info frame
          val f = Value.cast (StackInterface.frame_closure frame)
          val a = Value.cast (StackInterface.frame_arg frame)
          val c = StackInterface.frame_code frame
        in
          restore_intercepts ();
          (* make sure that if there was a breakpoint/trace on the function
           * restored by restore_intercepts, that it is nopped out ... *)
          MLWorks.Internal.Trace.restore f;
          intercepted_function := SOME name;
          stepping_status := LOGICALLY_ON;
          Debugger.break ("Entering: " ^ name ^ " " ^ arg_string);
          intercepted_function := NONE;
          StackInterface.set_frame_return_value (frame, Value.cast (f a))
        end




      (* Replace/intercept "code" with a "step" function.
       * If "code" is a setup function, then this is a nop since they
       * shouldn't be stepped.  If "code" is not currently being intercepted,
       * then it is replaced with the step function.  If "code" is currently
       * intercepted, then the interception is replaced by another
       * intercept which when run reinstalls the "step" function.
       *)
      fun replace_with step code =
        let
          val full_code_name = Value.code_name code
          val function_name = strip_location full_code_name
        in
          if function_name = "<Setup>" then
            ()
          else
            case !intercepted_function of
              NONE => 
                trace_code_replace (code, step)
            | SOME name => 
                if name = function_name
d979 2
a980 2
                else trace_code_replace (code, step)
        end
d982 1
a982 1
 
d984 1
a984 1
      val make_code_step_always = replace_with step_always_replacement
d986 22
d1009 1
a1009 35

      val make_code_step_once = replace_with step_once_replacement



      fun set_stepping b =
        if b then
          case !stepping_status of
            ON => ()
          | _ => 
               (apply_all make_code_step_always;
                trace_set_code_loader_function make_code_step_always;
                stepping_status := ON)
        else
          case !stepping_status of
            OFF =>          ()
          | LOGICALLY_ON => stepping_status := OFF
          | ON =>           restore_intercepts ()



      fun make_all_code_step_once () =
        (apply_all make_code_step_once;
         stepping_status := ON)



      fun stepping () =
        case !stepping_status of
          OFF => false
        | _   => true



      fun set_step_count n =
d1014 13
d1028 1
d1030 1
a1030 13
      (* What the following does is reasonably clear, what isn't is
       * why it is needed.  I can only find one use of it in
       * _ml_debugger but I haven't investigated to see what use is made
       * of it - stephenb.
       *)
      fun step_through f a =
        let
          val _ = set_stepping true
          val result = f a handle exn => (set_stepping false; raise exn)
        in
          set_stepping false;
          result
        end
d1032 6
d1039 6
d1046 12
d1059 3
a1061 89
      fun tracealways code = trace_code_intercept (code,trace_function)



      (* Trace interface functions *)

      (* Note that we only change the intercept status of code if we are
       * not stepping.  Might be better to have separate functions for
       * setting the name refs and actually updating the relevant code objects.
       * Should ensure traced and broken functions are kept consistent with
       * each other
       *)

      fun update (name,data,list,acc) =
        case list of
          [] => (name,data)::acc
        | ((a,d)::rest) =>
            if a = name then rev acc @@ ((a,data)::rest)
            else update (name,data,rest,(a,d)::acc)


      fun trace name =
        let
          fun restore code = (traceit code; breakit code)
        in
          traced_functions := update (name,(always,never),!traced_functions,[]);
          remove_breakpoint name;
          if stepping () then
            ()
          else
            (trace_set_code_loader_function restore;
             apply_all traceit)
        end



      fun trace_full (name,f,g) =
        let
          fun restore code = (traceit code; breakit code)
        in
          traced_functions := update (name,(f,g),!traced_functions,[]);
          remove_breakpoint name;
          if stepping () then
            ()
          else
            (trace_set_code_loader_function restore;
             apply_all traceit)
        end



      (* Set a breakpoint on the function with the given name. *)

      fun break name =
        let
          fun restore code = (traceit code; breakit code)
        in
          broken_functions := update (name,(always,never),!broken_functions,[]);
          remove_traced name;
          trace_set_code_loader_function restore;
          apply_all breakit
        end


      val break = fn(arg as {hits, max, name}) =>
        (break name;
         add_break arg)




      (* Replace all the existing traced functions with those named in the
       * argument list.  IMHO this isn't a particularly good interface, 
       * but it is what the GUI debugger currently expects.
       *
       * If the user is currently stepping, then you don't want to physically
       * overwrite the existing intercepts with trace intercepts, 
       * so in this case all that it is done is to construct correct
       * the correct trace list and table so that the traced functions
       * will be restored when stepping is over.
       *
       * If the user isn't currently stepping, then the traced functions can
       * be updated straight away.  The method used to do this is not
       * particularly efficient or elegant, but since the whole debugger
       * will hopefully be rewritten soon I'm not spending much time on
       * it now - stephenb
       *)
      local
        fun addTrace (name, tfl) = (name, (always,never))::tfl
d1063 7
a1069 11
        fun trace_list names =
          if stepping () then
            let
              val tfl = List.foldl addTrace [] names
            in
               traced_functions := tfl
            end
          else
            (traced_functions := [];
             restore_intercepts ();
             List.app trace names)
d1072 1
d1074 3
a1076 24


      (* Replace all the existing breakpoints with those named in the
       * argument list.  IMHO this isn't a particularly good interface, 
       * but it is what the GUI debugger currently expects.
       *
       * If the user is currently stepping, then you don't want to physically
       * overwrite the existing intercepts with breakpoint intercepts, 
       * so in this case all that it is done is to construct correct
       * the correct breakpoint list and table so that the breakpoints
       * will be restored when stepping is over.
       *
       * If the user isn't currently stepping, then the breakpoints can
       * be updated straight away.  The method used to do this is not
       * particularly efficient or elegant, but since the whole debugger
       * will hopefully be rewritten soon I'm not spending much time on
       * it now - stephenb
       *)
      local
        val init = ([], NewMap.empty' ((op<):string*string->bool))

        fun addBreakpoint (bp as {hits, max, name}, (bpl, bpt)) =
          ((name, (always,never))::bpl, NewMap.define (bpt, name, bp))

d1078 4
a1081 13
        fun break_list name_hits_list =
          if stepping () then
            let
              val (bpl, bpt) = List.foldl addBreakpoint init name_hits_list
            in
               broken_functions := bpl;
               breakpoint_table := bpt
            end
          else
            (broken_functions := [];
             breakpoint_table := NewMap.empty' ((op<):string*string->bool);
             restore_intercepts ();
             List.app break name_hits_list)
d1084 35
d1120 18
d1139 2
d1142 15
a1156 22
      fun untrace name = 
        (remove_traced name;
         restore_intercepts_if_not_stepping ())


      fun unbreak name =
        (remove_breakpoint name;
         remove_break name;
         restore_intercepts_if_not_stepping ())


      fun untrace_all () =
        (traced_functions := [];
         restore_intercepts_if_not_stepping ())


      fun unbreak_all () = 
        (broken_functions := [];
         breakpoint_table :=
         NewMap.empty' ((op<):string*string->bool);
         restore_intercepts_if_not_stepping ())

d1158 18
a1175 2
      fun breakpoints () = 
        NewMap.range_ordered(!breakpoint_table)
d1177 2
a1178 1
      fun traces () = map #1 (!traced_functions)
d1180 1
d1182 2
a1183 2
      fun set_trace_all b =
        if b 
d1185 1
a1185 1
        else restore_intercepts ()
d1187 15
d1203 13
d1217 3
a1219 33
      (* "next" implements something that is a mixture of "next" and 
       * "finish" in gdb.  The idea is that given a frame which has
       * just been intercepted (due to either step or breakpoint), 
       * step over all (child) calls in the body of the code associated with
       * the frame and stop at the start of next (sibling) call.
       *
       * This would be relatively simple to do by inserting breakpoint
       * after the call instruction.  However, the approach taken here
       * is to use the existing intercept mechanism and use a
       * technique based on the way tracing is implemented i.e. the
       * flow of control is contorted.
       *)
      fun next frame =
        let
          val step_status_before_next_called = !stepping_status

          fun replacement frame =
            let
              val (name, arg_string, _) = get_frame_info frame
              val f = Value.cast (StackInterface.frame_closure frame)
              val a = Value.cast (StackInterface.frame_arg frame)
              val c = StackInterface.frame_code frame
              val _ = MLWorks.Internal.Trace.restore f
            in
              StackInterface.set_frame_return_value (frame, Value.cast (f a));
              case step_status_before_next_called of
                ON => set_stepping true
              | _ =>  make_all_code_step_once ()
            end

        in
          set_stepping false;
          trace_code_replace ((StackInterface.frame_code frame), replacement)
d1221 6
a1226 10
          (MLWorks.IO.output (MLWorks.IO.std_out, "Cannot step over ");
           MLWorks.IO.output (MLWorks.IO.std_out, strip_location (StackInterface.frame_name frame));
           MLWorks.IO.output (MLWorks.IO.std_out, ": ");
           MLWorks.IO.output (MLWorks.IO.std_out, s);
           MLWorks.IO.output (MLWorks.IO.std_out, "\n"))
        end

    end


d1238 1
a1238 1
          if primary = Tags.PAIRPTR 
d1240 1
a1240 1
              if field >= 2 
d1245 1
a1245 1
              else if primary = Tags.POINTER 
d1254 1
a1254 1
                         else 
a1266 2


a1280 2


a1287 1

@


1.41
log
@[Bug #1441]
gather_recipes: remove the 4* stuff now that offsets are byte
offsets rather than word offsets.
@
text
@d14 5
a208 1
    structure Option = MLWorks.Option
d402 1
a402 1
        case Scheme.make_scheme (tyvars,(ty,Option.NONE)) of
d550 1
a550 1
                  Datatypes.FUNTYPE (Datatypes.DEBRUIJN (0,false,false,Option.NONE),
@


1.41.5.1
log
@branched from 1.41
@
text
@a13 5
 * Revision 1.41  1996/11/05  12:56:46  stephenb
 * [Bug #1441]
 * gather_recipes: remove the 4* stuff now that offsets are byte
 * offsets rather than word offsets.
 *
@


1.41.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a13 3
 * Revision 1.41.5.1  1997/05/12  10:29:21  hope
 * branched from 1.41
 *
@


1.41.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a13 3
 * Revision 1.41.5.1  1997/05/12  10:29:21  hope
 * branched from 1.41
 *
@


1.41.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a13 3
 * Revision 1.41.5.1  1997/05/12  10:29:21  hope
 * branched from 1.41
 *
@


1.41.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a13 3
 * Revision 1.41.5.1.1.1  1997/07/28  18:15:14  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.41.4.1
log
@branched from 1.41
@
text
@a13 5
 * Revision 1.41  1996/11/05  12:56:46  stephenb
 * [Bug #1441]
 * gather_recipes: remove the 4* stuff now that offsets are byte
 * offsets rather than word offsets.
 *
@


1.41.3.1
log
@branched from 1.41
@
text
@a13 5
 * Revision 1.41  1996/11/05  12:56:46  stephenb
 * [Bug #1441]
 * gather_recipes: remove the 4* stuff now that offsets are byte
 * offsets rather than word offsets.
 *
@


1.41.3.1.1.1
log
@branched from 1.41.3.1
@
text
@a13 3
 * Revision 1.41.3.1  1996/12/17  17:43:13  hope
 * branched from 1.41
 *
@


1.41.2.1
log
@branched from 1.41
@
text
@a13 5
 * Revision 1.41  1996/11/05  12:56:46  stephenb
 * [Bug #1441]
 * gather_recipes: remove the 4* stuff now that offsets are byte
 * offsets rather than word offsets.
 *
@


1.41.1.1
log
@branched from 1.41
@
text
@a13 5
 * Revision 1.41  1996/11/05  12:56:46  stephenb
 * [Bug #1441]
 * gather_recipes: remove the 4* stuff now that offsets are byte
 * offsets rather than word offsets.
 *
@


1.41.1.1.1.1
log
@branched from 1.41.1.1
@
text
@a13 3
 * Revision 1.41.1.1  1996/11/14  12:43:50  hope
 * branched from 1.41
 *
@


1.40
log
@[Bug #1614]
basifying String
@
text
@d14 4
a317 1
                    val byte_offset = 4 * offset
d319 1
a319 1
                      case assoc (byte_offset,annotations) of
@


1.39
log
@[Bug #1521]
Porpagating changes to typechecker/_types.sml
@
text
@d14 4
d168 1
d236 1
a236 1
        fun aux1("["::l,acc) = (acc,l)
d239 2
a240 2
        fun aux2(["]"],acc) = acc
          | aux2("]"::l,acc) = acc
d243 1
a243 1
        val (namechars,rest) = aux1(String.explode code_name,[])
d246 1
a246 1
        (String.implode(rev namechars),String.implode(rev locchars))
d256 2
a257 2
            if String.ordof (s,n) = String.ord "["
              then String.substring (s,0,n)
d291 1
a291 1
    fun assoc (a,[]) = Option.NONE
d293 1
a293 1
        if a = a' then Option.SOME b
d311 1
a311 1
                Option.SOME (DebuggerTypes.FUNINFO {ty,annotations,...}) =>
d317 1
a317 1
                        Option.SOME recipe => recipe
d355 1
a355 1
          Option.SOME (DebuggerTypes.FUNINFO {ty = Datatypes.FUNTYPE (dom,ran),...}) =>
d417 1
a417 1
                          String.implode ["ty: ",Types.debug_print_type ty,
d454 1
a454 1
            Option.SOME (DebuggerTypes.FUNINFO {ty,...}) =>
d462 1
a462 1
                             String.implode ["Combine types fails for: ",
d539 1
a539 1
                                                         Option.NONE),
d633 1
a633 1
               (String.implode [fun_name ^ ": Test function domain not compatible with traced function domain:",
d641 1
a641 1
               (String.implode [fun_name ^ ": Test function range not boolean",
d648 1
a648 1
               (String.implode [fun_name ^ ": Break function domain not compatible with traced function domain:",
d657 1
a657 1
               (String.implode [fun_name ^ ": Break function range not boolean:",
d743 1
a743 1
        if size s > n then String.substring (s,0,n) else s
d760 1
a760 1
      fun assoc (name,[]) = Option.NONE
d762 2
a763 2
          if size name >=  size s andalso String.substring (name,0,size s) = s
            then Option.SOME b
d773 1
a773 1
            MLWorks.Option.SOME (f,g) =>
d822 1
a822 1
      val intercepted_function = ref MLWorks.Option.NONE
d830 1
a830 1
        ref(NewMap.empty' String.<) : (string, {hits: int, max: int, name: string}) NewMap.map ref
d864 1
a864 1
          MLWorks.Option.SOME _ => 
d866 1
a866 1
        | MLWorks.Option.NONE => ()
d887 1
a887 1
          intercepted_function := MLWorks.Option.SOME name;
d890 1
a890 1
            (intercepted_function := MLWorks.Option.NONE;
d893 1
a893 1
          intercepted_function := MLWorks.Option.NONE;
d961 1
a961 1
             (intercepted_function := MLWorks.Option.SOME name;
d964 1
a964 1
              intercepted_function := MLWorks.Option.NONE));
d986 1
a986 1
          intercepted_function := MLWorks.Option.SOME name;
d989 1
a989 1
          intercepted_function := MLWorks.Option.NONE;
d1012 1
a1012 1
              MLWorks.Option.NONE => 
d1014 1
a1014 1
            | MLWorks.Option.SOME name => 
d1206 1
a1206 1
        val init = ([], NewMap.empty' String.<)
d1222 1
a1222 1
             breakpoint_table := NewMap.empty' String.<;
d1249 1
a1249 1
         NewMap.empty' String.<;
@


1.39.3.1
log
@branched from 1.39
@
text
@a13 4
 * Revision 1.39  1996/08/05  17:38:16  andreww
 * [Bug #1521]
 * Porpagating changes to typechecker/_types.sml
 *
@


1.39.2.1
log
@branched from 1.39
@
text
@a13 4
 * Revision 1.39  1996/08/05  17:38:16  andreww
 * [Bug #1521]
 * Porpagating changes to typechecker/_types.sml
 *
@


1.39.1.1
log
@branched from 1.39
@
text
@a13 4
 * Revision 1.39  1996/08/05  17:38:16  andreww
 * [Bug #1521]
 * Porpagating changes to typechecker/_types.sml
 *
@


1.38
log
@Add some comments documenting the tracing code that Matthew wrote.
The code comment ratio is now moving in the right direction, but
there is still a lot of undocumented code here.
@
text
@d14 5
d181 2
d417 3
d421 2
a422 2
          Scheme.apply_instantiation (ty,
                                      Scheme.generalises_map (true,gen_ty,spec_ty))
d442 1
d459 1
a459 1
                                      Types.debug_print_type arg_type,
d461 2
a462 1
                                      Types.debug_print_type reconstructed_arg_type]);
d554 7
a560 2
      Scheme.generalises (true,ty1,ty2) handle Scheme.Mismatch => false

d600 1
d629 3
a631 2
                        "\n  test domain: ", Types.debug_print_type test_dom,
                        "\n  function domain: ", Types.debug_print_type fun_dom, "\n"]);
d637 2
a638 1
                        "\n  test range: ", Types.debug_print_type test_ran, "\n"]);
d644 4
a647 2
                         "\n  break domain: ", Types.debug_print_type break_dom,
                         "\n  function domain: ", Types.debug_print_type fun_dom, "\n"]);
d653 1
a653 1
                         "\n  break range: ", Types.debug_print_type break_ran,"\n"]))
@


1.37
log
@Fix #1408.
Modified break_list and trace_list to they remove any existing intercepts
before installing the new ones.  This cures (in an inelegant way) the problem
of intercepts hanging around.
@
text
@d1 1
a1 1
(*  Tracing utility
d3 9
a11 1
 *  Copyright (C) 1993 Harlequin Ltd
d14 6
d321 2
d336 2
d348 5
a352 2
    (* This is kind of hacky, but if it doesn't work then nothing disastrous happens *)
    (* seems to be OK mind *)
a367 1
(*          Lists.reducel (fn (acc,ty) => tyvars_of (ty,acc)) (acc,tylist) *)
d372 5
a376 2
    (* Need to replace any (meta)tyvars in the type by debruijns, so that the *)
    (* Scheme functions will work *)
d389 5
a393 2
    (* Note that we insist on value polymorphism semantics here, I don't think this matters much *)
    (* Just affects calls to Scheme.generalises* functions *)
d418 10
d464 2
d504 2
a507 1
    fun outspaces 0 = () | outspaces n = (MLWorks.IO.output(MLWorks.IO.std_out,"  ");outspaces(n-1))
d509 11
d529 8
d539 2
d544 1
d547 31
d692 1
d696 5
a700 3
      (* Lists of the functions that currently have breakpoints set on them
       * and which are being traced.  I have no idea what the #2 of the tuple
       * represents.  If you know, please add a comment here - stephenb.
d739 2
d943 1
d966 10
d1039 5
d1062 6
a1067 4
      (* Note that we only change the intercept status of code if we are not stepping *)
      (* Might be better to have separate functions for setting the name refs and *)
      (* actually updating the relevant code objects *)
      (* Should ensure traced and broken functions are kept consistent with each other *)
d1283 1
d1323 2
d1338 2
@


1.36
log
@Update wrt MLWorks.Debugger -> MLWorks.Internal.Debugger change.
@
text
@d6 3
d133 1
a133 1
require "../utils/lists";
d147 1
a147 1
  structure Lists : LISTS
d164 1
a164 1
	       DebuggerUtilities.Debugger_Types.Type
d166 2
a167 2
	       Incremental.InterMake.Compiler.DebugInformation =
    	       DebuggerUtilities.Debugger_Types.information
d346 2
a347 1
          Lists.reducel (fn (acc,ty) => tyvars_of (ty,acc)) (acc,tylist)
d439 2
a440 2
	      (trace_code_intercept (cv, fn _ => trace (cv, new));
	       f' a)
d602 5
d701 4
d706 1
a706 1
	ref(NewMap.empty' String.<) : (string, {hits: int, max: int, name: string}) NewMap.map ref
d715 1
a715 1
	breakpoint_table := NewMap.define'(!breakpoint_table, (name, arg))
d720 3
a722 3
	breakpoint_table :=
	NewMap.define'(!breakpoint_table,
		       (name, {hits=hits, max=max, name=name}))
d727 1
a727 1
	breakpoint_table := NewMap.undefine(!breakpoint_table, name)
d1006 3
a1008 2
	(break name;
	 add_break arg)
a1010 2
      fun trace_list namelist =
        Lists.iterate trace namelist
d1012 74
a1085 2
      fun break_list name_hits_list =
        Lists.iterate break name_hits_list
d1094 1
a1094 1
	(remove_breakpoint name;
d1106 2
a1107 2
	 breakpoint_table :=
	 NewMap.empty' String.<;
d1112 1
a1112 1
	NewMap.range_ordered(!breakpoint_table)
d1159 1
a1159 1
	   MLWorks.IO.output (MLWorks.IO.std_out, strip_location (StackInterface.frame_name frame));
@


1.35
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d6 6
d174 1
a174 1
    structure Debugger = MLWorks.Debugger
@


1.34
log
@Changes for value polymorphism
@
text
@d6 3
d175 1
a175 1
    fun P s = output (std_out,s)
d208 1
a208 1
        val (namechars,rest) = aux1(explode code_name,[])
d211 1
a211 1
        (implode(rev namechars),implode(rev locchars))
d221 1
a221 1
            if String.ordof (s,n) = ord "["
d369 1
a369 1
                          implode ["ty: ",Types.debug_print_type ty,
d400 1
a400 1
                             implode ["Combine types fails for: ",
d458 1
a458 1
    fun outspaces 0 = () | outspaces n = (output(std_out,"  ");outspaces(n-1))
d478 1
a478 1
        fun message_fn s = output (std_out,s ^ "\n")
d508 1
a508 1
               (implode [fun_name ^ ": Test function domain not compatible with traced function domain:",
d515 1
a515 1
               (implode [fun_name ^ ": Test function range not boolean",
d521 1
a521 1
               (implode [fun_name ^ ": Break function domain not compatible with traced function domain:",
d528 1
a528 1
               (implode [fun_name ^ ": Break function range not boolean:",
d648 5
a652 5
          output (std_out, message);
          output (std_out, name);
          output (std_out, " ");
          output (std_out, arg_string);
          output (std_out, "\n")
d1068 5
a1072 5
          (output (std_out, "Cannot step over ");
	   output (std_out, strip_location (StackInterface.frame_name frame));
           output (std_out, ": ");
           output (std_out, s);
           output (std_out, "\n"))
@


1.33
log
@Fix bug #1148 -- quitting the debugger clears the breakpoints.
Fixed by adding some exception handlers to breakpoint_replacement
to ensure that the breakpoint is reinstalled even if an exception is thrown.
@
text
@d6 5
d184 1
a184 1
      fun env s = Value.cast (MLWorks.Internal.Runtime.environment s)
d188 2
a189 2
      val trace_code_intercept : Value.T * ('a -> unit) -> unit = env "trace code intercept"
      val trace_code_replace : Value.T * ('a -> unit) -> unit = env "trace code replace"
d352 4
d373 1
a373 1
                                      Scheme.generalises_map (gen_ty,spec_ty))
d469 1
a469 1
      Scheme.generalises (ty1,ty2) handle Scheme.Mismatch => false
a845 2


d1116 1
@


1.32
log
@Fix the long standing (i.e. since before I started working on the debugger)
bug that if you step in the debugger and keep stepping until you return
to the top level (i.e. the debugger is now out of the loop) all functions
still have step code enabled i.e. if you run anything it will immediately
call the debugger!
@
text
@d6 7
d733 5
a737 1
          Debugger.break ("Entering: " ^ name ^ " " ^ arg_string);
d739 2
a740 1
          StackInterface.set_frame_return_value (frame, Value.cast (f a));
@


1.31
log
@Comment the recently changed step/break/next commands.
Also remove some redundant tests (famous last words!).
@
text
@d6 4
a636 1
      datatype Stepping = OFF | ONCE | CONTINUOUS
d638 18
a655 1
      val status = ref OFF
d664 1
a664 2
      val break_count = ref 0

d693 1
d704 1
a704 2
        | MLWorks.Option.NONE =>   ()

a714 4
       *
       * The break_count stuff is to ensure that if this is the last
       * active breakpoint then all the intercepts are restored to
       * their original state.  Can't remember why it is needed here!
a722 1
          break_count := !break_count + 1;
d725 1
d727 1
d729 1
a729 6
          break_count := !break_count - 1;
          if !break_count = 0 then
            (restore_intercepts ();
             status := OFF)
          else
            install_breakpoint (name, c)
d749 1
d757 1
a757 1
        case !status of
d761 1
a761 1
      
d787 4
a790 1
          trace_code_intercept (c, reinstall step_always_replacement);
d794 4
a797 1
             Debugger.break ("Entering: " ^ name ^ " " ^ arg_string));
d815 5
a819 1
          status := ONCE;
d821 2
a822 8
          StackInterface.set_frame_return_value (frame, Value.cast (f a));
          (*
           * Take account of the fact that the user might have altered
           * the stepping state during the debugger invocation.
           *)
          case !status of
            ONCE => (restore_intercepts (); status := OFF)
          | _ =>    ()
a830 3
          val is_a_break = fn s => case is_a_break s of
                                     MLWorks.Option.NONE => false
                                   | MLWorks.Option.SOME _ => true
d832 1
a832 1
          if function_name = "<Setup>" orelse is_a_break function_name then
d835 7
a841 1
            trace_code_replace (code, step)
d856 2
a857 2
          case !status of
            CONTINUOUS => ()
d861 1
a861 1
                status := CONTINUOUS)
d863 5
a867 3
          case !status of
            OFF => ()
          | _   => (restore_intercepts (); status := OFF)
d872 2
a873 1
         status := ONCE)
d877 1
a877 1
        case !status of
d882 1
d889 1
d1026 1
a1027 4
          val step_status_before_next_called = !status

          fun trace frame = ()
   
a1034 1
              val r = Value.cast (f a)
d1036 1
a1036 1
              StackInterface.set_frame_return_value (frame, r);
d1038 2
a1039 7
                CONTINUOUS => 
                  set_stepping true
              | _ =>
                  if !break_count <= 1 then
                    ()
                  else 
                    make_all_code_step_once ()
@


1.30
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d6 3
d637 3
d642 2
d646 2
d651 2
d656 1
d660 2
d668 1
d673 7
d681 6
a686 3
        (case assoc (name,!broken_functions) of
          MLWorks.Option.SOME _ => trace_code_replace (code, breakpoint)
        | MLWorks.Option.NONE =>   ())
d689 13
a701 1
      and breakpoint frame =
d709 1
a709 3
          (*
           * nop out the intercept to avoid an infinite loop.
           *)
a717 4
            (* 
             * re-install the breakpoint, but not if the user has
             * removed the breakpoint in the debugger.
             *)
d731 1
d743 1
d750 2
a751 1
      fun reinstall_function function frame =
d759 10
a768 1
      fun step_always frame =
d775 3
a777 6
          (if name <> "<Setup>" then
            (trace_code_intercept (c, reinstall_function step_always);
             (if !step_count > 0 then
               step_count := !step_count - 1
              else
                Debugger.break ("Entering: " ^ name ^ " " ^ arg_string)))
d779 1
a779 1
             ());
d784 6
a789 1
      fun step_once frame =
d797 2
a798 5
          (if name <> "<Setup>" then
            (status := ONCE;
             Debugger.break ("Entering: " ^ name ^ " " ^ arg_string))
           else
             ());
d810 1
a825 1
      val make_code_step_always = replace_with step_always
d827 6
a832 1
      val make_code_step_once = replace_with step_once
a875 1
      (* was end of Step *)
d927 2
d935 2
a936 5
          if stepping () then
            ()
          else
            (trace_set_code_loader_function restore;
             apply_all breakit)
d944 1
d975 1
a975 1
      fun breakpoints () = (*map #1 (!broken_functions)*)
d979 1
@


1.29
log
@Replacing Map with NewMap
@
text
@d6 3
d639 1
a639 1
	ref(NewMap.empty' String.<) : (string, {hits: int, max: int, name: string}) NewMap.T ref
@


1.28
log
@Add "next" which makes it possible for the debugger to step over a
function call.  In order to add this, had to change the way stepping
and breakpointing is implemented.
@
text
@d6 5
d309 1
a309 1
          Mapping.fold (fn (acc,ty) => tyvars_of (ty,acc)) (acc,labtys)
@


1.27
log
@Removing Option in favour of MLWorks.Option
@
text
@d6 3
d395 2
a396 2
              (trace_code_intercept (cv, fn _ => trace (cv, new));
               f' a)
d555 1
a587 14
      val step_count_ref = ref 0

      fun step_function frame = 
        if !step_count_ref > 0
          then step_count_ref := !step_count_ref -1
        else
          let
            val (name,arg_string,_) = get_frame_info frame
          in
	    if name <> "<Setup>" then
              Debugger.break ("Entering: " ^ name ^ " " ^ arg_string)
	    else
	      ()
          end
d605 79
a683 1
      fun breakit code = 
d687 130
a816 4
          case assoc (name,!broken_functions) of
            MLWorks.Option.SOME _ =>
              trace_code_intercept (code,break_function)
          | _ => ()
d819 3
a821 1
      fun stepalways code = trace_code_intercept (code,step_function)
a824 11
      (* STEPPING *)

      (* Reset the trace status according to the trace tables *)
      fun reset () =
          (Trace.restore_all ();
           step_count_ref := 0;
           trace_set_code_loader_function (fn code => (traceit code; breakit code));
           apply_all traceit;
           apply_all breakit)
        
      val step_on = ref false
a825 2
      fun maybe_reset () =
        if !step_on then () else reset ()
d841 1
d843 11
a853 6
        (traced_functions := update (name,(always,never),!traced_functions,[]);
         remove_breakpoint name;
         if !step_on then () 
         else
           (trace_set_code_loader_function (fn code => (traceit code; breakit code));
            apply_all traceit))
a854 7
      fun trace_full (name,f,g) =
        (traced_functions := update (name,(f,g),!traced_functions,[]);
         remove_breakpoint name;
         if !step_on then () 
         else
           (trace_set_code_loader_function (fn code => (traceit code; breakit code));
            apply_all traceit))
a855 2
      val breakpoint_table =
	ref(NewMap.empty' String.<) : (string, {hits: int, max: int, name: string}) NewMap.T ref
d857 12
a868 3
      fun is_a_break s = NewMap.tryApply'(!breakpoint_table, s)
      fun update_break(arg as {name, ...}) =
	breakpoint_table := NewMap.define'(!breakpoint_table, (name, arg))
a869 4
      fun add_break{hits, max, name} =
	breakpoint_table :=
	NewMap.define'(!breakpoint_table,
		       (name, {hits=hits, max=max, name=name}))
a870 2
      fun remove_break name =
	breakpoint_table := NewMap.undefine(!breakpoint_table, name)
d873 12
a884 6
        (broken_functions := update (name,(always,never),!broken_functions,[]);
         remove_traced name;
         if !step_on then ()
           else
             (trace_set_code_loader_function (fn code => (traceit code; breakit code));
              apply_all breakit))
d896 6
a901 1
      fun untrace name = (remove_traced name; maybe_reset ())
d903 4
a906 1
	(remove_breakpoint name; remove_break name; maybe_reset ())
d910 2
a911 1
         maybe_reset ())
d917 2
a918 1
         maybe_reset ())
d926 3
a928 5
        if b (* Put tracing on *)
          then
            apply_all tracealways
        else (* Put tracing off *)
          reset ()
a929 12
      fun set_stepping b =
        if b = !step_on
          then ()
        else
          if b (* Put stepping on *)
            then
              (apply_all stepalways;
               trace_set_code_loader_function stepalways;
               step_on := true)
          else (* Put stepping off *)
            (reset ();
             step_on := false)
a930 3
      fun set_step_count n =
        if n > 0 then step_count_ref := n-1
        else step_count_ref := 0
d932 13
a944 1
      fun step_through f a =
d946 25
a970 2
          val _ = set_stepping true
          val result = f a handle exn => (set_stepping false; raise exn)
d973 7
a979 1
          result
d982 1
a982 1
      fun step_state () = !step_on
a983 2
        
    end
@


1.26
log
@Add more structure to the breakpoint table to allow
multiple skipping of breakpoints, and breakpoint hit counting
@
text
@d6 4
d317 1
a317 1
        case Scheme.make_scheme (tyvars,(ty,Datatypes.Option.ABSENT)) of
d425 1
a425 1
                                                         Datatypes.Option.ABSENT),
d429 1
a429 1
                  Datatypes.FUNTYPE (Datatypes.DEBRUIJN (0,false,false,Datatypes.Option.ABSENT),
@


1.25
log
@Adding untrace_all
@
text
@d6 3
d132 1
d670 15
d693 4
a697 4
(*
        (traced_functions := namelist;
         maybe_reset ())
*)
d700 2
a701 6
      fun break_list namelist =
(*
        (broken_functions := namelist;
         maybe_reset ())
*)
        Lists.iterate break namelist
d704 2
a705 1
      fun unbreak name = (remove_breakpoint name; maybe_reset ())
d713 2
d717 3
a719 1
      fun breakpoints () = map #1 (!broken_functions)
@


1.24
log
@Step function now skips setup functions.
@
text
@d6 3
d690 8
@


1.23
log
@Removed get_stepping (it duplicated step_state).
@
text
@d6 3
d582 4
a585 1
            Debugger.break ("Entering: " ^ name ^ " " ^ arg_string)
@


1.22
log
@Adding type inference for returned values
@
text
@d6 3
a703 2

      fun get_stepping () = !step_on
@


1.21
log
@Merging trace_full and simple_trace functionality
@
text
@d6 3
d271 33
a303 1
    (* These functions should probably be in Types *)
a304 2
  
(*
d313 1
d318 2
d321 2
a322 2
          apply_instantiation (ty,
                               specialize (gen_ty,spec_ty))
a326 4
*)

    (* dummy for the moment *)
    fun instantiate_type (ty,gen_ty,spec_ty) = ty
d408 2
a409 1
                                                Datatypes.Option.ABSENT),Types.bool_type))
d412 2
a413 2
                  Datatypes.FUNTYPE (Datatypes.DEBRUIJN (0,false,false,
                                                Datatypes.Option.ABSENT),Types.bool_type))
d450 1
a450 1
            (if generalises (test_dom,fun_dom) andalso type_eq (test_ran,Types.bool_type)
d454 1
a454 1
               (implode [fun_name ^ ": Test function type not compatible with traced function:",
a455 1
                        "\n  test range: ", Types.debug_print_type test_ran,
d457 7
a463 1
             if generalises (break_dom,fun_dom) andalso type_eq (break_ran,Types.bool_type)
d467 1
a467 1
               (implode [fun_name ^ ": break function type not compatible with traced function:",
d469 7
a475 2
                         "\n  break range: ", Types.debug_print_type break_ran,
                         "\n  function domain: ", Types.debug_print_type fun_dom, "\n"]))
@


1.20
log
@Added get_stepping.
@
text
@d6 3
d139 1
a143 39
    (* Select from an object, with some checking for error cases *)
    (* A header of zero is possible if we are in a shared closure *)
    fun select field =
      if field < 0 then
        raise Value "select: negative field"
      else
        fn value =>
        let
          val primary = Value.primary value
        in
          if primary = Tags.PAIRPTR 
            then
              if field >= 2 
                then
                  raise Value "select: field >= 2 in pair"
              else
                Value.sub (value, field)
              else if primary = Tags.POINTER 
                     then
                       let
                         val (secondary, length) = Value.header value
                       in
                         if (secondary = Tags.INTEGER0 andalso field=0)
                           orelse (secondary = Tags.INTEGER1 andalso field=0)
                           then
                             Value.sub (value, 1)
                         else 
                           if secondary = Tags.RECORD then
                             if field >= length then
                               raise Value "select: field >= length in record"
                             else
                               Value.sub (value, field+1)
                           else
                             raise Value "select: invalid secondary"
                       end
                   else
                     raise Value "select: invalid primary"
        end

d175 7
a181 10
    fun get_function_string f =
      let
        val value = select 0 f
      in
        if
          Value.primary value = Tags.POINTER andalso
          #1 (Value.header value) = Tags.BACKPTR
          then
            Value.code_name value
        else
a182 1
      end
d184 1
a184 1
    fun get_function_name f =
d186 1
a186 1
        val code_name = get_function_string f
d196 2
d257 22
a278 2
            
      fun get_frame_info frame =
d280 4
a283 27
          val shell_data = !ShellTypes.shell_data_ref
          val user_options = ShellTypes.get_user_options shell_data
          val context = ShellTypes.get_current_context shell_data
          val name = StackInterface.frame_name frame
          val debug_info = Incremental.InterMake.current_debug_information ()
          val funinfo = DebuggerTypes.lookup_debug_info (debug_info,name)
          val arg_string =
            case funinfo of
              Option.SOME (DebuggerTypes.FUNINFO {ty,...}) =>
                let
                  val arg = StackInterface.frame_arg frame
                  val arg_type = funarg ty
                  val reconstructed_type = reconstruct_type (frame,arg_type,debug_info)
                  val argty = Types.combine_types (reconstructed_type,arg_type)
                                   handle Types.CombineTypes =>
                                     (fdebug (fn _ => 
                                             implode ["Combine types fails for: ",
                                                      name, "\n argtype: ",
                                                      Types.debug_print_type arg_type,
                                                      "\n reconstructed type: ",
                                                      Types.debug_print_type reconstructed_type]);
                                     arg_type)	
                  val print_options = UserOptions.new_print_options user_options
                in
                  ValuePrinter.stringify_value false (print_options,arg,argty,debug_info)
                end
              | _ => "<Unknown arg>"
d285 5
a289 1
          (strip_location name,arg_string)
d291 39
d335 2
a336 2
        val trace : ('a -> 'b) * (('a -> 'b) * 'a * Frame.frame -> 'b) -> unit
        val replace : ('a -> 'b) * ('c -> 'd) -> unit
d340 1
a340 5
        val arg_offset = 8
        fun update_arg (frame,value) = Frame.update (frame,arg_offset,value)
        fun get_arg frame = Frame.sub (frame,arg_offset)

        fun trace (f, new) =
d342 3
a344 3
            fun untraced_once a =
              (Trace.intercept (f, fn _ => trace (f, new));
               f a)
d348 5
a352 4
               update_arg (frame,
                           Value.cast (new (untraced_once,
                                        Value.cast (get_arg frame),
                                        frame))))
d354 1
a354 1
            Trace.replace (f, replacement)
d357 1
a357 1
        fun replace (f, new) =
d361 3
a363 1
               update_arg (frame,Value.cast (new (Value.cast (get_arg frame)))))
d365 1
a365 1
            Trace.replace (f, replacement)
a386 22
    fun replace ((fun_val,fun_ty),
                 (new_val,new_ty),
                 user_options,
                 get_context,
                 message_fn) =
      let
        fun do_error s = (message_fn s;raise Error)
      in
        if not (Types.isFunType fun_ty)
          then do_error "Cannot replace: replaced value not a function"
        else ();
        if not (Types.isFunType new_ty)
          then do_error "Cannot replace: new value not a function"
        else ();          
        (if generalises (new_ty,fun_ty)
           then ()
         else
           do_error ("Replace function not compatible with original");
         Test.replace (Value.cast fun_val,Value.cast new_val)
         handle Trace.Trace s => do_error ("Cannot replace: " ^ s))
      end

d389 1
a389 6
    fun trace_internal 
      entry_only (((fun_val,fun_ty),
                   (test_val,test_ty),
                   (break_val,break_ty)),
                  user_options,get_context,
                  message_fn) =
d391 3
a395 3
        if not (Types.isFunType fun_ty)
          then do_error "Cannot trace value: not a function"
        else ();
d406 1
a406 1
              val debug_info = Incremental.debug_info (get_context())
d410 2
a411 2
              
          val (fun_dom,fun_ran) = Types.argres fun_ty
d414 1
d419 6
a424 1
             else do_error "Test function type not compatible with traced function";
d427 6
a432 2
             else do_error "Break function type not compatible with traced function")
          val fun_name = strip_location (get_function_name fun_val)
d446 1
a446 1
                     val (name,arg) = get_frame_info frame
d459 1
a459 1
                     val (name,arg) = get_frame_info frame
d473 1
a473 1
                     P (name ^ " returns " ^ string_value (result,fun_ran) ^ "\n");
d480 1
a480 1
                      val (name,arg) = get_frame_info frame
a491 15
    fun trace (function,user_options,context_fn,message_fn) =
      trace_internal false ((function,always,never),user_options,context_fn,message_fn)

    fun breakpoint (function,user_options,context_fn,message_fn) =
      trace_internal false ((function,always,always),user_options,context_fn,message_fn)

    val trace_full = trace_internal false

    fun untrace ((value,ty),message_fun) =
      if Types.isFunType ty
        then Trace.restore (Value.cast value)
          handle Trace.Trace s =>
            message_fun ("Cannot untrace " ^ get_function_name value ^ ": " ^ s)
      else message_fun ("Cannot untrace value: not a function")

d494 2
a495 2
      val traced_functions : string list ref = ref [] 
      val broken_functions : string list ref = ref []
d498 3
a500 3
        | remove' (s,a::b,acc) =
          if s = a then (rev acc) @@ b
          else remove' (s,b,a::acc)
d512 1
a512 1
          val (name,arg_string) = get_frame_info frame
d519 1
a519 1
          val (name,arg_string) = get_frame_info frame
d531 1
a531 1
            val (name,arg_string) = get_frame_info frame
d536 6
d546 4
a549 5
          if Lists.exists 
            (fn s => size name >=  size s andalso String.substring (name,0,size s) = s)
            (!traced_functions)
            then trace_code_intercept (code,trace_function)
          else ()
d556 4
a559 5
          if Lists.exists 
            (fn s => size name >=  size s andalso String.substring (name,0,size s) = s)
            (!broken_functions)
            then trace_code_intercept (code,break_function)
          else ()
d588 10
a597 6
      fun simple_trace name =
        (if Lists.member (name,!traced_functions)
           then ()
         else 
           (traced_functions := name :: !traced_functions;
            remove_breakpoint name);
d603 11
a613 6
      fun simple_break name =
        (if Lists.member (name,!broken_functions)
           then ()
         else 
           (broken_functions := name :: !broken_functions;
            remove_traced name);
d619 2
a620 1
      fun simple_trace_list namelist =
d623 2
d626 2
a627 1
      fun simple_break_list namelist =
d630 2
d633 2
a634 2
      fun simple_untrace name = (remove_traced name; maybe_reset ())
      fun simple_unbreak name = (remove_breakpoint name; maybe_reset ())
d636 2
a637 2
      fun simple_breakpoints () = !broken_functions
      fun simple_traces () = !traced_functions
d676 1
d678 62
@


1.19
log
@Adding trace_all function
@
text
@d6 3
d669 2
@


1.18
log
@Split user_options into tool-specific and context-specific parts.
@
text
@d6 3
d122 1
d305 11
a315 1
                  val argty = reconstruct_type (frame,funarg ty,debug_info)
a538 1
          (* val _ = P (trim (StackInterface.frame_name frame,20)) *)
d551 12
d585 3
a587 1
      fun breakalways code = trace_code_intercept (code,break_function)
d594 2
d647 7
d660 2
a661 1
              (apply_all breakalways;
d666 4
@


1.17
log
@Changing Scheme.generalises
@
text
@d6 3
d76 23
a98 21
functor Trace (structure Lists : LISTS
               structure Types : TYPES
               structure Scheme : SCHEME
               structure UserOptions : USER_OPTIONS
               structure Tags : TAGS
               structure Incremental : INCREMENTAL
               structure ShellTypes : SHELL_TYPES
               structure ValuePrinter : VALUE_PRINTER
               structure StackInterface : STACK_INTERFACE
               structure DebuggerUtilities : DEBUGGER_UTILITIES

               sharing ValuePrinter.Options = UserOptions.Options
               sharing Types.Datatypes = Scheme.Datatypes

               sharing type Incremental.Context = ShellTypes.Context
               sharing type UserOptions.user_options = ShellTypes.user_options
               sharing type ValuePrinter.Type = Types.Datatypes.Type = DebuggerUtilities.Debugger_Types.Type
               sharing type ValuePrinter.DebugInformation = Incremental.InterMake.Compiler.DebugInformation =
                 DebuggerUtilities.Debugger_Types.information

               ) : TRACE =
d111 1
a111 1
    type UserOptions = UserOptions.user_options
d302 1
a302 1
                  val Options.OPTIONS{print_options,...} = UserOptions.new_options user_options
d413 1
a413 1
              val Options.OPTIONS{print_options,...} = UserOptions.new_options user_options
@


1.16
log
@Changing uses of cast (again)
@
text
@d6 3
d110 2
d184 14
a269 38
(*
    fun gather_recipes (frame,acc,debug_info) =
      let
        val (another,next,offset) = Frame.frame_next frame
      in
        if offset <> 0 (* It's an ML frame *)
          then
            let
              val frame_name = StackInterface.frame_name next
            in
              case DebuggerTypes.lookup_debug_info (debug_info,frame_name) of
                Option.SOME (DebuggerTypes.FUNINFO {ty,annotations,...}) =>
                  let
                    val argty = funarg ty
                    val byte_offset = 4 * offset
                    val recipe = 
                      case assoc (byte_offset,annotations) of
                        Option.SOME recipe => recipe
                      | _ => raise TypeReconstructionFailed 
                          ("Annotation for offset " ^ MLWorks.Integer.makestring byte_offset ^
                           " not found in " ^ frame_name)
                  in
                    if DebuggerUtilities.is_type_polymorphic argty
                      then
                        if another then gather_recipes (next,recipe::acc,debug_info)
                        else raise TypeReconstructionFailed "No more frames"
                    else
                      (argty,recipe::acc)
                  end
              | _ => gather_recipes (next,DebuggerTypes.NOP :: acc, debug_info) (* raise TypeReconstructionFailed ("No funinfo for " ^ frame_name) *)
            end
        else
          if StackInterface.is_stack_extension_frame next
            then gather_recipes (next,acc,debug_info)
          else gather_recipes (next,DebuggerTypes.NOP :: acc, debug_info) (* raise TypeReconstructionFailed ("Not an ML stack frame") *)
      end
*)

d303 1
a303 1
          (name,arg_string)
d361 1
a361 1
      Scheme.generalises (ty1,ty2) handle Scheme.MisMatch _ => false
a413 5
          fun print (label,x,ty) =
            output(std_out,label ^ string_value (x,ty) ^ "\n")

          fun newprint (label,name,arg) =
            output(std_out,label ^ name ^ " " ^ arg ^ "\n")
d425 1
a425 3
          val name = get_function_name fun_val
          val in_label = name ^ " "
          val out_label = name ^ " returns "
d441 1
a441 2
(*                     val _ = print (in_label,a,fun_dom) *)
                     val _ = newprint (in_label,name,arg)
d456 1
a456 2
(*                     val _ = print (in_label,a,fun_dom) *)
                     val _ = newprint (in_label,name,arg)
d466 1
a466 1
                     print(out_label,result,fun_ran);
d472 5
a476 1
                    Debugger.break ("Function entry: " ^ name ^ " " ^ string_value(a,fun_dom))
d481 1
a481 1
            message_fn ("Cannot trace " ^ name ^ ": " ^ s)
d523 1
a523 1
          P (name ^ arg_string ^ "\n")
d530 1
a530 1
          Debugger.break ("Entering: " ^ name ^ arg_string)
@


1.15
log
@Adding newline after trace output.
@
text
@d6 3
a110 1
    val castit : 'a -> 'b = Value.cast (fn x => x)
d114 1
a114 1
      fun env s = castit (MLWorks.Internal.Runtime.environment s)
d347 2
a348 2
                           castit (new (untraced_once,
                                        castit (get_arg frame),
d358 1
a358 1
               update_arg (frame,castit (new (castit (get_arg frame)))))
d369 1
a369 1
    val always = ((castit (fn _ => true)) : Value.T,
d373 1
a373 1
    val never = ((castit (fn _ => false)) : Value.T,
d400 1
a400 1
         Test.replace (castit fun_val,castit new_val)
d454 1
a454 1
          ((castit fun_val),
d458 2
a459 2
             val do_output = ((castit test_val) a) : bool
             val do_break = ((castit break_val) a) : bool
d519 1
a519 1
        then Trace.restore (castit value)
@


1.14
log
@Switching off debugger messages
@
text
@d6 3
d545 1
a545 1
          P (name ^ arg_string)
@


1.13
log
@New step and breakpoint functionality
@
text
@d6 3
d101 3
d290 1
a290 1
            (output (std_out,"Recipe Application failed: " ^ s ^ "\n");
d293 1
a293 1
                   (output (std_out,"Type Reconstruction Failed: " ^ s ^ "\n");
a520 1
      fun P s = output (std_out,s ^ "\n")
@


1.12
log
@Adding StackInterface structure
@
text
@d6 3
d86 5
d99 12
a110 1
    val cast = MLWorks.Internal.Value.cast
d112 1
d120 1
a120 1
          val primary = MLWorks.Internal.Value.primary value
d128 1
a128 1
                MLWorks.Internal.Value.sub (value, field)
d132 1
a132 1
                         val (secondary, length) = MLWorks.Internal.Value.header value
d137 1
a137 1
                             MLWorks.Internal.Value.sub (value, 1)
d143 1
a143 1
                               MLWorks.Internal.Value.sub (value, field+1)
d150 2
a151 1
      
d168 1
a168 1
    fun get_code_name f =
d173 2
a174 2
          MLWorks.Internal.Value.primary value = Tags.POINTER andalso
          #1 (MLWorks.Internal.Value.header value) = Tags.BACKPTR
d176 1
a176 1
            MLWorks.Internal.Value.code_name value
d183 1
a183 1
        val code_name = get_code_name f
d189 127
d318 1
a318 1
        val trace : ('a -> 'b) * (('a -> 'b) * 'a -> 'b) -> unit
a322 2
        structure Trace = MLWorks.Internal.Trace;
        structure Frame = MLWorks.Internal.Value.Frame
a325 1
        val cast = MLWorks.Internal.Value.cast
d336 3
a338 2
                           cast (new (untraced_once,
                                      cast (get_arg frame)))))
d347 1
a347 1
               update_arg (frame,cast (new (cast (get_arg frame)))))
d354 1
d358 1
a358 1
    val always = ((cast (fn _ => true)) : MLWorks.Internal.Value.T,
d362 1
a362 1
    val never = ((cast (fn _ => false)) : MLWorks.Internal.Value.T,
a365 3
    fun funarg (Datatypes.FUNTYPE (t,_)) = t
      | funarg _ = Datatypes.NULLTYPE

a367 1

d389 2
a390 3
         Test.replace (cast fun_val,cast new_val)
         handle MLWorks.Internal.Trace.Trace s =>
           do_error ("Cannot replace: " ^ s))
d392 3
a394 1
          
d425 2
d432 1
a432 1
            (if generalises (test_dom,fun_dom) andalso generalises (test_ran,Types.bool_type)
d435 1
a435 1
             if generalises (break_dom,fun_dom) andalso generalises (break_ran,Types.bool_type)
d443 2
a444 2
          ((cast fun_val),
           fn (f,a) =>
d446 3
a448 2
             val do_output = ((cast test_val) a) : bool
             val do_break = ((cast break_val) a) : bool
d454 4
a457 1
                     val _ = print (in_label,a,fun_dom)
d461 1
a461 1
                           MLWorks.Debugger.break ("Function entry: " ^ name ^ " " ^ string_value(a,fun_dom))
d468 1
d472 2
a473 1
                     val _ = print (in_label,a,fun_dom)
d477 1
a477 1
                           MLWorks.Debugger.break ("Function entry: " ^ name ^ " " ^ string_value(a,fun_dom))
d489 1
a489 1
                    MLWorks.Debugger.break ("Function entry: " ^ name ^ " " ^ string_value(a,fun_dom))
d493 1
a493 1
          handle MLWorks.Internal.Trace.Trace s =>
d508 2
a509 2
        then MLWorks.Internal.Trace.restore (cast value)
          handle MLWorks.Internal.Trace.Trace s =>
d514 1
a514 9
      fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
    in
      (* apply_all applies an ML function to all code objects compiled with tracing on *)
      val apply_all : (('a -> 'b) -> unit) -> unit = env "trace ml apply all"
    end

    local
      open MLWorks.Internal.Value
      fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
d524 1
a528 91
      datatype Code = CODE of int
      val apply_all : (Code -> unit) -> unit = env "trace ml apply all"
      val trace_code_intercept : Code * ('a -> unit) -> unit = env "trace code intercept"
      val trace_set_code_loader_function : (Code -> unit) -> unit = env "trace set code loader function"
      val trace_unset_code_loader_function : (unit -> unit) -> unit = env "trace unset code loader function"

      val code_name : Code -> string = cast (MLWorks.Internal.Value.code_name)

      fun assoc (a,[]) = MLWorks.Option.NONE
        | assoc (a,(a',b)::rest) =
          if a = a' then MLWorks.Option.SOME b
          else assoc (a,rest)

      exception TypeReconstructionFailed of string

      fun infer_types (ty,[]) = ty
        | infer_types (ty,recipe::rest) =
          infer_types (DebuggerUtilities.apply_recipe (recipe,ty),rest)

      (* This scans down the stack and collects up recipes *)
      fun gather_recipes (frame,acc,debug_info) =
        let
          val (another,next,offset) = MLWorks.Internal.Value.Frame.frame_next frame
        in
          if offset <> 0 (* It's an ML frame *)
            then
              let
                val frame_name = StackInterface.frame_name next
              in
                case DebuggerTypes.lookup_debug_info (debug_info,frame_name) of
                  MLWorks.Option.SOME (DebuggerTypes.FUNINFO {ty,annotations,...}) =>
                    let
                      val argty = funarg ty
                        val byte_offset = 4 * offset
                      val recipe = 
                        case assoc (byte_offset,annotations) of
                          MLWorks.Option.SOME recipe => recipe
                        | _ => raise TypeReconstructionFailed 
                            ("Annotation for offset " ^ MLWorks.Integer.makestring byte_offset ^
                             " not found in " ^ frame_name)
                    in
                      if DebuggerUtilities.is_type_polymorphic argty
                        then
                          if another then gather_recipes (next,recipe::acc,debug_info)
                          else raise TypeReconstructionFailed "No more frames"
                      else
                        (argty,recipe::acc)
                    end
                | _ => raise TypeReconstructionFailed ("No funinfo for " ^ frame_name)
              end
          else
            if StackInterface.is_stack_extension_frame next
              then gather_recipes (next,acc,debug_info)
            else raise TypeReconstructionFailed ("Not an ML stack frame")
        end

      fun reconstruct_type (frame,ty,debug_info) =
        if DebuggerUtilities.is_type_polymorphic ty
          then 
            (infer_types (gather_recipes (frame,[],debug_info)))
            handle DebuggerUtilities.ApplyRecipe s =>
              (output (std_out,"Recipe Application failed: " ^ s ^ "\n");
               ty)
                 | TypeReconstructionFailed s => 
                     (output (std_out,"Type Reconstruction Failed: " ^ s ^ "\n");
                      ty)
        else ty
            
      fun get_frame_info frame =
        let
          val shell_data = !ShellTypes.shell_data_ref
          val user_options = ShellTypes.get_user_options shell_data
          val context = ShellTypes.get_current_context shell_data
          val name = StackInterface.frame_name frame
          val debug_info = Incremental.InterMake.current_debug_information ()
          val funinfo = DebuggerTypes.lookup_debug_info (debug_info,name)
          val arg_string =
            case funinfo of
              MLWorks.Option.SOME (DebuggerTypes.FUNINFO {ty,...}) =>
                let
                  val arg = StackInterface.frame_arg frame
                  val argty = reconstruct_type (frame,funarg ty,debug_info)
                  val Options.OPTIONS{print_options,...} = UserOptions.new_options user_options
                in
                  ValuePrinter.stringify_value false (print_options,arg,argty,debug_info)
                end
              | _ => "<Unknown arg>"
        in
          (name,arg_string)
        end

d544 1
a544 1
          MLWorks.Debugger.break ("Entering: " ^ name ^ arg_string)
d549 1
a549 1
          val name = code_name code
d560 1
a560 1
          val name = code_name code
d571 16
d590 1
d597 4
a600 2
         trace_set_code_loader_function (fn code => (traceit code; breakit code));
         apply_all traceit)
d608 12
a619 2
         trace_set_code_loader_function (fn code => (traceit code; breakit code));
         apply_all breakit)
d621 5
a625 7
      fun reset () =
          (MLWorks.Internal.Trace.restore_all ();
           apply_all traceit;
           apply_all breakit)
        
      fun simple_untrace name = (remove_traced name; reset ())
      fun simple_unbreak name = (remove_breakpoint name; reset ())
d628 22
a649 5
        if b (* Put stepping on *)
          then
            apply_all breakalways
        else (* Put stepping off *)
          reset ()
@


1.11
log
@Adding breakpoint function
Perhaps also working on type reconstruction
@
text
@d6 4
d52 1
d66 1
d411 1
a411 1
                val frame_name = DebuggerUtilities.frame_name next
d435 1
a435 1
            if DebuggerUtilities.is_stack_extension_frame next
d457 1
a457 1
          val name = DebuggerUtilities.frame_name frame
d464 1
a464 1
                  val arg = DebuggerUtilities.frame_arg frame
d480 1
a480 1
          (* val _ = P (trim (DebuggerUtilities.frame_name frame,20)) *)
@


1.10
log
@Change bogus code test.
@
text
@d6 3
d41 1
a43 1
require "../interpreter/incremental";
d46 3
d53 2
a54 1
functor Trace (structure Types : TYPES
d56 2
d59 1
a59 1
               structure UserOptions : USER_OPTIONS
d61 1
a61 1
               structure Tags : TAGS
d66 5
a70 3
               sharing type ValuePrinter.Type = Types.Datatypes.Type
               sharing type ValuePrinter.DebugInformation =
                 Incremental.InterMake.Compiler.DebugInformation
d75 1
d77 1
d82 1
a82 35
    structure Test :
      sig
        val trace : ('a -> 'b) * (('a -> 'b) * 'a -> 'b) -> unit
        val replace : ('a -> 'b) * ('c -> 'd) -> unit
      end =
      struct
        structure Trace = MLWorks.Internal.Trace;
        structure SPARC = MLWorks.Internal.Architecture.SPARC;
        val cast = MLWorks.Internal.Value.cast
        fun trace (f, new) =
          let
            fun untraced_once a =
              (Trace.intercept (f, fn _ => trace (f, new));
               f a)

            val replacement =
              (fn frame =>
               SPARC.Frame.update
               (frame, 8,
                cast (new (untraced_once,
                           cast (SPARC.Frame.sub (frame, 8))))))
          in
            Trace.replace (f, replacement)
          end
        fun replace (f, new) =
          let
            val replacement =
              (fn frame =>
               SPARC.Frame.update
               (frame, 8,
                cast (new (cast (SPARC.Frame.sub (frame, 8))))))
          in
            Trace.replace (f, replacement)
          end
      end
d84 1
a86 30
    val indent_level = ref 0
    fun outspaces 0 = () | outspaces n = (output(std_out,"  ");outspaces(n-1))

    (* from _value_printer *)
    exception Value of string
    fun get_code_name value =
      if
        MLWorks.Internal.Value.primary value = Tags.POINTER andalso
	#1 (MLWorks.Internal.Value.header value) = Tags.BACKPTR
      then
        MLWorks.Internal.Value.code_name value
      else
        raise Value "code_name: not a code item"

    (* from ml_debugger *)
    fun get_name_and_location code_name =
      let
        fun aux1("["::l,acc) = (acc,l)
          | aux1(c::l,acc) = aux1(l,c::acc)
          | aux1([],acc) = (acc,[])
        fun aux2(["]"],acc) = acc
          | aux2("]"::l,acc) = acc
          | aux2(c::l,acc) = aux2(l,c::acc)
          | aux2([],acc) = acc
        val (namechars,rest) = aux1(explode code_name,[])
        val locchars = aux2 (rest,[])
      in
        (implode(rev namechars),implode(rev locchars))
      end

d125 30
a154 1
    fun get_function_name value =
d156 1
a156 1
        val code_name = get_code_name (select 0 value)
d162 43
d213 3
d245 6
a250 5
    fun trace_full (((fun_val,fun_ty),
                     (test_val,test_ty),
                     (break_val,break_ty)),
                    user_options,get_context,
                    message_fn) =
d269 1
a269 2
              ValuePrinter.stringify_value false
              (print_options,value,ty,debug_info)
d299 29
a327 17
                 let
                   val level = !indent_level
                   val _ = indent_level := (!indent_level) + 1
                   val _ = outspaces level
                   val _ = print (in_label,a,fun_dom)
                   val _ = 
                     if do_break
                       then
                         MLWorks.Debugger.break ("Function entry: " ^ name ^ " " ^ string_value(a,fun_dom))
                     else ()
                   val result = f a handle exn => (indent_level := level;raise exn)
                 in
                   indent_level := level;
                   outspaces level;
                   print(out_label,result,fun_ran);
                   result
                 end
d340 5
d346 1
a346 2
    fun trace (function,user_options,context_fn,message_fn) =
      trace_full ((function,always,never),user_options,context_fn,message_fn)
d355 192
a547 1

@


1.9
log
@New runtime directory structure.
@
text
@d6 3
d115 1
a115 3
        (#1 (MLWorks.Internal.Value.header value) = Tags.CODE
         orelse
         #1 (MLWorks.Internal.Value.header value) = Tags.BACKPTR)
d119 1
a119 1
        raise Value "code_name: not a code vector"
@


1.8
log
@Added call to message_fn in untrace
;
@
text
@d6 4
d39 1
a39 1
require "../rts/tags";
@


1.7
log
@Boolean indicator for Monomorphic debugger decapsulation.
@
text
@d6 3
d257 2
a258 2
            val in_label = name ^ " "
            val out_label = name ^ " returns "
d305 2
@


1.6
log
@ Added function replacement functions
@
text
@d6 3
d235 1
a235 1
              ValuePrinter.stringify_value
@


1.5
log
@Instances in DEBRUIJNs for polymorphic debugger.
@
text
@d6 3
d58 2
a59 1
        val trace : ('a -> 'b) * (('a -> 'b) * 'a -> 'b) -> unit 
d64 1
a66 2
            val cast = MLWorks.Internal.Value.cast

d80 10
d181 28
d244 7
a250 11
            ((if Scheme.generalises (test_dom,fun_dom) andalso
                Scheme.generalises (test_ran,Types.bool_type)
                then ()
              else do_error "Test function type not compatible with traced function")
             handle Scheme.MisMatch _ => do_error "Test function type not compatible with traced function";
             (if Scheme.generalises (break_dom,fun_dom) andalso
                Scheme.generalises (break_ran,Types.bool_type)
                then ()
              else do_error "Break function type not compatible with traced function")
              handle Scheme.MisMatch _ => do_error "Break function type not compatible with traced function")
            val name = get_function_name fun_val
@


1.4
log
@Added message_fn parameter.
Report problems by calling message_fn rather than raising exceptions
@
text
@d6 4
d160 2
a161 1
                  Datatypes.FUNTYPE (Datatypes.DEBRUIJN (0,false,false),Types.bool_type))
d164 2
a165 1
                  Datatypes.FUNTYPE (Datatypes.DEBRUIJN (0,false,false),Types.bool_type))
@


1.4.1.1
log
@Fork for bug fixing
@
text
@a5 4
Revision 1.4  1993/08/19  11:39:21  matthew
Added message_fn parameter.
Report problems by calling message_fn rather than raising exceptions

@


1.3
log
@Changed format of tracing messages.
@
text
@d6 3
a154 2
    exception NotFunction

d161 1
a161 3
    exception InvalidTraceCondition
    exception InvalidBreakCondition

d165 23
a187 12
                    user_options,get_context) =
      if Types.isFunType fun_ty andalso Types.isFunType test_ty andalso Types.isFunType break_ty
        then
          let
            fun string_value (value,ty) =
              let
                val Options.OPTIONS{print_options,...} = UserOptions.new_options user_options
                val debug_info = Incremental.debug_info (get_context())
              in
                ValuePrinter.stringify_value
                (print_options,value,ty,debug_info)
              end
d189 2
a190 2
            fun print (label,x,ty) =
              output(std_out,label ^ string_value (x,ty) ^ "\n")
d192 15
a206 15
            val (fun_dom,fun_ran) = Types.argres fun_ty
            val (test_dom,test_ran) = Types.argres test_ty
            val (break_dom,break_ran) = Types.argres break_ty
            val _ = 
              (* Tedious correctness checking *)
              ((if Scheme.generalises (test_dom,fun_dom) andalso
                  Scheme.generalises (test_ran,Types.bool_type)
                  then ()
                else raise InvalidTraceCondition)
                handle Scheme.MisMatch _ => raise InvalidTraceCondition;
               (if Scheme.generalises (break_dom,fun_dom) andalso
                  Scheme.generalises (break_ran,Types.bool_type)
                  then ()
                else raise InvalidBreakCondition)
                  handle Scheme.MisMatch _ => raise InvalidBreakCondition)
d210 32
a241 32
          in
            Test.trace
            ((cast fun_val),
             fn (f,a) =>
             let
               val do_output = ((cast test_val) a) : bool
               val do_break = ((cast break_val) a) : bool
             in
               if do_output
                 then
                   let
                     val level = !indent_level
                     val _ = indent_level := (!indent_level) + 1
                     val _ = outspaces level
                     val _ = print (in_label,a,fun_dom)
                     val _ = 
                       if do_break
                         then
                           MLWorks.Debugger.break ("Function entry: " ^ name ^ " " ^ string_value(a,fun_dom))
                       else ()
                     val result = f a handle exn => (indent_level := level;raise exn)
                   in
                     indent_level := level;
                     outspaces level;
                     print(out_label,result,fun_ran);
                     result
                   end
               else
                 (if do_break
                    then
                      MLWorks.Debugger.break ("Function entry: " ^ name ^ " " ^ string_value(a,fun_dom))
                  else ();
d243 6
a248 3
             end)
          end
      else raise NotFunction
d250 2
a251 2
    fun trace (function,user_options,context_fn) =
      trace_full ((function,always,never),user_options,context_fn)
d253 1
a253 1
    fun untrace (value,ty) =
d256 1
a256 1
      else raise NotFunction
@


1.2
log
@Added untrace function
@
text
@d6 3
d198 2
a199 2
            val in_label = name ^ " -> "
            val out_label = name ^ " <- "
@


1.1
log
@Initial revision
@
text
@d6 3
d236 6
@
