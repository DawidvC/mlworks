head	1.186;
access;
symbols
	MLW_daveb_inline_1_4_99:1.186.1
	MLWorks_21c0_1999_03_25:1.186
	MLWorks_20c1_1998_08_20:1.185
	MLWorks_20c0_1998_08_04:1.185
	MLWorks_20b2c2_1998_06_19:1.185
	MLWorks_20b2_Windows_1998_06_12:1.185
	MLWorks_20b1c1_1998_05_07:1.185
	MLWorks_20b0_1998_04_07:1.183
	MLWorks_20b0_1998_03_20:1.181
	MLWorks_20m2_1998_02_16:1.177
	MLWorks_20m1_1997_10_23:1.174
	MLWorks_11r1:1.170.1.1.1.1.1
	MLWorks_workspace_97:1.173.2
	MLWorks_dt_wizard:1.173.1
	MLWorks_11c0_1997_09_09:1.170.1.1.1.1
	MLWorks_10r3:1.170.1.1.3
	MLWorks_10r2_551:1.170.1.1.2
	MLWorks_11:1.170.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.170.1.1
	MLWorks_20m0_1997_06_20:1.172
	MLWorks_1_0_r2c2_1997_06_14:1.170.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.170.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.170.1
	MLWorks_BugFix_1997_04_24:1.170
	MLWorks_1_0_r2_Win32_1997_04_11:1.170
	MLWorks_1_0_r2_Unix_1997_04_04:1.170
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.166.3.1.1
	MLWorks_gui_1996_12_18:1.166.4
	MLWorks_1_0_Win32_1996_12_17:1.166.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.166.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.166.1.1
	MLWorks_1_0_Irix_1996_11_28:1.166.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.166.2
	MLWorks_1_0_Unix_1996_11_14:1.166.1
	MLWorks_Open_Beta2_1996_10_11:1.162.2
	MLWorks_License_dev:1.162.1
	MLWorks_1_open_beta_1996_09_13:1.161.1
	MLWorks_Open_Beta_1996_08_22:1.161
	MLWorks_Beta_1996_07_02:1.159
	MLWorks_Beta_1996_06_07:1.156
	MLWorks_Beta_1996_06_06:1.156
	MLWorks_Beta_1996_06_05:1.156
	MLWorks_Beta_1996_06_03:1.156
	MLWorks_Beta_1996_05_31:1.156
	MLWorks_Beta_1996_05_30:1.155
	ML_beta_release_12/08/94:1.94
	ML_beta_release_03/08/94:1.94
	ML_revised_beta_release_25/05/94:1.89
	ML_final_beta_release_02/03/94:1.89
	mlworks-28-01-1994:1.86
	Release:1.78
	mlworks-beta-01-09-1993:1.78
	MLWorks-1-0-4-29/01/1993:1.49
	MLWorks-1-0-3-21/12/1992:1.49
	MLWorks-1-0-2-15/12/1992:1.46
	MLWorks-1-0-1-04/12/1992:1.42
	checkpoint_17_08_92:1.12;
locks; strict;
comment	@ * @;


1.186
date	99.02.02.15.59.08;	author mitchell;	state Exp;
branches
	1.186.1.1;
next	1.185;

1.185
date	98.04.22.17.12.57;	author jont;	state Exp;
branches;
next	1.184;

1.184
date	98.04.16.11.01.54;	author jont;	state Exp;
branches;
next	1.183;

1.183
date	98.03.31.13.04.37;	author jont;	state Exp;
branches;
next	1.182;

1.182
date	98.03.23.14.36.31;	author jont;	state Exp;
branches;
next	1.181;

1.181
date	98.03.02.15.07.22;	author mitchell;	state Exp;
branches;
next	1.180;

1.180
date	98.02.19.20.16.47;	author mitchell;	state Exp;
branches;
next	1.179;

1.179
date	98.02.18.16.55.25;	author jont;	state Exp;
branches;
next	1.178;

1.178
date	98.02.10.16.01.52;	author jont;	state Exp;
branches;
next	1.177;

1.177
date	98.02.05.12.11.08;	author jont;	state Exp;
branches;
next	1.176;

1.176
date	97.11.25.10.43.26;	author jont;	state Exp;
branches;
next	1.175;

1.175
date	97.11.10.16.58.35;	author jont;	state Exp;
branches;
next	1.174;

1.174
date	97.09.18.14.36.41;	author brucem;	state Exp;
branches;
next	1.173;

1.173
date	97.07.21.16.47.26;	author jont;	state Exp;
branches
	1.173.1.1
	1.173.2.1;
next	1.172;

1.172
date	97.05.21.17.02.51;	author jont;	state Exp;
branches;
next	1.171;

1.171
date	97.05.02.17.06.02;	author jont;	state Exp;
branches;
next	1.170;

1.170
date	97.03.21.15.43.26;	author matthew;	state Exp;
branches
	1.170.1.1;
next	1.169;

1.169
date	97.03.20.14.50.05;	author stephenb;	state Exp;
branches;
next	1.168;

1.168
date	97.03.07.16.43.08;	author matthew;	state Exp;
branches;
next	1.167;

1.167
date	96.12.18.14.24.52;	author stephenb;	state Exp;
branches;
next	1.166;

1.166
date	96.11.07.17.27.53;	author stephenb;	state Exp;
branches
	1.166.1.1
	1.166.2.1
	1.166.3.1
	1.166.4.1;
next	1.165;

1.165
date	96.11.07.14.33.56;	author stephenb;	state Exp;
branches;
next	1.164;

1.164
date	96.11.06.11.23.09;	author matthew;	state Exp;
branches;
next	1.163;

1.163
date	96.10.31.14.09.40;	author io;	state Exp;
branches;
next	1.162;

1.162
date	96.09.27.12.40.40;	author stephenb;	state Exp;
branches
	1.162.1.1
	1.162.2.1;
next	1.161;

1.161
date	96.08.06.14.47.21;	author andreww;	state Exp;
branches
	1.161.1.1;
next	1.160;

1.160
date	96.08.01.12.49.18;	author jont;	state Exp;
branches;
next	1.159;

1.159
date	96.06.27.14.37.08;	author stephenb;	state Exp;
branches;
next	1.158;

1.158
date	96.06.19.10.41.31;	author stephenb;	state Exp;
branches;
next	1.157;

1.157
date	96.06.17.15.37.54;	author stephenb;	state Exp;
branches;
next	1.156;

1.156
date	96.05.30.13.09.08;	author daveb;	state Exp;
branches;
next	1.155;

1.155
date	96.05.21.11.12.28;	author stephenb;	state Exp;
branches;
next	1.154;

1.154
date	96.05.17.09.58.11;	author matthew;	state Exp;
branches;
next	1.153;

1.153
date	96.05.01.10.16.56;	author jont;	state Exp;
branches;
next	1.152;

1.152
date	96.04.29.15.04.24;	author matthew;	state Exp;
branches;
next	1.151;

1.151
date	96.04.23.11.36.14;	author daveb;	state Exp;
branches;
next	1.150;

1.150
date	96.04.18.15.17.50;	author jont;	state Exp;
branches;
next	1.149;

1.149
date	96.04.15.12.06.34;	author stephenb;	state Exp;
branches;
next	1.148;

1.148
date	96.04.15.10.27.34;	author stephenb;	state Exp;
branches;
next	1.147;

1.147
date	96.04.04.13.31.13;	author stephenb;	state Exp;
branches;
next	1.146;

1.146
date	96.04.01.12.54.31;	author stephenb;	state Exp;
branches;
next	1.145;

1.145
date	96.03.15.12.08.56;	author stephenb;	state Exp;
branches;
next	1.144;

1.144
date	96.03.05.14.21.37;	author stephenb;	state Exp;
branches;
next	1.143;

1.143
date	96.02.29.15.11.46;	author stephenb;	state Exp;
branches;
next	1.142;

1.142
date	96.02.28.12.18.02;	author stephenb;	state Exp;
branches;
next	1.141;

1.141
date	96.02.27.11.27.45;	author stephenb;	state Exp;
branches;
next	1.140;

1.140
date	96.02.26.14.02.18;	author stephenb;	state Exp;
branches;
next	1.139;

1.139
date	96.02.23.16.30.32;	author stephenb;	state Exp;
branches;
next	1.138;

1.138
date	96.02.22.14.43.39;	author jont;	state Exp;
branches;
next	1.137;

1.137
date	96.02.22.14.29.28;	author stephenb;	state Exp;
branches;
next	1.136;

1.136
date	96.02.21.11.22.32;	author stephenb;	state Exp;
branches;
next	1.135;

1.135
date	96.02.20.09.34.49;	author stephenb;	state Exp;
branches;
next	1.134;

1.134
date	96.02.19.11.20.47;	author stephenb;	state Exp;
branches;
next	1.133;

1.133
date	96.02.05.12.34.35;	author stephenb;	state Exp;
branches;
next	1.132;

1.132
date	96.02.01.16.30.15;	author stephenb;	state Exp;
branches;
next	1.131;

1.131
date	96.02.01.16.01.54;	author stephenb;	state Exp;
branches;
next	1.130;

1.130
date	96.01.25.15.39.57;	author matthew;	state Exp;
branches;
next	1.129;

1.129
date	96.01.15.17.03.04;	author stephenb;	state Exp;
branches;
next	1.128;

1.128
date	96.01.08.16.29.55;	author nickb;	state Exp;
branches;
next	1.127;

1.127
date	96.01.05.16.20.41;	author matthew;	state Exp;
branches;
next	1.126;

1.126
date	95.12.18.16.36.44;	author jont;	state Exp;
branches;
next	1.125;

1.125
date	95.12.11.14.27.16;	author jont;	state Exp;
branches;
next	1.124;

1.124
date	95.11.17.16.41.26;	author jont;	state Exp;
branches;
next	1.123;

1.123
date	95.10.26.10.23.54;	author nickb;	state Exp;
branches;
next	1.122;

1.122
date	95.10.20.10.32.19;	author daveb;	state Exp;
branches;
next	1.121;

1.121
date	95.10.17.13.58.36;	author matthew;	state Exp;
branches;
next	1.120;

1.120
date	95.09.21.11.04.38;	author matthew;	state Exp;
branches;
next	1.119;

1.119
date	95.09.12.12.21.47;	author matthew;	state Exp;
branches;
next	1.118;

1.118
date	95.09.08.12.16.33;	author jont;	state Exp;
branches;
next	1.117;

1.117
date	95.08.31.15.16.47;	author matthew;	state Exp;
branches;
next	1.116;

1.116
date	95.08.02.13.57.00;	author daveb;	state Exp;
branches;
next	1.115;

1.115
date	95.06.20.13.53.24;	author daveb;	state Exp;
branches;
next	1.114;

1.114
date	95.06.15.14.46.18;	author daveb;	state Exp;
branches;
next	1.113;

1.113
date	95.06.14.14.25.58;	author daveb;	state Exp;
branches;
next	1.112;

1.112
date	95.06.02.14.10.32;	author nickb;	state Exp;
branches;
next	1.111;

1.111
date	95.06.01.11.37.01;	author matthew;	state Exp;
branches;
next	1.110;

1.110
date	95.05.10.11.09.54;	author matthew;	state Exp;
branches;
next	1.109;

1.109
date	95.04.24.12.41.06;	author matthew;	state Exp;
branches;
next	1.108;

1.108
date	95.04.20.19.15.32;	author daveb;	state Exp;
branches;
next	1.107;

1.107
date	95.04.20.13.57.41;	author jont;	state Exp;
branches;
next	1.106;

1.106
date	95.04.11.14.38.45;	author matthew;	state Exp;
branches;
next	1.105;

1.105
date	95.03.28.15.25.46;	author matthew;	state Exp;
branches;
next	1.104;

1.104
date	95.03.10.16.38.11;	author matthew;	state Exp;
branches;
next	1.103;

1.103
date	95.03.06.12.08.37;	author daveb;	state Exp;
branches;
next	1.102;

1.102
date	95.03.01.15.38.58;	author matthew;	state Exp;
branches;
next	1.101;

1.101
date	95.02.01.16.10.42;	author matthew;	state Exp;
branches;
next	1.100;

1.100
date	95.01.30.12.47.30;	author matthew;	state Exp;
branches;
next	1.99;

1.99
date	95.01.27.14.14.12;	author daveb;	state Exp;
branches;
next	1.98;

1.98
date	95.01.13.14.40.22;	author daveb;	state Exp;
branches;
next	1.97;

1.97
date	94.12.06.10.24.40;	author matthew;	state Exp;
branches;
next	1.96;

1.96
date	94.10.13.15.42.09;	author matthew;	state Exp;
branches;
next	1.95;

1.95
date	94.09.21.15.18.47;	author matthew;	state Exp;
branches;
next	1.94;

1.94
date	94.08.01.09.20.09;	author daveb;	state Exp;
branches;
next	1.93;

1.93
date	94.06.23.10.26.30;	author jont;	state Exp;
branches;
next	1.92;

1.92
date	94.06.20.09.37.31;	author daveb;	state Exp;
branches;
next	1.91;

1.91
date	94.06.09.15.49.20;	author nickh;	state Exp;
branches;
next	1.90;

1.90
date	94.06.09.09.44.29;	author nosa;	state Exp;
branches;
next	1.89;

1.89
date	94.02.28.09.46.45;	author nosa;	state Exp;
branches;
next	1.88;

1.88
date	94.02.23.17.40.01;	author matthew;	state Exp;
branches;
next	1.87;

1.87
date	94.02.02.12.23.36;	author daveb;	state Exp;
branches;
next	1.86;

1.86
date	93.12.22.15.18.20;	author daveb;	state Exp;
branches;
next	1.85;

1.85
date	93.12.17.17.03.33;	author matthew;	state Exp;
branches;
next	1.84;

1.84
date	93.12.09.19.27.26;	author jont;	state Exp;
branches;
next	1.83;

1.83
date	93.12.01.18.12.04;	author matthew;	state Exp;
branches;
next	1.82;

1.82
date	93.11.23.12.02.28;	author daveb;	state Exp;
branches;
next	1.81;

1.81
date	93.10.12.16.23.15;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	93.09.06.15.51.36;	author nosa;	state Exp;
branches;
next	1.79;

1.79
date	93.09.02.17.08.03;	author matthew;	state Exp;
branches;
next	1.78;

1.78
date	93.08.25.15.02.10;	author matthew;	state Exp;
branches
	1.78.1.1;
next	1.77;

1.77
date	93.08.24.13.46.29;	author matthew;	state Exp;
branches;
next	1.76;

1.76
date	93.08.17.18.13.03;	author daveb;	state Exp;
branches;
next	1.75;

1.75
date	93.08.06.14.24.32;	author nosa;	state Exp;
branches;
next	1.74;

1.74
date	93.08.04.15.06.30;	author nosa;	state Exp;
branches;
next	1.73;

1.73
date	93.08.03.09.22.49;	author nosa;	state Exp;
branches;
next	1.72;

1.72
date	93.07.30.13.32.06;	author nosa;	state Exp;
branches;
next	1.71;

1.71
date	93.06.17.10.52.06;	author matthew;	state Exp;
branches;
next	1.70;

1.70
date	93.06.11.13.16.16;	author matthew;	state Exp;
branches;
next	1.69;

1.69
date	93.05.28.16.39.24;	author matthew;	state Exp;
branches;
next	1.68;

1.68
date	93.05.24.15.27.56;	author matthew;	state Exp;
branches;
next	1.67;

1.67
date	93.05.18.13.56.26;	author jont;	state Exp;
branches;
next	1.66;

1.66
date	93.05.12.15.21.00;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	93.05.10.15.35.42;	author daveb;	state Exp;
branches;
next	1.64;

1.64
date	93.05.07.17.20.44;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	93.05.06.13.00.32;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	93.04.30.15.49.09;	author matthew;	state Exp;
branches;
next	1.61;

1.61
date	93.04.29.15.10.40;	author matthew;	state Exp;
branches;
next	1.60;

1.60
date	93.04.29.14.31.29;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	93.04.26.17.25.23;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	93.04.02.13.56.33;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	93.03.30.11.51.00;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	93.03.25.18.17.19;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	93.03.11.13.55.02;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	93.03.08.16.03.41;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	93.03.03.09.57.01;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	93.02.23.16.46.39;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	93.02.09.11.21.21;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	93.02.04.17.59.34;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	92.12.18.12.10.20;	author clive;	state Exp;
branches;
next	1.48;

1.48
date	92.12.17.11.46.04;	author clive;	state Exp;
branches;
next	1.47;

1.47
date	92.12.15.17.16.09;	author clive;	state Exp;
branches;
next	1.46;

1.46
date	92.12.10.15.38.15;	author clive;	state Exp;
branches;
next	1.45;

1.45
date	92.12.09.19.32.08;	author clive;	state Exp;
branches;
next	1.44;

1.44
date	92.12.09.14.53.52;	author clive;	state Exp;
branches;
next	1.43;

1.43
date	92.12.07.17.17.28;	author clive;	state Exp;
branches;
next	1.42;

1.42
date	92.12.01.09.46.09;	author clive;	state Exp;
branches;
next	1.41;

1.41
date	92.11.27.18.34.52;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	92.11.23.15.06.54;	author clive;	state Exp;
branches;
next	1.39;

1.39
date	92.11.20.16.48.35;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	92.11.19.15.35.58;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	92.11.17.14.20.42;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	92.11.16.16.21.48;	author clive;	state Exp;
branches;
next	1.35;

1.35
date	92.11.16.14.17.21;	author clive;	state Exp;
branches;
next	1.34;

1.34
date	92.11.12.16.53.39;	author clive;	state Exp;
branches;
next	1.33;

1.33
date	92.11.10.12.04.30;	author clive;	state Exp;
branches;
next	1.32;

1.32
date	92.11.05.18.17.27;	author richard;	state Exp;
branches;
next	1.31;

1.31
date	92.10.27.11.15.59;	author clive;	state Exp;
branches;
next	1.30;

1.30
date	92.10.14.08.54.15;	author clive;	state Exp;
branches;
next	1.29;

1.29
date	92.10.12.14.20.18;	author clive;	state Exp;
branches;
next	1.28;

1.28
date	92.10.08.10.54.43;	author clive;	state Exp;
branches;
next	1.27;

1.27
date	92.10.05.14.58.02;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.09.10.14.42.44;	author richard;	state Exp;
branches;
next	1.25;

1.25
date	92.09.09.16.12.18;	author clive;	state Exp;
branches;
next	1.24;

1.24
date	92.09.03.09.12.40;	author clive;	state Exp;
branches;
next	1.23;

1.23
date	92.09.01.17.44.13;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.08.28.16.03.50;	author clive;	state Exp;
branches;
next	1.21;

1.21
date	92.08.27.17.01.53;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.08.26.18.59.19;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	92.08.26.18.50.53;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.08.26.17.14.10;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.08.24.15.46.59;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.08.21.16.36.02;	author clive;	state Exp;
branches;
next	1.15;

1.15
date	92.08.19.13.27.06;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.08.19.10.44.45;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.08.18.11.49.21;	author clive;	state Exp;
branches;
next	1.12;

1.12
date	92.08.14.15.11.29;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.08.13.15.54.57;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.08.11.15.05.36;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.08.10.17.00.04;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.08.07.15.38.06;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.08.03.17.01.07;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.07.29.14.28.04;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.07.17.08.32.01;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	92.07.16.16.18.25;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.07.13.15.34.05;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.06.22.16.27.21;	author clive;	state Exp;
branches;
next	1.1;

1.1
date	92.06.22.16.07.39;	author clive;	state Exp;
branches;
next	;

1.78.1.1
date	93.08.25.15.02.10;	author jont;	state Exp;
branches;
next	1.78.1.2;

1.78.1.2
date	93.09.02.13.58.06;	author matthew;	state Exp;
branches;
next	1.78.1.3;

1.78.1.3
date	93.10.12.14.30.34;	author matthew;	state Exp;
branches;
next	;

1.161.1.1
date	96.09.13.11.11.20;	author hope;	state Exp;
branches;
next	;

1.162.1.1
date	96.10.07.16.02.06;	author hope;	state Exp;
branches;
next	;

1.162.2.1
date	96.10.17.11.20.21;	author hope;	state Exp;
branches;
next	;

1.166.1.1
date	96.11.14.12.43.56;	author hope;	state Exp;
branches
	1.166.1.1.1.1;
next	;

1.166.1.1.1.1
date	96.11.28.14.55.52;	author hope;	state Exp;
branches;
next	;

1.166.2.1
date	96.11.22.18.04.22;	author hope;	state Exp;
branches;
next	;

1.166.3.1
date	96.12.17.17.43.19;	author hope;	state Exp;
branches
	1.166.3.1.1.1;
next	;

1.166.3.1.1.1
date	97.02.24.11.32.12;	author hope;	state Exp;
branches;
next	;

1.166.4.1
date	96.12.18.09.37.18;	author hope;	state Exp;
branches;
next	;

1.170.1.1
date	97.05.12.10.29.28;	author hope;	state Exp;
branches
	1.170.1.1.1.1
	1.170.1.1.2.1
	1.170.1.1.3.1;
next	;

1.170.1.1.1.1
date	97.07.28.18.15.20;	author daveb;	state Exp;
branches
	1.170.1.1.1.1.1.1;
next	;

1.170.1.1.1.1.1.1
date	97.10.07.11.40.24;	author jkbrook;	state Exp;
branches;
next	;

1.170.1.1.2.1
date	97.09.08.17.08.50;	author daveb;	state Exp;
branches;
next	;

1.170.1.1.3.1
date	97.09.09.14.03.56;	author daveb;	state Exp;
branches;
next	;

1.173.1.1
date	97.09.10.19.18.27;	author brucem;	state Exp;
branches;
next	;

1.173.2.1
date	97.09.11.20.49.26;	author daveb;	state Exp;
branches;
next	;

1.186.1.1
date	99.04.01.17.53.14;	author daveb;	state Exp;
branches;
next	;


desc
@First version
@


1.186
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* _ml_debugger.sml the functor *)
(*
 * $Log: _ml_debugger.sml,v $
 * Revision 1.185  1998/04/22  17:12:57  jont
 * [Bug #70099]
 * Modifications to encapsulation format to put type_env first
 *
 * Revision 1.184  1998/04/16  11:01:54  jont
 * [Bug #70058]
 * Add a function to collect the stamps of all submodules when getting
 * type information
 *
 * Revision 1.183  1998/03/31  13:04:37  jont
 * [Bug #70077]
 * Remove use of Path, and replace with OS.Path
 *
 * Revision 1.182  1998/03/23  14:36:31  jont
 * [Bug #30090]
 * Remove use of MLWorks.IO
 *
 * Revision 1.181  1998/03/02  15:07:22  mitchell
 * [Bug #70074]
 * Add depth limit support for signature printing
 *
 * Revision 1.180  1998/02/19  20:16:47  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.179  1998/02/18  16:55:25  jont
 * [Bug #70070]
 * Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
 * Revision 1.178  1998/02/10  16:01:52  jont
 * [Bug #70065]
 * Remove uses of MLWorks.IO.messages and use the Messages structure
 *
 * Revision 1.177  1998/02/05  12:11:08  jont
 * [Bug #30331]
 * Modify to use Encapsulate.input_debug_info
 *
 * Revision 1.176  1997/11/25  10:43:26  jont
 * [Bug #30328]
 * Add environment parameter to decode_type_basis
 * for finding pervasive type names
 *
 * Revision 1.175  1997/11/10  16:58:35  jont
 * [Bug #30320]
 * Swap effects of < and > around
 *
 * Revision 1.174  1997/09/18  14:36:41  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.173  1997/07/21  16:47:26  jont
 * [Bug #30201]
 * Remove Unix-ism "Fatal Unix signal" and replace
 * with "Fatal OS signal"
 *
 * Revision 1.172  1997/05/21  17:02:51  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
 * Revision 1.171  1997/05/02  17:06:02  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.170  1997/03/21  15:43:26  matthew
 * Adding catchall handlers around print function
 *
 * Revision 1.169  1997/03/20  14:50:05  stephenb
 * [Bug #1822]
 * make_frame_details: introduce a Stack_Interface.variable_debug_frame
 * call at an appropriate point ensure that details of the correct
 * frame are displayed.
 *
 * Revision 1.168  1997/03/07  16:43:08  matthew
 * Don't exit with do_quit if use_debugger is false
 *
 * Revision 1.167  1996/12/18  14:24:52  stephenb
 * [Bug #1786]
 * do_continue: add a raise Exit in the FUN case so that the debugger loop
 * is exited.
 *
 * Revision 1.166  1996/11/07  17:27:53  stephenb
 * [Bug #1461]
 * Change to stack closure tags.
 *
 * Revision 1.165  1996/11/07  14:33:56  stephenb
 * [Bug #1441]
 * Change from using word to byte offsets for annotation indices.
 * This is necessary because the instructions on an I386 are not
 * word aligned as they are on a SPARC/MIPS.
 *
 * Revision 1.164  1996/11/06  11:23:09  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.163  1996/10/31  14:09:40  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.162  1996/09/27  12:40:40  stephenb
 * As discussed in mlworks.mail.{8075,8081,8086}, display
 * a message when about to and just after scanning the stack
 * when entering the debugger.
 *
 * Revision 1.161  1996/08/06  14:47:21  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml
 *
 * Revision 1.160  1996/08/01  12:49:18  jont
 * [Bug #1503]
 * Ensure no arg acquired if there isn't one saved
 *
 * Revision 1.159  1996/06/27  14:37:08  stephenb
 * Fix #1437 - NT: stack browser frame hiding doesn't work properly
 *
 * Revision 1.158  1996/06/19  10:41:31  stephenb
 * Fix #1423 - duplicate anonymous frames not hidden correctly.
 *
 * Revision 1.157  1996/06/17  15:37:54  stephenb
 * with_start_frame: Fix so that it does not unconditionally turn off
 * stepping, rather it sets it to what it was before with_start_frame
 * was run.
 *
 * Revision 1.156  1996/05/30  13:09:08  daveb
 * The Io exception is no longer at top level.
 *
 * Revision 1.155  1996/05/21  11:12:28  stephenb
 * Change to pull in Path directly rather than OS.Path since the latter
 * now conforms to the latest basis and it is too much effort to update
 * the code to OS.Path at this point.
 *
 * Revision 1.154  1996/05/17  09:58:11  matthew
 * Moved Bits to MLWorks.Internal
 *
 * Revision 1.153  1996/05/01  10:16:56  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.152  1996/04/29  15:04:24  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.151  1996/04/23  11:36:14  daveb
 * Made debug_print local to the debug functions, and removed a call to it
 * that should have used one of the other debug functions.
 *
 * Revision 1.150  1996/04/18  15:17:50  jont
 * initbasis moves to basis
 *
 * Revision 1.149  1996/04/15  12:06:34  stephenb
 * Rename Os -> OS to conform with latest basis revision.
 *
 * Revision 1.148  1996/04/15  10:27:34  stephenb
 * output_frame_details: restore to its original behaviour of outputting
 * a newline after the frame details.
 *
 * Revision 1.147  1996/04/04  13:31:13  stephenb
 * Lift out some of the functions in ml_debugger so that it is
 * easier to follow what is going on.
 *
 * Revision 1.146  1996/04/01  12:54:31  stephenb
 * Replace Path/PATH by Os.Path/OS_PATH
 *
 * Revision 1.145  1996/03/15  12:08:56  stephenb
 * Fix so that if the user keeps stepping right through until the MLWorks
 * prompt is reached (i.e. the user does not explicitly continue or quit),
 * stepping is not left on.
 *
 * Revision 1.144  1996/03/05  14:21:37  stephenb
 * Fix the frame filtering mechanism so that it doesn't drop
 * the top frame if it is a delivered frame.
 *
 * Revision 1.143  1996/02/29  15:11:46  stephenb
 * Modify the tty->gui interface so that the gui debugger knows
 * which frame to apply Trace.next to.
 * Modified the tty frame movement commands so that they deal gracefully
 * with the case where there are no visible ML frames (I didn't
 * consider this case when I originally wrote the code since it cannot
 * occur if the debugger is entered due to a breakpoint).
 * Removed an unused function from inside _ml_debugger.
 *
 * Revision 1.142  1996/02/28  12:18:02  stephenb
 * Re-implement the frame hiding stuff so that hiding/revealing a frame
 * does not lose the user's position in the backtrace.
 *
 * Revision 1.141  1996/02/27  11:27:45  stephenb
 * Simplified the mapping between frame type names and the frame hiding flags.
 * Added some more comments.
 *
 * Revision 1.140  1996/02/26  14:02:18  stephenb
 * Unify control of hiding and revealing frames in the tty&gui debuggers.
 *
 * Revision 1.139  1996/02/23  16:30:32  stephenb
 * Rewrite frame hiding so that it supports the same sort of
 * features as the gui debugger.
 *
 * Revision 1.138  1996/02/22  14:43:39  jont
 * Replacing Map with NewMap
 *
 * Revision 1.137  1996/02/22  14:29:28  stephenb
 * Fix so that frames created as a result of a breakpoint/step/trace
 * are not visible to the user.
 * This doesn't have any of the fancy options that the gui version does.
 * Hopefully this and the gui version will converge in the near future.
 *
 * Revision 1.136  1996/02/21  11:22:32  stephenb
 * Fix so that the 5th frame is displayed if the debugger has
 * been invoked due to stepping or breakpointing but the top
 * frame is displayed otherwise.
 *
 * Revision 1.135  1996/02/20  09:34:49  stephenb
 * Add an extra (impossible) branch to a case to keep the compiler
 * from warning about non-exhaustive patterns.
 *
 * Revision 1.134  1996/02/19  11:20:47  stephenb
 * Updated wrt Trace.step_status -> Trace.stepping name change and wrt
 * the changes in the implementation of step/breakpoint which mean that
 * the function to break/step is not the top frame any more!  Instead it
 * is the second ML frame (empirically determined to be the the 4th frame
 * from top on the stack).
 *
 * Revision 1.133  1996/02/05  12:34:35  stephenb
 * Add "breakpoints" command to tty debugger.
 * Modify "ignore" command so that it more closely resembles the gdb command.
 *
 * Revision 1.132  1996/02/01  16:30:15  stephenb
 * Add the ignore command description to the help info.
 *
 * Revision 1.131  1996/02/01  16:01:54  stephenb
 * Added the "ignore" command which allows the next n hits on a
 * breakpoint to be skipped.
 *
 * Revision 1.130  1996/01/25  15:39:57  matthew
 * Need to raise Exit occasionally to exit the debugger
 *
 * Revision 1.129  1996/01/15  17:03:04  stephenb
 * Fix the continue action so that if the action is not possible, it
 * does not drop out of the debugger back to MLWorks.
 *
 * Revision 1.128  1996/01/08  16:29:55  nickb
 * Change SIGNAL to INTERRUPT (interrupts aren't signals on Windows).
 *
 * Revision 1.127  1996/01/05  16:20:41  matthew
 * Fixing bungle with step mode
 *
 * Revision 1.126  1995/12/18  16:36:44  jont
 * Remove debugging print stuff
 *
 * Revision 1.125  1995/12/11  14:27:16  jont
 * Add counting of break points, and continuing multiple times
 *
 * Revision 1.124  1995/11/17  16:41:26  jont
 * General improvements to debug inference of types in stack backtraces,
 * particularly for local variable debugging
 *
Revision 1.123  1995/10/26  10:23:54  nickb
Fix frames seen by the debugger when tracing.

Revision 1.122  1995/10/20  10:32:19  daveb
Renamed ShellUtils.edit_string to ShellUtils.edit_source
(and ShellUtils.edit_source to ShellUtils.edit_location).

Revision 1.121  1995/10/17  13:58:36  matthew
Renaming trace functions

Revision 1.120  1995/09/21  11:04:38  matthew
Suppressing display of C frames

Revision 1.119  1995/09/12  12:21:47  matthew
Improving messages

Revision 1.118  1995/09/08  12:16:33  jont
Add location imformation to exception names when printed

Revision 1.117  1995/08/31  15:16:47  matthew
Changing behaviour for empty list of frames

Revision 1.116  1995/08/02  13:57:00  daveb
If the use_debugger preference is not set, make the debugger function do a
quit option instead of a normal return.

Revision 1.115  1995/06/20  13:53:24  daveb
Fixed mistake in my last change: the tty debugger wasn't printing the
reason that the debugger was invoked.

Revision 1.114  1995/06/15  14:46:18  daveb
Made the debugger use the message function from the debugger type
info to print the message when use_debugger is false or the stack is empty.

Revision 1.113  1995/06/14  14:25:58  daveb
Made use of debugger depend on preference setting.
Removed redundant parameters from ml_debugger, added a message_fn
parameter, and removed unnecessary currying.

Revision 1.112  1995/06/02  14:10:32  nickb
Add fatal signals.

Revision 1.111  1995/06/01  11:37:01  matthew
Cleaning up tty interface

Revision 1.110  1995/05/10  11:09:54  matthew
Removed old step & breakpoint stuff
Removed script parameter to ml_debugger

Revision 1.109  1995/04/24  12:41:06  matthew
General cosmetic improvements

Revision 1.108  1995/04/20  19:15:32  daveb
filesys and path moved from utils to initbasis.

Revision 1.107  1995/04/20  13:57:41  jont
Change type of decode_type_basis to take a btree

Revision 1.106  1995/04/11  14:38:45  matthew
New stepping and breakpointing stuff

Revision 1.105  1995/03/28  15:25:46  matthew
More stuff

Revision 1.104  1995/03/10  16:38:11  matthew
Making debugger platform independent

Revision 1.103  1995/03/06  12:08:37  daveb
New path functions.

Revision 1.102  1995/03/01  15:38:58  matthew
Various changes
Addition of simple trace functions to tty debugger
Improvements to backtrace stuff
etc. etc.

Revision 1.101  1995/02/01  16:10:42  matthew
Debugger changes

Revision 1.100  1995/01/30  12:47:30  matthew
Renaming debugger_env to runtime_env
Various simplifications etc,

Revision 1.99  1995/01/27  14:14:12  daveb
Replaced hacky file name operations with Path functions.

Revision 1.97  1994/12/06  10:24:40  matthew
Changing uses of cast.

Revision 1.96  1994/10/13  15:42:09  matthew
Make NewMap return pervasive option

Revision 1.95  1994/09/21  15:18:47  matthew
Abstraction of debug information

Revision 1.94  1994/08/01  09:20:09  daveb
Moved preferences out of Options structure.

Revision 1.93  1994/06/23  10:26:30  jont
Update debugger information production

Revision 1.92  1994/06/20  09:37:31  daveb
Replaced context_ref with context.

Revision 1.91  1994/06/09  15:49:20  nickh
\nNew runtime directory structure.

Revision 1.90  1994/06/09  09:44:29  nosa
Breakpoint settings on function exits;
altered filename formation in decapsulation of debugger environments.

Revision 1.89  1994/02/28  09:46:45  nosa
Step and Breakpoints Debugger;
Type basis decapsulation facility for Monomorphic debugger;
Few changes to the debugger command line parser.

Revision 1.88  1994/02/23  17:40:01  matthew
Modifying loop

Revision 1.87  1994/02/02  12:23:36  daveb
CHanged substructure of InterMake.

Revision 1.86  1993/12/22  15:18:20  daveb
The tty debugger was printing the wrong frame.

Revision 1.85  1993/12/17  17:03:33  matthew
Ignore stack extension frames in type inference

Revision 1.84  1993/12/09  19:27:26  jont
Added copyright message

Revision 1.83  1993/12/01  18:12:04  matthew
Made make_frame_string tail recursive.

Revision 1.82  1993/11/23  12:02:28  daveb
Removed with_frame_wrap.  Changed type of with_start_frame so that callers
don't have to provide a frame.  Changed several details of presentation to
make the TTY debugger more friendly.  Removed extraneous frames from list
of frames perused by debugger.  Coding in the number of frames to remove
is a gross hack, but I couldn't get anything else to work.

Revision 1.81  1993/10/12  16:23:15  matthew
Merging bug fixes

Revision 1.80  1993/09/06  15:51:36  nosa
Polymorphic debugger.

Revision 1.79  1993/09/02  17:08:03  matthew
Merging in bug fixes

Revision 1.78.1.3  1993/10/12  14:30:34  matthew
Added STACK_OVERFLOW parameter type
Changed the debugger entry message to be more informative

Revision 1.78.1.2  1993/09/02  13:58:06  matthew
Get the debug_info using the global access function InterMake.current_debug_information

Revision 1.78  1993/08/25  15:02:10  matthew
Return quit function from ShellUtils.edit_string

Revision 1.77  1993/08/24  13:46:29  matthew
 Tidied up edit failure messages.
Back traces now include current frame

Revision 1.76  1993/08/17  18:13:03  daveb
Removed Io structure.

Revision 1.75  1993/08/06  14:24:32  nosa
Inspector invocation in debugger-window on values of local
and closure variables.

Revision 1.74  1993/08/04  15:06:30  nosa
Changes for ShowFrameInfo option in debugger window.

Revision 1.73  1993/08/03  09:22:49  nosa
Improved frame relative naming.

Revision 1.72  1993/07/30  13:32:06  nosa
Debugger Environments for local and closure variable inspection
in the debugger;
enhanced debugger commands.

Revision 1.71  1993/06/17  10:52:06  matthew
Improved frame filtering

Revision 1.70  1993/06/11  13:16:16  matthew
Added function continuation

Revision 1.69  1993/05/28  16:39:24  matthew
Added window_debugger option
Added tty_ok option to WINDOWING

Revision 1.68  1993/05/24  15:27:56  matthew
Fixed problem with previous frame in tty debugger

Revision 1.67  1993/05/18  13:56:26  jont
Removed integer parameter

Revision 1.66  1993/05/12  15:21:00  matthew
 Added message function to Windowing debugger
Added with_start_frame

Revision 1.65  1993/05/10  15:35:42  daveb
Changed argument of ml_debugger from Incremental.options to Options.options.
Removed lots of commented out code.

Revision 1.64  1993/05/07  17:20:44  matthew
Partial implementation of frame selection in tty debugger
Added quit and continue options to windowing debugger.

Revision 1.63  1993/05/06  13:00:32  matthew
Removed printer descriptors.

Revision 1.62  1993/04/30  15:49:09  matthew
Changed edit function interface

Revision 1.61  1993/04/29  15:10:40  matthew
Changed do_my_debug to false

Revision 1.60  1993/04/29  14:31:29  matthew
Rewritten

Revision 1.59  1993/04/26  17:25:23  matthew
Much diddling.

Revision 1.58  1993/04/02  13:56:33  matthew
 Signature changes

Revision 1.57  1993/03/30  11:51:00  matthew
Removed current module parameter from ml_debugger
Fixed "bv" so as not to change the frame stack

Revision 1.56  1993/03/25  18:17:19  matthew
Added call to flush_out on prompting

Revision 1.55  1993/03/11  13:55:02  matthew
Simplified interface to debugger
Signature revisions

Revision 1.54  1993/03/08  16:03:41  matthew
Options & Info changes
Incremental changes
Absyn changes

Revision 1.53  1993/03/03  09:57:01  matthew
empty_rec_type to empty_rectype

Revision 1.52  1993/02/23  16:46:39  matthew
Added break option and changed debugger message.

Revision 1.51  1993/02/09  11:21:21  matthew
Typechecker structure changes

Revision 1.50  1993/02/04  17:59:34  matthew
Changed functor parameter

Revision 1.49  1992/12/18  12:10:20  clive
We also pass the current module forward

Revision 1.48  1992/12/17  11:46:04  clive
Changed debug info to have only module name - needed to pass module table through to window stuff

Revision 1.47  1992/12/15  17:16:09  clive
Keep the backtrace short

Revision 1.46  1992/12/10  15:38:15  clive
Removed a lot of unnecessary handlers

Revision 1.44  1992/12/09  14:53:52  clive
Two bugs fixes and propagation of changes lower down

Revision 1.43  1992/12/07  17:17:28  clive
Fixed a bug when tracing

Revision 1.42  1992/12/01  09:46:09  clive
Debugger now takes a print descriptor

Revision 1.41  1992/11/27  18:34:52  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.40  1992/11/23  15:06:54  clive
Fixed a bug in tracing
Changed the option 'c' to 'q' and added another 'c'

Revision 1.39  1992/11/20  16:48:35  jont
Modified the sharing equations slightly

Revision 1.38  1992/11/19  15:35:58  matthew
Tidied up debugger loop.

Revision 1.37  1992/11/17  14:20:42  matthew
Changed Error structure to Info

Revision 1.36  1992/11/16  16:21:48  clive
Added extra info for the frames whose types have not been deduced yet

Revision 1.35  1992/11/16  14:17:21  clive
Added polymorphic tracing

Revision 1.34  1992/11/12  16:53:39  clive
Added tracing again

Revision 1.33  1992/11/10  12:04:30  clive
Added a handle for substring and changed the help message

Revision 1.32  1992/11/05  18:17:27  richard
Stripped out tracing code.  Many changes concerning
changes to pervasives.  Needs seeing to.

Revision 1.31  1992/10/27  11:15:59  clive
Took out trace and added binding of frame arguments to it

Revision 1.30  1992/10/14  08:54:15  clive
Changes for windowing listener

Revision 1.29  1992/10/12  14:20:18  clive
Tynames now have a slot recording their definition point

Revision 1.28  1992/10/08  10:54:43  clive
Changes for the use of new shell

Revision 1.27  1992/10/05  14:58:02  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.26  1992/09/10  14:42:44  richard
Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.

Revision 1.25  1992/09/09  16:12:18  clive
Added switches t the value-printer to control depth of printing etc

Revision 1.24  1992/09/03  09:12:40  clive
Added functionality to the value_printer

Revision 1.23  1992/09/01  17:44:13  clive
Small fix to :n fred

Revision 1.22  1992/08/28  16:03:50  clive
Used get_code_object_debug_info in the trace code

Revision 1.21  1992/08/27  17:01:53  clive
Neatened up the output a bit

Revision 1.20  1992/08/26  18:59:19  richard
Rationalisation of the MLWorks structure.

Revision 1.19  1992/08/26  18:50:53  jont
Removed some redundant structures and sharing

Revision 1.18  1992/08/26  17:14:10  clive
Fixed a few bugs and added binding of frame arguments to it

Revision 1.17  1992/08/24  15:46:59  clive
Added details about leafness to the debug information

Revision 1.16  1992/08/21  16:36:02  clive
Added a loop inside the debugger

Revision 1.15  1992/08/19  13:27:06  clive
Added untrace

Revision 1.14  1992/08/19  10:44:45  clive
Changed to reflect changes to pervasive_library

Revision 1.13  1992/08/18  11:49:21  clive
Various improvements

Revision 1.12  1992/08/14  15:11:29  clive
Corrected a few errors

Revision 1.11  1992/08/13  15:54:57  clive
Neatening up, plus changes due to lower level sharing changes

Revision 1.10  1992/08/11  15:05:36  clive
More improvements

Revision 1.8  1992/08/07  15:38:06  clive
Working monomorphic version of trace

Revision 1.5  1992/07/17  08:32:01  clive
More work on the debugger

Revision 1.4  1992/07/16  16:18:25  clive
Made the debugger work better, and changes for the new interface to the runtime system

Revision 1.3  1992/07/13  15:34:05  clive
Support for interpreter

Revision 1.2  1992/06/22  16:27:21  clive
get_next_frame only returns two arguments - the third exnp is no longer required

Revision 1.1  1992/06/22  16:07:39  clive
Initial revision

 * Copyright (c) 1993 Harlequin Ltd.
*)

require "$.basis.__int";
require "$.basis.__text_io";
require "$.basis.__string";

require "^.utils.lists";
require "^.utils.crash";
require "^.utils.__messages";
require "^.utils.__terminal";
require "^.basics.module_id";
require "^.basics.location";
require "^.basis.os_path";
require "^.main.encapsulate";
require "^.main.preferences";
require "^.main.project";
require "^.typechecker.types";
require "^.interpreter.incremental";
require "^.interpreter.shell_utils";
require "^.rts.gen.tags";
require "debugger_print";
require "^.main.stack_interface";
require "debugger_utilities";
require "value_printer";
require "newtrace";
require "stack_frame";
require "ml_debugger";

functor Ml_Debugger(
  structure Lists : LISTS
  structure Crash : CRASH
  structure Path : OS_PATH
  structure Encapsulate : ENCAPSULATE
  structure Preferences : PREFERENCES
  structure Project : PROJECT
  structure ModuleId : MODULE_ID
  structure Location : LOCATION
  structure Types : TYPES
  structure Incremental : INCREMENTAL
  structure ShellUtils : SHELL_UTILS
  structure ValuePrinter : VALUE_PRINTER
  structure StackInterface : STACK_INTERFACE
  structure DebuggerUtilities : DEBUGGER_UTILITIES
  structure Tags : TAGS
  structure DebuggerPrint : DEBUGGER_PRINT
  structure Trace : TRACE
  structure StackFrame : STACK_FRAME

  sharing DebuggerPrint.Options = DebuggerUtilities.Options =
          ShellUtils.Options = Types.Options = ValuePrinter.Options =
          Incremental.InterMake.Inter_EnvTypes.Options

  sharing DebuggerUtilities.Debugger_Types = Encapsulate.Debugger_Types
  sharing DebuggerUtilities.Debugger_Types.Options = DebuggerPrint.Options
  sharing Incremental.Datatypes = Types.Datatypes
  sharing DebuggerPrint.RuntimeEnv = DebuggerUtilities.Debugger_Types.RuntimeEnv
  sharing Types.Datatypes.NewMap = Encapsulate.ParserEnv.Map
  sharing Encapsulate.BasisTypes.Datatypes = Types.Datatypes

  sharing type Incremental.Context = ShellUtils.Context
  sharing type DebuggerUtilities.Debugger_Types.information =
    ValuePrinter.DebugInformation = Incremental.InterMake.Compiler.DebugInformation
  sharing type Types.Datatypes.Type = DebuggerUtilities.Debugger_Types.Type =
    ValuePrinter.Type
  sharing type (* GetTypeInformation.TypeBasis = *) ValuePrinter.TypeBasis =
    Incremental.InterMake.Compiler.TypeBasis
  sharing type DebuggerUtilities.Debugger_Types.Type = DebuggerPrint.RuntimeEnv.Type
  sharing type Preferences.preferences = ShellUtils.preferences
  sharing type ModuleId.Location = Location.T
  sharing type Project.ModuleId = ModuleId.ModuleId
  sharing type Project.Project = Incremental.InterMake.Project
    ) : ML_DEBUGGER =

  struct

    structure Incremental = Incremental
    structure Datatypes = Types.Datatypes
    structure NewMap = Datatypes.NewMap
    structure Debugger_Types = DebuggerUtilities.Debugger_Types
    structure InterMake = Incremental.InterMake
    structure Info = InterMake.Compiler.Info
    structure ValuePrinter = ValuePrinter
    structure Options = DebuggerPrint.Options
    structure RuntimeEnv = DebuggerPrint.RuntimeEnv

    datatype ('a, 'b)union = INL of 'a | INR of 'b

    type preferences = Preferences.preferences

    local
      fun debug_print s = Terminal.output("  # " ^ s ^ "\n")
    in
      val do_debug = false

      (* For multiple line output *)
      fun debugl f =
        if do_debug then
          app debug_print (f ())
        else ()
  
      fun debug f = if do_debug then debug_print (f ()) else ()
      fun ddebug f = debug_print (f ())
    end

    fun assoc (a,[]) = NONE
      | assoc (a,(a',b)::rest) =
        if a = a' then SOME b
        else assoc (a,rest)


    (* This should be replaced by List.take if and when Lists is replaced
       by the basis List *)
    fun firstn (l,n) =
      if n < 0 then []
      else
        let
          fun aux (_,0,acc) = rev acc
            | aux ([],n,_) = l
            | aux (a::b,n,acc) = aux (b,n-1,a::acc)
        in
          aux (l,n,[])
        end


    val cast : 'a -> 'b = MLWorks.Internal.Value.cast

    val empty_map = NewMap.empty' (op < : string * string -> bool)

    (* Some utilities *)


    (* Display a message in the shell or podium if in the GUI.
     * The output is flushed after the message is displayed to 
     * ensure that the output appears even if it is not terminated
     * with a newline.
     *)
    fun outputMessage (message:string):unit =
      (Messages.output message;
       Messages.flush())



(* 
 This works on exploded strings 
    fun substring (str1,str2) =
      let
        fun tl [] = []
          | tl (a::b) = b
        fun substring ([],_,_) = true
          | substring (_,[],_) = false
          | substring (x::xs,y::ys,yys) =
            if x = y
              then substring (xs,ys,yys)
            else substring(str1,yys,tl yys)
      in
        substring (str1,str2,tl str2)
      end
*)

    (* This should use some Location function *)
    fun location_source_file locdata =
      let
        fun aux1(#":"::l,acc) = implode (rev acc)
          | aux1(c::l,acc) = aux1(l,c::acc)
          | aux1([],acc) = implode (rev acc)
      in
        aux1(explode locdata,[])
      end

    fun get_data_from_frame frame =
      let
        fun get_name_and_location code_name =
          let
            fun duff () = debug (fn _ => "Odd codename:"^code_name^":")
            fun aux1( #"[" ::l,acc) = (acc,l)
              | aux1(c::l,acc) = aux1(l,c::acc)
              | aux1([],acc) = (duff();(acc,[]))
            fun aux2([ #"]" ],acc) = (acc,nil)
              | aux2( #"]" ::l,acc) = (duff();(acc,l))
              | aux2(c::l,acc) = aux2(l,c::acc)
              | aux2([],acc) = (duff();(acc,nil))
            val (namechars,rest) = aux1(explode code_name,[])
            val (locchars,fnname) = aux2 (rest,[])
          in
            (implode(rev namechars),(implode(rev locchars),implode fnname))
          end
        val name_string = StackInterface.frame_name frame
      in
        (get_name_and_location name_string,name_string)
      end

    (* DIAGNOSTIC FUNCTIONS *)

    fun get_arg_type(Datatypes.METATYVAR(ref(_,object,_),_,_)) = get_arg_type object
      | get_arg_type(Datatypes.FUNTYPE (arg,_)) = arg
      | get_arg_type x = Datatypes.NULLTYPE

    fun get_res_type(Datatypes.METATYVAR(ref(_,object,_),_,_)) = get_res_type object
      | get_res_type(Datatypes.FUNTYPE (_,res)) = res
      | get_res_type x = Datatypes.NULLTYPE

    exception FailedToGetTypeInfo

    (* Cache away any file information that is recorded *)
    exception CacheFail
    val size_of_data_cache = ref(7)
    val data_cache = ref([] : (string * Debugger_Types.information) list)
    fun cache_lookup file =
      let
        fun cache_lookup(x,[]) =
          (debug (fn _ => file ^ " not found in cache") ;
           raise CacheFail)
          | cache_lookup(x,(elem as (h,t))::rest) =
            if x=h
              then (debug (fn _ => file ^ " found in cache");
                    (t,rest))
            else
              let
                val (a,b) = cache_lookup(x,rest)
              in
                (a,elem::b)
              end
        val (result,rest) = cache_lookup(file,!data_cache)
        val _ = data_cache := (file,result) :: rest
      in
        result
      end

    fun add_to_cache x = data_cache := x :: !data_cache

    fun initialise_cache () = data_cache := nil

    val stamp_map =
      ref empty_map : (string, (string * int * int))NewMap.map ref

    fun update_stamp_map project =
      let
	fun update_stamp_map' id =
	  let
	    val name = ModuleId.string id
	  in
	    case NewMap.tryApply'(!stamp_map, name) of
	      SOME _ => ()
	    | NONE =>
		let
		  val requires =
		    if name = " __pervasive_library" then
		      []
		    else
		      Project.get_requires(project, id)
		      (* This can raise an exception not in its signature *)
		in
		  case Project.get_object_info(project, id) of
		    SOME{stamps, ...} =>
		      (stamp_map :=
		       NewMap.define(!stamp_map, name, (name, stamps, 0));
		       Lists.iterate
		       update_stamp_map'
		       requires)
		    | _ => ()
		end
	      handle _ => ()
	  end
      in
	update_stamp_map'
      end

    fun get_type_information (options,debug_info,((function_name,loc),name_string)) =
      let
        val source_file = location_source_file loc
      in
        case Debugger_Types.lookup_debug_info (debug_info,name_string) of
          SOME funinfo =>
            (funinfo,source_file)
	| _ =>
	    (* This needs to be thought about a little *)
	    (let
	       val file = Path.base source_file
	       val file_debug_info =
		 if Lists.member(file,["","__pervasive_library","__builtin_library"]) then
		   Debugger_Types.empty_information
		 else
		   cache_lookup file
		   handle CacheFail =>
		     (let
			val project = Incremental.get_project()
			val base = Path.base(Path.file source_file)
			val information =
			  case ModuleId.from_string' base of
			    SOME id =>
			      let
				val _ = update_stamp_map project id
				val _ = update_stamp_map
				  project
				  (ModuleId.perv_from_string
				   ("__pervasive_library",
				    Location.FILE"<debugger>"))
				val information =
				  case Project.get_object_info(project, id) of
				    SOME{file, ...} =>
				      let
					val information =
					  Encapsulate.input_debug_info
					  {file_name=file,
					   sub_modules= !stamp_map}
				      in
					information
				      end
				  | _ => Debugger_Types.empty_information
			      in
				information
			      end
			  | _ => Debugger_Types.empty_information
		      in
			add_to_cache (file,information);
			information
		      end
			handle Encapsulate.BadInput msg =>
			  (debug (fn _ =>
				  "Decapsulation failed for function " ^
				  function_name ^ ": " ^ file ^ ":" ^ msg);
			   let
			     val information = Debugger_Types.empty_information
			   in
			     (add_to_cache (file,information); information)
			   end))
	     in
	       case Debugger_Types.lookup_debug_info (file_debug_info, name_string) of
		 SOME funinfo => (funinfo,source_file)
	       | _ => raise FailedToGetTypeInfo
	     end)
      end

    local
      (* The name "part_of_a_frame" is not terribly helpful, but it's
       * still easier to read the debugger_window type now that I've
       * separated out it's components.  This type probably corresponds
       * to the info about a local variable, but I wouldn't bet on it. *)
      type part_of_a_frame =
        (string
         * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value * string)
         ) list

      type frame_details =
        string
        * string
        * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value * string)
        * (unit -> string * part_of_a_frame,
           string * part_of_a_frame)
        union ref option

      type frame = {name : string, loc : string, details: frame_details}
    in
      type debugger_window =
        {parameter_details: string,
         frames: frame list,
         quit_fn: (unit -> unit) option,
         continue_fn: (unit -> unit) option,
         top_ml_user_frame: MLWorks.Internal.Value.Frame.frame option}
        -> unit
    end

    datatype TypeOfDebugger =
      WINDOWING of debugger_window * (string -> unit) * bool
      | TERMINAL

    datatype parameter =
      INTERRUPT |
      FATAL_SIGNAL of int |
      EXCEPTION of exn |
      BREAK of string |
      STACK_OVERFLOW

    datatype Continuation_action =
      NORMAL_RETURN |
      DO_RAISE of exn |
      FUN of (unit -> unit)

    datatype Continuation =
      POSSIBLE of string * Continuation_action |
      NOT_POSSIBLE

    datatype FrameInfo =
      FRAMEINFO of
      Datatypes.Type * Debugger_Types.Backend_Annotation
      * RuntimeEnv.RuntimeEnv * Datatypes.Type ref |
      NOFRAMEINFO

    datatype FrameSpec =
      MLFRAME of
      MLWorks.Internal.Value.Frame.frame *
      ((string * (string * string)) * string) *
      MLWorks.Internal.Value.T option*
      FrameInfo |
      CFRAME of (MLWorks.Internal.Value.Frame.frame * string)

    fun make_continuation_function (POSSIBLE (_,NORMAL_RETURN)) =
        SOME (fn _ => ())
      | make_continuation_function (POSSIBLE (_,DO_RAISE exn)) =
        SOME (fn _ => raise exn)
      | make_continuation_function (POSSIBLE (_,FUN f)) =
        SOME f
      | make_continuation_function NOT_POSSIBLE =
        NONE

    (* need to ensure that this is the latest stuff *)

    fun get_interpreter_information () = InterMake.current_debug_information ()

    (* Incremental.debug_info context *)

    (* Note that offset is a _byte_ count (it used to be a _word_ count) *)

    fun get_frame_details options (frame,offset,is_ml) =
      if is_ml then
        let
          val debug_info as ((name,(loc,_)),name_str) = get_data_from_frame frame
          val (info, arg) =
            let
              val (Debugger_Types.FUNINFO {ty,is_leaf,has_saved_arg,annotations,runtime_env,...},
                   source_file) =
                get_type_information (options,
                                      get_interpreter_information(),
                                      ((name,loc),name_str))
              val arg_type = get_arg_type ty
              val _ = debug (fn _ => "Getting info for " ^ name ^ ", offset: " ^ Int.toString (offset))
              val current_annotation =
                case assoc (offset, annotations) of
                  SOME a => a
                | _ =>
                    let
                      val string =
                        ("No annotation for offset " ^
                         Int.toString offset ^ " for " ^ name)
                    in
                      ignore(Debugger_Types.ERROR string);
                      Debugger_Types.NOP
                    end
              val _ = debug (fn _ => "Annotation: " ^ Debugger_Types.print_backend_annotation options current_annotation)
            in
              (FRAMEINFO(arg_type,current_annotation,runtime_env,
			 ref Datatypes.NULLTYPE),
	       if has_saved_arg then
		 SOME (StackInterface.frame_arg frame)
	       else
		 NONE)
            end
          handle FailedToGetTypeInfo => (NOFRAMEINFO, NONE)
        in
          MLFRAME(frame,debug_info,arg,info)
        end
      else
        let
          val closure_bits = MLWorks.Internal.Bits.lshift(MLWorks.Internal.Value.cast (StackInterface.frame_closure frame),2)
          fun clos_type n =
            if n = Tags.STACK_START then "start"
            else if n = Tags.STACK_EXTENSION then "extension"
            else if n = Tags.STACK_DISTURB_EVENT then "disturb event"
            else if n = Tags.STACK_EXTENSION then "extension"
            else if n = Tags.STACK_RAISE then "raise"
            else if n = Tags.STACK_EVENT then "event"
            else if n = Tags.STACK_C_RAISE then "c raise"
            else if n = Tags.STACK_C_CALL then "c call"
            else if n = Tags.STACK_INTERCEPT then "intercept"
            else if n = Tags.STACK_SPACE_PROFILE then "space profile"
            else "unknown closure "^(Int.toString n)
        in
          CFRAME(frame, clos_type (closure_bits))
        end

    fun type_list_to_rectype ty_list =
      let
        val (numbered_list, _) =
          Lists.number_from_by_one
          (ty_list, 1,
           fn i => Datatypes.Ident.LAB(Datatypes.Ident.Symbol.find_symbol
                                       (Int.toString i)))
      in
        Datatypes.RECTYPE
        (Lists.reducel
         (fn (map, (ty, lab)) => NewMap.define'(map, (lab, ty)))
         (NewMap.empty' Datatypes.Ident.lab_lt, numbered_list))
      end

    fun make_partial_map(poly_type, mono_type, partial_map) =
      let
        val poly_type = DebuggerUtilities.slim_down_a_type poly_type
        val mono_type = DebuggerUtilities.slim_down_a_type mono_type
      in
        make_map(poly_type, mono_type, partial_map)
      end

    and make_map(Datatypes.METATYVAR(r as ref (_, ty, _), _, _),
                 mono_type, partial_map) =
      (case ty of
         Datatypes.NULLTYPE => (r, mono_type) :: partial_map
       | _ => make_map(ty, mono_type, partial_map))
      | make_map(Datatypes.META_OVERLOADED{1=ref ty, ...}, mono_type, partial_map) =
        make_map(ty, mono_type, partial_map)
      | make_map(ty as Datatypes.TYVAR _, mono_type, partial_map) =
        partial_map (* Can't do anything with this I think *)
      | make_map(Datatypes.METARECTYPE(ref {3=ty, ...}), mono_type, partial_map) =
        make_map(ty, mono_type, partial_map)
      | make_map(Datatypes.RECTYPE mapping, mono_type, partial_map) =
        (case mono_type of
           Datatypes.RECTYPE mapping' =>
             Lists.reducel
             (fn (map, ((_, ty1), (_, ty2))) =>
              make_map(ty1, ty2, map))
             (partial_map, Lists.zip(NewMap.to_list_ordered mapping,
                                     NewMap.to_list_ordered mapping'))
         | _ => partial_map (* Can't deal with this any more *))
      | make_map(Datatypes.FUNTYPE(ty, ty'), mono_type, partial_map) =
        (case mono_type of
           Datatypes.FUNTYPE(ty'', ty''') =>
             make_map(ty', ty'', make_map(ty, ty'', partial_map))
         | _ => partial_map (* Can't deal with this any more *))
      | make_map(Datatypes.CONSTYPE(ty_list, tyname), mono_type, partial_map) =
        (case mono_type of
           Datatypes.CONSTYPE(ty_list', tyname') =>
             Lists.reducel
             (fn (map, (ty1, ty2)) =>
              make_map(ty1, ty2, map))
             (partial_map, Lists.zip(ty_list, ty_list'))
         | _ => partial_map (* Can't deal with this any more *))
      | make_map(Datatypes.DEBRUIJN _, mono_type, partial_map) =
        partial_map (* Can't do anything with this I think *)
      | make_map(Datatypes.NULLTYPE, mono_type, partial_map) =
        partial_map (* Can't do anything with this I think *)

    fun apply_map partial_map =
      let
        fun apply_map(ty as Datatypes.METATYVAR(r as ref (_, ty', _), _, _)) =
          (case ty' of
             Datatypes.NULLTYPE =>
               (Lists.assoc(r, partial_map) handle Lists.Assoc => ty)
             | _ => apply_map ty')
          | apply_map(Datatypes.META_OVERLOADED{1=ref ty, ...}) = apply_map ty
          | apply_map(ty as Datatypes.TYVAR _) = ty
          | apply_map(Datatypes.METARECTYPE(ref {3=ty, ...})) = apply_map ty
          | apply_map(Datatypes.RECTYPE mapping) =
            Datatypes.RECTYPE(NewMap.map apply_map_map mapping)
          | apply_map(Datatypes.FUNTYPE(ty, ty')) =
            Datatypes.FUNTYPE(apply_map ty, apply_map ty')
          | apply_map(Datatypes.CONSTYPE(ty_list, tyname)) =
            Datatypes.CONSTYPE(map apply_map ty_list, tyname)
          | apply_map(ty as Datatypes.DEBRUIJN _) = ty
          | apply_map(ty as Datatypes.NULLTYPE) = ty

        and apply_map_map(_, ty) = apply_map ty
      in
        apply_map
      end

    fun print_parameter(INTERRUPT) = "INTERRUPT"
      | print_parameter(FATAL_SIGNAL _) = "FATAL_SIGNAL"
      | print_parameter(EXCEPTION _) = "EXCEPTION"
      | print_parameter(BREAK _) = "BREAK"
      | print_parameter STACK_OVERFLOW = "STACK_OVERFLOW"



    (* The following appears to convert the basic frames list into a 
     * another list of slightly different frames.  In the process some
     * sort of type reconstruction is done.  What isn't clear is why
     * this is done at all since if the gui debugger is invoked, all
     * the frames built by this routine are converted back to a simple
     * frame format (using make_frame_strings) - stephenb
     *)
    fun make_frames (basic_frames,parameter,options) =
      let
        val Options.OPTIONS{print_options, ...} = options
        exception ApplyRecipe
        fun apply_recipe (annotation,ty,name) =
          let
            val result =
              DebuggerUtilities.apply_recipe(annotation,ty)
              handle DebuggerUtilities.ApplyRecipe problem =>
                (debugl (fn _ =>
                         ["Recipe problem " ^ problem ^ " for " ^ name,
                          "Annotation: " ^ Debugger_Types.print_backend_annotation options annotation,
                          "Arg : " ^ Types.debug_print_type options ty]);
                raise ApplyRecipe)
          in
            if do_debug then
              debugl (fn _ => ["Name: " ^ name,
                               "Annotation: " ^ Debugger_Types.print_backend_annotation options annotation,
                               "Arg : " ^ Types.debug_print_type options ty,
                               "Res : " ^Types.debug_print_type options result])
            else ();
              result
          end

        datatype TypeThunk =
          NORECIPE |
          RECIPE of (Debugger_Types.Backend_Annotation * Datatypes.Type)

        fun generate_from_previous_types([], _, ty) = ty (*Can't do any better here *)
          | generate_from_previous_types(poly_type_list, mono_type_list, ty) =
            let
              val new_poly_type =
                Datatypes.FUNTYPE
                (type_list_to_rectype poly_type_list,
                 Datatypes.NULLTYPE) (* Result type will be ignored *)
              val new_mono_type = type_list_to_rectype mono_type_list
              val recipe =
                DebuggerUtilities.generate_recipe options (new_poly_type, ty, "Debugger internal")
            in
              DebuggerUtilities.apply_recipe(recipe, new_mono_type)
              handle DebuggerUtilities.ApplyRecipe problem =>
                (debug(fn _ =>"Problem '" ^ problem ^
                        "' with record type inference mechanism\nty = " ^
                        Types.debug_print_type options ty ^
                        " as " ^ Types.extra_debug_print_type ty ^
                        " and\nnew_poly_type = " ^
                        Types.debug_print_type options new_poly_type ^
                        " as " ^ Types.extra_debug_print_type new_poly_type ^ "\n"
                        );
                raise ApplyRecipe)
            end

        val sys_indicator = "[ "

        fun upto_sys_indicator(s, i) =
          if i+1 >= size s then s
          else
            if substring (* could raise Substring *)(s, i, 2) = sys_indicator then
              substring (* could raise Substring *)(s, 0, i+2)
            else
              upto_sys_indicator(s, i+1)


        (* This appears to only do a subset of what was inside frame_name (and
           now frame_code) in StackInterface.  It should probably be
           changed - stephenb *)

        fun get_code closure =
          MLWorks.Internal.Value.cast
          (MLWorks.Internal.Value.unsafe_record_sub
           (MLWorks.Internal.Value.cast closure, 0))


        val step_through : int = get_code(Trace.step_through (fn x => x))
        val step_through_name =
          upto_sys_indicator
          (MLWorks.Internal.Value.code_name(MLWorks.Internal.Value.cast step_through),
           0)


        fun infer_types (recipe,[], _, _) = ()
          | infer_types (recipe,frame::rest, done_poly_types, done_mono_types) =
            let
(*
              fun debug f = debug_print (f ())
*)
            in
            (case frame of
               CFRAME (frame,_) =>
                 (debug(fn _ => "CFRAME");
                  
                 if StackInterface.is_stack_extension_frame frame then
                   infer_types (recipe,rest, done_poly_types, done_mono_types)
                 else
                   infer_types (NORECIPE,rest, done_poly_types, done_mono_types)
                   )
             | MLFRAME (fr,((name,_),_),_,NOFRAMEINFO) =>
                 let
                   val frame_name = upto_sys_indicator(StackInterface.frame_name fr, 0)
                   val recipe =
                     if frame_name = step_through_name then recipe else NORECIPE
                 (* We can use the recipe from the previous frame *)
                 (* when we find a step_through frame *)
                 in
                   (debug(fn _ => "MLFRAME for " ^ name ^
                          " - no info, => no recipe,\n" ^
                            "parameter type: " ^ print_parameter parameter ^
                            " but inferred type was: " ^
                            (case recipe of
                               RECIPE(r, ty) =>
                                 Types.debug_print_type options (apply_recipe (r,ty,name))
                             | _ => "unavailable due to missing recipe"));
                   infer_types (recipe,rest, done_poly_types, done_mono_types))
                 end
             | MLFRAME (_,((name,_),_),_,FRAMEINFO(arg_type,annotation,_,tyref)) =>
                 let
                   val _ = debug (fn _ => "Doing " ^ name)
                   val itype =
                     if not (DebuggerUtilities.is_type_polymorphic arg_type)
                       then (debug (fn _ => "Not polymorphic"); arg_type)
                     else
                       let
                         val reconstructed_type =
                           case recipe of
                             NORECIPE =>
                               (debug (fn _ => "No recipe, trying previous types");
                                let
                                  val done_poly_types =
                                    type_list_to_rectype done_poly_types
                                  val done_mono_types =
                                    type_list_to_rectype done_mono_types
                                  val map =
                                    make_partial_map(done_poly_types,
                                                     done_mono_types, [])
                                  val seen_tyvars = Types.no_tyvars
                                  val (str1, seen_tyvars) =
                                    Types.print_type_with_seen_tyvars
                                    (options, done_poly_types, seen_tyvars)
                                  val (str2, seen_tyvars) =
                                    Types.print_type_with_seen_tyvars
                                    (options, done_mono_types, seen_tyvars)
                                  val (str3, seen_tyvars) =
                                    Types.print_type_with_seen_tyvars
                                    (options, arg_type, seen_tyvars)
                                in
                                  debug
				    (fn () =>
				       ("Attempting partial tyvar substitution in stack backtrace for\n" ^
                                        str1 ^ " as\n" ^ str2 ^
					" with\n" ^ str3));
                                  apply_map map arg_type
                                end)
                           | RECIPE(r,ty) =>
                               let
                                 val _ = debug (fn _ => "Applying recipe to " ^
                                                Types.debug_print_type options ty ^
                                                " when arg_type = " ^
                                                Types.debug_print_type options arg_type)
                               in
                                 apply_recipe (r,ty,name)
                                 handle ApplyRecipe =>
                                   (debug(fn _ => "generating from previous types");
                                    
                                    generate_from_previous_types(done_poly_types, done_mono_types, arg_type)
                                    handle ApplyRecipe =>
                                      (* This case should try to use the partial instantiation stuff *)
                                      let
                                        val done_poly_types =
                                          type_list_to_rectype done_poly_types
                                        val done_mono_types =
                                          type_list_to_rectype done_mono_types
                                        val map =
                                          make_partial_map(done_poly_types,
                                                           done_mono_types, [])
                                        val seen_tyvars = Types.no_tyvars
                                          
                                        val (str1, seen_tyvars) =
                                          Types.print_type_with_seen_tyvars
                                          (options, done_poly_types, seen_tyvars)
                                          val (str2, seen_tyvars) =
                                            Types.print_type_with_seen_tyvars
                                            (options,done_mono_types, seen_tyvars)
                                          val (str3, seen_tyvars) =
                                            Types.print_type_with_seen_tyvars
                                            (options, arg_type, seen_tyvars)
                                      in
                                        debug(fn _ => "Attempting partial tyvar substitution in stack backtrace for\n" ^
                                              str1 ^ " as\n" ^
                                              str2 ^ " with\n" ^
                                              str3);
                                        apply_map map arg_type
                                      end)
                               end
                       in
                         Types.combine_types (reconstructed_type,arg_type)
                         handle Types.CombineTypes =>
                           (debug (fn _ =>
                                   concat ["Combine types fails for: ",
                                            name, "\n argtype: ",
                                            Types.debug_print_type options arg_type,
                                            "\n reconstructed type: ",
                                            Types.debug_print_type options reconstructed_type]);
                           arg_type)
                       end
                 in
                   tyref := itype;
                   debug (fn _ => " Type = " ^ Types.extra_debug_print_type itype);
                   infer_types (RECIPE (annotation,itype), rest,
                                arg_type :: done_poly_types,
                                itype :: done_mono_types)
                 end)
            end

	val _ = stamp_map := empty_map
	(* Clear out prior to getting frames *)
        val frames = map (get_frame_details options) basic_frames
        val _ = infer_types (NORECIPE,frames, [], [])
      in
        case parameter of
          EXCEPTION _ =>
            ((* Omit the first frame.  This should usually be a top level handler *)
             case rev frames of
               (_::rest) => rest
             | rest => rest)
        (* Otherwise, keep all of the frames -- the top ones will usually be C frames and suppressed *)
        | _ => rev frames
      end

    (* If the frame has a well defined type, use that to print the *)
    (* argument.  Otherwise, scan down the stack collecting recipes until *)
    (* either we run out of stack, or recipes or we find a fully *)
    (* instantiated type *)

    fun fix_runtime_env_types options (arg_type, inferred_type, raise_excp) =
      let
        fun fix_runtime_env_types(RuntimeEnv.LET(varinfo_env_list, env)) =
          let
            val varinfo_env_list =
              map
              (fn (RuntimeEnv.NOVARINFO, env) =>
               (RuntimeEnv.NOVARINFO, fix_runtime_env_types env)
                | (var as RuntimeEnv.VARINFO(str, (ty' as ref ty, rti_ref), offs_ref_opt),
                   env) =>
                  let
                    val recipe =
                      DebuggerUtilities.generate_recipe options
                      (Datatypes.FUNTYPE(arg_type, Datatypes.NULLTYPE), ty,
                       "fix_runtime_env_types")
                    val env = fix_runtime_env_types env
                  in
                    (RuntimeEnv.VARINFO
                     (str, (ref(DebuggerUtilities.apply_recipe(recipe, inferred_type)),
                            rti_ref), offs_ref_opt), env)
                    handle exn as DebuggerUtilities.ApplyRecipe _ =>
                      if raise_excp then raise exn
                      else
                        (* Do stuff with partial_maps *)
                        ((*print("Attempting partial tyvar substitution for\n" ^
                                Types.debug_print_type options arg_type ^ " as\n" ^
                                Types.debug_print_type options inferred_type ^ " with\n" ^
                                Types.debug_print_type options ty ^ "\n");*)
                         let
                           val map = make_partial_map(arg_type, inferred_type, [])
                         in
                           (RuntimeEnv.VARINFO
                            (str, (ref(apply_map map ty), rti_ref), offs_ref_opt), env)
                         end)
                  end)
              varinfo_env_list
          in
            RuntimeEnv.LET(varinfo_env_list, fix_runtime_env_types env)
          end
          | fix_runtime_env_types(RuntimeEnv.FN(string, env, offs, funinfo)) =
            RuntimeEnv.FN(string, fix_runtime_env_types env, offs, funinfo)
          | fix_runtime_env_types(RuntimeEnv.APP(env, env', int_opt)) =
            RuntimeEnv.APP(fix_runtime_env_types env, fix_runtime_env_types env',
                           int_opt)
          | fix_runtime_env_types(RuntimeEnv.RAISE env) =
            RuntimeEnv.RAISE(fix_runtime_env_types env)
          | fix_runtime_env_types(RuntimeEnv.SELECT(int, env)) =
            RuntimeEnv.SELECT(int, fix_runtime_env_types env)
          | fix_runtime_env_types(RuntimeEnv.STRUCT(env_list)) =
            RuntimeEnv.STRUCT(map fix_runtime_env_types env_list)
          | fix_runtime_env_types(RuntimeEnv.LIST(env_list)) =
            RuntimeEnv.LIST(map fix_runtime_env_types env_list)
          | fix_runtime_env_types(RuntimeEnv.SWITCH(env, offs_ref, int, tag_env_list)) =
            RuntimeEnv.SWITCH
            (fix_runtime_env_types env, offs_ref, int,
             map (fn (tag, env) => (tag, fix_runtime_env_types env)) tag_env_list)
          | fix_runtime_env_types(RuntimeEnv.HANDLE(env, offs_ref, int, int', env')) =
            RuntimeEnv.HANDLE(fix_runtime_env_types env, offs_ref, int, int',
                              fix_runtime_env_types env')
          | fix_runtime_env_types(RuntimeEnv.EMPTY) = RuntimeEnv.EMPTY
          | fix_runtime_env_types(RuntimeEnv.BUILTIN) = RuntimeEnv.BUILTIN
      in
        fix_runtime_env_types
      end

    fun find_space(arg as (s, i)) =
      if i >= size s orelse MLWorks.String.ordof arg = ord #" " then
        i
      else
        find_space(s, i+1)

    fun ignore_spaces(arg as (s, i)) =
      if i >= size s orelse MLWorks.String.ordof arg <> ord #" " then
        i
      else
        ignore_spaces(s, i+1)

    fun find_colon(arg as (s, i)) =
      if i >= size s then
        0
      else
        let
          val arg' = (s, i+1)
        in
          if MLWorks.String.ordof arg = ord #":" then
            ignore_spaces arg'
          else
            find_colon arg'
        end

    fun strip_name s =
      (* Strip up to first : and space, and all after first space *)
      let
        val start = find_colon(s, 0)
        val finish = find_space(s, start)
      in
        substring (* could raise Substring *)(s, start, finish-start)
      end



    local
      fun should_ignore_break {hits, max, name} =
        let
          val (new_hits, new_max, ignore) =
            let val new_hits = hits+1
            in if max >= 0 andalso new_hits >= max
               then (0, 1, false)
               else (new_hits, max, true)
            end
        in
          Trace.update_break{hits=new_hits, max=new_max, name=name};
          ignore
        end

    in
      fun should_ignore INTERRUPT        = false
        | should_ignore (FATAL_SIGNAL _) = false
        | should_ignore (EXCEPTION    _) = false
        | should_ignore (BREAK  fn_info) = 
            (case Trace.is_a_break (strip_name fn_info) of
               SOME break_info => should_ignore_break break_info
             | NONE            => false)
        | should_ignore STACK_OVERFLOW   = false
    end



    fun ignore_command breakpoint_name ignore_count =
      case Trace.is_a_break breakpoint_name of
        SOME {hits, max, name} =>
          (Trace.update_break {hits=hits, max=hits+ignore_count, name=name};
           print"ignoring next ";
           print(Int.toString ignore_count);
           print" hits on the breakpoint ";
           print breakpoint_name;
           print"\n")
      | NONE =>
          (print breakpoint_name;
           print" is not a breakpoint\n")

    fun breakpoints_command () =
      let fun display_breakpoint {hits, max, name} = 
             (print name;
              print" ";
              print(Int.toString hits);
              print" ";
              print(Int.toString max);
              print"\n")
          val breakpoints = Trace.breakpoints ()
      in case breakpoints of
           [] =>
             print"No breakpoints set\n\n"
         | _  =>
             (app display_breakpoint breakpoints;
              print"\n")
      end



    local
      (* A mapping from frame type name to the associated flag.
       * A list is sufficient since the number of entries is small.
       *)
      val frame_visibility = 
        [ ("c",         StackFrame.hide_c_frames)
        , ("anon",      StackFrame.hide_anonymous_frames)
        , ("setup",     StackFrame.hide_setup_frames)
        , ("handler",   StackFrame.hide_handler_frames)
        , ("delivered", StackFrame.hide_delivered_frames)
        , ("duplicate", StackFrame.hide_duplicate_frames)
        ]


      fun frame_type_to_ref frame_type =
        SOME (Lists.assoc (frame_type, frame_visibility))
        handle Lists.Assoc => NONE


      fun apply action frame_type =
        case frame_type_to_ref frame_type of
          NONE => (print"No such frame type as ";
                   print frame_type;
                   print"\n")
        | SOME flag => action flag


      fun display_frames_status status =
        let
          fun out (name, hide) = 
            if !hide = status
            then (print name; print" ")
            else ()
        in
          app out frame_visibility;
          print"\n"
        end


      (*
       * User frames are unconditionally displayed.  However, to make
       * the implementation of frame filtering easier, a ref of the same
       * for that is used for all the other frames (see StackFrame) exists.
       * Since user frames are unconditionaly displayed, this value should
       * never be changed.  If the debugger is changed to allow user frames
       * to be hidden, then move this ref to StackFrame with all the other
       * frame controls.
       *)
      val hide_user_frame = ref false

    in

      (* Display the names of all the frame types that are currently hidden *)

      fun display_hidden_frames_command () =
        display_frames_status true



      (* Display the names of all the frame types that are currently visible *)

      fun display_revealed_frames_command () =
        display_frames_status false



      (* Mark as hidden any frames with the given types.
       * If the frame type is not legal, then issue a warning 
       * for that frame type but process any following frame types.
       * If a given frame type is already set, then leave it set.
       * (Could output a warning ?)
       *)
      fun hide_frame_command frame_types =
        app (apply (fn var => var := true)) frame_types



      (* Mark as visible any frames with the given types.
       * If the frame type is not legal, then issue a warning 
       * for that frame type but process any following frame types.
       * If a given frame type is already set, then leave it set.
       * (Could output a warning ?)
       *)
      fun reveal_frame_command frame_types =
        app (apply (fn var => var := false)) frame_types
        

      (* The backtrace and stack frame movement commands need to take
       * account of whether a given frame is visible at a given point.
       * Whether a frame is visible or not depends on the type of frame, 
       * its name, location, ... etc., and in one case the type of the
       * *next* frame (specifically any ML frame that comes after a 
       * frame which has been identified as a delivered ML frame is
       * considered to be a duplicate frame resulting from the step/next/trace
       * implementation).  It is this last case which makes it awkward
       * to do the test in the display and movement commands, especially
       * since it is necessary to move in both directions in the stack.
       *
       * The solution adopted here is to classify the frames once and for
       * all at the start.  The list of frames then becomes a list of 
       * pairs, where the first item is a boolean reference to the particular
       * flag that controls whether that (type of) frame should be
       * displayed.
       *
       * If you make any changes to the following, make sure that you make
       * the corresponding changes to the gui version (filter_frames in 
       * ../gui/_debugger_window.sml).
       *)
      local
        fun classify ([], fs') = rev fs'
          | classify (((f as (CFRAME (_, name)))::fs), fs') = 
               classify (fs, (StackFrame.hide_c_frames, f)::fs')
          | classify (((f as (MLFRAME (_, ((name, (loc, file_name)), _), _, _)))::fs), fs') =
               case name of
                 "<Setup>" =>  
                   classify (fs, (StackFrame.hide_setup_frames, f)::fs')
               | "<anon>" =>   
                   classify (fs, (StackFrame.hide_anonymous_frames, f)::fs')
               | "<handle>" => 
                   classify (fs, (StackFrame.hide_handler_frames, f)::fs')
               | _ =>
                   if file_name = "" andalso size loc > 0 andalso 
		     MLWorks.String.ordof (loc, 0) <> ord #" " then
                     classify (fs, (hide_user_frame, f)::fs')
                   else
                     let 
                       val f' = (StackFrame.hide_delivered_frames, f)
                     in
                       case fs' of
                         [] => classify (fs, [f'])
                       | ((hide, f)::rest) =>
                           if     hide = hide_user_frame
                           orelse hide = StackFrame.hide_anonymous_frames
                           then classify (fs, f'::(StackFrame.hide_duplicate_frames, f)::rest)
                           else classify (fs, f'::fs')
                     end
      in
        fun classify_frames frames = classify (frames, [])
      end

    end



    (* The show_frame_above and show_frame_below were added to help
     * work out what is stack at any point.  I found these very useful when
     * reworking the stepper and adding the next_command.
     * They shouldn't be visible to users of the debugger.
     * -stephenb
     *)
    fun display_frame (hide, (MLFRAME (frame, ((name, (loc,file_name)), nameStr), _, _))) =
      (print"MLFRAME";
       (if !hide then print" (hidden)" else ());
	print"\nname = X";
	print name;
	print"X\nfile_name= X";
	print file_name;
	print"X\nlocation= X";
	print loc;
	print"X\nnameStr= X";
	print nameStr;
	print"X\n")
      | display_frame (hide, (CFRAME (frame, name))) =
	(print"CFRAME";
	 (if !hide then print" (hidden)" else ());
	  print"\nname = ";
	  print name;
	  print"\n")

    fun show_frame_above_command ([], _, _) = print"TOP\n"
      | show_frame_above_command (above as (a::as'), below, n) =
          if n = 0
          then display_frame a
          else show_frame_above_command (as', a::below, n-1)

    fun show_frame_below_command (_, [], _) = print"BOTTOM\n"
      | show_frame_below_command (above, below as (b::bs), n) =
          if n = 0
          then display_frame b
          else show_frame_below_command (b::above, bs, n-1)

    (*
     * This is just here for debugging/development purposes.
     *)
    local
      fun out m = (print"Parameter = ";
                   print m;
                   print"\n")
    in
      fun show_parameter_command INTERRUPT = out "interrupt"
        | show_parameter_command (FATAL_SIGNAL _) = out "fatal signal"
        | show_parameter_command (EXCEPTION _) = out "exception"
        | show_parameter_command (BREAK _) = out "breakpoint"
        | show_parameter_command STACK_OVERFLOW = out "stack overflow"
    end



    local 

      fun make_frame_details (_, CFRAME (f,s),_) _ =
        ("<Cframe> "^s,"", (Datatypes.NULLTYPE,cast 0,""), NONE)
        | make_frame_details (_, MLFRAME (f,((name,(loc,_)),st),_,NOFRAMEINFO),_) _ =
          (concat[name,"<??>"],
           concat["[",loc,"]"],
           (Datatypes.NULLTYPE,cast 0,""),
           NONE)
        | make_frame_details (_, MLFRAME (f,((name,(loc,_)),st),NONE,_),_) _ =
          (concat[name,"<??>"],
           concat["[",loc,"]"],
           (Datatypes.NULLTYPE,cast 0,""),
           NONE)
        | make_frame_details (options as (Options.OPTIONS {print_options, ...}), MLFRAME (f,
                                       ((name,(loc,_)),st),
                                       SOME arg,
                                       FRAMEINFO(arg_type,annotation,runtime_env,
                                                 ref inferredType)),frames) windowing =
          (concat[name," ",
                   if windowing then ""
                   else
                     ValuePrinter.stringify_value false (print_options,
                                                         arg,
                                                         inferredType,
                                                         get_interpreter_information())],
          concat[name,"[",loc,"]", ":",Types.print_type options inferredType],
          if windowing then
            (inferredType, arg,
             ValuePrinter.stringify_value false (print_options,
                                                 arg,
                                                 inferredType,
                                                 get_interpreter_information()))
          else (Datatypes.NULLTYPE, cast 0,""),
            if windowing then
              let
                val new_runtime_env =
                  (fix_runtime_env_types options
                   (arg_type, inferredType, true)
                   runtime_env)
                  handle DebuggerUtilities.ApplyRecipe _ =>
                    (* Try using the entire set of frames to do the same job *)
                    let
                      fun collect_types(poly_list, mono_list, []) =
                        (poly_list, mono_list)
                        | collect_types(poly_list, mono_list, CFRAME _ :: frames) =
                          collect_types(poly_list, mono_list, frames)
                        | collect_types(poly_list, mono_list,
                                        MLFRAME(_, _, _, NOFRAMEINFO) :: frames) =
                          collect_types(poly_list, mono_list, frames)
                        | collect_types(poly_list, mono_list,
                                        MLFRAME(_, _, _,
                                                FRAMEINFO(arg_type, _, _,
                                                          ref inferredType)) ::
                                        frames) =
                          collect_types(arg_type :: poly_list,
                                        inferredType :: mono_list,
                                        frames)
                      val (poly_type_list, mono_type_list) =
                        collect_types([arg_type], [inferredType], frames)
                      val new_poly_type =
                        type_list_to_rectype poly_type_list
                      val new_mono_type = type_list_to_rectype mono_type_list
                    in
                      (fix_runtime_env_types options
                       (new_poly_type, new_mono_type, false)
                       runtime_env)
                      (* This shouldn't raise, but just in case it does ... *)
                      handle DebuggerUtilities.ApplyRecipe _ =>
                        runtime_env
                    end
                val frame = StackInterface.variable_debug_frame f
              in
                (* This should use the full stack if necessary *)
                (* And now it does *)
                SOME (ref (INL
			   (fn () =>
			    DebuggerPrint.print_env
			    ((frame, new_runtime_env, inferredType),
			     (* Mysterious errors can happen during local variable printing *)
			     (* so we have catchall exception here *)
			     (* This is suboptimal, but beats having the debugger renter itself *)
			     fn (ty1,value) =>
			     ValuePrinter.stringify_value true (print_options,
								value,
								ty1,get_interpreter_information())
			     handle _ => "_" (*XXXX HACK *),
			       options,true,
			       map (fn MLFRAME(frame,_,_,FRAMEINFO(_,_,env,ref ty))=>(frame,env,ty)
			     | MLFRAME (frame,_,_,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)
			     | CFRAME(frame,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE))
			       frames))))
              end
            else NONE)



      fun make_frame_strings (options, frames) =
        let
          fun aux (frame::frames,acc) =
            let
              val details = make_frame_details (options, frame,frames) true
              val stuff =
                case frame of
                  CFRAME (_,loc) => {name = "<Cframe>", loc = loc,details = details}
                | MLFRAME (_,((name,(loc,_)),_),_,_) => {name = name,loc = loc, details = details}
            in
              aux (frames,stuff::acc)
            end
            | aux (nil,acc) = rev acc
        in
          aux (frames,[])
        end



      local
        fun turn_on_exn_details_printing
          (Options.PRINTOPTIONS{maximum_seq_size,
                               maximum_string_size,
                               maximum_ref_depth,
                               maximum_str_depth,
                               maximum_sig_depth,
                               maximum_depth,
                               float_precision,
                               print_fn_details,
                               print_exn_details,
                               show_id_class,
                               show_eq_info}) =
           Options.PRINTOPTIONS{maximum_seq_size = maximum_seq_size,
                                maximum_string_size = maximum_string_size,
                                maximum_ref_depth = maximum_ref_depth,
                                maximum_str_depth = maximum_str_depth,
                                maximum_sig_depth = maximum_sig_depth,
                                maximum_depth = maximum_depth,
                                float_precision = float_precision,
                                print_fn_details = print_fn_details,
                                print_exn_details = true,
                                show_id_class = show_id_class,
                                show_eq_info = show_eq_info}
      in
        fun parameter_details (EXCEPTION exn, print_options) =
              let
                val print_options = turn_on_exn_details_printing print_options
                val exn_name = ValuePrinter.stringify_value false (print_options,
                                                             cast exn,
                                                             Datatypes.CONSTYPE([],Types.exn_tyname),
                                                             get_interpreter_information())
              in
                concat ["Exception ", exn_name, " raised"]
              end
          | parameter_details (INTERRUPT, _) = "Interrupt"
          | parameter_details (FATAL_SIGNAL s, _) =
              "Fatal OS signal " ^ Int.toString s
          | parameter_details (BREAK s, _) = s
          | parameter_details (STACK_OVERFLOW, _) = "Break on stack overflow"
       end



      fun string_to_int str =
        let
          exception Finished of int
          fun factor 0 = 1
            | factor n = 10*factor (n-1)
          fun string_to_int nil (n,_) = n
            | string_to_int (m::ms) (n,power) =
              string_to_int ms
              ((case m of
                  #"1" => 1*(factor power)+n
                | #"2" => 2*(factor power)+n
                | #"3" => 3*(factor power)+n
                | #"4" => 4*(factor power)+n
                | #"5" => 5*(factor power)+n
                | #"6" => 6*(factor power)+n
                | #"7" => 7*(factor power)+n
                | #"8" => 8*(factor power)+n
                | #"9" => 9*(factor power)+n
                | #"0" => n
                | _ => raise Finished(n)),power+1)
        in
          string_to_int (rev(explode str)) (0,0)
          handle Finished(n) => n
        end



      (* As part of the step/next implementation it is necessary to locate
       * the first user frame on the stack.  
       *
       * For example, in the following stack trace taken after a few
       * steps into Btree.fromList ([1,2,3], op<) under Unix, the first
       * user frame is the listfold frame :-
       *
       *   step_always_replacement<??>
       *   <Cframe> start
       *   <Cframe> start intercept
       *   <Cframe> start intercept
       *   listfold argument 0 fn
       *   fromList ([1, 2, 3], fn)
       *   step_always_replacement<??>
       *   <Cframe> start
       *   <Cframe> start intercept
       *   <Cframe> start intercept
       *   fromList ([1, 2, 3], fn)
       *   <Setup> ()
       *)
      local
        (* The delivery mechanism ensures that any functions that are
         * part of a delivered image have a location whose first character
         * is a space.  See rts/src/loader.c for (a little) more info.
         *)
        fun userFrame (MLFRAME (_, ((name, (loc, fileName)), _), _, _)) =
              fileName = "" andalso
              size loc > 0  andalso
              (String.sub(loc, 0)) <> #" "
          | userFrame _ = false
      in
        fun locateFirstUserFrame (BREAK _, frames) = 
          ((case (Lists.findp (fn frame => userFrame frame) frames) of
	      (MLFRAME (frame, _, _, _)) => SOME frame
	    | _                          => NONE) handle Find => NONE)
	  |   locateFirstUserFrame (_, _) = NONE
      end



      local

        fun next ((_,[]), orig, _, k) = k orig
          | next (frames as (above, (frame as (hide, _))::rest), orig, n, k) =
              if !hide then
                next ((frame::above, rest), orig, n, k)
              else
                if n = 0
                then frames
                else next ((frame::above, rest), frames, n-1, k)


        fun prev (([], _), orig, _, k) = k orig
          | prev (frames as ((frame as (hide, _))::rest, below), orig, n, k) =
              let
                val frames' = (rest, frame::below)
              in
                if !hide then
                  prev (frames', orig, n, k)
                else
                  if n = 0
                  then frames'
                  else prev (frames', frames', n-1, k)
              end

      in

        (* Move to nth next visible frame up the stack.
         * if n = 0 and the frame is visible then don't move.
         * If n > number of visible calling frames, then move to the
         * last visible frame.
         *)
        local
          fun hit_bottom frames =
            (print"No calling frame\n";  frames)
        in
          fun next_frame_command (frames, n) =
            next (frames, frames, n, hit_bottom)
        end




        (* Moves to the nth next visible frame down the stack.
         * If n = 0 and the frame is visible then don't move.
         * if n > number of visible called frames, then move to the
         * earliest visible frame.
         *)
        local
          fun hit_top frames = 
            (print"No called frame\n";  frames)
        in
          fun previous_frame_command (frames, n) =
            prev (frames, frames, n, hit_top)
        end



        (* Move to the first visible frame.  This is defined to be (in order):-
         *
         *   1. current frame if visible, 
         *   2. the first visible frame up the stack from the current frame.
         *   3. the first visible frame down the stack from the current frame.
         *
         * Note that in certain circumstances there may not be any visible
         * frames (for example an exception handler invoked from the listener).
         *)
        local
          fun hit_top (above, below) = ((rev below) @@ above, [])
          fun hit_bottom frames = prev (frames, frames, 0, hit_top)
        in
          fun move_to_first_visible_frame frames =
            next (frames, frames, 0, hit_bottom)
        end




        fun goto_top_command frames = move_to_first_visible_frame frames



        (* Goto the last visible stack frame.  In the event that there
         * are no visible stack frames below the current one, then
         * display the current stack frame if it is visible.
         * If that is not visible (it isn't clear to me if this situation
         * can occur) then goto the first visible stack frame above the
         * current one -- this might be confusing for users so perhaps
         * an informational message of some sort would be appropriate.
         *)
        local
          fun hit_top frames = frames
          fun next (frames as (_, []), (_, [])) =
                prev (frames, frames, 0, hit_top)
            | next (frames as (_, []), orig as (_, ((hide, _)::rest))) =
                if !hide
                then prev (orig, frames, 0, hit_top)
                else orig
            | next (frames as (above, (frame as (hide, _))::rest), orig) = 
                let 
                  val above' = (frame::above, rest)
                in
                  if !hide
                  then next (above', orig)
                  else next (above', frames)
                end
        in
          fun goto_bottom_command frames = next (frames, frames)
        end

      end




      fun output_frame_details (options, frame) =
        let
          val frame_details = make_frame_details (options, frame, nil) false
        in
          print( #1 frame_details);
          print"\n"
        end



      (* Display all of the visible frames in the frame list.
       * Each frame is displayed on a separate line.
       *)
      fun backtrace_command (options, frames) =
        let
          fun display (hide, frame) =
            if !hide
            then ()
            else output_frame_details (options, frame)
        in
          print"(Current frame)\n";
          app display frames
        end



      (* Make the debugger step over the next ML function call, assuming
       * there is one!
       *)
      fun next_command NONE = 
            print"No ML function to step over\n"
        | next_command (SOME frame) =
            Trace.next frame



      (* Print out the value of local and closure variables of the current
       * frame if it is an ML frame, otherwise do nothing.
       *)
      fun frame_details_command ([], _) = ()
        | frame_details_command ((_, (CFRAME _))::_, _) = ()
        | frame_details_command ((frames as (_, (MLFRAME (frame, _, _, frameinfo)))::_), options) =
            case frameinfo of
              NOFRAMEINFO => ()
            | FRAMEINFO(_, _, runtime_env, ref ty) =>
                let
                  fun munge_frame (_, (MLFRAME (frame,_,_,FRAMEINFO(_,_,env,ref ty)))) =
                       (frame, env, ty)
                    | munge_frame (_, (MLFRAME (frame,_,_,_))) = 
                       (frame, RuntimeEnv.EMPTY, Datatypes.NULLTYPE)
                    | munge_frame (_, (CFRAME (frame,_))) =
                       (frame, RuntimeEnv.EMPTY, Datatypes.NULLTYPE)

                  val Options.OPTIONS {print_options, ...} = options
                  fun display_value (ty,value) =
                    ValuePrinter.stringify_value true
                      (print_options,
                       value,
                       ty,
                       get_interpreter_information())

                  val windowing = false

                  val frame = StackInterface.variable_debug_frame frame
                  val frame_details = (frame ,runtime_env, ty)
                  val frames = map munge_frame frames
                  (* Mysterious errors can happen during local variable printing *)
                  (* so we have catchall exception here *)
                  (* This is suboptimal, but beats having the debugger renter itself *)
                  val (str, _) = DebuggerPrint.print_env (frame_details, 
                                                          fn (ty,x) => display_value (ty,x) handle _ => "_", (*XXX HACK *)
                                                          options, windowing, frames)
                in
                  print str
                end



      fun edit_frame (preferences, (CFRAME _)) =
            print"Cannot edit source for C frame\n"
        | edit_frame (preferences, (MLFRAME (_,((_,(loc,_)),_),_,_))) =
            (ignore(ShellUtils.edit_source (loc, preferences)); ())
            handle ShellUtils.EditFailed s =>
              print("Edit failed: " ^ s ^ "\n")



    in
      fun ml_debugger
        (type_of_debugger, options, preferences)
        (base_frame, parameter, quit_continuation, continue_continuation) =
        if should_ignore parameter then
          ()
        else
          let
            val Options.OPTIONS {print_options, ...} = options
            val Preferences.PREFERENCES {environment_options,...} = preferences

            val Preferences.ENVIRONMENT_OPTIONS
              {use_debugger, window_debugger, ...} =
              environment_options

            fun stack_empty basic_frames =
              case parameter of
                EXCEPTION _ => length basic_frames <= 2
              (* one for the money, two for the show *)
              | _ => false

            val outfun = print
            fun outline s = outfun (s ^ "\n")

            val output_frame_details = fn frame => output_frame_details (options, frame)

            fun output_full_frame_details frame =
              outline (#2 (make_frame_details (options, frame,nil) false))
            fun prompt s = (outfun s; TextIO.flushOut TextIO.stdOut)

            fun do_quit_action () =
              (case quit_continuation of
                 NOT_POSSIBLE => ()
               | POSSIBLE (_,NORMAL_RETURN) => ()
               | POSSIBLE (_,DO_RAISE exn) => raise exn
               | POSSIBLE (_,FUN f) => f())

            (* This is a "private" exception used to exit from the 
             * debugger inner loop *)
            exception Exit


            val edit_frame = fn frame => edit_frame (preferences, frame)


            fun do_input frames =
              let
                fun is_whitespace char =
                  case char of
                    #" " => true
                  | #"\n" => true
                  | _ => false

                fun parse_command s =
                  let
                    fun parse ([],acc) =
                      (case acc of
                         [] => []
                       | _ =>  [implode (rev acc)])
                      | parse (char::rest,acc) =
                        if is_whitespace char
                          then
                            (case acc of
                               nil => parse (rest,nil)
                             | _ => implode(rev acc)::parse(rest,nil))
                        else
                          parse (rest,char::acc)
                  in
                    parse (explode s,[])
                  end

                fun display_simple_help_info () =
                  outline "Enter ? or help for help"

                fun display_help_info () =
		  app
                  outline
                  (["Commands:",
                    " <                - go to the earliest frame in the stack",
                    " >                - go to the latest frame in the stack",
                    " i                - next frame INto the stack or next later frame (callee)",
                    " i <n>            - next n frames INto the stack",
                    " o                - next frame OUT of the stack or next earlier frame (caller)",
                    " o <n>            - next n frames OUT of the stack",
                    " b                - do a backtrace of the stack",
                    " f                - show full frame details",
                    " e                - edit definition",
                    " h {<name>}       - hide the given types of frame or list hidden frame types if none given",
                    " r {<name>}       - reveal the given types of frame or list the reveald frame types if none given",
                    " p                - print values of local and closure variables",
                    " c                - continue interrupted computation",
                    " s                - step through computation",
                    " s <n>            - step through computation to nth function call",
                    " n                - step over the current function to the start of the next one",
                    " trace <name>     - set trace on function entry at <name>",
                    " breakpoint <name> - set breakpoint on function entry at <name>",
                    " untrace <name>   - unset trace on function entry at <name>",
                    " unbreakpoint <name> - unset breakpoint on function entry at <name>",
                    " breakpoints      - display the list of breakpoints",
                    " ignore name n    - ignore the next n hits on the breakpoint on function <name>",
                    " help             - display this help info",
                    " ?                - display this help info"] @@
                  (case continue_continuation of
                     POSSIBLE(st,_) => [" c                - " ^ st]
                   | _ => []) @@
                     (case quit_continuation of
                        POSSIBLE(st,_) => [" q                - " ^ st]
                      | _ => []))


                val firstUserFrame = locateFirstUserFrame (parameter, frames)
                val classified_frames = ([], classify_frames frames)



                fun loop (frames as (above, below)) =
                  let

                    (* Next two functions raise Exit, so only call from inside loop *)
                    (* Attempt to return from the debugger to whatever called
                     * it.  If this is possible, the action is performed before
                     * returning.
                     *)
                    fun do_continue action =
                      (case continue_continuation of
                         NOT_POSSIBLE => outline "Cannot Continue"
                       | POSSIBLE (_,NORMAL_RETURN) => (ignore(action ()); raise Exit)
                       | POSSIBLE (_,DO_RAISE exn) => raise exn
                       | POSSIBLE (_,FUN f) => (ignore(action ()); f (); raise Exit))


                    fun do_quit () =
                      (case quit_continuation of
                         NOT_POSSIBLE => outline "Cannot Quit"
                       | POSSIBLE (_,NORMAL_RETURN) => raise Exit
                       | POSSIBLE (_,DO_RAISE exn) => raise exn
                       | POSSIBLE (_,FUN f) => (f()))

                    fun apply_to_current_frame action =
                      case below of
                        [] => print"No visible frame\n"
                      | ((_, this)::_) => action this


                    val _ = if Trace.stepping ()
                            then ()
                            else apply_to_current_frame output_frame_details

                    val _ = prompt "Debugger> "

                    val command_and_args =
                      let
                        val _ =
                          if TextIO.endOfStream TextIO.stdIn then
                            (do_quit(); raise Exit)
                          else ()

                        val line = TextIO.inputLine TextIO.stdIn
                      in
                        parse_command line
                      end

                  in
                    case command_and_args of
                      ">"::_ => loop (goto_top_command classified_frames)
                    | "<"::_ => loop (goto_bottom_command frames)
                    | "f"::_ =>
                        (apply_to_current_frame output_full_frame_details;
                         loop frames)
                    | "e"::_ =>
                        (apply_to_current_frame edit_frame;  loop frames)
                    | ["i"] =>
                        loop (previous_frame_command (frames, 1))
                    | "i"::arg::_ =>
                        let
                          val n = string_to_int arg
                        in
                          loop (previous_frame_command (frames, n))
                        end
                    | ["o"] =>
                        loop (next_frame_command (frames, 1))
                    | "o"::arg::_ =>
                        let
                          val n = string_to_int arg
                        in
                          loop (next_frame_command (frames, n))
                        end
                    | ["b"] =>
                        (backtrace_command (options, below);
                         print"(Outermost frame)\n";
                         loop frames)
                    | ("b"::arg::_) =>
                        let
                          val frames' = firstn (below, string_to_int arg)
                        in
                          backtrace_command (options, frames');
                          loop frames
                        end
                    | "c"::_ =>
                        (do_continue (fn () => ());
                         loop frames)
                    | ["h"] => 
                        (display_hidden_frames_command ();
                         loop frames)
                    | "h"::names =>
                        (hide_frame_command names;
                         loop (move_to_first_visible_frame frames))
                    | "q"::_ =>
                        (do_quit ();
                         ignore(raise Exit); (* Why the call to loop frames after this ? *)
                         loop frames)
                    | ["r"] => 
                       (display_revealed_frames_command ();
                        loop frames)
                    | "r"::names => 
                        (reveal_frame_command names;
                         loop (move_to_first_visible_frame frames))
                    | ""::_ => loop frames
                    | "?"::_ =>
                        (display_help_info();  loop frames)
                    | "help"::_ =>
                        (display_help_info();  loop frames)
                    | "trace" :: args =>
			(app Trace.trace args;  loop frames)
                    | ["breakpoints"] =>
                        (breakpoints_command ();  loop frames)
                    | "breakpoint" :: args =>
                        (app Trace.break
                          (map (fn name => {name=name, hits=0, max=1}) args);
                         loop frames)
                    | "ignore" :: fn_name :: n :: _ =>
                        (ignore_command fn_name (string_to_int n);
                         loop frames)
                    | "untrace" :: args => (app Trace.untrace args;
                                            loop frames)
                    | "unbreakpoint" :: args =>
                         (app Trace.unbreak args;  loop frames)
                    | ["s"] =>
                         (do_continue (fn () => Trace.set_stepping true);
                          loop frames)
                    | "s" :: arg :: _ => 
                       (do_continue (fn () =>
                          (Trace.set_stepping true;
                           Trace.set_step_count (string_to_int arg)));
                        loop frames)
                    | ["n"] => 
                        (do_continue (fn () => next_command firstUserFrame);
                         loop frames)
                    | "show_frame_above"::arg::_ => 
                        (show_frame_above_command (above, below, string_to_int arg);
                         loop frames)
                    | "show_frame_below"::arg::_ => 
                        (show_frame_below_command (above, below, string_to_int arg);
                         loop frames)
                    | ["show_parameter"] =>
                        (show_parameter_command parameter;
                         loop frames)
                    | ["t"] => 
                        (do_continue (fn () => Trace.set_trace_all true);
                         loop frames)
                    | "p"::_ =>
                        (frame_details_command (below, options);
                         loop frames)
                    | "show_debug"::_ =>
                        (let
                           val debug_info = get_interpreter_information ()
                         in
                           app (fn s => print(s^"\n")) (Debugger_Types.print_information options (debug_info,true))
                         end;
                         loop frames)
                    | _ => (display_simple_help_info();
                            loop frames)
                  end
              in
                (if Trace.stepping () then
                   ()
                 else
                   outline "Current (innermost) stack frame:");
                loop (move_to_first_visible_frame classified_frames)
                handle Exit => ()
              end

            fun make_entry_info_line () =
              (case quit_continuation of
                 POSSIBLE (s,_) => "q : " ^ s ^ ", "
               | _ => "") ^
                 (case continue_continuation of
                    POSSIBLE (s,_) => "c : " ^ s ^ ", "
                  | _ => "") ^
                    " ? : more help"

            fun tty_debugger basic_frames =
              if not (!use_debugger) then
                (outline (parameter_details (parameter, print_options));
                 do_quit_action ())
              else
                if stack_empty basic_frames then
                  outline (parameter_details (parameter, print_options) ^ " at top level")
                else
                  (outline (parameter_details (parameter, print_options));
                   (if Trace.stepping () then
                      ()
                    else
                      outline ("Entering debugger, commands: " ^ make_entry_info_line ()));
                   do_input (make_frames (basic_frames,parameter,options)))
          in
            let
              val top_frame = MLWorks.Internal.Value.Frame.current ()

              val no_message = Trace.stepping ()  orelse not (!use_debugger)
              val _ = 
                if no_message
                  then ()
                else outputMessage "Entering Debugger, scanning stack ... "

              val basic_frames =
                StackInterface.get_basic_frames (top_frame,base_frame)

              val _ = 
                if no_message
                  then ()
                else outputMessage "done.\n";
            
              (* The identifier debugger_call is never used; 
                 this is deliberate!  See below.  *)
              val debugger_call =
                case type_of_debugger of
                  TERMINAL =>
                    tty_debugger basic_frames
                | WINDOWING (make_window, send_message, tty_ok) =>
                    if tty_ok andalso not (!window_debugger) then
                      tty_debugger basic_frames
                    else if not (!use_debugger) then
                      (send_message (parameter_details (parameter, print_options) ^ "\n");
                       do_quit_action ())
                    else if stack_empty basic_frames then
                      send_message (parameter_details (parameter, print_options) ^ " at top level\n")
                    else
                      let
                        (* This is terribly distracting when stepping *)
                        (* val _ = outline (parameter_details (parameter, print_options)) *)
                        val frames = make_frames (basic_frames,parameter,options)
                        val firstUserFrame = locateFirstUserFrame (parameter, frames)
                        val frame_strings = make_frame_strings (options, frames)
                      in
                        make_window
                          {parameter_details = parameter_details (parameter, print_options),
                           frames = frame_strings,
                           quit_fn =
                             make_continuation_function quit_continuation,
                           continue_fn = 
                             make_continuation_function continue_continuation,
                           top_ml_user_frame = firstUserFrame};
                        ()
                      end
            in
              (* Ensure call to tty_debugger not tail, else frame is invalid *)
              (* The lambda optimizer is unable to guarantee that this will be maintained *)
              ()
            end
          end
    end


    val start_frame_ref = ref (MLWorks.Internal.Value.Frame.current())



    (* The "Trace.set_stepping previousStepStatus" expression is there to
     * ensure that all stepping is restored to its previous status
     * (generally off) before returning to the top level.
     * In previous versions of the debugger, an equivalent was sprinkled
     * around various parts of the debugger to try and ensure that stepping
     * was turned off, however they never dealt with all the possible cases,
     * particularly the case where the user used step/next to step right
     * to the end of a computation and doesn't exit the debugger using 
     * "c"ontinue or "q"uit.
     *)
    fun with_start_frame f =
      let
        val frame = MLWorks.Internal.Value.Frame.current ()
        val old_frame = !start_frame_ref
        val _ = start_frame_ref := frame
        val previousStepStatus = Trace.stepping ()
        val result =
          f frame
          handle exn => (start_frame_ref := old_frame; Trace.set_stepping previousStepStatus; raise exn)
      in
        start_frame_ref := old_frame;
        Trace.set_stepping previousStepStatus;
        result
      end



    fun get_start_frame () = !start_frame_ref

    val debugger_type_ref = ref TERMINAL

    fun with_debugger_type debugger_type f =
      let
        val old_type = !debugger_type_ref
        val _ = debugger_type_ref := debugger_type
        val result = (with_start_frame f) handle exn => (debugger_type_ref := old_type; raise exn)
      in
        debugger_type_ref := old_type;
        result
      end

    fun get_debugger_type () = !debugger_type_ref

  end
@


1.186.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.186  1999/02/02  15:59:08  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.185
log
@[Bug #70099]
Modifications to encapsulation format to put type_env first
@
text
@d4 4
a657 1
require "$.basis.__list";
@


1.184
log
@[Bug #70058]
Add a function to collect the stamps of all submodules when getting
type information
@
text
@d4 5
d885 1
a885 1
      ref empty_map : (string, (string * (int * int)))NewMap.map ref
d907 1
a907 1
		       NewMap.define(!stamp_map, name, (name, (stamps, 0)));
d955 2
a956 1
					  (file, !stamp_map)
@


1.183
log
@[Bug #70077]
Remove use of Path, and replace with OS.Path
@
text
@d4 4
d657 2
d662 1
d681 3
d715 3
d773 1
a773 1
    val empty_map = NewMap.empty' (op =)
d875 1
a875 2
    fun add_to_cache x =
      data_cache := x :: !data_cache
d879 35
d921 16
a936 22
           | _ =>
               (* This needs to be thought about a little *)
               ((* debug (fn _ => "No info for " ^ name_string); *)
                let
                  val file = Path.base source_file
                  val file_debug_info =
                    if Lists.member(file,["","__pervasive_library","__builtin_library"]) then
                      Debugger_Types.empty_information
                    else
                      cache_lookup file
		      handle CacheFail =>
			(let
			   val information =
			     Encapsulate.input_debug_info(file ^ ".mo", empty_map)
			 (* I think the empty_map above is a bug (70058) *)
			 in
			   (add_to_cache (file,information); information)
			 end
			   handle Encapsulate.BadInput msg =>
			     (debug (fn _ =>
				     "Decapsulation failed for function " ^
				     function_name ^ ": " ^ file ^ ":" ^ msg);
d938 17
a954 1
				val information = Debugger_Types.empty_information
d956 21
a976 7
				(add_to_cache (file,information); information)
			      end))
                in
                  case Debugger_Types.lookup_debug_info (file_debug_info, name_string) of
                    SOME funinfo => (funinfo,source_file)
                  | _ => raise FailedToGetTypeInfo
                end)
a1056 2


a1287 4
(*
        val print_int : int -> unit =
          MLWorks.Internal.Value.cast(MLWorks.Internal.Runtime.environment "print integer")
*)
a1293 5
(*
        val _ = debug_print("parameter type: " ^ print_parameter parameter ^
                            " step_through name: " ^ step_through_name)
        val _ = print_int step_through
*)
d1428 2
a1542 6
(*
        val _ = print("Looking for name of '" ^ s ^ "' with start = " ^
                      Int.toString start ^
                      " and finish = " ^
                      Int.toString finish ^ "\n")
*)
@


1.182
log
@[Bug #30090]
Remove use of MLWorks.IO
@
text
@d4 4
d653 1
a653 1
require "^.basis.path";
d671 1
a671 1
  structure Path : PATH
d878 1
a878 1
                  val file = Path.name (source_file) (* OS.Path.file *)
@


1.181
log
@[Bug #70074]
Add depth limit support for signature printing
@
text
@d4 4
d879 18
a896 20
                      (cache_lookup file
                       handle CacheFail =>
                         (let
			    val information =
			      Encapsulate.input_debug_info(file ^ ".mo", empty_map)
			  (* I think the empty_map above is a bug (70058) *)
                          in
                            (add_to_cache (file,information); information)
                          end
                        handle Encapsulate.BadInput msg =>
                          (debug (fn _ =>
                                  "Decapsulation failed for function " ^
                                  function_name ^ ": " ^ file ^ ":" ^ msg);
                           let
                             val information = Debugger_Types.empty_information
                           in
                             (add_to_cache (file,information); information)
                           end)))
                      handle MLWorks.IO.Io arg =>
			Debugger_Types.empty_information
@


1.180
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
d1866 1
d1877 1
@


1.179
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@d4 4
d1002 1
a1002 1
                      Debugger_Types.ERROR string;
d2161 1
a2161 1
            (ShellUtils.edit_source (loc, preferences); ())
d2293 1
a2293 1
                       | POSSIBLE (_,NORMAL_RETURN) => (action (); raise Exit)
d2295 1
a2295 1
                       | POSSIBLE (_,FUN f) => (action (); f (); raise Exit))
d2376 1
a2376 1
                         raise Exit;
@


1.178
log
@[Bug #70065]
Remove uses of MLWorks.IO.messages and use the Messages structure
@
text
@d4 4
d636 1
d708 1
a708 1
      fun debug_print s = MLWorks.IO.output(MLWorks.IO.terminal_out,"  # " ^ s ^ "\n")
@


1.177
log
@[Bug #30331]
Modify to use Encapsulate.input_debug_info
@
text
@d4 4
d631 1
d750 2
a751 2
      (MLWorks.IO.output (MLWorks.IO.messages, message);
       MLWorks.IO.flush_out MLWorks.IO.messages)
@


1.176
log
@[Bug #30328]
Add environment parameter to decode_type_basis
for finding pervasive type names
@
text
@d4 5
d860 3
a862 4
                            val (_,information) =
                              Encapsulate.decode_type_basis
                              (#type_env (Encapsulate.input_all (file ^ ".mo")),file,empty_map,true,
			       Datatypes.ENV(Datatypes.SE(NewMap.empty' (op =)), Datatypes.TE(NewMap.empty' (op =)), Datatypes.empty_valenv))
@


1.175
log
@[Bug #30320]
Swap effects of < and > around
@
text
@d4 4
a661 1

d663 1
a663 1

d857 2
a858 1
                              (#type_env (Encapsulate.input_all (file ^ ".mo")),file,empty_map,true)
@


1.174
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 4
d2309 2
a2310 2
                      "<"::_ => loop (goto_top_command classified_frames)
                    | ">"::_ => loop (goto_bottom_command frames)
@


1.173
log
@[Bug #30201]
Remove Unix-ism "Fatal Unix signal" and replace
with "Fatal OS signal"
@
text
@d4 5
d607 4
a610 3
require "^.basis.__int";
require "^.basis.__list";
require "^.basis.__text_io";
a627 1
require "^.basis.__old";
d1927 1
a1927 1
              Old.ord loc <> ord #" "
@


1.173.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 5
 * Revision 1.173  1997/07/21  16:47:26  jont
 * [Bug #30201]
 * Remove Unix-ism "Fatal Unix signal" and replace
 * with "Fatal OS signal"
 *
@


1.173.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 5
 * Revision 1.173  1997/07/21  16:47:26  jont
 * [Bug #30201]
 * Remove Unix-ism "Fatal Unix signal" and replace
 * with "Fatal OS signal"
 *
@


1.172
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@d4 4
d1860 1
a1860 1
              "Fatal Unix signal " ^ Int.toString s
@


1.171
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d600 2
d1365 1
a1365 1
                        ((*output(MLWorks.IO.std_out, "Attempting partial tyvar substitution for\n" ^
d1437 4
a1440 5
        val _ = output(MLWorks.IO.std_out,
                       "Looking for name of '" ^ s ^ "' with start = " ^
                       Int.toString start ^
                       " and finish = " ^
                       Int.toString finish ^ "\n")
d1479 5
a1483 5
           MLWorks.IO.output (MLWorks.IO.std_out, "ignoring next ");
           MLWorks.IO.output (MLWorks.IO.std_out, Int.toString ignore_count);
           MLWorks.IO.output (MLWorks.IO.std_out, " hits on the breakpoint ");
           MLWorks.IO.output (MLWorks.IO.std_out, breakpoint_name);
           MLWorks.IO.output (MLWorks.IO.std_out, "\n"))
d1485 2
a1486 3
          (MLWorks.IO.output (MLWorks.IO.std_out, breakpoint_name);
           MLWorks.IO.output (MLWorks.IO.std_out, " is not a breakpoint\n"))

d1490 6
a1495 6
             (MLWorks.IO.output (MLWorks.IO.std_out, name);
              MLWorks.IO.output (MLWorks.IO.std_out, " ");
              MLWorks.IO.output (MLWorks.IO.std_out, Int.toString hits);
              MLWorks.IO.output (MLWorks.IO.std_out, " ");
              MLWorks.IO.output (MLWorks.IO.std_out, Int.toString max);
              MLWorks.IO.output (MLWorks.IO.std_out, "\n"))
d1499 1
a1499 1
             MLWorks.IO.output (MLWorks.IO.std_out, "No breakpoints set\n\n")
d1502 1
a1502 1
              MLWorks.IO.output (MLWorks.IO.std_out, "\n"))
d1528 3
a1530 3
          NONE => (MLWorks.IO.output (MLWorks.IO.std_out, "No such frame type as ");
                   MLWorks.IO.output (MLWorks.IO.std_out, frame_type);
                   MLWorks.IO.output (MLWorks.IO.std_out, "\n"))
d1538 1
a1538 1
            then (MLWorks.IO.output (MLWorks.IO.std_out, name); MLWorks.IO.output (MLWorks.IO.std_out, " "))
d1542 1
a1542 1
          MLWorks.IO.output (MLWorks.IO.std_out, "\n")
d1658 11
a1668 11
      (MLWorks.IO.output (MLWorks.IO.std_out, "MLFRAME");
       (if !hide then MLWorks.IO.output (MLWorks.IO.std_out, " (hidden)") else ());
	MLWorks.IO.output (MLWorks.IO.std_out, "\nname = X");
	MLWorks.IO.output (MLWorks.IO.std_out, name);
	MLWorks.IO.output (MLWorks.IO.std_out, "X\nfile_name= X");
	MLWorks.IO.output (MLWorks.IO.std_out, file_name);
	MLWorks.IO.output (MLWorks.IO.std_out, "X\nlocation= X");
	MLWorks.IO.output (MLWorks.IO.std_out, loc);
	MLWorks.IO.output (MLWorks.IO.std_out, "X\nnameStr= X");
	MLWorks.IO.output (MLWorks.IO.std_out, nameStr);
	MLWorks.IO.output (MLWorks.IO.std_out, "X\n"))
d1670 5
a1674 5
	(MLWorks.IO.output (MLWorks.IO.std_out, "CFRAME");
	 (if !hide then MLWorks.IO.output (MLWorks.IO.std_out, " (hidden)") else ());
	  MLWorks.IO.output (MLWorks.IO.std_out, "\nname = ");
	  MLWorks.IO.output (MLWorks.IO.std_out, name);
	  MLWorks.IO.output (MLWorks.IO.std_out, "\n"))
d1676 1
a1676 1
    fun show_frame_above_command ([], _, _) = MLWorks.IO.output (MLWorks.IO.std_out, "TOP\n")
d1682 1
a1682 1
    fun show_frame_below_command (_, [], _) = MLWorks.IO.output (MLWorks.IO.std_out, "BOTTOM\n")
a1687 3



d1692 3
a1694 3
      fun out m = (MLWorks.IO.output (MLWorks.IO.std_out, "Parameter = ");
                   MLWorks.IO.output (MLWorks.IO.std_out, m);
                   MLWorks.IO.output (MLWorks.IO.std_out, "\n"))
d1964 1
a1964 1
            (MLWorks.IO.output (MLWorks.IO.std_out, "No calling frame\n");  frames)
d1980 1
a1980 1
            (MLWorks.IO.output (MLWorks.IO.std_out, "No called frame\n");  frames)
d2049 2
a2050 2
          MLWorks.IO.output (MLWorks.IO.std_out, #1 frame_details);
          MLWorks.IO.output (MLWorks.IO.std_out, "\n")
d2065 1
a2065 1
          MLWorks.IO.output (MLWorks.IO.std_out, "(Current frame)\n");
d2075 1
a2075 1
            MLWorks.IO.output (MLWorks.IO.std_out, "No ML function to step over\n")
d2118 1
a2118 1
                  MLWorks.IO.output (MLWorks.IO.std_out, str)
d2124 1
a2124 1
            MLWorks.IO.output (MLWorks.IO.std_out, "Cannot edit source for C frame\n")
d2128 1
a2128 1
              MLWorks.IO.output (MLWorks.IO.std_out, "Edit failed: " ^ s ^ "\n")
d2153 1
a2153 1
            fun outfun s = MLWorks.IO.output(MLWorks.IO.std_out,s)
d2160 1
a2160 1
            fun prompt s = (outfun s; MLWorks.IO.flush_out MLWorks.IO.std_out)
d2272 1
a2272 1
                        [] => MLWorks.IO.output (MLWorks.IO.std_out, "No visible frame\n")
d2285 1
a2285 1
                          if MLWorks.IO.end_of_stream MLWorks.IO.std_in then
d2289 1
a2289 1
                        val line = MLWorks.IO.input_line MLWorks.IO.std_in
d2321 1
a2321 1
                         MLWorks.IO.output (MLWorks.IO.std_out, "(Outermost frame)\n");
d2399 1
a2399 1
                           app (fn s => MLWorks.IO.output(MLWorks.IO.std_out,s^"\n")) (Debugger_Types.print_information options (debug_info,true))
@


1.170
log
@Adding catchall handlers around print function
@
text
@d4 3
d666 2
d873 1
a873 1
        MLWorks.Option.union ref option
d1779 17
a1795 17
                SOME (ref (MLWorks.Option.INL
                                          (fn () =>
                                           DebuggerPrint.print_env
                                           ((frame, new_runtime_env, inferredType),
                                            (* Mysterious errors can happen during local variable printing *)
                                            (* so we have catchall exception here *)
                                            (* This is suboptimal, but beats having the debugger renter itself *)
                                            fn (ty1,value) =>
                                            ValuePrinter.stringify_value true (print_options,
                                                                               value,
                                                                               ty1,get_interpreter_information())
                                            handle _ => "_" (*XXXX HACK *),
                                            options,true,
                                            map (fn MLFRAME(frame,_,_,FRAMEINFO(_,_,env,ref ty))=>(frame,env,ty)
                                          | MLFRAME (frame,_,_,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)
                                          | CFRAME(frame,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE))
                                            frames))))
@


1.170.1.1
log
@branched from 1.170
@
text
@a3 3
 * Revision 1.170  1997/03/21  15:43:26  matthew
 * Adding catchall handlers around print function
 *
@


1.170.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.170.1.1  1997/05/12  10:29:28  hope
 * branched from 1.170
 *
@


1.170.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.170.1.1  1997/05/12  10:29:28  hope
 * branched from 1.170
 *
@


1.170.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.170.1.1  1997/05/12  10:29:28  hope
 * branched from 1.170
 *
@


1.170.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.170.1.1.1.1  1997/07/28  18:15:20  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.169
log
@[Bug #1822]
make_frame_details: introduce a Stack_Interface.variable_debug_frame
call at an appropriate point ensure that details of the correct
frame are displayed.
@
text
@d4 6
d1778 3
d1784 2
a1785 1
                                                                               ty1,get_interpreter_information()),
d2105 6
a2110 1
                  val (str, _) = DebuggerPrint.print_env (frame_details, display_value, options, windowing, frames)
@


1.168
log
@Don't exit with do_quit if use_debugger is false
@
text
@d4 3
d1764 1
d1771 1
a1771 1
                                           ((f, new_runtime_env, inferredType),
@


1.167
log
@[Bug #1786]
do_continue: add a raise Exit in the FUN case so that the debugger loop
is exited.
@
text
@d4 5
d2137 7
a2148 20
            (* Attempt to return from the debugger to whatever called
             * it.  If this is possible, the action is performed before
             * returning.
             *)
            fun do_continue action =
              (case continue_continuation of
                 NOT_POSSIBLE => outline "Cannot Continue"
               | POSSIBLE (_,NORMAL_RETURN) => (action (); raise Exit)
               | POSSIBLE (_,DO_RAISE exn) => raise exn
               | POSSIBLE (_,FUN f) => (action (); f (); raise Exit))


            fun do_quit () =
              (case quit_continuation of
                 NOT_POSSIBLE => outline "Cannot Quit"
               | POSSIBLE (_,NORMAL_RETURN) => raise Exit
               | POSSIBLE (_,DO_RAISE exn) => raise exn
               | POSSIBLE (_,FUN f) => (f()))


d2225 20
d2401 1
a2401 1
                 do_quit ())
d2416 1
d2418 2
a2419 2
                if Trace.stepping ()
                then ()
d2426 2
a2427 2
                if Trace.stepping ()
                then ()
d2441 1
a2441 1
                       do_quit ())
d2464 1
@


1.166
log
@[Bug #1461]
Change to stack closure tags.
@
text
@d4 4
d2146 1
a2146 1
               | POSSIBLE (_,FUN f) => (action (); f ()))
@


1.166.4.1
log
@branched from 1.166
@
text
@a3 4
 * Revision 1.166  1996/11/07  17:27:53  stephenb
 * [Bug #1461]
 * Change to stack closure tags.
 *
@


1.166.3.1
log
@branched from 1.166
@
text
@a3 4
 * Revision 1.166  1996/11/07  17:27:53  stephenb
 * [Bug #1461]
 * Change to stack closure tags.
 *
@


1.166.3.1.1.1
log
@branched from 1.166.3.1
@
text
@a3 3
 * Revision 1.166.3.1  1996/12/17  17:43:19  hope
 * branched from 1.166
 *
@


1.166.2.1
log
@branched from 1.166
@
text
@a3 4
 * Revision 1.166  1996/11/07  17:27:53  stephenb
 * [Bug #1461]
 * Change to stack closure tags.
 *
@


1.166.1.1
log
@branched from 1.166
@
text
@a3 4
 * Revision 1.166  1996/11/07  17:27:53  stephenb
 * [Bug #1461]
 * Change to stack closure tags.
 *
@


1.166.1.1.1.1
log
@branched from 1.166.1.1
@
text
@a3 3
 * Revision 1.166.1.1  1996/11/14  12:43:56  hope
 * branched from 1.166
 *
@


1.165
log
@[Bug #1441]
Change from using word to byte offsets for annotation indices.
This is necessary because the instructions on an I386 are not
word aligned as they are on a SPARC/MIPS.
@
text
@d4 6
a958 2
            else if n = Tags.STACK_START_INTERCEPT then "start intercept"
            else if n = Tags.STACK_END then "end"
d960 2
a961 1
            else if n = Tags.STACK_LEAF_RAISE then "leaf raise"
a962 2
            else if n = Tags.STACK_RESUME then "resume"
            else if n = Tags.STACK_PROFILE then "profile"
@


1.164
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d892 1
a892 1
      SOME (fn _ => ())
a899 2
    (* Note that offset is a _word_ count *)

d906 4
d922 1
a922 1
              val _ = debug (fn _ => "Getting info for " ^ name ^ ", offset: " ^ Int.toString (4 * offset))
d924 1
a924 1
                case assoc (4 * offset,annotations) of
d930 1
a930 1
                         Int.toString (4 * offset) ^ " for " ^ name)
@


1.163
log
@[Bug #1614]
basifying String
@
text
@d4 4
d563 1
a563 1
require "^.basis.__integer";
@


1.162
log
@As discussed in mlworks.mail.{8075,8081,8086}, display
a message when about to and just after scanning the stack
when entering the debugger.
@
text
@d4 5
d560 1
d577 1
d641 1
a641 1
          Lists.iterate debug_print (f ())
d648 1
a648 1
    fun assoc (a,[]) = MLWorks.Option.NONE
d650 1
a650 1
        if a = a' then MLWorks.Option.SOME b
d686 2
a687 1
    (* This works on exploded strings *)
d701 1
d706 1
a706 1
        fun aux1(":"::l,acc) = String.implode(rev acc)
d708 1
a708 1
          | aux1([],acc) = String.implode(rev acc)
d710 1
a710 1
        aux1(String.explode locdata,[])
d718 1
a718 1
            fun aux1("["::l,acc) = (acc,l)
d721 2
a722 2
            fun aux2(["]"],acc) = (acc,nil)
              | aux2("]"::l,acc) = (duff();(acc,l))
d725 1
a725 1
            val (namechars,rest) = aux1(String.explode code_name,[])
d728 1
a728 1
            (String.implode(rev namechars),(String.implode(rev locchars),String.implode fnname))
d782 1
a782 1
          MLWorks.Option.SOME funinfo =>
d815 1
a815 1
                    MLWorks.Option.SOME funinfo => (funinfo,source_file)
d836 1
a836 1
        MLWorks.Option.union ref MLWorks.Option.option
d843 3
a845 3
         quit_fn: (unit -> unit) MLWorks.Option.option,
         continue_fn: (unit -> unit) MLWorks.Option.option,
         top_ml_user_frame: MLWorks.Internal.Value.Frame.frame MLWorks.Option.option}
d879 1
a879 1
      MLWorks.Internal.Value.T MLWorks.Option.option*
d884 1
a884 1
      MLWorks.Option.SOME (fn _ => ())
d886 1
a886 1
        MLWorks.Option.SOME (fn _ => raise exn)
d888 1
a888 1
        MLWorks.Option.SOME f
d890 1
a890 1
        MLWorks.Option.NONE
d915 1
a915 1
                  MLWorks.Option.SOME a => a
d930 1
a930 1
		 MLWorks.Option.SOME(StackInterface.frame_arg frame)
d932 1
a932 1
		 MLWorks.Option.NONE)
d934 1
a934 1
          handle FailedToGetTypeInfo => (NOFRAMEINFO, MLWorks.Option.NONE)
d1116 2
a1117 2
            if String.substring(s, i, 2) = sys_indicator then
              String.substring(s, 0, i+2)
d1265 1
a1265 1
                                   String.implode ["Combine types fails for: ",
d1365 1
a1365 1
      if i >= size s orelse String.ordof arg = String.ord" " then
d1371 1
a1371 1
      if i >= size s orelse String.ordof arg <> String.ord" " then
d1383 1
a1383 1
          if String.ordof arg = String.ord":" then
d1402 1
a1402 1
        String.substring(s, start, finish-start)
a1407 2
      open MLWorks.Option

d1436 1
a1436 1
        MLWorks.Option.SOME {hits, max, name} =>
d1443 1
a1443 1
      | MLWorks.Option.NONE =>
d1461 1
a1461 1
             (Lists.iterate display_breakpoint breakpoints;
a1467 3
      open MLWorks.Option


d1501 1
a1501 1
          Lists.iterate out frame_visibility;
d1540 1
a1540 1
        Lists.iterate (apply (fn var => var := true)) frame_types
d1551 1
a1551 1
        Lists.iterate (apply (fn var => var := false)) frame_types
d1588 2
a1589 1
                   if file_name = "" andalso size loc > 0 andalso String.ord loc <> String.ord " " then
d1671 1
a1671 1
        ("<Cframe> "^s,"", (Datatypes.NULLTYPE,cast 0,""), MLWorks.Option.NONE)
d1673 2
a1674 2
          (String.implode[name,"<??>"],
           String.implode["[",loc,"]"],
d1676 4
a1679 4
           MLWorks.Option.NONE)
        | make_frame_details (_, MLFRAME (f,((name,(loc,_)),st),MLWorks.Option.NONE,_),_) _ =
          (String.implode[name,"<??>"],
           String.implode["[",loc,"]"],
d1681 1
a1681 1
           MLWorks.Option.NONE)
d1684 1
a1684 1
                                       MLWorks.Option.SOME arg,
d1687 1
a1687 1
          (String.implode[name," ",
d1694 1
a1694 1
          String.implode[name,"[",loc,"]", ":",Types.print_type options inferredType],
d1742 1
a1742 1
                MLWorks.Option.SOME (ref (MLWorks.Option.INL
d1756 1
a1756 1
            else MLWorks.Option.NONE)
d1810 1
a1810 1
                String.implode ["Exception ", exn_name, " raised"]
d1830 10
a1839 10
                  "1" => 1*(factor power)+n
                | "2" => 2*(factor power)+n
                | "3" => 3*(factor power)+n
                | "4" => 4*(factor power)+n
                | "5" => 5*(factor power)+n
                | "6" => 6*(factor power)+n
                | "7" => 7*(factor power)+n
                | "8" => 8*(factor power)+n
                | "9" => 9*(factor power)+n
                | "0" => n
d1842 1
a1842 1
          string_to_int (rev(String.explode str)) (0,0)
d1876 1
a1876 1
              String.ord loc <> String.ord " "
a1877 2
        
        open MLWorks.Option
d1881 3
a1883 3
                (MLFRAME (frame, _, _, _)) => SOME frame
           | _                          => NONE) handle Find => NONE)
        |   locateFirstUserFrame (_, _) = NONE
d2024 1
a2024 1
          Lists.iterate display frames
d2032 1
a2032 1
      fun next_command MLWorks.Option.NONE = 
d2034 1
a2034 1
        | next_command (MLWorks.Option.SOME frame) =
d2102 1
a2102 1
                EXCEPTION _ => Lists.length basic_frames <= 2
d2147 2
a2148 2
                    " " => true
                  | "\n" => true
d2156 1
a2156 1
                       | _ =>  [String.implode (rev acc)])
d2162 1
a2162 1
                             | _ => String.implode(rev acc)::parse(rest,nil))
d2166 1
a2166 1
                    parse (String.explode s,[])
d2173 1
a2173 1
                  Lists.iterate
d2301 1
a2301 1
                         (Lists.iterate Trace.trace args;  loop frames)
d2305 1
a2305 1
                        (Lists.iterate Trace.break
d2311 1
a2311 1
                    | "untrace" :: args => (Lists.iterate Trace.untrace args;
d2314 1
a2314 1
                         (Lists.iterate Trace.unbreak args;  loop frames)
d2345 1
a2345 1
                           Lists.iterate (fn s => MLWorks.IO.output(MLWorks.IO.std_out,s^"\n")) (Debugger_Types.print_information options (debug_info,true))
@


1.162.2.1
log
@branched from 1.162
@
text
@a3 5
 * Revision 1.162  1996/09/27  12:40:40  stephenb
 * As discussed in mlworks.mail.{8075,8081,8086}, display
 * a message when about to and just after scanning the stack
 * when entering the debugger.
 *
@


1.162.1.1
log
@branched from 1.162
@
text
@a3 5
 * Revision 1.162  1996/09/27  12:40:40  stephenb
 * As discussed in mlworks.mail.{8075,8081,8086}, display
 * a message when about to and just after scanning the stack
 * when entering the debugger.
 *
@


1.161
log
@[Bug #1521]
Propagating changes made to typechecker/_types.sml
@
text
@d4 4
d554 10
a563 11
require "../basis/__integer";

require "../utils/lists";
require "../utils/crash";
require "../basis/path";
require "../main/encapsulate";
require "../main/preferences";
require "../typechecker/types";
require "../interpreter/incremental";
require "../interpreter/shell_utils";
require "../rts/gen/tags";
d565 1
a565 2
(* require "get_type_information"; *)
require "../main/stack_interface";
d667 12
d2383 6
d2391 5
d2397 2
a2398 2
              (* The identifier debugger_call is never used; this is deliberate!
               See below.  *)
@


1.161.1.1
log
@branched from 1.161
@
text
@a3 4
 * Revision 1.161  1996/08/06  14:47:21  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml
 *
@


1.160
log
@[Bug #1503]
Ensure no arg acquired if there isn't one saved
@
text
@d4 4
d587 1
a587 1
  sharing DebuggerPrint.Options =
d592 1
a592 1

d598 1
a598 1
  sharing type DebuggerUtilities.Debugger_Types.printOptions = DebuggerPrint.Options.print_options
d902 1
a902 1
              val _ = debug (fn _ => "Annotation: " ^ Debugger_Types.print_backend_annotation current_annotation)
d1047 2
a1048 2
                          "Annotation: " ^ Debugger_Types.print_backend_annotation annotation,
                          "Arg : " ^ Types.debug_print_type ty]);
d1053 3
a1055 3
                               "Annotation: " ^ Debugger_Types.print_backend_annotation annotation,
                               "Arg : " ^ Types.debug_print_type ty,
                               "Res : " ^ Types.debug_print_type result])
d1073 1
a1073 1
                DebuggerUtilities.generate_recipe(new_poly_type, ty, "Debugger internal")
d1079 1
a1079 1
                        Types.debug_print_type ty ^
d1082 1
a1082 1
                        Types.debug_print_type new_poly_type ^
d1155 1
a1155 1
                                 Types.debug_print_type(apply_recipe (r,ty,name))
d1182 1
a1182 1
                                    (print_options, done_poly_types, seen_tyvars)
d1185 1
a1185 1
                                    (print_options, done_mono_types, seen_tyvars)
d1188 1
a1188 1
                                    (print_options, arg_type, seen_tyvars)
d1200 1
a1200 1
                                                Types.debug_print_type ty ^
d1202 1
a1202 1
                                                Types.debug_print_type arg_type)
d1223 1
a1223 1
                                          (print_options, done_poly_types, seen_tyvars)
d1226 1
a1226 1
                                            (print_options, done_mono_types, seen_tyvars)
d1229 1
a1229 1
                                            (print_options, arg_type, seen_tyvars)
d1244 1
a1244 1
                                            Types.debug_print_type arg_type,
d1246 1
a1246 1
                                            Types.debug_print_type reconstructed_type]);
d1276 1
a1276 1
    fun fix_runtime_env_types (arg_type, inferred_type, raise_excp) =
d1288 1
a1288 1
                      DebuggerUtilities.generate_recipe
d1301 3
a1303 3
                                Types.debug_print_type arg_type ^ " as\n" ^
                                Types.debug_print_type inferred_type ^ " with\n" ^
                                Types.debug_print_type ty ^ "\n");*)
d1675 1
a1675 1
          String.implode[name,"[",loc,"]", ":",Types.print_type print_options inferredType],
d1686 1
a1686 1
                  (fix_runtime_env_types
d1713 1
a1713 1
                      (fix_runtime_env_types
d2328 1
a2328 1
                           Lists.iterate (fn s => MLWorks.IO.output(MLWorks.IO.std_out,s^"\n")) (Debugger_Types.print_information (debug_info,true))
@


1.159
log
@Fix #1437 - NT: stack browser frame hiding doesn't work properly
@
text
@d4 3
d852 1
a852 1
      MLWorks.Internal.Value.T *
d877 1
a877 2
          val arg = StackInterface.frame_arg frame
          val info =
d879 1
a879 1
              val (Debugger_Types.FUNINFO {ty,is_leaf,annotations,runtime_env,...},
d900 6
a905 2
              FRAMEINFO (arg_type,current_annotation,runtime_env,
                         ref Datatypes.NULLTYPE)
d907 1
a907 1
          handle FailedToGetTypeInfo => NOFRAMEINFO
d1595 11
a1605 11
          (MLWorks.IO.output (MLWorks.IO.std_out, "MLFRAME");
           (if !hide then MLWorks.IO.output (MLWorks.IO.std_out, " (hidden)") else ());
           MLWorks.IO.output (MLWorks.IO.std_out, "\nname = X");
           MLWorks.IO.output (MLWorks.IO.std_out, name);
           MLWorks.IO.output (MLWorks.IO.std_out, "X\nfile_name= X");
           MLWorks.IO.output (MLWorks.IO.std_out, file_name);
           MLWorks.IO.output (MLWorks.IO.std_out, "X\nlocation= X");
           MLWorks.IO.output (MLWorks.IO.std_out, loc);
           MLWorks.IO.output (MLWorks.IO.std_out, "X\nnameStr= X");
           MLWorks.IO.output (MLWorks.IO.std_out, nameStr);
           MLWorks.IO.output (MLWorks.IO.std_out, "X\n"))
d1607 5
a1611 6
          (MLWorks.IO.output (MLWorks.IO.std_out, "CFRAME");
           (if !hide then MLWorks.IO.output (MLWorks.IO.std_out, " (hidden)") else ());
           MLWorks.IO.output (MLWorks.IO.std_out, "\nname = ");
           MLWorks.IO.output (MLWorks.IO.std_out, name);
           MLWorks.IO.output (MLWorks.IO.std_out, "\n"))

d1649 6
a1654 1
        | make_frame_details (_, MLFRAME (f,((name,(loc,_)),st),arg,NOFRAMEINFO),_) _ =
d1661 1
a1661 1
                                       arg,
@


1.158
log
@Fix #1423 - duplicate anonymous frames not hidden correctly.
@
text
@d4 3
a1525 1

d1588 19
a1606 17
    local
      fun display_frame (hide, (MLFRAME (frame, ((name, (loc,file_name)), _), _, _))) =
            (MLWorks.IO.output (MLWorks.IO.std_out, "MLFRAME");
             (if !hide then MLWorks.IO.output (MLWorks.IO.std_out, " (hidden)") else ());
             MLWorks.IO.output (MLWorks.IO.std_out, "\nname = X");
             MLWorks.IO.output (MLWorks.IO.std_out, name);
             MLWorks.IO.output (MLWorks.IO.std_out, "X\nfile_name= X");
             MLWorks.IO.output (MLWorks.IO.std_out, file_name);
             MLWorks.IO.output (MLWorks.IO.std_out, "X\nlocation= X");
             MLWorks.IO.output (MLWorks.IO.std_out, loc);
             MLWorks.IO.output (MLWorks.IO.std_out, "X\n"))
        | display_frame (hide, (CFRAME (frame, name))) =
            (MLWorks.IO.output (MLWorks.IO.std_out, "CFRAME");
             (if !hide then MLWorks.IO.output (MLWorks.IO.std_out, " (hidden)") else ());
             MLWorks.IO.output (MLWorks.IO.std_out, "\nname = ");
             MLWorks.IO.output (MLWorks.IO.std_out, name);
             MLWorks.IO.output (MLWorks.IO.std_out, "\n"))
d1608 11
a1618 12
    in
      fun show_frame_above_command ([], _, _) = MLWorks.IO.output (MLWorks.IO.std_out, "TOP\n")
        | show_frame_above_command (above as (a::as'), below, n) =
            if n = 0
            then display_frame a
            else show_frame_above_command (as', a::below, n-1)

      fun show_frame_below_command (_, [], _) = MLWorks.IO.output (MLWorks.IO.std_out, "BOTTOM\n")
        | show_frame_below_command (above, below as (b::bs), n) =
            if n = 0
            then display_frame b
            else show_frame_below_command (b::above, bs, n-1)
a1619 1
    end
d1815 20
d1836 10
d1848 5
a1852 23

        (* Generally this is the first frame in the frame list, but in
         * the case where the debugger has been entered via Debugger.break
         * this frame is the 5th frame (4th if counting from 0)
         *
         * Some of the NONE cases below should perhaps be Crash.impossible
         * instead (e.g. the empty stack and not finding an MLFRAME as
         * the 5th item).  
         *)
        fun locate_logical_top_frame (_, []) = NONE
          | locate_logical_top_frame (parameter, frames as (hd::tail)) =
              let 
                val frame = 
                  case parameter of
                    BREAK _ => (SOME (Lists.nth (4, frames))
                                handle Nth => NONE)
                  | _ => SOME hd
              in
                case frame of
                  NONE => NONE
                | SOME (MLFRAME (frame, _, _, _)) => SOME frame
                | SOME (CFRAME _) => NONE
              end
d2177 1
a2177 1
                val logical_top_frame = locate_logical_top_frame (parameter, frames)
d2293 1
a2293 1
                        (do_continue (fn () => next_command logical_top_frame);
d2377 1
a2377 1
                        val logical_top_frame = locate_logical_top_frame (parameter, frames)
d2387 1
a2387 1
                           top_ml_user_frame = logical_top_frame};
@


1.157
log
@with_start_frame: Fix so that it does not unconditionally turn off
stepping, rather it sets it to what it was before with_start_frame
was run.
@
text
@d4 5
d1474 10
d1567 4
a1570 4
                           if hide = hide_user_frame then
                             classify (fs, f'::(StackFrame.hide_duplicate_frames, f)::rest)
                           else
                              classify (fs, f'::fs')
@


1.156
log
@The Io exception is no longer at top level.
@
text
@d4 3
d2373 4
a2376 3
    (* The "Trace.set_stepping false" expression is there to ensure that
     * all stepping is turned off before returning to the top level.
     * In previous versions of the debugger, this expression was sprinkled
d2388 1
d2391 1
a2391 1
          handle exn => (start_frame_ref := old_frame; Trace.set_stepping false; raise exn)
d2394 1
a2394 1
        Trace.set_stepping false;
@


1.155
log
@Change to pull in Path directly rather than OS.Path since the latter
now conforms to the latest basis and it is too much effort to update
the code to OS.Path at this point.
@
text
@d4 5
d770 2
a771 1
                      handle Io arg => Debugger_Types.empty_information
@


1.154
log
@Moved Bits to MLWorks.Internal
@
text
@d4 3
d531 1
a531 1
require "../basis/os";
d550 1
a550 1
  structure OS : OS
d742 1
a742 1
                  val file = OS.Path.name (source_file) (* OS.Path.base *)
@


1.153
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d887 1
a887 1
          val closure_bits = Bits.lshift(MLWorks.Internal.Value.cast (StackInterface.frame_closure frame),2)
@


1.152
log
@Removing MLWorks.Integer
@
text
@d4 3
d593 1
a593 1
      fun debug_print s = output(MLWorks.IO.terminal_out,"  # " ^ s ^ "\n")
d651 1
a651 1
        fun aux1(":"::l,acc) = implode(rev acc)
d653 1
a653 1
          | aux1([],acc) = implode(rev acc)
d655 1
a655 1
        aux1(explode locdata,[])
d670 1
a670 1
            val (namechars,rest) = aux1(explode code_name,[])
d673 1
a673 1
            (implode(rev namechars),(implode(rev locchars),implode fnname))
d1206 1
a1206 1
                                   implode ["Combine types fails for: ",
d1264 1
a1264 1
                        ((*output(std_out, "Attempting partial tyvar substitution for\n" ^
d1306 1
a1306 1
      if i >= size s orelse String.ordof arg = ord" " then
d1312 1
a1312 1
      if i >= size s orelse String.ordof arg <> ord" " then
d1324 1
a1324 1
          if String.ordof arg = ord":" then
d1336 1
a1336 1
        val _ = output(std_out,
d1381 5
a1385 5
           output (std_out, "ignoring next ");
           output (std_out, Int.toString ignore_count);
           output (std_out, " hits on the breakpoint ");
           output (std_out, breakpoint_name);
           output (std_out, "\n"))
d1387 2
a1388 2
          (output (std_out, breakpoint_name);
           output (std_out, " is not a breakpoint\n"))
d1393 6
a1398 6
             (output (std_out, name);
              output (std_out, " ");
              output (std_out, Int.toString hits);
              output (std_out, " ");
              output (std_out, Int.toString max);
              output (std_out, "\n"))
d1402 1
a1402 1
             output (std_out, "No breakpoints set\n\n")
d1405 1
a1405 1
              output (std_out, "\n"))
d1434 3
a1436 3
          NONE => (output (std_out, "No such frame type as ");
                   output (std_out, frame_type);
                   output (std_out, "\n"))
d1444 1
a1444 1
            then (output (std_out, name); output (std_out, " "))
d1448 1
a1448 1
          output (std_out, "\n")
d1525 1
a1525 1
                   if file_name = "" andalso size loc > 0 andalso ord loc <> ord " " then
d1555 9
a1563 9
            (output (std_out, "MLFRAME");
             (if !hide then output (std_out, " (hidden)") else ());
             output (std_out, "\nname = X");
             output (std_out, name);
             output (std_out, "X\nfile_name= X");
             output (std_out, file_name);
             output (std_out, "X\nlocation= X");
             output (std_out, loc);
             output (std_out, "X\n"))
d1565 5
a1569 5
            (output (std_out, "CFRAME");
             (if !hide then output (std_out, " (hidden)") else ());
             output (std_out, "\nname = ");
             output (std_out, name);
             output (std_out, "\n"))
d1572 1
a1572 1
      fun show_frame_above_command ([], _, _) = output (std_out, "TOP\n")
d1578 1
a1578 1
      fun show_frame_below_command (_, [], _) = output (std_out, "BOTTOM\n")
d1592 3
a1594 3
      fun out m = (output (std_out, "Parameter = ");
                   output (std_out, m);
                   output (std_out, "\n"))
d1610 2
a1611 2
          (implode[name,"<??>"],
           implode["[",loc,"]"],
d1619 1
a1619 1
          (implode[name," ",
d1626 1
a1626 1
          implode[name,"[",loc,"]", ":",Types.print_type print_options inferredType],
d1742 1
a1742 1
                implode ["Exception ", exn_name, " raised"]
d1774 1
a1774 1
          string_to_int (rev(explode str)) (0,0)
d1844 1
a1844 1
            (output (std_out, "No calling frame\n");  frames)
d1860 1
a1860 1
            (output (std_out, "No called frame\n");  frames)
d1929 2
a1930 2
          output (std_out, #1 frame_details);
          output (std_out, "\n")
d1945 1
a1945 1
          output (std_out, "(Current frame)\n");
d1955 1
a1955 1
            output (std_out, "No ML function to step over\n")
d1993 1
a1993 1
                  output (std_out, str)
d1999 1
a1999 1
            output (std_out, "Cannot edit source for C frame\n")
d2003 1
a2003 1
              output (std_out, "Edit failed: " ^ s ^ "\n")
d2028 1
a2028 1
            fun outfun s = output(std_out,s)
d2035 1
a2035 1
            fun prompt s = (outfun s; MLWorks.IO.flush_out std_out)
d2078 1
a2078 1
                       | _ =>  [implode (rev acc)])
d2084 1
a2084 1
                             | _ => implode(rev acc)::parse(rest,nil))
d2088 1
a2088 1
                    parse (explode s,[])
d2140 1
a2140 1
                        [] => output (std_out, "No visible frame\n")
d2153 1
a2153 1
                          if end_of_stream std_in then
d2157 1
a2157 1
                        val line = MLWorks.IO.input_line std_in
d2189 1
a2189 1
                         output (std_out, "(Outermost frame)\n");
d2267 1
a2267 1
                           Lists.iterate (fn s => output(std_out,s^"\n")) (Debugger_Types.print_information (debug_info,true))
@


1.151
log
@Made debug_print local to the debug functions, and removed a call to it
that should have used one of the other debug functions.
@
text
@d4 4
d515 2
d854 1
a854 1
              val _ = debug (fn _ => "Getting info for " ^ name ^ ", offset: " ^ MLWorks.Integer.makestring (4 * offset))
d862 1
a862 1
                         MLWorks.Integer.makestring (4 * offset) ^ " for " ^ name)
d893 1
a893 1
            else "unknown closure "^(MLWorks.Integer.makestring n)
d904 1
a904 1
                                       (MLWorks.Integer.makestring i)))
d1335 1
a1335 1
                       MLWorks.Integer.makestring start ^
d1337 1
a1337 1
                       MLWorks.Integer.makestring finish ^ "\n")
d1379 1
a1379 1
           output (std_out, MLWorks.Integer.makestring ignore_count);
d1392 1
a1392 1
              output (std_out, MLWorks.Integer.makestring hits);
d1394 1
a1394 1
              output (std_out, MLWorks.Integer.makestring max);
d1743 1
a1743 1
              "Fatal Unix signal " ^ MLWorks.Integer.makestring s
@


1.150
log
@initbasis moves to basis
@
text
@d4 3
d583 4
a586 2
    val do_debug = (*true*)false
    fun debug_print s = output(MLWorks.IO.terminal_out,"  # " ^ s ^ "\n")
d588 9
a596 8
    (* For multiple line output *)
    fun debugl f =
      if do_debug then
        Lists.iterate debug_print (f ())
      else ()

    fun debug f = if do_debug then debug_print (f ()) else ()
    fun ddebug f = debug_print (f ())
d1145 5
a1149 4
                                  debug_print("Attempting partial tyvar substitution in stack backtrace for\n" ^
                                              str1 ^ " as\n" ^
                                              str2 ^ " with\n" ^
                                              str3);
@


1.149
log
@Rename Os -> OS to conform with latest basis revision.
@
text
@d4 3
d510 1
a510 1
require "../initbasis/os";
@


1.148
log
@output_frame_details: restore to its original behaviour of outputting
a newline after the frame details.
@
text
@d4 4
d526 1
a526 1
  structure Os : OS
d715 1
a715 1
                  val file = Os.Path.name (source_file)
@


1.147
log
@Lift out some of the functions in ml_debugger so that it is
easier to follow what is going on.
@
text
@d4 4
d1906 2
a1907 1
          output (std_out, #1 frame_details)
@


1.146
log
@Replace Path/PATH by Os.Path/OS_PATH
@
text
@d4 3
d586 3
d600 1
d1580 173
d1756 1
d1898 25
d1969 10
a1999 142
            fun make_frame_details (CFRAME (f,s),_) _ =
              ("<Cframe> "^s,"",
               (Datatypes.NULLTYPE,cast 0,""), MLWorks.Option.NONE)
              | make_frame_details (MLFRAME (f,((name,(loc,_)),st),arg,NOFRAMEINFO),_) _ =
                (implode[name,"<??>"],
                 implode["[",loc,"]"],
                 (Datatypes.NULLTYPE,cast 0,""),
                 MLWorks.Option.NONE)
              | make_frame_details (MLFRAME (f,
                                             ((name,(loc,_)),st),
                                             arg,
                                             FRAMEINFO(arg_type,annotation,runtime_env,
                                                       ref inferredType)),frames) windowing =
                (implode[name," ",
                         if windowing then ""
                         else
                           ValuePrinter.stringify_value false (print_options,
                                                               arg,
                                                               inferredType,
                                                               get_interpreter_information())],
                implode[name,"[",loc,"]", ":",Types.print_type print_options inferredType],
                if windowing then
                  (inferredType, arg,
                   ValuePrinter.stringify_value false (print_options,
                                                       arg,
                                                       inferredType,
                                                       get_interpreter_information()))
                else (Datatypes.NULLTYPE, cast 0,""),
                  if windowing then
                    let
                      val new_runtime_env =
                        (fix_runtime_env_types
                         (arg_type, inferredType, true)
                         runtime_env)
                        handle DebuggerUtilities.ApplyRecipe _ =>
                          (* Try using the entire set of frames to do the same job *)
                          let
                            fun collect_types(poly_list, mono_list, []) =
                              (poly_list, mono_list)
                              | collect_types(poly_list, mono_list, CFRAME _ :: frames) =
                                collect_types(poly_list, mono_list, frames)
                              | collect_types(poly_list, mono_list,
                                              MLFRAME(_, _, _, NOFRAMEINFO) :: frames) =
                                collect_types(poly_list, mono_list, frames)
                              | collect_types(poly_list, mono_list,
                                              MLFRAME(_, _, _,
                                                      FRAMEINFO(arg_type, _, _,
                                                                ref inferredType)) ::
                                              frames) =
                                collect_types(arg_type :: poly_list,
                                              inferredType :: mono_list,
                                              frames)
                            val (poly_type_list, mono_type_list) =
                              collect_types([arg_type], [inferredType], frames)
                            val new_poly_type =
                              type_list_to_rectype poly_type_list
                            val new_mono_type = type_list_to_rectype mono_type_list
                          in
                            (fix_runtime_env_types
                             (new_poly_type, new_mono_type, false)
                             runtime_env)
                            (* This shouldn't raise, but just in case it does ... *)
                            handle DebuggerUtilities.ApplyRecipe _ =>
                              runtime_env
                          end
                    in
                      (* This should use the full stack if necessary *)
                      (* And now it does *)
                      MLWorks.Option.SOME (ref (MLWorks.Option.INL
                                                (fn () =>
                                                 DebuggerPrint.print_env
                                                 ((f, new_runtime_env, inferredType),
                                                  fn (ty1,value) =>
                                                  ValuePrinter.stringify_value true (print_options,
                                                                                     value,
                                                                                     ty1,get_interpreter_information()),
                                                  options,true,
                                                  map (fn MLFRAME(frame,_,_,FRAMEINFO(_,_,env,ref ty))=>(frame,env,ty)
                                                | MLFRAME (frame,_,_,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)
                                                | CFRAME(frame,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE))
                                                  frames))))
                    end
                  else MLWorks.Option.NONE)

            fun make_frame_strings frames =
              let
                fun aux (frame::frames,acc) =
                  let
                    val details = make_frame_details (frame,frames) true
                    val stuff =
                      case frame of
                        CFRAME (_,loc) => {name = "<Cframe>", loc = loc,details = details}
                      | MLFRAME (_,((name,(loc,_)),_),_,_) => {name = name,loc = loc, details = details}
                  in
                    aux (frames,stuff::acc)
                  end
                  | aux (nil,acc) = rev acc
              in
                aux (frames,[])
              end

            fun parameter_details () =
              case parameter of
                EXCEPTION exn =>
                  let
                    val Options.PRINTOPTIONS{maximum_seq_size,
                                             maximum_string_size,
                                             maximum_ref_depth,
                                             maximum_str_depth,
                                             maximum_depth,
                                             float_precision,
                                             print_fn_details,
                                             print_exn_details,
                                             show_id_class,
                                             show_eq_info
                                             } = print_options
                    val print_options =
                      Options.PRINTOPTIONS{maximum_seq_size = maximum_seq_size,
                                           maximum_string_size = maximum_string_size,
                                           maximum_ref_depth = maximum_ref_depth,
                                           maximum_str_depth = maximum_str_depth,
                                           maximum_depth = maximum_depth,
                                           float_precision = float_precision,
                                           print_fn_details = print_fn_details,
                                           print_exn_details = true,
                                           show_id_class = show_id_class,
                                           show_eq_info = show_eq_info
                                           }
                  in
                    implode ["Exception ",
                             ValuePrinter.stringify_value false (print_options,
                                                                 cast exn,
                                                                 Datatypes.CONSTYPE([],Types.exn_tyname),
                                                                 get_interpreter_information()),
                             " raised"]
                  end
              | INTERRUPT => "Interrupt"
              | FATAL_SIGNAL s =>
                  "Fatal Unix signal " ^ MLWorks.Integer.makestring s
              | BREAK s => s
              | STACK_OVERFLOW => "Break on stack overflow"

d2003 2
a2004 2
            fun output_frame_details frame =
              outline (#1 (make_frame_details (frame,nil) false))
d2006 1
a2006 1
              outline (#2 (make_frame_details (frame,nil) false))
d2009 2
a2010 1
            (* This is a "private" exception used to exit from the debugger inner loop *)
a2013 12
            fun backtrace_command frames =
              let
                fun display (hide, frame) =
                  if !hide
                  then ()
                  else output_frame_details frame
              in
                output (std_out, "(Current frame)\n");
                Lists.iterate display frames
              end


d2034 3
a2062 6
                fun edit_frame (CFRAME _) =
                      outline "Cannot edit source for C frame"
                  | edit_frame (MLFRAME (_,((_,(loc,_)),_),_,_)) =
                    (ShellUtils.edit_source (loc, preferences); ())
                    handle ShellUtils.EditFailed s => outline ("Edit failed: " ^ s)

a2100 24
                fun string_to_int str =
                  let
                    exception Finished of int
                    fun factor 0 = 1
                      | factor n = 10*factor (n-1)
                    fun string_to_int nil (n,_) = n
                      | string_to_int (m::ms) (n,power) =
                        string_to_int ms
                        ((case m of
                            "1" => 1*(factor power)+n
                          | "2" => 2*(factor power)+n
                          | "3" => 3*(factor power)+n
                          | "4" => 4*(factor power)+n
                          | "5" => 5*(factor power)+n
                          | "6" => 6*(factor power)+n
                          | "7" => 7*(factor power)+n
                          | "8" => 8*(factor power)+n
                          | "9" => 9*(factor power)+n
                          | "0" => n
                          | _ => raise Finished(n)),power+1)
                  in
                    string_to_int (rev(explode str)) (0,0)
                    handle Finished(n) => n
                  end
a2101 1
                  
d2106 1
d2116 3
a2118 4
                    val _ = if Trace.stepping () then
                              ()
                            else
                              apply_to_current_frame output_frame_details
d2160 1
a2160 1
                        (backtrace_command below;
d2164 6
a2169 2
                        (backtrace_command (firstn (below, string_to_int arg));
                         loop frames)
d2265 1
a2265 1
                (outline (parameter_details ());
d2269 1
a2269 1
                  outline (parameter_details () ^ " at top level")
d2271 1
a2271 1
                  (outline (parameter_details ());
d2293 1
a2293 1
                      (send_message (parameter_details () ^ "\n");
d2296 1
a2296 1
                      send_message (parameter_details () ^ " at top level\n")
d2300 1
a2300 1
                        (* val _ = outline (parameter_details ()) *)
d2303 1
a2303 1
                        val frame_strings = make_frame_strings frames
d2306 1
a2306 1
                          {parameter_details = parameter_details (),
@


1.145
log
@Fix so that if the user keeps stepping right through until the MLWorks
prompt is reached (i.e. the user does not explicitly continue or quit),
stepping is not left on.
@
text
@d4 5
d496 1
a496 1
require "../initbasis/path";
d515 1
a515 1
  structure Path : PATH
d700 1
a700 1
                  val file = Path.name (source_file)
@


1.144
log
@Fix the frame filtering mechanism so that it doesn't drop
the top frame if it is a delivered frame.
@
text
@d4 4
d1953 3
a1955 3
               | POSSIBLE(_,NORMAL_RETURN) => (action (); raise Exit)
               | POSSIBLE(_,DO_RAISE exn) => raise exn
               | POSSIBLE (_,FUN f) => f ())
d1958 1
a1958 1
            fun do_quit() =
d1961 3
a1963 3
               | POSSIBLE(_,NORMAL_RETURN) => raise Exit
               | POSSIBLE(_,DO_RAISE exn) => raise exn
               | POSSIBLE(_,FUN f) => (f()))
d2127 1
a2127 1
                        (do_continue (fn () => Trace.set_stepping false);
d2165 3
a2167 2
                    | ["s"] => (do_continue (fn () => Trace.set_stepping true);
                                loop frames)
d2281 11
d2299 1
a2299 1
          handle exn => (start_frame_ref := old_frame; raise exn)
d2302 1
d2305 2
@


1.143
log
@Modify the tty->gui interface so that the gui debugger knows
which frame to apply Trace.next to.
Modified the tty frame movement commands so that they deal gracefully
with the case where there are no visible ML frames (I didn't
consider this case when I originally wrote the code since it cannot
occur if the debugger is entered due to a breakpoint).
Removed an unused function from inside _ml_debugger.
@
text
@d4 9
d1489 1
a1489 1
                         [] => classify (fs, [])
d1711 4
a1714 2
      fun next_command MLWorks.Option.NONE = ()
        | next_command (MLWorks.Option.SOME frame) = Trace.next frame
d2198 1
a2198 1
                  ()
@


1.142
log
@Re-implement the frame hiding stuff so that hiding/revealing a frame
does not lose the user's position in the backtrace.
@
text
@d4 4
d737 2
a738 1
         continue_fn: (unit -> unit) MLWorks.Option.option}
d1455 4
d1463 1
a1463 5
              let
                val f' = (StackFrame.hide_c_frames, f)
              in
                classify (fs, f'::fs')
              end
d1521 1
a1521 2
        | show_frame_above_command (_, [], _) = output (std_out, "BOTTOM\n")
        | show_frame_above_command (above as (a::as'), below as (b::bs), n) =
d1523 1
a1523 1
            then display_frame b
d1555 26
a1580 12
      (* Generally this is the first frame in the frame list, but in
       * the case where the debugger has been entered via Debugger.break
       * this frame is the 5th frame (4th if counting from 0)
       *)
      fun locate_logical_top_frame (_, []) =
             Crash.impossible "locate_logical_top_frame"
        | locate_logical_top_frame (parameter, frames as (hd::tail)) =
            case parameter of
              BREAK _ =>
                (Lists.nth (4, frames)
                 handle Nth => Crash.impossible "locate_logical_top_frame")
            | _ => hd
d1598 10
a1607 7
              if !hide then
                prev ((rest, frame::below), orig, n, k)
              else
                if n = 0
                then frames
                else prev ((rest, frame::below), frames, n-1, k)

d1648 2
a1649 2
         * Since hiding user frames is not (currently) allowed, it should
         * always be possible to find at least one visible (user) frame.
d1652 1
a1652 2
          fun hit_top frames = 
            Crash.impossible "hit_top:move_to_first_visible_frame"
a1659 1
      end
d1662 1
a1663 1
      fun goto_top_command frames = move_to_first_visible_frame frames
d1666 27
a1693 8
      local
        fun next ((_, []), orig) = orig
          | next (frames as (above, (frame as (hide, _))::rest), orig) = 
             if !hide
             then next ((frame::above, rest), orig)
             else next ((frame::above, rest), frames)
      in
        fun goto_bottom_command frames = next (frames, frames)
d1698 6
a1703 4
      fun next_command frame =
        case frame of
          MLFRAME (frame, _, _, _) => Trace.next frame
        | CFRAME _ => Crash.impossible "next_command"
d1707 6
a1712 4
      fun frame_details_command ([], _) = 
            Crash.impossible "frame_details_command"
        | frame_details_command ((_, CFRAME _)::_, _) = ()
        | frame_details_command (frames as ((_, MLFRAME (frame, _, _, frameinfo))::_), options) =
a1917 10
      fun backtrace_command frames =
        let
          fun display (hide, frame) =
            if !hide
            then ()
            else output_frame_details frame
        in
          output (std_out, "(Current frame)\n");
          Lists.iterate display frames
        end
d1919 10
d2050 2
a2051 1
                fun loop (frames as (above, below as ((_, this)::rest))) =
d2053 7
d2063 1
a2063 1
                             output_frame_details this
d2078 1
a2078 14
                    fun frame_fnname () =
                      let
                        val (name,loc,fnname) =
                          case this of
                            CFRAME (_,name) => (name,"","")
                          | MLFRAME (_,((name,(loc,fnname)),_),_,_) => (name,loc,fnname)
                        fun to_rbrace nil = Crash.impossible "rbrace:frame_fnname:loop:ml_debugger"
                          | to_rbrace ("}"::rest) = rest
                          | to_rbrace (_::rest) = to_rbrace rest
                      in
                        case explode fnname of
                          "{"::namechars => (implode o rev o to_rbrace o rev) namechars
                        | _ => name ^ "[" ^ loc ^ "]"
                      end
d2082 1
a2082 1
                    | ">"::_ => loop (goto_bottom_command classified_frames)
d2084 2
a2085 1
                        (output_full_frame_details this;  loop frames)
d2087 1
a2087 1
                        (edit_frame this;  loop frames)
a2184 1
                  | loop _ = output (std_out,"No frames to look at in debugger!\n")
d2242 1
d2251 2
a2252 1
                             make_continuation_function continue_continuation};
@


1.141
log
@Simplified the mapping between frame type names and the frame hiding flags.
Added some more comments.
@
text
@d4 4
d1356 4
a1369 8
      fun hide_frame (CFRAME _) = !StackFrame.hide_c_frames
        | hide_frame (MLFRAME (_, ((name, (_, file_name)), _), _, _)) =
            case name of
              "<Setup>"  => !StackFrame.hide_setup_frames
            | "<anon>"   => !StackFrame.hide_anonymous_frames
            | "<handle>" => !StackFrame.hide_handler_frames
            | _          => file_name <> "" andalso !StackFrame.hide_delivered_frames
 
d1385 4
a1388 1
          fun out (name, _) = (output (std_out, name); output (std_out, " "))
d1394 2
d1398 2
d1403 4
d1410 8
d1421 8
d1431 2
d1434 51
a1484 1
      val filter_frames = Lists.filterp (not o hide_frame)
d1497 4
a1500 3
      fun display_frame (MLFRAME (frame, ((name, (loc,file_name)), _), _, _)) =
            (output (std_out, "MLFRAME\n");
             output (std_out, "name = X");
d1507 4
a1510 3
        | display_frame (CFRAME (frame, name)) =
            (output (std_out, "CFRAME\n");
             output (std_out, "name = ");
a1527 24
      val show_top_frame_command = display_frame

    end



    (*
     * This is just here for debugging/development purposes.
     *)
    local
      fun out (s, m) = 
        (output (std_out, "Continuation = ");
         output (std_out, s);
         output (std_out, " ");
         output (std_out, m);
         output (std_out, "\n"))
    in
      fun show_continuation_command NOT_POSSIBLE = out ("", "not possible")
        | show_continuation_command (POSSIBLE (str, NORMAL_RETURN)) =
            out (str, "normal")
        | show_continuation_command (POSSIBLE (str, DO_RAISE _)) =
            out (str, "exeption")
        | show_continuation_command (POSSIBLE (str, FUN _)) = 
            out (str, "function")
d1566 1
a1566 1
      fun goto_top_command (above, below) = ([], (rev above) @@ below)
d1568 18
d1587 58
a1644 4
      fun goto_bottom_command (_, []) = Crash.impossible "goto_bottom_command"
        | goto_bottom_command (frames as (_, [_])) = frames
        | goto_bottom_command (above, frame::frames) = 
            goto_bottom_command (frame::above, frames)
a1646 14
      (* Move to nth next frame.
       * n = 0 means don't move.
       * If n > number of calling frames, then move to the latest frame.
       *)
      fun next_frame_command (_, [], _) =
            Crash.impossible "next_frame_command"
        | next_frame_command (above, below as [_], n) = 
            ((if n <> 0
              then output (std_out, "No calling frame\n")
              else ());
             (above, below))
        | next_frame_command (above, below, 0) = (above, below)
        | next_frame_command (above, frame::frames, n) =
            next_frame_command (frame::above, frames, n-1)
d1648 9
a1657 12
      (* Moves to the nth previous frame.  
       * n = 0 means don't move.
       * if n > number of called frames, then move to the earliest frame.
       *)
      fun previous_frame_command ([], below, n) = 
            ((if n <> 0
              then output (std_out, "No called frame\n")
              else ());
             ([], below))
        | previous_frame_command (above, below, 0) = (above, below)
        | previous_frame_command (frame::frames, below, n) =
            previous_frame_command (frames, frame::below, n-1)
d1669 2
a1670 2
        | frame_details_command ((CFRAME _)::_, _) = ()
        | frame_details_command (frames as (MLFRAME (frame, _, _, frameinfo)::_), options) =
d1675 1
a1675 1
                  fun munge_frame (MLFRAME (frame,_,_,FRAMEINFO(_,_,env,ref ty))) =
d1677 1
a1677 1
                    | munge_frame (MLFRAME (frame,_,_,_)) = 
d1679 1
a1679 1
                    | munge_frame (CFRAME (frame,_)) =
d1876 12
d1936 1
a1936 1
                  outline "Cannot edit source for C frame"
d2006 3
a2008 2
                   
                fun loop (above, below as (this::rest)) =
d2044 2
a2045 2
                      "<"::_ => loop (goto_top_command (above, below))
                    | ">"::_ => loop (goto_bottom_command (above, below))
d2047 1
a2047 2
                        (output_full_frame_details this;
                         loop (above,below))
d2049 1
a2049 2
                        (edit_frame this;
                         loop (above,below))
d2051 1
a2051 1
                        loop (previous_frame_command (above, below, 1))
d2056 1
a2056 1
                          loop (previous_frame_command (above, below, n))
d2059 1
a2059 1
                        loop (next_frame_command (above,below, 1))
d2064 1
a2064 1
                          loop (next_frame_command (above, below, n))
d2067 1
a2067 2
                        (output (std_out, "(Current frame)\n");
                         Lists.iterate output_frame_details below;
d2069 1
a2069 1
                         loop (above,below))
d2071 2
a2072 8
                        let
                          val n = string_to_int arg
                          val frames' = firstn (below, n)
                        in
                          output (std_out, "(Current frame)\n");
                          Lists.iterate output_frame_details frames';
                          loop (above, below)
                        end
d2075 1
a2075 1
                         loop (above,below))
d2078 1
a2078 1
                         loop (above, below))
d2081 1
a2081 1
                         loop ([], filter_frames frames))
d2085 1
a2085 1
                         loop (above,below))
d2088 1
a2088 1
                        loop (above, below))
d2091 2
a2092 2
                         loop ([], filter_frames frames))
                    | ""::_ => loop (above,below)
d2094 1
a2094 2
                        (display_help_info();
                         loop (above,below))
d2096 3
a2098 4
                        (display_help_info();
                         loop (above,below))
                    | "trace" :: args => (Lists.iterate Trace.trace args;
                                          loop (above,below))
d2100 5
a2104 5
                        (breakpoints_command ();
                         loop (above, below))
                    | "breakpoint" :: args => (Lists.iterate Trace.break
                                               (map (fn name => {name=name, hits=0, max=1}) args);
                                               loop (above,below))
d2107 1
a2107 1
                         loop (above, below))
d2109 3
a2111 3
                                            loop (above,below))
                    | "unbreakpoint" :: args => (Lists.iterate Trace.unbreak args;
                                                 loop (above,below))
d2113 1
a2113 1
                                loop (above,below))
d2118 1
a2118 1
                        loop (above,below))
d2121 1
a2121 1
                         loop (above, below))
d2124 1
a2124 1
                         loop (above,below))
d2127 1
a2127 4
                         loop (above,below))
                    | ["show_top_frame"] => 
                        (show_top_frame_command logical_top_frame;
                         loop (above,below))
d2130 1
a2130 4
                         loop (above, below))
                    | ["show_continuation"] =>
                        (show_continuation_command continue_continuation;
                         loop (above, below))
d2133 1
a2133 1
                         loop (above,below))
d2136 1
a2136 1
                         loop (above, below))
d2143 1
a2143 1
                           loop (above,below))
d2145 1
a2145 1
                            loop (above,below))
d2153 1
a2153 1
                loop ([], filter_frames frames)
@


1.140
log
@Unify control of hiding and revealing frames in the tty&gui debuggers.
@
text
@d4 3
d504 2
a505 2
	  ShellUtils.Options = Types.Options = ValuePrinter.Options =
	  Incremental.InterMake.Inter_EnvTypes.Options
d546 1
a546 1
	Lists.iterate debug_print (f ())
d554 2
a555 2
	if a = a' then MLWorks.Option.SOME b
	else assoc (a,rest)
d560 7
a566 7
	let
	  fun aux (_,0,acc) = rev acc
	    | aux ([],n,_) = l
	    | aux (a::b,n,acc) = aux (b,n-1,a::acc)
	in
	  aux (l,n,[])
	end
d577 8
a584 8
	fun tl [] = []
	  | tl (a::b) = b
	fun substring ([],_,_) = true
	  | substring (_,[],_) = false
	  | substring (x::xs,y::ys,yys) =
	    if x = y
	      then substring (xs,ys,yys)
	    else substring(str1,yys,tl yys)
d586 1
a586 1
	substring (str1,str2,tl str2)
d592 3
a594 3
	fun aux1(":"::l,acc) = implode(rev acc)
	  | aux1(c::l,acc) = aux1(l,c::acc)
	  | aux1([],acc) = implode(rev acc)
d596 1
a596 1
	aux1(explode locdata,[])
d601 16
a616 16
	fun get_name_and_location code_name =
	  let
	    fun duff () = debug (fn _ => "Odd codename:"^code_name^":")
	    fun aux1("["::l,acc) = (acc,l)
	      | aux1(c::l,acc) = aux1(l,c::acc)
	      | aux1([],acc) = (duff();(acc,[]))
	    fun aux2(["]"],acc) = (acc,nil)
	      | aux2("]"::l,acc) = (duff();(acc,l))
	      | aux2(c::l,acc) = aux2(l,c::acc)
	      | aux2([],acc) = (duff();(acc,nil))
	    val (namechars,rest) = aux1(explode code_name,[])
	    val (locchars,fnname) = aux2 (rest,[])
	  in
	    (implode(rev namechars),(implode(rev locchars),implode fnname))
	  end
	val name_string = StackInterface.frame_name frame
d618 1
a618 1
	(get_name_and_location name_string,name_string)
d639 15
a653 15
	fun cache_lookup(x,[]) =
	  (debug (fn _ => file ^ " not found in cache") ;
	   raise CacheFail)
	  | cache_lookup(x,(elem as (h,t))::rest) =
	    if x=h
	      then (debug (fn _ => file ^ " found in cache");
		    (t,rest))
	    else
	      let
		val (a,b) = cache_lookup(x,rest)
	      in
		(a,elem::b)
	      end
	val (result,rest) = cache_lookup(file,!data_cache)
	val _ = data_cache := (file,result) :: rest
d655 1
a655 1
	result
d665 1
a665 1
	val source_file = location_source_file loc
d667 3
a669 3
	case Debugger_Types.lookup_debug_info (debug_info,name_string) of
	  MLWorks.Option.SOME funinfo =>
	    (funinfo,source_file)
d682 3
a684 3
			    val (_,information) =
			      Encapsulate.decode_type_basis
			      (#type_env (Encapsulate.input_all (file ^ ".mo")),file,empty_map,true)
d688 9
a696 9
			handle Encapsulate.BadInput msg =>
			  (debug (fn _ =>
				  "Decapsulation failed for function " ^
				  function_name ^ ": " ^ file ^ ":" ^ msg);
			   let
			     val information = Debugger_Types.empty_information
			   in
			     (add_to_cache (file,information); information)
			   end)))
d711 3
a713 3
	(string
	 * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value * string)
	 ) list
d716 6
a721 6
	string
	* string
	* (ValuePrinter.Type * MLWorks.Internal.Value.ml_value * string)
	* (unit -> string * part_of_a_frame,
	   string * part_of_a_frame)
	MLWorks.Option.union ref MLWorks.Option.option
d726 5
a730 5
	{parameter_details: string,
	 frames: frame list,
	 quit_fn: (unit -> unit) MLWorks.Option.option,
	 continue_fn: (unit -> unit) MLWorks.Option.option}
	-> unit
d770 1
a770 1
	MLWorks.Option.SOME (fn _ => raise exn)
d772 1
a772 1
	MLWorks.Option.SOME f
d774 1
a774 1
	MLWorks.Option.NONE
d786 33
a818 33
	let
	  val debug_info as ((name,(loc,_)),name_str) = get_data_from_frame frame
	  val arg = StackInterface.frame_arg frame
	  val info =
	    let
	      val (Debugger_Types.FUNINFO {ty,is_leaf,annotations,runtime_env,...},
		   source_file) =
		get_type_information (options,
				      get_interpreter_information(),
				      ((name,loc),name_str))
	      val arg_type = get_arg_type ty
	      val _ = debug (fn _ => "Getting info for " ^ name ^ ", offset: " ^ MLWorks.Integer.makestring (4 * offset))
	      val current_annotation =
		case assoc (4 * offset,annotations) of
		  MLWorks.Option.SOME a => a
		| _ =>
		    let
		      val string =
			("No annotation for offset " ^
			 MLWorks.Integer.makestring (4 * offset) ^ " for " ^ name)
		    in
		      Debugger_Types.ERROR string;
		      Debugger_Types.NOP
		    end
	      val _ = debug (fn _ => "Annotation: " ^ Debugger_Types.print_backend_annotation current_annotation)
	    in
	      FRAMEINFO (arg_type,current_annotation,runtime_env,
			 ref Datatypes.NULLTYPE)
	    end
	  handle FailedToGetTypeInfo => NOFRAMEINFO
	in
	  MLFRAME(frame,debug_info,arg,info)
	end
d820 20
a839 20
	let
	  val closure_bits = Bits.lshift(MLWorks.Internal.Value.cast (StackInterface.frame_closure frame),2)
	  fun clos_type n =
	    if n = Tags.STACK_START then "start"
	    else if n = Tags.STACK_START_INTERCEPT then "start intercept"
	    else if n = Tags.STACK_END then "end"
	    else if n = Tags.STACK_EXTENSION then "extension"
	    else if n = Tags.STACK_LEAF_RAISE then "leaf raise"
	    else if n = Tags.STACK_RAISE then "raise"
	    else if n = Tags.STACK_RESUME then "resume"
	    else if n = Tags.STACK_PROFILE then "profile"
	    else if n = Tags.STACK_EVENT then "event"
	    else if n = Tags.STACK_C_RAISE then "c raise"
	    else if n = Tags.STACK_C_CALL then "c call"
	    else if n = Tags.STACK_INTERCEPT then "intercept"
	    else if n = Tags.STACK_SPACE_PROFILE then "space profile"
	    else "unknown closure "^(MLWorks.Integer.makestring n)
	in
	  CFRAME(frame, clos_type (closure_bits))
	end
d843 5
a847 5
	val (numbered_list, _) =
	  Lists.number_from_by_one
	  (ty_list, 1,
	   fn i => Datatypes.Ident.LAB(Datatypes.Ident.Symbol.find_symbol
				       (MLWorks.Integer.makestring i)))
d849 4
a852 4
	Datatypes.RECTYPE
	(Lists.reducel
	 (fn (map, (ty, lab)) => NewMap.define'(map, (lab, ty)))
	 (NewMap.empty' Datatypes.Ident.lab_lt, numbered_list))
d857 2
a858 2
	val poly_type = DebuggerUtilities.slim_down_a_type poly_type
	val mono_type = DebuggerUtilities.slim_down_a_type mono_type
d860 1
a860 1
	make_map(poly_type, mono_type, partial_map)
d864 1
a864 1
		 mono_type, partial_map) =
d866 1
a866 1
	 Datatypes.NULLTYPE => (r, mono_type) :: partial_map
d869 1
a869 1
	make_map(ty, mono_type, partial_map)
d871 1
a871 1
	partial_map (* Can't do anything with this I think *)
d873 1
a873 1
	make_map(ty, mono_type, partial_map)
d875 8
a882 8
	(case mono_type of
	   Datatypes.RECTYPE mapping' =>
	     Lists.reducel
	     (fn (map, ((_, ty1), (_, ty2))) =>
	      make_map(ty1, ty2, map))
	     (partial_map, Lists.zip(NewMap.to_list_ordered mapping,
				     NewMap.to_list_ordered mapping'))
	 | _ => partial_map (* Can't deal with this any more *))
d884 4
a887 4
	(case mono_type of
	   Datatypes.FUNTYPE(ty'', ty''') =>
	     make_map(ty', ty'', make_map(ty, ty'', partial_map))
	 | _ => partial_map (* Can't deal with this any more *))
d889 7
a895 7
	(case mono_type of
	   Datatypes.CONSTYPE(ty_list', tyname') =>
	     Lists.reducel
	     (fn (map, (ty1, ty2)) =>
	      make_map(ty1, ty2, map))
	     (partial_map, Lists.zip(ty_list, ty_list'))
	 | _ => partial_map (* Can't deal with this any more *))
d897 1
a897 1
	partial_map (* Can't do anything with this I think *)
d899 1
a899 1
	partial_map (* Can't do anything with this I think *)
d903 16
a918 16
	fun apply_map(ty as Datatypes.METATYVAR(r as ref (_, ty', _), _, _)) =
	  (case ty' of
	     Datatypes.NULLTYPE =>
	       (Lists.assoc(r, partial_map) handle Lists.Assoc => ty)
	     | _ => apply_map ty')
	  | apply_map(Datatypes.META_OVERLOADED{1=ref ty, ...}) = apply_map ty
	  | apply_map(ty as Datatypes.TYVAR _) = ty
	  | apply_map(Datatypes.METARECTYPE(ref {3=ty, ...})) = apply_map ty
	  | apply_map(Datatypes.RECTYPE mapping) =
	    Datatypes.RECTYPE(NewMap.map apply_map_map mapping)
	  | apply_map(Datatypes.FUNTYPE(ty, ty')) =
	    Datatypes.FUNTYPE(apply_map ty, apply_map ty')
	  | apply_map(Datatypes.CONSTYPE(ty_list, tyname)) =
	    Datatypes.CONSTYPE(map apply_map ty_list, tyname)
	  | apply_map(ty as Datatypes.DEBRUIJN _) = ty
	  | apply_map(ty as Datatypes.NULLTYPE) = ty
d920 1
a920 1
	and apply_map_map(_, ty) = apply_map ty
d922 1
a922 1
	apply_map
d932 8
d942 49
a990 59
	val Options.OPTIONS{print_options, ...} = options
	exception ApplyRecipe
	fun apply_recipe (annotation,ty,name) =
	  let
	    val result =
	      DebuggerUtilities.apply_recipe(annotation,ty)
	      handle DebuggerUtilities.ApplyRecipe problem =>
		(debugl (fn _ =>
			 ["Recipe problem " ^ problem ^ " for " ^ name,
			  "Annotation: " ^ Debugger_Types.print_backend_annotation annotation,
			  "Arg : " ^ Types.debug_print_type ty]);
		raise ApplyRecipe)
	  in
	    if do_debug then
	      debugl (fn _ => ["Name: " ^ name,
			       "Annotation: " ^ Debugger_Types.print_backend_annotation annotation,
			       "Arg : " ^ Types.debug_print_type ty,
			       "Res : " ^ Types.debug_print_type result])
	    else ();
	      result
	  end

	datatype TypeThunk =
	  NORECIPE |
	  RECIPE of (Debugger_Types.Backend_Annotation * Datatypes.Type)

	fun generate_from_previous_types([], _, ty) = ty (*Can't do any better here *)
	  | generate_from_previous_types(poly_type_list, mono_type_list, ty) =
	    let
	      val new_poly_type =
		Datatypes.FUNTYPE
		(type_list_to_rectype poly_type_list,
		 Datatypes.NULLTYPE) (* Result type will be ignored *)
	      val new_mono_type = type_list_to_rectype mono_type_list
	      val recipe =
		DebuggerUtilities.generate_recipe(new_poly_type, ty, "Debugger internal")
	    in
	      DebuggerUtilities.apply_recipe(recipe, new_mono_type)
	      handle DebuggerUtilities.ApplyRecipe problem =>
		(debug(fn _ =>"Problem '" ^ problem ^
			"' with record type inference mechanism\nty = " ^
			Types.debug_print_type ty ^
			" as " ^ Types.extra_debug_print_type ty ^
			" and\nnew_poly_type = " ^
			Types.debug_print_type new_poly_type ^
			" as " ^ Types.extra_debug_print_type new_poly_type ^ "\n"
			);
		raise ApplyRecipe)
	    end

	val sys_indicator = "[ "

	fun upto_sys_indicator(s, i) =
	  if i+1 >= size s then s
	  else
	    if String.substring(s, i, 2) = sys_indicator then
	      String.substring(s, 0, i+2)
	    else
	      upto_sys_indicator(s, i+1)
d992 1
d994 10
a1003 1
	(* This appears to only do a subset of what was inside frame_name (and
d1005 1
a1005 1
	   changed - stephenb *)
d1007 4
a1010 4
	fun get_code closure =
	  MLWorks.Internal.Value.cast
	  (MLWorks.Internal.Value.unsafe_record_sub
	   (MLWorks.Internal.Value.cast closure, 0))
d1014 2
a1015 2
	val print_int : int -> unit =
	  MLWorks.Internal.Value.cast(MLWorks.Internal.Runtime.environment "print integer")
d1017 5
a1021 5
	val step_through : int = get_code(Trace.step_through (fn x => x))
	val step_through_name =
	  upto_sys_indicator
	  (MLWorks.Internal.Value.code_name(MLWorks.Internal.Value.cast step_through),
	   0)
d1024 3
a1026 3
	val _ = debug_print("parameter type: " ^ print_parameter parameter ^
			    " step_through name: " ^ step_through_name)
	val _ = print_int step_through
d1029 3
a1031 3
	fun infer_types (recipe,[], _, _) = ()
	  | infer_types (recipe,frame::rest, done_poly_types, done_mono_types) =
	    let
d1033 1
a1033 1
	      fun debug f = debug_print (f ())
d1035 125
a1159 125
	    in
	    (case frame of
	       CFRAME (frame,_) =>
		 (debug(fn _ => "CFRAME");
		  
		 if StackInterface.is_stack_extension_frame frame then
		   infer_types (recipe,rest, done_poly_types, done_mono_types)
		 else
		   infer_types (NORECIPE,rest, done_poly_types, done_mono_types)
		   )
	     | MLFRAME (fr,((name,_),_),_,NOFRAMEINFO) =>
		 let
		   val frame_name = upto_sys_indicator(StackInterface.frame_name fr, 0)
		   val recipe =
		     if frame_name = step_through_name then recipe else NORECIPE
		 (* We can use the recipe from the previous frame *)
		 (* when we find a step_through frame *)
		 in
		   (debug(fn _ => "MLFRAME for " ^ name ^
			  " - no info, => no recipe,\n" ^
			    "parameter type: " ^ print_parameter parameter ^
			    " but inferred type was: " ^
			    (case recipe of
			       RECIPE(r, ty) =>
				 Types.debug_print_type(apply_recipe (r,ty,name))
			     | _ => "unavailable due to missing recipe"));
		   infer_types (recipe,rest, done_poly_types, done_mono_types))
		 end
	     | MLFRAME (_,((name,_),_),_,FRAMEINFO(arg_type,annotation,_,tyref)) =>
		 let
		   val _ = debug (fn _ => "Doing " ^ name)
		   val itype =
		     if not (DebuggerUtilities.is_type_polymorphic arg_type)
		       then (debug (fn _ => "Not polymorphic"); arg_type)
		     else
		       let
			 val reconstructed_type =
			   case recipe of
			     NORECIPE =>
			       (debug (fn _ => "No recipe, trying previous types");
				let
				  val done_poly_types =
				    type_list_to_rectype done_poly_types
				  val done_mono_types =
				    type_list_to_rectype done_mono_types
				  val map =
				    make_partial_map(done_poly_types,
						     done_mono_types, [])
				  val seen_tyvars = Types.no_tyvars
				  val (str1, seen_tyvars) =
				    Types.print_type_with_seen_tyvars
				    (print_options, done_poly_types, seen_tyvars)
				  val (str2, seen_tyvars) =
				    Types.print_type_with_seen_tyvars
				    (print_options, done_mono_types, seen_tyvars)
				  val (str3, seen_tyvars) =
				    Types.print_type_with_seen_tyvars
				    (print_options, arg_type, seen_tyvars)
				in
				  debug_print("Attempting partial tyvar substitution in stack backtrace for\n" ^
					      str1 ^ " as\n" ^
					      str2 ^ " with\n" ^
					      str3);
				  apply_map map arg_type
				end)
			   | RECIPE(r,ty) =>
			       let
				 val _ = debug (fn _ => "Applying recipe to " ^
						Types.debug_print_type ty ^
						" when arg_type = " ^
						Types.debug_print_type arg_type)
			       in
				 apply_recipe (r,ty,name)
				 handle ApplyRecipe =>
				   (debug(fn _ => "generating from previous types");
				    
				    generate_from_previous_types(done_poly_types, done_mono_types, arg_type)
				    handle ApplyRecipe =>
				      (* This case should try to use the partial instantiation stuff *)
				      let
					val done_poly_types =
					  type_list_to_rectype done_poly_types
					val done_mono_types =
					  type_list_to_rectype done_mono_types
					val map =
					  make_partial_map(done_poly_types,
							   done_mono_types, [])
					val seen_tyvars = Types.no_tyvars
					  
					val (str1, seen_tyvars) =
					  Types.print_type_with_seen_tyvars
					  (print_options, done_poly_types, seen_tyvars)
					  val (str2, seen_tyvars) =
					    Types.print_type_with_seen_tyvars
					    (print_options, done_mono_types, seen_tyvars)
					  val (str3, seen_tyvars) =
					    Types.print_type_with_seen_tyvars
					    (print_options, arg_type, seen_tyvars)
				      in
					debug(fn _ => "Attempting partial tyvar substitution in stack backtrace for\n" ^
					      str1 ^ " as\n" ^
					      str2 ^ " with\n" ^
					      str3);
					apply_map map arg_type
				      end)
			       end
		       in
			 Types.combine_types (reconstructed_type,arg_type)
			 handle Types.CombineTypes =>
			   (debug (fn _ =>
				   implode ["Combine types fails for: ",
					    name, "\n argtype: ",
					    Types.debug_print_type arg_type,
					    "\n reconstructed type: ",
					    Types.debug_print_type reconstructed_type]);
			   arg_type)
		       end
		 in
		   tyref := itype;
		   debug (fn _ => " Type = " ^ Types.extra_debug_print_type itype);
		   infer_types (RECIPE (annotation,itype), rest,
				arg_type :: done_poly_types,
				itype :: done_mono_types)
		 end)
	    end
d1161 2
a1162 2
	val frames = map (get_frame_details options) basic_frames
	val _ = infer_types (NORECIPE,frames, [], [])
d1164 8
a1171 8
	case parameter of
	  EXCEPTION _ =>
	    ((* Omit the first frame.  This should usually be a top level handler *)
	     case rev frames of
	       (_::rest) => rest
	     | rest => rest)
	(* Otherwise, keep all of the frames -- the top ones will usually be C frames and suppressed *)
	| _ => rev frames
d1181 59
a1239 59
	fun fix_runtime_env_types(RuntimeEnv.LET(varinfo_env_list, env)) =
	  let
	    val varinfo_env_list =
	      map
	      (fn (RuntimeEnv.NOVARINFO, env) =>
	       (RuntimeEnv.NOVARINFO, fix_runtime_env_types env)
		| (var as RuntimeEnv.VARINFO(str, (ty' as ref ty, rti_ref), offs_ref_opt),
		   env) =>
		  let
		    val recipe =
		      DebuggerUtilities.generate_recipe
		      (Datatypes.FUNTYPE(arg_type, Datatypes.NULLTYPE), ty,
		       "fix_runtime_env_types")
		    val env = fix_runtime_env_types env
		  in
		    (RuntimeEnv.VARINFO
		     (str, (ref(DebuggerUtilities.apply_recipe(recipe, inferred_type)),
			    rti_ref), offs_ref_opt), env)
		    handle exn as DebuggerUtilities.ApplyRecipe _ =>
		      if raise_excp then raise exn
		      else
			(* Do stuff with partial_maps *)
			((*output(std_out, "Attempting partial tyvar substitution for\n" ^
				Types.debug_print_type arg_type ^ " as\n" ^
				Types.debug_print_type inferred_type ^ " with\n" ^
				Types.debug_print_type ty ^ "\n");*)
			 let
			   val map = make_partial_map(arg_type, inferred_type, [])
			 in
			   (RuntimeEnv.VARINFO
			    (str, (ref(apply_map map ty), rti_ref), offs_ref_opt), env)
			 end)
		  end)
	      varinfo_env_list
	  in
	    RuntimeEnv.LET(varinfo_env_list, fix_runtime_env_types env)
	  end
	  | fix_runtime_env_types(RuntimeEnv.FN(string, env, offs, funinfo)) =
	    RuntimeEnv.FN(string, fix_runtime_env_types env, offs, funinfo)
	  | fix_runtime_env_types(RuntimeEnv.APP(env, env', int_opt)) =
	    RuntimeEnv.APP(fix_runtime_env_types env, fix_runtime_env_types env',
			   int_opt)
	  | fix_runtime_env_types(RuntimeEnv.RAISE env) =
	    RuntimeEnv.RAISE(fix_runtime_env_types env)
	  | fix_runtime_env_types(RuntimeEnv.SELECT(int, env)) =
	    RuntimeEnv.SELECT(int, fix_runtime_env_types env)
	  | fix_runtime_env_types(RuntimeEnv.STRUCT(env_list)) =
	    RuntimeEnv.STRUCT(map fix_runtime_env_types env_list)
	  | fix_runtime_env_types(RuntimeEnv.LIST(env_list)) =
	    RuntimeEnv.LIST(map fix_runtime_env_types env_list)
	  | fix_runtime_env_types(RuntimeEnv.SWITCH(env, offs_ref, int, tag_env_list)) =
	    RuntimeEnv.SWITCH
	    (fix_runtime_env_types env, offs_ref, int,
	     map (fn (tag, env) => (tag, fix_runtime_env_types env)) tag_env_list)
	  | fix_runtime_env_types(RuntimeEnv.HANDLE(env, offs_ref, int, int', env')) =
	    RuntimeEnv.HANDLE(fix_runtime_env_types env, offs_ref, int, int',
			      fix_runtime_env_types env')
	  | fix_runtime_env_types(RuntimeEnv.EMPTY) = RuntimeEnv.EMPTY
	  | fix_runtime_env_types(RuntimeEnv.BUILTIN) = RuntimeEnv.BUILTIN
d1241 1
a1241 1
	fix_runtime_env_types
d1246 1
a1246 1
	i
d1248 1
a1248 1
	find_space(s, i+1)
d1252 1
a1252 1
	i
d1254 1
a1254 1
	ignore_spaces(s, i+1)
d1258 1
a1258 1
	0
d1260 8
a1267 8
	let
	  val arg' = (s, i+1)
	in
	  if String.ordof arg = ord":" then
	    ignore_spaces arg'
	  else
	    find_colon arg'
	end
d1272 2
a1273 2
	val start = find_colon(s, 0)
	val finish = find_space(s, start)
d1275 5
a1279 5
	val _ = output(std_out,
		       "Looking for name of '" ^ s ^ "' with start = " ^
		       MLWorks.Integer.makestring start ^
		       " and finish = " ^
		       MLWorks.Integer.makestring finish ^ "\n")
d1282 1
a1282 1
	String.substring(s, start, finish-start)
d1321 4
a1324 4
	   output (std_out, MLWorks.Integer.makestring ignore_count);
	   output (std_out, " hits on the breakpoint ");
	   output (std_out, breakpoint_name);
	   output (std_out, "\n"))
d1327 1
a1327 1
	   output (std_out, " is not a breakpoint\n"))
d1332 6
a1337 6
	     (output (std_out, name);
	      output (std_out, " ");
	      output (std_out, MLWorks.Integer.makestring hits);
	      output (std_out, " ");
	      output (std_out, MLWorks.Integer.makestring max);
	      output (std_out, "\n"))
d1341 1
a1341 1
	     output (std_out, "No breakpoints set\n\n")
d1343 2
a1344 2
	     (Lists.iterate display_breakpoint breakpoints;
	      output (std_out, "\n"))
d1352 9
d1371 2
a1372 7
        case frame_type of
          "anon" =>      SOME StackFrame.hide_anonymous_frames
        | "handler" =>   SOME StackFrame.hide_handler_frames
        | "delivered" => SOME StackFrame.hide_delivered_frames
        | "setup" =>     SOME StackFrame.hide_setup_frames
        | "c" =>         SOME StackFrame.hide_c_frames
        | _ =>           NONE
d1382 1
d1385 1
a1385 1
          fun out str = (output (std_out, str); output (std_out, " "))
d1387 1
a1387 5
          if !StackFrame.hide_c_frames = status then out "c" else ();
          if !StackFrame.hide_setup_frames = status then out "setup" else ();
          if !StackFrame.hide_anonymous_frames = status then out "anon" else ();
          if !StackFrame.hide_handler_frames = status then out "handler" else ();
          if !StackFrame.hide_delivered_frames = status then out "delivered" else ();
d1422 2
a1423 2
	     output (std_out, "X\nfile_name= X");
	     output (std_out, file_name);
d1426 1
a1426 1
	     output (std_out, "X\n"))
d1437 3
a1439 4
            if n = 0 then
              display_frame b
            else 
              show_frame_above_command (as', a::below, n-1)
d1443 3
a1445 4
            if n = 0 then
              display_frame b
            else 
             show_frame_below_command (b::above, bs, n-1)
d1593 1
a1593 1
	if should_ignore parameter then
d1595 165
a1759 165
	else
	  let
	    val Options.OPTIONS {print_options, ...} = options
	    val Preferences.PREFERENCES {environment_options,...} = preferences

	    val Preferences.ENVIRONMENT_OPTIONS
	      {use_debugger, window_debugger, ...} =
	      environment_options

	    fun stack_empty basic_frames =
	      case parameter of
		EXCEPTION _ => Lists.length basic_frames <= 2
	      (* one for the money, two for the show *)
	      | _ => false

	    fun make_frame_details (CFRAME (f,s),_) _ =
	      ("<Cframe> "^s,"",
	       (Datatypes.NULLTYPE,cast 0,""), MLWorks.Option.NONE)
	      | make_frame_details (MLFRAME (f,((name,(loc,_)),st),arg,NOFRAMEINFO),_) _ =
		(implode[name,"<??>"],
		 implode["[",loc,"]"],
		 (Datatypes.NULLTYPE,cast 0,""),
		 MLWorks.Option.NONE)
	      | make_frame_details (MLFRAME (f,
					     ((name,(loc,_)),st),
					     arg,
					     FRAMEINFO(arg_type,annotation,runtime_env,
						       ref inferredType)),frames) windowing =
		(implode[name," ",
			 if windowing then ""
			 else
			   ValuePrinter.stringify_value false (print_options,
							       arg,
							       inferredType,
							       get_interpreter_information())],
		implode[name,"[",loc,"]", ":",Types.print_type print_options inferredType],
		if windowing then
		  (inferredType, arg,
		   ValuePrinter.stringify_value false (print_options,
						       arg,
						       inferredType,
						       get_interpreter_information()))
		else (Datatypes.NULLTYPE, cast 0,""),
		  if windowing then
		    let
		      val new_runtime_env =
			(fix_runtime_env_types
			 (arg_type, inferredType, true)
			 runtime_env)
			handle DebuggerUtilities.ApplyRecipe _ =>
			  (* Try using the entire set of frames to do the same job *)
			  let
			    fun collect_types(poly_list, mono_list, []) =
			      (poly_list, mono_list)
			      | collect_types(poly_list, mono_list, CFRAME _ :: frames) =
				collect_types(poly_list, mono_list, frames)
			      | collect_types(poly_list, mono_list,
					      MLFRAME(_, _, _, NOFRAMEINFO) :: frames) =
				collect_types(poly_list, mono_list, frames)
			      | collect_types(poly_list, mono_list,
					      MLFRAME(_, _, _,
						      FRAMEINFO(arg_type, _, _,
								ref inferredType)) ::
					      frames) =
				collect_types(arg_type :: poly_list,
					      inferredType :: mono_list,
					      frames)
			    val (poly_type_list, mono_type_list) =
			      collect_types([arg_type], [inferredType], frames)
			    val new_poly_type =
			      type_list_to_rectype poly_type_list
			    val new_mono_type = type_list_to_rectype mono_type_list
			  in
			    (fix_runtime_env_types
			     (new_poly_type, new_mono_type, false)
			     runtime_env)
			    (* This shouldn't raise, but just in case it does ... *)
			    handle DebuggerUtilities.ApplyRecipe _ =>
			      runtime_env
			  end
		    in
		      (* This should use the full stack if necessary *)
		      (* And now it does *)
		      MLWorks.Option.SOME (ref (MLWorks.Option.INL
						(fn () =>
						 DebuggerPrint.print_env
						 ((f, new_runtime_env, inferredType),
						  fn (ty1,value) =>
						  ValuePrinter.stringify_value true (print_options,
										     value,
										     ty1,get_interpreter_information()),
						  options,true,
						  map (fn MLFRAME(frame,_,_,FRAMEINFO(_,_,env,ref ty))=>(frame,env,ty)
						| MLFRAME (frame,_,_,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)
						| CFRAME(frame,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE))
						  frames))))
		    end
		  else MLWorks.Option.NONE)

	    fun make_frame_strings frames =
	      let
		fun aux (frame::frames,acc) =
		  let
		    val details = make_frame_details (frame,frames) true
		    val stuff =
		      case frame of
			CFRAME (_,loc) => {name = "<Cframe>", loc = loc,details = details}
		      | MLFRAME (_,((name,(loc,_)),_),_,_) => {name = name,loc = loc, details = details}
		  in
		    aux (frames,stuff::acc)
		  end
		  | aux (nil,acc) = rev acc
	      in
		aux (frames,[])
	      end

	    fun parameter_details () =
	      case parameter of
		EXCEPTION exn =>
		  let
		    val Options.PRINTOPTIONS{maximum_seq_size,
					     maximum_string_size,
					     maximum_ref_depth,
					     maximum_str_depth,
					     maximum_depth,
					     float_precision,
					     print_fn_details,
					     print_exn_details,
					     show_id_class,
					     show_eq_info
					     } = print_options
		    val print_options =
		      Options.PRINTOPTIONS{maximum_seq_size = maximum_seq_size,
					   maximum_string_size = maximum_string_size,
					   maximum_ref_depth = maximum_ref_depth,
					   maximum_str_depth = maximum_str_depth,
					   maximum_depth = maximum_depth,
					   float_precision = float_precision,
					   print_fn_details = print_fn_details,
					   print_exn_details = true,
					   show_id_class = show_id_class,
					   show_eq_info = show_eq_info
					   }
		  in
		    implode ["Exception ",
			     ValuePrinter.stringify_value false (print_options,
								 cast exn,
								 Datatypes.CONSTYPE([],Types.exn_tyname),
								 get_interpreter_information()),
			     " raised"]
		  end
	      | INTERRUPT => "Interrupt"
	      | FATAL_SIGNAL s =>
		  "Fatal Unix signal " ^ MLWorks.Integer.makestring s
	      | BREAK s => s
	      | STACK_OVERFLOW => "Break on stack overflow"

	    fun outfun s = output(std_out,s)
	    fun outline s = outfun (s ^ "\n")

	    fun output_frame_details frame =
	      outline (#1 (make_frame_details (frame,nil) false))
	    fun output_full_frame_details frame =
	      outline (#2 (make_frame_details (frame,nil) false))
	    fun prompt s = (outfun s; MLWorks.IO.flush_out std_out)
d1764 75
a1838 68
	    fun do_continue action =
	      (case continue_continuation of
		 NOT_POSSIBLE => outline "Cannot Continue"
	       | POSSIBLE(_,NORMAL_RETURN) => (action (); raise Exit)
	       | POSSIBLE(_,DO_RAISE exn) => raise exn
	       | POSSIBLE (_,FUN f) => f ())

	    fun do_quit() =
	      (case quit_continuation of
		 NOT_POSSIBLE => outline "Cannot Quit"
	       | POSSIBLE(_,NORMAL_RETURN) => raise Exit
	       | POSSIBLE(_,DO_RAISE exn) => raise exn
	       | POSSIBLE(_,FUN f) => (f()))

	    fun do_input frames =
	      let
		fun is_whitespace char =
		  case char of
		    " " => true
		  | "\n" => true
		  | _ => false

		fun parse_command s =
		  let
		    fun parse ([],acc) =
		      (case acc of
			 [] => []
		       | _ =>  [implode (rev acc)])
		      | parse (char::rest,acc) =
			if is_whitespace char
			  then
			    (case acc of
			       nil => parse (rest,nil)
			     | _ => implode(rev acc)::parse(rest,nil))
			else
			  parse (rest,char::acc)
		  in
		    parse (explode s,[])
		  end

		fun edit_frame (CFRAME _) =
		  outline "Cannot edit source for C frame"
		  | edit_frame (MLFRAME (_,((_,(loc,_)),_),_,_)) =
		    (ShellUtils.edit_source (loc, preferences); ())
		    handle ShellUtils.EditFailed s => outline ("Edit failed: " ^ s)

		fun display_simple_help_info () =
		  outline "Enter ? or help for help"

		fun display_help_info () =
		  Lists.iterate
		  outline
		  (["Commands:",
		    " <                - go to the earliest frame in the stack",
		    " >                - go to the latest frame in the stack",
		    " i                - next frame INto the stack or next later frame (callee)",
		    " i <n>            - next n frames INto the stack",
		    " o                - next frame OUT of the stack or next earlier frame (caller)",
		    " o <n>            - next n frames OUT of the stack",
		    " b                - do a backtrace of the stack",
		    " f                - show full frame details",
		    " e                - edit definition",
		    " h {<name>}       - hide the given types of frame or list hidden frame types if none given",
		    " r {<name>}       - reveal the given types of frame or list the reveald frame types if none given",
		    " p                - print values of local and closure variables",
		    " c                - continue interrupted computation",
		    " s                - step through computation",
		    " s <n>            - step through computation to nth function call",
d1840 4
a1843 4
		    " trace <name>     - set trace on function entry at <name>",
		    " breakpoint <name> - set breakpoint on function entry at <name>",
		    " untrace <name>   - unset trace on function entry at <name>",
		    " unbreakpoint <name> - unset breakpoint on function entry at <name>",
d1845 34
a1878 34
		    " ignore name n    - ignore the next n hits on the breakpoint on function <name>",
		    " help             - display this help info",
		    " ?                - display this help info"] @@
		  (case continue_continuation of
		     POSSIBLE(st,_) => [" c                - " ^ st]
		   | _ => []) @@
		     (case quit_continuation of
			POSSIBLE(st,_) => [" q                - " ^ st]
		      | _ => []))

		fun string_to_int str =
		  let
		    exception Finished of int
		    fun factor 0 = 1
		      | factor n = 10*factor (n-1)
		    fun string_to_int nil (n,_) = n
		      | string_to_int (m::ms) (n,power) =
			string_to_int ms
			((case m of
			    "1" => 1*(factor power)+n
			  | "2" => 2*(factor power)+n
			  | "3" => 3*(factor power)+n
			  | "4" => 4*(factor power)+n
			  | "5" => 5*(factor power)+n
			  | "6" => 6*(factor power)+n
			  | "7" => 7*(factor power)+n
			  | "8" => 8*(factor power)+n
			  | "9" => 9*(factor power)+n
			  | "0" => n
			  | _ => raise Finished(n)),power+1)
		  in
		    string_to_int (rev(explode str)) (0,0)
		    handle Finished(n) => n
		  end
d1883 3
a1885 3
		fun loop (above, below as (this::rest)) =
		  let
		    val _ = if Trace.stepping () then
d1890 1
a1890 1
		    val _ = prompt "Debugger> "
d1892 36
a1927 36
		    val command_and_args =
		      let
			val _ =
			  if end_of_stream std_in then
			    (do_quit(); raise Exit)
			  else ()

			val line = MLWorks.IO.input_line std_in
		      in
			parse_command line
		      end
		    fun frame_fnname () =
		      let
			val (name,loc,fnname) =
			  case this of
			    CFRAME (_,name) => (name,"","")
			  | MLFRAME (_,((name,(loc,fnname)),_),_,_) => (name,loc,fnname)
			fun to_rbrace nil = Crash.impossible "rbrace:frame_fnname:loop:ml_debugger"
			  | to_rbrace ("}"::rest) = rest
			  | to_rbrace (_::rest) = to_rbrace rest
		      in
			case explode fnname of
			  "{"::namechars => (implode o rev o to_rbrace o rev) namechars
			| _ => name ^ "[" ^ loc ^ "]"
		      end
		  in
		    case command_and_args of
		      "<"::_ => loop (goto_top_command (above, below))
		    | ">"::_ => loop (goto_bottom_command (above, below))
		    | "f"::_ =>
			(output_full_frame_details this;
			 loop (above,below))
		    | "e"::_ =>
			(edit_frame this;
			 loop (above,below))
		    | ["i"] =>
d1929 1
a1929 1
		    | "i"::arg::_ =>
d1935 1
a1935 1
		    | ["o"] =>
d1937 1
a1937 1
		    | "o"::arg::_ =>
d1943 6
a1948 6
		    | ["b"] =>
			(output (std_out, "(Current frame)\n");
			 Lists.iterate output_frame_details below;
			 output (std_out, "(Outermost frame)\n");
			 loop (above,below))
		    | ("b"::arg::_) =>
d1951 1
a1951 1
			  val frames' = firstn (below, n)
d1954 1
a1954 1
			  Lists.iterate output_frame_details frames';
d1957 4
a1960 4
		    | "c"::_ =>
			(do_continue (fn () => Trace.set_stepping false);
			 loop (above,below))
		    | ["h"] => 
d1963 1
a1963 1
		    | "h"::names =>
d1966 5
a1970 5
		    | "q"::_ =>
			(do_quit ();
			 raise Exit;
			 loop (above,below))
		    | ["r"] => 
d1973 1
a1973 1
		    | "r"::names => 
d1976 9
a1984 9
		    | ""::_ => loop (above,below)
		    | "?"::_ =>
			(display_help_info();
			 loop (above,below))
		    | "help"::_ =>
			(display_help_info();
			 loop (above,below))
		    | "trace" :: args => (Lists.iterate Trace.trace args;
					  loop (above,below))
d1986 15
a2000 15
			(breakpoints_command ();
			 loop (above, below))
		    | "breakpoint" :: args => (Lists.iterate Trace.break
					       (map (fn name => {name=name, hits=0, max=1}) args);
					       loop (above,below))
		    | "ignore" :: fn_name :: n :: _ =>
			(ignore_command fn_name (string_to_int n);
			 loop (above, below))
		    | "untrace" :: args => (Lists.iterate Trace.untrace args;
					    loop (above,below))
		    | "unbreakpoint" :: args => (Lists.iterate Trace.unbreak args;
						 loop (above,below))
		    | ["s"] => (do_continue (fn () => Trace.set_stepping true);
				loop (above,below))
		    | "s" :: arg :: _ => 
d2003 14
a2016 14
			   Trace.set_step_count (string_to_int arg)));
			loop (above,below))
		    | ["n"] => 
			(do_continue (fn () => next_command logical_top_frame);
			 loop (above, below))
		    | "show_frame_above"::arg::_ => 
			(show_frame_above_command (above, below, string_to_int arg);
			 loop (above,below))
		    | "show_frame_below"::arg::_ => 
			(show_frame_below_command (above, below, string_to_int arg);
			 loop (above,below))
		    | ["show_top_frame"] => 
			(show_top_frame_command logical_top_frame;
			 loop (above,below))
d2023 1
a2023 1
		    | ["t"] => 
d2026 1
a2026 1
		    | "p"::_ =>
d2029 12
a2040 12
		    | "show_debug"::_ =>
			(let
			   val debug_info = get_interpreter_information ()
			 in
			   Lists.iterate (fn s => output(std_out,s^"\n")) (Debugger_Types.print_information (debug_info,true))
			 end;
			   loop (above,below))
		    | _ => (display_simple_help_info();
			    loop (above,below))
		  end
		  | loop _ = output (std_out,"No frames to look at in debugger!\n")
	      in
d2045 1
a2045 1
		loop ([], filter_frames frames)
d2047 1
a2047 1
	      end
d2049 17
a2065 17
	    fun make_entry_info_line () =
	      (case quit_continuation of
		 POSSIBLE (s,_) => "q : " ^ s ^ ", "
	       | _ => "") ^
		 (case continue_continuation of
		    POSSIBLE (s,_) => "c : " ^ s ^ ", "
		  | _ => "") ^
		    " ? : more help"

	    fun tty_debugger basic_frames =
	      if not (!use_debugger) then
		(outline (parameter_details ());
		 do_quit ())
	      else
		if stack_empty basic_frames then
		  outline (parameter_details () ^ " at top level")
		else
d2072 11
a2082 11
	  in
	    let
	      val top_frame = MLWorks.Internal.Value.Frame.current ()
	      val basic_frames =
		StackInterface.get_basic_frames (top_frame,base_frame)
	    
	      (* The identifier debugger_call is never used; this is deliberate!
	       See below.  *)
	      val debugger_call =
		case type_of_debugger of
		  TERMINAL =>
d2084 29
a2112 35
		| WINDOWING (make_window, send_message, tty_ok) =>
		    if tty_ok andalso not (!window_debugger) then
		      tty_debugger basic_frames
		    else if not (!use_debugger) then
		      (send_message (parameter_details () ^ "\n");
		       do_quit ())
			 else
			   if stack_empty basic_frames then
			     send_message (parameter_details () ^ " at top level\n")
			   else
			     let
		    (* This is terribly distracting when stepping *)
		    (* val _ = outline (parameter_details ()) *)
		    val frames = make_frames (basic_frames,parameter,options)
		    val frame_strings = make_frame_strings frames

		    fun edit s =
		      (ShellUtils.edit_location (s, preferences); ())
		      handle ShellUtils.EditFailed s =>
			send_message ("Edit failed: " ^ s)
			     in
			       make_window
			       {parameter_details = parameter_details (),
				frames = frame_strings,
				quit_fn =
				make_continuation_function quit_continuation,
				continue_fn =
				make_continuation_function continue_continuation};
			       ()
			     end
	    in
	      (* Ensure call to tty_debugger not tail, else frame is invalid *)
	      ()
	    end
	  end
d2120 6
a2125 6
	val frame = MLWorks.Internal.Value.Frame.current ()
	val old_frame = !start_frame_ref
	val _ = start_frame_ref := frame
	val result =
	  f frame
	  handle exn => (start_frame_ref := old_frame; raise exn)
d2127 2
a2128 2
	start_frame_ref := old_frame;
	result
d2137 3
a2139 3
	val old_type = !debugger_type_ref
	val _ = debugger_type_ref := debugger_type
	val result = (with_start_frame f) handle exn => (debugger_type_ref := old_type; raise exn)
d2141 2
a2142 2
	debugger_type_ref := old_type;
	result
a2147 1

@


1.139
log
@Rewrite frame hiding so that it supports the same sort of
features as the gui debugger.
@
text
@d4 4
d480 1
d498 1
a1340 5
      val hide_c_frames = ref true
      val hide_setup_frames = ref true
      val hide_anonymous_frames = ref true
      val hide_handler_frames = ref true
      val hide_delivered_frames = ref true
d1342 1
a1342 1
      fun hide_frame (CFRAME _) = !hide_c_frames
d1345 4
a1348 4
              "<Setup>"  => !hide_setup_frames
            | "<anon>"   => !hide_anonymous_frames
            | "<handle>" => !hide_handler_frames
            | _          => file_name <> "" andalso !hide_delivered_frames
d1352 5
a1356 5
          "anon" =>      SOME hide_anonymous_frames
        | "handler" =>   SOME hide_handler_frames
        | "delivered" => SOME hide_delivered_frames
        | "setup" =>     SOME hide_setup_frames
        | "c" =>         SOME hide_c_frames
d1371 5
a1375 5
          if !hide_c_frames = status then out "c" else ();
          if !hide_setup_frames = status then out "setup" else ();
          if !hide_anonymous_frames = status then out "anon" else ();
          if !hide_handler_frames = status then out "handler" else ();
          if !hide_delivered_frames = status then out "delivered" else ();
@


1.138
log
@Replacing Map with NewMap
@
text
@d4 3
a766 2
    val suppressed_frames = ref ["<Cframe>" (*, "<Setup>" *)] : string list ref

d1335 13
a1347 8
      fun next_ml_frame [] = NONE
        | next_ml_frame ((frame as (MLFRAME _))::_) = SOME frame
        | next_ml_frame ((CFRAME _)::frames) = next_ml_frame frames
    in
      fun second_ml_frame [] = NONE
        | second_ml_frame ((MLFRAME _)::frames) = next_ml_frame frames
        | second_ml_frame ((CFRAME _)::frames) = second_ml_frame frames
    end
d1349 9
d1359 6
d1366 11
a1376 42
    (* Filter out any frames related to the next/step/trace mechanism
     * from the frame list so that they are not visible to the user.
     * For example, after a hitting a breakpoint on "fact", the stack
     * will look like (stack grows upwards) :-
     *
     *   MLFRAME "breakpoint"
     *   CRAME   "start"
     *   CFRAME  "start intercept"
     *   CFRAME  "start intercept"
     *   MLFRAME "fact"
     *
     * Therefore, the MLFRAME "breakpoint" and the next 3 frames are
     * removed from the list.  As the user steps through code it is
     * also possible for something like the following to appear (again
     * the stack grows upwards) :-
     *
     *   MLFRAME "fact"
     *   MLFRAME "step_always"
     *   CRAME   "start"
     *   CFRAME  "start intercept"
     *   CFRAME  "start intercept"
     *   MLFRAME "fact"
     *  
     * Here the first "fact" is an artifact of the stepping mechansism
     * so besides removing the step_always and the following 3 frames
     * it is also necessary to remove the preceeding MLFRAME.
     * 
     * SYSFRAMEID: Note that the way system frames are identified is by
     * their name and file_name!  This is hardly ideal, but it is the
     * best we can do at the moment.
     *)
    local
      fun system_frame (MLFRAME (_, ((name, (_,file_name)), _) , _, _)) =
        if file_name = "" then
          name = "replacement"
        else if file_name = "<Entry1>" then
          name = "breakpoint"  orelse
          name = "step_always" orelse
          name = "step_once"
        else
          false
      | system_frame (CFRAME _) = false
a1378 15
      fun filter_out_system_frames [] = []
        | filter_out_system_frames (frames as ((frame as (MLFRAME _))::rest)) =
          if system_frame frame then
            filter_out_system_frames (Lists.nthtail (2, rest))
          else
            (case rest of 
              [] => frames
            | (next::rest') =>
                if system_frame next then
                  filter_out_system_frames (Lists.nthtail (2, rest'))
                else
                  frame::filter_out_system_frames rest)
        | filter_out_system_frames ((frame as (CFRAME _))::frames) =
            frame::(filter_out_system_frames frames)
    end
d1380 11
d1392 1
d1394 1
a1394 8
    fun next_command frames =
      case second_ml_frame frames of
        MLWorks.Option.NONE =>
          output (std_out, "No function to step over\n")
      | MLWorks.Option.SOME (MLFRAME (frame, _, _, _)) =>
          Trace.next frame
      | MLWorks.Option.SOME (CFRAME _) => 
          Crash.impossible "next_command"
d1407 1
a1407 1
             output (std_out, "name = ");
d1409 1
a1409 1
	     output (std_out, "\nfile_name= ");
d1411 1
a1411 1
             output (std_out, "\nlocation= ");
d1413 1
a1413 1
	     output (std_out, "\n"))
d1435 3
d1481 103
a1583 7
    fun ml_debugger
      (type_of_debugger, options, preferences)
      (base_frame, parameter, quit_continuation, continue_continuation) =
      let
	val ignore = should_ignore parameter
      in
	if ignore then ()
d1753 1
a1753 1
	    fun do_continue() =
d1756 1
a1756 1
	       | POSSIBLE(_,NORMAL_RETURN) => raise Exit
d1758 1
a1758 1
	       | POSSIBLE (_,FUN f) => (f()))
d1815 2
a1816 2
		    " h <name>         - hide frame type",
		    " r <name>         - reveal frame type",
a1836 64
		fun hidden_frame (CFRAME _) = Lists.member ("<Cframe>",!suppressed_frames)
		  | hidden_frame (MLFRAME (_,((name,_),_),_,_)) =
		    Lists.member (name,!suppressed_frames) orelse DebuggerUtilities.is_suppressed_frame_name name

		fun hide_frame_type name =
		  if (Lists.member (name,!suppressed_frames))
		    then ()
		  else suppressed_frames := name :: !suppressed_frames

		fun reveal_frame_type name =
		  let
		    fun delete_item (i,[],acc) = []
		      | delete_item (i,i'::l,acc) =
			if i = i'
			  then (rev acc) @@ l
			else delete_item (i,l,i'::acc)
		  in
		    if Lists.member (name,!suppressed_frames)
		      then suppressed_frames := delete_item (name,!suppressed_frames,[])
		    else outline ("Frame type \"" ^ name ^ "\" not currently hidden")
		  end

		exception Search
		fun search (_,[]) = raise Search
		  | search (a,l as (next :: rest)) =
		    if hidden_frame next
		      then search (next::a,rest)
		    else (a,l)

		fun goto_top l =
		  search ([],l) handle Search => ([],l)

		fun get_next_frame (above, below as (this :: rest)) =
		  (search (this::above,rest)
		   handle Search => (outline "No calling frame"; (above,below)))
		  | get_next_frame x = (outline "No calling frame"; x)

		fun get_next_frames (above, below) 0 = (above, below)
		  | get_next_frames (above, below as (this :: rest)) n =
		    (get_next_frames (search (this::above,rest)) (n-1)
		     handle Search => (outline "No calling frame"; (above,below)))
		  | get_next_frames x _ = (outline "No calling frame"; x)

		fun get_previous_frame (above,below) =
		  (case search (below,above) of
		     (l1,this :: l2) => (l2,this ::l1)
		   | _ => (outline "No called frame"; (above,below)))
		     handle Search => (outline "No called frame"; (above,below))

		fun get_previous_frames (above,below) 0 = (above,below)
		  | get_previous_frames (above,below) n =
		    (case search (below,above) of
		       (l1,this :: l2) =>
			 get_previous_frames (l2,this ::l1) (n-1)
		     | _ => (outline "No called frame"; (above,below)))
		       handle Search => (outline "No called frame"; (above,below))

		fun goto_bottom (above,below) =
		  let val distance = Lists.length below - 2
		    val distance' = if distance < 0 then 0 else distance
		  in
		    get_next_frames (above, below) distance'
		  end

d1863 2
d1901 2
a1902 2
		      "<"::_ => loop (goto_top ((rev above) @@ below))
		    | ">"::_ => loop (goto_bottom (above,below))
d1909 2
a1910 1
		    | ["i"] => loop (get_previous_frame (above,below))
d1912 7
a1918 4
			loop (case string_to_int arg of
				0 => get_previous_frame (above,below)
			      | n => get_previous_frames (above,below) n)
		    | ["o"] => loop (get_next_frame (above,below))
d1920 5
a1924 3
			loop (case string_to_int arg of
				0 => get_next_frame (above,below)
			      | n => get_next_frames (above,below) n)
d1927 1
a1927 3
			 Lists.iterate
			 (fn f => if hidden_frame f then () else output_frame_details f)
			 below;
d1931 8
a1938 6
			(output (std_out, "(Current frame)\n");
			 Lists.iterate
			 (fn f => if hidden_frame f then () else output_frame_details f)
			 (firstn (below,string_to_int arg));
			 output (std_out, "(Outermost frame)\n");
			 loop (above,below))
d1940 1
a1940 2
			(Trace.set_stepping false;
			 do_continue();
d1942 6
a1947 2
		    | ["h"] => (outline ("\"h\" needs a frame type name");loop(above,below))
		    | "h"::name::_ => (hide_frame_type name;loop (above,below))
d1952 6
a1957 2
		    | ["r"] => (outline ("\"r\" needs a frame type name");loop(above,below))
		    | "r"::name::_ => (reveal_frame_type name;loop (above,below))
d1980 1
a1980 2
		    | ["s"] => (Trace.set_stepping true;
				do_continue();
d1983 3
a1985 3
                       (Trace.set_stepping true;
			Trace.set_step_count (string_to_int arg);
			do_continue();
d1988 1
a1988 2
			(next_command below;
			 do_continue ();
d1996 3
d2005 3
a2007 3
		    | ["t"] => (Trace.set_trace_all true;
				do_continue();
				loop (above,below))
d2009 2
a2010 21
			(case this of
			   MLFRAME(frame,_,_,frameinfo) =>
			     (case frameinfo of
				NOFRAMEINFO => ()
			      | FRAMEINFO(_,_,runtime_env,ref ty) =>
				  outfun
				  (#1(DebuggerPrint.print_env
				      ((StackInterface.variable_debug_frame frame,runtime_env,ty),
				       (fn (ty,value) =>
					ValuePrinter.stringify_value true
					(print_options,
					 value,
					 ty,get_interpreter_information())),
				       options,false,
				       map
				       (fn MLFRAME(frame,_,_,FRAMEINFO(_,_,env,ref ty)) => (frame,env,ty)
				     | MLFRAME(frame,_,_,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)
				     | CFRAME(frame,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE))
				       below))))
			 | CFRAME(_) => ();
			     loop (above,below))
d2027 1
a2027 1
		loop (goto_top (filter_out_system_frames frames))
d2101 2
a2102 1
      end
@


1.137
log
@Fix so that frames created as a result of a breakpoint/step/trace
are not visible to the user.
This doesn't have any of the fancy options that the gui version does.
Hopefully this and the gui version will converge in the near future.
@
text
@d3 7
a9 1
$Log: _ml_debugger.sml,v $
d841 2
a842 2
	 (fn (map, (ty, lab)) => Datatypes.Mapping.add((lab, ty), map, Datatypes.Ident.lab_order))
	 (Datatypes.Mapping.empty_map, numbered_list))
d870 2
a871 2
	     (partial_map, Lists.zip(Datatypes.Mapping.assoc mapping,
				     Datatypes.Mapping.assoc mapping'))
d902 1
a902 1
	    Datatypes.RECTYPE(Datatypes.Mapping.mapit(mapping, apply_map))
d909 2
@


1.136
log
@Fix so that the 5th frame is displayed if the debugger has
been invoked due to stepping or breakpointing but the top
frame is displayed otherwise.
@
text
@d4 5
d1337 62
d1451 3
d1473 3
d1845 1
a1845 7
                              case parameter of
                                BREAK _ =>
                                  (case second_ml_frame below of
                                     MLWorks.Option.NONE => ()
                                   | MLWorks.Option.SOME frame =>
                                       output_frame_details frame)
                              | _ => output_frame_details this
d2007 1
a2007 1
		loop (goto_top frames)
@


1.135
log
@Add an extra (impossible) branch to a case to keep the compiler
from warning about non-exhaustive patterns.
@
text
@d4 4
d1330 2
d1342 1
d1346 1
a1346 1
     * They probably shouldn't be visible to users of the debugger.
d1383 34
d1766 1
d1772 7
a1778 4
                              (case second_ml_frame below of
                                 MLWorks.Option.NONE => ()
                               | MLWorks.Option.SOME frame =>
                                   output_frame_details frame)
d1893 6
@


1.134
log
@Updated wrt Trace.step_status -> Trace.stepping name change and wrt
the changes in the implementation of step/breakpoint which mean that
the function to break/step is not the top frame any more!  Instead it
is the second ML frame (empirically determined to be the the 4th frame
from top on the stack).
@
text
@d4 7
d1328 6
a1333 3
        MLWorks.Option.NONE =>       output (std_out, "No function to step over\n")
      | MLWorks.Option.SOME (MLFRAME (frame, _, _, _)) => Trace.next frame

@


1.133
log
@Add "breakpoints" command to tty debugger.
Modify "ignore" command so that it more closely resembles the gdb command.
@
text
@d4 4
d960 5
d970 1
d1245 2
a1246 13
    fun should_ignore_break {hits, max, name} =
      let
	val (new_hits, new_max, ignore) =
	  let val new_hits = hits+1
	  in if max >= 0 andalso new_hits >= max then
		(0, 1, false)
	     else
		(new_hits, max, true)
	  end
      in
       Trace.update_break{hits=new_hits, max=new_max, name=name};
       ignore
      end
d1248 12
d1261 10
a1270 9

    fun should_ignore INTERRUPT        = false
      | should_ignore (FATAL_SIGNAL _) = false
      | should_ignore (EXCEPTION    _) = false
      | should_ignore (BREAK  fn_info) = 
          (case Trace.is_a_break (strip_name fn_info) of
             MLWorks.Option.SOME break_info => should_ignore_break break_info
 	   | _                             => false)
      | should_ignore STACK_OVERFLOW = false
d1307 59
d1610 1
d1717 8
a1724 4
		    val _ =
		      if Trace.step_state () then
			()
		      else output_frame_details this
d1823 15
a1837 4
		    | "s" :: arg :: _ => (Trace.set_stepping true;
					  Trace.set_step_count (string_to_int arg);
					  do_continue();
					  loop (above,below))
d1875 4
a1878 3
		if Trace.step_state () 
                  then () 
                else outline "Current (innermost) stack frame:";
d1900 6
a1905 7
		  if Trace.step_state () then
		    (outline (parameter_details ());
                     do_input (make_frames (basic_frames,parameter,options)))
		  else
		    (outline (parameter_details ());
		     outline ("Entering debugger, commands: " ^ make_entry_info_line ());
		     do_input (make_frames (basic_frames,parameter,options)))
@


1.132
log
@Add the ignore command description to the help info.
@
text
@d4 3
d1262 33
d1539 5
a1543 4
		    " trace <name[<file>:<loc>]> - set trace on function entry at <name> and optional <file>,<loc>",
		    " breakpoint <name[<file>:<loc>]> - set breakpoint on function entry at <name> and optional <file>,<loc>",
		    " untrace <name[<file>:<loc>]> - unset trace on function entry at <name> and optional <file>,<loc>",
		    " unbreakpoint <name[<file>:<loc>]> - unset breakpoint on function entry at <name> and optional <file>,<loc>",
d1731 3
d1738 1
a1738 4
			((case Trace.is_a_break fn_name of
                            MLWorks.Option.SOME {hits, max, name} =>
                              Trace.update_break {hits=hits, max=max+(string_to_int n), name=name}
                          | _ => outline (fn_name ^ " does not have a breakpoint set"));
@


1.131
log
@Added the "ignore" command which allows the next n hits on a
breakpoint to be skipped.
@
text
@d4 4
d1507 1
@


1.130
log
@Need to raise Exit occasionally to exit the debugger
@
text
@d4 3
d1226 29
d1259 1
a1259 46
	val ignore =
	  case parameter of
	    INTERRUPT => false
	  | FATAL_SIGNAL _ => false
	  | EXCEPTION _ => false
	  | BREAK s =>
	      let
		val stripped = strip_name s
(*
		val _ = output(std_out, "Hit break point '" ^ s ^
			       "' stripped to '" ^ stripped ^ "\n")
*)
		val break_info =
		  case Trace.is_a_break stripped of
		    MLWorks.Option.SOME{hits, max, name} =>
		      let
			val (new_hits, ignore) =
			  let
			    val new_hits = hits+1
			  in
			    if max >= 0 andalso new_hits >= max then
			      (0, false)
			    else
			      (* This case happens when we haven't reached *)
			      (* the limit, or are only counting anyway *)
			      (new_hits, true)
			  end
			val ign_string =
			  if ignore then
			    "ignoring this time, new_hits = " ^
			    MLWorks.Integer.makestring new_hits ^
			    "and max = " ^ MLWorks.Integer.makestring max
			  else
			    "taking this time"
		      in
		      ((*output(std_out, "In the table " ^ ign_string ^ "\n");*)
		       Trace.update_break{hits=new_hits, max=max, name=name};
		       ignore)
		      end
		  | _ =>
		      ((*output(std_out, "Not in the table\n");*)
		       false)
	      in
		break_info
	      end
	  | STACK_OVERFLOW => false
d1692 6
@


1.129
log
@Fix the continue action so that if the action is not possible, it
does not drop out of the debugger back to MLWorks.
@
text
@d4 4
d1441 3
d1447 1
a1447 1
	       | POSSIBLE(_,NORMAL_RETURN) => ()
d1454 1
a1454 1
	       | POSSIBLE(_,NORMAL_RETURN) => ()
a1459 2
		exception Exit

@


1.128
log
@Change SIGNAL to INTERRUPT (interrupts aren't signals on Windows).
@
text
@d4 3
d1679 1
a1679 2
			 raise Exit;
			   loop (above,below))
d1685 1
a1685 1
			   loop (above,below))
d1706 1
a1706 2
				raise Exit;
				  loop (above,below))
d1710 1
a1710 2
					  raise Exit;
					    loop (above,below))
d1713 1
a1713 2
				raise Exit;
				  loop (above,below))
@


1.127
log
@Fixing bungle with step mode
@
text
@d4 3
d683 1
a683 1
      SIGNAL of int |
d870 1
a870 1
    fun print_parameter(SIGNAL _) = "SIGNAL"
d1222 1
a1222 1
	    SIGNAL _ => false
d1419 1
a1419 1
	      | SIGNAL s => "Unix signal " ^ MLWorks.Integer.makestring s
@


1.126
log
@Remove debugging print stuff
@
text
@d4 3
d1264 1
a1264 2
	if ignore then
	  ()
d1608 1
a1608 2
		      else
			output_frame_details this
d1746 5
a1750 3
		if Trace.step_state () then () else outline "Current (innermost) stack frame:";
		  loop (goto_top frames)
		  handle Exit => ()
d1771 2
a1772 1
		    ()
d1788 1
a1788 1
		    tty_debugger basic_frames
@


1.125
log
@Add counting of break points, and continuing multiple times
@
text
@d4 3
d1199 1
d1205 1
d1222 1
d1225 1
d1249 1
a1249 1
		      (output(std_out, "In the table " ^ ign_string ^ "\n");
d1254 1
a1254 1
		      (output(std_out, "Not in the table\n");
@


1.124
log
@General improvements to debug inference of types in stack backtraces,
particularly for local variable debugging
@
text
@d4 4
d1166 39
d1209 1
a1209 8
	val Options.OPTIONS {print_options, ...} = options
	val Preferences.PREFERENCES {environment_options,...} = preferences

	val Preferences.ENVIRONMENT_OPTIONS
	  {use_debugger, window_debugger, ...} =
	  environment_options

	fun stack_empty basic_frames =
d1211 11
a1221 40
	    EXCEPTION _ => Lists.length basic_frames <= 2
	  (* one for the money, two for the show *)
	  | _ => false

	fun make_frame_details (CFRAME (f,s),_) _ =
	  ("<Cframe> "^s,"",
	   (Datatypes.NULLTYPE,cast 0,""), MLWorks.Option.NONE)
	  | make_frame_details (MLFRAME (f,((name,(loc,_)),st),arg,NOFRAMEINFO),_) _ =
	    (implode[name,"<??>"],
	     implode["[",loc,"]"],
	     (Datatypes.NULLTYPE,cast 0,""),
	     MLWorks.Option.NONE)
	  | make_frame_details (MLFRAME (f,
					 ((name,(loc,_)),st),
					 arg,
					 FRAMEINFO(arg_type,annotation,runtime_env,
						   ref inferredType)),frames) windowing =
	    (implode[name," ",
		     if windowing then ""
		     else
		       ValuePrinter.stringify_value false (print_options,
							   arg,
							   inferredType,
							   get_interpreter_information())],
	    implode[name,"[",loc,"]", ":",Types.print_type print_options inferredType],
	    if windowing then
	      (inferredType, arg,
	       ValuePrinter.stringify_value false (print_options,
						   arg,
						   inferredType,
						   get_interpreter_information()))
	    else (Datatypes.NULLTYPE, cast 0,""),
	      if windowing then
		let
		  val new_runtime_env =
		    (fix_runtime_env_types
		     (arg_type, inferredType, true)
		     runtime_env)
		    handle DebuggerUtilities.ApplyRecipe _ =>
		      (* Try using the entire set of frames to do the same job *)
d1223 18
a1240 20
			fun collect_types(poly_list, mono_list, []) =
			  (poly_list, mono_list)
			  | collect_types(poly_list, mono_list, CFRAME _ :: frames) =
			    collect_types(poly_list, mono_list, frames)
			  | collect_types(poly_list, mono_list,
					  MLFRAME(_, _, _, NOFRAMEINFO) :: frames) =
			    collect_types(poly_list, mono_list, frames)
			  | collect_types(poly_list, mono_list,
					  MLFRAME(_, _, _,
						  FRAMEINFO(arg_type, _, _,
							    ref inferredType)) ::
					  frames) =
			    collect_types(arg_type :: poly_list,
					  inferredType :: mono_list,
					  frames)
			val (poly_type_list, mono_type_list) =
			  collect_types([arg_type], [inferredType], frames)
			val new_poly_type =
			  type_list_to_rectype poly_type_list
			val new_mono_type = type_list_to_rectype mono_type_list
d1242 3
a1244 6
			(fix_runtime_env_types
			 (new_poly_type, new_mono_type, false)
			 runtime_env)
			(* This shouldn't raise, but just in case it does ... *)
			handle DebuggerUtilities.ApplyRecipe _ =>
			  runtime_env
d1246 3
a1248 28
		in
		  (* This should use the full stack if necessary *)
		  (* And now it does *)
		  MLWorks.Option.SOME (ref (MLWorks.Option.INL
					    (fn () =>
					     DebuggerPrint.print_env
					     ((f, new_runtime_env, inferredType),
					      fn (ty1,value) =>
					      ValuePrinter.stringify_value true (print_options,
										 value,
										 ty1,get_interpreter_information()),
					      options,true,
					      map (fn MLFRAME(frame,_,_,FRAMEINFO(_,_,env,ref ty))=>(frame,env,ty)
					    | MLFRAME (frame,_,_,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)
					    | CFRAME(frame,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE))
					      frames))))
		end
	      else MLWorks.Option.NONE)

	fun make_frame_strings frames =
	  let
	    fun aux (frame::frames,acc) =
	      let
		val details = make_frame_details (frame,frames) true
		val stuff =
		  case frame of
		    CFRAME (_,loc) => {name = "<Cframe>", loc = loc,details = details}
		  | MLFRAME (_,((name,(loc,_)),_),_,_) => {name = name,loc = loc, details = details}
d1250 1
a1250 1
		aux (frames,stuff::acc)
d1252 5
a1256 70
	      | aux (nil,acc) = rev acc
	  in
	    aux (frames,[])
	  end

	fun parameter_details () =
	  case parameter of
	    EXCEPTION exn =>
	      let
		val Options.PRINTOPTIONS{maximum_seq_size,
					 maximum_string_size,
					 maximum_ref_depth,
					 maximum_str_depth,
					 maximum_depth,
					 float_precision,
					 print_fn_details,
					 print_exn_details,
					 show_id_class,
					 show_eq_info
					 } = print_options
		val print_options =
		  Options.PRINTOPTIONS{maximum_seq_size = maximum_seq_size,
				       maximum_string_size = maximum_string_size,
				       maximum_ref_depth = maximum_ref_depth,
				       maximum_str_depth = maximum_str_depth,
				       maximum_depth = maximum_depth,
				       float_precision = float_precision,
				       print_fn_details = print_fn_details,
				       print_exn_details = true,
				       show_id_class = show_id_class,
				       show_eq_info = show_eq_info
				       }
	      in
		implode ["Exception ",
			 ValuePrinter.stringify_value false (print_options,
							     cast exn,
							     Datatypes.CONSTYPE([],Types.exn_tyname),
							     get_interpreter_information()),
			 " raised"]
	      end
	  | SIGNAL s => "Unix signal " ^ MLWorks.Integer.makestring s
	  | FATAL_SIGNAL s =>
	      "Fatal Unix signal " ^ MLWorks.Integer.makestring s
	  | BREAK s => s
	  | STACK_OVERFLOW => "Break on stack overflow"

	fun outfun s = output(std_out,s)
	fun outline s = outfun (s ^ "\n")

	fun output_frame_details frame =
	  outline (#1 (make_frame_details (frame,nil) false))
	fun output_full_frame_details frame =
	  outline (#2 (make_frame_details (frame,nil) false))
	fun prompt s = (outfun s; MLWorks.IO.flush_out std_out)

	fun do_continue() =
	  (case continue_continuation of
	     NOT_POSSIBLE => outline "Cannot Continue"
	   | POSSIBLE(_,NORMAL_RETURN) => ()
	   | POSSIBLE(_,DO_RAISE exn) => raise exn
	   | POSSIBLE (_,FUN f) => (f()))

	fun do_quit() =
	  (case quit_continuation of
	     NOT_POSSIBLE => outline "Cannot Quit"
	   | POSSIBLE(_,NORMAL_RETURN) => ()
	   | POSSIBLE(_,DO_RAISE exn) => raise exn
	   | POSSIBLE(_,FUN f) => (f()))

	fun do_input frames =
d1258 2
a1259 1
	    exception Exit
d1261 8
a1268 4
	    fun is_whitespace char =
	      case char of
		" " => true
	      | "\n" => true
d1271 85
a1355 1
	    fun parse_command s =
d1357 11
a1367 12
		fun parse ([],acc) =
		  (case acc of
		     [] => []
		   | _ =>  [implode (rev acc)])
		  | parse (char::rest,acc) =
		    if is_whitespace char
		      then
			(case acc of
			   nil => parse (rest,nil)
			 | _ => implode(rev acc)::parse(rest,nil))
		    else
		      parse (rest,char::acc)
d1369 1
a1369 1
		parse (explode s,[])
d1372 51
a1422 34
	    fun edit_frame (CFRAME _) =
	      outline "Cannot edit source for C frame"
	      | edit_frame (MLFRAME (_,((_,(loc,_)),_),_,_)) =
		(ShellUtils.edit_source (loc, preferences); ())
		handle ShellUtils.EditFailed s => outline ("Edit failed: " ^ s)

	    fun display_simple_help_info () =
	      outline "Enter ? or help for help"

	    fun display_help_info () =
	      Lists.iterate
	      outline
	      (["Commands:",
		" <                - go to the earliest frame in the stack",
		" >                - go to the latest frame in the stack",
		" i                - next frame INto the stack or next later frame (callee)",
		" i <n>            - next n frames INto the stack",
		" o                - next frame OUT of the stack or next earlier frame (caller)",
		" o <n>            - next n frames OUT of the stack",
		" b                - do a backtrace of the stack",
		" f                - show full frame details",
		" e                - edit definition",
		" h <name>         - hide frame type",
		" r <name>         - reveal frame type",
		" p                - print values of local and closure variables",
		" c                - continue interrupted computation",
		" s                - step through computation",
		" s <n>            - step through computation to nth function call",
		" trace <name[<file>:<loc>]> - set trace on function entry at <name> and optional <file>,<loc>",
		" breakpoint <name[<file>:<loc>]> - set breakpoint on function entry at <name> and optional <file>,<loc>",
		" untrace <name[<file>:<loc>]> - unset trace on function entry at <name> and optional <file>,<loc>",
		" unbreakpoint <name[<file>:<loc>]> - unset breakpoint on function entry at <name> and optional <file>,<loc>",
		" help             - display this help info",
		" ?                - display this help info"] @@
d1424 11
a1434 14
		 POSSIBLE(st,_) => [" c                - " ^ st]
	       | _ => []) @@
		 (case quit_continuation of
		    POSSIBLE(st,_) => [" q                - " ^ st]
		  | _ => []))

	    fun hidden_frame (CFRAME _) = Lists.member ("<Cframe>",!suppressed_frames)
	      | hidden_frame (MLFRAME (_,((name,_),_),_,_)) =
		Lists.member (name,!suppressed_frames) orelse DebuggerUtilities.is_suppressed_frame_name name

	    fun hide_frame_type name =
	      if (Lists.member (name,!suppressed_frames))
		then ()
	      else suppressed_frames := name :: !suppressed_frames
d1436 1
a1436 1
	    fun reveal_frame_type name =
d1438 1
a1438 10
		fun delete_item (i,[],acc) = []
		  | delete_item (i,i'::l,acc) =
		    if i = i'
		      then (rev acc) @@ l
		    else delete_item (i,l,i'::acc)
	      in
		if Lists.member (name,!suppressed_frames)
		  then suppressed_frames := delete_item (name,!suppressed_frames,[])
		else outline ("Frame type \"" ^ name ^ "\" not currently hidden")
	      end
d1440 5
a1444 41
	    exception Search
	    fun search (_,[]) = raise Search
	      | search (a,l as (next :: rest)) =
		if hidden_frame next
		  then search (next::a,rest)
		else (a,l)

	    fun goto_top l =
	      search ([],l) handle Search => ([],l)

	    fun get_next_frame (above, below as (this :: rest)) =
	      (search (this::above,rest)
	       handle Search => (outline "No calling frame"; (above,below)))
	      | get_next_frame x = (outline "No calling frame"; x)

	    fun get_next_frames (above, below) 0 = (above, below)
	      | get_next_frames (above, below as (this :: rest)) n =
		(get_next_frames (search (this::above,rest)) (n-1)
		 handle Search => (outline "No calling frame"; (above,below)))
	      | get_next_frames x _ = (outline "No calling frame"; x)

	    fun get_previous_frame (above,below) =
	      (case search (below,above) of
		 (l1,this :: l2) => (l2,this ::l1)
	       | _ => (outline "No called frame"; (above,below)))
		 handle Search => (outline "No called frame"; (above,below))

	    fun get_previous_frames (above,below) 0 = (above,below)
	      | get_previous_frames (above,below) n =
                (case search (below,above) of
                   (l1,this :: l2) =>
                     get_previous_frames (l2,this ::l1) (n-1)
                 | _ => (outline "No called frame"; (above,below)))
		   handle Search => (outline "No called frame"; (above,below))

	    fun goto_bottom (above,below) =
	      let val distance = Lists.length below - 2
		val distance' = if distance < 0 then 0 else distance
	      in
		get_next_frames (above, below) distance'
	      end
d1446 17
a1462 24
	    fun string_to_int str =
	      let
		exception Finished of int
		fun factor 0 = 1
		  | factor n = 10*factor (n-1)
		fun string_to_int nil (n,_) = n
		  | string_to_int (m::ms) (n,power) =
		    string_to_int ms
		    ((case m of
			"1" => 1*(factor power)+n
		      | "2" => 2*(factor power)+n
		      | "3" => 3*(factor power)+n
		      | "4" => 4*(factor power)+n
		      | "5" => 5*(factor power)+n
		      | "6" => 6*(factor power)+n
		      | "7" => 7*(factor power)+n
		      | "8" => 8*(factor power)+n
		      | "9" => 9*(factor power)+n
		      | "0" => n
		      | _ => raise Finished(n)),power+1)
	      in
		string_to_int (rev(explode str)) (0,0)
		handle Finished(n) => n
	      end
d1464 49
a1512 4
	    fun loop (above, below as (this::rest)) =
	      let
		val _ = if Trace.step_state () then () else output_frame_details this
		val _ = prompt "Debugger> "
d1514 1
a1514 1
		val command_and_args =
d1516 52
a1567 4
		    val _ =
		      if end_of_stream std_in then
			(do_quit(); raise Exit)
		      else ()
d1569 20
a1588 1
		    val line = MLWorks.IO.input_line std_in
d1590 2
a1591 1
		    parse_command line
d1593 2
a1594 1
		fun frame_fnname () =
d1596 32
a1627 7
		    val (name,loc,fnname) =
		      case this of
			CFRAME (_,name) => (name,"","")
		      | MLFRAME (_,((name,(loc,fnname)),_),_,_) => (name,loc,fnname)
		    fun to_rbrace nil = Crash.impossible "rbrace:frame_fnname:loop:ml_debugger"
		      | to_rbrace ("}"::rest) = rest
		      | to_rbrace (_::rest) = to_rbrace rest
d1629 106
a1734 3
		    case explode fnname of
		      "{"::namechars => (implode o rev o to_rbrace o rev) namechars
		    | _ => name ^ "[" ^ loc ^ "]"
d1736 1
d1738 3
a1740 105
		case command_and_args of
		  "<"::_ => loop (goto_top ((rev above) @@ below))
		| ">"::_ => loop (goto_bottom (above,below))
		| "f"::_ =>
		    (output_full_frame_details this;
		     loop (above,below))
		| "e"::_ =>
		    (edit_frame this;
		     loop (above,below))
		| ["i"] => loop (get_previous_frame (above,below))
		| "i"::arg::_ =>
		    loop (case string_to_int arg of
			    0 => get_previous_frame (above,below)
			  | n => get_previous_frames (above,below) n)
		| ["o"] => loop (get_next_frame (above,below))
		| "o"::arg::_ =>
		    loop (case string_to_int arg of
			    0 => get_next_frame (above,below)
			  | n => get_next_frames (above,below) n)
		| ["b"] =>
		    (output (std_out, "(Current frame)\n");
		     Lists.iterate
		     (fn f => if hidden_frame f then () else output_frame_details f)
		     below;
		     output (std_out, "(Outermost frame)\n");
		     loop (above,below))
		| ("b"::arg::_) =>
		    (output (std_out, "(Current frame)\n");
		     Lists.iterate
		     (fn f => if hidden_frame f then () else output_frame_details f)
		     (firstn (below,string_to_int arg));
		     output (std_out, "(Outermost frame)\n");
		     loop (above,below))
		| "c"::_ =>
		    (Trace.set_stepping false;
		     do_continue();
		     raise Exit;
                       loop (above,below))
		| ["h"] => (outline ("\"h\" needs a frame type name");loop(above,below))
		| "h"::name::_ => (hide_frame_type name;loop (above,below))
		| "q"::_ =>
		    (do_quit ();
		     raise Exit;
                       loop (above,below))
		| ["r"] => (outline ("\"r\" needs a frame type name");loop(above,below))
		| "r"::name::_ => (reveal_frame_type name;loop (above,below))
		| ""::_ => loop (above,below)
		| "?"::_ =>
		    (display_help_info();
		     loop (above,below))
		| "help"::_ =>
		    (display_help_info();
		     loop (above,below))
		| "trace" :: args => (Lists.iterate Trace.trace args;
				      loop (above,below))
		| "breakpoint" :: args => (Lists.iterate Trace.break args;
					   loop (above,below))
		| "untrace" :: args => (Lists.iterate Trace.untrace args;
					loop (above,below))
		| "unbreakpoint" :: args => (Lists.iterate Trace.unbreak args;
					     loop (above,below))
		| ["s"] => (Trace.set_stepping true;
			    do_continue();
			    raise Exit;
                              loop (above,below))
		| "s" :: arg :: _ => (Trace.set_stepping true;
				      Trace.set_step_count (string_to_int arg);
				      do_continue();
				      raise Exit;
					loop (above,below))
		| ["t"] => (Trace.set_trace_all true;
			    do_continue();
			    raise Exit;
                              loop (above,below))
		| "p"::_ =>
		    (case this of
		       MLFRAME(frame,_,_,frameinfo) =>
			 (case frameinfo of
			    NOFRAMEINFO => ()
			  | FRAMEINFO(_,_,runtime_env,ref ty) =>
			      outfun
			      (#1(DebuggerPrint.print_env
				  ((StackInterface.variable_debug_frame frame,runtime_env,ty),
				   (fn (ty,value) =>
				    ValuePrinter.stringify_value true
				    (print_options,
				     value,
				     ty,get_interpreter_information())),
				   options,false,
				   map
				   (fn MLFRAME(frame,_,_,FRAMEINFO(_,_,env,ref ty)) => (frame,env,ty)
				 | MLFRAME(frame,_,_,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)
				 | CFRAME(frame,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE))
				   below))))
		     | CFRAME(_) => ();
			 loop (above,below))
		| "show_debug"::_ =>
		    (let
		       val debug_info = get_interpreter_information ()
		     in
		       Lists.iterate (fn s => output(std_out,s^"\n")) (Debugger_Types.print_information (debug_info,true))
		     end;
		     loop (above,below))
		| _ => (display_simple_help_info();
			loop (above,below))
a1741 1
	      | loop _ = output (std_out,"No frames to look at in debugger!\n")
d1743 23
d1767 4
a1770 31
	    if Trace.step_state () then () else outline "Current (innermost) stack frame:";
              loop (goto_top frames)
              handle Exit => ()
	  end

	fun make_entry_info_line () =
	  (case quit_continuation of
	     POSSIBLE (s,_) => "q : " ^ s ^ ", "
	   | _ => "") ^
	     (case continue_continuation of
		POSSIBLE (s,_) => "c : " ^ s ^ ", "
	      | _ => "") ^
		" ? : more help"

	fun tty_debugger basic_frames =
	  if not (!use_debugger) then
	    (outline (parameter_details ());
	     do_quit ())
	  else if stack_empty basic_frames then
	    outline (parameter_details () ^ " at top level")
	       else if Trace.step_state () then
		 ()
		    else
		      (outline (parameter_details ());
		       outline ("Entering debugger, commands: " ^ make_entry_info_line ());
		       do_input (make_frames (basic_frames,parameter,options)))
      in
	let
	  val top_frame = MLWorks.Internal.Value.Frame.current ()
	  val basic_frames =
	    StackInterface.get_basic_frames (top_frame,base_frame)
d1772 17
a1788 16
	  (* The identifier debugger_call is never used; this is deliberate!
	   See below.  *)
	  val debugger_call =
	    case type_of_debugger of
	      TERMINAL =>
		tty_debugger basic_frames
	    | WINDOWING (make_window, send_message, tty_ok) =>
		if tty_ok andalso not (!window_debugger) then
		  tty_debugger basic_frames
		else if not (!use_debugger) then
		  (send_message (parameter_details () ^ "\n");
		   do_quit ())
	        else if stack_empty basic_frames then
		  send_message (parameter_details () ^ " at top level\n")
	        else
		  let
d1798 15
a1812 14
		  in
		    make_window
		       {parameter_details = parameter_details (),
			frames = frame_strings,
                        quit_fn =
			make_continuation_function quit_continuation,
                        continue_fn =
			make_continuation_function continue_continuation};
		       ()
		  end
	in
	  (* Ensure call to tty_debugger not tail, else frame is invalid *)
	  ()
	end
d1814 1
@


1.123
log
@Fix frames seen by the debugger when tracing.
@
text
@d4 3
a428 1
(*  structure GetTypeInformation : GETTYPEINFORMATION *)
d430 1
a430 1
  structure DebuggerUtilities : DEBUGGER_UTILITIES       
d439 1
a439 2
  sharing (* GetTypeInformation.Debugger_Types = *)
    DebuggerUtilities.Debugger_Types = Encapsulate.Debugger_Types
a445 3
(*
  sharing type GetTypeInformation.Options = DebuggerPrint.Options.options
*)
a453 3
(*
  sharing type GetTypeInformation.ParserBasis  = Incremental.InterMake.Compiler.ParserBasis
*)
d458 1
a458 1
     struct
d460 142
a601 142
       structure Incremental = Incremental
       structure Datatypes = Types.Datatypes
       structure NewMap = Datatypes.NewMap
       structure Debugger_Types = DebuggerUtilities.Debugger_Types
       structure InterMake = Incremental.InterMake
       structure Info = InterMake.Compiler.Info
       structure ValuePrinter = ValuePrinter
       structure Options = DebuggerPrint.Options
       structure RuntimeEnv = DebuggerPrint.RuntimeEnv

       type preferences = Preferences.preferences

       val do_debug = false
       fun debug_print s = output(MLWorks.IO.terminal_out,"  # " ^ s ^ "\n")

       (* For multiple line output *)
       fun debugl f = 
         if do_debug then 
           Lists.iterate debug_print (f ())
         else ()

       fun debug f = if do_debug then debug_print (f ()) else ()
       fun ddebug f = debug_print (f ())

       fun assoc (a,[]) = MLWorks.Option.NONE
         | assoc (a,(a',b)::rest) =
           if a = a' then MLWorks.Option.SOME b
           else assoc (a,rest)

       fun firstn (l,n) =
         if n < 0 then []
         else
           let
             fun aux (_,0,acc) = rev acc
               | aux ([],n,_) = l
               | aux (a::b,n,acc) = aux (b,n-1,a::acc)
           in
             aux (l,n,[])
           end

       val cast : 'a -> 'b = MLWorks.Internal.Value.cast

       val empty_map = NewMap.empty' (op =)

       (* Some utilities *)

       (* This works on exploded strings *)
       fun substring (str1,str2) =
         let
           fun tl [] = []
             | tl (a::b) = b
           fun substring ([],_,_) = true
             | substring (_,[],_) = false
             | substring (x::xs,y::ys,yys) =
               if x = y 
                 then substring (xs,ys,yys)
               else substring(str1,yys,tl yys)
         in
           substring (str1,str2,tl str2)
         end

       (* This should use some Location function *)
       fun location_source_file locdata =
         let
           fun aux1(":"::l,acc) = implode(rev acc)
             | aux1(c::l,acc) = aux1(l,c::acc)
             | aux1([],acc) = implode(rev acc)
         in
           aux1(explode locdata,[])
         end

       fun get_data_from_frame frame =
         let
           fun get_name_and_location code_name =
             let
               fun duff () = debug (fn _ => "Odd codename:"^code_name^":")
               fun aux1("["::l,acc) = (acc,l)
                 | aux1(c::l,acc) = aux1(l,c::acc)
                 | aux1([],acc) = (duff();(acc,[]))
               fun aux2(["]"],acc) = (acc,nil)
                 | aux2("]"::l,acc) = (duff();(acc,l))
                 | aux2(c::l,acc) = aux2(l,c::acc)
                 | aux2([],acc) = (duff();(acc,nil))
               val (namechars,rest) = aux1(explode code_name,[])
               val (locchars,fnname) = aux2 (rest,[])
             in
               (implode(rev namechars),(implode(rev locchars),implode fnname))
             end
           val name_string = StackInterface.frame_name frame
         in
           (get_name_and_location name_string,name_string)
         end

       (* DIAGNOSTIC FUNCTIONS *)

       fun get_arg_type(Datatypes.METATYVAR(ref(_,object,_),_,_)) = get_arg_type object
         | get_arg_type(Datatypes.FUNTYPE (arg,_)) = arg
         | get_arg_type x = Datatypes.NULLTYPE

       fun get_res_type(Datatypes.METATYVAR(ref(_,object,_),_,_)) = get_res_type object
         | get_res_type(Datatypes.FUNTYPE (_,res)) = res
         | get_res_type x = Datatypes.NULLTYPE

       exception FailedToGetTypeInfo 

       (* Cache away any file information that is recorded *)
       exception CacheFail
       val size_of_data_cache = ref(7)
       val data_cache = ref([] : (string * Debugger_Types.information) list)
       fun cache_lookup file =
         let
           fun cache_lookup(x,[]) = 
             (debug (fn _ => file ^ " not found in cache") ;
              raise CacheFail)
             | cache_lookup(x,(elem as (h,t))::rest) =
               if x=h
                 then (debug (fn _ => file ^ " found in cache");
                       (t,rest))
               else
                 let
                   val (a,b) = cache_lookup(x,rest)
                 in
                   (a,elem::b)
                 end
           val (result,rest) = cache_lookup(file,!data_cache)
           val _ = data_cache := (file,result) :: rest
         in
           result
         end

       fun add_to_cache x =
           data_cache := x :: !data_cache

       fun initialise_cache () = data_cache := nil

       fun get_type_information (options,debug_info,((function_name,loc),name_string)) =
         let
           val source_file = location_source_file loc
         in
           case Debugger_Types.lookup_debug_info (debug_info,name_string) of
             MLWorks.Option.SOME funinfo =>
               (funinfo,source_file)
d607 1
a607 1
                  val file_debug_info = 
d614 3
a616 3
                           val (_,information) = 
                             Encapsulate.decode_type_basis
                             (#type_env (Encapsulate.input_all (file ^ ".mo")),file,empty_map,true)
d620 9
a628 9
                          handle Encapsulate.BadInput msg =>
                            (debug (fn _ => 
                                    "Decapsulation failed for function " ^ 
                                    function_name ^ ": " ^ file ^ ":" ^ msg);
                            let
                              val information = Debugger_Types.empty_information
                            in
                              (add_to_cache (file,information); information)
                            end)))
d635 573
a1207 306
         end
       
       local
	 (* The name "part_of_a_frame" is not terribly helpful, but it's
	    still easier to read the debugger_window type now that I've
	    separated out it's components.  This type probably corresponds
	    to the info about a local variable, but I wouldn't bet on it. *)
	 type part_of_a_frame = 
	   (string
	    * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value * string)
	   ) list
 
	 type frame_details =
	   string
	   * string
	   * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value * string)
	   * (unit -> string * part_of_a_frame,
              string * part_of_a_frame)
	     MLWorks.Option.union ref MLWorks.Option.option
 
         type frame = {name : string, loc : string, details: frame_details}
       in
         type debugger_window = 
           {parameter_details: string,
	    frames: frame list,
	    quit_fn: (unit -> unit) MLWorks.Option.option,
	    continue_fn: (unit -> unit) MLWorks.Option.option}
	   -> unit
       end

       datatype TypeOfDebugger = 
           WINDOWING of debugger_window * (string -> unit) * bool
         | TERMINAL

       datatype parameter =
         SIGNAL of int |
	 FATAL_SIGNAL of int |
         EXCEPTION of exn |
         BREAK of string |
         STACK_OVERFLOW

       datatype Continuation_action =
         NORMAL_RETURN | 
         DO_RAISE of exn |
         FUN of (unit -> unit)

       datatype Continuation =
         POSSIBLE of string * Continuation_action |
         NOT_POSSIBLE

       datatype FrameInfo =
         FRAMEINFO of
         Datatypes.Type * Debugger_Types.Backend_Annotation 
         * RuntimeEnv.RuntimeEnv * Datatypes.Type ref |
         NOFRAMEINFO

       datatype FrameSpec = 
         MLFRAME of
         MLWorks.Internal.Value.Frame.frame *
         ((string * (string * string)) * string) *
         MLWorks.Internal.Value.T *
         FrameInfo |
         CFRAME of (MLWorks.Internal.Value.Frame.frame * string)

       fun make_continuation_function (POSSIBLE (_,NORMAL_RETURN)) =
	 MLWorks.Option.SOME (fn _ => ())
       |   make_continuation_function (POSSIBLE (_,DO_RAISE exn)) =
	 MLWorks.Option.SOME (fn _ => raise exn)
       |   make_continuation_function (POSSIBLE (_,FUN f)) =
	 MLWorks.Option.SOME f
       |    make_continuation_function NOT_POSSIBLE =
	 MLWorks.Option.NONE

       val suppressed_frames = ref ["<Cframe>" (*, "<Setup>" *)] : string list ref

           (* Note that offset is a _word_ count *)

       (* need to ensure that this is the latest stuff *)

       fun get_interpreter_information () = InterMake.current_debug_information ()

       (* Incremental.debug_info context *)

       fun get_frame_details options (frame,offset,is_ml) =
         if is_ml
           then
             let
               val debug_info as ((name,(loc,_)),name_str) = get_data_from_frame frame
               val arg = StackInterface.frame_arg frame
               val info =
                 let
                   val (Debugger_Types.FUNINFO {ty,is_leaf,annotations,runtime_env,...},
                        source_file) =
                     get_type_information (options,
                                           get_interpreter_information(),
                                           ((name,loc),name_str))
                   val arg_type = get_arg_type ty
                   val _ = debug (fn _ => "Getting info for " ^ name ^ ", offset: " ^ MLWorks.Integer.makestring (4 * offset))
                   val current_annotation =
                     case assoc (4 * offset,annotations) of
                       MLWorks.Option.SOME a => a
                     | _ => 
                         let
                           val string = 
                             ("No annotation for offset " ^ 
                              MLWorks.Integer.makestring (4 * offset) ^ " for " ^ name)
                         in
                           Debugger_Types.ERROR string;
                           Debugger_Types.NOP
                         end
                   val _ = debug (fn _ => "Annotation: " ^ Debugger_Types.print_backend_annotation current_annotation)
                 in
                   FRAMEINFO (arg_type,current_annotation,runtime_env,
                              ref Datatypes.NULLTYPE)
                 end
               handle FailedToGetTypeInfo => NOFRAMEINFO
             in
               MLFRAME(frame,debug_info,arg,info)
             end
         else
	   let
	     val closure_bits = Bits.lshift(MLWorks.Internal.Value.cast (StackInterface.frame_closure frame),2)
	     fun clos_type n =
	       if n = Tags.STACK_START then "start"
	       else if n = Tags.STACK_START_INTERCEPT then "start intercept"
	       else if n = Tags.STACK_END then "end"
	       else if n = Tags.STACK_EXTENSION then "extension"
	       else if n = Tags.STACK_LEAF_RAISE then "leaf raise"
	       else if n = Tags.STACK_RAISE then "raise"
	       else if n = Tags.STACK_RESUME then "resume"
	       else if n = Tags.STACK_PROFILE then "profile"
	       else if n = Tags.STACK_EVENT then "event"
	       else if n = Tags.STACK_C_RAISE then "c raise"
	       else if n = Tags.STACK_C_CALL then "c call"
	       else if n = Tags.STACK_INTERCEPT then "intercept"
	       else if n = Tags.STACK_SPACE_PROFILE then "space profile"
	       else "unknown closure "^(MLWorks.Integer.makestring n)
	   in
	     CFRAME(frame, clos_type (closure_bits))
	   end

       fun make_frames (basic_frames,parameter,options) =
         let
           exception ApplyRecipe 
           fun apply_recipe (annotation,ty,name) =
             let
               val result = 
                 DebuggerUtilities.apply_recipe(annotation,ty)
                 handle DebuggerUtilities.ApplyRecipe problem =>
                   (debugl (fn _ => 
                            ["Recipe problem " ^ problem ^ " for " ^ name,
                             "Annotation: " ^ Debugger_Types.print_backend_annotation annotation,
                             "Arg : " ^ Types.debug_print_type ty]);
                   raise ApplyRecipe)
             in
               if do_debug
                 then
                   debugl (fn _ => ["Name: " ^ name,
                                    "Annotation: " ^ Debugger_Types.print_backend_annotation annotation,
                                    "Arg : " ^ Types.debug_print_type ty,
                                    "Res : " ^ Types.debug_print_type result])
               else ();
                 result
             end

           datatype TypeThunk =
             NORECIPE |
             RECIPE of (Debugger_Types.Backend_Annotation * Datatypes.Type)

           fun infer_types (recipe,[]) = ()
             | infer_types (recipe,frame::rest) =
               (case frame of
                     CFRAME (frame,_) => 
                       if StackInterface.is_stack_extension_frame frame
                         then infer_types (recipe,rest)
                       else infer_types (NORECIPE,rest)
                   | MLFRAME (_,_,_,NOFRAMEINFO) => infer_types (NORECIPE,rest)
                   | MLFRAME (_,((name,_),_),_,FRAMEINFO(arg_type,annotation,_,tyref)) =>
                       let
                         val _ = debug (fn _ => "Doing " ^ name)
                         val itype =
                           if not (DebuggerUtilities.is_type_polymorphic arg_type)
                             then (debug (fn _ => "Not polymorphic"); arg_type)
                           else
                             case recipe of
                               NORECIPE => (debug (fn _ => "No recipe"); arg_type)
                             | RECIPE (r,ty) => 
                                 let
                                   val reconstructed_type = apply_recipe (r,ty,name)
                                 in 
                                   Types.combine_types (reconstructed_type,arg_type)
                                   handle Types.CombineTypes =>
                                     (debug (fn _ =>
                                             implode ["Combine types fails for: ",
                                                      name, "\n argtype: ",
                                                      Types.debug_print_type arg_type,
                                                      "\n reconstructed type: ",
                                                      Types.debug_print_type reconstructed_type]);
                                     arg_type)
                                 end
                                 handle ApplyRecipe => arg_type
                       in
                         tyref := itype;
                         infer_types (RECIPE (annotation,itype),rest)
                       end)

           val frames = map (get_frame_details options) basic_frames
           val _ = infer_types (NORECIPE,frames)
         in
           case parameter of
             EXCEPTION _ =>
               ((* Omit the first frame.  This should usually be a top level handler *)
                case rev frames of
                  (_::rest) => rest
                | rest => rest)
           (* Otherwise, keep all of the frames -- the top ones will usually be C frames and suppressed *)
           | _ => rev frames
         end

       (* If the frame has a well defined type, use that to print the *)
       (* argument.  Otherwise, scan down the stack collecting recipes until *)
       (* either we run out of stack, or recipes or we find a fully *)
       (* instantiated type *)

       fun ml_debugger 
         (type_of_debugger, options, preferences)
         (base_frame, parameter, quit_continuation, continue_continuation)
         =
         let
	   val Options.OPTIONS {print_options, ...} = options
           val Preferences.PREFERENCES {environment_options,...} = preferences

           val Preferences.ENVIRONMENT_OPTIONS
	         {use_debugger, window_debugger, ...} =
	     environment_options

	   fun stack_empty basic_frames = 
             case parameter of
               EXCEPTION _ => Lists.length basic_frames <= 2
		 (* one for the money, two for the show *)
             | _ => false

           fun make_frame_details (CFRAME (f,s),_) _ =
             ("<Cframe> "^s,"",
              (Datatypes.NULLTYPE,cast 0,""), MLWorks.Option.NONE)
             | make_frame_details (MLFRAME (f,((name,(loc,_)),st),arg,NOFRAMEINFO),_) _ =
               (implode[name,"<??>"],
                implode["[",loc,"]"],
                (Datatypes.NULLTYPE,cast 0,""),
                MLWorks.Option.NONE)
             | make_frame_details (MLFRAME (f,
                                            ((name,(loc,_)),st),
                                            arg,
                                            FRAMEINFO(arg_type,annotation,runtime_env,
                                                      ref inferredType)),frames) windowing =
               (implode[name," ",
                        if windowing then ""
                        else
                          ValuePrinter.stringify_value false (print_options,
                                                              arg,
                                                              inferredType,
                                                              get_interpreter_information())],
               implode[name,"[",loc,"]", ":",Types.print_type print_options inferredType],
               if windowing then 
                 (inferredType, arg, 
                  ValuePrinter.stringify_value false (print_options,
                                                      arg,
                                                      inferredType,
                                                      get_interpreter_information()))
               else (Datatypes.NULLTYPE, cast 0,""),
                 if windowing then 
                   MLWorks.Option.SOME (ref (MLWorks.Option.INL 
                                             (fn () =>
                                              DebuggerPrint.print_env
                                              ((f,runtime_env,inferredType),
                                               fn (ty1,value) => 
                                               ValuePrinter.stringify_value true (print_options,
                                                                                  value,
                                                                                  ty1,get_interpreter_information()),
                                               options,true,
                                               map (fn MLFRAME(frame,_,_,FRAMEINFO(_,_,env,ref ty))=>(frame,env,ty)
                                             | MLFRAME (frame,_,_,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)
                                             | CFRAME(frame,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)) 
                                               frames))))
                 else MLWorks.Option.NONE)

          fun make_frame_strings frames =
            let 
              fun aux (frame::frames,acc) =
                let
                  val details = make_frame_details (frame,frames) true
                  val stuff =
                    case frame of
                      CFRAME (_,loc) => {name = "<Cframe>", loc = loc,details = details}
                    | MLFRAME (_,((name,(loc,_)),_),_,_) => {name = name,loc = loc, details = details}
                in
                  aux (frames,stuff::acc)
                end
                | aux (nil,acc) = rev acc
            in
              aux (frames,[])
            end
              
          fun parameter_details () =
            case parameter of
              EXCEPTION exn =>
d1209 35
a1243 24
		  val Options.PRINTOPTIONS{maximum_seq_size,
					   maximum_string_size,
					   maximum_ref_depth,
					   maximum_str_depth,
					   maximum_depth,
					   float_precision,
					   print_fn_details,
					   print_exn_details,
					   show_id_class,
					   show_eq_info
					   } = print_options
		  val print_options =
		    Options.PRINTOPTIONS{maximum_seq_size = maximum_seq_size,
					 maximum_string_size = maximum_string_size,
					 maximum_ref_depth = maximum_ref_depth,
					 maximum_str_depth = maximum_str_depth,
					 maximum_depth = maximum_depth,
					 float_precision = float_precision,
					 print_fn_details = print_fn_details,
					 print_exn_details = true,
					 show_id_class = show_id_class,
					 show_eq_info = show_eq_info
					 }

d1245 15
a1259 6
		  implode ["Exception ",
			   ValuePrinter.stringify_value false (print_options,
							       cast exn,
							       Datatypes.CONSTYPE([],Types.exn_tyname),
							       get_interpreter_information()),
			   " raised"]
d1261 1
a1261 38
            | SIGNAL s => "Unix signal " ^ MLWorks.Integer.makestring s
	    | FATAL_SIGNAL s =>
		"Fatal Unix signal " ^ MLWorks.Integer.makestring s
            | BREAK s => s
            | STACK_OVERFLOW => "Break on stack overflow"

          fun outfun s = output(std_out,s)
          fun outline s = outfun (s ^ "\n")

          fun output_frame_details frame =
            outline (#1 (make_frame_details (frame,nil) false))
          fun output_full_frame_details frame =
            outline (#2 (make_frame_details (frame,nil) false))
          fun prompt s = (outfun s; MLWorks.IO.flush_out std_out)

          fun do_continue() =
            (case continue_continuation of
               NOT_POSSIBLE => outline "Cannot Continue"
             | POSSIBLE(_,NORMAL_RETURN) => ()
             | POSSIBLE(_,DO_RAISE exn) => raise exn
             | POSSIBLE (_,FUN f) => (f()))

          fun do_quit() =
            (case quit_continuation of
               NOT_POSSIBLE => outline "Cannot Quit"
             | POSSIBLE(_,NORMAL_RETURN) => ()
             | POSSIBLE(_,DO_RAISE exn) => raise exn
             | POSSIBLE(_,FUN f) => (f()))

          fun do_input frames =
            let 
              exception Exit

              fun is_whitespace char =
                case char of
                  " " => true
                | "\n" => true
                | _ => false
d1263 198
a1460 67
              fun parse_command s = 
                let
                  fun parse ([],acc) = 
                    (case acc of 
                       [] => [] 
                     | _ =>  [implode (rev acc)])
                    | parse (char::rest,acc) = 
                      if is_whitespace char
                        then
                          (case acc of
                             nil => parse (rest,nil)
                           | _ => implode(rev acc)::parse(rest,nil))
                      else
                        parse (rest,char::acc)
                in
                  parse (explode s,[])
                end
                  
              fun edit_frame (CFRAME _) =
                outline "Cannot edit source for C frame"
                | edit_frame (MLFRAME (_,((_,(loc,_)),_),_,_)) =
                  (ShellUtils.edit_source (loc, preferences); ())
                  handle ShellUtils.EditFailed s => outline ("Edit failed: " ^ s)
                    
              fun display_simple_help_info () =
                outline "Enter ? or help for help"

              fun display_help_info () =
                Lists.iterate
                outline
                (["Commands:",
                  " <                - go to the earliest frame in the stack",
                  " >                - go to the latest frame in the stack",
                  " i                - next frame INto the stack or next later frame (callee)",
                  " i <n>            - next n frames INto the stack",
                  " o                - next frame OUT of the stack or next earlier frame (caller)",
                  " o <n>            - next n frames OUT of the stack",
                  " b                - do a backtrace of the stack",
                  " f                - show full frame details",
                  " e                - edit definition",
                  " h <name>         - hide frame type",
                  " r <name>         - reveal frame type",
                  " p                - print values of local and closure variables",
                  " c                - continue interrupted computation",
                  " s                - step through computation",
                  " s <n>            - step through computation to nth function call",
                  " trace <name[<file>:<loc>]> - set trace on function entry at <name> and optional <file>,<loc>",
                  " breakpoint <name[<file>:<loc>]> - set breakpoint on function entry at <name> and optional <file>,<loc>",
                  " untrace <name[<file>:<loc>]> - unset trace on function entry at <name> and optional <file>,<loc>",
                  " unbreakpoint <name[<file>:<loc>]> - unset breakpoint on function entry at <name> and optional <file>,<loc>",
                  " help             - display this help info",
                  " ?                - display this help info"] @@
                (case continue_continuation of
                   POSSIBLE(st,_) => [" c                - " ^ st]
                 | _ => []) @@
                   (case quit_continuation of
                      POSSIBLE(st,_) => [" q                - " ^ st]
                    | _ => []))

              fun hidden_frame (CFRAME _) = Lists.member ("<Cframe>",!suppressed_frames)
                | hidden_frame (MLFRAME (_,((name,_),_),_,_)) =
                  Lists.member (name,!suppressed_frames) orelse DebuggerUtilities.is_suppressed_frame_name name

              fun hide_frame_type name =
                if (Lists.member (name,!suppressed_frames))
                  then ()
                else suppressed_frames := name :: !suppressed_frames
d1462 2
a1463 35
              fun reveal_frame_type name =
                let
                  fun delete_item (i,[],acc) = []
                    | delete_item (i,i'::l,acc) = 
                      if i = i'
                        then (rev acc) @@ l
                      else delete_item (i,l,i'::acc)
                in
                  if Lists.member (name,!suppressed_frames)
                    then suppressed_frames := delete_item (name,!suppressed_frames,[])
                  else outline ("Frame type \"" ^ name ^ "\" not currently hidden")
                end

              exception Search
              fun search (_,[]) = raise Search
                | search (a,l as (next :: rest)) =
                  if hidden_frame next
                    then search (next::a,rest)
                  else (a,l)
                    
              fun goto_top l =
                search ([],l) handle Search => ([],l)
                  
              fun get_next_frame (above, below as (this :: rest)) =
                (search (this::above,rest)
                 handle Search => (outline "No calling frame"; (above,below)))
                | get_next_frame x = (outline "No calling frame"; x)

              fun get_next_frames (above, below) 0 = (above, below)
                | get_next_frames (above, below as (this :: rest)) n =
                  (get_next_frames (search (this::above,rest)) (n-1)
                   handle Search => (outline "No calling frame"; (above,below)))
                | get_next_frames x _ = (outline "No calling frame"; x)
                  
              fun get_previous_frame (above,below) =
d1465 1
a1465 8
                   (l1,this :: l2) => (l2,this ::l1)
                 | _ => (outline "No called frame"; (above,below)))
                handle Search => (outline "No called frame"; (above,below))
              
              fun get_previous_frames (above,below) 0 = (above,below)
                | get_previous_frames (above,below) n =
                (case search (below,above) of
                   (l1,this :: l2) => 
d1468 1
a1468 33
                handle Search => (outline "No called frame"; (above,below))

              fun goto_bottom (above,below) = 
		let val distance = Lists.length below - 2
		    val distance' = if distance < 0 then 0 else distance
		in
                  get_next_frames (above, below) distance'
		end

              fun string_to_int str = 
                let
                  exception Finished of int
                  fun factor 0 = 1
                    | factor n = 10*factor (n-1)
                  fun string_to_int nil (n,_) = n
                    | string_to_int (m::ms) (n,power) = 
                      string_to_int ms
                      ((case m of
                          "1" => 1*(factor power)+n
                        | "2" => 2*(factor power)+n
                        | "3" => 3*(factor power)+n
                        | "4" => 4*(factor power)+n
                        | "5" => 5*(factor power)+n
                        | "6" => 6*(factor power)+n
                        | "7" => 7*(factor power)+n
                        | "8" => 8*(factor power)+n
                        | "9" => 9*(factor power)+n
                        | "0" => n
                        | _ => raise Finished(n)),power+1)
                in
                  string_to_int (rev(explode str)) (0,0)
                  handle Finished(n) => n
                end
d1470 100
a1569 80
              fun loop (above, below as (this::rest)) =
                let
                  val _ = if Trace.step_state () then () else output_frame_details this
                  val _ = prompt "Debugger> "

                  val command_and_args =
                    let
                      val _ =
			if end_of_stream std_in then
			  (do_quit(); raise Exit)
			else ()

                      val line = MLWorks.IO.input_line std_in
                    in
                      parse_command line
                    end
                  fun frame_fnname () = 
                    let
                      val (name,loc,fnname) =
                        case this of
                          CFRAME (_,name) => (name,"","")
                        | MLFRAME (_,((name,(loc,fnname)),_),_,_) => (name,loc,fnname)
                      fun to_rbrace nil = Crash.impossible "rbrace:frame_fnname:loop:ml_debugger"
                        | to_rbrace ("}"::rest) = rest
                        | to_rbrace (_::rest) = to_rbrace rest
                    in
                      case explode fnname of
                        "{"::namechars => (implode o rev o to_rbrace o rev) namechars
                      | _ => name ^ "[" ^ loc ^ "]"
                    end
                in
                  case command_and_args of
                    "<"::_ => loop (goto_top ((rev above) @@ below))
                  | ">"::_ => loop (goto_bottom (above,below))
                  | "f"::_ =>
                      (output_full_frame_details this;
                       loop (above,below))
                  | "e"::_ =>
                      (edit_frame this;
                       loop (above,below))
                  | ["i"] => loop (get_previous_frame (above,below))
                  | "i"::arg::_ => 
                      loop (case string_to_int arg of 
                              0 => get_previous_frame (above,below)
                            | n => get_previous_frames (above,below) n)
                  | ["o"] => loop (get_next_frame (above,below))
                  | "o"::arg::_ => 
                      loop (case string_to_int arg of 
                              0 => get_next_frame (above,below)
                            | n => get_next_frames (above,below) n)
                  | ["b"] => 
                      (output (std_out, "(Current frame)\n");
                       Lists.iterate
                       (fn f => if hidden_frame f then () else output_frame_details f)
                       below;
		       output (std_out, "(Outermost frame)\n");
                       loop (above,below))
                  | ("b"::arg::_) => 
                      (output (std_out, "(Current frame)\n");
                       Lists.iterate
                       (fn f => if hidden_frame f then () else output_frame_details f)
                       (firstn (below,string_to_int arg));
		       output (std_out, "(Outermost frame)\n");
                       loop (above,below))
                  | "c"::_ => 
                      (Trace.set_stepping false;
                       do_continue();
		       raise Exit;
                       loop (above,below))
                  | ["h"] => (outline ("\"h\" needs a frame type name");loop(above,below))
                  | "h"::name::_ => (hide_frame_type name;loop (above,below))
                  | "q"::_ =>
                      (do_quit ();
		       raise Exit;
                       loop (above,below))
                  | ["r"] => (outline ("\"r\" needs a frame type name");loop(above,below))
                  | "r"::name::_ => (reveal_frame_type name;loop (above,below))
                  | ""::_ => loop (above,below)
                  | "?"::_ =>
                      (display_help_info();
d1571 5
a1575 2
                  | "help"::_ =>
                      (display_help_info();
d1577 20
a1596 11
                  | "trace" :: args => (Lists.iterate Trace.trace args;
                                     loop (above,below))
                  | "breakpoint" :: args => (Lists.iterate Trace.break args;
                                     loop (above,below))
                  | "untrace" :: args => (Lists.iterate Trace.untrace args;
                                      loop (above,below))
                  | "unbreakpoint" :: args => (Lists.iterate Trace.unbreak args;
                                      loop (above,below))
                  | ["s"] => (Trace.set_stepping true;
                              do_continue();
			      raise Exit;
d1598 8
a1605 8
                  | "s" :: arg :: _ => (Trace.set_stepping true;
                                   Trace.set_step_count (string_to_int arg);
                                   do_continue();
				   raise Exit;
                                   loop (above,below))
                  | ["t"] => (Trace.set_trace_all true;
                              do_continue();
			      raise Exit;
d1607 33
a1639 34
                  | "p"::_ => 
                     (case this of 
                        MLFRAME(frame,_,_,frameinfo) =>
                          (case frameinfo of
                             NOFRAMEINFO => ()
                           | FRAMEINFO(_,_,runtime_env,ref ty) => 
                             outfun 
                             (#1(DebuggerPrint.print_env
                                 ((StackInterface.variable_debug_frame frame,runtime_env,ty),
                                  (fn (ty,value) => 
                                   ValuePrinter.stringify_value true 
                                   (print_options,
                                    value,
                                    ty,get_interpreter_information())),
                                  options,false,
                                  map 
                                  (fn MLFRAME(frame,_,_,FRAMEINFO(_,_,env,ref ty)) => (frame,env,ty)
                                    | MLFRAME(frame,_,_,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)
                                    | CFRAME(frame,_) => (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)) 
                                  below))))
                      | CFRAME(_) => ();
                          loop (above,below))
                 | "show_debug"::_ =>
                     (let
                        val debug_info = get_interpreter_information ()
                      in
                        Lists.iterate (fn s => output(std_out,s^"\n")) (Debugger_Types.print_information (debug_info,true))
                      end;
                      loop (above,below))

                  | _ => (display_simple_help_info();
                          loop (above,below))
                end
                | loop _ = output (std_out,"No frames to look at in debugger!\n")
d1641 2
a1642 2
            in
	      if Trace.step_state () then () else outline "Current (innermost) stack frame:";
d1645 1
a1645 1
            end
d1647 54
a1700 55
          fun make_entry_info_line () =
            (case quit_continuation of
               POSSIBLE (s,_) => "q : " ^ s ^ ", "
             | _ => "") ^
            (case continue_continuation of
               POSSIBLE (s,_) => "c : " ^ s ^ ", "
             | _ => "") ^
            " ? : more help"

          fun tty_debugger basic_frames =
	    if not (!use_debugger) then
	      (outline (parameter_details ());
	       do_quit ())
	    else if stack_empty basic_frames then
	      outline (parameter_details () ^ " at top level")
	    else if Trace.step_state () then
	      ()
            else
	      (outline (parameter_details ());
	       outline ("Entering debugger, commands: " ^ make_entry_info_line ());
               do_input (make_frames (basic_frames,parameter,options)))

         in
	   let
             val top_frame = MLWorks.Internal.Value.Frame.current ()
             val basic_frames =
	       StackInterface.get_basic_frames (top_frame,base_frame)

	     (* The identifier debugger_call is never used; this is deliberate!
	        See below.  *)
	     val debugger_call =
	       case type_of_debugger
	       of TERMINAL =>
	         tty_debugger basic_frames
               |  WINDOWING (make_window, send_message, tty_ok) =>
                 if tty_ok andalso not (!window_debugger) then
	           tty_debugger basic_frames
	         else if not (!use_debugger) then
	           (send_message (parameter_details () ^ "\n");
		    do_quit ())
	         else if stack_empty basic_frames then
                   send_message (parameter_details () ^ " at top level\n")
	         else
                   let
                     (* This is terribly distracting when stepping *)
                     (* val _ = outline (parameter_details ()) *)
                     val frames = make_frames (basic_frames,parameter,options)
                     val frame_strings = make_frame_strings frames
  
		     fun edit s =
		       (ShellUtils.edit_location (s, preferences); ())
                       handle ShellUtils.EditFailed s =>
                         send_message ("Edit failed: " ^ s)
                   in
                     make_window
d1704 1
a1704 1
			  make_continuation_function quit_continuation,
d1706 36
a1741 37
			  make_continuation_function continue_continuation};
                     ()
                   end
           in
	     (* Ensure call to tty_debugger not tail, else frame is invalid *)
             ()
           end
         end

       val start_frame_ref = ref (MLWorks.Internal.Value.Frame.current())

       fun with_start_frame f =
         let
           val frame = MLWorks.Internal.Value.Frame.current ()
           val old_frame = !start_frame_ref
           val _ = start_frame_ref := frame
           val result =
             f frame
             handle exn => (start_frame_ref := old_frame; raise exn)
         in
           start_frame_ref := old_frame;
           result
         end

       fun get_start_frame () = !start_frame_ref

       val debugger_type_ref = ref TERMINAL

       fun with_debugger_type debugger_type f =
         let
           val old_type = !debugger_type_ref
           val _ = debugger_type_ref := debugger_type
           val result = (with_start_frame f) handle exn => (debugger_type_ref := old_type; raise exn)
         in
           debugger_type_ref := old_type;
           result
         end
d1743 1
a1743 1
       fun get_debugger_type () = !debugger_type_ref
d1745 1
a1745 1
     end
@


1.122
log
@Renamed ShellUtils.edit_string to ShellUtils.edit_source
(and ShellUtils.edit_source to ShellUtils.edit_location).
@
text
@d4 4
d760 20
a779 1
           CFRAME(frame,"<Cframe>")
d882 2
a883 2
           fun make_frame_details (CFRAME f,_) _ =
             ("<Cframe> " ^ MLWorks.Integer.makestring (cast f),"",
d933 1
a933 1
                      CFRAME (_,name) => {name = name, loc = "",details = details}
@


1.121
log
@Renaming trace functions
@
text
@d4 3
d1016 1
a1016 1
                  (ShellUtils.edit_string (loc, preferences); ())
d1339 1
a1339 1
		       (ShellUtils.edit_string (s, preferences); ())
@


1.120
log
@Suppressing display of C frames
@
text
@d4 3
d1224 1
a1224 1
                  | "trace" :: args => (Lists.iterate Trace.simple_trace args;
d1226 1
a1226 1
                  | "breakpoint" :: args => (Lists.iterate Trace.simple_break args;
d1228 1
a1228 1
                  | "untrace" :: args => (Lists.iterate Trace.simple_untrace args;
d1230 1
a1230 1
                  | "unbreakpoint" :: args => (Lists.iterate Trace.simple_unbreak args;
@


1.119
log
@Improving messages
@
text
@d4 3
d703 1
a703 1
       val suppressed_frames = ref [(* "<Cframe>","<Setup>" *)] : string list ref
@


1.118
log
@Add location imformation to exception names when printed
@
text
@d4 3
d1280 9
d1299 1
a1299 2
	       outline ("Entering debugger " ^
                        "(type q to return to listener, or ? for help).");
@


1.117
log
@Changing behaviour for empty list of frames
@
text
@d4 3
d911 33
a943 6
                implode ["Exception ",
                         ValuePrinter.stringify_value false (print_options,
                                                             cast exn,
                                                             Datatypes.CONSTYPE([],Types.exn_tyname),
                                                             get_interpreter_information()),
                         " raised"]
@


1.116
log
@If the use_debugger preference is not set, make the debugger function do a
quit option instead of a normal return.
@
text
@d4 4
d1239 1
a1239 1
                | loop _ = Crash.impossible "inside input loop"
@


1.115
log
@Fixed mistake in my last change: the tty debugger wasn't printing the
reason that the debugger was invoked.
@
text
@d4 4
d925 14
a972 13
              fun do_continue() =
                (case continue_continuation of
                   NOT_POSSIBLE => outline "Cannot Continue"
                 | POSSIBLE(_,NORMAL_RETURN) => raise Exit
                 | POSSIBLE(_,DO_RAISE exn) => raise exn
                 | POSSIBLE (_,FUN f) => (f(); raise Exit))
              fun do_quit() =
                (case quit_continuation of
                   NOT_POSSIBLE => outline "Cannot Quit"
                 | POSSIBLE(_,NORMAL_RETURN) => raise Exit
                 | POSSIBLE(_,DO_RAISE exn) => raise exn
                 | POSSIBLE(_,FUN f) => (f(); raise Exit))

d1104 5
a1108 1
                      val _ = if end_of_stream std_in then do_quit() else ()
d1164 1
d1170 1
d1191 1
d1196 1
d1200 1
d1245 2
a1246 1
	      outline (parameter_details ())
d1273 2
a1274 1
	           send_message (parameter_details () ^ "\n")
@


1.114
log
@Made the debugger use the message function from the debugger type
info to print the message when use_debugger is false or the stack is empty.
@
text
@d4 4
d1237 2
a1238 1
	      (outline ("Entering debugger " ^
@


1.113
log
@Made use of debugger depend on preference setting.
Removed redundant parameters from ml_debugger, added a message_fn
parameter, and removed unnecessary currying.
@
text
@d4 5
d160 1
a160 1
Added tty_ok option to WINDOWINF
d611 27
a637 14
       type debugger_window = 
         ((string * 
           {name : string, 
            loc : string, 
            details: string * 
                     string * 
                     (ValuePrinter.Type * MLWorks.Internal.Value.ml_value * string) * 
                     (unit -> string * ((string * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value * string)) list),
                      string * ((string * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value * string)) list))
                     MLWorks.Option.union ref
                     MLWorks.Option.option} list *
           (string -> unit) *
           ((unit -> unit) MLWorks.Option.option * (unit -> unit) MLWorks.Option.option) -> unit) *
         (string -> unit))
d640 1
a640 1
         WINDOWING of debugger_window * bool
d815 1
a815 1
         (type_of_debugger, options, preferences, message_fn)
d1226 11
a1236 8
             let
               val _ = outline (parameter_details ())
             in
               if Trace.step_state () then ()
               else outline ("Entering debugger " ^
                             "(type q to return to listener, or ? for help).");
               do_input (make_frames (basic_frames,parameter,options))
             end
d1238 42
a1279 39
	   if not (!use_debugger) then
	     message_fn (parameter_details () ^ "\n")
	   else
             let
               val top_frame = MLWorks.Internal.Value.Frame.current ()
               val basic_frames = StackInterface.get_basic_frames (top_frame,base_frame)

               val debugger_call =
                 if stack_empty basic_frames then
                   message_fn (parameter_details () ^ " at top level\n")
                 else
                   case type_of_debugger of
                     TERMINAL => tty_debugger basic_frames
                   | WINDOWING ((make_window,send_message),tty_ok) =>
                       if tty_ok andalso not (!window_debugger)
                         then tty_debugger basic_frames
                       else
                         let
                           (* This is terribly distracting when stepping *)
                           (* val _ = outline (parameter_details ()) *)
                           val frames = make_frames (basic_frames,parameter,options)
                           val frame_strings = make_frame_strings frames
                         in
                           make_window (parameter_details (),
                                        frame_strings,
                                        fn s =>
                                        (ShellUtils.edit_string
                                         (s, preferences);
                                         ())
                                        handle ShellUtils.EditFailed s =>
                                          send_message ("Edit failed: " ^ s),
                                          (make_continuation_function quit_continuation,
                                           make_continuation_function continue_continuation)
                                          );
                           ()
                         end
             in
               () (* Ensure call to tty_debugger not tail, else frame is invalid *)
             end
d1281 1
@


1.112
log
@Add fatal signals.
@
text
@d4 3
d797 2
a798 5
         type_of_debugger
         (options, preferences, context)
         execute_function
         base_frame
         (parameter,quit_continuation,continue_continuation)
d804 2
a805 1
           val Preferences.ENVIRONMENT_OPTIONS{window_debugger,...} =
d810 2
a811 1
               EXCEPTION _ => Lists.length basic_frames <= 2 (* one for the money, two for the show *)
d892 1
d930 1
a930 1
                  (ShellUtils.edit_string (loc, context, preferences); ())
d1217 6
a1222 3
           let
             val top_frame = MLWorks.Internal.Value.Frame.current ()
             val basic_frames = StackInterface.get_basic_frames (top_frame,base_frame)
d1224 32
a1255 31
             val debugger_call =
               if stack_empty basic_frames then
                 outline (parameter_details () ^ " at top level")
               else
                 case type_of_debugger of
                   TERMINAL => tty_debugger basic_frames
                 | WINDOWING ((make_window,send_message),tty_ok) =>
                     if tty_ok andalso not (!window_debugger)
                       then tty_debugger basic_frames
                     else
                       let
                         (* This is terribly distracting when stepping *)
                         (* val _ = outline (parameter_details ()) *)
                         val frames = make_frames (basic_frames,parameter,options)
                         val frame_strings = make_frame_strings frames
                       in
                         make_window (parameter_details (),
                                      frame_strings,
                                      fn s =>
                                      (ShellUtils.edit_string
                                       (s, context, preferences);
                                       ())
                                      handle ShellUtils.EditFailed s =>
                                        send_message ("Edit failed: " ^ s),
                                        (make_continuation_function quit_continuation,
                                         make_continuation_function continue_continuation)
                                        );
                         ()
                       end
           in
             () (* Ensure call to tty_debugger not tail, else frame is invalid *)
a1256 1
         end
@


1.111
log
@Cleaning up tty interface
@
text
@d4 3
d624 1
d883 2
@


1.110
log
@Removed old step & breakpoint stuff
Removed script parameter to ml_debugger
@
text
@d4 4
d957 6
a962 10
                  " s <n>            - step debugging in intervals of n local variable computations",
                  " s                - single step debugging",
                  " S <n>            - step debugging in intervals of n local variable computations in current frame",
                  " S                - single step debugging in current frame",
                  " br <name[<file>:<loc>]> - set breakpoint on function entry at <name> and optional <file>,<loc>",
                  " brx <name[<file>:<loc>]> - set breakpoint on function exit at <name> and optional <file>,<loc>",
                  " d <name[<file>:<loc>]>  - delete breakpoint at <name> and optional <file>,<loc>",
                  " D                - delete all breakpoints",
                  " l                - list breakpoints",
                  (* " shell - start a subshell (binding 'it' to frame argument)", *)
d1139 1
a1139 1
                  | "st" :: args => (Lists.iterate Trace.simple_trace args;
d1141 1
a1141 1
                  | "sb" :: args => (Lists.iterate Trace.simple_break args;
d1143 1
a1143 1
                  | "sut" :: args => (Lists.iterate Trace.simple_untrace args;
d1145 1
a1145 1
                  | "sub" :: args => (Lists.iterate Trace.simple_unbreak args;
d1147 10
a1156 3
                  | ["step"] => (Trace.set_stepping true;
                                 do_continue();
                                 loop (above,below))
@


1.109
log
@General cosmetic improvements
@
text
@d4 3
d459 1
a459 1
       val castit : 'a -> 'b = MLWorks.Internal.Value.cast (fn x => x)
d597 14
a610 14
      ((string * {name : string, loc : string, 
                 details: string * string * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value 
                                            * string) * 
                (unit -> string * ((string * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value 
                                            * string)) list),
                 string * ((string * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value 
                                            * string)) list))
                MLWorks.Option.union ref
                 MLWorks.Option.option} list 
       * (string -> unit) *
       ((unit -> unit) MLWorks.Option.option *
        (unit -> unit) MLWorks.Option.option) ->
       unit) *
      (string -> unit))
d790 1
a790 1
         (parameter,quit_continuation,continue_continuation) debugger_script
a792 2
           val debugger_script = ref(debugger_script)

d805 2
a806 2
             ("<Cframe> " ^ MLWorks.Integer.makestring (castit f),"",
              (Datatypes.NULLTYPE,castit 0,""), MLWorks.Option.NONE)
d810 1
a810 1
                (Datatypes.NULLTYPE,castit 0,""),
d824 1
a824 2
               implode[name,"[",loc,"]",
                       ":",Types.print_type print_options inferredType],
d826 6
a831 6
                  (arg_type,arg,ValuePrinter.stringify_value false
                   (print_options,
                    arg,
                    inferredType,
                    get_interpreter_information()))
               else (Datatypes.NULLTYPE, castit 0,""),
d833 13
a845 15
                   MLWorks.Option.SOME(ref(MLWorks.Option.INL(fn () =>
                                  DebuggerPrint.print_env(
                                                        (f,runtime_env,inferredType),
                                                        fn (Type,value) => 
                                                        ValuePrinter.stringify_value true 
                                                        (print_options,
                                                         value,
                                                         Type,get_interpreter_information()),
                                                        options,true,
                                     map (fn MLFRAME(frame,_,_,FRAMEINFO(_,_,env,ref ty))=>(frame,env,ty)
                                           | MLFRAME(frame,_,_,_)=> 
                                               (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)
                                           | CFRAME(frame,_) => 
                                               (frame,RuntimeEnv.EMPTY,Datatypes.NULLTYPE)) 
                                     frames))))
d870 1
a870 1
                                                             castit exn,
d1067 6
a1072 12
                    case !debugger_script of
                      [] =>
                        let
                          val _ = if end_of_stream std_in then do_quit() else ()
                          val line = MLWorks.IO.input_line std_in
                        in
                          parse_command line
                        end
                    | command::commands => (debugger_script := commands;
                                            outline command;
                                            parse_command command)

a1124 87
                  | ["s"] => 
                      (MLWorks.Debugger.set_step(1,"");
                       do_continue();
                       loop (above,below))
                  | "s"::arg::nil => 
                      (MLWorks.Debugger.set_step
                          ((case string_to_int arg of
                             0 => 1
                           | n => n),"");
                       do_continue();
                       loop (above,below))
                  | "s"::arg::arg' => 
                      let
                        val arg' = 
                          Lists.reducer
                          (fn (str1,str2) =>
                           case str2 of
                             "" => str1
                           | _ => str1 ^ " " ^ str2) 
                          (arg',"")
                      in
                        (MLWorks.Debugger.set_step
                         ((case string_to_int arg of
                             0 => 1
                           | n => n),arg');
                         do_continue();
                         loop (above,below))
                      end
                  | ["S"] => 
                      (MLWorks.Debugger.set_step
                       (1,frame_fnname ());
                       do_continue();
                       loop (above,below))
                  | "S"::arg::nil => 
                      (MLWorks.Debugger.set_step
                          ((case string_to_int arg of
                             0 => 1
                           | n => n),frame_fnname ());
                       do_continue();
                       loop (above,below))
                  | "S"::arg::arg' => 
                      let
                        val arg' = 
                          Lists.reducer 
                          (fn (str1,str2) =>
                           case str2 of
                             "" => str1
                           | _ => str1^" "^str2) (arg',"")
                      in
                        (MLWorks.Debugger.set_step
                         ((case string_to_int arg of
                             0 => 1
                           | n => n),arg');
                         do_continue();
                         loop (above,below))
                      end
                  | "br"::arg =>
                      (MLWorks.Debugger.set_breakpoint
                       (Lists.reducer 
                        (fn (str1,str2) =>
                         case str2 of
                           "" => str1
                         | _ => str1 ^ " " ^ str2)
                        (arg,""));
                       loop (above,below))
                  | "brx"::arg =>
                      (MLWorks.Debugger.set_breakpoint_on_exit(
                          Lists.reducer 
                          (fn (str1,str2) =>
                           case str2 of
                             "" => str1
                           | _ => str1^" "^str2) (arg,""));
                       loop (above,below))
                  | "d"::arg =>
                      (MLWorks.Debugger.delete_breakpoint (
                          Lists.reducer 
                          (fn (str1,str2) =>
                           case str2 of
                             "" => str1
                           | _ => str1^" "^str2) (arg,""));
                       loop (above,below))
                  | "D"::_ => 
                      (MLWorks.Debugger.delete_breakpoints();
                       loop (above,below))
                  | "l"::_ => 
                      (Lists.iterate outline ("Breakpoints:"::(MLWorks.Debugger.list_breakpoints()));
                       loop (above,below))
d1195 4
a1198 7
               (case !debugger_script of
                  [] =>
                    if Trace.step_state () then ()
                    else outline ("Entering debugger " ^
                                  "(type q to return to listener, or ? for help).")
                | _ => ();
                do_input (make_frames (basic_frames,parameter,options)))
a1268 136

       (* Step Debugging and Breakpoints code *)
       (* These functions get called via MLWorks.Debugger.xxx *)
       local
         val entry_breakpoints_ref : string list list ref = ref []
         val exit_breakpoints_ref : string list list ref = ref []

         local

           val interval : int ref = ref 0
           val timer_interval : int ref = ref 0

         in
           (* Runtime call of this function is created in Lambda Translation *)

           (* Just print some information and do a break *)
           fun step (MLfun,exception_raise) = 
             case !timer_interval of
               0 => ()
             | 1 => 
                 (timer_interval := (!interval);
                  case exception_raise of
                    MLWorks.Option.SOME exn =>
                      (case exn of
                         (* This is used for returning from the debugger *)
                         Interrupt => ()
                       | _ => 
                           MLWorks.Debugger.break 
                           ("exception: " ^
                            ValuePrinter.stringify_value false
                            (ValuePrinter.Options.default_print_options,
                             castit exn,
                             Types.exn_type,
                             Debugger_Types.empty_information) ^
                            " raised in " ^ MLfun))
                  | MLWorks.Option.NONE =>
                      MLWorks.Debugger.break MLfun)
             | _ => 
                 (debug (fn _ => "Decrementing timer_interval"); 
                  timer_interval := !timer_interval - 1)

           (* This function is used for an exception handler around a stepped expression *)
           fun step_handler_fn MLfun exn =
             (step (MLfun,MLWorks.Option.SOME exn);
              raise exn)

           fun set_step_interval (i,s) =
             (interval := i;
              debug (fn _ => "Setting timer_interval to " ^ MLWorks.Integer.makestring i);
              timer_interval := i)

           (* Runtime call of this function is created in Lambda Translation *)
           (* Looks like we search down the list of breakpoints set each *)
           (* time this function  is called *)

             
           fun breakpoint (message,ref_breakpoints) ml_fun = 
             let
               val break_here =
                 case !ref_breakpoints of
                   [] => false
                 | breakpoints => 
                     let
                       val ml_fun_chars = explode ml_fun
                       fun check [] = false
                         | check (breakpt::rest) =
                           substring (breakpt,ml_fun_chars) orelse
                           check rest
                     in
                       check breakpoints
                     end
             in
               if break_here 
                 then MLWorks.Debugger.break ("breakpoint at " ^ ml_fun)
               (* Else try calling the step function *)
               else step (message ^ " " ^ ml_fun,MLWorks.Option.NONE)
             end

           fun set_breakpoint ref_breakpoints breakpoint =
             let
               val breakpoint = explode breakpoint
               (* Remove leading spaces!! *)
               fun strip nil = nil
                 | strip (" " :: bs) = strip bs
                 | strip bs = bs
             in
               if strip breakpoint = [] then ()
               else
                 ref_breakpoints := breakpoint::(!ref_breakpoints)
             end

           fun delete_breakpoint breakpoint =
             let
               val breakpoint = explode breakpoint
               fun delete_breakpoint nil = nil
                 | delete_breakpoint (breakpt::breakpts) =
                   if substring (breakpoint,breakpt) then
                     delete_breakpoint breakpts
                   else
                     breakpt::delete_breakpoint breakpts
             in
               entry_breakpoints_ref := delete_breakpoint (!entry_breakpoints_ref);
               exit_breakpoints_ref := delete_breakpoint (!exit_breakpoints_ref)
             end

           fun delete_breakpoints () = (entry_breakpoints_ref := nil; exit_breakpoints_ref := nil)

           fun list_breakpoints () = map implode (!entry_breakpoints_ref @@ !exit_breakpoints_ref)
         end
         local
           fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
         in
           val set_breakpoint_fn : (string -> unit) -> unit =
             env "debugger set breakpoint function"
           val set_stepper_fn : ((string * 'a) -> unit) -> unit =
             env "debugger set stepper function"
           val set_exit_breakpoint_fn : (string -> unit) -> unit =
             env "debugger set exit breakpoint function"
           val set_stepper_handler_fn : (string -> exn -> unit) -> unit =
             env "debugger set stepper handler function"
         end
       in
         (* Set the various implicit vector function entries *)
         (* Prior to this they are set to unit, so tend to bus error on being called *)
         val _ = (set_stepper_fn step;
                  set_breakpoint_fn (breakpoint ("entering", entry_breakpoints_ref));
                  set_exit_breakpoint_fn (breakpoint ("exiting", exit_breakpoints_ref));
                  set_stepper_handler_fn step_handler_fn;

                  MLWorks.Debugger.set_step_hook := set_step_interval;
                  MLWorks.Debugger.set_breakpoint_hook := set_breakpoint entry_breakpoints_ref;
                  MLWorks.Debugger.set_breakpoint_on_exit_hook := set_breakpoint exit_breakpoints_ref;
                  MLWorks.Debugger.delete_breakpoint_hook := delete_breakpoint;
                  MLWorks.Debugger.delete_breakpoints_hook := delete_breakpoints;
                  MLWorks.Debugger.list_breakpoints_hook := list_breakpoints)
       end
@


1.108
log
@filesys and path moved from utils to initbasis.
@
text
@d4 3
d1314 2
a1315 1
                         val _ = outline (parameter_details ())
@


1.107
log
@Change type of decode_type_basis to take a btree
@
text
@d4 3
d349 1
a349 1
require "../utils/path";
@


1.106
log
@New stepping and breakpointing stuff
@
text
@d4 3
d388 2
d566 1
a566 1
                             (#type_env (Encapsulate.input_all (file ^ ".mo")),file,nil,true)
@


1.105
log
@More stuff
@
text
@d4 3
d673 2
a674 1
                           Debugger_Types.ERROR string
a675 1
                         (* Debugger_Types.NOP *)
d681 1
a681 2
               handle
               FailedToGetTypeInfo => NOFRAMEINFO
a770 3
       (* This should be reinstantiated for different debuggers *)
       val stepping_ref = ref false

d1054 1
a1054 1
                  val _ = if !stepping_ref then () else output_frame_details this
a1086 1

a1087 1
                      
d1119 1
a1119 1
                      (MLWorks.Debugger.set_step(0,"");
a1223 1
                                     if !stepping_ref then Trace.set_stepping true else ();
a1225 1
                                     if !stepping_ref then Trace.set_stepping true else ();
a1227 1
                                      if !stepping_ref then Trace.set_stepping true else ();
a1229 5
                                      if !stepping_ref then Trace.set_stepping true else ();
                                      loop (above,below))
                  (* I guess this could now go into "step mode"? *)
                  | ["step","on"] => (Trace.set_stepping true;
                                      stepping_ref := true;
d1231 3
a1233 3
                  | ["step","off"] => (Trace.set_stepping false;
                                       stepping_ref := false;
                                       loop (above,below))
d1270 1
a1270 1
	      if !stepping_ref then () else outline "Current (innermost) stack frame:";
d1281 1
a1281 1
                    if !stepping_ref then ()
d1467 8
a1474 4
           val set_breakpoint_fn : (string -> unit) -> unit = env "debugger set breakpoint function"
           val set_stepper_fn : ((string * 'a) -> unit) -> unit = env "debugger set stepper function"
           val set_exit_breakpoint_fn : (string -> unit) -> unit = env "debugger set exit breakpoint function"
           val set_stepper_handler_fn : (string -> exn -> unit) -> unit = env "debugger set stepper handler function"
@


1.104
log
@Making debugger platform independent
@
text
@d4 3
d790 1
a790 1
               EXCEPTION _ => Lists.length basic_frames <= 1
@


1.103
log
@New path functions.
@
text
@d4 3
d346 1
d363 1
a413 2
       val is_ml_frame = MLWorks.Internal.Value.Frame.is_ml_frame

d487 1
a487 1
           val name_string = DebuggerUtilities.frame_name frame
d542 1
a542 4
(*
               raise FailedToGetTypeInfo
*)
(* This needs to be thought about a little *)
d648 1
a648 1
               val arg = DebuggerUtilities.frame_arg frame
d683 1
a683 1
       fun make_frames (frame,base_frame,parameter,options) =
a684 12
           fun get_basic_frames (bottom,acc) =
             let
               val (another,next,offset) = MLWorks.Internal.Value.Frame.frame_next bottom
             in
               if another andalso next <> base_frame
                 then
                   get_basic_frames (next,(next,offset,offset <> 0)::acc)
               else
                 (if next <> base_frame then debug (fn _ => "No base frame") else ();
                  acc)
             end

d715 1
a715 1
                       if DebuggerUtilities.is_stack_extension_frame frame
a747 9
           val basic_frames = get_basic_frames (frame,[(frame,0,is_ml_frame frame)])

           (* omit bottom frame (this is the one above the base frame) *)
           (* This depends on our mechanism for setting up the base frame *)
           val basic_frames =
             case basic_frames of
               (_::rest) => rest
             | rest => rest

d785 1
a785 1
	   fun stack_empty top_frame =
d787 1
a787 17
               EXCEPTION _ =>
                 let
                   val HACK = 3
                   fun stack_empty' (frame, 0) = false
                     | stack_empty' (frame, n) =
                         let
                           val (another,next,offset) =
                             MLWorks.Internal.Value.Frame.frame_next frame
                         in
                           if another andalso next <> base_frame then
                             stack_empty' (next, n - 1)
                           else
                             (debug (fn _ => "fewer than "^MLWorks.Integer.makestring HACK^" frames"); true)
                         end
                 in
                   stack_empty' (top_frame, HACK)
                 end
a827 1
                                                        MLWorks.Internal.Value.Frame.frame_offset,
d955 1
a955 1
                   POSSIBLE(st,_) => [" c     - " ^ st]
d958 1
a958 1
                      POSSIBLE(st,_) => [" q     - " ^ st]
d1250 1
a1250 1
                                 ((frame,runtime_env,ty),
a1255 1
                                  MLWorks.Internal.Value.Frame.frame_offset,
d1283 1
a1283 1
          fun tty_debugger top_frame =
d1293 1
a1293 1
                do_input (make_frames (top_frame,base_frame,parameter,options)))
d1297 31
a1327 5
             val this_frame = MLWorks.Internal.Value.Frame.current ()
             (* This gets us to the next frame *)
             (* Slightly non-portable this *)
             val top_frame = MLWorks.Internal.Value.cast (MLWorks.Internal.Value.Frame.sub (this_frame,14))
             (* val _ = output (std_out,MLWorks.Integer.makestring top_frame ^ "\n") *)
d1329 1
a1329 27
             if stack_empty top_frame then
               outline (parameter_details () ^ " at top level")
             else
               case type_of_debugger of
                 TERMINAL => tty_debugger top_frame
               | WINDOWING ((make_window,send_message),tty_ok) =>
                   if tty_ok andalso not (!window_debugger)
                     then tty_debugger top_frame
                   else
                     let
                       val _ = outline (parameter_details ())
                       val frames = make_frames (top_frame,base_frame,parameter,options)
                       val frame_strings = make_frame_strings frames
                     in
                       make_window (parameter_details (),
                                    frame_strings,
                                    fn s =>
                                    (ShellUtils.edit_string
                                     (s, context, preferences);
                                     ())
                                    handle ShellUtils.EditFailed s =>
                                      send_message ("Edit failed: " ^ s),
                                      (make_continuation_function quit_continuation,
                                       make_continuation_function continue_continuation)
                                      );
                       ()
                     end
@


1.102
log
@Various changes
Addition of simple trace functions to tty debugger
Improvements to backtrace stuff
etc. etc.
@
text
@d4 6
d545 1
a545 1
                  val file = Path.base (source_file)
@


1.101
log
@Debugger changes
@
text
@d4 3
d336 1
a336 1
require "get_type_information";
d339 1
d352 1
a352 1
  structure GetTypeInformation : GETTYPEINFORMATION
d356 1
d358 1
a358 1
  sharing GetTypeInformation.Debugger_Types.Options = DebuggerPrint.Options =
d361 4
a364 2
  sharing GetTypeInformation.Debugger_Types =
    DebuggerUtilities.Debugger_Types
a365 2
  sharing GetTypeInformation.Debugger_Types = Encapsulate.Debugger_Types
  sharing GetTypeInformation.Debugger_Types.NewMap = Types.Datatypes.NewMap
d368 4
d373 1
a373 1
  sharing type GetTypeInformation.Debugger_Types.information =
d375 1
a375 1
  sharing type Types.Datatypes.Type = GetTypeInformation.Debugger_Types.Type =
d377 1
a377 1
  sharing type GetTypeInformation.TypeBasis = ValuePrinter.TypeBasis =
d379 1
d381 2
a382 1
  sharing type GetTypeInformation.Debugger_Types.Type = DebuggerPrint.RuntimeEnv.Type
d391 1
a391 1
       structure Debugger_Types = GetTypeInformation.Debugger_Types
d395 1
a395 1
       structure Options = Debugger_Types.Options
d403 2
d412 1
d419 11
d451 10
d483 12
d525 1
a525 17
       (* DIAGNOSTIC FUNCTIONS *)

       fun get_arg_type(Datatypes.METATYVAR(ref(_,object,_),_,_)) = get_arg_type object
         | get_arg_type(Datatypes.FUNTYPE (arg,_)) = arg
         | get_arg_type x = Datatypes.NULLTYPE

       fun get_res_type(Datatypes.METATYVAR(ref(_,object,_),_,_)) = get_res_type object
         | get_res_type(Datatypes.FUNTYPE (_,res)) = res
         | get_res_type x = Datatypes.NULLTYPE

       exception FailedToGetTypeInfo 

       val show_compiler_frames = ref false

       fun get_type_information (options,
                                 debug_info as Debugger_Types.INFO interpreter_information,
                                 ((function_name,loc),name_string)) =
d527 10
a536 15
           (* This should use some Location function *)
           fun find_source_file locdata =
             let
               fun aux1(":"::l,acc) = implode(rev acc)
                 | aux1(c::l,acc) = aux1(l,c::acc)
                 | aux1([],acc) = implode(rev acc)
             in
               aux1(explode locdata,[])
             end
           val source_file = find_source_file loc

           fun find_in_file source_file =
             (NewMap.apply interpreter_information name_string;
              debug_info)
             handle NewMap.Undefined => 
d538 12
a549 15
                if !show_compiler_frames
                  then
                    let
                      val file = Path.base (source_file)
                      val result = cache_lookup file
                        handle CacheFail =>
                          let
                            val _ =
                              output(std_out,
                                     "Reading type information from file " ^ 
                                     file ^ 
                                     " - please wait ...\n")
                            val (_,_,information,_) = 
                              GetTypeInformation.get_type_information options file
                            val _ = add_to_cache(file,information)
d551 1
a551 1
                            information
d553 15
a567 37
                    in
                      result
                    end
                else
                  let
                    val file = Path.base (source_file)
                    val result = 
                      if Lists.member(file,["","__pervasive_library","__builtin_library"]) then
                        Debugger_Types.empty_information
                      else
                        (cache_lookup file
                        handle CacheFail =>
                          let
                            val (_,information) = 
                              Encapsulate.decode_type_basis
                              (#type_env (Encapsulate.input_all (file ^ ".mo")),file,nil,true)
                          in
                            (add_to_cache(file,information); information)
                          end
                        handle Encapsulate.BadInput msg =>
                          (debug (fn _ => 
                                  "Decapsulation failed for function " ^ 
                                  function_name ^ ": " ^ file ^ ":" ^ msg);
                           let
                             val information = Debugger_Types.empty_information
                           in
                             (add_to_cache(file,information); information)
                           end))
                  in
                    result
                  end)
               handle Io arg => Debugger_Types.empty_information
           val Debugger_Types.INFO mapping = find_in_file source_file
         in
           case NewMap.tryApply'(mapping, name_string) of
             MLWorks.Option.SOME funinfo => (funinfo,source_file)
           | _ => raise FailedToGetTypeInfo
d612 1
a612 1
         MLWorks.Internal.Value.frame *
d616 1
a616 1
         CFRAME of (MLWorks.Internal.Value.frame * string)
d627 1
a627 1
       val suppressed_frames = ref ["<Cframe>","<Setup>"] : string list ref
d629 1
a629 12
       fun ml_debugger 
         type_of_debugger
         (options, preferences, context)
         execute_function
         base_frame
         (parameter,quit_continuation,continue_continuation) debugger_script
         =
         let
           val debugger_script = ref(debugger_script)

	   val Options.OPTIONS {print_options, ...} = options
           val Preferences.PREFERENCES {environment_options,...} = preferences
d631 1
a631 2
           val Preferences.ENVIRONMENT_OPTIONS{window_debugger,...} =
	     environment_options
d633 1
a633 4
           (* need to ensure that this is the latest stuff *)
           fun get_interpreter_information() =
	     InterMake.current_debug_information ()
	     (* Incremental.debug_info context *)
d635 1
a635 1
           (* Note that offset is a _word_ count *)
d637 7
a643 3
           fun get_frame_details (frame,offset) =
             if offset <> 0 (* its an ML frame *)
               then
d645 13
a657 16
                   val debug_info as ((name,(loc,_)),name_str) = get_data_from_frame frame
                   val arg = DebuggerUtilities.frame_arg frame
                   val info =
                     let
                       val (Debugger_Types.FUNINFO {ty,is_leaf,annotations,runtime_env,...},
                            source_file) =
                         get_type_information (options,
                                               get_interpreter_information(),
                                               ((name,loc),name_str))
                       val arg_type = get_arg_type ty
                       val _ = debug (fn _ => "Getting info for " ^ name ^ ", offset: " ^ MLWorks.Integer.makestring (4 * offset))
                       val current_annotation =
                         case assoc (4 * offset,annotations) of
                           MLWorks.Option.SOME a => a
                         | _ => 
                             Debugger_Types.ERROR 
d660 5
a664 8

                       val _ = debug (fn _ => "Annotation: " ^ Debugger_Types.print_backend_annotation current_annotation)
                     in
                       FRAMEINFO (arg_type,current_annotation,runtime_env,
                                  ref Datatypes.NULLTYPE)
                     end
                   handle
                   FailedToGetTypeInfo => NOFRAMEINFO
d666 2
a667 1
                   MLFRAME(frame,debug_info,arg,info)
d669 7
a675 2
             else
               CFRAME(frame,"<Cframe>")
d677 3
a679 1
	   fun stack_empty top_frame =
d681 9
a689 18
               val HACK =
                 case parameter of
                   BREAK _ => 4
                 | _ => 6
               fun stack_empty' (frame, 0) = false
               |   stack_empty' (frame, n) =
                 let
                   val (another,next,offset) =
		     MLWorks.Internal.Value.frame_next frame
                 in
                   if another andalso next <> base_frame then
                     stack_empty' (next, n - 1)
                   else
		     (debug (fn _ => "fewer than "^MLWorks.Integer.makestring HACK^" frames"); true)
                 end
	     in
	       stack_empty' (top_frame, HACK)
	     end
d691 2
a692 1
           fun make_frames frame =
d694 18
a711 14
              fun get_basic_frames (all as _::_) bottom =
                 let
                   val (another,next,offset) = MLWorks.Internal.Value.frame_next bottom
                 in
                   if another andalso next <> base_frame
                     then
                       get_basic_frames ((next,offset)::all) next
                   else
                     (if next <> base_frame then debug (fn _ => "No base frame") else ();
                        all)
                 end
                 | get_basic_frames _ _ = Crash.impossible "adjusted_base_frame in _ml_debugger"

              val basic_frames = get_basic_frames [(frame,0)] frame
d713 7
a719 29
              exception ApplyRecipe 
              fun apply_recipe (annotation,ty,name) =
                let
                  val result = 
                    DebuggerUtilities.apply_recipe(annotation,ty)
                    handle DebuggerUtilities.ApplyRecipe problem =>
                      (debugl (fn _ => 
                              ["Recipe problem " ^ problem ^ " for " ^ name,
                               "Annotation: " ^ Debugger_Types.print_backend_annotation annotation,
                               "Arg : " ^ Types.debug_print_type ty]);
                      raise ApplyRecipe)
                in
                  if do_debug
                    then
                      debugl (fn _ => ["Name: " ^ name,
                                       "Annotation: " ^ Debugger_Types.print_backend_annotation annotation,
                                       "Arg : " ^ Types.debug_print_type ty,
                                       "Res : " ^ Types.debug_print_type result])
                  else ();
                    result
                end

              datatype TypeThunk =
                NORECIPE |
                RECIPE of (Debugger_Types.Backend_Annotation * Datatypes.Type)

              fun infer_types (recipe,[]) = ()
                | infer_types (recipe,frame::rest) =
                  (case frame of
d734 14
a747 1
                             | RECIPE (r,ty) => apply_recipe (r,ty,name)
d754 42
a795 6
	      (* omit bottom four frames (two Cframes, two anon functions) HACK *)
              (* This depends on our mechanism for setting up the base frame *)
	      val basic_frames =
		case basic_frames of
		  (_::_::_::_::rest) => rest
		| rest => rest
d797 2
a798 11
              val frames = map get_frame_details basic_frames
              val _ = infer_types (NORECIPE,frames)
             in
               case parameter of
                 BREAK _ => rev frames
               | _ =>
                   (* Omit the first two frames.  This is a HACK *)
                   case rev frames of
                     (_::_::rest) => rest
                   | rest => rest
             end
d800 20
a819 4
           fun print_argument (text,arg as (_,_,ty,_),after) =
             case ty of
               Datatypes.NULLTYPE => ""
             | _ =>  (text ^ ValuePrinter.stringify_value false arg ^ after)
d859 1
a859 1
                                                        MLWorks.Internal.Value.frame_offset,
d886 1
a886 3
          fun parameter_details empty =
	    let val tail = if empty then " at top level" else ""
	    in
d889 9
a897 12
		  implode
		    ["Exception ",
                ValuePrinter.stringify_value false (print_options,
                                                    castit exn,
                                                    Datatypes.CONSTYPE([],Types.exn_tyname),
                                                    get_interpreter_information()),
		     " raised",
		     tail]
            | SIGNAL s => "Unix signal " ^ MLWorks.Integer.makestring s ^ tail
            | BREAK s => "Break: " ^ s ^ tail
            | STACK_OVERFLOW => "Break on stack overflow" ^ tail
            end
d917 17
a933 9
              fun parse_command ([],acc) = [implode (rev acc)]
                | parse_command (char::rest,acc) = 
                  if is_whitespace char
                    then
                      (case acc of
                         nil => parse_command(rest,nil)
                       | _ => implode(rev acc)::parse_command(rest,nil))
                  else
                    parse_command (rest,char::acc)
d1084 1
a1084 1
                  val _ = output_frame_details this
d1086 1
d1094 1
a1094 1
                          parse_command(explode line,[])
d1097 3
a1099 2
                                            output(std_out, command^"\n");
                                            parse_command(explode command,[]))
d1136 1
a1136 1
                  | "b"::_ => 
d1143 7
d1252 23
a1274 43

(*
                  | ("shell",_) => 
                      let
                        fun update_it_to_unit () =
                          #1(Incremental.add_value
                          (context, "it",
                          Datatypes.UNBOUND_SCHEME (Types.empty_rectype),
                          castit 0))
                          
                        fun update_it_to_value() =
                          (case current_info of 
                             (OK (x,_,ty)) => 
                               let
                                 val ty' = get_arg_type ty
                                 val is_nulltype = 
                                   case ty' of
                                     Datatypes.NULLTYPE => true
                                   | _ => false
                               in
                                 if is_nulltype orelse
                                   DebuggerUtilities.is_type_polymorphic(ty')
                                   then
                                     update_it_to_unit()
                                 else
                                   let
                                     val arg = DebuggerUtilities.frame_arg this
                                   in
                                     #1(Incremental.add_value
                                        (context, "it",
                                         Datatypes.UNBOUND_SCHEME (ty'),
                                         castit arg))
                                   end
                               end
                           | _ => update_it_to_unit())
                          
                        val context' = update_it_to_value()
                      in
                        execute_function context';
                        loop (above,below)
                      end
*)
                 | "p"::_ => 
d1288 1
a1288 1
                                  MLWorks.Internal.Value.frame_offset,
d1311 1
a1311 1
	      output (std_out, "Current (innermost) stack frame:\n");
d1316 1
a1316 1
          fun tty_debugger (top_frame, empty) =
d1318 1
a1318 1
               val _ = outline (parameter_details empty)
d1320 7
a1326 9
	      if empty then
		()
	      else
		(case !debugger_script of
                   [] =>
                     outline ("Entering debugger " ^
                              "(type q to return to listener, or ? for help).")
                 | _ => ();
                 do_input (make_frames top_frame))
d1329 35
a1363 31
           MLWorks.Internal.Value.frame_call
             (fn top_frame =>
                let
	  	  val empty = stack_empty top_frame
	        in
                  case type_of_debugger of
                    TERMINAL => tty_debugger (top_frame, empty)
                  | WINDOWING ((make_window,send_message),tty_ok) =>
                      if tty_ok andalso (empty orelse not (!window_debugger)) 
                        then
                          (tty_debugger (top_frame, empty))
                      else
                        let
                          val _ = outline (parameter_details empty)
                          val frames = make_frames top_frame
                          val frame_strings = make_frame_strings frames
                        in
                          make_window (parameter_details empty,
                                       frame_strings,
                                       fn s =>
                                       (ShellUtils.edit_string
					  (s, context, preferences);
					())
                                       handle ShellUtils.EditFailed s =>
                                         send_message ("Edit failed: " ^ s),
                                         (make_continuation_function quit_continuation,
                                          make_continuation_function continue_continuation)
                                         );
                          ()
                        end
                end)
d1366 1
a1366 1
       val start_frame_ref = ref (MLWorks.Internal.Value.frame_call (fn x => x))
d1369 11
a1379 12
	 MLWorks.Internal.Value.frame_call 
	   (fn frame =>
              let
                val old_frame = !start_frame_ref
	        val _ = start_frame_ref := frame;
                val result =
	          f frame
	          handle exn => (start_frame_ref := old_frame; raise exn)
              in
                start_frame_ref := old_frame;
                result
              end)
d1418 1
a1418 1
                    MLWorks.Debugger.PRESENT exn =>
d1431 1
a1431 1
                  | MLWorks.Debugger.ABSENT =>
d1437 5
d1471 1
a1471 1
               else step (message ^ " " ^ ml_fun,MLWorks.Debugger.ABSENT)
d1505 8
d1514 7
a1520 1
         val _ = (MLWorks.Debugger.step_hook := step;
a1521 1
                  MLWorks.Debugger.breakpoint_hook := breakpoint ("entering", entry_breakpoints_ref);
a1522 1
                  MLWorks.Debugger.breakpoint_on_exit_hook := breakpoint ("exiting", exit_breakpoints_ref);
@


1.100
log
@Renaming debugger_env to runtime_env
Various simplifications etc,
@
text
@d4 4
d1432 1
a1432 1
           fun breakpoint ref_breakpoints ml_fun = 
d1451 1
a1451 1
               else step ("entering " ^ ml_fun,MLWorks.Debugger.ABSENT)
d1488 1
a1488 1
                  MLWorks.Debugger.breakpoint_hook := breakpoint entry_breakpoints_ref;
d1490 1
a1490 1
                  MLWorks.Debugger.breakpoint_on_exit_hook := breakpoint exit_breakpoints_ref;
@


1.99
log
@Replaced hacky file name operations with Path functions.
@
text
@d4 3
d330 1
a330 1
require "debugger_type_utilities";
d345 1
a345 1
  structure DebuggerTypeUtilities : DEBUGGER_TYPE_UTILITIES       
d353 1
a353 1
    DebuggerTypeUtilities.Debugger_Types
d357 1
a357 1
  sharing DebuggerPrint.RuntimeEnv = DebuggerTypeUtilities.Debugger_Types.RuntimeEnv
a376 1
       structure DebuggerTypeUtilities = DebuggerTypeUtilities
d386 14
a399 1
       fun debug(x) = if do_debug then output(MLWorks.IO.terminal_out,x()) else ()
d405 1
a405 1
       (* Offsets of saved registers in a stack frame *)
d407 14
a420 2
       val I0 = 8
       val I1 = 9
d439 1
a439 5
           open MLWorks.Internal.Value
           val closure = frame_sub (frame, I1)
           val primary = primary closure
           val name_string =
             code_name (sub (closure, if primary = Tags.PAIRPTR then 0 else 1))
a443 2
       val get_value_from_frame = MLWorks.Internal.Value.frame_sub

d447 1
a447 7
       val data_cache = ref([] :
                            (string * 
                             (string,
                               (Datatypes.Type * bool *
                               (int * Debugger_Types.Backend_Annotation) list)
                                * RuntimeEnv.debugger_env * bool) NewMap.T)
                            list)
d450 3
a452 3
           val _ = debug(fn _ => "Looking up " ^ file ^ " in cache - ")
           fun cache_lookup(x,[]) = (debug ( fn _ => "Not found \n") ;
                                     raise CacheFail)
d455 1
a455 1
                 then (debug (fn _ => "Found\n");
a483 18
       (* should use MLWorks.IO.input_line -- which returns the newline also *)
       fun get_line stream =
         let
           fun extend_line line =
             if end_of_stream stream then
               line
             else
               let
                 val char = input(stream, 1)
               in
                 if char = "\n" then line
                 else
                   extend_line(line ^ char)
               end
         in
           extend_line ""
         end

d489 2
a490 2
                                 Debugger_Types.INFO interpreter_information,
                                 ((function_name,loc),st)) =
d502 1
d504 2
a505 2
             (NewMap.apply interpreter_information st;
              interpreter_information)
d507 1
a507 1
               (debug (fn _ => "No info for " ^ st);
d520 1
a520 1
                            val (_,_,Debugger_Types.INFO mapping,_) = 
d522 1
a522 2
                            val _ = 
                              add_to_cache(file,mapping)
d524 1
a524 1
                            mapping
d534 1
a534 1
                        NewMap.empty (fn _ => false,fn _ => true)
d539 1
a539 1
                            val (_,mapping) = 
d541 1
a541 1
                              (#type_env(Encapsulate.input_all (file^".mo")),file,nil,true)
d543 1
a543 1
                            (add_to_cache(file,mapping); mapping)
d545 4
a548 2
                        handle Encapsulate.BadInput(msg) =>
                          ((*output(std_out,"\n Decapsulation failed for "^file^":"^msg);*)
d550 1
a550 1
                             val mapping = NewMap.empty (fn _ => false,fn _ => true)
d552 1
a552 1
                             (add_to_cache(file,mapping); mapping)
d557 2
a558 2
               handle Io arg => NewMap.empty (fn _ => false,fn _ => true)
           val mapping = find_in_file source_file
d560 2
a561 3
           case NewMap.tryApply'(mapping, st) of
             MLWorks.Option.SOME ((lookup,is_leaf,annotations),env, _) =>
               (lookup,is_leaf,annotations,env,source_file)
d602 1
a602 1
         * RuntimeEnv.debugger_env * Datatypes.Type ref |
d644 38
a681 28
            
              fun get_frame_details (frame,offset) =
                if offset <> 0 (* its an ML frame *)
                  then
                    let
                      val debug_info as ((name,(loc,_)),name_str) = get_data_from_frame frame
                      val arg = get_value_from_frame (frame,I0)
                      val info =
                        let
                          val (ty,is_leaf,annotations,runtime_env,source_file) =
                            get_type_information (options,
                                                  get_interpreter_information(),
                                                  ((name,loc),name_str))
                          val arg_type = get_arg_type ty
                          val current_annotation =
                            Lists.assoc (4 * offset,annotations) 
                            handle Lists.Assoc => Debugger_Types.Nop
                        in
                          FRAMEINFO (arg_type,current_annotation,runtime_env,
                                     ref Datatypes.NULLTYPE)
                        end
                      handle
                      FailedToGetTypeInfo => NOFRAMEINFO
                    in
                      MLFRAME(frame,debug_info,arg,info)
                    end
                else
                  CFRAME(frame,"<Cframe>")
d722 1
a722 1
              fun apply_recipe (annotation,ty) =
d725 6
a730 7
                    DebuggerTypeUtilities.apply_recipe(annotation,ty)
                    handle
                    DebuggerTypeUtilities.RecipeApplicationProblem problem =>
                      (debug (fn _ => 
                              "Recipe problem" ^ problem ^ "\n" ^
                              "Annotation: " ^ Debugger_Types.print_backend_annotation annotation ^"\n" ^
                              "Arg : " ^ Types.debug_print_type ty ^"\n");
a731 3
                  | DebuggerTypeUtilities.InValidMatch problem =>
                      (debug (fn _ => "Invalid match" ^ problem);
                       raise ApplyRecipe)
d735 4
a738 4
                      debug(fn _ => implode ["Annotation: ",
                                             Debugger_Types.print_backend_annotation annotation,"\n",
                                             "Arg : ", Types.debug_print_type ty,"\n",
                                             "Res : ", Types.debug_print_type result])
a746 7
              fun is_stack_extension_frame frame =
                let
                  val closure = MLWorks.Internal.Value.frame_sub (frame, I1)
                in
                  castit closure = Bits.rshift (Tags.STACK_EXTENSION,2)
                end
                
d751 1
a751 1
                       if is_stack_extension_frame frame
d757 1
d759 2
a760 2
                           if not (DebuggerTypeUtilities.is_type_polymorphic(arg_type))
                             then arg_type
d763 3
a765 4
                               NORECIPE => arg_type
                             | RECIPE (r,ty) => apply_recipe (r,ty)
                                 handle ApplyRecipe => (debug (fn _ => "recipe failure for " ^ name ^ "\n");
                                                        arg_type)
d771 7
a779 5
	      (* omit bottom four frames (two Cframes, two anon functions *)
	      val frames =
		case frames of
		  (_::_::_::_::rest) => rest
		| rest => rest
d784 1
a784 1
                   (* Omit the first two frames.  This is a hack *)
d797 1
a797 1
              (Datatypes.NULLTYPE,castit(0),""), MLWorks.Option.NONE)
d801 1
a801 1
                (Datatypes.NULLTYPE,castit(0),""),
d823 1
a823 1
               else (Datatypes.NULLTYPE, castit(0),""),
d827 1
a827 1
                                                        (f,runtime_env),
d835 1
a835 1
                                     map (fn MLFRAME(frame,_,_,FRAMEINFO(_,_,env,_))=>(frame,env)
d837 1
a837 1
                                               (frame,RuntimeEnv.EMPTY)
d839 1
a839 1
                                               (frame,RuntimeEnv.EMPTY)) 
d889 16
a904 15
              fun to_lowercase x =
                let
                  val v = ord x
                in
                  if v >= 65 andalso v <= 90
                    then chr(v + 32)
                  else x
                end
              
              fun parse_command ([],acc) = [implode(rev acc)]
                | parse_command (" "::rest,acc) = 
                  (case acc of
                     nil => parse_command(rest,nil)
                   | _ => implode(rev acc)::parse_command(rest,nil))
                | parse_command (h::t,acc) = parse_command (t,(*to_lowercase(h)*)h::acc)
d926 1
a926 1
                outline "Enter ? for help"
d955 2
a956 1
                  " help     - display this help info"] @@
a963 6
              val suppressed_frame = 
                  fn name => 
                   (String.substring(name,0,12) = "instance of " orelse
                    String.substring(name,0,26) = "Debugger exception handler")
                   handle String.Substring => false

d966 1
a966 1
                  Lists.member (name,!suppressed_frames) orelse suppressed_frame name
d1062 1
a1062 1
                          val line = get_line std_in
d1075 3
a1077 6
                      fun rbrace nil = Crash.impossible "rbrace:frame_fnname:loop:ml_debugger"
                        | rbrace ("}"::rest) = rest
                        | rbrace (_::rest) = rbrace rest
                      fun rparen nil = Crash.impossible "rparen:frame_fnname:loop:ml_debugger"
                        | rparen (")"::rest) = rest
                        | rparen (_::rest) = rparen rest
d1080 2
a1081 8
                        "{"::fnname => (implode o rev o rbrace o rev) fnname
                      | _ => 
                          if (String.substring(name,0,27) = "Part of match translation ("
                              handle String.Substring => false) then
                            (implode o rparen o explode o String.substring)
                            (name,27,size name-27)^"["^loc^"]"
                          else
                            name^"["^loc^"]"
d1134 2
a1135 1
                           | _ => str1^" "^str2) (arg',"")
d1173 7
a1179 6
                      (MLWorks.Debugger.set_breakpoint(
                          Lists.reducer 
                          (fn (str1,str2) =>
                           case str2 of
                             "" => str1
                           | _ => str1^" "^str2) (arg,""));
d1201 1
a1201 1
                      (map outline ("*****"::(MLWorks.Debugger.list_breakpoints()@@["*****"]));
d1235 1
a1235 1
                                   DebuggerTypeUtilities.is_type_polymorphic(ty')
d1240 1
a1240 2
                                     val arg = 
                                       get_value_from_frame (this,I0)   
d1261 5
a1265 4
                           | FRAMEINFO(_,_,runtime_env,_) => 
                             outfun (#1(DebuggerPrint.print_env(
                              (frame,runtime_env),
                               fn (Type,value) => 
d1267 10
a1276 11
                                     (print_options,
                                      value,
                                      Type,get_interpreter_information()),
                                     MLWorks.Internal.Value.frame_offset,
                                     options,false,
                                     map (fn MLFRAME(frame,_,_,FRAMEINFO(_,_,env,_))=>(frame,env)
                                           | MLFRAME(frame,_,_,_)=> 
                                               (frame,RuntimeEnv.EMPTY)
                                           | CFRAME(frame,_) => 
                                               (frame,RuntimeEnv.EMPTY)) 
                                     below))))
d1279 8
d1323 1
a1323 2
                          (debug (fn _ => "Selecting TTY debugger");
                           tty_debugger (top_frame, empty))
d1379 1
d1381 3
a1383 2
         val breakpoints : string list ref = ref([])
         val exit_breakpoints : string list ref = ref([])
d1385 4
a1388 18
           val interval : int ref = ref(0)
           val timer_interval : int ref = ref(0)
           val MLfunction : string ref = ref("")
           fun substring (str1,str2) =
             let
               val str1 = explode str1
               val str2 = explode str2
               fun tl xs = 
                 Lists.tl xs
                 handle Lists.Tl => nil
               fun substring (nil,_,_) = true
                 | substring (_,nil,_) = false
                 | substring (x::xs,y::ys,yys) =
                   if x = y then substring (xs,ys,yys)
                   else substring(str1,yys,tl yys)
             in
               substring (str1,str2,tl str2)
             end
d1391 2
d1394 29
a1422 23
             if !MLfunction = "" orelse substring(!MLfunction,MLfun) then
               case !timer_interval of
                 0 => ()
               | 1 => 
                   (timer_interval := (!interval);
                    case exception_raise of
                      MLWorks.Debugger.PRESENT(E) => 
                       MLWorks.Debugger.break ("exception:"^
                        ValuePrinter.stringify_value false
                                               (ValuePrinter.Options.default_print_options,
                                                castit(E),
                                                Types.exn_type,
                                                Debugger_Types.empty_information)^
                        " raised in local variable in "^MLfun)
                    | MLWorks.Debugger.ABSENT =>
                        MLWorks.Debugger.break ("local variable in "^MLfun))
               | _ => timer_interval := (!timer_interval)-1
             else
               ()
           fun set_step (parameter: int*string) =
             (interval := #1(parameter);
              timer_interval := #1(parameter);
              MLfunction := #2(parameter))
d1424 39
a1462 20
           fun breakpoint breakpoints MLfun = 
             case !breakpoints of
               nil => ()
             | breakpoints => 
                 let
                   fun breakpoint nil = ()
                     | breakpoint (breakpt::breakpts) =
                       if substring(breakpt,MLfun) then
                         MLWorks.Debugger.break ("breakpoint at "^MLfun)
                       else breakpoint breakpts
                 in
                   breakpoint breakpoints
                 end
           fun strip nil = nil
             | strip (" "::bs) = strip bs
             | strip bs = bs
           fun set_breakpoint breakpoints breakpoint =
             if (implode o strip o explode) breakpoint = "" then ()
             else
               breakpoints := breakpoint::(!breakpoints)
d1465 1
d1468 1
a1468 1
                   if substring(breakpoint,breakpt) then
d1473 2
a1474 1
               breakpoints := delete_breakpoint(!breakpoints@@(!exit_breakpoints))
d1477 1
a1477 1
           fun delete_breakpoints() = (breakpoints := nil; exit_breakpoints := nil)
d1479 1
a1479 1
           fun list_breakpoints() = (!breakpoints@@(!exit_breakpoints))
d1483 5
a1487 6
                  MLWorks.Debugger.set_step_hook := set_step;
                  MLWorks.Debugger.breakpoint_hook := breakpoint breakpoints;
                  MLWorks.Debugger.set_breakpoint_hook := set_breakpoint breakpoints;
                  MLWorks.Debugger.breakpoint_on_exit_hook := breakpoint exit_breakpoints;
                  MLWorks.Debugger.set_breakpoint_on_exit_hook :=
                    set_breakpoint exit_breakpoints;
@


1.98
log
@Replaced Option structure with references to MLWorks.Option.
@
text
@d318 1
d334 1
a460 3
       (* This doesn't seem to be used *)
       val default_path = ref("")

a490 14
       (* This is a hack, and doesn't belong here *)
       fun root_name filename =
         let
           val len = size filename
         in
           if len >= 4 then
             (case String.substring(filename, len-4, 4) of
                ".sml" => String.substring(filename, 0, len-4)
              | _ => filename)
           else
             filename
         end


d513 1
a513 1
                      val file = root_name(!default_path ^ source_file)
d534 1
a534 10
                    fun filename name =
                      if String.substring(name,size name-4,4) = ".sml" then
                        String.substring(name,0,size name-4)
                      else
                        name
                    (*fun filename [] = []
                      | filename ("."::rest) = "/"::rest
                      | filename (c::rest) = c::filename rest*)
                    val source_file = filename (source_file)
                    val file = root_name(!default_path ^ source_file)
@


1.97
log
@Changing uses of cast.
@
text
@d4 3
d344 3
a346 2
  sharing GetTypeInformation.Debugger_Types.Options = DebuggerPrint.Options = ShellUtils.Options =
    Types.Options = ValuePrinter.Options = Incremental.InterMake.Inter_EnvTypes.Options
a373 1
       structure Option = InterMake.Option
d599 2
a600 2
                Option.option ref
                 Option.opt} list 
d602 2
a603 2
       ((unit -> unit) Option.opt *
        (unit -> unit) Option.opt) ->
d639 8
a646 4
       fun make_continuation_function (POSSIBLE (_,NORMAL_RETURN)) = Option.PRESENT (fn _ => ())
         | make_continuation_function (POSSIBLE (_,DO_RAISE exn)) = Option.PRESENT (fn _ => raise exn)
         | make_continuation_function (POSSIBLE (_,FUN f)) = Option.PRESENT f
         |  make_continuation_function NOT_POSSIBLE = Option.ABSENT
d822 1
a822 1
              (Datatypes.NULLTYPE,castit(0),""),Option.ABSENT)
d827 1
a827 1
                Option.ABSENT)
d850 1
a850 1
                   Option.PRESENT(ref(Option.SOME1(fn () =>
d866 1
a866 1
                 else Option.ABSENT)
@


1.96
log
@Make NewMap return pervasive option
@
text
@d4 3
d381 2
d764 1
a764 1
                  MLWorks.Internal.Value.cast closure = Bits.rshift (Tags.STACK_EXTENSION,2)
d814 2
a815 2
             ("<Cframe> " ^ MLWorks.Integer.makestring (MLWorks.Internal.Value.cast f),"",
              (Datatypes.NULLTYPE,MLWorks.Internal.Value.cast(0),""),Option.ABSENT)
d819 1
a819 1
                (Datatypes.NULLTYPE,MLWorks.Internal.Value.cast(0),""),
d841 1
a841 1
               else (Datatypes.NULLTYPE,MLWorks.Internal.Value.cast(0),""),
d886 1
a886 1
                                                    MLWorks.Internal.Value.cast exn,
d1251 1
a1251 1
                          MLWorks.Internal.Value.cast 0))
d1275 1
a1275 1
                                         MLWorks.Internal.Value.cast arg))
d1437 1
a1437 1
                                                MLWorks.Internal.Value.cast(E),
@


1.95
log
@Abstraction of debug information
@
text
@d4 3
d578 1
a578 1
             NewMap.YES ((lookup,is_leaf,annotations),env, _) =>
@


1.94
log
@Moved preferences out of Options structure.
@
text
@d4 3
d333 1
a333 1
  structure RuntimeEnv : DEBUGGER_ENVIRONMENT
d335 1
a335 1
  sharing GetTypeInformation.Debugger_Types.Options = RuntimeEnv.Options = ShellUtils.Options =
d342 1
d352 1
a352 3
  sharing type GetTypeInformation.Debugger_Types.Type = RuntimeEnv.RuntimeEnv_type.Type
  sharing type RuntimeEnv.RuntimeEnv_type.debugger_env = 
     DebuggerTypeUtilities.Debugger_Types.Debugger_Env.debugger_env
a366 1
       structure RuntimeEnv = RuntimeEnv
d368 1
d375 1
a375 4
       val do_my_debug = false
       fun my_debug x = if do_my_debug then output(MLWorks.IO.terminal_out,x ^ "\n") else ()

       val empty_map = Datatypes.NewMap.empty' (op =)
d386 1
a386 1
               fun duff () = my_debug ("Odd codename:"^code_name^":")
d418 1
a418 1
                                * Debugger_Types.Debugger_Env.debugger_env * bool) NewMap.T)
d422 1
a422 1
           val _ = debug(fn () => "Looking up " ^ file ^ " in cache - ")
d513 1
a513 1
               (my_debug ("No info for " ^ st);
d617 1
a617 1
         * RuntimeEnv.RuntimeEnv_type.debugger_env * Datatypes.Type ref |
d699 1
a699 1
		     (my_debug ("fewer than "^MLWorks.Integer.makestring HACK^" frames"); true)
d715 1
a715 1
                     (if next <> base_frame then my_debug "No base frame" else ();
d729 5
a733 4
                      (my_debug ("Recipe problem" ^ problem ^ "\n" ^
                                 "Annotation: " ^ Debugger_Types.print_backend_annotation annotation ^"\n" ^
                                 "Arg : " ^ Types.debug_print_type ty ^"\n");
                       raise ApplyRecipe)
d735 1
a735 1
                      (my_debug ("Invalid match" ^ problem);
d738 1
a738 1
                  if do_my_debug
d740 4
a743 4
                      my_debug(implode ["Annotation: ",
                                        Debugger_Types.print_backend_annotation annotation,"\n",
                                        "Arg : ", Types.debug_print_type ty,"\n",
                                        "Res : ", Types.debug_print_type result])
d776 1
a776 1
                                 handle ApplyRecipe => (my_debug ("recipe failure for " ^ name ^ "\n");
d835 2
a836 2
                   Option.PRESENT(ref(Option.SOME1(fn ()=>
                                   RuntimeEnv.print_env(
d847 1
a847 1
                                               (frame,RuntimeEnv.RuntimeEnv_type.EMPTY)
d849 1
a849 1
                                               (frame,RuntimeEnv.RuntimeEnv_type.EMPTY)) 
d1284 1
a1284 1
                             outfun (#1(RuntimeEnv.print_env(
d1295 1
a1295 1
                                               (frame,RuntimeEnv.RuntimeEnv_type.EMPTY)
d1297 1
a1297 1
                                               (frame,RuntimeEnv.RuntimeEnv_type.EMPTY)) 
d1337 1
a1337 1
                          (my_debug "Selecting TTY debugger";
@


1.93
log
@Update debugger information production
@
text
@d4 3
d307 1
d317 1
d322 1
d351 1
d368 2
d638 1
a638 1
         (options, context)
d646 2
a647 1
           val Options.OPTIONS{print_options,environment_options,...} = options
d649 2
a650 1
           val Options.ENVIRONMENT_OPTIONS{window_debugger,...} = environment_options
d918 1
a918 1
                  (ShellUtils.edit_string (loc, context, options); ())
d1349 1
a1349 1
					  (s, context, options);
@


1.92
log
@Replaced context_ref with context.
@
text
@d4 3
d410 1
a410 1
                                * Debugger_Types.Debugger_Env.debugger_env) NewMap.T)
d566 2
a567 2
           case NewMap.tryApply mapping st of
             NewMap.YES ((lookup,is_leaf,annotations),env) =>
@


1.91
log
@\nNew runtime directory structure.
@
text
@d4 3
d626 1
a626 1
         (options, context_ref)
d639 3
a641 1
           fun get_interpreter_information() = InterMake.current_debug_information () (* Incremental.debug_info (!context_ref) *)
d904 1
a904 1
                  (ShellUtils.edit_string (loc,!context_ref,options);())
d1227 1
a1227 1
                          (!context_ref,"it",
d1251 1
a1251 1
                                        (!context_ref,"it",
d1334 3
a1336 1
                                       (ShellUtils.edit_string (s,!context_ref,options);())
@


1.90
log
@Breakpoint settings on function exits;
altered filename formation in decapsulation of debugger environments.
@
text
@d4 4
d301 1
a301 1
require "../rts/tags";
@


1.89
log
@Step and Breakpoints Debugger;
Type basis decapsulation facility for Monomorphic debugger;\nFew changes to the debugger command line parser.
@
text
@d4 5
d520 6
a525 1
                    fun filename [] = []
d527 2
a528 2
                      | filename (c::rest) = c::filename rest
                    val source_file = implode(filename (explode source_file))
a539 2
                            val _ = 
                              add_to_cache(file,mapping)
d541 1
a541 1
                            mapping
d545 5
a549 1
                           NewMap.empty (fn _ => false,fn _ => true)))
d935 2
a936 1
                  " br <name[<file>:<loc>]> - set breakpoint at <name> and optional <file>,<loc>",
d1058 1
d1179 8
d1370 2
a1375 1
           val breakpoints : string list ref = ref([])
d1418 1
a1418 1
           fun breakpoint MLfun = 
d1434 1
a1434 1
           fun set_breakpoint breakpoint =
d1447 1
a1447 1
               breakpoints := delete_breakpoint(!breakpoints)
d1450 1
a1450 1
           fun delete_breakpoints() = breakpoints := nil
d1452 1
a1452 1
           fun list_breakpoints() = (!breakpoints)
d1457 5
a1461 2
                  MLWorks.Debugger.breakpoint_hook := breakpoint;
                  MLWorks.Debugger.set_breakpoint_hook := set_breakpoint;
@


1.88
log
@Modifying loop
@
text
@d4 3
d14 1
a14 1
 Ignore stack extension frames in type inference
d27 1
a27 1
is a gross hack, butI couldn't get anything else to work.
d288 1
d301 1
d316 1
d367 2
a368 2
               fun aux2(["]"],acc) = acc
                 | aux2("]"::l,acc) = (duff();acc)
d370 1
a370 1
                 | aux2([],acc) = (duff();acc)
d372 1
a372 1
               val locchars = aux2 (rest,[])
d374 1
a374 1
               (implode(rev namechars),implode(rev locchars))
d419 3
a421 7
         let
           fun clean(_,[]) = []
             | clean(0,_) = []
             | clean(n,h::t) = h :: clean(n-1,t)
         in
           data_cache := x :: clean(!size_of_data_cache,!data_cache)
         end
d473 1
a473 1
                                 Debugger_Types.INFO (interpreter_information,_),
d503 1
a503 1
                            val (_,_,Debugger_Types.INFO (mapping,_),_) = 
d514 28
a541 2
                  NewMap.empty (fn _ => false,fn _ => true))
                handle Io arg => NewMap.empty (fn _ => false,fn _ => true)
d551 2
a552 3
         (string * 
          {name : string, loc : string, 
           details: string * string * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value 
d554 11
a564 11
                (unit -> string * (string * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value 
                                            * string)) list,
                 string * (string * (ValuePrinter.Type * MLWorks.Internal.Value.ml_value 
                                            * string)) list) 
                 Option.option ref
                 Option.opt} list *
          (string -> unit) *
          ((unit -> unit) Option.opt *
           (unit -> unit) Option.opt) ->
          unit) *
         (string -> unit)
d593 1
a593 1
         ((string * string) * string) *
d603 1
a603 1
       val suppressed_frames = ref ["<anon>","<handle>","<Cframe>","<Setup>"] : string list ref
d610 1
a610 1
         (parameter,quit_continuation,continue_continuation)
d613 1
a613 3
           val Options.OPTIONS{print_options,environment_options,
                               compiler_options = 
                               Options.COMPILEROPTIONS{debug_polyvariables,...},...} = options
d615 2
d620 1
a620 3
           fun get_interpreter_information() =
	     InterMake.current_debug_information ()
	     (* Incremental.debug_info (!context_ref) *)
d626 1
a626 1
                      val debug_info as ((name,_),_) = get_data_from_frame frame
d633 1
a633 1
                                                  debug_info)
d652 4
d665 1
a665 1
		     (my_debug ("fewer than 6 frames"); true)
d668 1
a668 1
	       stack_empty' (top_frame, 6)
d675 1
a675 2
                   val (another,next,offset) =
		     MLWorks.Internal.Value.frame_next bottom
d749 1
a749 1
              val _ = infer_types (NORECIPE,frames);
d756 7
a762 4
               (* Omit the first two frames.  This is a hack *)
               case rev frames of
                 (_::_::rest) => rest
               | rest => rest
d768 1
a768 1
             | _ =>  (text ^ ValuePrinter.stringify_value arg ^ after)
d773 1
a773 1
             | make_frame_details (MLFRAME (f,((name,loc),st),arg,NOFRAMEINFO),_) _ =
d779 1
a779 1
                                            ((name,loc),st),
d786 5
a790 5
                          ValuePrinter.stringify_value (print_options,
                                                      arg,
                                                      inferredType,
                                                      get_interpreter_information())],
               implode[name," [",loc,"]",
d793 5
a797 4
                  (arg_type,arg,ValuePrinter.stringify_value (print_options,
                                                              arg,
                                                              inferredType,
                                                              get_interpreter_information()))
d804 1
a804 1
                                                        ValuePrinter.stringify_value 
d823 4
a826 3
                  val stuff = case frame of
                                CFRAME (_,name) => {name = name, loc = "",details = details}
                              | MLFRAME (_,((name,loc),_),_,_) => {name = name,loc = loc, details = details}
d834 1
d838 2
a839 2
              case parameter of
                EXCEPTION exn =>
d842 4
a845 5
                     ValuePrinter.stringify_value
		       (print_options,
                        MLWorks.Internal.Value.cast exn,
                        Datatypes.CONSTYPE([],Types.exn_tyname),
                        get_interpreter_information()),
d848 4
a851 4
              | SIGNAL s => "Unix signal " ^ MLWorks.Integer.makestring s ^ tail
              | BREAK s => "Break: " ^ s ^ tail
              | STACK_OVERFLOW => "Break on stack overflow" ^ tail
	    end
a863 1

d873 6
a878 3
              fun strip_space [] = []
                | strip_space (" "::rest) = strip_space rest
                | strip_space rest = rest
a879 4
              fun parse_command ([],acc) = (implode(rev acc),"")
                | parse_command (" "::rest,acc) = (implode(rev acc),implode (strip_space rest))
                | parse_command (h::t,acc) = parse_command (t,to_lowercase(h)::acc)
                  
d882 1
a882 1
                | edit_frame (MLFRAME (_,((_,loc),_),_,_)) =
d906 21
a926 12
                  " <        - go to the earliest frame in the stack",
                  " >        - go to the latest frame in the stack",
                  " i        - next frame INto the stack or next later frame (callee)",
                  " i <n>    - next n frames INto the stack",
                  " o        - next frame OUT of the stack or next earlier frame (caller)",
                  " o <n>    - next n frames OUT of the stack",
                  " b        - do a backtrace of the stack",
                  " f        - show full frame details",
                  " e        - edit definition",
                  " h <name> - hide frame type",
                  " r <name> - reveal frame type",
                  " p        - print values of local and closure variables",
d930 1
a930 1
                   POSSIBLE(st,_) => [" c        - " ^ st]
d933 1
a933 1
                      POSSIBLE(st,_) => [" q        - " ^ st]
d937 4
a940 6
                if debug_polyvariables then 
                  (fn name => 
                   String.substring(name,0,12) = "instance of "
                   handle String.Substring => false)
                else
                  fn _ => false
d992 1
a992 1
              |   get_previous_frames (above,below) n =
a1007 1
                  exception Zero
d1025 1
a1025 2
                        | " " => raise Finished(n)
                        | _ => raise Zero),power+1)
d1028 1
a1028 2
                  handle Zero => 0
                       | Finished(n) => n
a1030 5
	      fun output_current_frame_details (_, f::_) =
	        output_frame_details f
	      |   output_current_frame_details _ =
	        Crash.impossible "no current frame"
              
d1033 1
d1035 34
a1068 3
                  val _ = if end_of_stream std_in then do_quit() else ()
                  val line = get_line std_in
                  val (command,args) = parse_command(strip_space (explode line),[])
d1070 6
a1075 12
                  case (command,args) of
                    (">",_) =>
		    let val next = goto_top ((rev above) @@ below)
		    in output_current_frame_details next;
		       loop next
		    end
                  | ("<",_) =>
		    let val next = goto_bottom (above,below)
		    in output_current_frame_details next;
		       loop next
		    end
                  | ("f",_) =>
d1078 1
a1078 1
                  | ("e",_) =>
d1081 12
a1092 18
                  | ("i",arg) => 
		    let val next =
                          case string_to_int arg of 
                            0 => get_previous_frame (above,below)
                          | n => get_previous_frames (above,below) n
		    in output_current_frame_details next;
		       loop next
		    end
                  | ("o",arg) => 
		    let val next =
                          case string_to_int arg of 
                            0 => get_next_frame (above,below)
                          | n => get_next_frames (above,below) n
		    in output_current_frame_details next;
		       loop next
		    end
                  | ("b",_) => 
		      (output (std_out, "(Current frame)\n");
d1098 74
a1171 2
                  | ("c",_) => 
                      (do_continue();
d1173 9
a1181 5
                  | ("h","") => (outline ("\"h\" needs a frame type name");
				 loop(above,below))
                  | ("h",name) => (hide_frame_type name;
				   loop (above,below))
                  | ("q",_) =>
d1184 4
a1187 6
                  | ("r","") => (outline ("\"r\" needs a frame type name");
				 loop(above,below))
                  | ("r",name) => (reveal_frame_type name;
				   loop (above,below))
                  | ("",_) => loop (above,below)
                  | ("?",_) =>
d1233 1
a1233 1
                 | ("p",_) => 
d1242 1
a1242 1
                                   ValuePrinter.stringify_value 
a1260 1
	      val init_frames = goto_top frames
d1263 1
a1263 2
	      output_current_frame_details init_frames;
              loop init_frames
d1268 1
a1268 1
            let
d1270 1
a1270 1
	    in
d1274 5
a1278 2
		(outline ("Entering debugger " ^
			  "(type q to return to listener, or ? for help).");
d1280 1
a1280 1
            end
d1284 1
a1284 1
		let
a1295 1
                          val _ = my_debug "Selecting Window Debugger"
d1301 8
a1308 8
                                 frame_strings,
                                 fn s =>
                                 (ShellUtils.edit_string (s,!context_ref,options);())
                                 handle ShellUtils.EditFailed s =>
                                   send_message ("Edit failed: " ^ s),
                                 (make_continuation_function quit_continuation,
                                  make_continuation_function continue_continuation)
                                   );
d1310 1
a1310 1
			end
d1345 95
@


1.87
log
@CHanged substructure of InterMake.
@
text
@d4 3
d867 4
a870 1
                   
d1063 1
a1063 1
                  | ("help",_) =>
d1132 1
a1132 1
                  | _ => (display_help_info();
@


1.86
log
@The tty debugger was printing the wrong frame.
@
text
@d4 3
d331 1
a331 2
       structure FileName = InterMake.FileName
       structure Option = FileName.Option
d528 2
a529 2
                Incremental.InterMake.FileName.Option.option ref
                 Incremental.InterMake.FileName.Option.opt} list *
d531 2
a532 2
          ((unit -> unit) Incremental.InterMake.FileName.Option.opt *
           (unit -> unit) Incremental.InterMake.FileName.Option.opt) ->
@


1.85
log
@ Ignore stack extension frames in type inference
@
text
@d4 3
d882 1
a882 1
                   POSSIBLE(st,_) => [" c     - " ^ st]
d885 1
a885 1
                      POSSIBLE(st,_) => [" q     - " ^ st]
d946 1
a946 1
                | get_previous_frames (above,below) n =
d953 6
a958 2
              fun go_to_bottom (above,below) = 
                get_next_frames (above, below) (Lists.length below - 2)
d987 5
d1003 1
a1003 1
		    in output_frame_details this;
d1007 2
a1008 2
		    let val next = go_to_bottom (above,below)
		    in output_frame_details this;
d1022 1
a1022 1
		    in output_frame_details this;
d1030 1
a1030 1
		    in output_frame_details this;
d1132 1
a1132 5
	      case init_frames
	      of (_, this::_) =>
	        output_frame_details this
	      |  _ =>
		Crash.impossible "Empty initial stack";
@


1.84
log
@Added copyright message
@
text
@d4 3
d681 7
d691 4
a694 1
                     CFRAME _ => infer_types (NORECIPE,rest)
@


1.83
log
@Made make_frame_string tail recursive.
@
text
@d4 3
d268 1
@


1.82
log
@Removed with_frame_wrap.  Changed type of with_start_frame so that callers
don't have to provide a frame.  Changed several details of presentation to
make the TTY debugger more friendly.  Removed extraneous frames from list
of frames perused by debugger.  Coding in the number of frames to remove
is a gross hack, butI couldn't get anything else to work.
@
text
@d4 7
d761 12
a772 3
          fun make_frame_strings (frame::frames) =
            let
              val details = make_frame_details (frame,frames) true
d774 1
a774 4
             (case frame of
                CFRAME (_,name) => {name = name, loc = "",details = details}
              | MLFRAME (_,((name,loc),_),_,_) => {name = name,loc = loc, details = details})
                :: make_frame_strings frames
a775 2
            | make_frame_strings nil = nil
              
d1132 4
a1135 3
                      if tty_ok andalso
			 (empty orelse not (!window_debugger)) then
                        tty_debugger (top_frame, empty)
d1138 1
@


1.81
log
@Merging bug fixes
@
text
@d4 3
d571 3
a573 1
           fun get_interpreter_information() = InterMake.current_debug_information () (* Incremental.debug_info (!context_ref) *)
a574 17
           fun make_frames frame =
             let
              fun get_basic_frames (all as _::_) bottom =
                 let
                   val (another,next,offset) = MLWorks.Internal.Value.frame_next bottom
                 in
                   if another andalso next <> base_frame
                     then
                       get_basic_frames ((next,offset)::all) next
                   else
                     (if next <> base_frame then my_debug "No base frame" else ();
                        all)
                 end
                 | get_basic_frames _ _ = Crash.impossible "adjusted_base_frame in _ml_debugger"

              val basic_frames = get_basic_frames [(frame,0)] frame

d603 35
d690 5
d765 18
a782 11
          val parameter_details =
            case parameter of
              EXCEPTION exn =>
                "Uncaught exception " ^
                ValuePrinter.stringify_value (print_options,
                                              MLWorks.Internal.Value.cast exn,
                                              Datatypes.CONSTYPE([],Types.exn_tyname),
                                              get_interpreter_information())
            | SIGNAL s => "Break on SIGNAL " ^ MLWorks.Integer.makestring s
            | BREAK s => "Break: " ^ s
            | STACK_OVERFLOW => "Break on stack overflow"
d795 1
d836 3
a838 3
                  " <        - go to the latest frame in the stack",
                  " >        - go to the earliest frame in the stack",
                  " i        - next frame INto the stack or next earlier frame (caller)",
d840 1
a840 1
                  " o        - next frame OUT of the stack or next later frame (callee)",
d923 1
a923 1
                get_next_frames (above, below) (Lists.length below)
a954 1
                  val _ = output_frame_details this
d961 10
a970 4
                    ("<",_) => loop (goto_top ((rev above) @@ below))

                  | (">",_) => loop (go_to_bottom (above,below))
                      
d978 7
a984 3
                      loop (case string_to_int arg of 
                              0 => get_next_frame (above,below)
                            | n => get_next_frames (above,below) n)
d986 7
a992 3
                      loop (case string_to_int arg of 
                              0 => get_previous_frame (above,below)
                            | n => get_previous_frames (above,below) n)
d994 2
a995 1
                      (Lists.iterate
d998 1
d1003 4
a1006 2
                  | ("h","") => (outline ("\"h\" needs a frame type name");loop(above,below))
                  | ("h",name) => (hide_frame_type name;loop (above,below))
d1010 4
a1013 2
                  | ("r","") => (outline ("\"r\" needs a frame type name");loop(above,below))
                  | ("r",name) => (reveal_frame_type name;loop (above,below))
d1088 2
d1091 7
a1097 1
              loop (goto_top frames)
d1100 12
a1111 7
          fun tty_debugger top_frame =
             let
               val _ = outline parameter_details;
               val frames = make_frames top_frame
             in
               do_input frames
             end
d1114 17
a1130 13
           (fn top_frame =>
            case type_of_debugger of
              TERMINAL => tty_debugger top_frame
            | WINDOWING ((make_window,send_message),tty_ok) =>
                if tty_ok andalso not (!window_debugger) then
                  tty_debugger top_frame
                else
                  let
                    val _ = outline parameter_details
                    val frames = make_frames top_frame
                    val frame_strings = make_frame_strings frames
                  in
                    make_window (parameter_details,
d1139 3
a1141 2
                    ()
                  end)
d1146 13
a1158 14
       fun with_start_frame frame f =
         let
           val old_frame = !start_frame_ref
           val _ = start_frame_ref := frame
           val result = f () handle exn => (start_frame_ref := old_frame; raise exn)
         in
           start_frame_ref := old_frame;
           result
         end

       fun with_frame_wrap f =
         MLWorks.Internal.Value.frame_call
         (fn frame =>
          (with_start_frame frame f))
d1168 1
a1168 1
           val result = (with_frame_wrap f) handle exn => (debugger_type_ref := old_type; raise exn)
@


1.80
log
@Polymorphic debugger.
@
text
@d4 3
d10 4
d520 2
a521 1
         BREAK of string
d747 1
d1039 1
a1039 1
               val _ = outline "Debugger entered"
a1041 1
               outline parameter_details;
d1054 1
@


1.79
log
@Merging in bug fixes
@
text
@d4 3
a287 1
  sharing type RuntimeEnv.RuntimeEnv_type.spill = int
d394 1
a394 1
       fun get_arg_type(Datatypes.METATYVAR(ref(_,object),_,_)) = get_arg_type object
d398 1
a398 1
       fun get_res_type(Datatypes.METATYVAR(ref(_,object),_,_)) = get_res_type object
d439 1
a439 1
                                 Debugger_Types.INFO interpreter_information,
d469 1
a469 1
                            val (_,_,Debugger_Types.INFO mapping,_) = 
d553 3
a555 1
           val Options.OPTIONS{print_options,environment_options,...} = options
d671 1
a671 1
           fun make_frame_details (CFRAME f) _ =
d674 1
a674 1
             | make_frame_details (MLFRAME (f,((name,loc),st),arg,NOFRAMEINFO)) _ =
d683 1
a683 1
                                                      ref inferredType))) windowing =
d709 7
a715 1
                                                        options,true))))
d718 1
a718 1
          fun make_frame_strings frame =
d720 1
a720 1
              val details = make_frame_details frame true
d722 1
a722 1
              case frame of
d724 2
a725 1
              | MLFRAME (_,((name,loc),_),_,_) => {name = name,loc = loc, details = details}
d727 1
d743 1
a743 1
            outline (#1 (make_frame_details frame false))
d745 1
a745 1
            outline (#2 (make_frame_details frame false))
d812 11
a822 3
              fun ok_frame (CFRAME _) = not (Lists.member ("<Cframe>",!suppressed_frames))
                | ok_frame (MLFRAME (_,((name,_),_),_,_)) =
                  not (Lists.member (name,!suppressed_frames))
d845 3
a847 3
                  if ok_frame next
                    then (a,l)
                  else search (next::a,rest)
d872 2
a873 1
                   (l1,this :: l2) => get_previous_frames (l2,this ::l1) (n-1)
d937 1
a937 1
                       (fn f => if ok_frame f then output_frame_details f else ())
d1007 11
a1017 5
                                                   (print_options,
                                                    value,
                                                    Type,get_interpreter_information()),
                                                   MLWorks.Internal.Value.frame_offset,
                                                   options,false))))
d1047 1
a1047 1
                    val frame_strings = map make_frame_strings frames
@


1.78
log
@Return quit function from ShellUtils.edit_string
@
text
@d4 6
d555 2
a556 1
           fun get_interpreter_information() = Incremental.debug_info (!context_ref)
d610 3
a612 1
                      (my_debug ("Recipe problem" ^ problem);
a617 1
(*
a624 1
*)
d637 1
a637 1
                   | MLFRAME (_,_,_,FRAMEINFO(arg_type,annotation,_,tyref)) =>
d645 3
a647 1
                             | RECIPE (r,ty) => apply_recipe (r,ty) handle ApplyRecipe => arg_type
@


1.78.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.78  1993/08/25  15:02:10  matthew
Return quit function from ShellUtils.edit_string

@


1.78.1.2
log
@Get the debug_info using the global access function InterMake.current_debug_information
@
text
@d552 1
a552 2
           (* need to ensure that this is the latest stuff *)
           fun get_interpreter_information() = InterMake.current_debug_information () (* Incremental.debug_info (!context_ref) *)
d606 1
a606 3
                      (my_debug ("Recipe problem" ^ problem ^ "\n" ^
                                 "Annotation: " ^ Debugger_Types.print_backend_annotation annotation ^"\n" ^
                                 "Arg : " ^ Types.debug_print_type ty ^"\n");
d612 1
d620 1
d633 1
a633 1
                   | MLFRAME (_,((name,_),_),_,FRAMEINFO(arg_type,annotation,_,tyref)) =>
d641 1
a641 3
                             | RECIPE (r,ty) => apply_recipe (r,ty)
                                 handle ApplyRecipe => (my_debug ("recipe failure for " ^ name ^ "\n");
                                                        arg_type)
@


1.78.1.3
log
@Added STACK_OVERFLOW parameter type
Changed the debugger entry message to be more informative
@
text
@a3 3
Revision 1.78.1.2  1993/09/02  13:58:06  matthew
Get the debug_info using the global access function InterMake.current_debug_information

d508 1
a508 2
         BREAK of string |
         STACK_OVERFLOW
a723 1
            | STACK_OVERFLOW => "Break on stack overflow"
d1000 1
a1000 1
               val _ = outline parameter_details;
d1003 1
a1015 1
                    val _ = outline parameter_details
@


1.77
log
@ Tidied up edit failure messages.
Back traces now include current frame
@
text
@d4 4
d750 1
a750 1
                  ShellUtils.edit_string (loc,!context_ref,options)
d1016 1
a1016 1
                                 ShellUtils.edit_string (s,!context_ref,options)
@


1.76
log
@Removed Io structure.
@
text
@d4 3
d747 1
a747 1
                  handle ShellUtils.EditFailed s => outline ("Edit problem: " ^ s)
d904 1
a904 1
                       rest;
d1014 1
a1014 1
                                   send_message ("Edit Failed: " ^ s),
@


1.75
log
@Inspector invocation in debugger-window on values of local
and closure variables.
@
text
@d4 4
a238 1
require "../main/io";
a253 1
  structure Io : IO
a404 3
       val root_name = Io.root_name
       val mo_name = Io.mo_name
         
d408 14
@


1.74
log
@Changes for ShowFrameInfo option in debugger window.
@
text
@d4 3
d462 1
a462 2
       datatype TypeOfDebugger = 
         WINDOWING of
d465 8
a472 1
           details: string * string * string * (unit -> string) Option.opt} list *
d477 3
a479 2
         (string -> unit) *
         bool
d640 1
a640 1
              "",Option.ABSENT)
d644 1
a644 1
                "",
d661 5
a665 5
                          ValuePrinter.stringify_value (print_options,
                                                      arg,
                                                      inferredType,
                                                      get_interpreter_information())
               else "",
d667 2
a668 2
                   Option.PRESENT(fn ()=>"\n"
                                  ^RuntimeEnv.print_env(
d670 1
a670 1
                                                        fn (Type,offset) => 
d673 1
a673 2
                                                         MLWorks.Internal.Value.frame_offset
                                                         (f,offset),
d676 1
a676 1
                                                        options))
d953 1
a953 1
                             outfun (RuntimeEnv.print_env(
d955 1
a955 1
                               fn (Type,offset) => 
d958 1
a958 2
                                                    MLWorks.Internal.Value.frame_offset
                                                    (frame,offset),
d961 1
a961 1
                                                   options)))
d985 1
a985 1
            | WINDOWING (make_window,send_message,tty_ok) =>
@


1.73
log
@Improved frame relative naming.
@
text
@d4 3
d462 2
a463 1
          {name : string, loc : string, details: string * string} list *
d628 4
a631 3
           fun make_frame_details (CFRAME f) =
             ("<Cframe> " ^ MLWorks.Integer.makestring (MLWorks.Internal.Value.cast f),"")
             | make_frame_details (MLFRAME (f,((name,loc),st),arg,NOFRAMEINFO)) =
d633 3
a635 1
                implode["[",loc,"]"])
d639 2
a640 2
                                            FRAMEINFO(arg_type,annotation,_,
                                                      ref inferredType))) =
d642 3
a644 1
                        ValuePrinter.stringify_value (print_options,
d649 20
a668 1
                       ":",Types.print_type print_options inferredType])
d672 1
a672 1
              val details = make_frame_details frame
d693 1
a693 1
            outline (#1 (make_frame_details frame))
d695 1
a695 1
            outline (#2 (make_frame_details frame))
d944 1
a944 1
                             (RuntimeEnv.print_env(
@


1.72
log
@Debugger Environments for local and closure variable inspection
in the debugger;
enhanced debugger commands.
@
text
@d4 5
d713 6
a718 3
                  " <        - go to the top of the stack",
                  " n        - next frame down the stack",
                  " p        - next frame up the stack",
d724 1
d768 2
a769 2
                 handle Search => (outline "No next frame"; (above,below)))
                | get_next_frame x = (outline "No next frame"; x)
d774 2
a775 2
                   handle Search => (outline "No next frame"; (above,below)))
                | get_next_frames x _ = (outline "No next frame"; x)
d780 2
a781 2
                 | _ => (outline "No previous frame"; (above,below)))
                handle Search => (outline "No previous frame"; (above,below))
d787 2
a788 2
                 | _ => (outline "No previous frame"; (above,below)))
                handle Search => (outline "No previous frame"; (above,below))
d840 1
a840 1
                  | ("n",arg) => 
d844 1
a844 1
                  | ("p",arg) => 
d910 1
a910 1
                 | ("pr",_) => 
a975 1
           val _ = output(std_out,"\n result ... \n")
a976 1
           val _ = output(std_out,"\n ... result \n")
@


1.71
log
@Improved frame filtering
@
text
@d4 3
d226 1
a230 1

d242 1
d244 1
a244 1
  sharing GetTypeInformation.Debugger_Types.Options = ShellUtils.Options =
d259 4
d277 1
d326 4
a329 3
                             ((string,
                               Datatypes.Type * bool *
                               (int * Debugger_Types.Backend_Annotation) list) NewMap.T)) 
d446 2
a447 2
             NewMap.YES (lookup,is_leaf,annotations) =>
               (lookup,is_leaf,annotations,source_file)
d456 2
a457 2
          ((unit -> unit) Incremental.InterMake.FileName.Option.T *
           (unit -> unit) Incremental.InterMake.FileName.Option.T) ->
d479 2
a480 1
         Datatypes.Type * Debugger_Types.Backend_Annotation * Datatypes.Type ref |
d514 1
a514 1
              fun get_basic_frames(all as (bottom,_)::_) =
d520 1
a520 1
                       get_basic_frames ((next,offset)::all)
d525 1
a525 1
                 | get_basic_frames _ = Crash.impossible "adjusted_base_frame in _ml_debugger"
d527 1
a527 1
              val basic_frames = get_basic_frames [(frame,0)]
d537 1
a537 1
                          val (ty,is_leaf,annotations,source_file) =
d546 2
a547 1
                          FRAMEINFO (arg_type,current_annotation,ref Datatypes.NULLTYPE)
d591 1
a591 1
                   | MLFRAME (_,_,_,FRAMEINFO(arg_type,annotation,tyref)) =>
d627 1
a627 1
                                            FRAMEINFO(arg_type,annotation,
d682 1
a682 1
                | parse_command (" "::rest,acc) = (implode(rev acc),implode rest)
d761 6
d774 38
d823 16
a846 6
                  | ("e",_) =>
                      (edit_frame this;
                       loop (above,below))
                  | ("f",_) =>
                      (output_full_frame_details this;
                       loop (above,below))
a848 2
                  | ("n",_) => loop (get_next_frame (above,below))
                  | ("p",_) => loop (get_previous_frame (above,below))
d865 1
a865 1
                          Datatypes.UNBOUND_SCHEME Types.empty_rectype,
d889 1
a889 1
                                         Datatypes.UNBOUND_SCHEME ty',
d901 18
d967 1
d969 1
@


1.70
log
@Added function continuation
@
text
@d4 3
d485 2
d608 1
a608 1
             ("C frame at " ^ MLWorks.Integer.makestring (MLWorks.Internal.Value.cast f),"")
d696 8
a703 6
                  " <     - go to the top of the stack",
                  " n     - next frame down the stack",
                  " p     - next frame up the stack",
                  " b     - do a backtrace of the stack",
                  " f     - show full frame details",
                  " e     - edit definition",
d705 1
a705 1
                  " help  - display this help info"] @@
d712 23
a734 4
                
              fun ok_frame (CFRAME _) = false
                | ok_frame (MLFRAME _) = true
                  
d766 1
a766 9
                      
                  | ("f",_) =>
                      (output_full_frame_details this;
                       loop (above,below))
                  | ("e",_) =>
                      (edit_frame this;
                       loop (above,below))
                  | ("n",_) => loop (get_next_frame (above,below))
                  | ("p",_) => loop (get_previous_frame (above,below))
a771 3
                      
                  | ("",_) => loop (above,below)

d775 10
d788 3
a790 1

@


1.69
log
@Added window_debugger option
Added tty_ok option to WINDOWINF
@
text
@d4 4
d457 2
a458 1
         DO_RAISE of exn
d479 1
d678 2
a679 2
                 | POSSIBLE(_,DO_RAISE exn) => raise exn)
                   
d684 2
a685 1
                 | POSSIBLE(_,DO_RAISE exn) => raise exn)
@


1.68
log
@Fixed problem with previous frame in tty debugger
@
text
@d4 3
a263 2
       val window_debugger = true

d442 2
a443 1
         (string -> unit)
d484 3
a486 1
           val Options.OPTIONS{print_options,...} = options
d824 2
a825 2
            | WINDOWING (make_window,send_message) =>
                if not (window_debugger) then
@


1.67
log
@Removed integer parameter
@
text
@d4 3
d711 1
a711 1
                | get_next_frame x = x
d714 4
a717 4
                let val (l1,l2) = search (below,above) handle Search => (below,above)
                in
                  (l2,l1)
                end
@


1.66
log
@ Added message function to Windowing debugger
Added with_start_frame
@
text
@d4 4
a202 1
require "../utils/integer" ;
d215 11
a225 12
functor Ml_Debugger
  (structure Integer : INTEGER
   structure Lists : LISTS
   structure Crash : CRASH
   structure Types : TYPES
   structure Incremental : INCREMENTAL
   structure ShellUtils : SHELL_UTILS
   structure ValuePrinter : VALUE_PRINTER
   structure GetTypeInformation : GETTYPEINFORMATION
   structure DebuggerTypeUtilities : DEBUGGER_TYPE_UTILITIES       
   structure Io : IO
   structure Tags : TAGS
d227 6
a232 6
   sharing GetTypeInformation.Debugger_Types.Options = ShellUtils.Options =
     Types.Options = ValuePrinter.Options = Incremental.InterMake.Inter_EnvTypes.Options
   sharing GetTypeInformation.Debugger_Types =
     DebuggerTypeUtilities.Debugger_Types
   sharing Incremental.Datatypes = Types.Datatypes
   sharing GetTypeInformation.Debugger_Types.NewMap = Types.Datatypes.NewMap
d234 9
a242 9
   sharing type Incremental.Context = ShellUtils.Context
   sharing type GetTypeInformation.Debugger_Types.information =
     ValuePrinter.DebugInformation = Incremental.InterMake.Compiler.DebugInformation
   sharing type Types.Datatypes.Type = GetTypeInformation.Debugger_Types.Type =
     ValuePrinter.Type
   sharing type GetTypeInformation.TypeBasis = ValuePrinter.TypeBasis =
     Incremental.InterMake.Compiler.TypeBasis
   sharing type GetTypeInformation.ParserBasis  = Incremental.InterMake.Compiler.ParserBasis
     ) : ML_DEBUGGER =
d590 1
a590 1
             ("C frame at " ^ Integer.makestring (MLWorks.Internal.Value.cast f),"")
d624 1
a624 1
            | SIGNAL s => "Break on SIGNAL " ^ Integer.makestring s
@


1.65
log
@Changed argument of ml_debugger from Incremental.options to Options.options.
Removed lots of commented out code.
@
text
@d4 4
d430 7
a436 6
         string * 
         {name : string, loc : string, details: string * string} list *
         (string -> unit) *
         ((unit -> unit) Incremental.InterMake.FileName.Option.T *
          (unit -> unit) Incremental.InterMake.FileName.Option.T) ->
         unit
d656 1
a656 1
                  ShellUtils.edit_source (loc,!context_ref,options)
d815 1
a815 1
            | WINDOWING make_window =>
d826 3
a828 2
                                 ShellUtils.edit_source (s,!context_ref,options)
                                 handle ShellUtils.EditFailed _ => (),
d848 5
d861 1
a861 1
           val result = f () handle exn => (debugger_type_ref := old_type; raise exn)
@


1.64
log
@Partial implementation of frame selection in tty debugger
Added quit and continue options to windowing debugger.
@
text
@d4 4
a220 1
   sharing GetTypeInformation.Info = Incremental.InterMake.Compiler.Info
d372 1
a372 2
       fun get_type_information (error_info,
                                 options,
d404 1
a404 1
                              GetTypeInformation.get_type_information error_info options file
d466 1
a466 2
         (inc_options as Incremental.OPTIONS{error_info,options,...},
          context_ref)
d502 1
a502 2
                            get_type_information (error_info,
                                                  options,
d751 1
a751 1
                          #1(Incremental.add_value inc_options
d775 1
a775 1
                                     #1(Incremental.add_value inc_options
a859 260
   
(* Removed, keep the code though *)
(*
             TRACE (arg,closure) => 
               (let
                 open MLWorks.Internal.Value
                 val _ = debug(fn _ => "Inside trace code\n")
                 val primary = primary closure
                 val debug_info = 
                   code_name (sub (closure, if primary = Tags.PAIRPTR then 0 else 1))
                 val _ = debug(fn _ => "Getting debugging information\n")
               in
                 let
                   val (ty,is_leaf,annotations,source_file) =
                     get_type_information (error_info,
                                           options,
                                           get_interpreter_information(),
                                           debug_info,
                                           true)
                   val _ = debug(fn _ => "Getting arg and res types\n")
                   val arg_ty = get_arg_type ty
                   val res_ty = get_res_type ty
                 in
                   if DebuggerTypeUtilities.is_type_polymorphic arg_ty
                     then
                       MLWorks.Internal.Value.frame_call
                       (fn top_frame =>
                        let
                          val _ = debug(fn _ => "Dealing with a polymorphic trace\n")
                          val return_print =
                            ref(fn _ => output(std_out,"Return from " ^ debug_info ^ "\n"))
                          val (_,top_frame,_) = 
                          MLWorks.Internal.Value.frame_next top_frame
                          val (_,top_frame,_) = 
                            MLWorks.Internal.Value.frame_next top_frame
                          val dummy_frames = 
                            [(top_frame,
                              TO_BE_INSTANTIATED
                              (debug_info,
                               "",
                               fn inferred_type => 
                               let
                                 val f_type = DebuggerTypeUtilities.check_type(inferred_type,ty)
                                 val _ =
                                   output(std_out,"Trace of " ^ debug_info ^ 
                                          " applied to " ^
                                          ValuePrinter.stringify_value
                                          (print_options,
                                           arg,
                                           get_arg_type f_type,
                                           get_interpreter_information()) ^
                                          "\n")
                                 val _ =
                                   return_print := 
                                   (fn result => 
                                    let
                                      val res_ty =
                                        get_res_type f_type
                                    in
                                      if DebuggerTypeUtilities.is_type_polymorphic res_ty
                                        then
                                          output(std_out,"Return from " ^ debug_info ^ "\n")
                                      else 
                                        (output(std_out,
                                                "Return " ^
                                                ValuePrinter.stringify_value 
                                                (print_options,
                                                 result,
                                                 res_ty,
                                                 get_interpreter_information()) ^ 
                                                " from " ^ debug_info ^ "\n")
                                        handle _ => 
                                          output(std_out,"Return from " ^ debug_info ^ "\n"))
                                    end)
                               in
                                 (debug_info,
                                  "",
                                  Datatypes.NULLTYPE,
                                  f_type)
                               end,
                             ref ""))]
                          val _ = debug(fn _ => "dealing with the backtrace\n")
                          val (_,fr) = 
                            deal_with_next_monomorphic(dummy_frames,false) 
                          val _ = debug(fn _ => "Checking the result\n")
                        in
                          case rev fr of
                            (_,OK (_,_,input_ty)) :: _ =>
                              ! return_print
                          | _ => 
                              (output(std_out,"Trace of " ^ debug_info ^ 
                                      " which is polymorphic\n");
                             fn _ => output(std_out,"Return from " ^ debug_info ^ "\n"))
                        end)
                   else 
                   (debug(fn _ => "monomorphic case\n");
                    output(std_out,"Trace of " ^ debug_info ^ 
                           " applied to " ^
                           ValuePrinter.stringify_value (print_options,
                                                         arg,
                                                         arg_ty,
                                                         get_interpreter_information()) ^ "\n");
                    fn result => 
                    (output(std_out,
                            "Return " ^
                            ValuePrinter.stringify_value (print_options,
                                                          result,
                                                          res_ty,
                                                          get_interpreter_information()) ^ 
                            " from " ^ debug_info ^ "\n")))
                 end
               handle FailedToGetTypeInfo => 
                 (output(std_out,"Entering function " ^ debug_info ^ "\n");
                  fn _ => output(std_out,"Return from " ^ debug_info ^ "\n"))
               end
             handle MLWorks.Internal.Value.Value _  => 
               (output(std_out,"Entering a traced function\n");
                fn _ => output(std_out,"Returns\n")))
*)
(*
             fun do_input (previous_frames,
                           frames as ((current as (current_frame,current_info))::rest_of_frames)) =
             let 
               val _ = output(std_out,"\n")
               val _ = output_frame_details current_info
               val _ = output(std_out,"MLWorks Debugger> ")
               val _ = MLWorks.IO.flush_out (std_out)
               val _ = if end_of_stream std_in then MLWorks.exit 0 else ()
               val command' = get_line std_in
               fun to_lowercase x =
                 let
                   val v = ord x
                 in
                   if v >= 65 andalso v <= 90
                     then chr(v + 32)
                   else x
                 end
               fun strip_space [] = []
                 | strip_space (" "::rest) = strip_space rest
                 | strip_space rest = rest
               fun parse_command ([],acc) = (implode(rev acc),"")
                 | parse_command (" "::rest,acc) = (implode(rev acc),implode rest)
                 | parse_command (h::t,acc) = parse_command (t,to_lowercase(h)::acc)
               val (command,args) = parse_command(strip_space (explode command'),[])
             in
               case (command,args,frames,previous_frames) of

                 ("<",_,_,_) => 
                   do_input(do_top(previous_frames,frames))

                | ("n","",_,(h,info)::t) =>
                   do_input(t,(h,info)::frames)
                    
               | ("n","",_,[]) =>
                   do_input(do_next(current_frame,frames,true))

               | ("n",function_name,_,_) =>
                   do_input(do_next_function_name(function_name,current_frame,frames,true))

               | ("bv",_,_,_) => 
                   (do_backtrace(rest_of_frames,[current],true);
                    do_input(previous_frames,frames))

               | ("b",_,_,_) =>
                   (do_simple_backtrace current_frame;
                    do_input (previous_frames,frames))

               | ("nm",_,_,(top as (_,OK _)) :: rest) =>
                   do_input(rest,top::frames)

               | ("nm",_,_,_) =>
                   do_input(deal_with_next_monomorphic(rev(previous_frames) @@ frames,true))
                 
               | ("p","",[_],_) =>
                   (output(std_out,"Currently at the top of the ML stack\n");
                    do_input (previous_frames,frames))
                   
               | ("p","",top::old,prev) => 
                   do_input (top::prev,old)

               | ("p",function_name,_,_) => 
                   do_input(do_previous_named(function_name,previous_frames,frames))
                   
               | ("",_,_,_) => do_input (previous_frames,frames)
                   
               | ("c",_,_,_) => 
                   (case continue_continuation of
                      NOT_POSSIBLE => 
                        (display_help_info();
                         do_input (previous_frames,frames))
                    | POSSIBLE(_,NORMAL_RETURN) => ()
                    | POSSIBLE(_,DO_RAISE exn) => raise exn)

               | ("q",_,_,_) => 
                   (case quit_continuation of
                      NOT_POSSIBLE => do_input (previous_frames,frames)
                    | POSSIBLE(_,NORMAL_RETURN) => ()
                    | POSSIBLE(_,DO_RAISE exn) => raise exn)
                        
               | ("help",_,_,_) => (display_help_info();
                                    do_input (previous_frames,frames))

               | ("shell",_,_,_) => 
                   let
                     fun update_it_to_unit () =
                       #1(Incremental.add_value inc_options
                          (!context_ref,"it",
                           Datatypes.UNBOUND_SCHEME Types.empty_rectype,
                           MLWorks.Internal.Value.cast 0))
               
                     fun update_it_to_value() =
                       (case current_info of 
                          (OK (x,_,ty)) => 
                            let
                              val ty' = get_arg_type ty
                              val is_nulltype = 
                                case ty' of
                                  Datatypes.NULLTYPE => true
                                | _ => false
                            in
                              if is_nulltype orelse DebuggerTypeUtilities.is_type_polymorphic(ty')
                                then
                                  update_it_to_unit()
                              else
                                let
                                  val arg = 
                                    get_value_from_frame (current_frame,I0)   
                                in
                                  #1(Incremental.add_value inc_options
                                     (!context_ref,"it",
                                      Datatypes.UNBOUND_SCHEME ty',
                                      MLWorks.Internal.Value.cast arg))
                                end
                            end
                        | _ => update_it_to_unit())
                          
                     val context' = update_it_to_value()
                       
                   in
                     execute_function context';
                     do_input (previous_frames,frames)
                   end

               | _ => (display_help_info();
                       do_input (previous_frames,frames))

             end      
             | do_input _ = Crash.impossible "inside _ml_debugger 2"
*)
(*
           fun deal_with_frame (top_frame,print_instantiated) = 
             let
               val (_,first_frame,first_offset) = frame_next top_frame
               val top = (first_frame,
                          #1(calculate_frame_status (first_frame,first_offset,[],
                                                     print_instantiated)))
             in
               top
             end
*)
@


1.63
log
@Removed printer descriptors.
@
text
@d4 3
d422 50
a471 46
    datatype TypeOfDebugger = 
      WINDOWING of
      string * 
      {name : string, loc : string, details: string * string} list *
      (string -> unit) -> unit
    | TERMINAL

    datatype parameter =
      SIGNAL of int
    | EXCEPTION of exn
    | BREAK of string
(*
    | TRACE of MLWorks.Internal.Value.ml_value * MLWorks.Internal.Value.ml_value
*)
                    
    datatype Continuation_action =
      NORMAL_RETURN | 
      DO_RAISE of exn

    datatype Continuation =
      POSSIBLE of string * Continuation_action |
      NOT_POSSIBLE

    datatype FrameInfo =
      FRAMEINFO of
      Datatypes.Type * Debugger_Types.Backend_Annotation * Datatypes.Type ref |
      NOFRAMEINFO

    datatype FrameSpec = 
      MLFRAME of
        MLWorks.Internal.Value.frame *
        ((string * string) * string) *
        MLWorks.Internal.Value.T *
        FrameInfo |
      CFRAME of (MLWorks.Internal.Value.frame * string)

    fun ml_debugger 
        type_of_debugger
        (inc_options as Incremental.OPTIONS{error_info,options,...},
         context_ref)
        execute_function
        base_frame
        (parameter,quit_continuation,continue_continuation)
        =
        let
          val Options.OPTIONS{print_options,...} = options
d473 1
a473 1
          fun get_interpreter_information() = Incremental.debug_info (!context_ref)
d475 2
a476 2
          fun make_frames frame =
            let
d478 11
a488 26
                let
                  val (another,next,offset) = MLWorks.Internal.Value.frame_next bottom
                in
                  if another andalso next <> base_frame
                    then
                      get_basic_frames ((next,offset)::all)
                  else
                    (if next <> base_frame then my_debug "No base frame" else ();
                     all)
                end
                | get_basic_frames _ = Crash.impossible "adjusted_base_frame in _ml_debugger"

(*
              val _ = 
                if do_my_debug
                  then
                    let val Debugger_Types.INFO i = get_interpreter_information()
                      val dom = NewMap.domain i
                    in
                      my_debug("Interpreter info is");
                      Lists.iterate my_debug dom;
                      my_debug ("That was interpreter info")
                    end
                else
                  ();
*)
d570 6
a575 6
            in
              (* Omit the first two frames.  This is a hack *)
              case rev frames of
                (_::_::rest) => rest
                | rest => rest
            end
d577 22
a598 22
          fun print_argument (text,arg as (_,_,ty,_),after) =
            case ty of
              Datatypes.NULLTYPE => ""
            | _ =>  (text ^ ValuePrinter.stringify_value arg ^ after)

          fun make_frame_details (CFRAME f) =
            ("C frame at " ^ Integer.makestring (MLWorks.Internal.Value.cast f),"")
            | make_frame_details (MLFRAME (f,((name,loc),st),arg,NOFRAMEINFO)) =
              (implode[name,"<??>"],
               implode["[",loc,"]"])
            | make_frame_details (MLFRAME (f,
                                          ((name,loc),st),
                                          arg,
                                          FRAMEINFO(arg_type,annotation,
                                                    ref inferredType))) =
              (implode[name,
                       ValuePrinter.stringify_value (print_options,
                                                     arg,
                                                     inferredType,
                                                     get_interpreter_information())],
              implode[name," [",loc,"]",
                      ":",Types.print_type print_options inferredType])
d628 93
a720 70
           fun do_input frames =
             let 
               exception Exit
               fun to_lowercase x =
                 let
                   val v = ord x
                 in
                   if v >= 65 andalso v <= 90
                     then chr(v + 32)
                   else x
                 end

               fun strip_space [] = []
                 | strip_space (" "::rest) = strip_space rest
                 | strip_space rest = rest

               fun parse_command ([],acc) = (implode(rev acc),"")
                 | parse_command (" "::rest,acc) = (implode(rev acc),implode rest)
                 | parse_command (h::t,acc) = parse_command (t,to_lowercase(h)::acc)

               fun edit_frame (CFRAME _) =
                 outline "Cannot edit source for C frame"
                 | edit_frame (MLFRAME (_,((_,loc),_),_,_)) =
                   ShellUtils.edit_source (loc,!context_ref,options)
                   handle ShellUtils.EditFailed s => outline ("Edit problem: " ^ s)

               fun do_continue() =
                 (case continue_continuation of
                    NOT_POSSIBLE => outline "Cannot Continue"
                  | POSSIBLE(_,NORMAL_RETURN) => raise Exit
                  | POSSIBLE(_,DO_RAISE exn) => raise exn)

               fun do_quit() =
                 (case quit_continuation of
                    NOT_POSSIBLE => outline "Cannot Quit"
                  | POSSIBLE(_,NORMAL_RETURN) => raise Exit
                  | POSSIBLE(_,DO_RAISE exn) => raise exn)

               fun display_help_info () =
                 Lists.iterate
                 outline
                 (["Commands:",
                   " <     - go to the top of the stack",
                   " n     - next frame down the stack",
                   " p     - next frame up the stack",
                   " b     - do a backtrace of the stack",
                   " f     - show full frame details",
                   " e     - edit definition",
                   (* " shell - start a subshell (binding 'it' to frame argument)", *)
                   " help  - display this help info"] @@
                 (case continue_continuation of
                    POSSIBLE(st,_) => [" c     - " ^ st]
                  | _ => []) @@
                    (case quit_continuation of
                       POSSIBLE(st,_) => [" q     - " ^ st]
                     | _ => []))

               fun loop (above, below as (this::rest)) =
                 let
                   val _ = output_frame_details this
                   val _ = prompt "Debugger> "
                   val _ = if end_of_stream std_in then do_quit() else ()
                   val line = get_line std_in
                   val (command,args) = parse_command(strip_space (explode line),[])
                 in
                   case (command,args) of
                     ("<",_) =>
                       loop ([],(rev above) @@ below)

                   | ("f",_) =>
d723 1
a723 1
                   | ("e",_) =>
d726 20
a745 27
                   | ("n",_) =>
                       (case rest of
                          [] => (outline "Bottom of stack"; loop (above,below))
                        | _ => loop (this :: above,rest))

                   | ("b",_) => 
                       (Lists.iterate output_frame_details rest;
                        loop (above,below))

                   | ("p",_) =>
                       (case above of
                          [] => (outline "Top of stack";
                                 loop (above,below))
                        | (next :: rest) => loop (rest,next::below))

                   | ("",_) => loop (above,below)

                   | ("c",_) => 
                       (do_continue();
                        loop (above,below))
                   | ("q",_) =>
                       (do_quit ();
                        loop (above,below))

                   | ("help",_) =>
                       (display_help_info();
                        loop (above,below))
d748 34
a781 33
                     | ("shell",_) => 
                         let
                           fun update_it_to_unit () =
                             #1(Incremental.add_value inc_options
                                (!context_ref,"it",
                                 Datatypes.UNBOUND_SCHEME Types.empty_rectype,
                                 MLWorks.Internal.Value.cast 0))
               
                           fun update_it_to_value() =
                             (case current_info of 
                                (OK (x,_,ty)) => 
                                  let
                                    val ty' = get_arg_type ty
                                    val is_nulltype = 
                                      case ty' of
                                        Datatypes.NULLTYPE => true
                                      | _ => false
                                  in
                                    if is_nulltype orelse DebuggerTypeUtilities.is_type_polymorphic(ty')
                                      then
                                        update_it_to_unit()
                                    else
                                      let
                                        val arg = 
                                          get_value_from_frame (this,I0)   
                                      in
                                        #1(Incremental.add_value inc_options
                                           (!context_ref,"it",
                                            Datatypes.UNBOUND_SCHEME ty',
                                            MLWorks.Internal.Value.cast arg))
                                      end
                                  end
                              | _ => update_it_to_unit())
d783 5
a787 5
                           val context' = update_it_to_value()
                         in
                           execute_function context';
                           loop (above,below)
                         end
d789 9
a797 9
                   | _ => (display_help_info();
                           loop (above,below))
                 end
                 | loop _ = Crash.impossible "inside input loop"
             in
               loop ([],frames)
               handle Exit => ()
             end
           fun tty_debugger top_frame =
d805 53
a857 22
        in
          MLWorks.Internal.Value.frame_call
          (fn top_frame =>
           case type_of_debugger of
             TERMINAL => tty_debugger top_frame
           | WINDOWING make_window =>
               if not (window_debugger) then
                 tty_debugger top_frame
               else
                 let
                   val frames = make_frames top_frame
                   val frame_strings = map make_frame_strings frames
                 in
                   make_window (parameter_details,
                                frame_strings,
                                fn s =>
                                ShellUtils.edit_source (s,!context_ref,options)
                                handle ShellUtils.EditFailed _ => ()
                                );
                   ()
                 end)
        end
d860 1
@


1.62
log
@Changed edit function interface
@
text
@d4 3
d457 1
a457 2
        (print_method_table,
         inc_options as Incremental.OPTIONS{error_info,options,...},
a467 4
          val print_descriptor = 
            ValuePrinter.PRINTER_DESCRIPTOR{print_method_table=print_method_table,
                                            print_options=print_options}
                                                                 
d601 1
a601 1
                       ValuePrinter.stringify_value (print_descriptor,
d621 1
a621 1
                ValuePrinter.stringify_value (print_descriptor,
d816 1
a816 2
                 end);
          fn _ => ()
d866 1
a866 1
                                          (print_descriptor,
d885 1
a885 1
                                                (print_descriptor,
d917 1
a917 1
                           ValuePrinter.stringify_value (print_descriptor,
d924 1
a924 1
                            ValuePrinter.stringify_value (print_descriptor,
@


1.61
log
@Changed do_my_debug to false
@
text
@d4 3
d190 1
a199 1
   structure Types : TYPES
d202 4
a206 1
   structure ValuePrinter : VALUE_PRINTER
a207 1
   structure Incremental : INCREMENTAL
d212 1
a212 1
   sharing GetTypeInformation.Debugger_Types.Options =
d218 2
d236 4
a239 1
       structure Info = Incremental.InterMake.Compiler.Info
a355 9
       fun find_source_file locdata =
         let
           fun aux1(":"::l,acc) = implode(rev acc)
             | aux1(c::l,acc) = aux1(l,c::acc)
             | aux1([],acc) = implode(rev acc)
         in
           aux1(explode locdata,[])
         end
         
d368 9
d417 4
a420 1
      WINDOWING of string * (string * string) list * (string -> string) -> unit
d450 1
a450 1
      CFRAME of MLWorks.Internal.Value.frame
d528 1
a528 1
                  CFRAME(frame)
a577 1
              (* returns the frame objects from bottom to top *)
d579 1
d581 4
a584 2
              infer_types (NORECIPE,frames);
              rev frames
d592 1
a592 1
          fun make_frame_string (CFRAME f) =
d594 1
a594 1
            | make_frame_string (MLFRAME (f,((name,loc),st),arg,NOFRAMEINFO)) =
d597 1
a597 1
            | make_frame_string (MLFRAME (f,
d609 9
d630 8
d658 6
a663 8
               fun outfun s = output(std_out,s)
               fun outline s = outfun (s ^ "\n")
               fun output_frame_details frame =
                 outline (#1 (make_frame_string frame))
               fun output_full_frame_details frame =
                 outline (#2 (make_frame_string frame))
               fun prompt s = (outfun s; MLWorks.IO.flush_out std_out)
                   
d685 1
d710 3
d790 8
d802 1
a802 6
             TERMINAL =>
               let val frames = make_frames top_frame
               in
                 output(std_out,parameter_details ^ "\n");
                 do_input frames
               end
d805 1
a805 5
                 let val frames = make_frames top_frame
                 in
                   output(std_out,parameter_details ^ "\n");
                   do_input frames
                 end
a807 18
                   val current_module = ""
                   fun lookup_function filename =
                     let
                       val sml_filename =
                         Io.sml_name filename
                     in
                       if size sml_filename <= size current_module
                         andalso String.substring(current_module,
                                                  size current_module - size sml_filename,
                                                  size sml_filename) = sml_filename
                         then
                           String.substring(current_module,0,
                                            size current_module - size sml_filename)
                       else
                         Incremental.find_module
                         (!context_ref,
                          Incremental.InterMake.FileName.parse_absolute ("/tmp/" ^ filename))
                     end
d809 1
a809 1
                   val frame_strings = map make_frame_string frames
d813 3
a815 1
                                lookup_function
@


1.60
log
@Rewritten
@
text
@d4 3
d238 1
a238 1
       val do_my_debug = true
@


1.59
log
@Much diddling.
@
text
@d4 3
d196 1
a196 1
   structure Get_Type_Information : GETTYPEINFORMATION
d198 1
a198 1
   structure Debugger_Type_Utilities : DEBUGGER_TYPE_UTILITIES       
d203 2
a204 2
   sharing Get_Type_Information.Info = Incremental.InterMake.Compiler.Info
   sharing Get_Type_Information.Debugger_Types.Options =
d206 2
a207 2
   sharing Get_Type_Information.Debugger_Types =
     Debugger_Type_Utilities.Debugger_Types
d209 2
a210 2
   sharing Get_Type_Information.Debugger_Types.NewMap = Types.Datatypes.NewMap
   sharing type Get_Type_Information.Debugger_Types.information =
d212 1
a212 1
   sharing type Types.Datatypes.Type = Get_Type_Information.Debugger_Types.Type =
d214 1
a214 1
   sharing type Get_Type_Information.TypeBasis = ValuePrinter.TypeBasis =
d216 1
a216 1
   sharing type Get_Type_Information.ParserBasis  = Incremental.InterMake.Compiler.ParserBasis
d224 2
a225 2
       structure Debugger_Types = Get_Type_Information.Debugger_Types
       structure Debugger_Type_Utilities = Debugger_Type_Utilities
d230 1
a230 3
       val window_debugger = false

       val show_compiler_frames = ref false
d235 2
a236 2
       val do_mydebug = false
       fun mydebug x = if do_mydebug then output(std_out,x ^ "\n") else ()
d249 1
a249 1
               fun duff () = mydebug ("Odd codename:"^code_name^":")
a272 11
       (* Print out an argument value *)
       fun print_argument (text,arg as (_,_,ty,_),after) =
         case ty of
           Datatypes.NULLTYPE => ""
         | _ =>  (text ^ ValuePrinter.stringify_value arg ^ after)
             
       fun print_type options (base,ty,after) =
         case ty of
           Datatypes.NULLTYPE => ""
         | _ => (base ^ Types.print_type options ty ^ after)

d314 1
a314 20
       datatype Frame = 
         (* Printed information and function type *)
         OK of string * string * Datatypes.Type 
          (* Printed information, passed on type and function instance type *)
         | TO_BE_INSTANTIATED of
           (string * 
            string *
            (Datatypes.Type -> (string * string * Datatypes.Type * Datatypes.Type)) *
            string ref)

       fun output_frame_details(OK (x,y,_)) =
         output(std_out,x ^ "\n" ^ y ^ "\n")
         | output_frame_details(TO_BE_INSTANTIATED(x,y,_,_)) = 
           output(std_out,x ^ "\n" ^ y ^ "\n")

       fun short_output_frame_details (OK (x,y,_)) = 
         output(std_out,x ^ y ^ "\n")
         | short_output_frame_details(TO_BE_INSTANTIATED (x,y,_,_)) =
           output(std_out,x ^ y ^ "\n")

a316 12
(*
       (* This isn't used *)
       fun position_to_emacs_position x =
         let
           fun remove_comma [] = [")"]
             | remove_comma (","::t) = " " :: remove_comma t
             | remove_comma (h::t) = h :: remove_comma t
         in
           implode("'(" :: remove_comma (explode x))
         end
*)

d325 2
a326 1
       fun get_line file =
d329 1
a329 1
             if end_of_stream file then
d333 1
a333 1
                 val char = input(file, 1)
d356 7
a362 5
       
       fun get_type_information 
         (error_info,options)
         (Debugger_Types.INFO interpreter_information)
         (((function_name,loc),st),message_on_fail) =
a363 1
           val _ = debug(fn _ => "Entering get_type_information\n")
a364 1
           val _ = mydebug("Name:" ^ function_name ^ ":source_file: " ^ source_file ^ ":")
d369 3
a371 27
               (let
                 val file = root_name(! default_path ^ source_file)
                 val result = cache_lookup file
                   handle CacheFail =>
                     if !show_compiler_frames
                       then
                         let
                           val _ =
                             output(std_out,
                                    "Reading type information from file " ^ 
                                    file ^ 
                                    " - please wait ...\n")
                           val (_,_,Debugger_Types.INFO mapping,_) = 
                             Get_Type_Information.get_type_information error_info options file
                           val _ = 
                             add_to_cache(file,mapping)
                         in
                           mapping
                         end
                     else
                       NewMap.empty (fn _ => false,fn _ => true)
               in
                 result
               end
             handle Io arg => 
               (if message_on_fail
                  then 
d373 16
a388 3
                      val _ = output(std_out,arg ^ "\n");
                      val _ = output(std_out,"Hit enter to fail or type the required filename\n")
                      val line = get_line std_in
d390 1
a390 5
                      if line=""
                        then 
                          NewMap.empty (fn _ => false,fn _ => true)
                      else
                        find_in_file line
d393 2
a394 2
                  NewMap.empty (fn _ => false,fn _ => true)))
                  
a395 1
             
d415 4
d420 16
a435 6
      POSSIBLE of string * Continuation_action
             | NOT_POSSIBLE
    and Continuation_action =
      NORMAL_RETURN
      | DO_RAISE of exn
        
d454 1
a454 1
          fun calculate_frame_status (current,offset,other_frames,indent,print_instantiated) =
d456 12
a467 6
              val _ = debug(fn _ => "Entering display frame status\n")
              val debug_info as ((name,loc),_) = get_data_from_frame current
              fun conditional_output x =
                if print_instantiated
                  then output(std_out,x)
                else ()
d469 14
a482 60
            in
              (let
                val (ty,is_leaf,annotations,source_file) = 
                  get_type_information
                  (error_info,options)
                  (get_interpreter_information())
                  (debug_info,true)
                  
                val arg = get_value_from_frame (current,I0)
                val arg_type = get_arg_type ty
                val current_annotation = 
                  Lists.assoc (4 * offset,annotations) 
                  handle Lists.Assoc => Debugger_Types.Nop

                val _ = debug(fn _ =>
                              "Offset " ^ Integer.makestring offset ^ "\n" ^
                              "Annotation " ^ 
                              Debugger_Types.print_backend_annotation current_annotation ^
                              "\n")
  
                fun print((_,OK _)::_) = ()
                  | print((_,TO_BE_INSTANTIATED(x,y,_,_))::rest) = 
                    (print rest; conditional_output(x ^ "\n" ^ y ^ "\n"))
                  | print _ = Crash.impossible "inside _ml_debugger 6"

                fun propogate_new_type_information (ty,[]) = []
                   | propogate_new_type_information 
                     (ty,all_frames as ((frame,TO_BE_INSTANTIATED(details,_,infer,errors))::rest)) =
                     (let
                       val _ = debug(fn _ => 
                                     "propogating using the type " ^
                                     Types.debug_print_type (ty()) ^ "\n")
                         
                       val (res_frame,res_arg,ty',function_type) = 
                         infer (ty())
                       val result = (frame,OK(res_frame,res_arg,function_type)) 
                         :: propogate_new_type_information(fn () => ty',rest)
                     in
                       conditional_output(res_frame ^ "\n" ^ res_arg ^ "\n") ;
                       result
                     end
                   handle Debugger_Type_Utilities.InValidMatch problem => 
                     (if print_instantiated
                        then 
                          (output(std_out,problem);
                           print all_frames)
                      else 
                        errors := problem;
                        all_frames)
                        | Debugger_Type_Utilities.RecipeApplicationProblem problem =>
                            (let
                              val message =
                                "RecipeApplicationProblem " ^ problem ^ 
                                " - can't deduce types due to tail calls or polymorphic closures\n"
                            in
                              if print_instantiated
                                then output(std_out,message)
                              else errors := message
                            end;
                            all_frames))
d484 1
a484 1
                   | propogate_new_type_information (ty,rest) = rest
d486 27
a512 82
               in
                 if Debugger_Type_Utilities.is_type_polymorphic arg_type
                   then
                     let
                       val _ = debug(fn _ => "Into polymorphic case\n")
                       val general_type = 
                         print_type print_options (indent ^ "General type: ",ty,"\n")
                     in
                     (TO_BE_INSTANTIATED
                      (name,
                       indent ^ general_type,
                       fn inferred_type => 
                       let
                         val _ = debug(fn _ => "Checking type\n")
                         val f_type = Debugger_Type_Utilities.check_type(inferred_type,ty)
                         val _ = debug(fn _ => "Checked type\n")
                       in
                         (name,
                          indent ^ general_type ^
                          indent ^ "Instance type : " ^ 
                          Types.print_type print_options f_type ^ "\n" ^
                          indent ^ "Inferred input type " ^ 
                          Types.print_type print_options inferred_type ^ "\n" ^
                          print_argument(indent ^ "Argument: ",
                                         (print_descriptor,
                                          arg,
                                          get_arg_type f_type,
                                          get_interpreter_information()),
                                         "\n"),
                          Debugger_Type_Utilities.apply_recipe(current_annotation,inferred_type),
                          f_type)
                       end,
                     ref ""),
                      other_frames)
                     end
                 else
                   let
                     val _ = debug(fn _ => "Monomorphic case\n")
                     val string_argument = 
                       print_argument (indent ^ "Argument: ",
                                       (print_descriptor,
                                        arg,arg_type,
                                        get_interpreter_information()),
                                       "\n")
                   in
                     (OK(name,
                         print_type print_options (indent ^ "General type: ",ty,"\n") ^
                         string_argument,ty),
                      propogate_new_type_information
                      (fn () =>
                       Debugger_Type_Utilities.apply_recipe(current_annotation,arg_type),
                       other_frames))
                   end
               end)
                  handle String.Substring => 
                    (OK(name,"",Datatypes.NULLTYPE),
                     other_frames)
                    | FailedToGetTypeInfo =>
                        (OK(name,"",Datatypes.NULLTYPE),
                         other_frames)
                    | Match => (OK(name,"",
                                   Datatypes.NULLTYPE),other_frames)
             end
             
          fun display_help_info () =
             (output(std_out, "\nCommands\n");
              output(std_out, " <     - go to the top of the stack \n");
              output(std_out, " n     - next frame down the stack \n");
              output(std_out, " nm    - go down the stack to the next monomorphic frame \n");
              output(std_out, " p     - next frame up the stack \n");
              output(std_out, " bv    - do a backtrace of the stack \n");
              output(std_out, " b     - do a backtrace of the stack without values\n");
              output(std_out, " shell - start a subshell (binding it to frame argument)\n");
              output(std_out, " help  - display this help info\n");
              (case continue_continuation of
                 POSSIBLE(st,_) => 
                   output(std_out, " c     - " ^ st ^ " \n")
               | _ => ());
                 (case quit_continuation of
                    POSSIBLE(st,_) => 
                      output(std_out, " q     - " ^ st ^ " \n")
                  | _ => ()))
d514 2
a515 3
          val adjusted_base_frame =
            let
              fun frames(all as (h::_)) =
d517 9
a525 4
                  val (another,current,_) = 
                    MLWorks.Internal.Value.frame_next h
                  val _ = mydebug ("Frame = " ^
                                   Integer.makestring (MLWorks.Internal.Value.cast current))
d527 10
a536 9
                  if another andalso current <> base_frame
                    then 
                      frames (current::all)
                  else
                    (if another then debug (fn _ => "Base frame found\n")
                       else debug (fn _ => "Base frame not found\n");
                     case all of
                       (_::_::this::_) => this
                     | _ => Crash.impossible "No enough frames")
d538 26
a563 1
                | frames _ = Crash.impossible "adjusted_base_frame in _ml_debugger"
d565 2
a566 7
              MLWorks.Internal.Value.frame_call
              (fn top_frame =>
               (mydebug ("BaseFrame = " ^
                         Integer.makestring (MLWorks.Internal.Value.cast base_frame));
                mydebug ("TopFrame = " ^
                         Integer.makestring (MLWorks.Internal.Value.cast top_frame));
                frames [top_frame]))
d569 33
a601 126
          fun frame_next current_frame = 
            if adjusted_base_frame = current_frame
              then (false,current_frame,0)
            else 
              let
                val result = MLWorks.Internal.Value.frame_next current_frame
              in
                case result of
                  (_,next_frame,0) => frame_next next_frame
                | _ => result
              end

           fun do_next(current_frame,frames,print_instantiated) =
             let
               val (another,next_frame,offset) = frame_next current_frame
             in
               if another
                 then 
                   let
                     val (status,new_frames) = 
                       calculate_frame_status (next_frame,offset,frames,"",print_instantiated)
                   in
                     ([],(next_frame,status)::new_frames)
                   end
               else (if print_instantiated 
                       then output(std_out,"At the bottom of the stack\n")
                     else ();
                     ([],frames))
             end
           
           fun do_previous_named(name,previous,[top]) =
             (previous,[top])
             
             | do_previous_named(name,previous,(top as (current,_))::rest) =
               let
                 val ((this_name,_),_) = get_data_from_frame current
                 val len = size name
                 val max = size this_name - len
                 fun search x =
                   if x > max
                     then false
                   else String.substring(this_name,x,len) = name orelse search(x+1)
               in
                 if search 0
                   then (previous,top::rest)
                 else do_previous_named(name,top::previous,rest)
               end
             | do_previous_named _ = Crash.impossible "inside _ml_debugger 5"                 
               
           fun do_next_function_name(name,current_frame,frames,print_instantiated) =
             let
               val (another,next_frame,offset) = frame_next current_frame
             in
               if another
                 then 
                   let
                     val (status,new_frames) = 
                       calculate_frame_status (next_frame,offset,frames,"",print_instantiated)
                     val ((this_name,_),_) = get_data_from_frame next_frame
                     val len = size name
                     val max = size this_name - len
                     fun search x =
                       if x> max
                         then false
                       else String.substring(this_name,x,len) = name (* orelse search(x+1) *)
                   in
                     if search 0
                       then
                         ([],(next_frame,status)::new_frames)
                     else
                       do_next_function_name(name,
                                             next_frame,
                                             (next_frame,status)::new_frames,
                                             true)
                   end
               else (output(std_out,"At the bottom of the stack\n");
                     ([],frames))
             end

             fun deal_with_next_monomorphic(frames as ((current_frame,_)::_),print_instantiated) =
               let
                 val (new_frames,status) = 
                   case do_next(current_frame,frames,print_instantiated) of 
                     (_,new_frames as ((_,status)::_)) => (new_frames,status)
                   | _ => Crash.impossible "problem case (ii) in _ml_debugger"
               in
                 case status of
                  OK _ => ([],new_frames)
                | TO_BE_INSTANTIATED _ =>
                    deal_with_next_monomorphic(new_frames,print_instantiated)
               end
               | deal_with_next_monomorphic _ = Crash.impossible "inside _ml_debugger 1"

             fun do_backtrace(additional_frames,
                              frames as ((top as (current_frame,details)) :: _),
                              print) =
               let
                 val _ = if print then short_output_frame_details details else ()
                 val result = #2(do_next(current_frame,frames,print))
               in
                 if Lists.length result = Lists.length frames
                   then ([],frames @@ additional_frames)
                 else do_backtrace(additional_frames,result,print)
               end
               | do_backtrace _ = Crash.impossible "inside _ml_debugger 1"

             fun do_simple_backtrace frame =
               let
                 val ((name,_),_) = get_data_from_frame frame
                 val _ = output(std_out,name ^ "\n")
                 val (another,next,_) = frame_next frame
               in
                 if another 
                   then do_simple_backtrace next
                 else output(std_out,"\n")
               end

             fun do_top(previous_frames,frames) =
               let
                 val (top,rest) = 
                   case rev frames @@ previous_frames of 
                     (top::rest) => (top,rest)
                   | _ => Crash.impossible "problem case (i) in _ml_debugger"
               in
                 (rest,[top])
               end
d603 1
a603 2
             fun do_input (previous_frames,
                           frames as ((current as (current_frame,current_info))::rest_of_frames)) =
d605 1
a605 6
               val _ = output(std_out,"\n")
               val _ = output_frame_details current_info
               val _ = output(std_out,"MLWorks Debugger> ")
               val _ = MLWorks.IO.flush_out (std_out)
               val _ = if end_of_stream std_in then MLWorks.exit 0 else ()
               val command' = get_line std_in
d614 1
d618 1
a621 6
               val (command,args) = parse_command(strip_space (explode command'),[])
             in
               case (command,args,frames,previous_frames) of

                 ("<",_,_,_) => 
                   do_input(do_top(previous_frames,frames))
d623 7
a629 26
                | ("n","",_,(h,info)::t) =>
                   do_input(t,(h,info)::frames)
                    
               | ("n","",_,[]) =>
                   do_input(do_next(current_frame,frames,true))

               | ("n",function_name,_,_) =>
                   do_input(do_next_function_name(function_name,current_frame,frames,true))

               | ("bv",_,_,_) => 
                   (do_backtrace(rest_of_frames,[current],true);
                    do_input(previous_frames,frames))

               | ("b",_,_,_) =>
                   (do_simple_backtrace current_frame;
                    do_input (previous_frames,frames))

               | ("nm",_,_,(top as (_,OK _)) :: rest) =>
                   do_input(rest,top::frames)

               | ("nm",_,_,_) =>
                   do_input(deal_with_next_monomorphic(rev(previous_frames) @@ frames,true))
                 
               | ("p","",[_],_) =>
                   (output(std_out,"Currently at the top of the ML stack\n");
                    do_input (previous_frames,frames))
d631 5
a635 2
               | ("p","",top::old,prev) => 
                   do_input (top::prev,old)
d637 23
a659 12
               | ("p",function_name,_,_) => 
                   do_input(do_previous_named(function_name,previous_frames,frames))
                   
               | ("",_,_,_) => do_input (previous_frames,frames)
                   
               | ("c",_,_,_) => 
                   (case continue_continuation of
                      NOT_POSSIBLE => 
                        (display_help_info();
                         do_input (previous_frames,frames))
                    | POSSIBLE(_,NORMAL_RETURN) => ()
                    | POSSIBLE(_,DO_RAISE exn) => raise exn)
d661 42
a702 8
               | ("q",_,_,_) => 
                   (case quit_continuation of
                      NOT_POSSIBLE => do_input (previous_frames,frames)
                    | POSSIBLE(_,NORMAL_RETURN) => ()
                    | POSSIBLE(_,DO_RAISE exn) => raise exn)
                        
               | ("help",_,_,_) => (display_help_info();
                                    do_input (previous_frames,frames))
d704 8
a711 7
               | ("shell",_,_,_) => 
                   let
                     fun update_it_to_unit () =
                       #1(Incremental.add_value inc_options
                          (!context_ref,"it",
                           Datatypes.UNBOUND_SCHEME Types.empty_rectype,
                           MLWorks.Internal.Value.cast 0))
d713 25
a737 25
                     fun update_it_to_value() =
                       (case current_info of 
                          (OK (x,_,ty)) => 
                            let
                              val ty' = get_arg_type ty
                              val is_nulltype = 
                                case ty' of
                                  Datatypes.NULLTYPE => true
                                | _ => false
                            in
                              if is_nulltype orelse Debugger_Type_Utilities.is_type_polymorphic(ty')
                                then
                                  update_it_to_unit()
                              else
                                let
                                  val arg = 
                                    get_value_from_frame (current_frame,I0)   
                                in
                                  #1(Incremental.add_value inc_options
                                     (!context_ref,"it",
                                      Datatypes.UNBOUND_SCHEME ty',
                                      MLWorks.Internal.Value.cast arg))
                                end
                            end
                        | _ => update_it_to_unit())
d739 10
a748 19
                     val context' = update_it_to_value()
                       
                   in
                     execute_function context';
                     do_input (previous_frames,frames)
                   end

               | _ => (display_help_info();
                       do_input (previous_frames,frames))

             end      
             | do_input _ = Crash.impossible "inside _ml_debugger 2"

           fun deal_with_frame (top_frame,indent,print_instantiated) = 
             let
               val (_,first_frame,first_offset) = frame_next top_frame
               val top = (first_frame,
                          #1(calculate_frame_status (first_frame,first_offset,[],indent,
                                                     print_instantiated)))
d750 2
a751 1
               top
a752 10
           val parameter_details =
             case parameter of
               EXCEPTION exn =>
                 "Uncaught exception " ^
                 ValuePrinter.stringify_value (print_descriptor,
                                               MLWorks.Internal.Value.cast exn,
                                               Datatypes.CONSTYPE([],Types.exn_tyname),
                                               get_interpreter_information())
             | SIGNAL s => "Break on SIGNAL " ^ Integer.makestring s
             | BREAK s => "Break: " ^ s
d758 5
a762 2
               (output(std_out,"Debugger entered\n" ^ parameter_details ^ "\n");
                do_input([],[deal_with_frame (top_frame,"",false)]))
d765 5
a769 2
                 (output(std_out,"Debugger entered\n" ^ parameter_details ^ "\n");
                  do_input([],[deal_with_frame (top_frame,"",false)]))
d790 2
a791 6
                   val frames =                    
                     rev
                     (map 
                      (fn (_,OK(x,y,_)) => (x,y)
                    | (_,TO_BE_INSTANTIATED(x,_,_,ref y)) => (x,y))
                      (#2(do_backtrace([],[deal_with_frame (top_frame,"",false)],false))))
d794 1
a794 1
                                frames,
d815 6
a820 2
                   val (ty,is_leaf,annotations,source_file) = 
                     get_type_information(error_info,options) (get_interpreter_information()) (debug_info,true)
d825 1
a825 1
                   if Debugger_Type_Utilities.is_type_polymorphic arg_ty
d844 1
a844 1
                                 val f_type = Debugger_Type_Utilities.check_type(inferred_type,ty)
d861 1
a861 1
                                      if Debugger_Type_Utilities.is_type_polymorphic res_ty
d920 141
@


1.58
log
@ Signature changes
@
text
@d4 3
d227 2
d231 6
a236 1
       fun debug(x) = () (*output(std_out,x())*)
a238 2
       val shorten_backtrace = true

d246 15
d264 2
d267 1
a267 1
           code_name (sub (closure, if primary = Tags.PAIRPTR then 0 else 1))
a270 2
           

d312 1
d328 15
a342 10
         | TO_BE_INSTANTIATED of (string * 
                                  string *
                                  (Datatypes.Type -> (string * string * Datatypes.Type * Datatypes.Type)) *
                                  string ref)

         fun output_frame_details(OK (x,y,_)) = output(std_out,x ^ "\n" ^ y ^ "\n")
           | output_frame_details(TO_BE_INSTANTIATED(x,y,_,_)) = output(std_out,x ^ "\n" ^ y ^ "\n")

         fun output_frame_details_if_instantiated(OK (x,y,_)) = output(std_out,x ^ "\n" ^ y ^ "\n")
           | output_frame_details_if_instantiated(TO_BE_INSTANTIATED _) = ()
d346 2
d356 1
d358 7
d366 16
a381 7
           fun get_arg_type(Datatypes.METATYVAR(ref(_,object),_,_)) = get_arg_type object
             | get_arg_type(Datatypes.FUNTYPE (arg,_)) = arg
             | get_arg_type x = Datatypes.NULLTYPE

           fun get_res_type(Datatypes.METATYVAR(ref(_,object),_,_)) = get_res_type object
             | get_res_type(Datatypes.FUNTYPE (_,res)) = res
             | get_res_type x = Datatypes.NULLTYPE
d383 45
a427 10
           fun get_line file =
             let
               fun extend_line line =
                 if end_of_stream file then
                   line
                 else
                   let
                     val char = input(file, 1)
                   in
                     if char = "\n" then line
d429 30
a458 91
                       extend_line(line ^ char)
                   end
             in
               extend_line ""
             end

           fun find_source_file_and_name_and_position x =
             let
               fun find(pos,direction,findchar) = 
                 let
                   val char = String.substring(x,pos,1)
                 in
                   if  char = findchar
                     then pos
                   else find(pos+direction,direction,findchar)
                 end
               val end_of_file_name = find (size x - 1,~1,":")
               val start_of_file_name = find(end_of_file_name-1,~1," ")

             in
               (String.substring(x,0,start_of_file_name),
                String.substring(x,start_of_file_name+1,end_of_file_name - start_of_file_name - 1),
                String.substring(x,end_of_file_name+1,size x - end_of_file_name - 1))
             end
           handle String.Substring => (x,"","")

           val root_name = Io.root_name
           val mo_name = Io.mo_name

           exception FailedToGetTypeInfo 

           fun get_type_information 
             (error_info,options)
             (Debugger_Types.INFO interpreter_information)
             (st,message_on_fail) =
             let
               val _ = debug(fn _ => "Entering get_type_information\n")
               val (function_name,source_file,position) = find_source_file_and_name_and_position st
               val _ = debug(fn _ => "Name: " ^ function_name ^ "\nsource_file: " ^ source_file ^ "\n")

               fun find_in_file source_file =
                 (NewMap.apply interpreter_information st;
                  interpreter_information)
                 handle NewMap.Undefined => 
                   (let
                     val file = root_name(! default_path ^ source_file)
                     val result = cache_lookup file
                       handle CacheFail =>
                         if !show_compiler_frames
                           then
                             let
                               val _ =
                                 output(std_out,"Reading type information from file " ^ file ^ " - please wait ...\n")
                               val (_,_,Debugger_Types.INFO mapping,_) = 
                                 Get_Type_Information.get_type_information error_info options file
                               val _ = 
                                 add_to_cache(file,mapping)
                             in
                               mapping
                             end
                         else
                           NewMap.empty (fn _ => false,fn _ => true)
                   in
                     result
                   end
                 handle Io arg => 
                   (if message_on_fail
                      then 
                        let
                          val _ = output(std_out,arg ^ "\n");
                          val _ = output(std_out,"Hit enter to fail or type the required filename\n")
                          val line = get_line std_in
                        in
                          if line=""
                            then 
                              NewMap.empty (fn _ => false,fn _ => true)
                          else
                            find_in_file line
                        end
                    else
                      NewMap.empty (fn _ => false,fn _ => true)))
                      
               val mapping = find_in_file source_file
                 
             in
               case NewMap.tryApply mapping st of
                 NewMap.YES (lookup,is_leaf,annotations) =>
                   (lookup,is_leaf,annotations,source_file,position)
               | _ => raise FailedToGetTypeInfo
             end

d467 1
d469 1
a477 4
    datatype BackTraceType =
      BASE_FRAME of MLWorks.Internal.Value.frame |
      NO_BASE_FRAME

d499 1
a499 3
              val debug_info = get_data_from_frame current
              val _ = debug(fn _ => "Retrieved debug_info is " ^ debug_info ^ "\n")
                
d507 5
a511 2
                val (ty,is_leaf,annotations,source_file,position) = 
                  get_type_information (error_info,options) (get_interpreter_information()) (debug_info,true)
d519 5
a523 2
                val _ = debug(fn _ => "Offset " ^ Integer.makestring offset ^ "\n" ^
                               "Annotation " ^ Debugger_Types.print_backend_annotation current_annotation ^ "\n")
d526 2
a527 2
                  | print((_,TO_BE_INSTANTIATED(x,y,_,_))::rest) = (print rest ; 
                                                                    conditional_output(x ^ "\n" ^ y ^ "\n"))
d577 1
a577 1
                      (debug_info,
d585 1
a585 1
                         (debug_info,
d587 4
a590 2
                          indent ^ "Instance type : " ^ Types.print_type print_options f_type ^ "\n" ^
                          indent ^ "Inferred input type " ^ Types.print_type print_options inferred_type ^ "\n" ^
d613 1
a613 1
                     (OK(debug_info,
d617 2
a618 1
                      (fn () => Debugger_Type_Utilities.apply_recipe(current_annotation,arg_type),
d623 2
a624 1
                    (OK(debug_info,"No debugging data available\n",Datatypes.NULLTYPE),other_frames)
d626 3
a628 2
                        (OK(debug_info,"No debugging data available\n",Datatypes.NULLTYPE),other_frames)
                    | Match => (OK(debug_info,"No debugging data available\n",
d632 1
a632 1
           fun display_help_info () =
d651 41
a691 40
           val adjusted_base_frame =
             if shorten_backtrace
               then
                 case base_frame of
                   NO_BASE_FRAME => base_frame
                 | BASE_FRAME base =>
                     let
                       fun frames(all as (h::_)) =
                         let
                           val (another,current,_) = 
                             MLWorks.Internal.Value.frame_next h
                         in
                           if another andalso current <> base
                             then 
                               frames (current::all)
                           else
                             case all of
                               [] => NO_BASE_FRAME
                             | [_] => NO_BASE_FRAME
                             | [_,_] => NO_BASE_FRAME
                             | (_::_::this::_) => BASE_FRAME this
                         end
                         | frames _ = Crash.impossible "adjusted_base_frame in _ml_debugger"
                     in
                       MLWorks.Internal.Value.frame_call
                       (fn top_frame =>
                        frames [top_frame])
                     end
             else
               NO_BASE_FRAME
                     
           fun frame_next current_frame = 
             case adjusted_base_frame of
               NO_BASE_FRAME => 
                 MLWorks.Internal.Value.frame_next current_frame
             | BASE_FRAME base =>
               if base = current_frame
                 then (false,current_frame,0)
               else 
                 MLWorks.Internal.Value.frame_next current_frame
d716 1
a716 1
                 val debug_info = get_data_from_frame current
d718 3
a720 3
                 val max = size debug_info - len
                 fun search (x) =
                   if x> max
d722 1
a722 1
                   else String.substring(debug_info,x,len) = name orelse search(x+1)
d737 3
a739 2
                     val (status,new_frames) = calculate_frame_status (next_frame,offset,frames,"",print_instantiated)
                     val debug_info = get_data_from_frame next_frame
d741 2
a742 2
                     val max = size debug_info - len
                     fun search (x) =
d745 1
a745 1
                       else String.substring(debug_info,x,len) = name (* orelse search(x+1) *)
d751 4
a754 1
                       do_next_function_name(name,next_frame,(next_frame,status)::new_frames,true)
d774 3
a776 1
             fun do_backtrace(additional_frames,frames as ((top as (current_frame,details)) :: _),print) =
d778 1
a778 1
                 val _ = if print then output_frame_details_if_instantiated details else ()
d789 2
a790 2
                 val debug_info = get_data_from_frame frame
                 val _ = output(std_out,debug_info ^ "\n")
a938 1
               val _ = debug(fn _ => "Entering get next frame\n")
d940 3
a942 5
               val _ = debug(fn _ => "Entering get data from frame\n")
               val top_debug_info = get_data_from_frame first_frame
               val _ = debug(fn _ => "Entering calculate frame status\n")
               val top = (first_frame,#1(calculate_frame_status (first_frame,first_offset,[],indent,
                                                                 print_instantiated)))
d946 57
d1004 2
a1005 2
         in
           case parameter of
d1016 2
a1017 2
                   val (ty,is_leaf,annotations,source_file,position) = 
                     get_type_information (error_info,options) (get_interpreter_information()) (debug_info,true)
d1117 1
a1117 60
           | _ => 
               let
                 val parameter_details =
                   case parameter of
                     EXCEPTION exn =>
                       "Uncaught exception " ^
                       ValuePrinter.stringify_value (print_descriptor,
                                                     MLWorks.Internal.Value.cast exn,
                                                     Datatypes.CONSTYPE([],Types.exn_tyname),
                                                     get_interpreter_information())
                   | SIGNAL s => "Break on SIGNAL " ^ Integer.makestring s
                   | BREAK s => "Break: " ^ s
                   | _ => ""
               in
                 MLWorks.Internal.Value.frame_call
                 (fn top_frame =>
                  case type_of_debugger of
                    TERMINAL =>
                      (output(std_out,"Debugger entered\n" ^ parameter_details ^ "\n");
                       do_input([],[deal_with_frame (top_frame,"",false)]))
                  | WINDOWING make_window => 
                      let
                        val current_module = ""
                        fun lookup_function filename =
                          let
                            val sml_filename =
                              Io.sml_name filename
                          in
                            if size sml_filename <= size current_module
                              andalso String.substring(current_module,
                                                       size current_module - size sml_filename,
                                                       size sml_filename) = sml_filename
                              then
                                String.substring(current_module,0,
                                                 size current_module - size sml_filename)
                            else
                              Incremental.find_module
                              (!context_ref,
                               Incremental.InterMake.FileName.parse_absolute ("/tmp/" ^ filename))
                          end
                        val frames =                    
                          rev
                          (map 
                           (fn (_,OK(x,y,_)) => (x,y)
                         | (_,TO_BE_INSTANTIATED(x,_,_,ref y)) => (x,y))
                           (#2(do_backtrace([],[deal_with_frame (top_frame,"",false)],false))))
                      in
                        make_window (parameter_details,
                                     frames,
                                     lookup_function
                                     );
                        ()
                      end);
                 fn _ => ()
               end
             end
                 
     end


@


1.57
log
@Removed current module parameter from ml_debugger
Fixed "bv" so as not to change the frame stack
@
text
@d4 4
d199 1
a199 1
     Types.Options
d201 1
a201 2
     Debugger_Type_Utilities.Debugger_Types = ValuePrinter.Debugger_Types =
     Incremental.InterMake.Compiler.Debugger_Types
d204 4
a207 1
   sharing type Types.Datatypes.Type = Get_Type_Information.Debugger_Types.Type
@


1.56
log
@Added call to flush_out on prompting
@
text
@d4 3
d456 1
a456 2
         context_ref,
         current_module)
d806 2
a807 1
                   do_input(do_backtrace(rest_of_frames,[current],true))
d1043 1
d1054 1
a1054 1
                                String.substring(current_module ,0,
@


1.55
log
@Simplified interface to debugger
Signature revisions
@
text
@d4 4
d770 1
@


1.54
log
@Options & Info changes
Incremental changes
Absyn changes
@
text
@d4 5
d191 4
a194 2
     Incremental.InterMake.Compiler.MirTypes.Debugger_Types
   sharing Types.Datatypes = Get_Type_Information.Debugger_Types.Datatypes
d365 1
a365 1
             (error_info,print_options)
d387 1
a387 1
                                 Get_Type_Information.get_type_information error_info print_options file
d448 1
a448 1
         options as Incremental.OPTIONS{error_info,options = Options.OPTIONS(_,_,print_options),...},
d456 1
a456 3

          (* what is this context for? *)
          val context = !context_ref
d458 1
a458 1
          val interpreter_information = Incremental.debug_info context
d478 1
a478 1
                  get_type_information (error_info,print_options) (interpreter_information) (debug_info,true)
d557 1
a557 1
                                          interpreter_information),
d572 1
a572 1
                                        interpreter_information),
d843 2
a844 2
                       #1(Incremental.add_value options
                          (context,"it",
d866 2
a867 2
                                  #1(Incremental.add_value options
                                     (context,"it",
d913 1
a913 1
                     get_type_information (error_info,print_options) (interpreter_information) (debug_info,true)
d945 1
a945 1
                                           interpreter_information) ^
d964 1
a964 1
                                                 interpreter_information) ^ 
d996 1
a996 1
                                                         interpreter_information) ^ "\n");
d1003 1
a1003 1
                                                          interpreter_information) ^ 
d1022 1
a1022 1
                                                     interpreter_information)
d1049 1
a1049 1
                              (context,
@


1.53
log
@empty_rec_type to empty_rectype
@
text
@d4 3
d181 3
a183 3
   sharing Get_Type_Information.Debugger_Types.Info =
     Incremental.InterMake.Compiler.Parser.Lexer.Info =
     Types.Info
a186 3
   sharing Get_Type_Information.BasisTypes = ValuePrinter.BasisTypes =
     Incremental.InterMake.Compiler.BasisTypes
   sharing Get_Type_Information.Parser  = Incremental.InterMake.Compiler.Parser
d188 3
d196 2
a197 3
       structure BasisTypes = Get_Type_Information.BasisTypes
       structure Datatypes = BasisTypes.Datatypes
       structure Parser = Get_Type_Information.Parser
d200 1
a200 2
       structure NewMap = Debugger_Types.Datatypes.NewMap
       structure Info = BasisTypes.Info
d202 1
d358 1
a358 1
             info_opts
d380 1
a380 1
                                 Get_Type_Information.get_type_information info_opts file
d440 4
a443 2
        info_opts
        (print_descriptor,options,context,current_module)
d449 4
d455 4
d473 1
a473 1
                  get_type_information info_opts (interpreter_information) (debug_info,true)
d533 1
a533 1
                         print_type info_opts (indent ^ "General type: ",ty,"\n")
d546 2
a547 2
                          indent ^ "Instance type : " ^ Types.print_type info_opts f_type ^ "\n" ^
                          indent ^ "Inferred input type " ^ Types.print_type info_opts inferred_type ^ "\n" ^
d571 1
a571 1
                         print_type info_opts (indent ^ "General type: ",ty,"\n") ^
d908 1
a908 1
                     get_type_information info_opts (interpreter_information) (debug_info,true)
@


1.52
log
@Added break option and changed debugger message.
@
text
@d4 3
d828 1
a828 1
                           Datatypes.UNBOUND_SCHEME Types.empty_rec_type,
@


1.51
log
@Typechecker structure changes
@
text
@d4 3
d419 1
d998 1
d1003 2
a1004 1
                   | SIGNAL s => "SIGNAL " ^ Integer.makestring s
d1011 1
a1011 3
                      (output(std_out,
                              "\nException on entry to debugger:" ^ 
                              parameter_details ^ "\n");
@


1.50
log
@Changed functor parameter
@
text
@d4 3
d178 2
a179 2
   sharing Get_Type_Information.Basis = ValuePrinter.Basis =
     Incremental.InterMake.Compiler.Basis
d187 2
a188 2
       structure Basis = Get_Type_Information.Basis
       structure Datatypes = Get_Type_Information.Debugger_Types.Datatypes
d193 1
a193 1
       structure Info = Get_Type_Information.Debugger_Types.Info
@


1.49
log
@We also pass the current module forward
@
text
@d4 3
d169 1
a169 1
   sharing Get_Type_Information.Info =
d190 1
a190 1
       structure Info = Get_Type_Information.Info
d1023 1
a1023 1
                               Incremental.FileName.parse_absolute ("/tmp/" ^ filename))
@


1.48
log
@Changed debug info to have only module name - needed to pass module table through to window stuff
@
text
@d4 3
d426 1
a426 1
        (print_descriptor,options,context)
d1005 17
d1031 2
a1032 4
                                     fn filename => 
                                     Incremental.find_module
                                     (context,
                                      Incremental.FileName.parse_absolute filename));
@


1.47
log
@Keep the backtrace short
@
text
@d4 3
d401 1
a401 1
      WINDOWING of string * (string * string) list -> unit
d1009 6
a1014 1
                        make_window (parameter_details,frames);
@


1.46
log
@Removed a lot of unnecessary handlers
@
text
@d4 3
d189 2
d413 4
d422 1
d573 42
a614 1
             
d617 1
a617 1
               val (another,next_frame,offset) = MLWorks.Internal.Value.frame_next current_frame
d622 2
a623 1
                     val (status,new_frames) = calculate_frame_status (next_frame,offset,frames,"",print_instantiated)
d654 1
a654 1
               val (another,next_frame,offset) = MLWorks.Internal.Value.frame_next current_frame
d707 1
a707 1
                 val (another,next,_) = MLWorks.Internal.Value.frame_next frame
d854 1
a854 1
               val (_,first_frame,first_offset) = MLWorks.Internal.Value.frame_next top_frame
@


1.45
log
@Edited the help text and took out the newline before the prompt
@
text
@d817 1
a817 1
                   val _ = debug(fn _ => "Inside trace code\n")
d821 1
a823 1
                   val _ = debug(fn _ => "Getting debugging information\n")
d829 3
a831 3
               in
                 if Debugger_Type_Utilities.is_type_polymorphic arg_ty
                   then
d839 1
a839 1
                            MLWorks.Internal.Value.frame_next top_frame
d859 22
a880 22
                                   val _ =
                                     return_print := 
                                     (fn result => 
                                      let
                                        val res_ty =
                                          get_res_type f_type
                                      in
                                        if Debugger_Type_Utilities.is_type_polymorphic res_ty
                                          then
                                            output(std_out,"Return from " ^ debug_info ^ "\n")
                                        else 
                                          (output(std_out,
                                                  "Return " ^
                                                  ValuePrinter.stringify_value 
                                                  (print_descriptor,
                                                   result,
                                                   res_ty,
                                                   interpreter_information) ^ 
                                                  " from " ^ debug_info ^ "\n")
                                          handle _ => 
                                            output(std_out,"Return from " ^ debug_info ^ "\n"))
                                      end)
d899 3
a901 7
                               fn _ => output(std_out,"Return from " ^ debug_info ^ "\n"))
                        end
                      handle _ =>
                         (output(std_out,"Trace of " ^ debug_info ^ 
                                      " which is polymorphic\n");
                          fn _ => output(std_out,"Return from " ^ debug_info ^ "\n")))
                 else 
d909 12
a920 10
                   fn result => 
                   (output(std_out,
                           "Return " ^
                           ValuePrinter.stringify_value (print_descriptor,
                                                         result,
                                                         res_ty,
                                                         interpreter_information) ^ 
                           " from " ^ debug_info ^ "\n")
                   handle _ => 
                     output(std_out,"Return from " ^ debug_info ^ "\n")))
d922 1
a922 5
             handle _ => 
               (output(std_out,"Trace of " ^ debug_info ^ "\n");
                fn _ => output(std_out,"Return from " ^ debug_info ^ "\n"))
               end
             handle _ => 
d941 1
a941 2
                      (display_help_info();
                       output(std_out,
@


1.44
log
@Two bugs fixes and propagation of changes lower down
@
text
@d4 3
d550 1
a550 1
              output(std_out, " p     - next frame down the stack \n");
a676 1
               val _ = output(std_out,"\n")
@


1.43
log
@Fixed a bug when tracing
@
text
@d4 3
d159 1
a159 1
     Incremental.InterMake.Compiler.Debugger_Types
d735 3
a737 1
                      NOT_POSSIBLE => do_input (previous_frames,frames)
d916 1
a916 1
                                                         arg_ty,
@


1.42
log
@Debugger now takes a print descriptor
@
text
@d4 3
d469 2
a470 2
                                "RecipeApplicationProblem of " ^ problem ^ 
                                " - can't deduce types due to tail calls \n"
d484 1
d493 1
d495 1
d515 1
d810 1
d816 1
d819 1
d823 1
a823 1
                 if Debugger_Type_Utilities.is_type_polymorphic res_ty
d828 1
d881 1
d884 1
d899 2
a900 1
                   (output(std_out,"Trace of " ^ debug_info ^ 
@


1.41
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d170 1
d402 1
a402 1
        (options,context)
d496 1
a496 1
                                         (ValuePrinter.default_print_descriptor,
d511 1
a511 1
                                       (ValuePrinter.default_print_descriptor,
d836 1
a836 1
                                          (ValuePrinter.default_print_descriptor,
d854 5
a858 4
                                                  ValuePrinter.stringify_value (ValuePrinter.default_print_descriptor,
                                                                                result,
                                                                                res_ty,
                                                                                interpreter_information) ^ 
d888 1
a888 1
                           ValuePrinter.stringify_value (ValuePrinter.default_print_descriptor,
d895 1
a895 1
                           ValuePrinter.stringify_value (ValuePrinter.default_print_descriptor,
d915 1
a915 1
                       ValuePrinter.stringify_value (ValuePrinter.default_print_descriptor,
@


1.40
log
@Fixed a bug in tracing
Changed the option 'c' to 'q' and added another 'c'
@
text
@d4 4
d145 2
a146 1
     Incremental.InterMake.Compiler.Parser.Lexer.Info
d196 1
a196 1
       fun print_type (base,ty,after) =
d199 1
a199 1
         | _ => (base ^ Types.print_type ty ^ after)
d440 1
a440 1
                                     Types.print_type (ty()) ^ "\n")
d477 1
a477 1
                         print_type(indent ^ "General type: ",ty,"\n")
d488 2
a489 2
                          indent ^ "Instance type : " ^ Types.print_type f_type ^ "\n" ^
                          indent ^ "Inferred input type " ^ Types.print_type inferred_type ^ "\n" ^
d512 1
a512 1
                         print_type(indent ^ "General type: ",ty,"\n") ^
@


1.39
log
@Modified the sharing equations slightly
@
text
@d4 3
d381 9
a389 2
               
      fun ml_debugger 
d394 1
a394 1
        parameter
d525 2
a526 2
              output(std_out, " n     - next frame up the stack \n");
              output(std_out, " nm    - next frame up the stack \n");
a529 1
              output(std_out, " c     - continue \n");
d531 9
a539 1
              output(std_out, " help  - display this help info\n"))
d713 5
a717 1
               | ("c",_,_,_) => ()
d719 6
a795 4
                 val (ty,is_leaf,annotations,source_file,position) = 
                   get_type_information info_opts (interpreter_information) (debug_info,true)
                 val arg_ty = get_arg_type ty
                 val res_ty = get_res_type ty
d797 6
d893 6
a898 1
               (fn _ => output(std_out,"Returns\n")))
@


1.38
log
@Tidied up debugger loop.
@
text
@d4 3
d137 8
a144 5
   sharing Get_Type_Information.Info = Incremental.Compiler.Info
   sharing Get_Type_Information.Debugger_Types = Debugger_Type_Utilities.Debugger_Types 
     = ValuePrinter.Debugger_Types = Incremental.Compiler.Debugger_Types
   sharing Get_Type_Information.Basis = ValuePrinter.Basis = Incremental.Compiler.Basis
   sharing Get_Type_Information.Parser  = Incremental.Compiler.Parser
@


1.37
log
@Changed Error structure to Info
@
text
@d4 3
d633 1
d643 3
d649 1
a649 1
               val (command,args) = parse_command(explode command',[])
d688 1
a688 3
               | ("",_,_,_) => if end_of_stream std_in
                               then MLWorks.exit 0
                             else do_input (previous_frames,frames)
@


1.36
log
@Added extra info for the frames whose types have not been deduced yet
@
text
@d4 3
d131 1
d148 1
d302 1
d324 1
a324 1
                                 Get_Type_Information.get_type_information file
a359 4
           
           datatype TypeOfDebugger = 
             WINDOWING of string * (string * string) list -> unit
             | TERMINAL
d361 8
a368 4
           datatype parameter =
             SIGNAL of int
             | EXCEPTION of exn
             | TRACE of MLWorks.Internal.Value.ml_value * MLWorks.Internal.Value.ml_value
d370 20
a389 23
           fun ml_debugger 
             type_of_debugger
             (options,context)
             execute_function
             parameter =
             let
               val interpreter_information = Incremental.debug_info context
                 
               fun calculate_frame_status (current,offset,other_frames,indent,print_instantiated) =
                 let
                   val _ = debug(fn _ => "Entering display frame status\n")
                   val debug_info = get_data_from_frame current
                   val _ = debug(fn _ => "Retrieved debug_info is " ^ debug_info ^ "\n")
                     
               fun conditional_output x =
                 if print_instantiated
                   then output(std_out,x)
                 else ()

             in
               (let
                 val (ty,is_leaf,annotations,source_file,position) = 
                   get_type_information (interpreter_information) (debug_info,true)
d391 10
a400 5
                 val arg = get_value_from_frame (current,I0)
                 val arg_type = get_arg_type ty
                 val current_annotation = 
                   Lists.assoc (4 * offset,annotations) 
                   handle Lists.Assoc => Debugger_Types.Nop
d402 1
a402 1
                 val _ = debug(fn _ => "Offset " ^ Integer.makestring offset ^ "\n" ^
d405 4
a408 4
                 fun print((_,OK _)::_) = ()
                   | print((_,TO_BE_INSTANTIATED(x,y,_,_))::rest) = (print rest ; 
                                                                   conditional_output(x ^ "\n" ^ y ^ "\n"))
                   | print _ = Crash.impossible "inside _ml_debugger 6"
d410 1
a410 1
               fun propogate_new_type_information (ty,[]) = []
d759 1
a759 1
                   get_type_information (interpreter_information) (debug_info,true)
@


1.35
log
@Added polymorphic tracing
@
text
@d4 3
d224 1
d229 1
a229 1
           | output_frame_details(TO_BE_INSTANTIATED(x,_,_)) = output(std_out,x)
d232 1
a232 1
           | output_frame_details_if_instantiated(TO_BE_INSTANTIATED(x,_,_)) = ()
d398 2
a399 2
                   | print((_,TO_BE_INSTANTIATED(x,_,_))::rest) = (print rest ; 
                                                                   conditional_output(x ^ "\n"))
d404 1
a404 1
                     (ty,all_frames as ((frame,TO_BE_INSTANTIATED(details,infer,errors))::rest)) =
d449 1
d496 1
a496 1
             (output(std_out, "Commands\n");
d770 1
d873 1
a873 1
                         | (_,TO_BE_INSTANTIATED(x,_,ref y)) => (x,y))
@


1.34
log
@Added tracing again
@
text
@d4 3
d750 72
a821 5
                 output(std_out,"Trace of " ^ debug_info ^ 
                        (if Debugger_Type_Utilities.is_type_polymorphic arg_ty
                           then
                             "which is polymorphic"
                         else
d826 1
a826 5
                                                         interpreter_information)) ^ "\n");
                 if Debugger_Type_Utilities.is_type_polymorphic res_ty
                   then
                   fn _ => output(std_out,"Return from" ^ debug_info ^ "\n")
                 else 
d836 1
a836 1
                     output(std_out,"Return from" ^ debug_info ^ "\n"))
@


1.33
log
@Added a handle for substring and changed the help message
@
text
@d4 3
d338 1
a338 1

d340 1
a340 1

d347 4
d352 10
a361 17
    datatype TypeOfDebugger = 
      WINDOWING of string * (string * string) list -> unit
    | TERMINAL

    datatype parameter =
      SIGNAL of int
    | EXCEPTION of exn

      fun ml_debugger 
        type_of_debugger
        (options,context)
        execute_function
        parameter =
         let
           val interpreter_information = Incremental.debug_info context

           fun calculate_frame_status (current,offset,other_frames,indent,print_instantiated) =
d363 8
a370 4
               val _ = debug(fn _ => "Entering display frame status\n")
               val debug_info = get_data_from_frame current
               val _ = debug(fn _ => "Retrieved debug_info is " ^ debug_info ^ "\n")

d482 3
a484 3
                    (OK(debug_info,"No debugging data available\n",Datatypes.NULLTYPE),other_frames)
                       | Match => (OK(debug_info,"No debugging data available\n",
                                      Datatypes.NULLTYPE),other_frames)
a733 8
           val parameter_details =
             case parameter of
               EXCEPTION exn =>
                 ValuePrinter.stringify_value (ValuePrinter.default_print_descriptor,
                                               MLWorks.Internal.Value.cast exn,
                                               Datatypes.CONSTYPE([],Types.exn_tyname),
                                               interpreter_information)
             | SIGNAL s => "SIGNAL " ^ Integer.makestring s
d735 75
a809 22
           MLWorks.Internal.Value.frame_call
           (fn top_frame =>
            case type_of_debugger of
              TERMINAL =>
                (display_help_info();
                 output(std_out,
                        "\nException on entry to debugger:" ^ 
                        parameter_details ^ "\n");
                 do_input([],[deal_with_frame (top_frame,"",false)]))
            | WINDOWING make_window => 
                let
                  val frames =                    
                    rev
                    (map 
                     (fn (_,OK(x,y,_)) => (x,y)
                   | (_,TO_BE_INSTANTIATED(x,_,ref y)) => (x,y))
                     (#2(do_backtrace([],[deal_with_frame (top_frame,"",false)],false))))
                in
                  make_window (parameter_details,frames);
                  ()
                end)
         end
d812 1
@


1.32
log
@Stripped out tracing code.  Many changes concerning
changes to pervasives.  Needs seeing to.
@
text
@d4 4
d279 1
d492 1
a492 1
              output(std_out, " shell - start a subshell \n");
@


1.31
log
@Took out trace and added binding of frame arguments to it
@
text
@d4 3
d97 1
d113 1
d137 18
d344 4
d352 1
a352 1
        (top_frame,type_of_exception,exception_object) = 
a355 8
           val can_continue = 
             case type_of_exception of
               MLWorks.Internal.Debugger.CONTINUABLE => (debug(fn _ => "Continuable\n");
                                        true )
             | MLWorks.Internal.Debugger.SINGLE_STEP _ => (debug(fn _ => "Single step\n");
                                        true)
             | _ => false

d359 1
a359 1
               val debug_info = MLWorks.Internal.Debugger.get_data_from_frame current
d372 1
a372 1
                 val arg = MLWorks.Internal.Debugger.get_value_from_frame (current,MLWorks.Internal.Debugger.I0)
d479 10
a488 13
             (output(std_out,"Commands\n");
              output(std_out," <     - go to the top of the stack \n");
              output(std_out," n     - next frame up the stack \n");
              output(std_out," nm    - next frame up the stack \n");
              output(std_out," p     - next frame down the stack \n");
              output(std_out," bv    - do a backtrace of the stack \n");
              output(std_out," b     - do a backtrace of the stack without values\n");
              if can_continue
                then output(std_out," c     - continue \n")
              else ();
                output(std_out," shell - start a subshell \n");
                output(std_out," help  - display this help info\n");
                ())
d492 1
a492 1
               val (another,next_frame,offset) = MLWorks.Internal.Debugger.get_next_frame current_frame
d512 1
a512 1
                 val debug_info = MLWorks.Internal.Debugger.get_data_from_frame current
d528 1
a528 1
               val (another,next_frame,offset) = MLWorks.Internal.Debugger.get_next_frame current_frame
d534 1
a534 1
                     val debug_info = MLWorks.Internal.Debugger.get_data_from_frame next_frame
d579 1
a579 1
                 val debug_info = MLWorks.Internal.Debugger.get_data_from_frame frame
d581 1
a581 1
                 val (another,next,_) = MLWorks.Internal.Debugger.get_next_frame frame
d657 1
a657 1
                               then MLWorks.Internal.Debugger.exit 0
d660 1
a660 2
               | ("c",_,_,_) => 
                   MLWorks.Internal.Debugger.CONTINUE
d689 1
a689 2
                                    MLWorks.Internal.Debugger.get_value_from_frame 
                                    (current_frame,MLWorks.Internal.Debugger.I0)   
d715 1
a715 2
               val (_,first_frame,first_offset) = 
                 MLWorks.Internal.Debugger.get_next_frame(top_frame)
d717 1
a717 1
               val top_debug_info = MLWorks.Internal.Debugger.get_data_from_frame first_frame
d724 9
a732 1
           
d734 22
a755 33
           case type_of_exception of
             MLWorks.Internal.Debugger.SINGLE_STEP (object,offset,stack_size) =>
               (output(std_out,"Traceis no longer working\n");
                MLWorks.Internal.Debugger.CONTINUE)
           | _ => 
               let
                 val exception_details = 
                   ValuePrinter.stringify_value (ValuePrinter.default_print_descriptor,
                                                 exception_object,
                                                 Datatypes.CONSTYPE([],Types.exn_tyname),
                                                 interpreter_information)
               in
                 case type_of_debugger of
                   TERMINAL =>
                     (display_help_info();
                      output(std_out,
                             "\nException on entry to debugger:" ^ 
                             exception_details ^ "\n");
                      do_input([],[deal_with_frame (top_frame,"",false)]))
                 | WINDOWING make_window => 
                     let
                       val frames =                    
                         rev
                         (map 
                          (fn (_,OK(x,y,_)) => (x,y)
                        | (_,TO_BE_INSTANTIATED(x,_,ref y)) => (x,y))
                          (#2(do_backtrace([],[deal_with_frame (top_frame,"",false)],false))))

                     in
                       make_window (exception_details,frames);
                       MLWorks.Internal.Debugger.CONTINUE
                     end
               end
a756 2
         end

a757 2


@


1.30
log
@Changes for windowing listener
@
text
@d4 3
a96 1
require "trace";
a106 1
   structure Trace : TRACE
d323 1
a323 1
        context
d461 6
a466 6
              output(std_out," :<   - go to the top of the stack \n");
              output(std_out," :n   - next frame up the stack \n");
              output(std_out," :nm  - next frame up the stack \n");
              output(std_out," :p   - next frame down the stack \n");
              output(std_out," :bv  - do a backtrace of the stack \n");
              output(std_out," :b   - do a backtrace of the stack without values\n");
d468 1
a468 1
                then output(std_out," :c   - continue \n")
d471 1
a471 1
                output(std_out," help - display this help info\n");
a473 4
           fun set_new_default_path () =
             (output(std_out,"New path> ");
              default_path := get_line std_in)
             
d476 1
a476 1
               val (another,next_frame,offset) = Trace.get_next_frame current_frame
d512 1
a512 1
               val (another,next_frame,offset) = Trace.get_next_frame current_frame
d582 2
a583 1
             fun do_input (previous_frames,frames as ((current as (current_frame,current_info))::rest_of_frames)) =
d588 1
a588 1
               val _ = output(std_out,"MLWorks Debugger >")
d590 8
d600 1
a600 1
                 | parse_command (h::t,acc) = parse_command (t,h::acc)
d605 1
a605 1
                 (":<",_,_,_) => 
d608 1
a608 1
                | (":n","",_,(h,info)::t) =>
d611 1
a611 1
               | (":n","",_,[]) =>
d614 1
a614 1
               | (":n",function_name,_,_) =>
d617 1
a617 1
               | (":bv",_,_,_) => 
d620 1
a620 1
               | (":b",_,_,_) =>
d624 1
a624 1
               | (":nm",_,_,(top as (_,OK _)) :: rest) =>
d627 1
a627 1
               | (":nm",_,_,_) =>
d630 1
a630 1
               | (":p","",[_],_) =>
d634 1
a634 1
               | (":p","",top::old,prev) => 
d637 1
a637 1
               | (":p",function_name,_,_) => 
d644 2
a645 4
               | (":c",_,_,_) => 
                     if Trace.are_we_breakpointing() orelse Trace.are_we_tracing()
                       then MLWorks.Internal.Debugger.DO_SINGLE_STEP
                     else MLWorks.Internal.Debugger.CONTINUE
d650 42
a691 3
               | ("shell",_,_,_) => (execute_function();
                                     do_input (previous_frames,frames))
                   
d701 2
a702 1
               val (_,first_frame,first_offset) = Trace.get_next_frame(top_frame)
d715 2
a716 69
               let
                 val trace_lookup = 
                   Trace.find_object object
               in
                 case trace_lookup of
                   Trace.Found =>
                     let
                       fun generate x =
                         if x > 50
                           then generate 50
                         else
                           if x<0
                             then []
                           else " " :: generate(x-1)

                       val (frame,details) = deal_with_frame (top_frame,"",false)

                       val (frame,details) =
                         case details of
                           OK _ => (frame,details)
                         | _ =>
                             (let
                                val (_,analysed) = 
                                  deal_with_next_monomorphic([deal_with_frame (top_frame,"",false)],false)
                                fun last [x] = x
                                  | last (_::t) = last t
                                  | last _ = Crash.impossible "inside _ml_debugger 1"
                              in
                                last analysed
                              end) 
                     in
                       case details of 
                         OK(name,data,ty) =>
                           let
                             fun print(arg,arg_ty) =
                               ValuePrinter.stringify_value (ValuePrinter.default_print_descriptor,
                                                             arg,arg_ty,
                                                             interpreter_information)
                             val closure = MLWorks.Internal.Debugger.get_value_from_frame (frame,MLWorks.Internal.Debugger.I1)   
                             val arg = MLWorks.Internal.Debugger.get_value_from_frame (frame,MLWorks.Internal.Debugger.I0)   
                             val arg_ty = get_arg_type ty
                             val _ = output(std_out,name ^ "\n" ^ data)

                             val to_be_updated = ref(top_frame : MLWorks.Internal.Debugger.StackFrame)
                             val _ = Trace.add_trace_frame(frame,to_be_updated)
                             val result =  MLWorks.Internal.Debugger.call_function((arg,offset,stack_size),closure,to_be_updated)
                             val _ = Trace.remove_trace_frame(frame,to_be_updated)

                             val _ = output(std_out,"Returns " ^
                                            print(result,get_res_type ty) ^ 
                                            "\n")
                           in
                             MLWorks.Internal.Debugger.TRACE_RETURN_VALUE result
                           end
                       | _ => (output(std_out,"Polymorphic Function and can't deduce type\n");
                               MLWorks.Internal.Debugger.DO_SINGLE_STEP)
                     end
                 | Trace.NotFound => 
                     let
                       val breakpoint_lookup = Trace.find_object object
                     in
                       case breakpoint_lookup of
                         Trace.Found => (output(std_out,"\nReached a breakpoint...\n");
                                         do_input([],[deal_with_frame (top_frame,"",false)]))
                       | Trace.NotFound => (output(std_out,
                                                   "Found interesting object that is being neither traced nor breakpointed\n");
                                            MLWorks.Internal.Debugger.DO_SINGLE_STEP)
                     end
               end
d727 3
a729 2
                     (output(std_out,
                             "Exception on entry to debugger:" ^ 
@


1.29
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d255 2
d313 1
a313 1
               | _ => (Datatypes.NULLTYPE,false,[],"","")
d316 4
d321 1
d408 1
a408 2
                       val info = 
                         debug_info ^ "\n" ^ 
d412 1
a412 1
                      (info,
d417 2
a418 1
                         (info,
d450 4
a453 1
                  handle String.Substring => (OK(debug_info,"No debugging data available\n",Datatypes.NULLTYPE),other_frames)
a456 1
           handle Substring => (OK("","No data available\n",Datatypes.NULLTYPE),other_frames)
d488 3
a490 1
               else (output(std_out,"At the bottom of the stack\n");
d553 1
a553 1
             fun do_backtrace(additional_frames,frames as ((top as (current_frame,details)) :: _)) =
d555 2
a556 2
                 val _ = output_frame_details_if_instantiated details
                 val result = #2(do_next(current_frame,frames,true))
d560 1
a560 1
                 else do_backtrace(additional_frames,result)
d612 1
a612 1
                   do_input(do_backtrace(rest_of_frames,[current]))
d741 27
a767 18
               if true
                 then
                   let
                     val _ = output(std_out,"Exception on entry to debugger:" ^ 
                                    ValuePrinter.stringify_value (ValuePrinter.default_print_descriptor,
                                                                  exception_object,
                                                                  Datatypes.CONSTYPE([],Types.exn_tyname),
                                                                  interpreter_information) ^ "\n")
                   in
                     do_input([],[deal_with_frame (top_frame,"",false)])
                   end
               else
                 let
                   val frames =                    
                     do_backtrace([],[deal_with_frame (top_frame,"",false)])
                 in
                   MLWorks.Internal.Debugger.CONTINUE
                 end
@


1.28
log
@Changes for the use of new shell
@
text
@d4 3
d87 1
d104 1
d144 1
a144 2
                             (Parser.ParserBasis * Basis.Basis * 
                              (string,
d181 1
a181 1
         OK of string * Datatypes.Type * Datatypes.Tyenv
d184 2
a185 1
                                  (Datatypes.Type -> (string * Datatypes.Type * Datatypes.Type * Datatypes.Tyenv)))
d187 2
a188 2
         fun output_frame_details(OK (x,_,_)) = output(std_out,x)
           | output_frame_details(TO_BE_INSTANTIATED(x,_)) = output(std_out,x)
d190 2
a191 2
         fun output_frame_details_if_instantiated(OK (x,_,_)) = output(std_out,x ^ "\n")
           | output_frame_details_if_instantiated(TO_BE_INSTANTIATED(x,_)) = ()
a193 1
       val output_emacs_commands = ref(false)
a194 5
       fun emacs_output(x) =
         if !output_emacs_commands
           then output(std_out,"(emacs " ^ x ^ ")\n")
         else ()

d249 2
a250 12
           fun root_name filename =
             let
               val len = size filename
               val final_name =
                 if len >= 4 then
                   String.substring(filename, len-4, 4)
                 else ""
             in
               case final_name of
                 ".sml" => String.substring(filename, 0, len-4)
               | _ => filename
             end
a251 3
           fun mo_name filename =
             root_name filename ^ ".mo"

d253 1
a253 2
             (toploop_parser_basis,toploop_type_basis,
              Debugger_Types.INFO interpreter_information)
d262 1
a262 1
                  (toploop_parser_basis,toploop_type_basis,interpreter_information))
d273 1
a273 1
                               val (p,b,Debugger_Types.INFO mapping,_) = 
d276 1
a276 1
                                 add_to_cache(file,(p,b,mapping))
d278 1
a278 1
                               (p,b,mapping)
d281 1
a281 1
                           (Parser.empty_pB,Basis.empty_basis,NewMap.empty (fn _ => false,fn _ => true))
d295 1
a295 1
                              (Parser.empty_pB,Basis.empty_basis,NewMap.empty (fn _ => false,fn _ => true))
d300 1
a300 1
                      (Parser.empty_pB,Basis.empty_basis,NewMap.empty (fn _ => false,fn _ => true))))
d302 1
a302 1
               val (p,b,mapping) = find_in_file source_file
a303 2
               val (found,(lookup,is_leaf,annotations)) = (true,NewMap.apply mapping st)
                 handle NewMap.Undefined => (false,(Datatypes.NULLTYPE,false,[]))
d305 4
a308 5
               if found
                 then 
                   (p,b,lookup,is_leaf,annotations,source_file,position)
               else
                 (p,b,Datatypes.NULLTYPE,false,[],"","")
a315 2
           val toploop_parser_basis = Incremental.parser_basis context
           val toploop_type_basis = Incremental.type_basis context
d331 6
d339 2
a340 4
                 val (_,Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,_)),ty,is_leaf,
                      annotations,source_file,position) = 
                   get_type_information (toploop_parser_basis,toploop_type_basis,interpreter_information) 
                   (debug_info,true)
d344 4
a347 1
                 val current_annotation = Lists.assoc (4 * offset,annotations) handle Lists.Assoc => Debugger_Types.Nop
d350 5
d356 4
a359 11
                 val _ = if source_file=""
                           then ()
                         else emacs_output ("(sml-label-buffer \"" ^
                                       source_file ^
                                       "\" " ^
                                       position_to_emacs_position position ^
                                       " \" <*> \" t)")
                           
                 fun propogate_new_type_information (ty,[]) = []
                   | propogate_new_type_information (ty,all_frames as ((frame,TO_BE_INSTANTIATED(details,infer))::rest)) =
                     let
d363 2
a364 8
                       fun print((_,OK _)::_) = ()
                         | print((_,TO_BE_INSTANTIATED(x,_))::rest) = (print rest ; 
                                                                       if print_instantiated
                                                                         then output(std_out,x ^ "\n")
                                                                       else ())
                         | print _ = Crash.impossible "inside _ml_debugger 6"

                       val (res,ty',function_type,ty_env) = 
d366 1
a366 4
                         handle Debugger_Type_Utilities.InValidMatch =>
                           (print all_frames;
                            raise Debugger_Type_Utilities.InValidMatch)
                       val result = (frame,OK(res,function_type,ty_env)) 
d369 1
a369 1
                       (if print_instantiated then output(std_out,res ^ "\n") else ());
d372 20
d408 1
a408 1
                         (info ^ 
d416 1
a416 1
                                          "\n"),
d418 3
a420 3
                         f_type,
                         ty_env)
                       end),
d432 1
a432 1
                     (OK(debug_info ^ "\n" ^
d434 4
a437 9
                         string_argument,ty,ty_env),
                     propogate_new_type_information
                     (fn () => Debugger_Type_Utilities.apply_recipe(current_annotation,arg_type),
                      other_frames)
                     handle Debugger_Type_Utilities.InValidMatch => other_frames
                       | Debugger_Type_Utilities.RecipeApplicationProblem problem =>
                       (output(std_out,"RecipeApplicationProblem of " ^ problem ^ 
                               " - can't deduce types due to tail calls \n");
                        other_frames))
d439 4
a442 5
                 end)
                  handle String.Substring => (OK(debug_info ^ "\n" ^ "No data available\n",Datatypes.NULLTYPE,
                                          Datatypes.TE (empty_map)),other_frames)
                       | Match => (OK(debug_info ^ "\n" ^ "No data available\n",
                                      Datatypes.NULLTYPE,Datatypes.TE (empty_map)),other_frames)
d444 2
a445 3
           handle Substring => (OK("No data available\n",Datatypes.NULLTYPE,
                                   Datatypes.TE (empty_map)),other_frames)
           
d457 4
a460 5
              output(std_out," :s   - set new default path \n");
              output(std_out," shell - start a subshell \n");
              output(std_out," help - display this help info\n");
              ())

d464 20
a483 2

             fun do_next(current_frame,frames,print_instantiated) =
d485 7
a491 1
                 val (another,next_frame,offset) = Trace.get_next_frame current_frame
d493 3
a495 9
                 if another
                   then 
                     let
                       val (status,new_frames) = calculate_frame_status (next_frame,offset,frames,"",print_instantiated)
                     in
                       ([],(next_frame,status)::new_frames)
                     end
                 else (output(std_out,"At the bottom of the stack\n");
                       ([],frames))
d497 27
a524 45
             fun do_previous_named(name,previous,[top]) =
               (previous,[top])

               | do_previous_named(name,previous,(top as (current,_))::rest) =
                 let
                   val debug_info = MLWorks.Internal.Debugger.get_data_from_frame current
                   val len = size name
                   val max = size debug_info - len
                   fun search (x) =
                     if x> max
                       then false
                     else String.substring(debug_info,x,len) = name orelse search(x+1)
                 in
                   if search 0
                     then (previous,top::rest)
                   else do_previous_named(name,top::previous,rest)
                 end
               | do_previous_named _ = Crash.impossible "inside _ml_debugger 5"                 

             fun do_next_function_name(name,current_frame,frames,print_instantiated) =
               let
                 val (another,next_frame,offset) = Trace.get_next_frame current_frame
               in
                 if another
                   then 
                     let
                       val (status,new_frames) = calculate_frame_status (next_frame,offset,frames,"",print_instantiated)
                       val debug_info = MLWorks.Internal.Debugger.get_data_from_frame next_frame
                       val len = size name
                       val max = size debug_info - len
                       fun search (x) =
                         if x> max
                           then false
                         else String.substring(debug_info,x,len) = name (* orelse search(x+1) *)
                     in
                       if search 0
                         then
                           ([],(next_frame,status)::new_frames)
                       else
                         do_next_function_name(name,next_frame,(next_frame,status)::new_frames,true)
                     end
                 else (output(std_out,"At the bottom of the stack\n");
                       ([],frames))
               end

a628 3
               | (":s",_,_,_) => (set_new_default_path();
                                   do_input (previous_frames,frames))
                   
d689 1
a689 1
                         OK(name_string,ty,ty_env) =>
d698 1
a698 1
                             val _ = output(std_out,name_string)
d727 19
a745 9
               let
                 val _ = output(std_out,"Exception on entry to debugger:" ^ 
                                ValuePrinter.stringify_value (ValuePrinter.default_print_descriptor,
                                                              exception_object,
                                                              Datatypes.CONSTYPE([],Types.exn_tyname),
                                                              interpreter_information) ^ "\n")
               in
                 do_input([],[deal_with_frame (top_frame,"",false)])
               end
@


1.27
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d83 1
d87 1
d98 2
d101 5
a105 5
   sharing Get_Type_Information.Basis.Tyvarenv.Datatypes 
     = Types.Datatypes = Get_Type_Information.Debugger_Types.Datatypes 
     = Debugger_Type_Utilities.Debugger_Types.Datatypes = ValuePrinter.Datatypes
     sharing Get_Type_Information.Debugger_Types = Debugger_Type_Utilities.Debugger_Types
     sharing Get_Type_Information.Basis = ValuePrinter.Basis
d110 1
d117 1
a121 4
       val debugger_depth = ref(0)

       val print_method_defined = ValuePrinter.print_method_defined
       val define_a_print_method = ValuePrinter.define_a_print_method
d123 10
a132 10
         (* Print out an argument value *)
         fun print_argument (text,arg as (_,_,ty,_,_,_),after) =
           case ty of
             Datatypes.NULLTYPE => ""
           | _ =>  (text ^ ValuePrinter.stringify_value arg ^ after)

         fun print_type (base,ty,after) =
           case ty of
             Datatypes.NULLTYPE => ""
           | _ => (base ^ Types.print_type ty ^ after)
d142 1
a142 1
                               (int * Debugger_Types.Backend_Annotation) list) NewMap.T * bool)) 
a172 187
       (* IGNORE TRACE AND BREAKPOINT FRAMES *)

       val trace_frames = ref([] : (MLWorks.Internal.Debugger.StackFrame * MLWorks.Internal.Debugger.StackFrame ref) list)

       fun check(result,frame,[]) = result
         | check(result,frame,(b,ref a)::rest) = 
           if a=frame
             then get_next_frame b
           else check(result,frame,rest)

       and get_next_frame x = 
         let
           val result as (_,next,_) = MLWorks.Internal.Debugger.get_next_frame x
         in
           check(result,next,!trace_frames)
         end

       (* TRACING AND BREAKPOINTING *)

       val are_we_tracing = ref(false)
       val are_we_breakpointing = ref(false)
       val functions_to_trace = ref([] : MLWorks.Internal.Value.ml_value list)
       val functions_to_breakpoint = ref([] : MLWorks.Internal.Value.ml_value list)
       val trace_depth = ref(0)

       datatype Search = Found | NotFound 

       fun find_object (object,x) =
         let
           fun find' [] = NotFound
             | find' (h::t) = 
               if h = object
                 then Found
               else find' t
         in
           find' x
         end

       val get_function_debug_info =
         MLWorks.Internal.Debugger.get_code_object_debug_info;

       fun trace info closure = 
         let
           val Debugger_Types.INFO interpreter_info = info ()
           val closure = MLWorks.Internal.Value.cast closure
           val code_string = MLWorks.Internal.Debugger.get_object_at_address(closure,~1)
           val debug_info = get_function_debug_info code_string
           val the_slot = find_object (code_string,! functions_to_trace)
           val the_slot' = find_object (code_string,! functions_to_breakpoint)
         in
           case (the_slot,the_slot') of
             (Found,_) => (output(std_out,"Already tracing that function\n");
                       false)
           | (_,Found) => (output(std_out,"Already breakpointing that function\n");
                           false)
           | (NotFound,_)  =>
               let
                 val _ = if !are_we_tracing
                           then ()
                         else (trace_depth := 0;
                               trace_frames := [])
                 val not_possible =
                   (#2((NewMap.apply interpreter_info debug_info) :
                    Datatypes.Type * bool * (int * Debugger_Types.Backend_Annotation) list))
                   handle NewMap.Undefined => false
               in
                 if not_possible
                   then
                     (output(std_out,"This function is leaf and cannot be traced\n");
                      false)
                 else
                   (functions_to_trace := code_string :: ! functions_to_trace;
                    MLWorks.Internal.Debugger.tag_as_interesting code_string;
                    are_we_tracing := true;
                    MLWorks.Internal.Debugger.start_single_stepping();
                    true)
               end
         end


       fun untrace closure = 
         let
           val closure = MLWorks.Internal.Value.cast closure
           val code_string = MLWorks.Internal.Debugger.get_object_at_address(closure,~1)
           val the_slot = find_object(code_string,! functions_to_trace)
         in
           case (the_slot,! functions_to_trace) of 
             (Found,[_]) =>
               (functions_to_trace := [];
                MLWorks.Internal.Debugger.untag_as_interesting code_string;
                are_we_tracing := false;
                true)
           | (Found,rest) =>
               let
                 fun remove ([],acc) = acc
                   | remove (h::t,acc) = 
                     if h = code_string
                       then remove(t,acc)
                     else remove (t,h::acc)
               in
                 MLWorks.Internal.Debugger.untag_as_interesting code_string;
                 functions_to_trace := remove(rest,[]);
                 true
               end
           | (NotFound,_) => 
               (output(std_out,"Not being traced\n");
                false)
         end

       fun untrace_all() =
         (map MLWorks.Internal.Debugger.untag_as_interesting (!functions_to_trace);
          functions_to_trace := [];
          trace_depth := 0;
          case !functions_to_breakpoint of
            [] => MLWorks.Internal.Debugger.stop_single_stepping ()
          | _ => ())

       fun breakpoint info closure = 
         let
           val Debugger_Types.INFO interpreter_info = info ()
           val closure = MLWorks.Internal.Value.cast closure
           val code_string = MLWorks.Internal.Debugger.get_object_at_address(closure,~1)
           val debug_info = get_function_debug_info code_string
           val the_slot = find_object (code_string,! functions_to_breakpoint)
           val the_slot' = find_object (code_string,! functions_to_trace)
         in
           case (the_slot,the_slot') of
             (Found,_) => (output(std_out,"Already breakpointing that function\n");
                       false)
           | (_,Found) => (output(std_out,"Already tracing that function\n");
                           false)
           | (NotFound,_)  =>
               let
                 val not_possible =
                   (#2((NewMap.apply interpreter_info debug_info) :
                    Datatypes.Type * bool * (int * Debugger_Types.Backend_Annotation) list))
                   handle NewMap.Undefined => false
               in
                 if not_possible
                   then
                     (output(std_out,"This function is leaf and cannot be breakpointed\n");
                      false)
                 else
                   (functions_to_breakpoint := code_string :: ! functions_to_breakpoint;
                    MLWorks.Internal.Debugger.tag_as_interesting code_string;
                    are_we_breakpointing := true;
                    MLWorks.Internal.Debugger.start_single_stepping();
                    true)
               end
         end

       fun unbreakpoint closure = 
         let
           val closure = MLWorks.Internal.Value.cast closure
           val code_string = MLWorks.Internal.Debugger.get_object_at_address(closure,~1)
           val the_slot = find_object(code_string,! functions_to_breakpoint)
         in
           case (the_slot,! functions_to_trace) of 
             (Found,[_]) =>
               (functions_to_breakpoint := [];
                MLWorks.Internal.Debugger.untag_as_interesting code_string;
                are_we_breakpointing := false;
                true)
           | (Found,rest) =>
               let
                 fun remove ([],acc) = acc
                   | remove (h::t,acc) = 
                     if h = code_string
                       then remove(t,acc)
                     else remove (t,h::acc)
               in
                 MLWorks.Internal.Debugger.untag_as_interesting code_string;
                 functions_to_breakpoint := remove(rest,[]);
                 true
               end
           | (NotFound,_) => 
               (output(std_out,"Not being breakpointed\n");
                false)
         end

       fun unbreakpoint_all() =
         (map MLWorks.Internal.Debugger.untag_as_interesting (!functions_to_breakpoint);
          functions_to_breakpoint := [];
          case !functions_to_trace of
            [] => MLWorks.Internal.Debugger.stop_single_stepping ()
          | _ => ())

d277 1
a277 1
                  (toploop_parser_basis,toploop_type_basis,interpreter_information,true))
d291 1
a291 1
                                 add_to_cache(file,(p,b,mapping,true))
d293 1
a293 1
                               (p,b,mapping,false)
d296 1
a296 1
                           (Parser.empty_pB,Basis.empty_basis,NewMap.empty (fn _ => false,fn _ => true),true)
d310 1
a310 1
                              (Parser.empty_pB,Basis.empty_basis,NewMap.empty (fn _ => false,fn _ => true),true)
d315 1
a315 1
                      (Parser.empty_pB,Basis.empty_basis,NewMap.empty (fn _ => false,fn _ => true),true)))
d317 1
a317 2
               val (p,b,mapping,type_from_encapsulation) = 
                 find_in_file source_file
d324 1
a324 1
                   (p,b,lookup,is_leaf,annotations,source_file,position,type_from_encapsulation)
d326 1
a326 38
                 (p,b,Datatypes.NULLTYPE,false,[],"","",type_from_encapsulation)
             end

           fun exn_lookup (toploop_parser_basis,
                           toploop_type_basis,
                           info as (Debugger_Types.INFO interpreter_information)) debug =
             let
               val Basis.BASIS(_,_,_,Datatypes.ENV(_,default_ty_env,_,_)) = toploop_type_basis
               val (name,file_name,_) = find_source_file_and_name_and_position debug
               val s = size name
               fun find_end_of_name x =
                 if x=s
                   then name
                 else if String.substring(name,x,1) = " "
                        then String.substring(name,0,x)
                      else find_end_of_name (x+1)
               val name' = find_end_of_name 0
             in
               let
                 val (ty,_,_) = NewMap.apply interpreter_information debug
               in
                 (name',get_arg_type ty,default_ty_env,false)
               end
             handle Datatypes.NewMap.Undefined => 
               (if !show_compiler_frames
                  then
                    let
                      val (_,Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,Datatypes.VE(_,exn_map))),
                           ty,_,annotations,_,_,_) = 
                        get_type_information 
                        (toploop_parser_basis,toploop_type_basis, info) (debug,false)
                    in
                      (name', get_arg_type(#1(NewMap.apply interpreter_information debug)),
                       ty_env,true)
                    end
                else
                  raise NewMap.Undefined)
                  handle NewMap.Undefined  => (name',Datatypes.NULLTYPE,default_ty_env,true)
d330 1
a330 2
        update_environment
        interpreter_information_fn (toploop_parser_basis_fn,toploop_type_basis_fn) 
d334 3
a336 3
           val toploop_parser_basis = toploop_parser_basis_fn()
           val toploop_type_basis = toploop_type_basis_fn()
           val interpreter_information = interpreter_information_fn()
d354 1
a354 1
                      annotations,source_file,position,type_from_encapsulation) = 
d419 2
a420 5
                                          ty_env,
                                          exn_lookup
                                          (toploop_parser_basis,
                                           toploop_type_basis,interpreter_information),
                                          type_from_encapsulation),"\n"),
d433 1
a433 4
                                        ty_env,
                                        exn_lookup(toploop_parser_basis,
                                                   toploop_type_basis,interpreter_information),
                                        type_from_encapsulation),
d459 6
a464 6
              output(std_out," :<  - go to the top of the stack \n");
              output(std_out," :n  - next frame up the stack \n");
              output(std_out," :nm - next frame up the stack \n");
              output(std_out," :p  - next frame down the stack \n");
              output(std_out," :bv - do a backtrace of the stack \n");
              output(std_out," :b  - do a backtrace of the stack without values\n");
d466 1
a466 1
                then output(std_out," :c  - continue \n")
d468 3
a470 1
              output(std_out," :s  - set new default path \n");
d479 1
a479 1
                 val (another,next_frame,offset) = get_next_frame current_frame
d513 1
a513 1
                 val (another,next_frame,offset) = get_next_frame current_frame
a582 30
             val unit_type =
               Datatypes.RECTYPE Datatypes.Mapping.empty_map

             fun update_it_to_unit () =
               update_environment("it",unit_type,MLWorks.Internal.Value.cast 0)
               
             fun update_it_to_value(current_frame,current_info) =
               (case current_info of 
                  (OK (x,ty,_)) => 
                    let
                      val ty' = get_arg_type ty
                      val is_nulltype = 
                        case ty' of
                          Datatypes.NULLTYPE => true
                        | _ => false
                    in
                      if is_nulltype orelse Debugger_Type_Utilities.is_type_polymorphic(ty')
                        then
                          update_it_to_unit()
                      else
                        let
                          val arg = 
                            MLWorks.Internal.Debugger.get_value_from_frame 
                            (current_frame,MLWorks.Internal.Debugger.I0)   
                        in
                          update_environment("it",ty',arg)
                        end
                    end
                | _ => update_it_to_unit())

d588 1
a588 4
               val _ = update_it_to_value(current_frame,current_info)
               val _ = output(std_out,"MLWorks Debugger " ^ 
                              Integer.makestring(!debugger_depth) ^
                              " > ")
d637 1
a637 5
                   let
                     val _ = debugger_depth := !debugger_depth - 1
                     val _ = update_it_to_unit()
                   in
                     if !are_we_breakpointing orelse !are_we_tracing
a639 1
                   end
d646 3
d650 1
a650 1
               | _ => (execute_function (command' ^ " ");
d652 1
d659 1
a659 1
               val (_,first_frame,first_offset) = get_next_frame(top_frame)
d673 2
a674 1
                 val trace_lookup = find_object(object,!functions_to_trace)
d677 1
a677 1
                   Found =>
a685 2
                       val indent = implode(generate (!trace_depth))
                       val (frame,details) = deal_with_frame (top_frame,indent,false)
d687 2
d695 1
a695 1
                                  deal_with_next_monomorphic([deal_with_frame (top_frame,indent,false)],false)
d709 1
a709 6
                                                             ty_env,
                                                             exn_lookup
                                                             (toploop_parser_basis,
                                                              toploop_type_basis,
                                                              interpreter_information),
                                                             false)
d716 1
a716 3
                             val old_trace_frames = ! trace_frames
                             val _ = trace_frames := (frame,to_be_updated):: !trace_frames
                             val _ = trace_depth := !trace_depth + 1
d718 1
a718 2
                             val _ = trace_frames := old_trace_frames
                             val _ = trace_depth := !trace_depth - 1
d720 1
a720 1
                             val _ = output(std_out,indent ^ "Returns " ^
d729 1
a729 1
                 | NotFound => 
d731 1
a731 1
                       val breakpoint_lookup = find_object(object,!functions_to_breakpoint)
d734 5
a738 6
                         Found => (debugger_depth := ! debugger_depth + 1;
                                   output(std_out,"\nReached a breakpoint...\n");
                                   do_input([],[deal_with_frame (top_frame,"",false)]))
                       | NotFound => (output(std_out,
                                             "Found interesting object that is being neither traced nor breakpointed\n");
                                      MLWorks.Internal.Debugger.DO_SINGLE_STEP)
d747 1
a747 6
                                                              Datatypes.TE (empty_map),
                                                              exn_lookup(toploop_parser_basis,
                                                                         toploop_type_basis,
                                                                         interpreter_information),
                                                              false) ^ "\n")
                 val _= debugger_depth := !debugger_depth + 1
a752 18

      fun toplevel_value_printer (toploop_parser_basis,
                                  toploop_type_basis,
                                  interpreter_information_fn) (object,ty) =
        let
          val Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,_)) = toploop_type_basis()
        in
          ValuePrinter.stringify_value
          (ValuePrinter.toplevel_default_print_descriptor,
           object,
           ty,
           ty_env,
           exn_lookup(toploop_parser_basis(),
                      toploop_type_basis(),
                      interpreter_information_fn()),
           false)
        end
        
@


1.26
log
@Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.
@
text
@d4 4
d478 1
a478 1
                           (Parser.empty_pB,Basis.empty_basis,NewMap.empty (fn _ => NewMap.EQUAL),true)
d492 1
a492 1
                              (Parser.empty_pB,Basis.empty_basis,NewMap.empty (fn _ => NewMap.EQUAL),true)
d497 1
a497 1
                      (Parser.empty_pB,Basis.empty_basis,NewMap.empty (fn _ => NewMap.EQUAL),true)))
@


1.25
log
@Added switches t the value-printer to control depth of printing etc
@
text
@d4 3
d205 1
a205 1
       fun trace interpreter_info closure = 
d207 1
d226 1
a226 1
                   (#2((NewMap.apply (interpreter_info()) debug_info) :
d281 1
a281 1
       fun breakpoint interpreter_info closure = 
d283 1
d298 1
a298 1
                   (#2((NewMap.apply (interpreter_info()) debug_info) :
d445 2
a446 1
             (toploop_parser_basis,toploop_type_basis,interpreter_information)
d466 1
a466 1
                               val (p,b,mapping,_) = 
d508 3
a510 1
           fun exn_lookup (toploop_parser_basis,toploop_type_basis,interpreter_information) debug =
d535 1
a535 1
                        (toploop_parser_basis,toploop_type_basis,interpreter_information) (debug,false)
d1022 3
a1024 1
      fun toplevel_value_printer(toploop_parser_basis,toploop_type_basis,interpreter_information_fn)(object,ty) =
d1028 9
a1036 7
          ValuePrinter.stringify_value(ValuePrinter.toplevel_default_print_descriptor,
                                       object,
                                       ty,
                                       ty_env,
                                       exn_lookup(toploop_parser_basis(),toploop_type_basis(),
                                                  interpreter_information_fn()),
                                       false)
@


1.24
log
@Added functionality to the value_printer
@
text
@d4 3
d112 1
a112 1
         fun print_argument (text,arg as (_,ty,_,_,_),after) =
d625 8
a632 7
                                         (arg,
                                         get_arg_type f_type,
                                         ty_env,
                                         exn_lookup
                                         (toploop_parser_basis,
                                          toploop_type_basis,interpreter_information),
                                         type_from_encapsulation),"\n"),
d643 6
a648 5
                                       (arg,arg_type,
                                       ty_env,
                                       exn_lookup(toploop_parser_basis,
                                                  toploop_type_basis,interpreter_information),
                                       type_from_encapsulation),
a682 1
              output(std_out," :q  - quit \n");
a881 2
               | (":q",_,_,_) => MLWorks.Internal.Debugger.exit 0
                   
d953 2
a954 1
                               ValuePrinter.stringify_value (arg,arg_ty,
d999 2
a1000 1
                                ValuePrinter.stringify_value (exception_object,
d1018 2
a1019 1
          ValuePrinter.stringify_value(object,
@


1.23
log
@Small fix to :n fred
@
text
@d4 3
d957 1
a957 1
                                                             true)
@


1.22
log
@Used get_code_object_debug_info in the trace code
@
text
@d4 3
d731 1
a731 1
                         else String.substring(debug_info,x,len) = name orelse search(x+1)
d845 1
a845 1
               | (":n",function_name,_,[]) =>
@


1.21
log
@Neatened up the output a bit
@
text
@d4 3
d190 2
a191 4
       (* Replace this with some C stuff *)
     fun get_function_debug_info _ = 
       (output(std_out,"Function debug needs writing\n");
        "akakakakaka")
@


1.20
log
@Rationalisation of the MLWorks structure.
@
text
@d4 3
d806 3
a808 1
                          val arg = MLWorks.Internal.Debugger.get_value_from_frame (current_frame,MLWorks.Internal.Debugger.I0)   
d817 1
d819 1
d979 1
a979 1
                                   output(std_out,"Reached a breakpoint...\n");
@


1.19
log
@Removed some redundant structures and sharing
@
text
@d4 3
d148 1
a148 1
       val trace_frames = ref([] : (MLWorks.Debugger.StackFrame * MLWorks.Debugger.StackFrame ref) list)
d158 1
a158 1
           val result as (_,next,_) = MLWorks.Debugger.get_next_frame x
d167 2
a168 2
       val functions_to_trace = ref([] : MLWorks.System.Unsafe.Value.ml_value list)
       val functions_to_breakpoint = ref([] : MLWorks.System.Unsafe.Value.ml_value list)
d191 2
a192 2
           val closure = MLWorks.System.Unsafe.Value.cast closure
           val code_string = MLWorks.Debugger.get_object_at_address(closure,~1)
d219 1
a219 1
                    MLWorks.Debugger.tag_as_interesting code_string;
d221 1
a221 1
                    MLWorks.Debugger.start_single_stepping();
d229 2
a230 2
           val closure = MLWorks.System.Unsafe.Value.cast closure
           val code_string = MLWorks.Debugger.get_object_at_address(closure,~1)
d236 1
a236 1
                MLWorks.Debugger.untag_as_interesting code_string;
d247 1
a247 1
                 MLWorks.Debugger.untag_as_interesting code_string;
d257 1
a257 1
         (map MLWorks.Debugger.untag_as_interesting (!functions_to_trace);
d261 1
a261 1
            [] => MLWorks.Debugger.stop_single_stepping ()
d266 2
a267 2
           val closure = MLWorks.System.Unsafe.Value.cast closure
           val code_string = MLWorks.Debugger.get_object_at_address(closure,~1)
d290 1
a290 1
                    MLWorks.Debugger.tag_as_interesting code_string;
d292 1
a292 1
                    MLWorks.Debugger.start_single_stepping();
d299 2
a300 2
           val closure = MLWorks.System.Unsafe.Value.cast closure
           val code_string = MLWorks.Debugger.get_object_at_address(closure,~1)
d306 1
a306 1
                MLWorks.Debugger.untag_as_interesting code_string;
d317 1
a317 1
                 MLWorks.Debugger.untag_as_interesting code_string;
d327 1
a327 1
         (map MLWorks.Debugger.untag_as_interesting (!functions_to_breakpoint);
d330 1
a330 1
            [] => MLWorks.Debugger.stop_single_stepping ()
d497 2
a498 2
                 else if MLWorks.String.substring(name,x,1) = " "
                        then MLWorks.String.substring(name,0,x)
d536 1
a536 1
               MLWorks.Debugger.CONTINUABLE => (debug(fn _ => "Continuable\n");
d538 1
a538 1
             | MLWorks.Debugger.SINGLE_STEP _ => (debug(fn _ => "Single step\n");
d545 1
a545 1
               val debug_info = MLWorks.Debugger.get_data_from_frame current
d554 1
a554 1
                 val arg = MLWorks.Debugger.get_value_from_frame (current,MLWorks.Debugger.I0)
d696 1
a696 1
                   val debug_info = MLWorks.Debugger.get_data_from_frame current
d718 1
a718 1
                       val debug_info = MLWorks.Debugger.get_data_from_frame next_frame
d763 1
a763 1
                 val debug_info = MLWorks.Debugger.get_data_from_frame frame
d765 1
a765 1
                 val (another,next,_) = MLWorks.Debugger.get_next_frame frame
d786 1
a786 1
               update_environment("it",unit_type,MLWorks.System.Unsafe.Value.cast 0)
d803 1
a803 1
                          val arg = MLWorks.Debugger.get_value_from_frame (current_frame,MLWorks.Debugger.I0)   
d861 1
a861 1
                               then MLWorks.Debugger.exit 0
d864 1
a864 1
               | (":q",_,_,_) => MLWorks.Debugger.exit 0
d872 2
a873 2
                       then MLWorks.Debugger.DO_SINGLE_STEP
                     else MLWorks.Debugger.CONTINUE
d892 1
a892 1
               val top_debug_info = MLWorks.Debugger.get_data_from_frame first_frame
d902 1
a902 1
             MLWorks.Debugger.SINGLE_STEP (object,offset,stack_size) =>
d944 2
a945 2
                             val closure = MLWorks.Debugger.get_value_from_frame (frame,MLWorks.Debugger.I1)   
                             val arg = MLWorks.Debugger.get_value_from_frame (frame,MLWorks.Debugger.I0)   
d949 1
a949 1
                             val to_be_updated = ref(top_frame : MLWorks.Debugger.StackFrame)
d953 1
a953 1
                             val result =  MLWorks.Debugger.call_function((arg,offset,stack_size),closure,to_be_updated)
d961 1
a961 1
                             MLWorks.Debugger.TRACE_RETURN_VALUE result
d964 1
a964 1
                               MLWorks.Debugger.DO_SINGLE_STEP)
d976 1
a976 1
                                      MLWorks.Debugger.DO_SINGLE_STEP)
@


1.18
log
@Fixed a few bugs and added binding of frame arguments to it
@
text
@d4 3
a52 1
require "../utils/newmap";
a57 1

a63 1
   structure NewMap : NEWMAP
d83 1
a83 1

d112 1
a112 1
                               (int * Debugger_Types.Backend_Annotation) list) Debugger_Types.Map.T * bool)) 
d206 1
a206 1
                   (#2((Debugger_Types.Map.apply (interpreter_info()) debug_info) :
d208 1
a208 1
                   handle Debugger_Types.Map.Undefined => false
d277 1
a277 1
                   (#2((Debugger_Types.Map.apply (interpreter_info()) debug_info) :
d279 1
a279 1
                   handle Debugger_Types.Map.Undefined => false
d432 1
a432 1
                 (Get_Type_Information.Debugger_Types.Map.apply interpreter_information st;
d434 1
a434 1
                 handle Get_Type_Information.Debugger_Types.Map.Undefined => 
d452 1
a452 1
                           (Parser.empty_pB,Basis.empty_basis,Debugger_Types.Map.empty (fn _ => Debugger_Types.Map.EQUAL),true)
d466 1
a466 1
                              (Parser.empty_pB,Basis.empty_basis,Debugger_Types.Map.empty (fn _ => Debugger_Types.Map.EQUAL),true)
d471 1
a471 1
                      (Parser.empty_pB,Basis.empty_basis,Debugger_Types.Map.empty (fn _ => Debugger_Types.Map.EQUAL),true)))
d476 2
a477 2
               val (found,(lookup,is_leaf,annotations)) = (true,Get_Type_Information.Debugger_Types.Map.apply mapping st)
                 handle Get_Type_Information.Debugger_Types.Map.Undefined => (false,(Datatypes.NULLTYPE,false,[]))
d500 1
a500 1
                 val (ty,_,_) = Debugger_Types.Map.apply interpreter_information debug
d513 1
a513 1
                      (name', get_arg_type(#1(Debugger_Types.Map.apply interpreter_information debug)),
d517 2
a518 2
                  raise Debugger_Types.Map.Undefined)
                  handle Debugger_Types.Map.Undefined  => (name',Datatypes.NULLTYPE,default_ty_env,true)
@


1.17
log
@Added details about leafness to the debug information
@
text
@d4 3
d181 6
a186 1
       fun trace closure = 
d190 1
d205 4
d210 10
a219 5
                 (functions_to_trace := code_string :: ! functions_to_trace;
                  MLWorks.Debugger.tag_as_interesting code_string;
                  are_we_tracing := true;
                  MLWorks.Debugger.start_single_stepping();
                  true)
d254 3
a256 1
         (map MLWorks.Debugger.tag_as_interesting (!functions_to_trace);
d261 1
a261 1
       fun breakpoint closure = 
d265 1
d275 17
a291 5
               (functions_to_breakpoint := code_string :: ! functions_to_breakpoint;
                MLWorks.Debugger.tag_as_interesting code_string;
                are_we_breakpointing := true;
                MLWorks.Debugger.start_single_stepping();
                true)
d324 2
a325 1
         (map MLWorks.Debugger.tag_as_interesting (!functions_to_breakpoint);
d488 1
d500 1
a500 26
                 val (tystr,ty_env,type_from_encapsulation) =
                   (let
                     val Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,Datatypes.VE(_,exn_map))) = toploop_type_basis
                   in
                     (Datatypes.NewMap.apply
                      exn_map
                      (Datatypes.Ident.EXCON (Datatypes.Ident.Symbol.find_symbol name')),ty_env,true)
                   end                         
                 handle Datatypes.NewMap.Undefined => 
                   ((if !show_compiler_frames
                       then
                         let
                           val (_,Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,Datatypes.VE(_,exn_map))),
                                ty,_,_,_,_,_) = 
                             get_type_information 
                             (toploop_parser_basis,toploop_type_basis,interpreter_information) (debug,false)
                         in
                           (Datatypes.NewMap.apply
                            exn_map
                            (Datatypes.Ident.EXCON (Datatypes.Ident.Symbol.find_symbol name)),ty_env,false)
                         end
                     else
                       raise Datatypes.NewMap.Undefined)
                 handle Datatypes.NewMap.Undefined => 
                   (Datatypes.UNBOUND_SCHEME Datatypes.NULLTYPE,Datatypes.TE(empty_map),true)))

d502 1
a502 13
                 case tystr of
                   Datatypes.UNBOUND_SCHEME x => 
                     let
                       val arg = get_arg_type x
                     in
                       (name,arg,ty_env,type_from_encapsulation)
                     end
                 | Datatypes.SCHEME (level,ty) =>
                     if level=0
                       then (name,get_arg_type ty,Datatypes.TE(empty_map),type_from_encapsulation)
                     else (output(std_out,"Scheme when looking up an exception with non-zero count\n");
                           (name,Datatypes.NULLTYPE,Datatypes.TE(empty_map),type_from_encapsulation))
                 | _ => (name',Datatypes.NULLTYPE,ty_env,type_from_encapsulation)
d504 15
d521 3
a523 1
      fun ml_debugger interpreter_information_fn (toploop_parser_basis_fn,toploop_type_basis_fn) 
d779 29
a807 1
           fun do_input (previous_frames,frames as ((current as (current_frame,current_info))::rest_of_frames)) =
d810 1
d866 1
d985 1
a985 1
                                                              true) ^ "\n")
@


1.16
log
@Added a loop inside the debugger
@
text
@d4 3
d85 1
d108 2
a109 1
                               Datatypes.Type * (int * Debugger_Types.Backend_Annotation) list) Debugger_Types.Map.T * bool)) 
d442 2
a443 2
               val (found,(lookup,annotations)) = (true,Get_Type_Information.Debugger_Types.Map.apply mapping st)
                 handle Get_Type_Information.Debugger_Types.Map.Undefined => (false,(Datatypes.NULLTYPE,[]))
d447 1
a447 1
                   (p,b,lookup,annotations,source_file,position,type_from_encapsulation)
d449 1
a449 1
                 (p,b,Datatypes.NULLTYPE,[],"","",type_from_encapsulation)
d455 8
d471 1
a471 1
                      (Datatypes.Ident.EXCON (Datatypes.Ident.Symbol.find_symbol name)),ty_env,true)
d478 1
a478 1
                                ty,_,_,_,_) = 
d504 1
a504 1
                 | _ => (name,Datatypes.NULLTYPE,ty_env,type_from_encapsulation)
d531 2
a532 1
                 val (_,Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,_)),ty,annotations,source_file,position,type_from_encapsulation) = 
d538 1
a538 1
                 val current_annotation = Lists.assoc (offset,annotations) handle Lists.Assoc => Debugger_Types.Nop
d767 3
a769 1
               val _ = output(std_out,"MlWorks Debugger> ")
d820 8
a827 4
                   if !are_we_breakpointing orelse !are_we_tracing
                     then MLWorks.Debugger.DO_SINGLE_STEP
                   else MLWorks.Debugger.CONTINUE
                   
d923 2
a924 1
                         Found => (output(std_out,"Reached a breakpoint...\n");
d941 1
@


1.15
log
@Added untrace
@
text
@d4 3
d461 14
a474 10
                   (let
                     val (_,Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,Datatypes.VE(_,exn_map))),
                          ty,_,_,_,_) = 
                       get_type_information 
                       (toploop_parser_basis,toploop_type_basis,interpreter_information) (debug,false)
                   in
                     (Datatypes.NewMap.apply
                      exn_map
                      (Datatypes.Ident.EXCON (Datatypes.Ident.Symbol.find_symbol name)),ty_env,false)
                   end
d496 2
a497 1
         (top_frame,type_of_exception,exception_object) = 
d706 4
a709 1
                 val (_,new_frames as ((_,status)::_)) = do_next(current_frame,frames,print_instantiated)
d742 4
a745 1
                 val (top::rest) = rev frames @@ previous_frames
d754 1
a754 1
               val command = get_line std_in
d758 1
a758 1
               val (command,args) = parse_command(explode command,[])
d814 1
a814 1
               | _ => (output(std_out,"Not recognised - type 'help' for help\n");
@


1.14
log
@Changed to reflect changes to pervasive_library
@
text
@d4 3
d539 2
d668 1
a668 1
                 
d705 1
d716 1
d803 1
d842 2
a843 1
                                val (_,analysed) = deal_with_next_monomorphic([deal_with_frame (top_frame,indent,false)],false)
d846 1
@


1.13
log
@Various improvements
@
text
@d4 3
d39 1
d52 1
d150 2
a151 2
       val functions_to_trace = ref([] : MLWorks.Debugger.ml_value list)
       val functions_to_breakpoint = ref([] : MLWorks.Debugger.ml_value list)
d169 1
a169 1
           val closure = MLWorks.System.Unsafe.Int.make_ml_value closure
d197 1
a197 1
           val closure = MLWorks.System.Unsafe.Int.make_ml_value closure
d224 6
d232 1
a232 1
           val closure = MLWorks.System.Unsafe.Int.make_ml_value closure
d252 1
a252 1
           val closure = MLWorks.System.Unsafe.Int.make_ml_value closure
d279 6
d646 45
d750 3
d770 5
a774 1
               | (":p","",top::old,prev) => do_input (top::prev,old)
@


1.12
log
@Corrected a few errors
@
text
@d4 3
d67 2
d75 11
d93 1
a93 1
                               Datatypes.Type * (int * Debugger_Types.Backend_Annotation) list) Debugger_Types.Map.T)) 
d371 1
a371 1
                  (toploop_parser_basis,toploop_type_basis,interpreter_information))
d377 14
a390 10
                         let
                           val _ =
                             output(std_out,"Reading type information from file " ^ file ^ " - please wait ...\n")
                           val (p,b,mapping,_) = 
                             Get_Type_Information.get_type_information file
                           val _ = 
                             add_to_cache(file,(p,b,mapping))
                         in
                           (p,b,mapping)
                         end
d404 1
a404 1
                              (Parser.empty_pB,Basis.empty_basis,Debugger_Types.Map.empty (fn _ => Debugger_Types.Map.EQUAL))
d409 1
a409 1
                      (Parser.empty_pB,Basis.empty_basis,Debugger_Types.Map.empty (fn _ => Debugger_Types.Map.EQUAL))))
d411 1
a411 1
               val (p,b,mapping) = 
d419 1
a419 1
                   (p,b,lookup,annotations,source_file,position)
d421 1
a421 1
                 (p,b,Datatypes.NULLTYPE,[],"","")
d429 22
a450 21
                 val (tystr,ty_env) =
                   if file_name=""
                     then
                       let
                         val Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,Datatypes.VE(_,exn_map))) = toploop_type_basis
                       in
                         (Datatypes.NewMap.apply
                          exn_map
                          (Datatypes.Ident.EXCON (Datatypes.Ident.Symbol.find_symbol name)),ty_env)
                       end                         
                   else
                     let
                       val (_,Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,Datatypes.VE(_,exn_map))),
                            ty,_,_,_) = 
                         get_type_information 
                         (toploop_parser_basis,toploop_type_basis,interpreter_information) (debug,false)
                     in
                       (Datatypes.NewMap.apply
                        exn_map
                        (Datatypes.Ident.EXCON (Datatypes.Ident.Symbol.find_symbol name)),ty_env)
                     end
d457 1
a457 1
                       (name,arg,ty_env)
d461 1
a461 1
                       then (name,get_arg_type ty,Datatypes.TE(empty_map))
d463 2
a464 2
                           (name,Datatypes.NULLTYPE,Datatypes.TE(empty_map)))
                 | _ => (name,Datatypes.NULLTYPE,ty_env)
a465 2
             handle Datatypes.NewMap.Undefined => 
               (name,Datatypes.NULLTYPE,Datatypes.TE(empty_map))
d490 1
a490 1
                 val (_,Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,_)),ty,annotations,source_file,position) = 
d509 1
a509 1
                   | propogate_new_type_information (ty,(frame,TO_BE_INSTANTIATED(details,infer))::rest) =
d522 1
a522 2
                           ((if print_instantiated then output(std_out,details ^ "\n") else ());
                            print rest;
d538 1
a538 1
                         indent ^ "General type: " ^ Types.print_type ty ^ "\n"
d549 8
a556 10
                          indent ^ "Argument: " ^
                          ValuePrinter.stringify_value (arg,
                                                        (* inferred_type, *)
                                                        get_arg_type f_type,
                                                        ty_env,
                                                        exn_lookup
                                                        (toploop_parser_basis,
                                                         toploop_type_basis,interpreter_information),
                                                        true) 
                          ^ "\n",
d566 7
a572 5
                       ValuePrinter.stringify_value (arg,arg_type,
                                                     ty_env,
                                                     exn_lookup(toploop_parser_basis,
                                                                toploop_type_basis,interpreter_information),
                                                     true) 
d575 2
a576 4
                         indent ^ "General type: " ^ Types.print_type ty ^ "\n" ^
                         indent ^ "Argument: " ^ 
                         string_argument ^
                         "\n",ty,ty_env),
d597 6
a602 6
              output(std_out," top              - go to the top of the stack \n");
              output(std_out," next             - next frame up the stack \n");
              output(std_out," next monomorphic - next frame up the stack \n");
              output(std_out," prev             - next frame down the stack \n");
              output(std_out," backtrace        - do a backtrace of the stack \n");
              output(std_out," simple backtrace - do a backtrace of the stack without values\n");
d604 1
a604 1
                then output(std_out," continue         - continue \n")
d606 2
a607 2
              output(std_out," quit             - quit \n");
              output(std_out," set              - set new default path \n");
d657 1
a657 1
                 else ()
d679 1
a679 1
                 ("top",_,_,_) => 
d682 1
a682 1
                | ("next","",_,(h,info)::t) =>
d685 1
a685 1
               | ("next","",_,[]) =>
d688 1
a688 1
               | ("backtrace",_,_,_) => 
d691 1
a691 1
               | ("simple backtrace",_,_,_) =>
d695 1
a695 1
               | ("next monomorphic",_,_,(top as (_,OK _)) :: rest) =>
d698 1
a698 1
               | ("next monomorphic",_,_,_) =>
d701 1
a701 1
               | ("prev","",[_],_) =>
d705 1
a705 1
               | ("prev","",top::old,prev) => do_input (top::prev,old)
d711 1
a711 1
               | ("quit",_,_,_) => MLWorks.Debugger.exit 0
d713 1
a713 1
               | ("continue",_,_,_) => 
d718 1
a718 1
               | ("set",_,_,_) => (set_new_default_path();
a782 1
                             val _ = trace_depth := !trace_depth + 1
d791 1
d794 1
@


1.11
log
@Neatening up, plus changes due to lower level sharing changes
@
text
@d4 3
d81 3
a83 1
           fun cache_lookup(x,[]) = raise CacheFail
d86 2
a87 1
                 then (t,rest)
d103 1
a103 1
             | clean(n,h::t) = clean(n-1,t)
d115 1
a115 2
             then (output(std_out,"Found it\n"); 
                   get_next_frame b)
a120 1
           val _ = check(result,next,!trace_frames)
d122 1
a122 1
           result
d363 1
a363 1
                             output(std_out,"Reading type information from a file - please wait ...\n")
d571 1
a571 1
                  handle Substring => (OK(debug_info ^ "\n" ^ "No data available\n",Datatypes.NULLTYPE,
d646 1
a646 1
                 val (top::rest) = rev previous_frames @@ frames
d718 1
a718 1
               val _ = debug(fn _ => "Displaying the frame status\n")
d748 1
a748 2
                             (output(std_out,"Polymorphic frame\n");
                              let
@


1.10
log
@More improvements
@
text
@d4 3
d44 1
a44 1
   structure Debugger_Type_Utilities : DEBUGGER_TYPE_UTILITIES
d46 5
a50 4
   sharing Get_Type_Information.Basis.Datatypes = Types.Datatypes = ValuePrinter.Datatypes
   sharing Get_Type_Information.Debugger_Types = Debugger_Type_Utilities.Debugger_Types
   sharing type Debugger_Type_Utilities.Debugger_Types.Datatypes.Type = Types.Type
       
d56 1
a56 1
       structure Datatypes = Basis.Datatypes
d64 38
d104 1
a104 1
       val trace_frames = ref([] : (Debugger.StackFrame * Debugger.StackFrame ref) list)
d115 1
a115 3
           val _ = debug(fn _ => "get_next_frame called on " ^ Integer.makestring(x*4) ^ "\n")
           val result as (_,next,_) = Debugger.get_next_frame x
           val _ = debug(fn _ => "get_next_frame returns " ^ Integer.makestring(next*4) ^ "\n")
a122 2
       val unused = System.Unsafe.Int.make_ml_value 0

d125 2
a126 2
       val functions_to_trace = ref([] : ml_value list)
       val functions_to_breakpoint = ref([] : ml_value list)
d144 2
a145 2
           val closure = System.Unsafe.Int.make_ml_value closure
           val code_string = Debugger.get_object_at_address(closure,~1)
d162 1
a162 1
                  Debugger.tag_as_interesting code_string;
d164 1
a164 1
                  Debugger.start_single_stepping();
d172 2
a173 2
           val closure = System.Unsafe.Int.make_ml_value closure
           val code_string = Debugger.get_object_at_address(closure,~1)
d179 1
a179 1
                Debugger.untag_as_interesting code_string;
d190 1
a190 1
                 Debugger.untag_as_interesting code_string;
d201 2
a202 2
           val closure = System.Unsafe.Int.make_ml_value closure
           val code_string = Debugger.get_object_at_address(closure,~1)
d213 1
a213 1
                Debugger.tag_as_interesting code_string;
d215 1
a215 1
                Debugger.start_single_stepping();
d221 2
a222 2
           val closure = System.Unsafe.Int.make_ml_value closure
           val code_string = Debugger.get_object_at_address(closure,~1)
d228 1
a228 1
                Debugger.untag_as_interesting code_string;
d239 1
a239 1
                 Debugger.untag_as_interesting code_string;
d310 1
a310 1
                   val char = NewJersey.String.substring(x,pos,1)
d320 3
a322 3
               (NewJersey.String.substring(x,0,start_of_file_name),
                NewJersey.String.substring(x,start_of_file_name+1,end_of_file_name - start_of_file_name - 1),
                NewJersey.String.substring(x,end_of_file_name+1,size x - end_of_file_name - 1))
d330 1
a330 1
                   NewJersey.String.substring(filename, len-4, 4)
d334 1
a334 1
                 ".sml" => NewJersey.String.substring(filename, 0, len-4)
d350 2
a351 2
                 (Get_Type_Information.Debugger_Types.Map.apply  (! interpreter_information) st;
                  (!toploop_parser_basis,!toploop_type_basis,!interpreter_information))
d355 12
a366 2
                     val (p,b,mapping,_) = 
                       Get_Type_Information.get_type_information file
d368 1
a368 1
                     (p,b,mapping)
d374 1
a374 1
                          val _ = output(std_out,"File " ^ arg ^ " not found\n");
d409 1
a409 2
                         val Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,Datatypes.VE(_,exn_map))) = 
                           ! toploop_type_basis
d445 1
a445 1
      fun ml_debugger interpreter_information (toploop_parser_basis,toploop_type_basis) 
d448 3
a451 2
           val _ = debug(fn _ => "top frame on entry is " ^ Integer.makestring(top_frame*4) ^ "\n")
           
d454 1
a454 1
               Debugger.CONTINUABLE => (debug(fn _ => "Continuable\n");
d456 1
a456 1
             | Debugger.SINGLE_STEP _ => (debug(fn _ => "Single step\n");
d463 1
a463 1
               val debug_info = Debugger.get_data_from_frame current
d471 1
a471 1
                 val arg = Debugger.get_value_from_frame (current,Debugger.I0)
d577 1
d582 1
d629 18
d652 4
d657 6
a662 2
               case (command,frames,previous_frames) of
                 ("next",_,(h,info)::t) =>
d665 1
a665 1
               | ("next",_,[]) =>
d668 1
a668 1
               | ("backtrace",_,_) => 
d671 5
a675 1
               | ("next monomorphic",_,(top as (_,OK _)) :: rest) =>
d678 1
a678 1
               | ("next monomorphic",_,_) =>
d681 1
a681 1
               | ("prev",[_],_) =>
d685 1
a685 1
               | ("prev",top::old,prev) => do_input (top::prev,old)
d687 2
a688 2
               | ("",_,_) => if end_of_stream std_in
                               then Debugger.exit 0
d691 1
a691 1
               | ("quit",_,_) => Debugger.exit 0
d693 1
a693 1
               | ("continue",_,_) => 
d695 2
a696 2
                     then Debugger.DO_SINGLE_STEP
                   else Debugger.CONTINUE
d698 2
a699 5
               | ("set",_,_) => (set_new_default_path();
                               do_input (previous_frames,frames))

               | ("help",_,_) => (display_help_info();
                                  do_input (previous_frames,frames))
d701 3
d713 1
a713 1
               val top_debug_info = Debugger.get_data_from_frame first_frame
d723 1
a723 1
             Debugger.SINGLE_STEP (object,offset,stack_size) =>
d765 2
a766 2
                             val closure = Debugger.get_value_from_frame (frame,Debugger.I1)   
                             val arg = Debugger.get_value_from_frame (frame,Debugger.I0)   
d770 1
a770 1
                             val to_be_updated = ref(0: Debugger.StackFrame)
d773 1
a773 1
                             val result =  Debugger.call_function((arg,offset,stack_size),closure,to_be_updated)
d780 1
a780 1
                             Debugger.TRACE_RETURN_VALUE result
d783 1
a783 1
                               Debugger.DO_SINGLE_STEP)
d794 1
a794 1
                                      Debugger.DO_SINGLE_STEP)
d813 1
a813 1
      fun toplevel_value_printer(toploop_parser_basis,toploop_type_basis,interpreter_information)(object,ty) =
d815 1
a815 1
          val Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,_)) = ! toploop_type_basis
d820 2
a821 1
                                       exn_lookup(toploop_parser_basis,toploop_type_basis,interpreter_information),
@


1.9
log
@New sharing constraints after lower level changes
@
text
@d57 1
d60 21
d120 2
a121 1
                         else trace_depth := 0
a211 2
       fun debug(x) = () (* output(std_out,x()) *)

d401 2
d412 1
a412 1
           fun calculate_frame_status (current,offset,other_frames,indent) =
d444 4
a447 1
                         | print((_,TO_BE_INSTANTIATED(x,_))::rest) = (print rest ; output(std_out,x ^ "\n"))
d451 1
a451 1
                           (output(std_out,details ^ "\n");
d457 1
a457 1
                       output(std_out,res ^ "\n");
d467 1
a467 1
                         indent ^ debug_info ^ "\n" ^ 
d544 1
a544 1
             fun do_next(current_frame,frames) =
d546 1
a546 1
                 val (another,next_frame,offset) = Debugger.get_next_frame current_frame
d551 1
a551 1
                       val (status,new_frames) = calculate_frame_status (next_frame,offset,frames,"")
d559 1
a559 1
             fun deal_with_next_monomorphic(frames as ((current_frame,_)::_)) =
d561 1
a561 1
                 val (_,new_frames as ((_,status)::_)) = do_next(current_frame,frames)
d566 1
a566 1
                    deal_with_next_monomorphic(new_frames)
d572 1
a572 1
                 val result = #2(do_next(current_frame,frames))
d590 1
a590 1
                   do_input(do_next(current_frame,frames))
d599 1
a599 1
                   do_input(deal_with_next_monomorphic(rev(previous_frames) @@ frames))
d628 1
a628 1
           fun deal_with_frame (top_frame,indent) = 
d631 1
a631 1
               val (_,first_frame,first_offset) = Debugger.get_next_frame(top_frame)
d635 2
a636 1
               val top = (first_frame,#1(calculate_frame_status (first_frame,first_offset,[],indent)))
d643 1
a643 1
             Debugger.SINGLE_STEP (object,offset) =>
d651 6
a656 3
                         if x<0
                           then []
                         else " " :: generate(x-1)
d658 14
a671 1
                       val (frame,details) = deal_with_frame (top_frame,indent)
d689 7
a695 1
                             val result =  Debugger.call_function(closure,arg,offset)
d702 2
a703 1
                       | _ => Debugger.DO_SINGLE_STEP
d711 3
a713 2
                                   do_input([],[deal_with_frame (top_frame,"")]))
                       | NotFound => (output(std_out,"Found interesting object that is being neither traced nor breakpointed\n");
d728 1
a728 1
                 do_input([],[deal_with_frame (top_frame,"")])
@


1.8
log
@Working monomorphic version of trace
@
text
@d4 3
d57 2
d87 1
d89 2
a90 2
           case the_slot of
             Found => (output(std_out,"Already tracing that function\n");
d92 3
a94 1
           | NotFound  =>
d108 1
d138 49
d340 2
a341 1
                         val Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,Datatypes.VE(_,exn_map))) = ! toploop_type_basis
d343 3
a345 3
                         (Datatypes.Mapping.lookup
                          (Datatypes.Ident.EXCON (Datatypes.Ident.Symbol.find_symbol name),
                           exn_map),ty_env)
d351 2
a352 1
                         get_type_information (toploop_parser_basis,toploop_type_basis,interpreter_information) (debug,false)
d354 3
a356 3
                       (Datatypes.Mapping.lookup
                        (Datatypes.Ident.EXCON (Datatypes.Ident.Symbol.find_symbol name),
                         exn_map),ty_env)
d368 1
a368 1
                       then (name,get_arg_type ty,Datatypes.TE(Datatypes.Mapping.empty_map))
d370 1
a370 1
                           (name,Datatypes.NULLTYPE,Datatypes.TE(Datatypes.Mapping.empty_map)))
d373 2
a374 1
             handle Datatypes.Mapping.Lookup => (name,Datatypes.NULLTYPE,Datatypes.TE(Datatypes.Mapping.empty_map))
d420 2
a421 2
                       fun print((OK _)::_) = ()
                         | print(TO_BE_INSTANTIATED(x,_)::rest) = (print rest ; output(std_out,x ^ "\n"))
d494 1
a494 1
                                          Datatypes.TE (Datatypes.Mapping.empty_map)),other_frames)
d496 1
a496 1
                                      Datatypes.NULLTYPE,Datatypes.TE (Datatypes.Mapping.empty_map)),other_frames)
d499 1
a499 1
                                   Datatypes.TE (Datatypes.Mapping.empty_map)),other_frames)
d656 9
a664 1
                     Debugger.DO_SINGLE_STEP
d671 1
a671 1
                                                              Datatypes.TE (Datatypes.Mapping.empty_map),
d677 1
a677 1
                   do_input([],[deal_with_frame (top_frame,"")])
@


1.7
log
@Changed DO_SINGLE_STEP to take a parameter in patterns, as required
@
text
@a3 3
Revision 1.6  1992/07/29  14:28:04  clive
Periodical checking in - many improvements

d54 4
a57 1
       (* Tracing and breakpointing *)
d60 3
a62 6
       val maximum_number_of_functions_to_be_traced = ref(10)
       val functions_being_traced = Array.array(!maximum_number_of_functions_to_be_traced,
                                                System.Unsafe.Int.make_ml_value 0)
       val maximum_number_of_functions_to_be_breakpointed = ref(10)
       val functions_to_breakpoint = Array.array(!maximum_number_of_functions_to_be_breakpointed,
                                                 System.Unsafe.Int.make_ml_value 0)
d64 3
a66 1
       fun trace f =
d68 5
a72 1
           val _ = output(std_out,"Trying to trace something\n")
d74 1
a74 1
           "ok"
d77 54
d133 6
a138 2
       datatype Frame = OK of string
       | TO_BE_INSTANTIATED of (string * (Datatypes.Type -> (string * Datatypes.Type)))
d140 1
a140 1
         fun output_frame_details(OK x ) = output(std_out,x)
d143 3
d168 4
d227 2
a228 1
             (let
d230 7
a236 6
               val (p,b,mapping) = 
                 if source_file = ""
                   then
                     (!toploop_parser_basis,!toploop_type_basis,!interpreter_information)
                 else 
                   let
d238 2
a239 1
                     val (p,b,mapping,_) = Get_Type_Information.get_type_information file
d243 21
a263 1
               val (found,(lookup,annotations)) = (true,Get_Type_Information.Debugger_Types.Map.apply  mapping st)
d271 1
a272 7
             end) 
                handle Io arg => 
                  (if message_on_fail
                     then output(std_out,"File not found - use 'set' to set a new path\n")
                   else ();
                     (Parser.empty_pB,Basis.empty_basis,Datatypes.NULLTYPE,[],"",""))

d316 1
a316 1
       fun ml_debugger interpreter_information (toploop_parser_basis,toploop_type_basis) 
d322 1
a322 1
               Debugger.CONTINUABLE => (output(std_out,"Continuable\n");
d324 1
a324 1
             | Debugger.SINGLE_STEP _ => (output(std_out,"Single step\n");
d328 1
a328 1
           fun display_frame_status (current,offset,other_frames) =
d330 1
d332 1
d354 1
a354 1
                   | propogate_new_type_information (ty,(frame,TO_BE_INSTANTIATED(_,infer))::rest) =
d358 11
a368 3
                                     Types.print_type ty ^ "\n")
                       val (res,ty') = infer ty
                       val result = (frame,OK(res)) :: propogate_new_type_information(ty',rest)
d379 3
a381 1
                       val info = debug_info ^ "\n" ^ "General type: " ^ Types.print_type ty ^ "\n"
d386 20
a405 10
                       (info ^ "Inferred input type " ^ Types.print_type inferred_type ^ "\n" ^
                        "Argument: " ^
                        ValuePrinter.stringify_value (arg,
                                                      inferred_type,
                                                      ty_env,
                                                      exn_lookup
                                                      (toploop_parser_basis,toploop_type_basis,interpreter_information),
                                                      true) 
                        ^ "\n",
                       Debugger_Type_Utilities.apply_recipe(current_annotation,inferred_type))),
d413 2
a414 1
                                                     exn_lookup(toploop_parser_basis,toploop_type_basis,interpreter_information),
d418 2
a419 2
                         "General type: " ^ Types.print_type ty ^ "\n" ^
                         "Argument: " ^ 
d421 9
a429 3
                         "\n"),
                     propogate_new_type_information(Debugger_Type_Utilities.apply_recipe(current_annotation,arg_type),
                                                    other_frames))
d432 4
a435 2
                  handle Substring => (OK(debug_info ^ "\n" ^ "No data available\n"),other_frames)
                       | Match => (OK(debug_info ^ "\n" ^ "No data available\n"),other_frames)
d437 2
a438 1
           handle Substring => (OK("No data available\n"),other_frames)
d442 4
a445 2
              output(std_out," next      - next frame up the stack \n");
              output(std_out," prev      - next frame down the stack \n");
d447 1
a447 1
                then output(std_out," continue  - continue \n")
d449 2
a450 2
              output(std_out," quit      - quit \n");
              output(std_out," set       - set new default path \n");
a455 1
             
d457 35
d495 1
a495 1
               val _ = output(std_out,"Command> ")
d503 10
a512 13
                   let
                     val (another,next_frame,offset) = Debugger.get_next_frame current_frame
                   in
                     if another
                       then 
                         let
                           val (status,new_frames) = display_frame_status (next_frame,offset,frames)
                         in
                           do_input([],(next_frame,status)::new_frames)
                         end
                     else (output(std_out,"At the bottom of the stack\n");
                           do_input ([],frames))
                   end
d537 1
a537 1
               | _ => (output(std_out,"We should call the interpreter with this\n");
d541 1
a541 1
           fun deal_with_frame top_frame = 
d543 1
d545 1
d547 2
a548 1
               val top = (first_frame,#1(display_frame_status (first_frame,first_offset,[])))
d550 1
a550 1
               do_input([],[top])
d555 42
a596 3
             Debugger.SINGLE_STEP _ =>
               (output(std_out,"Single step \n");
                Debugger.DO_SINGLE_STEP)
d608 1
a608 1
                   deal_with_frame top_frame
@


1.6
log
@Periodical checking in - many improvements
@
text
@d4 3
d239 1
a239 1
             | Debugger.SINGLE_STEP => (output(std_out,"Single step\n");
d402 1
a402 1
             Debugger.SINGLE_STEP =>
@


1.5
log
@More work on the debugger
@
text
@d4 3
d22 2
a24 1
require "../utils/lists";
d35 1
d54 17
a231 4
           val _ = output(std_out,"You have entered the debugger...\n")
            
           val (_,first_frame,first_offset) = Debugger.get_next_frame(top_frame)

d234 4
a237 2
               CONTINUABLE => true 
             | SINGLE_STEP => true
d246 2
a247 1
                   get_type_information (toploop_parser_basis,toploop_type_basis,interpreter_information) (debug_info,true)
a319 2
           val top = (first_frame,#1(display_frame_status (first_frame,first_offset,[])))
           
d373 4
a376 4
               | ("continue",_,_) => (Debugger.install_debugger 
                                      (ml_debugger 
                                       interpreter_information (toploop_parser_basis,toploop_type_basis) );
                                      Debugger.CONTINUE)
d381 4
a384 2
               | _ => (output(std_out,"Option not recognised\n");
                       display_help_info ();
d388 9
a396 7

           val _ = output(std_out,"Exception on entry to debugger:" ^ 
                          ValuePrinter.stringify_value (exception_object,
                                                        Datatypes.CONSTYPE([],Types.exn_tyname),
                                                        Datatypes.TE (Datatypes.Mapping.empty_map),
                                                        exn_lookup(toploop_parser_basis,toploop_type_basis,interpreter_information),
                                                        true) ^ "\n")
d398 17
a414 1
           do_input([],[top])
@


1.4
log
@Made the debugger work better, and changes for the new interface to the runtime system
@
text
@d4 3
d37 2
a38 2
   sharing Get_Type_Information.Debugger_Types.Types = Types

d207 1
a207 1
         (top_frame,_,exception_object) = 
d214 6
d305 3
a307 1
              output(std_out," continue  - continue \n");
@


1.3
log
@Support for interpreter
@
text
@d4 3
d19 1
d30 1
d33 2
d44 1
d46 8
a70 7
       fun ml_debugger interpreter_information (toploop_parser_basis,toploop_type_basis) 
         (top_frame,can_continue,exception_object) = 
         let
           
           val _ = output(std_out,"You have entered the debugger...\n")
            
           val (_,first_frame) = Debugger.get_next_frame(top_frame)
d128 3
a130 1
           fun get_type_information (st,message_on_fail) =
d160 1
a160 1
           fun exn_lookup debug =
d162 1
a162 1
               val (name,_,_) = find_source_file_and_name_and_position debug
d165 20
a184 6
                 val (_,Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,Datatypes.VE(_,exn_map))),
                      ty,_,_,_) = 
                   get_type_information(debug,false)
                 val tystr = Datatypes.Mapping.lookup
                   (Datatypes.Ident.EXCON (Datatypes.Ident.Symbol.find_symbol name),
                    exn_map)
d203 9
a211 1
           fun display_frame_status (current) =
d216 3
a218 2
                 val (_,Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,_)),ty,_,source_file,position) = 
                   get_type_information(debug_info,true)
d220 4
a223 2
                 val string_argument = 
                   ValuePrinter.stringify_value (arg,get_arg_type ty,ty_env,exn_lookup,true) 
d232 15
a246 1
                                       
d248 39
a286 8
                 debug_info ^ "\n" ^
                 "General type: " ^ Types.print_type ty ^ "\n" ^
                 "Argument: " ^ 
                 string_argument ^
                 "\n"
               end
             handle Substring => debug_info ^ "\n" ^ "No data available\n"
                  | Match => debug_info ^ "\n" ^ "No data available\n")
d288 1
a288 1
           handle Substring => "No data available\n"
d290 1
a290 1
           val top = (first_frame,display_frame_status first_frame)
a291 14
           fun display_stack_backtrace (h::t) = h::display_stack_backtrace t
             | display_stack_backtrace [(frame,_)] =
               let
                 val (another,next_frame) = Debugger.get_next_frame frame
                 val stat = if another
                              then display_frame_status next_frame
                            else ""
               in
                 if another
                   then (output(std_out,stat);
                         (next_frame,stat) :: display_stack_backtrace [(next_frame,stat)])
                 else []
             end
           
d296 4
a299 7
              output(std_out," backtrace - display a stack backtrace\n");
              if can_continue
                then output(std_out," continue  - continue \n")
              else ();
                output(std_out," quit      - quit \n");
                output(std_out," set       - set new default path \n");
                ())
d306 1
a306 1
           fun do_input (previous_frames,frames as ((current_frame,current_info)::_)) =
d308 1
a308 1
               val _ = output(std_out,current_info)
d318 1
a318 1
                     val (another,next_frame) = Debugger.get_next_frame current_frame
d321 6
a326 1
                       then do_input([],(next_frame,display_frame_status next_frame)::frames)
d346 1
a346 1
                                      ())
a347 8
               | ("backtrace",_,_) => 
                   let
                     val _ = output(std_out,"\nStack backtrace\n\n")
                     val rest = display_stack_backtrace previous_frames
                   in
                     do_input (rest,frames)
                   end

d361 1
a361 1
                                                        exn_lookup,
d367 12
@


1.2
log
@get_next_frame only returns two arguments - the third exnp is no longer required
@
text
@d4 3
d36 1
d39 1
d41 6
a46 1
       fun ml_debugger (top_frame,can_continue,exception_object) = 
d48 10
d84 1
a84 1
           fun find_source_file_and_name x =
d99 2
a100 1
                NewJersey.String.substring(x,start_of_file_name+1,end_of_file_name - start_of_file_name - 1))
d121 14
a134 3
               val (function_name,source_file) = find_source_file_and_name st
               val file = root_name(! default_path ^ source_file)
               val (p,b,ass) = Get_Type_Information.get_type_information file
d136 5
a140 2
               (p,b,Lists.assoc(st,ass))
                  handle Lists.Assoc => (p,b,Datatypes.NULLTYPE)
d147 1
a147 1
                     (Parser.empty_pB,Basis.empty_basis,Datatypes.NULLTYPE))
d151 1
a151 1
               val (name,_) = find_source_file_and_name debug
d155 1
a155 1
                      ty) = 
d168 5
d183 1
a183 1
                 val (_,Basis.BASIS(_,_,_,Datatypes.ENV(_,ty_env,_,_)),ty) = 
d186 11
d201 1
a201 1
                 ValuePrinter.stringify_value (arg,get_arg_type ty,ty_env,exn_lookup,true) ^ 
d211 12
a222 11
           fun display_stack_backtrace frame =
             let
               val (another,next_frame) = Debugger.get_next_frame frame
               val stat = if another
                            then display_frame_status next_frame
                          else ""
             in
               if another
                 then (output(std_out,stat);
                       (next_frame,stat) :: display_stack_backtrace next_frame)
               else []
a234 1
                output(std_out," step      - single step to next major function \n");
d268 3
a270 1
               | ("",_,_) => Debugger.exit 0
d274 4
a277 2
               | ("continue",_,_) => (Debugger.install_debugger ml_debugger;
                             false)
d282 1
a282 1
                     val rest = display_stack_backtrace first_frame
d284 1
a284 1
                     do_input (rest,[top])
a289 3
               | ("step",_,_) => (Debugger.install_debugger ml_debugger;
                                  true)
                   
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d41 1
a41 1
           val (_,first_frame,exnp) = Debugger.get_next_frame(top_frame)
d162 1
a162 1
               val (another,next_frame,_) = Debugger.get_next_frame frame
d203 1
a203 1
                     val (another,next_frame,exnp) = Debugger.get_next_frame current_frame
@
