head	1.49;
access;
symbols
	ML_beta_release_12/08/94:1.42
	ML_beta_release_03/08/94:1.42
	ML_revised_beta_release_25/05/94:1.42
	ML_final_beta_release_02/03/94:1.41
	mlworks-28-01-1994:1.39
	Release:1.35
	mlworks-beta-01-09-1993:1.35
	MLWorks-1-0-4-29/01/1993:1.20
	MLWorks-1-0-3-21/12/1992:1.20
	MLWorks-1-0-2-15/12/1992:1.20
	MLWorks-1-0-1-04/12/1992:1.20
	checkpoint_17_08_92:1.9;
locks; strict;


1.49
date	95.04.20.15.49.35;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	95.04.12.13.26.52;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	95.03.01.15.30.58;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	95.02.07.12.54.20;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	95.01.30.13.20.53;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	95.01.24.17.43.51;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	94.12.08.17.23.53;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	94.04.08.10.23.52;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	94.02.22.12.02.27;	author nosa;	state Exp;
branches;
next	1.40;

1.40
date	94.02.02.12.15.21;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	94.01.07.17.07.44;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	93.12.15.15.11.00;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	93.12.09.19.27.13;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	93.09.06.15.51.12;	author nosa;	state Exp;
branches;
next	1.35;

1.35
date	93.08.25.14.38.57;	author daveb;	state Exp;
branches
	1.35.1.1;
next	1.34;

1.34
date	93.08.17.18.10.03;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	93.08.03.14.41.06;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	93.07.19.12.58.18;	author nosa;	state Exp;
branches;
next	1.31;

1.31
date	93.05.28.12.58.54;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	93.05.27.17.12.43;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.05.25.17.10.32;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	93.05.18.13.54.34;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	93.05.10.13.49.20;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	93.04.22.12.56.48;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	93.04.06.15.36.34;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	93.03.11.13.44.24;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.03.09.15.12.34;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.02.09.11.04.45;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.02.04.17.43.51;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	92.11.20.16.42.55;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.11.17.13.12.15;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	92.11.03.09.49.45;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	92.10.16.08.59.59;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.10.14.16.27.32;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.10.05.14.55.24;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.09.10.08.50.26;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	92.09.09.10.27.27;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	92.09.04.11.02.33;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	92.08.26.18.43.15;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.08.20.14.10.43;	author davidt;	state Exp;
branches;
next	1.9;

1.9
date	92.08.15.14.28.24;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.08.13.13.42.38;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.08.10.16.49.42;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.07.23.13.10.21;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.07.22.15.37.24;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.07.21.19.01.56;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.07.07.13.11.27;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.07.03.17.24.32;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	92.06.22.15.18.55;	author clive;	state Exp;
branches;
next	;

1.35.1.1
date	93.08.25.14.38.57;	author jont;	state Exp;
branches;
next	;


desc
@First version
@


1.49
log
@filesys and path moved from utils to initbasis.
FileSys.getdir renamed to FileSys.getDir.
@
text
@(* _get_type_information.sml the functor *)
(*
$Log: _get_type_information.sml,v $
Revision 1.48  1995/04/12  13:26:52  jont
Change FILESYS to FILE_SYS

Revision 1.47  1995/03/01  15:30:58  matthew
Changes to Debugger_Types

Revision 1.46  1995/02/07  12:54:20  matthew
Rationalizing

Revision 1.45  1995/01/30  13:20:53  matthew
Revisions to debugger types
.;

Revision 1.44  1995/01/24  17:43:51  daveb
Removed use of FileName structure.

Revision 1.43  1994/12/08  17:23:53  jont
Move OS specific stuff into a system link directory

Revision 1.42  1994/04/08  10:23:52  jont
Add original require file names to consistency info.

Revision 1.41  1994/02/22  12:02:27  nosa
Deleted structure Encapsulate.Debugger_Env_type.

Revision 1.40  1994/02/02  12:15:21  daveb
Changes in handling of file names, module names, etc.  Minor.

Revision 1.39  1994/01/07  17:07:44  matthew
Added range info. to sub requires.

Revision 1.38  1993/12/15  15:11:00  matthew
Renamed Encapsulate.Basistypes to Encapsulate.BasisTypes

Revision 1.37  1993/12/09  19:27:13  jont
Added copyright message

Revision 1.36  1993/09/06  15:51:12  nosa
Record compiler option debug_polyvariables in Debugger_Types.INFO
for recompilation purposes.

Revision 1.35  1993/08/25  14:38:57  daveb
ModuleId.from_string takes a location argument.

Revision 1.34  1993/08/17  18:10:03  daveb
Several changes to reflect use of moduleids and changes to io signature.
I expect that more work is needed here.

Revision 1.33  1993/08/03  14:41:06  jont
Modified to use new type for decode_type_basis

Revision 1.32  1993/07/19  12:58:18  nosa
Debugger Environments for local and closure variable inspection
in the debugger.

Revision 1.31  1993/05/28  12:58:54  jont
Cleaned up after assembly changes

Revision 1.30  1993/05/27  17:12:43  matthew
Change of type of Info.wrap

Revision 1.29  1993/05/25  17:10:32  jont
Changes because Assemblies now has Basistypes instead of Datatypes

Revision 1.28  1993/05/18  13:54:34  jont
Removed integer parameter

Revision 1.27  1993/05/10  13:49:20  daveb
Removed options argument to get_type_information.

Revision 1.26  1993/04/22  12:56:48  jont
Added pop_counters to normal exit for decapsulation

Revision 1.25  1993/04/06  15:36:34  jont
Made getting type info push and pop the relevant counters from simple types, thus not affecting the interpreter

Revision 1.24  1993/03/11  13:44:24  matthew
Options changes
Signature revisions

Revision 1.23  1993/03/09  15:12:34  matthew
Options & Info changes

Revision 1.22  1993/02/09  11:04:45  matthew
Typechecker structure changes

Revision 1.21  1993/02/04  17:43:51  matthew
Added sharing.

Revision 1.20  1992/11/20  16:42:55  jont
Modified sharing constraints to remove superfluous structures

Revision 1.19  1992/11/17  13:12:15  matthew
Changed Error structure to Info

Revision 1.18  1992/11/03  09:49:45  richard
Time is now represented by a pervasive structure.

Revision 1.17  1992/10/16  08:59:59  clive
Anel's changes for encapsulating assemblies

Revision 1.16  1992/10/14  16:27:32  richard
Added location information to the `require' topdec.
Added line number to token stream input functions.

Revision 1.15  1992/10/05  14:55:24  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.14  1992/09/10  08:50:26  richard
Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.

Revision 1.13  1992/09/09  10:27:27  richard
Changed the type of Error.wrap.

Revision 1.12  1992/09/04  11:02:33  richard
Installed central error reporting mechanism.

Revision 1.11  1992/08/26  18:43:15  jont
Removed some redundant structures and sharing

Revision 1.10  1992/08/20  14:10:43  davidt
Made changes to allow copying of mo files.

Revision 1.9  1992/08/15  14:28:24  jont
Modified to use the new encapsulator

Revision 1.8  1992/08/13  13:42:38  clive
Neatening up, plus changes due to lower level sharing changes

Revision 1.7  1992/08/10  16:49:42  clive
New sharing constraints after lower level changes

Revision 1.6  1992/07/23  13:10:21  clive
Encapsulator datastructures have changed
,

Revision 1.5  1992/07/22  15:37:24  jont
Moved all file manipulation into Io

Revision 1.4  1992/07/21  19:01:56  jont
Updated to fit new encapsulation interface

Revision 1.3  1992/07/07  13:11:27  clive
Changes when implementing call point annotation

Revision 1.2  1992/07/03  17:24:32  jont
Added code generation information to that returned

Revision 1.1  1992/06/22  15:18:55  clive
Initial revision

 * Copyright (c) 1993 Harlequin Ltd.
*)

require "../utils/crash";
require "../utils/lists";
require "../utils/diagnostic";
require "../utils/timer";
require "../initbasis/filesys";
require "../basics/module";
require "../basics/module_id";
require "../parser/parser";
require "../typechecker/basis";
require "../lambda/environ";
require "../typechecker/simpletypes";
require "../main/encapsulate";
require "../main/io";
require "get_type_information";

functor GetTypeInformation (
  structure Crash : CRASH
  structure Lists : LISTS
  structure FileSys : FILE_SYS
  structure Diagnostic : DIAGNOSTIC
  structure Timer : TIMER
  structure ModuleId : MODULE_ID
  structure Parser : PARSER
  structure Basis : BASIS
  structure Environ : ENVIRON
  structure Encapsulate : ENCAPSULATE
  structure TopLevel : sig val error_output_level : Parser.Lexer.Info.severity ref end
  structure Io : IO
  structure Module : MODULE

  sharing Encapsulate.BasisTypes = Basis.BasisTypes
  sharing Parser.Absyn.Set = Basis.BasisTypes.Set 
  sharing Encapsulate.EnvironTypes = Environ.EnvironTypes
  sharing Parser.Absyn.Ident = Basis.BasisTypes.Datatypes.Ident
  sharing type Encapsulate.ParserEnv.pB = Parser.ParserBasis
  sharing type Parser.Absyn.Type = Basis.BasisTypes.Datatypes.Type
  sharing type ModuleId.ModuleId = Parser.Absyn.ModuleId = Module.ModuleId
  sharing type ModuleId.Location = Parser.Lexer.Info.Location.T
) : GETTYPEINFORMATION =
  
struct
  structure Parser = Parser
  structure Lexer = Parser.Lexer
  structure Absyn = Parser.Absyn
  structure EnvironTypes = Environ.EnvironTypes
  structure Diagnostic = Diagnostic
  structure BasisTypes = Basis.BasisTypes
  structure Datatypes = BasisTypes.Datatypes
  structure Tyname_id = Datatypes.Tyname_id
  structure Tyfun_id = Datatypes.Tyfun_id
  structure Strname_id = Datatypes.Strname_id
  structure Debugger_Types = Encapsulate.Debugger_Types
  structure Info = Lexer.Info
  structure Location = Info.Location

  type ParserBasis = Parser.ParserBasis
  type TypeBasis = BasisTypes.Basis
  type Options = Parser.Lexer.Options

  val do_lambda_opt = ref true
  val print_timings = ref false
  val print_minor_timings = ref false

  datatype compiler_basis =
    CB of (Parser.ParserBasis * BasisTypes.Basis * EnvironTypes.Top_Env)

  val empty_cb =
    CB (Parser.empty_pB, Basis.empty_basis, Environ.empty_top_env)

(* this codegen basis will not cope with code including exceptions *)
      
  fun diagnose_simple str = Diagnostic.output 1 (fn i => [str])

  fun augment_cb(CB(p, t, c), CB(p', t', c')) =
    Timer.xtime
    ("augment_cb", !print_timings,
     fn () => CB(Parser.augment_pB(p, p'),
		 Basis.basis_circle_plus_basis(t, t'),
		 Environ.augment_top_env(c, c')))


  fun assoc_name(_, []) = false
    | assoc_name(name, (name', _, _, _) :: rest) =
      name = name' orelse assoc_name(name, rest)

  (* This seems to be bogus now.  Needs to be updated/unified with the stuff in _toplevel *)
  fun compile_program error_info (options,path, ts, initial) =
    let
      val pervasive_library_dir = Io.get_pervasive_dir ()
      val filename = Lexer.associated_filename ts

      val error_wrap = Info.wrap error_info (Info.FATAL, Info.RECOVERABLE, !TopLevel.error_output_level,Location.FILE filename)

      fun relative_mo (path, name) =
	Module.mo_name
	  (Module.MODULE
	     (path, ModuleId.from_string (name, Location.UNKNOWN)))

      fun do_subrequires (require_list, _, nil) = require_list
	| do_subrequires (require_list, path, {mod_name=name,...} :: cons) =
	let
	  val comp_name = (* Io.compilation_name *) name
	in
	  if Lists.exists (fn (n, _, _, _) => n = comp_name) require_list then
	    do_subrequires (require_list, path, cons)
	  else
	    let
              val mo = relative_mo (path, name)

	      val {tynames, strnames, tyfuns, consistency} =
		Encapsulate.input_info mo
		handle exn as Encapsulate.BadInput s =>
                  Info.error' error_info (Info.FATAL, Info.Location.FILE filename, s)

	      val require_list =
		do_subrequires (require_list,
				path, (* Io.compilation_path mo,*)
				case consistency of [] => [] | _ :: tl => tl)

	      val tyname_count = Tyname_id.read_counter ()
	      val strname_count = Strname_id.read_counter ()
	      val tyfun_count = Tyfun_id.read_counter ()

	      val _ = Tyname_id.reset_counter (tyname_count + tynames)
	      val _ = Strname_id.reset_counter (strname_count + strnames)
	      val _ = Tyfun_id.reset_counter (tyfun_count + tyfuns)
	    in
	      do_subrequires((comp_name, (tyname_count,tynames), (strname_count,strnames),
			      (tyfun_count,tyfuns)) ::
			     require_list, path, cons)
	    end
	end

      (* compile_topdec takes a path plus the env so far and delivers *)
      (* requires, the code, the updated initial env and *)
      (* the result of this compilation *)
      fun compile_topdec(path, require_list, CB(p, t, c),parse,
			 counters as (tynames, strnames, tyfuns),debug_information) =
	let
	  val (topdec,p') = 
            Timer.xtime("Parsing", ! print_timings, (fn () => error_wrap parse p))
	  val _ = diagnose_simple"Parsing complete"
	in
	  case topdec of
	    Absyn.REQUIREtopdec (s, location) =>
	      let
		(* This is probably wrong *)
                val mo = relative_mo (path, ModuleId.string s)
		val root = (ModuleId.string s)

		val {parser_env, type_env, lambda_env,
		     tynames, strnames, tyfuns, consistency} =
		  Encapsulate.input_all mo
		  handle exn as Encapsulate.BadInput s =>
                    Info.error' error_info (Info.FATAL, location, s)

		val (my_stamp as (name, stamp), cons) = case consistency of
		  [] => Crash.impossible ("Missing consistency info in " ^ mo)
		| {time=stamp, ...} :: tl => ((root, stamp), tl)

		val require_list =
		  do_subrequires (require_list, path, (* Io.compilation_path mo,*)
				  cons)

		(* environment handling *)

		val p = parser_env
		val c = lambda_env
		(* note that counters have already been bumped up by *)
		(* do_subrequires *)

		val tyname_count = Tyname_id.read_counter ()
		val strname_count = Strname_id.read_counter ()
		val tyfun_count = Tyfun_id.read_counter ()

		val name = (* Io.compilation_name *) root
		val require_list =
		  if assoc_name(name, require_list) then
		    require_list
		  else
		    (name, (tyname_count,tynames), (strname_count,strnames), (tyfun_count,tyfuns)) :: require_list

		val (t, debug_information) =
		  Timer.xtime("decoding encapsulated type basis of size " ^
			      MLWorks.Integer.makestring(size type_env),
			      !print_timings andalso !print_minor_timings,
			      fn () => Encapsulate.decode_type_basis
			      (type_env, name, require_list, false))

		val _ = Tyname_id.reset_counter (tyname_count + tynames)
		val _ = Strname_id.reset_counter (strname_count + strnames)
		val _ = Tyfun_id.reset_counter (tyfun_count + tyfuns)
	      in
		(* Later this should contain real timestamps *)
		(require_list, [my_stamp], CB(p, t, c), empty_cb,
		 counters, debug_information)
	      end
	  | _ =>
	      Crash.impossible"Non-require topdec"
	end	

    (* compile_topdecs takes unit and compiles all the
     topdecs remaining in the input stream, returning a
     (reverse-ordered) list of the declarations and a compiler basis
     which does not include the initial compiler basis *)

      fun compile_topdecs'(path, require_list, reqs, initial_cb,
                           parse,eof, counters,debug_information) = 
        let
          val (require_list, requires, req_cb, _,
               counters,debug_information) =
            compile_topdec(path, require_list,
                           initial_cb, parse,
                           counters,debug_information)
          val reqs' = reqs @@ requires
          val new_cb = augment_cb(initial_cb, req_cb)
        in
          if eof() then
            (require_list, reqs', counters, new_cb,
             debug_information)
          else
            compile_topdecs'(path, require_list, reqs', new_cb,
                             parse, eof, counters,debug_information)
        end

      fun eof () = Lexer.eof ts
      fun parse error_info pb = Parser.parse_topdec error_info (options,ts,pb)
      val initial_counters = (0, 0, 0)

      val (require_list, reqs_list,
	   counters,req_cb,debug_information) =
        if eof() then 
             ([], [], initial_counters, empty_cb, Debugger_Types.empty_information)
	else
	    compile_topdecs'(path, [], [], initial, parse, eof,
			     initial_counters, 
                             Debugger_Types.empty_information)
             
    in
      (require_list, reqs_list,
       counters,req_cb,debug_information)
    end
    
  (* This is a hack, and doesn't belong here *)
  fun root_name filename =
    let
      val len = size filename
    in
      if len >= 4 then
        (case String.substring(filename, len-4, 4) of
           ".sml" => String.substring(filename, 0, len-4)
         | _ => filename)
      else
        filename
    end

  fun get_type_information options (filename) =
    let
      val st = ref("require \"" ^ root_name filename ^ "\";")

      val ts = Lexer.mkTokenStream (fn _ => let val a = !st in st := ""; a end, filename)
	
      val _ = Datatypes.push_counters()
    in
      let
	val _ = Tyname_id.reset_counter Basis.pervasive_tyname_count
	val _ = Tyfun_id.reset_counter Basis.pervasive_tyfun_count
	val _ = Strname_id.reset_counter Basis.pervasive_strname_count

	val _ = Diagnostic.output 3 (fn _ => ["Cleaning refs in initial basis"])
	val _ = Encapsulate.clean_basis Basis.initial_basis
	(* Set all refs for encoding back to zero *)
	val _ = Diagnostic.output 3 (fn _ => ["Cleaned refs in initial basis"])

	val _ = Diagnostic.output 3 (fn _ => ["Tyname_id reset to " ^ MLWorks.Integer.makestring(Tyname_id.read_counter()) ^ "\n"])
	val _ = Diagnostic.output 3 (fn _ => ["Strname_id reset to " ^ MLWorks.Integer.makestring(Strname_id.read_counter()) ^ "\n"])

	val (require_list, requires,
	     (tyname_count, strname_count, tyfun_count),
	     cb' as CB(parser_env, type_basis, code_env),debug_information) =
	  compile_program
	    Info.default_options
	    (options, FileSys.getDir (), ts, empty_cb)
      in
	Datatypes.pop_counters();
	(parser_env, type_basis, debug_information, code_env)
      end
        handle exn =>
	  (Datatypes.pop_counters();
	   raise exn)
    end

end
@


1.48
log
@Change FILESYS to FILE_SYS
@
text
@d4 3
d163 1
a163 1
require "../utils/filesys";
d441 1
a441 1
	    (options, FileSys.getdir (), ts, empty_cb)
@


1.47
log
@Changes to Debugger_Types
@
text
@d4 3
d174 1
a174 1
  structure FileSys : FILESYS
@


1.46
log
@Rationalizing
@
text
@d4 3
a153 1
require "../utils/print";
a169 1
  structure Print : PRINT
a182 1
  sharing Parser.Options = Encapsulate.Debugger_Types.Options
a205 1
  structure Options = Debugger_Types.Options
d210 1
@


1.45
log
@Revisions to debugger types
.;
@
text
@d4 4
a158 2
require "../typechecker/types";
require "../typechecker/strenv";
a174 5
  structure Tyname_id : TYNAME_ID
  structure Tyfun_id : TYFUN_ID
  structure Strname_id : STRNAME_ID
  structure Types : TYPES
  structure Strenv : STRENV
a197 1
  structure LambdaTypes = EnvironTypes.LambdaTypes
a198 1
  structure Set = LambdaTypes.Set
d201 3
a204 3
  structure Map = Datatypes.NewMap
  structure Ident = Datatypes.Ident
  structure Symbol = Ident.Symbol
d418 3
a420 3
	val _ = Tyname_id.reset_counter Types.pervasive_tyname_count
	val _ = Tyfun_id.reset_counter Types.pervasive_tyfun_count
	val _ = Strname_id.reset_counter Strenv.pervasive_strname_count
@


1.44
log
@Removed use of FileName structure.
@
text
@d4 3
d243 1
d390 1
a390 1
             ([], [], initial_counters, empty_cb, Map.empty(fn _ => false,fn _ => true))
d394 1
a394 1
                             Map.empty(fn _ => false,fn _ => true))
d443 1
a443 1
	(parser_env, type_basis, Debugger_Types.INFO debug_information, code_env)
@


1.43
log
@Move OS specific stuff into a system link directory
@
text
@d4 3
d148 1
a148 1
require "../utils/filename";
d165 1
a180 1
  structure FileName : FILENAME
a189 1
  sharing type Io.Directory = Module.Directory = FileName.Directory
d436 1
a436 1
	    (options, FileName.parse_directory "", (*Io.compilation_path filename,*) ts, empty_cb)
@


1.42
log
@Add original require file names to consistency info.
@
text
@d4 3
a139 1
require "../make/unix";
a158 1
  structure Unix : UNIX
@


1.41
log
@Deleted structure Encapsulate.Debugger_Env_type.
@
text
@d4 3
d250 1
a250 1
	| do_subrequires (require_list, path, (name,_) :: cons) =
d309 1
a309 1
		| (_, stamp) :: tl => ((root, stamp), tl)
@


1.40
log
@Changes in handling of file names, module names, etc.  Minor.
@
text
@d4 3
a181 2
  sharing type Encapsulate.Debugger_Types.Debugger_Env.debugger_env = 
    Encapsulate.Debugger_Env_type.debugger_env
d335 1
a335 1
			      (type_env, name, require_list))
d433 1
a433 1
	(parser_env, type_basis, Debugger_Types.INFO (debug_information,false), code_env)
@


1.39
log
@Added range info. to sub requires.
@
text
@d4 3
d138 1
d169 1
d177 1
a177 4
(*
  sharing TopLevel.Info = Parser.Lexer.Info
*)
  sharing type (*TopLevel.ParserBasis = *) Encapsulate.ParserEnv.pB = Parser.ParserBasis
d181 2
a182 2
  sharing type ModuleId.ModuleId = Parser.Absyn.ModuleId = FileName.ModuleId
  sharing type Io.Directory = FileName.Directory
d241 2
a242 2
	FileName.mo_name
	  (FileName.MODULE
d429 1
a429 1
	    (options, Io.null_location, (*Io.compilation_path filename,*) ts, empty_cb)
@


1.38
log
@Renamed Encapsulate.Basistypes to Encapsulate.BasisTypes
@
text
@d4 3
d272 2
a273 2
	      do_subrequires((comp_name, tyname_count, strname_count,
			      tyfun_count) ::
a319 7
(*
		val require_list = 
		  (Io.compilation_name root, tyname_count, strname_count,
		   tyfun_count) ::
		  require_list
*)

d325 1
a325 1
		    (name, tyname_count, strname_count, tyfun_count) :: require_list
@


1.37
log
@Added copyright message
@
text
@d4 3
d165 1
a165 1
  sharing Encapsulate.Basistypes = Basis.BasisTypes
@


1.36
log
@Record compiler option debug_polyvariables in Debugger_Types.INFO
for recompilation purposes.
@
text
@d4 4
d119 1
@


1.35
log
@ModuleId.from_string takes a location argument.
@
text
@d4 3
d426 1
a426 1
	(parser_env, type_basis, Debugger_Types.INFO debug_information, code_env)
@


1.35.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.35  1993/08/25  14:38:57  daveb
ModuleId.from_string takes a location argument.

@


1.34
log
@Several changes to reflect use of moduleids and changes to io signature.
I expect that more work is needed here.
@
text
@d4 4
d167 1
d225 3
a227 1
	FileName.mo_name (FileName.MODULE (path, ModuleId.from_string name))
@


1.33
log
@Modified to use new type for decode_type_basis
@
text
@d4 3
d116 2
d135 1
d147 1
d161 2
a188 1
  val pervasive_library_dir = Io.pervasive_library_dir
d214 1
d220 1
a220 8
	let
	  val root = Io.root_name (Io.compilation_name name)
	in
	  if Lists.member (root, Io.pervasive_names) then
	    Io.mo_name(Io.relative_name(!pervasive_library_dir, root))
	  else
	    Io.relative_name(path, Io.mo_name name)
	end
d225 1
a225 1
	  val comp_name = Io.compilation_name name
d240 1
a240 1
				Io.compilation_path mo,
d270 3
a272 2
                val mo = relative_mo (path, s)
		val root = Io.root_name s
d285 1
a285 1
		  do_subrequires (require_list, Io.compilation_path mo,
d306 1
a306 1
		val name = Io.compilation_name root
d374 13
d389 1
a389 1
      val st = ref("require \"" ^ Io.root_name filename ^ "\";")
d411 3
a413 1
	  compile_program Info.default_options (options, Io.compilation_path filename, ts, empty_cb)
@


1.32
log
@Debugger Environments for local and closure variable inspection
in the debugger.
@
text
@d4 4
d200 4
d296 1
d301 1
d303 7
d315 1
a315 1
			      (type_env, require_list))
@


1.31
log
@Cleaned up after assembly changes
@
text
@d4 3
d148 2
@


1.30
log
@Change of type of Info.wrap
@
text
@d4 3
d136 1
a136 1
  sharing Encapsulate.Assemblies.Basistypes = Basis.BasisTypes
d288 1
a288 1
		val (t,_,_,debug_information) =
@


1.29
log
@Changes because Assemblies now has Basistypes instead of Datatypes
@
text
@d4 3
d160 1
d192 1
a192 1
      val error_wrap = Info.wrap error_info (Info.FATAL, Info.RECOVERABLE, !TopLevel.error_output_level)
@


1.28
log
@Removed integer parameter
@
text
@d4 3
d130 2
a131 2
  sharing Encapsulate.BasisTypes = Basis.BasisTypes
  sharing Parser.Absyn.Set = Encapsulate.BasisTypes.Set 
d133 1
a133 1
  sharing Parser.Absyn.Ident = Encapsulate.BasisTypes.Datatypes.Ident
d138 1
a138 1
  sharing type Parser.Absyn.Type = Encapsulate.BasisTypes.Datatypes.Type
@


1.27
log
@Removed options argument to get_type_information.
@
text
@d4 3
a93 1
require "../utils/integer";
a104 1
require "../main/toplevel";
a110 1
  structure Integer : INTEGER
d123 1
a123 1
  structure TopLevel : TOPLEVEL
d131 1
d133 2
a134 2

  sharing type TopLevel.ParserBasis = Encapsulate.ParserEnv.pB = Parser.ParserBasis
d280 1
a280 1
			      Integer.makestring(size type_env),
d357 2
a358 2
	val _ = Diagnostic.output 3 (fn _ => ["Tyname_id reset to " ^ Integer.makestring(Tyname_id.read_counter()) ^ "\n"])
	val _ = Diagnostic.output 3 (fn _ => ["Strname_id reset to " ^ Integer.makestring(Strname_id.read_counter()) ^ "\n"])
@


1.26
log
@Added pop_counters to normal exit for decapsulation
@
text
@d4 3
d338 1
a338 1
  fun get_type_information error_info options (filename) =
d362 1
a362 1
	  compile_program error_info (options, Io.compilation_path filename, ts, empty_cb)
@


1.25
log
@Made getting type info push and pop the relevant counters from simple types, thus not affecting the interpreter
@
text
@d4 3
d361 1
@


1.24
log
@Options changes
Signature revisions
@
text
@d4 4
d338 6
a343 8
      val _ = Tyname_id.reset_counter Types.pervasive_tyname_count
      val _ = Tyfun_id.reset_counter Types.pervasive_tyfun_count
      val _ = Strname_id.reset_counter Strenv.pervasive_strname_count
  
      val _ = Diagnostic.output 3 (fn _ => ["Cleaning refs in initial basis"])
      val _ = Encapsulate.clean_basis Basis.initial_basis
      (* Set all refs for encoding back to zero *)
      val _ = Diagnostic.output 3 (fn _ => ["Cleaned refs in initial basis"])
d345 4
a348 2
      val _ = Diagnostic.output 3 (fn _ => ["Tyname_id reset to " ^ Integer.makestring(Tyname_id.read_counter()) ^ "\n"])
      val _ = Diagnostic.output 3 (fn _ => ["Strname_id reset to " ^ Integer.makestring(Strname_id.read_counter()) ^ "\n"])
d350 13
a362 6
      val (require_list, requires,
	   (tyname_count, strname_count, tyfun_count),
	   cb' as CB(parser_env, type_basis, code_env),debug_information) =
	compile_program error_info (options, Io.compilation_path filename, ts, empty_cb)
    in
      (parser_env, type_basis, Debugger_Types.INFO debug_information, code_env)
@


1.23
log
@Options & Info changes
@
text
@d4 3
d85 1
d104 1
d116 1
a116 1
  sharing TopLevel.Parser.Options = Encapsulate.Debugger_Types.Options
d118 1
a118 1
  sharing TopLevel.Parser.Absyn.Set = Encapsulate.BasisTypes.Set 
d120 2
a121 1
  sharing TopLevel.Parser.Absyn.Ident = Encapsulate.BasisTypes.Datatypes.Ident
d123 2
a124 2
  sharing type TopLevel.Parser.ParserBasis = Encapsulate.ParserEnv.pB
  sharing type TopLevel.Parser.Absyn.Type = Encapsulate.BasisTypes.Datatypes.Type
d128 1
a128 1
  structure Parser = TopLevel.Parser
d170 1
a170 1
  fun compile_program error_info (print_options,path, ts, initial) =
d311 1
a311 1
      fun parse error_info pb = Parser.parse_topdec error_info (print_options,ts,pb)
d328 1
a328 1
  fun get_type_information error_info print_options (filename) =
d349 1
a349 1
	compile_program error_info (print_options, Io.compilation_path filename, ts, empty_cb)
@


1.22
log
@Typechecker structure changes
@
text
@d4 3
d111 1
a112 2
  sharing TopLevel.Parser.Absyn.Datatypes = Encapsulate.BasisTypes.Datatypes 
    = Encapsulate.Debugger_Types.Datatypes
d115 2
d118 1
a118 1
  sharing Encapsulate.Debugger_Types.Info = TopLevel.Parser.Lexer.Info
d135 5
a139 1
  structure Info = Lexer.Info 
d164 1
a164 1
  fun compile_program options (path, ts, initial) =
d168 1
a168 1
      val error_wrap = Info.wrap options (Info.FATAL, Info.RECOVERABLE, !TopLevel.error_output_level)
d194 1
a194 1
                  Info.error' options (Info.FATAL, Info.Location.FILE filename, s)
d235 1
a235 1
                    Info.error' options (Info.FATAL, location, s)
d305 1
a305 1
      fun parse options pb = Parser.parse_topdec options (ts,pb)
d322 1
a322 1
  fun get_type_information options (filename) =
d343 1
a343 1
	compile_program options (Io.compilation_path filename, ts, empty_cb)
@


1.21
log
@Added sharing.
@
text
@d4 3
d81 1
d102 1
d108 2
a109 1
  sharing TopLevel.Parser.Absyn.Datatypes = Encapsulate.Basis.Tyvarenv.Datatypes 
d111 1
a111 1
  sharing TopLevel.Parser.Absyn.Set = Encapsulate.Basis.Set 
d114 1
a114 3
  sharing Encapsulate.Debugger_Types.Info = TopLevel.Parser.Lexer.Info =
    (* This should be in Encapsulate *)
    Encapsulate.Basis.Sigenv.Sigma.Nameset.Info
a118 1
  structure Basis = Encapsulate.Basis
d125 2
a127 1
  structure Datatypes = Debugger_Types.Datatypes
d139 1
a139 1
    CB of (Parser.ParserBasis * Basis.Basis * EnvironTypes.Top_Env)
@


1.20
log
@Modified sharing constraints to remove superfluous structures
@
text
@d4 3
d108 3
@


1.19
log
@Changed Error structure to Info
@
text
@d4 3
d121 1
a121 1
  structure Info = Parser.Info 
@


1.18
log
@Time is now represented by a pervasive structure.
@
text
@d4 3
d118 1
a118 1
  structure Error = TopLevel.Parser.Error
a130 2
  val error_wrap = fn f => Error.wrap (Error.FATAL, Error.RECOVERABLE, !TopLevel.error_output_level) f

d143 1
a143 1
  fun compile_program (path, ts, initial) =
d147 2
d173 1
a173 2
                  Error.report'
                  (Error.ERROR (Error.FATAL, Error.Location.FILE filename, s))
d214 1
a214 1
                    Error.report' (Error.ERROR (Error.FATAL, location, s))
d284 1
a284 1
      fun parse pb = Parser.parse_topdec (ts,pb)
d301 1
a301 1
  fun get_type_information(filename) =
d322 1
a322 1
	compile_program (Io.compilation_path filename, ts, empty_cb)
@


1.17
log
@Anel's changes for encapsulating assemblies
@
text
@d4 3
d115 1
a115 1
  structure Error = TopLevel.Error
d215 2
a216 7
		  [] =>
		    let
		      val _ = Print.print"Strange, no consistency info"
		    in
		      ((root, {hi=0, lo=0}), [])
		    end
		| (_, (hi, lo)) :: tl => ((root, {hi=hi, lo=lo}), tl)
@


1.16
log
@Added location information to the `require' topdec.
Added line number to token stream input functions.
@
text
@d4 4
d240 1
a240 1
		val (t,debug_information) =
@


1.15
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
a59 1
require "../parser/parser";
a76 1
  structure Parser : PARSER
d87 1
a87 1
  sharing Parser.Absyn.Datatypes = Encapsulate.Basis.Tyvarenv.Datatypes 
d89 1
a89 5
(*
  sharing Absyn.IdentClass = LambdaTypes.Ident
  sharing EnvironTypes.NewMap = Map 
*)
  sharing Parser.Absyn.Set = Encapsulate.Basis.Set 
d91 1
a91 1
  sharing type Parser.ParserBasis = Encapsulate.ParserEnv.pB
d95 1
a95 1
  structure Parser = Parser
d196 1
a196 1
	    Absyn.REQUIREtopdec s =>
d205 1
a205 2
                    Error.report'
                    (Error.ERROR (Error.FATAL, Error.Location.FILE filename, s))
a299 6
      fun input_fn () =
        let
          val a = ! st
        in
          st := ""; a
        end
d301 1
a301 1
      val ts = Lexer.mkTokenStream (input_fn,filename)
@


1.14
log
@Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.
@
text
@d4 4
d290 1
a290 1
             ([], [], initial_counters, empty_cb, Map.empty(fn _ => Map.EQUAL))
d294 1
a294 1
                             Map.empty(fn _ => Map.EQUAL))
@


1.13
log
@Changed the type of Error.wrap.
@
text
@d4 3
d326 1
a326 1
      (parser_env,type_basis,debug_information, code_env)
@


1.12
log
@Installed central error reporting mechanism.
@
text
@d4 3
d117 1
a117 1
  val error_wrap = fn f => Error.wrap (Error.RECOVERABLE, !TopLevel.error_output_level) f
@


1.11
log
@Removed some redundant structures and sharing
@
text
@d4 3
d54 1
d73 1
d101 1
d114 1
d128 1
a128 1
  fun compile_program (path, ts, initial, do_pervasive_library) = 
d130 12
a141 1
	  
a145 8

	  fun encountered nil = false
	    | encountered ((name,_,_,_)::rest) =
	      if name = comp_name
		then
		  true
	      else
		encountered rest
d147 1
a147 2
	  if encountered require_list then
	    (* Ignore if already encountered this one *)
d151 1
a151 2
	      val mo_name = Io.mo_name name
	      val full_name = Io.relative_name (path, mo_name)
d154 4
a157 2
		Encapsulate.input_info full_name
		handle exn as Encapsulate.BadInput s => (Print.print("*** " ^ s ^ "\n"); raise exn)
d161 1
a161 1
				Io.compilation_path full_name,
d185 1
a185 4
            Timer.xtime("Parsing", ! print_timings,
                        (fn () => parse p))
            handle exn as Parser.ParseError x =>
              (Print.print("Parse Error: " ^ x ^ "\n"); raise exn)
d191 1
a191 2
		val mo_name = Io.mo_name s
		val full_name = Io.relative_name (path, mo_name)
d196 4
a199 3
		  Encapsulate.input_all full_name
		  handle exn as Encapsulate.BadInput s => (Print.print("*** " ^ s ^ "\n"); raise exn)
		(* consistency check *)
d211 1
a211 1
		  do_subrequires (require_list, Io.compilation_path full_name,
d236 1
d248 24
a271 23
      (* compile_topdecs takes unit and compiles all the
       topdecs remaining in the input stream, returning a
       (reverse-ordered) list of the declarations and a compiler basis
       which does not include the initial compiler basis *)
       
	fun compile_topdecs'(path, require_list, reqs, initial_cb,
			     parse,eof, counters,debug_information) = 
	  let
	    val (require_list, requires, req_cb, _,
		 counters,debug_information) =
	      compile_topdec(path, require_list,
			     initial_cb, parse,
			     counters,debug_information)
	    val reqs' = reqs @@ requires
	    val new_cb = augment_cb(initial_cb, req_cb)
	  in
	    if eof() then
	      (require_list, reqs', counters, new_cb,
	       debug_information)
	    else
	      compile_topdecs'(path, require_list, reqs', new_cb,
			       parse, eof, counters,debug_information)
	  end
a290 3
  fun compare_filenames(x,y) = 
    (Io.compilation_name x = Io.compilation_name y)

a299 1
      val do_pervasive_library = ref(true)
d318 1
a318 2
	compile_program (Io.compilation_path filename, ts, empty_cb,
			 !do_pervasive_library)
@


1.10
log
@Made changes to allow copying of mo files.
@
text
@d4 3
a37 1
require "../utils/newmap";
a43 4
require "../basics/absyn";
require "../basics/ident";
require "../basics/symbol";
require "../lexer/lexer";
a44 1
require "../typechecker/basis";
a46 1
require "../lambda/environtypes";
a48 1
require "../lambda/lambdatypes";
a54 1
  structure Map : NEWMAP
a60 4
  structure Absyn : ABSYN
  structure Ident : IDENT
  structure Symbol : SYMBOL
  structure Lexer : LEXER
a61 1
  structure Basis : BASIS
a66 2
  structure LambdaTypes : LAMBDATYPES
  structure EnvironTypes : ENVIRONTYPES
d71 1
a71 1
  sharing Absyn.Datatypes  = LambdaTypes.Datatypes = Basis.Tyvarenv.Datatypes 
d73 2
a74 1
  sharing Absyn.IdentClass = LambdaTypes.Ident = Ident 
d76 3
a78 7
  sharing Absyn.Set = Basis.Set 
  sharing Lexer = Parser.Lexer
  sharing Absyn = Parser.Absyn 
  sharing Basis = Encapsulate.Basis 
  sharing EnvironTypes.LambdaTypes = LambdaTypes 
  sharing EnvironTypes = Encapsulate.EnvironTypes = Environ.EnvironTypes
  sharing Symbol = Ident.Symbol
d84 5
a88 4
  structure Basis = Basis
  structure Lexer = Lexer
  structure EnvironTypes = EnvironTypes
  structure LambdaTypes = LambdaTypes
d93 3
d271 1
a271 1
             ([], [], initial_counters, empty_cb, Debugger_Types.Map.empty(fn _ => Debugger_Types.Map.EQUAL))
d275 1
a275 1
                             Debugger_Types.Map.empty(fn _ => Debugger_Types.Map.EQUAL))
@


1.9
log
@Modified to use the new encapsulator
@
text
@d4 3
d112 1
a112 1
  val pervasive_library_path = Io.pervasive_library_path
d159 1
d203 1
@


1.8
log
@Neatening up, plus changes due to lower level sharing changes
@
text
@d4 3
d154 2
a155 7
	      val (env, cons') =
		case Encapsulate.input_file full_name of
		  Encapsulate.TOTAL_INPUT{env=[env], consistency=cons', ...} => (env, cons')
		| _ => Crash.impossible"bad result from Encapsulate.input_file"
	      val cons' = Encapsulate.decode_cons cons'
	      val {tynames=tynames, strnames=strnames, tyfuns=tyfuns} = 
		Encapsulate.decode_counts env
d160 1
a160 1
				case cons' of [] => [] | _ :: tl => tl)
d171 1
a171 1
			      tyfun_count) :: 
d196 3
a198 4
		val (env, cons) =
		  case Encapsulate.input_file full_name of
		    Encapsulate.TOTAL_INPUT{env=[env], consistency=cons', ...} => (env, cons')
		  | _ => Crash.impossible"bad result from Encapsulate.input_file"
d201 1
a201 2
		val cons = Encapsulate.decode_cons cons
		val (my_stamp as (name, stamp), cons) = case cons of
d216 2
a217 13
		val {parser_env=p_env, ty_env=t_env, lambda_env=l_env,
		     tynames = tynames, strnames = strnames, tyfuns=tyfuns,...} =
		  Timer.xtime("decoding encapsulation of " ^ root,
			      !print_timings andalso !print_minor_timings,
                              fn () => Encapsulate.decode_env env)

		val p =
		  Timer.xtime("decoding encapsulated parser env of size " ^
			      Integer.makestring(size (#1 p_env)),
			      !print_timings andalso !print_minor_timings,
			      fn () => Encapsulate.decode_parser_env p_env)

		val c = Encapsulate.decode_lambda_env l_env
d232 1
a232 1
			      Integer.makestring(size (#1 t_env)),
d235 1
a235 1
			      (t_env, require_list))
@


1.7
log
@New sharing constraints after lower level changes
@
text
@d4 3
a31 1
require "../utils/string";
a56 1
  structure String : STRING
d78 2
a79 1
  sharing Basis.Datatypes = Absyn.Datatypes  = LambdaTypes.Datatypes
a82 1
  sharing Absyn.Nameset = Basis.Nameset
a98 1
  structure Datatypes = Basis.Datatypes
d101 1
@


1.6
log
@Encapsulator datastructures have changed
,
@
text
@d4 4
d87 1
a87 1
  sharing Lexer.Symbol = Symbol = Ident.Symbol
@


1.5
log
@Moved all file manipulation into Io
@
text
@d4 3
d148 1
a148 1
		  Encapsulate.TOTAL_OUTPUT{env=[env], consistency=cons', ...} => (env, cons')
d195 1
a195 1
		    Encapsulate.TOTAL_OUTPUT{env=[env], consistency=cons', ...} => (env, cons')
@


1.4
log
@Updated to fit new encapsulation interface
@
text
@d4 3
d40 1
d68 1
d98 1
a98 1
  val do_check_bindings = ref false
a99 4
  val builtin_library = "__builtin_library.sml"
  val pervasive_library = "__pervasive_library.sml" 
  val pervasive_library_path = ref"/usr/users/clive/ml/src/rts/__pervasive_library"

a105 3
(*
  val initial_cb =
    CB (Parser.initial_pB, Basis.initial_basis)
a106 13
  val initial_cb_for_builtin_library =
    CB (Parser.initial_pB_for_builtin_library, 
        Basis.initial_basis_for_builtin_library)

  val initial_cgb_for_normal_file =
    CB (Parser.initial_pB, 
        Basis.initial_basis)

  val empty_env =
    CB(Parser.empty_pB,
       Basis.empty_basis)
*)

a117 5
(*
  fun augment_cb (CB (p, t), CB (p', t')) = 
    CB (Parser.augment_pB (p,p'),
	Basis.basis_circle_plus_basis (t,t'))
*)
a118 63
  fun root_name filename =
    let
      val len = size filename
      val final_name =
	if len >= 4 then
	  String.substring(filename, len-4, 4)
	else ""
    in
      case final_name of
	".sml" => String.substring(filename, 0, len-4)
      | _ => filename
    end

  fun compilation_name filename =
    let
      val root = root_name filename
      val exp_root = explode root
      fun remove_slash(result, []) = result
      | remove_slash(result, "/" :: rest) = remove_slash(rest, rest)
      | remove_slash(result, x :: rest) = remove_slash(result, rest)
    in
      implode(remove_slash(exp_root, exp_root))
    end

  fun compilation_path filename =
    let
      val root = root_name filename
      val final = compilation_name filename
    in
      String.substring(root, 0, size root - size final)
    end

  fun sml_name filename = root_name filename ^ ".sml"

  fun mo_name filename =
    if size filename = 0 then
      "test.mo"
    else
      root_name filename ^ ".mo"

  fun relative_name(path, name) =
    case String.substring(name, 0, 1) of
      "/" => name
    (* Handle case of require via absolute pathname *)
    | _ => 
	let
	  fun join path name =
	    if size name < 3 orelse path = "" then path ^ name
	    else
	      case String.substring(name, 0, 3) of
		"../" =>
		  let
		    val prepath =
		      compilation_path(String.substring(path, 0,
							size path - 1))
		  in
		    join prepath (String.substring(name, 3, size name - 3))
		  end
	      | _ => path ^ name
	in
	  join path name
	end

d125 1
a125 1
	  val comp_name = compilation_name name
d140 2
a141 2
	      val mo_name = mo_name name
	      val full_name = relative_name (path, mo_name)
d153 1
a153 1
				compilation_path full_name,
d186 3
a188 3
		val mo_name = mo_name s
		val full_name = relative_name (path, mo_name)
		val root = root_name s
d207 2
a208 1
		  do_subrequires (require_list,compilation_path full_name,cons)
d233 1
a233 1
		  (compilation_name root, tyname_count, strname_count,
d297 1
a297 1
    (compilation_name x = compilation_name y)
d301 1
a301 1
      val st = ref("require \"" ^ root_name filename ^ "\";")
d327 1
a327 1
	compile_program (compilation_path filename, ts, empty_cb,
@


1.3
log
@Changes when implementing call point annotation
@
text
@d4 3
d226 4
a229 2
	      val Encapsulate.TOTAL_OUTPUT{env=env, consistency=cons', ...} =
		Encapsulate.input_file full_name
d273 4
a276 3
		val Encapsulate.TOTAL_OUTPUT{env=env, consistency=cons, ...} =
		  Encapsulate.input_file full_name

d302 1
a302 1
			      Integer.makestring(size p_env),
d321 1
a321 1
			      Integer.makestring(size t_env),
@


1.2
log
@Added code generation information to that returned
@
text
@d4 3
d85 1
d361 1
a361 1
             ([], [], initial_counters, empty_cb, [])
d364 2
a365 1
			     initial_counters, [])
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d27 1
d56 1
d68 1
a68 1
  sharing EnvironTypes = Encapsulate.EnvironTypes
d93 1
a93 1
    CB of (Parser.ParserBasis * Basis.Basis)
d96 1
a96 1
    CB (Parser.empty_pB, Basis.empty_basis)
d98 1
d102 1
a102 1
    val initial_cb_for_builtin_library =
d113 1
d119 8
d130 1
d222 2
a223 2
	      val {tynames=tynames, strnames=strnames, tyfuns=tyfuns, ...} = 
		Encapsulate.decode_env env
d247 1
a247 1
      fun compile_topdec(path, require_list, CB(p, t),parse,
d284 1
a284 1
		val {parser_env=p_env, ty_env=t_env, 
d296 1
d320 1
a320 1
		(require_list, [my_stamp], CB(p, t), empty_cb,
d397 1
a397 1
	   cb' as CB(parser_env, type_basis),debug_information) =
d401 1
a401 1
      (parser_env,type_basis,debug_information)
@
