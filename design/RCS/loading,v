head	1.5;
access;
symbols
	MLWorks_21c0_1999_03_25:1.5
	MLWorks_20c1_1998_08_20:1.5
	MLWorks_20c0_1998_08_04:1.5
	MLWorks_20b2c2_1998_06_19:1.5
	MLWorks_20b2_Windows_1998_06_12:1.5
	MLWorks_20b1c1_1998_05_07:1.5
	MLWorks_20b0_1998_04_07:1.5
	MLWorks_20b0_1998_03_20:1.5
	MLWorks_20m2_1998_02_16:1.5
	MLWorks_20m1_1997_10_23:1.5
	MLWorks_11r1:1.5.7.1.1.1.1
	MLWorks_11c0_1997_09_09:1.5.7.1.1.1
	MLWorks_10r3:1.5.7.1.3
	MLWorks_10r2_551:1.5.7.1.2
	MLWorks_11:1.5.7.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.5.7.1
	MLWorks_20m0_1997_06_20:1.5
	MLWorks_1_0_r2c2_1997_06_14:1.5.7.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.5.7.1
	MLWorks_1_0_r2c1_1997_05_12:1.5.7
	MLWorks_BugFix_1997_04_24:1.5
	MLWorks_1_0_r2_Win32_1997_04_11:1.5
	MLWorks_1_0_r2_Unix_1997_04_04:1.5
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.5.6.1.1
	MLWorks_1_0_Win32_1996_12_17:1.5.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.5.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.5.4.1
	MLWorks_1_0_Irix_1996_11_28:1.5.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.5.5
	MLWorks_1_0_Unix_1996_11_14:1.5.4
	MLWorks_Open_Beta2_1996_10_11:1.5.3
	MLWorks_License_dev:1.5.2
	MLWorks_1_open_beta_1996_09_13:1.5.1
	MLWorks_Open_Beta_1996_08_22:1.5
	MLWorks_Beta_1996_07_02:1.5
	MLWorks_Beta_1996_06_07:1.5
	MLWorks_Beta_1996_06_06:1.5
	MLWorks_Beta_1996_06_05:1.5
	MLWorks_Beta_1996_06_03:1.5
	MLWorks_Beta_1996_05_31:1.5
	MLWorks_Beta_1996_05_30:1.5
	ML_beta_release_12/08/94:1.5
	ML_beta_release_03/08/94:1.5
	ML_revised_beta_release_25/05/94:1.5
	ML_final_beta_release_02/03/94:1.5
	mlworks-28-01-1994:1.5;
locks; strict;
comment	@# @;


1.5
date	91.10.28.17.04.51;	author davidt;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1
	1.5.4.1
	1.5.5.1
	1.5.6.1
	1.5.7.1;
next	1.4;

1.4
date	91.10.16.12.54.07;	author davidt;	state Exp;
branches;
next	1.3;

1.3
date	91.10.16.12.14.32;	author davidt;	state Exp;
branches;
next	1.2;

1.2
date	91.10.15.17.20.20;	author davidt;	state Exp;
branches;
next	1.1;

1.1
date	91.05.03.18.12.20;	author jont;	state Exp;
branches;
next	;

1.5.1.1
date	96.09.13.11.08.01;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.10.07.15.59.11;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.10.17.11.17.34;	author hope;	state Exp;
branches;
next	;

1.5.4.1
date	96.11.14.12.41.04;	author hope;	state Exp;
branches
	1.5.4.1.1.1;
next	;

1.5.4.1.1.1
date	96.11.28.14.52.59;	author hope;	state Exp;
branches;
next	;

1.5.5.1
date	96.11.22.18.01.32;	author hope;	state Exp;
branches;
next	;

1.5.6.1
date	96.12.17.17.40.27;	author hope;	state Exp;
branches
	1.5.6.1.1.1;
next	;

1.5.6.1.1.1
date	97.02.24.11.27.51;	author hope;	state Exp;
branches;
next	;

1.5.7.1
date	97.05.12.10.25.29;	author hope;	state Exp;
branches
	1.5.7.1.1.1
	1.5.7.1.2.1
	1.5.7.1.3.1;
next	;

1.5.7.1.1.1
date	97.07.28.18.11.26;	author daveb;	state Exp;
branches
	1.5.7.1.1.1.1.1;
next	;

1.5.7.1.1.1.1.1
date	97.10.07.11.36.15;	author jkbrook;	state Exp;
branches;
next	;

1.5.7.1.2.1
date	97.09.08.17.04.44;	author daveb;	state Exp;
branches;
next	;

1.5.7.1.3.1
date	97.09.09.13.59.52;	author daveb;	state Exp;
branches;
next	;


desc
@Loading ML objects
@


1.5
log
@Up to date version I think.
@
text
@
Object file format
------------------

It is assumed that no load time resolution of addresses is required
within code sequences. Thus, the architecture must support pc-relative
branches. In the following grammar, |, is alternation, <...> indicates
terminals and ::= indicates a production rule.

We assume the following implicit definition for any syntactic class :

	[class] ::= class | class [class]
	class_size ::= <u_int32>

Any size specified is either the number of objects, or the size of the
object in bytes. The top level item is a module.

module		::= module_size [element]
element		::= real | string | codeset | external
codeset		::= opcode_codeset codeset_length total_size [code]
code		::= offset code_size [<u_int32>]
real		::= opcode_real offset real_size [<u_int32>]
string		::= opcode_string offset string_size [char]
external	::= opcode_external offset string_size [char]
offset		::= <u_int32>

During loading, all items are placed in a vector at the specified
offset, and external references are fixed up. The first element of the
resulting vector is a pointer to the initial function which is called
with the vector as its (only) argument. This is expected to transform
the collection of values previously read in into the correct structure
of a module (ie as a tuple of its declared values) and return it to
the loader.

Outstanding points to note
--------------------------

care must be taken to ensure the garbage collector sees all roots
while loading is in process. Also, the loader must be aware that ML
objects may be moved during any allocation (because the allocation may
invoke a garbage collection).
@


1.5.7.1
log
@branched from 1.5
@
text
@@


1.5.7.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.5.7.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.5.7.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.5.7.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.5.6.1
log
@branched from 1.5
@
text
@@


1.5.6.1.1.1
log
@branched from 1.5.6.1
@
text
@@


1.5.5.1
log
@branched from 1.5
@
text
@@


1.5.4.1
log
@branched from 1.5
@
text
@@


1.5.4.1.1.1
log
@branched from 1.5.4.1
@
text
@@


1.5.3.1
log
@branched from 1.5
@
text
@@


1.5.2.1
log
@branched from 1.5
@
text
@@


1.5.1.1
log
@branched from 1.5
@
text
@@


1.4
log
@Made a few changes (removec opcode_wordset and changed the positions
of the offsets so that each function in a wordset has a separate
offset).
@
text
@a0 3
The process of loading separately compiled ML object files into an ML
environment will probably consist of the interpretation of a byte code
containing instructions like:-
d2 2
a3 2
Here starts struct		Gives the numbers of elements of the
				struct.
a4 45
Here ends struct

Here comes int			Allocate the int on the heap.

Here comes real			Allocate the real on the heap.

Here comes string		Allocate the string on the heap.

Here comes function definition	Allocate the function on the heap.
				Allocate space for its closure.
				Resolve its closure from module name,
				component number pairs into the
				relevant set of constants and
				pointers. There will be a special
				module name to indicate that the item
				in question is within the current
				module.

Here comes function application	Call the function with its argument.
				Return a pointer to the result. There
				is room for optimisation of heap usage
				by possibly allocating the argument on
				the stack.

Here comes sequence of words	The words will be in the endian-ness
				of the producer, and may need reversal.

All items within a module can be resolved by their position within
that module, eg component 5 of component 4 of the module. Thus the
symbol table need only keep track of the module names.

Do we want all the internal names used to build such an object (eg an
ML environment) to be available? Probably not, though we need a method
by which certain names are made available, as though they had been
interpreted before the world began.

The resulting structure is a hierarchical one, starting at the level
of program, consisting of a tuple of pointers to modules 1 to n (and
their names for future reference), each of which is itself a similar
tuple of pointers to the top level values within the module, of
which those which are structures themselves are also tuples, etc.

Precise definition of the loadable code
---------------------------------------

d6 3
a8 3
within code sequences. Thus for instance the architecture must support
pc-relative branches. In the following grammar, |, is alternation,
<...> indicates terminals, and ::= indicates a production rule.
d15 2
a16 1
The top level item is a module.
d19 3
a21 3
element		::= real | string | wordset | external
wordset		::= opcode_wordset wordset_size total_size [words]
words		::= offset words_size [<u_int32>]
d24 1
a24 1
external	::= opcode_external offset string_value
d27 7
a33 7
During loading, all items are placed in store, and unresolved
references are fixed up to earlier parts of this module, or to
previously loaded modules. On encountering a call opcode, the object
given is interpreted as a function definition and called. This is
expected to transform the collection of values previously read in into
the correct structure of a module (ie as a tuple of its declared
values) and add it to the ML heap. Control then returns to the loader.
d35 2
a36 49
Outstanding questions/points to note.
1. The garbage collector must be turned off during the loading of the
various items as they have yet to become persistent (the only
references to them are in C variables). It must be turned on again
before calling the main function. Alternatively, the garbage collector
must be informed of a root lying within a C data structure, which it
may not move, but may modify internally.
2. Closures for functions within module can be built by means of load
time directives provide that they contain only:-
	a) Integer values
	b) Simple references (reals and strings)
	c) References to other fully closed functions within module
	d) References to external functions
Thus a function requiring another function within this module to be
placed within its closure can only have its closure built this way if
the other function has its closure already built in this way (mutually
recursive functions cannot be handled by this mechanism).
3. There needs to be a mechanism for resolving external references
when building closure objects if we want to optimise this part (ie
rather than doing it entirely within the final function). This merely
involves fixing the ML representation of record values. This is done
by field selection.
4. The run time tagging needs to be fixed, including those tags within
block headers to inform the garbage collector as to whether a block
contains pointer values. The loader needs to insert these tags during
the load process.
5. The garbage collector supports two runtime record types. These are
an ordinary one, and a special one for two element records in order to
allow cons cells to be done efficiently. The ordinary one has a header
word on the front of it, the cons cell doesn't. It is assumed that
tagged pointers to these items will both point to the first data item
(modulo the tagging information within the pointer). Thus the header
will be at an offset before the first item pointed to by a record
pointer. This will facilitate the dynamic record selection required by
the loader during resolution of external references. This may not be
necessary, see point 6 below.
6. It will probably turn out that indexes are unnecessary, and that
external references will always be to entire file compilations, with
the relevant field selection done within the compiled code.
7. Code loading will be roughly as follows:-
Action delivering result				| Slot
.							|
.							|
.							|
RECORD(loc_ref 0, ..., loc_ref m-1)			| n
STRING(code)						| n+1
fn_call n+1 n (delivers a further function)		| n+2
RECORD(ext_ref <file 0>, ..., ext_ref <file k-1>	| n+3
fn_call n+2 n+3 (delivers the STRUCT of this file)	| n+4
d38 4
a41 5
This last function call is the final action of loading, and after it
has happened many of the previous slots will become garbage collected
away. In particular, it will be the only slot directly visible to the
garbage collector, so anything previous that it does not reference is
available for garbage collection.
@


1.3
log
@Big rationalisation of previous design.
@
text
@d65 1
a65 1
module		::= module_size [offset element]
d68 5
a72 4
words		::= opcode_words words_size [<u_int32>]
real		::= opcode_real real_size [<u_int32>]
string		::= opcode_string string_size [char]
external	::= opcode_external string_value
@


1.2
log
@The latest version of jon's file loading.
This file should have been updated in RCS a while ago.
@
text
@d50 2
a51 7
Precise definition of the loadable code. It is assumed that no load
time resolution of addresses is required within code sequences. Thus
for instance the architecture must support pc-relative branches. The
following is in a sort of BNF, where | indicates alternation, < and >
indicate non-terminals and ::= indicates a production rule. There are
also symbols for certain fixed terminals whose values are as yet
unassigned.
d53 4
a56 1
First a meta-production.
d58 1
a58 3
[a] ::= a | a[a]
where a is any element of the grammar, either terminal or
non-terminal.
d60 2
a61 1
The top level item is a module.
a62 47
module			::= <structure>
structure		::= code_start_struct <structure_body> code_end_struct
structure_body		::= <structure_size> [<structure_element>]
structure_size		::= <u_int32>
structure_element	::= <structure> | <integer> | <real> |
			<string> | <fn_def> | <fn_app>
integer			::= code_int <u_int32>
real			::= code_real <real_value>
string			::= code_string <string_size> <string_value>
string_size		::= <u_int32>
string_value		::= [<char>]
fn_app			::= code_fn_app <fn_body>
fn_def			::= code_fn_def <fn_body>
fn_body			::= <closure> <instrs>
instrs			::= <instrs_size> [<u_int32>]
instrs_size		::= <u_int32>
closure			::= <closure_size> [<closure_element>]
closure_size		::= <u_int32>
closure_element		::= <integer> | <real> | <string> |
			<name_by_components>
name_by_components	::= code_start_comp <name_by_components_body>
			code_end_comp
name_by_components_body	::= <string_size> <string_value>
			<number_of_components> [<component_value>]
number_of_components	::= <u_int32>
component_value		::= <u_int32>

This doesn't yet explicitly address structured plain values, such as
tuples and lists. However, these could be done as function
applications to construct them.

The loading process occurs in two passes. During the first pass, all
items are placed in store, and a list of unresolved references is
produced for items using name_by_components (such as values from
external modules, recursive function definitions). This list is
resolved at the end of the first pass, when all positions of store
items is fixed. During the second pass, all structures are scanned
depth first for function applications, and these are executed as
encountered in order to provide structured values and other general
non-compile time values.

A second attempt

[a] ::= a | a[a]
where a is any element of the grammar, either terminal or
non-terminal.

d65 7
a71 26
module			::= <module_size> [<module_element>]
module_size		::= <u_int32>
module_element		::= <real> | <string> | <wordset> | <record> |
			| <integer> | <fn_call>
wordset			::= code_wordset <wordset_len> <wordset_size> [words]
wordset_len		::= <u_int32>
wordset_size		::= <u_int32>
words			::= code_words <words_size> [<u_int32>]
words_size		::= <u_int32>
fn_call			::= code_fn_call <fn_number> <record_element>
fn_number		::= <u_int32>
record			::= code_record <record_size> [<record_element>]
record_size		::= <u_int32>
record_element		::= <integer> | <local_reference> |
			<external_reference>
integer			::= code_int <u_int32>
real			::= code_real <real_value>
real_value		::= <real_size> [<u_int32>]
string			::= code_string <string_value>
string_value		::= <string_size> [<char>]
string_size		::= <u_int32>
local_reference		::= code_loc_ref <u_int32>
external_reference	::= code_ext_ref <string_value> <index>
index			::= <index_size> <index_value>
index_size		::= <u_int32>
index_value		::= [<u_int32>]
@


1.1
log
@Initial revision
@
text
@a3 10
Here comes int			Allocate the int on the heap
Here comes string		Allocate the string on the heap
Here comes function definition	Allocate the function on the heap, add
				its name to the dynamic symbol table,
				look up all names in its closure and
				resolve them.
Here comes function application	Resolve the function name and call the
				function, returning the address as the
				result, to be added to the current
				item.
d5 30
d44 161
@
