head	1.1;
access;
symbols
	MLWorks_21c0_1999_03_25:1.1
	MLWorks_20c1_1998_08_20:1.1
	MLWorks_20c0_1998_08_04:1.1
	MLWorks_20b2c2_1998_06_19:1.1
	MLWorks_20b2_Windows_1998_06_12:1.1
	MLWorks_20b1c1_1998_05_07:1.1
	MLWorks_20b0_1998_04_07:1.1
	MLWorks_20b0_1998_03_20:1.1
	MLWorks_20m2_1998_02_16:1.1
	MLWorks_20m1_1997_10_23:1.1
	MLWorks_11r1:1.1.7.1.1.1.1
	MLWorks_11c0_1997_09_09:1.1.7.1.1.1
	MLWorks_10r3:1.1.7.1.3
	MLWorks_10r2_551:1.1.7.1.2
	MLWorks_11:1.1.7.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.1.7.1
	MLWorks_20m0_1997_06_20:1.1
	MLWorks_1_0_r2c2_1997_06_14:1.1.7.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.1.7.1
	MLWorks_1_0_r2c1_1997_05_12:1.1.7
	MLWorks_BugFix_1997_04_24:1.1
	MLWorks_1_0_r2_Win32_1997_04_11:1.1
	MLWorks_1_0_r2_Unix_1997_04_04:1.1
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.1.6.1.1
	MLWorks_1_0_Win32_1996_12_17:1.1.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.1.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.1.4.1
	MLWorks_1_0_Irix_1996_11_28:1.1.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.1.5
	MLWorks_1_0_Unix_1996_11_14:1.1.4
	MLWorks_Open_Beta2_1996_10_11:1.1.3
	MLWorks_License_dev:1.1.2
	MLWorks_1_open_beta_1996_09_13:1.1.1
	MLWorks_Open_Beta_1996_08_22:1.1
	MLWorks_Beta_1996_07_02:1.1
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1
	ML_beta_release_12/08/94:1.1
	ML_beta_release_03/08/94:1.1
	ML_revised_beta_release_25/05/94:1.1
	ML_final_beta_release_02/03/94:1.1
	mlworks-28-01-1994:1.1;
locks; strict;
comment	@# @;


1.1
date	91.05.20.17.06.37;	author jont;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1
	1.1.4.1
	1.1.5.1
	1.1.6.1
	1.1.7.1;
next	;

1.1.1.1
date	96.09.13.11.07.54;	author hope;	state Exp;
branches;
next	;

1.1.2.1
date	96.10.07.15.59.04;	author hope;	state Exp;
branches;
next	;

1.1.3.1
date	96.10.17.11.17.25;	author hope;	state Exp;
branches;
next	;

1.1.4.1
date	96.11.14.12.40.56;	author hope;	state Exp;
branches
	1.1.4.1.1.1;
next	;

1.1.4.1.1.1
date	96.11.28.14.52.51;	author hope;	state Exp;
branches;
next	;

1.1.5.1
date	96.11.22.18.01.23;	author hope;	state Exp;
branches;
next	;

1.1.6.1
date	96.12.17.17.40.19;	author hope;	state Exp;
branches
	1.1.6.1.1.1;
next	;

1.1.6.1.1.1
date	97.02.24.11.27.32;	author hope;	state Exp;
branches;
next	;

1.1.7.1
date	97.05.12.10.25.19;	author hope;	state Exp;
branches
	1.1.7.1.1.1
	1.1.7.1.2.1
	1.1.7.1.3.1;
next	;

1.1.7.1.1.1
date	97.07.28.18.11.17;	author daveb;	state Exp;
branches
	1.1.7.1.1.1.1.1;
next	;

1.1.7.1.1.1.1.1
date	97.10.07.11.36.01;	author jkbrook;	state Exp;
branches;
next	;

1.1.7.1.2.1
date	97.09.08.17.04.36;	author daveb;	state Exp;
branches;
next	;

1.1.7.1.3.1
date	97.09.09.13.59.41;	author daveb;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@In order to call foreign functions from ML (such as the run time
library) we will need to do some data format conversions. In
particular, strings will need to become zero terminated rather than
having lengths associated with them, and integers will have to become
untagged by being shifted right two bits. Whilst the first function
(make C string) can effectively be produced in ML simply by appending
a zero in the appropriate place, the second can't, since it would
produce a value looking (potentially) like a pointer.

There is also a corresponding problem with interpreting the results of
function calls.

At the very least, integer parameters may be recognised by their tags,
and suitably converted. Similarly, pointer parameters need their tag
bits clearing.

This still leaves the more thorny problems of the internal structure
of objects passed by reference. Firstly, such objects might contain
integers, which need shifting. Secondly, ML does not order its records
in the declared order, but in an order of its own choosing. What we
will need in order to overcome these problems is something like the
LISP concept of an alien object, with constructors and destructors,
all of which are of course horribly type unsafe.

There are also problems in the interaction of C functions with the
garbage collector. In order to avoid heap fragmentation we shall need
our own version of malloc, which will interact sensibly with the
garbage collector. Thus if a C function calls malloc, it may cause a
garbage collection which in turn may move objects which the C wishes
to reference. But since C pointers will not be tagged, the garbage
collector cannot fix up these references within the stack and local
registers. We may also run into problems if the library itself calls
malloc and has been statically linked already. this can be a common
problem with shared libraries, where the static linking is done to
avoid the overhead of an extra indirection on every function call
within the library. This may be avoidable on most unix systems, if
only by linking with non-shared libraries. On other systems (MS-DOS,
RISC OS) the problem may be harder.
@


1.1.7.1
log
@branched from 1.1
@
text
@@


1.1.7.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.1.7.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.1.7.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.1.7.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.1.6.1
log
@branched from 1.1
@
text
@@


1.1.6.1.1.1
log
@branched from 1.1.6.1
@
text
@@


1.1.5.1
log
@branched from 1.1
@
text
@@


1.1.4.1
log
@branched from 1.1
@
text
@@


1.1.4.1.1.1
log
@branched from 1.1.4.1
@
text
@@


1.1.3.1
log
@branched from 1.1
@
text
@@


1.1.2.1
log
@branched from 1.1
@
text
@@


1.1.1.1
log
@branched from 1.1
@
text
@@
