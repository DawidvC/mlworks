head	1.4;
access;
symbols
	MLWorks_21c0_1999_03_25:1.4
	MLWorks_20c1_1998_08_20:1.4
	MLWorks_20c0_1998_08_04:1.4
	MLWorks_20b2c2_1998_06_19:1.4
	MLWorks_20b2_Windows_1998_06_12:1.4
	MLWorks_20b1c1_1998_05_07:1.4
	MLWorks_20b0_1998_04_07:1.4
	MLWorks_20b0_1998_03_20:1.4
	MLWorks_20m2_1998_02_16:1.4
	MLWorks_workspace_97:1.4.1
	MLWorks_20m1_1997_10_23:1.4
	MLWorks_20m0_1997_06_20:1.3;
locks; strict;
comment	@# @;


1.4
date	97.06.06.11.16.15;	author stephenb;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	97.05.19.13.47.43;	author stephenb;	state Exp;
branches;
next	1.2;

1.2
date	97.05.09.13.45.50;	author stephenb;	state Exp;
branches;
next	1.1;

1.1
date	97.04.29.14.09.47;	author stephenb;	state Exp;
branches;
next	;

1.4.1.1
date	97.11.30.16.48.14;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
[Bug #30030]
@


1.4
log
@[Bug #30029]
Update with respect to the change from C -> MLWorksCInterface.
@
text
@The add example is is very simple.  It shows how to interface MLWorks
to a C function that adds two integers and returns the result.  As
such it shows the following parts of the foreign interface :-
 
 - calling a C function from ML
 - passing C integer from ML to C.
 - returning a C integer from C to ML.

The first step to running the example is to follow the instructions
in the README contained in enclosing directory about how set up any
necessary values that the example requires and building the library
that the example requires.

Once the library has been built, start MLWorks and then :-

* Create a listener and load in the add code into MLWorks by doing :-

    Shell.File.loadSource "__add";

* If all goes well the C library has been loaded and it is ready to
  be called.  Since the arguments to the add function are C types,
  you need to explicitly load the C interface to enable you to
  interactively create C objects :-

    Shell.Build.loadSource "foreign.__mlworks_c_interface";

* Create some C integers and pass them to the add routine.  For
  example ...

    MLWorks> structure C = MLWorksCInterface;

    MLWorks> val x = C.Int.fromInt 25;
    val x : C.Int.int = _

    MLWorks> val y = C.Int.fromInt 17;
    val y : C.Int.int = _

    MLWorks> val z = Add.add (x, y);
    val z : C.Int.int = _

    MLWorks> C.Int.toInt z;
    val it : int = 42
@


1.4.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@@


1.3
log
@[Bug #30121]
Remove any mention of settting MLWORKS_INCLUDE and OS specific bits.
This is now taken care of in a README that covers all examples.
@
text
@d25 1
a25 1
	Shell.Build.loadSource "foreign.__c";
d30 1
a30 2
	MLWorks> val x = C.Int.fromInt 25
	val x : C.signed C.c_int = C_INT 0w25
d32 2
a33 2
	MLWorks> val y = C.Int.fromInt 17
	val y : C.signed C.c_int = C_INT 0w17
d35 2
a36 2
	MLWorks> val z = Add.add (x, y);
	val z : C.signed C.c_int = C_INT 0w42
d38 5
a42 2
	MLWorks> C.Int.toInt z;
	val it : int = 42
@


1.2
log
@[Bug #30033]
Add a note about MLWORKS_LIB for Win32.
@
text
@d1 12
a12 1
			     -*- Text -*-
d14 1
a14 53
* Create the C library file by passing the appropriate Makefile for
  your platform to make.  You also need to ensure that MLWORKS_INCLUDE
  is set to the directory containing mlw_ci.h and if you are working
  under NT or Win95 that MLWORKS_LIB is set to 
  containing main.lib.  This can be achieved by using environment
  variables, editing the appropriate Makefile or passing the values to
  the make.

  For example, when compiling for NT with MLWorks installed in
  C:\MLWorks you could edit Makefile.Win32 to include :-

    MLWORKS_INCLUDE=C:\MLWorks\foreign
    MLWORKS_LIB=C:\MLWorks\foreign\main.lib

  and then do

    nmake -f Makefile.Win32

  or pass the values as arguments to make :-

    nmake -f Makefile.Win32 MLWORKS_INCLUDE=C:\MLWorks\foreign MLWORKS_LIB=C:\MLWorks\foreign\main.lib


  Under Unix, the MLWORKS_LIB value does not need to be set, so
  assuming that MLWorks is installed in /usr/local/MLWorks, you could
  edit the makefile to include :-

    MLWORKS_INCLUDE=/usr/local/MLWorks/foreign

  set an environment variable using setenv in csh :-

    setenv MLWORKS_INCLUDE /usr/local/MLWorks/foreign

  or via export in sh/ksh/bash :-

    MLWORKS_INCLUDE=/usr/local/MLWorks/foreign
    export MLWORKS_INCLUDE

  and then just call make.  For example, under Solaris that would be :-

    make -f Makefile.Solaris

  or pass the value as an argument to make.  Again under Solaris that
  would be :-

    make -f Makefile.Solaris MLWORKS_INCLUDE=/usr/local/MLWorks/foreign



* Start MLWorks and ensure that the source path includes either Unix
  or Win32 as is appropriate for your system -- either set this on
  the command line using -source-path or use the Paths menu to add
  it.  
@


1.1
log
@new unit
[Bug #30030]
@
text
@d3 7
a9 1
1. Ensure that MLWORKS_INCLUDE is set to the directory that contains mlw_ci.h
d11 2
a12 3
2. Create the C library file by passing the appropriate Makefile for
   your platform to make.  For example, if running on a Solaris
   machine type :-
d14 2
a15 1
	make -f Makefile.Solaris
d17 1
a17 4
3. Start MLWorks and ensure that the source path includes either Unix
   or Win32 as is appropriate for your system -- either set this on
   the command line using -source-path or use the Paths menu to add
   it.  
d19 1
a19 1
4. Create a listener and load in the add code into MLWorks by doing :-
d21 1
a21 1
	Shell.File.loadSource "__add";
d23 42
a64 4
5. If all goes well the C library has been loaded and it is ready to
   be called.  Since the arguments to the add function are C types,
   you need to explicitly load the C interface to enable you to
   interactively create C objects :-
d68 2
a69 2
6. Create some C integers and pass them to the add routine.  For
   example ...
a81 1

@
