head	1.1;
access;
symbols
	MLWorks_21c0_1999_03_25:1.1
	MLWorks_20c1_1998_08_20:1.1
	MLWorks_20c0_1998_08_04:1.1
	MLWorks_20b2c2_1998_06_19:1.1
	MLWorks_20b2_Windows_1998_06_12:1.1
	MLWorks_20b1c1_1998_05_07:1.1
	MLWorks_20b0_1998_04_07:1.1
	MLWorks_20b0_1998_03_20:1.1
	MLWorks_20m2_1998_02_16:1.1
	MLWorks_workspace_97:1.1.1
	MLWorks_20m1_1997_10_23:1.1;
locks; strict;
comment	@# @;


1.1
date	97.06.30.15.26.44;	author stephenb;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.11.30.16.48.33;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
** No reason given. **
@


1.1
log
@new unit
** No reason given. **
@
text
@The stdio example consists of two simple versions of the Unix cat
program: __kitten.sml and __cat.sml.  The examples show the following
parts of the foreign interface :- 

 - The built in MLWorks <-> C <stdio.h> binding.
 - correct way to use C variables bound to ML values.
 - calling C functions from ML.
 - passing pointers to C structures from ML to C.
 - returning pointers to C structures from C to ML.
 - creating a standalone executable.

The first step to running the examples is to follow the instructions
in the README contained in enclosing directory about how set up any
necessary values that the examples require and building the library
that the examples require.

Once the library has been built, start MLWorks and create a listener
and load in one of the versions of cat.  For example, to load in
__kitten.sml do :-

  MLWorks> Shell.File.loadSource "__kitten";

This should create an executable called 'kitten'.  Loading __cub.sml
is done in the same way :-

  MLWorks> Shell.File.loadSource "__cub";

and this should create an executable called 'cub'.

To run either of the examples, just pass the name of the files to
concatenate.  For example, the following will concatenate __kitten.sml
and __cub.sml and write the result to the standard output.

@


1.1.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@@
