head	1.15;
access;
symbols
	MLWorks_21c0_1999_03_25:1.15
	MLWorks_20c1_1998_08_20:1.14
	MLWorks_20c0_1998_08_04:1.14
	MLWorks_20b2c2_1998_06_19:1.14
	MLWorks_20b2_Windows_1998_06_12:1.14
	MLWorks_20b1c1_1998_05_07:1.14
	MLWorks_20b0_1998_04_07:1.13
	MLWorks_20b0_1998_03_20:1.13
	MLWorks_20m2_1998_02_16:1.13
	MLWorks_workspace_97:1.13.1
	MLWorks_20m1_1997_10_23:1.13
	MLWorks_11r1:1.8.1.3.1.4.1
	MLWorks_11c0_1997_09_09:1.8.1.3.1.4
	MLWorks_10r3:1.8.1.3.3
	MLWorks_10r2_551:1.8.1.3.2
	MLWorks_11:1.8.1.3.1
	MLWorks_1_0_r2c2_1997_07_28:1.8.1.3
	MLWorks_20m0_1997_06_20:1.10
	MLWorks_1_0_r2c2_1997_06_14:1.8.1.3
	MLWorks_1_0_r2c1_released_1997_05_23:1.8.1.3
	MLWorks_1_0_r2c1_1997_05_12:1.8.1
	MLWorks_BugFix_1997_04_24:1.8
	MLWorks_1_0_r2_Win32_1997_04_11:1.8
	MLWorks_1_0_r2_Unix_1997_04_04:1.6
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.5.1.1.1
	MLWorks_1_0_Win32_1996_12_17:1.5.1
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.3.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.3.1.1
	MLWorks_1_0_Irix_1996_11_28:1.3.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.3.2
	MLWorks_1_0_Unix_1996_11_14:1.3.1
	MLWorks_Open_Beta2_1996_10_11:1.1.1;
locks; strict;
comment	@ *  @;


1.15
date	98.11.09.11.31.51;	author johnh;	state Exp;
branches;
next	1.14;

1.14
date	98.05.07.14.54.46;	author jkbrook;	state Exp;
branches;
next	1.13;

1.13
date	97.08.28.08.50.48;	author johnh;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	97.08.06.12.25.04;	author johnh;	state Exp;
branches;
next	1.11;

1.11
date	97.08.05.14.45.45;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	97.06.16.13.01.12;	author jkbrook;	state Exp;
branches;
next	1.9;

1.9
date	97.05.14.13.43.52;	author johnh;	state Exp;
branches;
next	1.8;

1.8
date	97.04.11.09.22.53;	author johnh;	state Exp;
branches
	1.8.1.1;
next	1.7;

1.7
date	97.04.10.16.19.02;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	97.01.07.16.34.48;	author io;	state Exp;
branches;
next	1.5;

1.5
date	96.12.06.11.13.25;	author johnh;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	96.12.02.13.55.53;	author johnh;	state Exp;
branches;
next	1.3;

1.3
date	96.11.07.19.02.30;	author jkbrook;	state Exp;
branches
	1.3.1.1
	1.3.2.1;
next	1.2;

1.2
date	96.11.06.11.54.48;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	96.10.11.14.10.15;	author johnh;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.10.17.11.17.03;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	96.11.14.12.40.31;	author hope;	state Exp;
branches
	1.3.1.1.1.1;
next	;

1.3.1.1.1.1
date	96.11.28.14.52.21;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.11.22.18.00.59;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.12.17.17.39.52;	author hope;	state Exp;
branches
	1.5.1.1.1.1;
next	;

1.5.1.1.1.1
date	97.02.24.11.27.04;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	97.05.12.10.24.52;	author hope;	state Exp;
branches;
next	1.8.1.2;

1.8.1.2
date	97.05.15.08.47.06;	author daveb;	state Exp;
branches;
next	1.8.1.3;

1.8.1.3
date	97.05.15.13.22.08;	author daveb;	state Exp;
branches
	1.8.1.3.1.1
	1.8.1.3.2.1
	1.8.1.3.3.1;
next	;

1.8.1.3.1.1
date	97.07.28.18.10.50;	author daveb;	state Exp;
branches;
next	1.8.1.3.1.2;

1.8.1.3.1.2
date	97.08.05.14.45.47;	author johnh;	state Exp;
branches;
next	1.8.1.3.1.3;

1.8.1.3.1.3
date	97.08.06.16.14.12;	author johnh;	state Exp;
branches;
next	1.8.1.3.1.4;

1.8.1.3.1.4
date	97.08.28.09.06.16;	author johnh;	state Exp;
branches
	1.8.1.3.1.4.1.1;
next	;

1.8.1.3.1.4.1.1
date	97.10.07.11.35.14;	author jkbrook;	state Exp;
branches;
next	;

1.8.1.3.2.1
date	97.09.08.17.04.08;	author daveb;	state Exp;
branches;
next	;

1.8.1.3.3.1
date	97.09.09.13.59.10;	author daveb;	state Exp;
branches;
next	;

1.13.1.1
date	97.11.30.16.47.51;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Reorganised demo directory to include separate demos for mswindows and motif.
@


1.15
log
@[Bug #50105]
Make toplevel functions unique across demos to avoid conflicts when loading demo project.
@
text
@(*  ==== Life demo  ====
 *
 *  Copyright (C) 1997 The Harlequin Group Limited.  All rights reserved.
 *
 * $Log: mswindows:life.sml,v $
 *  Revision 1.14  1998/05/07  14:54:46  jkbrook
 *  [Bug #30388]
 *  Change Windows to WindowsGui
 *  Also put in ignores to get rid of warnings
 *
 *  Revision 1.13  1997/08/28  08:50:48  johnh
 *  [Bug #30257]
 *  Generations cannot overlap now, and background is always white.
 *
 *  Revision 1.12  1997/08/06  12:25:04  johnh
 *  [Bug #30130]
 *  Made a delivered life work properly and removed some fns from users view.
 *
 *  Revision 1.11  1997/08/05  14:45:45  daveb
 *  [Bug #30130]
 *  Stopped mainLoop from looping in the event of an exception.
 *  Added a "destroyed" flag to prevent the timer attempting to draw in the
 *  window after it has been destroyed.  Removed code that was creating bogus
 *  new generations.  Ensured that the initial state is always drawn.
 *  A little tidying up.
 *
 *  Revision 1.10  1997/06/16  13:01:12  jkbrook
 *  [Bug #30127]
 *  Merging changes from 1.0r2c1 into 2.0m0
 *
 *
 *  Revision 1.8.1.3  1997/05/15  13:22:08  daveb
 *  [Bug #30127]
 *  Updated copyright.
 *
 *  Revision 1.8.1.2  1997/05/15  08:47:06  daveb
 *  [Bug #20009]
 *  Making the demo unresizable.
 *
 *  Revision 1.8.1.1  1997/05/12  10:24:52  hope
 *  branched from 1.8
 *
 *  Revision 1.9  1997/05/14  13:43:52  johnh
 *  Solving the resize problem.
 *
 *  Revision 1.8  1997/04/11  09:22:53  johnh
 *  Remove references to MLWorks.Internal and tidy the messy code.
 *
 *  Revision 1.7  1997/04/10  16:19:02  daveb
 *  [Bug #2039]
 *  Removed use of Threads.  Also changed handler for WM_DESTROY to WM_CHANGE.
 *
 *  Revision 1.6  1997/01/07  16:34:48  io
 *  [Bug #1757]
 *  renamed __ieeereal
 *
 *  Revision 1.5  1996/12/06  11:13:25  johnh
 *  Removed some test code.
 *
 *  Revision 1.4  1996/12/02  13:55:53  johnh
 *  [Bug #1823]
 *  Removing references to capitypes and labelstrings.
 *
 *  Revision 1.3  1996/11/07  19:02:30  jkbrook
 *  Removing redundant references to structure Windows_
 *
 *  Revision 1.1  1996/10/11  14:10:15  johnh
 *  new unit
 *  Reorganised demo directory to include separate demos for mswindows and motif.
 *
 *
 *)

require "forms";

require "$.winsys.__windows_gui";
require "$.basis.__int"; 
require "$.basis.__real";
require "$.basis.__string";
require "$.basis.__text_io";
require "$.basis.__ieee_real";
require "$.basis.__array";
require "$.basis.__word"; 

val gunvals =
  [(2,20),(3,19),(3,21),(4,18),
   (4,22),(4,23),(4,32),(5,7),
   (5,8),(5,18),(5,22),(5,23),
   (5,29),(5,30),(5,31),(5,32),
   (5,36),(6,7),(6,8),(6,18),
   (6,22),(6,23),(6,28),(6,29),
   (6,30),(6,31),(6,36),(7,19),
   (7,21),(7,28),(7,31),(7,42),
   (7,41),(8,20),(8,28),(8,29),
   (8,30),(8,31),(8,42),(8,41),
   (9,29),(9,30),(9,31),(9,32)
   ]
    
local
  fun lshift (i1, i2) = Word.toInt (Word.<< (Word.fromInt i1, Word.fromInt i2))

  val size_exp = 3
  val block_size = lshift (1,size_exp)
    
  fun max (x:int,y) = if x > y then x else y
  fun min (x:int,y) = if x < y then x else y
    
  fun make_gen (n,m) =
    (Array.tabulate (n, fn _ => Array.array (m,0)),
     n,
     m)
    
  fun sub ((array,n,m),i,j) =
    if i < 0 then 0
    else if j < 0 then 0
    else if i >= n then 0
    else if j >= m then 0
	 else Array.sub (Array.sub (array,i),j)
	   
  fun mymod (i,n) =
    if i < 0 then mymod (i+n,n)
    else if i >= n then mymod (i-n,n)
	 else i
	   
  fun update ((array,n,m),i,j,x:int) =
    Array.update (Array.sub (array,mymod (i,n)),mymod (j,m),x)
    
  fun calc_val (array,i,j) =
    sub (array,i-1,j-1) +
    sub (array,i-1,j) +
    sub (array,i-1,j+1) +
    sub (array,i,j-1) +
    sub (array,i,j+1) +
    sub (array,i+1,j-1) +
    sub (array,i+1,j) +
    sub (array,i+1,j+1)
    
  fun calc_val ((a,n,m),i,j) : int =
    let
      val lix = if j = 0 then m-1 else j-1
      val mix = j
      val rix = if j = m-1 then 0 else j+1
      val top_row = Array.sub (a,if i=0 then n-1 else i-1)
      val mid_row = Array.sub (a,i)
      val bottom_row = Array.sub (a,if i = n-1 then 0 else i+1)
    in
      Array.sub (top_row,lix) +
      Array.sub (top_row,mix) +
      Array.sub (top_row,rix) +
      Array.sub (mid_row,lix) +
      Array.sub (mid_row,rix) +
      Array.sub (bottom_row,lix) +
      Array.sub (bottom_row,mix) +
      Array.sub (bottom_row,rix)
    end
  
  fun new (ina,i,j,outa) =
    let
      val newval =
	case calc_val (ina,i,j) of
	  2 => sub (ina,i,j)
	| 3 => 1
	| _ => 0
    in
      update (outa,i,j,newval)
    end
  
  fun clean (a,n,m) =
    let
      fun loop1 i =
	if i = n
	  then ()
	else
	  let
	    val suba = Array.sub (a,i)
	    fun loop2 j =
	      if j = m then ()
	      else 
		(Array.update (suba,j,0);
		 loop2 (j+1))
	  in
	    loop2 0;
	    loop1 (i+1)
	  end
    in
      loop1 0
    end
  
  fun gen (ina as (_,n,m),outa) =
    let
      fun loop1 i =
	if i = n
	  then ()
	else
	  let
	    fun loop2 j =
	      if j = m then ()
	      else 
		(new (ina,i,j,outa);
		 loop2 (j+1))
	  in
	    loop2 0;
	    loop1 (i+1)
	  end
    in
      clean outa;
      loop1 0;
      (outa,ina)
    end
  
  fun set (a,[]) = ()
    | set (a,(i,j)::rest) =
      (update (a,i,j,1);
       set (a,rest))
      
  fun move (a:int,b:int) l = map (fn (x,y) => (x+a,y+b)) l
    
  val initvals = move (10,10) crash
    
  fun init_gen (initvals,world_x,world_y) = 
    let
      val (a1,a2) = (make_gen (world_x,world_y),make_gen (world_x,world_y))
      val _ = set (a1,initvals)
    in
      (a1,a2)
    end
  
  val state = ref (make_gen (0,0),make_gen (0,0))
    
  (* Windows stuff *)

  fun munge_string s =
    let
      fun munge ([],acc) = MLWorks.String.implode (rev acc)
        | munge ("\013" :: "\010" :: rest,acc) =
          munge (rest, "\010" :: "\013" :: acc)
        | munge ("\n"::rest,acc) = munge (rest,"\013\010" :: acc)
        | munge (c::rest,acc) = munge (rest,c::acc)
    in
      munge (MLWorks.String.explode s,[])
    end

  fun make_life_widget (name,class,parent,height,width,attributes) = 
    let
      val window =
        WindowsGui.createWindow {class = class,
                         name = name,
                         width = width,
                         height = height,
                         parent = parent,
                         menu = WindowsGui.nullWord,
                         styles = attributes}
    in
      WindowsGui.showWindow (window,WindowsGui.SW_SHOWNORMAL);
      WindowsGui.updateWindow window;
      window
    end

  fun make_toplevel (world_x,world_y) =
    let
      val title = "test"
	
      (*  The extent of the drawing area *)
      val xextent = world_x * block_size
      val yextent = world_y * block_size

      val default_width = xextent
      val toplevel_width = default_width + 10
      val graphics_height = yextent
      val toplevel_height = graphics_height + 34
  
      val applicationShell = WindowsGui.mainInit ()

      val life = make_life_widget ("Life", "Frame", applicationShell, 
			toplevel_height, toplevel_width,
			[WindowsGui.WS_OVERLAPPED, 
			 WindowsGui.WS_SYSMENU,
			 WindowsGui.WS_MINIMIZEBOX])

      local 
	val hdc = WindowsGui.getDC life
      in 
	val on_brush = WindowsGui.createSolidBrush (WindowsGui.getTextColor hdc);
	val off_brush = WindowsGui.createSolidBrush (WindowsGui.getBkColor hdc);
	val _ = WindowsGui.releaseDC (life,hdc)
      end

      fun draw_image (x,y) = 
	let val hdc = WindowsGui.getDC life
	in (WindowsGui.fillRect (hdc,WindowsGui.RECT {left=x+1,top=y+1,right=x + block_size,
				bottom=y + block_size}, on_brush);
	    WindowsGui.releaseDC (life,hdc))
	end
	
      fun clear_image (x,y) =
	let val hdc = WindowsGui.getDC life
	in (WindowsGui.fillRect (hdc,WindowsGui.RECT {left=x+1,top=y+1,right=x + block_size,
				bottom=y + block_size}, off_brush);
	    WindowsGui.releaseDC (life,hdc))
	end

      fun make_rect (x,y) = WindowsGui.RECT {left=lshift (x,size_exp)+1,
					  top=lshift (y,size_exp)+1,
					  right=(lshift (x,size_exp)+1)+ block_size,
					  bottom=(lshift (y,size_exp)+1) +block_size}
	
      fun draw_picture _ =
	let
	  val ((gen1,_,_),(gen2,_,_)) = !state
	  val on_rects = ref []
	  val off_rects = ref []
	  val hdc = WindowsGui.getDC life
	  fun fill_rects (brush, []) = ()
	    | fill_rects (brush, (rect1::rest)) = 
		(WindowsGui.fillRect(hdc, rect1, brush); 
		 fill_rects (brush, rest))
	in
          Array.appi
	  (fn (i,a) =>
	   let
	     val max = Array.length a
	     val a2 = Array.sub (gen2,i)
	     fun loop j = 
	       if j = max then ()
	       else
		 let
		   val n = Array.sub (a,j)
		 in
		   if n = 1 then 
		     on_rects := make_rect (i,j) :: !on_rects
		   else
		     if n = Array.sub (a2,j)
		       then ()
		     else
		       off_rects := make_rect (i,j) :: !off_rects;
		       loop (j+1)
		 end
	   in
	     loop 0
	   end)
	  (gen1, 0, NONE);
	  fill_rects (off_brush,!off_rects);
	  fill_rects (on_brush, !on_rects);
	  WindowsGui.releaseDC (life, hdc)
	end
      
      val goforit = ref false
      val destroyed = ref false
	
      fun drawit _ =
	if not (!destroyed) then
          draw_picture ()
        else ()
	
      fun paint_event _ = (drawit (); NONE)

      fun clearit _ =
	let val hdc = WindowsGui.getDC life
	in (WindowsGui.fillRect (hdc, WindowsGui.RECT {left=0, top=0, right=toplevel_width,
						bottom=toplevel_height}, off_brush);
	    WindowsGui.releaseDC (life, hdc))
  	end

      fun resize_event data = (clearit(); NONE)
  
      val generating = ref false

      fun new_gen () =
	if !generating then () else
	  (generating := true;	
	   state := gen (!state);
	   drawit ();
	   generating := false)

      fun timer _ = 
        if (!goforit) then 
	  new_gen()
        else ()
	
      fun mouse_event event (WindowsGui.WPARAM wparam, WindowsGui.LPARAM lparam) = 
        let 
	  val xPos = WindowsGui.loword(lparam)
	  val yPos = WindowsGui.hiword(lparam)
        in
	  case event of 
	    WindowsGui.WM_LBUTTONDOWN => (
	      let
		val i = xPos div block_size
		val j = yPos div block_size
	      in
		if i >= 0 andalso i < world_x
		  andalso j >= 0 andalso j < world_y
		  then
		    let 
		      val ((a,_,_),_) = !state
		      val current = Array.sub (Array.sub (a,i),j)
		      val new = 1 - current
		    in
		      Array.update (Array.sub (a,i),j,new);
		      if new = 1 
			then draw_image (i*block_size,j*block_size)
		      else clear_image (i*block_size,j*block_size)
		    end
		else ()
	      end)
	  | _ => ();
	  NONE
        end

        val colorcount = ref 0

        fun delay 0 = ()
          | delay n = if n>0 then delay (n-1) else ()

	exception Quit

        fun do_key key = 
	  case key of
	     "x" => (ignore
                     (goforit := false;
		     destroyed := true;
		     WindowsGui.destroyWindow life;
		     raise Quit);
		     ())
	  |  "r" => (state :=init_gen (initvals,world_x,world_y);
		     clearit ();
		     drawit ())
	  |  "s" => (goforit := not (!goforit);
	             if !goforit then new_gen() else ())
	  |   _  => (if not (!goforit) then new_gen () else ())

      fun key_press (WindowsGui.WPARAM wparam, WindowsGui.LPARAM lparam) = 
        (do_key (str (chr (WindowsGui.wordToInt wparam))); NONE)

    in
      ignore (WindowsGui.setTimer (life, 30, timer));
      WindowsGui.addMessageHandler(life, WindowsGui.WM_LBUTTONDOWN, 
				mouse_event WindowsGui.WM_LBUTTONDOWN);  
      WindowsGui.addMessageHandler(life, WindowsGui.WM_PAINT, paint_event);
      WindowsGui.addMessageHandler(life, WindowsGui.WM_SIZE, resize_event); 
      WindowsGui.addMessageHandler(life, WindowsGui.WM_CHAR, key_press);
      WindowsGui.addMessageHandler(life, WindowsGui.WM_CLOSE,
                                   fn _ => (do_key "x";
                                            SOME WindowsGui.nullWord));
      clearit();
      drawit ()
    end;

  fun create (init,x,y) = 
    (state := init;
     make_toplevel (x,y))

in

  val world_x = 121
  val world_y = 37
  
  fun life (vals,x,y) = 
    (create (init_gen (vals,x,y),x,y);
     WindowsGui.mainLoop () handle _ => ())

  fun life_test () = life (initvals, world_x, world_y)

  fun life_appl (vals,x,y) () = 
    (create (init_gen (vals,x,y),x,y);
     WindowsGui.mainLoop () handle _ => WindowsGui.postQuitMessage 0)
 
end

@


1.14
log
@[Bug #30388]
Change Windows to WindowsGui
Also put in ignores to get rid of warnings
@
text
@d6 5
d462 1
a462 1
  fun test () = life (initvals, world_x, world_y)
d464 1
a464 1
  fun appl (vals,x,y) () = 
@


1.13
log
@[Bug #30257]
Generations cannot overlap now, and background is always white.
@
text
@d6 4
d71 1
a71 1
require "$.winsys.__windows";
d241 1
a241 1
        Windows.createWindow {class = class,
d246 1
a246 1
                         menu = Windows.nullWord,
d249 2
a250 2
      Windows.showWindow (window,Windows.SW_SHOWNORMAL);
      Windows.updateWindow window;
d267 1
a267 1
      val applicationShell = Windows.mainInit ()
d271 3
a273 3
			[Windows.WS_OVERLAPPED, 
			 Windows.WS_SYSMENU,
			 Windows.WS_MINIMIZEBOX])
d276 1
a276 1
	val hdc = Windows.getDC life
d278 3
a280 3
	val on_brush = Windows.createSolidBrush (Windows.getTextColor hdc);
	val off_brush = Windows.createSolidBrush (Windows.getBkColor hdc);
	val _ = Windows.releaseDC (life,hdc)
d284 2
a285 2
	let val hdc = Windows.getDC life
	in (Windows.fillRect (hdc,Windows.RECT {left=x+1,top=y+1,right=x + block_size,
d287 1
a287 1
	    Windows.releaseDC (life,hdc))
d291 2
a292 2
	let val hdc = Windows.getDC life
	in (Windows.fillRect (hdc,Windows.RECT {left=x+1,top=y+1,right=x + block_size,
d294 1
a294 1
	    Windows.releaseDC (life,hdc))
d297 1
a297 1
      fun make_rect (x,y) = Windows.RECT {left=lshift (x,size_exp)+1,
d307 1
a307 1
	  val hdc = Windows.getDC life
d310 1
a310 1
		(Windows.fillRect(hdc, rect1, brush); 
d339 1
a339 1
	  Windows.releaseDC (life, hdc)
d353 2
a354 2
	let val hdc = Windows.getDC life
	in (Windows.fillRect (hdc, Windows.RECT {left=0, top=0, right=toplevel_width,
d356 1
a356 1
	    Windows.releaseDC (life, hdc))
d375 1
a375 1
      fun mouse_event event (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
d377 2
a378 2
	  val xPos = Windows.loword(lparam)
	  val yPos = Windows.hiword(lparam)
d381 1
a381 1
	    Windows.WM_LBUTTONDOWN => (
d414 2
a415 1
	     "x" => (goforit := false;
d417 2
a418 2
		     Windows.destroyWindow life;
		     raise Quit;
d427 2
a428 2
      fun key_press (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
        (do_key (str (chr (Windows.wordToInt wparam))); NONE)
d431 7
a437 7
      Windows.setTimer (life, 30, timer);
      Windows.addMessageHandler(life, Windows.WM_LBUTTONDOWN, 
				mouse_event Windows.WM_LBUTTONDOWN);  
      Windows.addMessageHandler(life, Windows.WM_PAINT, paint_event);
      Windows.addMessageHandler(life, Windows.WM_SIZE, resize_event); 
      Windows.addMessageHandler(life, Windows.WM_CHAR, key_press);
      Windows.addMessageHandler(life, Windows.WM_CLOSE,
d439 1
a439 1
                                            SOME Windows.nullWord));
d455 1
a455 1
     Windows.mainLoop () handle _ => ())
d461 1
a461 1
     Windows.mainLoop () handle _ => Windows.postQuitMessage 0)
@


1.13.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 4
 *  Revision 1.13  1997/08/28  08:50:48  johnh
 *  [Bug #30257]
 *  Generations cannot overlap now, and background is always white.
 *
@


1.12
log
@[Bug #30130]
Made a delivered life work properly and removed some fns from users view.
@
text
@d6 4
d357 2
d360 5
a364 2
	(state := gen (!state);
	 drawit ())
d435 1
@


1.11
log
@[Bug #30130]
Stopped mainLoop from looping in the event of an exception.
Added a "destroyed" flag to prevent the timer attempting to draw in the
window after it has been destroyed.  Removed code that was creating bogus
new generations.  Ensured that the initial state is always drawn.
A little tidying up.
@
text
@d6 8
d72 14
a202 14
  val gunvals =
    [(2,20),(3,19),(3,21),(4,18),
     (4,22),(4,23),(4,32),(5,7),
     (5,8),(5,18),(5,22),(5,23),
     (5,29),(5,30),(5,31),(5,32),
     (5,36),(6,7),(6,8),(6,18),
     (6,22),(6,23),(6,28),(6,29),
     (6,30),(6,31),(6,36),(7,19),
     (7,21),(7,28),(7,31),(7,42),
     (7,41),(8,20),(8,28),(8,29),
     (8,30),(8,31),(8,42),(8,41),
     (9,29),(9,30),(9,31),(9,32)
     ]
    
a245 2
in

a349 1
	
d397 2
a402 1
  		     Windows.postQuitMessage 0;
d404 1
d423 1
a423 1
      Windows.addMessageHandler (life,Windows.WM_CLOSE,
d426 1
a426 2
      drawit ();
      Windows.mainLoop () handle _ => ()
d432 3
a434 1
    
d438 4
a441 1
  fun life (vals,x,y) = create (init_gen (vals,x,y),x,y)
d443 4
@


1.10
log
@[Bug #30127]
Merging changes from 1.0r2c1 into 2.0m0
@
text
@d6 4
d299 1
a299 1
	  Array.appi
d329 1
d332 3
a334 6
	(draw_picture ();
	 if !goforit
	   then
	     (state := gen (!state);
	      draw_picture ())
	 else ())
d336 1
a336 3
      val draw_picture = drawit 
	
      fun paint_event _ = (draw_picture (); NONE)
d343 1
a343 1
	end
a391 2
        val ok = ref true;

d394 3
a396 1
	     "x" => (Windows.postQuitMessage 0;
d400 2
a401 1
		     clearit ())
d404 1
a404 1
	  |   _  => (new_gen (); ())
a408 11
      fun mainLoop () =
        let
          val loop =
	    (Windows.mainLoop (); false)
  	    (* normal return, don't loop *)
	    handle 
              MLWorks.Interrupt => true	(* interrupt, continue *)
            | exn => true
        in
          if loop then mainLoop () else ()
        end
d419 2
a420 2
      mainLoop ()
    
d432 1
a432 1

@


1.9
log
@Solving the resize problem.
@
text
@d3 1
a3 1
 *  Copyright (C) 1996 Harlequin Ltd
d6 15
a25 1
 *  [Bug #2039]
a35 1
 *  [Bug #1823]
@


1.8
log
@Remove references to MLWorks.Internal and tidy the messy code.
@
text
@d6 3
d230 1
a230 1
	
d240 3
a242 1
			[Windows.WS_OVERLAPPED_WINDOW])
a330 2
	  
      fun resize_event data = (clearit (); NONE)
d332 3
@


1.8.1.1
log
@branched from 1.8
@
text
@a5 3
 *  Revision 1.8  1997/04/11  09:22:53  johnh
 *  Remove references to MLWorks.Internal and tidy the messy code.
 *
@


1.8.1.2
log
@[Bug #20009]
Making the demo unresizable.
@
text
@a5 6
 *  Revision 1.8.1.1  1997/05/12  10:24:52  hope
 *  branched from 1.8
 *
 *  Revision 1.9  1997/05/14  13:43:52  johnh
 *  Solving the resize problem.
 *
d230 1
a230 1

d240 1
a240 3
			[Windows.WS_OVERLAPPED, 
			 Windows.WS_SYSMENU,
			 Windows.WS_MINIMIZEBOX])
d329 2
a331 3

      fun resize_event data = (clearit(); NONE)
  
@


1.8.1.3
log
@[Bug #30127]
Updated copyright.
@
text
@d3 1
a3 1
 *  Copyright (C) 1997 The Harlequin Group Limited.  All rights reserved.
a5 4
 *  Revision 1.8.1.2  1997/05/15  08:47:06  daveb
 *  [Bug #20009]
 *  Making the demo unresizable.
 *
d17 1
d28 1
@


1.8.1.3.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 4
 *  Revision 1.8.1.3  1997/05/15  13:22:08  daveb
 *  [Bug #30127]
 *  Updated copyright.
 *
@


1.8.1.3.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 4
 *  Revision 1.8.1.3  1997/05/15  13:22:08  daveb
 *  [Bug #30127]
 *  Updated copyright.
 *
@


1.8.1.3.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 4
 *  Revision 1.8.1.3  1997/05/15  13:22:08  daveb
 *  [Bug #30127]
 *  Updated copyright.
 *
@


1.8.1.3.1.2
log
@[Bug #30130]
Merging - see revision 1.11 below.
@
text
@a5 12
 *
 *  Revision 1.8.1.3.1.1  1997/07/28  18:10:50  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
 *  Revision 1.11  1997/08/05  14:45:45  daveb
 *  [Bug #30130]
 *  Stopped mainLoop from looping in the event of an exception.
 *  Added a "destroyed" flag to prevent the timer attempting to draw in the
 *  window after it has been destroyed.  Removed code that was creating bogus
 *  new generations.  Ensured that the initial state is always drawn.
 *  A little tidying up.
 *
d294 1
a294 1
          Array.appi
a323 1
      val destroyed = ref false
d326 8
a333 3
	if not (!destroyed) then
          draw_picture ()
        else ()
d335 1
a335 1
      fun paint_event _ = (drawit (); NONE)
d342 1
a342 1
  	end
d391 2
d395 1
a395 3
	     "x" => (goforit := false;
		     destroyed := true;
  		     Windows.postQuitMessage 0;
d399 1
a399 2
		     clearit ();
		     drawit ())
d402 1
a402 1
	  |   _  => (if not (!goforit) then new_gen () else ())
d407 11
d428 2
a429 2
      drawit ();
      Windows.mainLoop () handle _ => ()
d441 1
a441 1
 
@


1.8.1.3.1.3
log
@[Bug #30130]
Merging - Only call Windows.postQuitMessage when delivered.
@
text
@a6 4
 *  Revision 1.8.1.3.1.2  1997/08/05  14:45:47  johnh
 *  [Bug #30130]
 *  Merging - see revision 1.11 below.
 *
a70 14
val gunvals =
  [(2,20),(3,19),(3,21),(4,18),
   (4,22),(4,23),(4,32),(5,7),
   (5,8),(5,18),(5,22),(5,23),
   (5,29),(5,30),(5,31),(5,32),
   (5,36),(6,7),(6,8),(6,18),
   (6,22),(6,23),(6,28),(6,29),
   (6,30),(6,31),(6,36),(7,19),
   (7,21),(7,28),(7,31),(7,42),
   (7,41),(8,20),(8,28),(8,29),
   (8,30),(8,31),(8,42),(8,41),
   (9,29),(9,30),(9,31),(9,32)
   ]
    
d188 14
d245 2
d351 1
a398 2
	exception Quit

d403 1
a404 1
		     raise Quit;
d423 1
a423 1
      Windows.addMessageHandler(life, Windows.WM_CLOSE,
d426 2
a427 1
      drawit ()
d433 1
a433 3

in

d437 1
a437 4
  fun life (vals,x,y) = 
    (create (init_gen (vals,x,y),x,y);
     Windows.mainLoop () handle _ => ())

a438 4

  fun appl (vals,x,y) () = 
    (create (init_gen (vals,x,y),x,y);
     Windows.mainLoop () handle _ => Windows.postQuitMessage 0)
@


1.8.1.3.1.4
log
@[Bug #30257]
Merging - Generations cannot overlap now, and background is always white.
@
text
@a5 3
 *  Revision 1.8.1.3.1.3  1997/08/06  16:14:12  johnh
 *  [Bug #30130]
 *  Merging - Only call Windows.postQuitMessage when delivered.
a355 2
      val generating = ref false

d357 2
a358 5
	if !generating then () else
	  (generating := true;	
	   state := gen (!state);
	   drawit ();
	   generating := false)
a428 1
      clearit();
@


1.8.1.3.1.4.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 4
 *  Revision 1.8.1.3.1.4  1997/08/28  09:06:16  johnh
 *  [Bug #30257]
 *  Merging - Generations cannot overlap now, and background is always white.
 *
@


1.7
log
@[Bug #2039]
[Bug #2039]
Removed use of Threads.  Also changed handler for WM_DESTROY to WM_CHANGE.
@
text
@d6 5
d41 2
d45 1
a46 14
  datatype WidgetClass = Frame | Graphics | Label | Text | RowColumn | Paned | Form 

  structure Option = MLWorks.Option;
  structure Array = MLWorks.Internal.Array

  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)

  structure Array = MLWorks.Internal.Array
  structure ExtendedArray = MLWorks.Internal.ExtendedArray
  structure Bits = MLWorks.Internal.Bits
  open MLWorks.IO
in    
  fun P s = output (std_out, s ^ "\n")
    
d48 1
a48 1
  val block_size = Bits.lshift (1,size_exp)
d191 1
a191 1
   fun munge_string s =
d202 1
a202 1
  fun set_gui_font window =
d204 8
a211 5
      val Windows.OBJECT gui_font =
	Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
	handle
	  Windows.WindowSystemError _ => 
	    Windows.getStockObject (Windows.ANSI_VAR_FONT)
d213 3
a215 23
      Windows.sendMessage
        (window,
         Windows.WM_SETFONT,
         Windows.WPARAM gui_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

  fun convert_class class =
    case class of
      Label => ("STATIC",[Windows.SS_LEFT])
    | Text => ("EDIT",[Windows.WS_BORDER])
    | _ => ("Frame",[]) (* A class of my own devising *)

  fun set_text (window,s) =
    let
      val string_word = Windows.makeCString (munge_string s)
    in
      Windows.sendMessage (window,Windows.WM_SETTEXT,
                            Windows.WPARAM (Windows.nullWord),
                            Windows.LPARAM string_word);
      Windows.free string_word
d218 1
a218 3
  fun reveal window =
    (Windows.showWindow (window,Windows.SW_SHOWNORMAL);
     Windows.updateWindow window)
a219 40
  fun set_text_font window =
    let
      val Windows.OBJECT text_font =
	Windows.getStockObject (Windows.ANSI_FIXED_FONT)
    in
      Windows.sendMessage
        (window,
         Windows.WM_SETFONT,
         Windows.WPARAM text_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

  fun class_postaction (window,class) =
    case class of
      Text =>
	(set_text_font window;
         set_text (window, ""))
    | Label => set_gui_font window
    | _ => ()

  fun create_revealed args =
    let
      val window = Windows.createWindow args
    in
      reveal window;
      window
    end

  fun class_height class =
    case class of
      Frame => 120
    | Graphics => 120
    | Label => 20
    | Text => 25
    | RowColumn => 30
    | Paned => 120
    | Form => 120
    
d222 1
a222 1
     val title = "test"
d228 4
a231 4
    val default_width = xextent
    val toplevel_width = default_width + 10
    val graphics_height = yextent
    val toplevel_height = graphics_height + 34
d233 1
d235 1
a235 47
  fun make_managed_widget (name,class,parent,height,width,attributes) = 
    let
      val (class_name,styles) = convert_class class
      val window =
        create_revealed {class = class_name,
                         name = name,
                         width = width,
                         height = height,
                         parent = parent,
                         menu = Windows.nullWord,
                         styles = (* [Windows.WS_CHILD] @@ *) 
				styles @@ attributes}

    in
      class_postaction (window,class);
      window
    end

  fun make_message_text (name,parent,attributes) =
    let
      val window =
        create_revealed
        {class = "EDIT",
         name = name,
         width = default_width,
         height = 200,
         parent = parent,
         menu = Windows.nullWord,
         styles = [Windows.WS_CHILD,
                   Windows.WS_BORDER,
                   Windows.WS_HSCROLL,Windows.WS_VSCROLL,
                   Windows.ES_READONLY,
                   Windows.ES_MULTILINE,
                   Windows.ES_AUTOHSCROLL,Windows.ES_AUTOVSCROLL]}
    in
      set_text_font window;
      set_text (window,"");
      (window,window)
    end

      val window = Windows.mainInit ()
      val applicationShell = window

  val mainWindow = applicationShell
  val menuBar = applicationShell

  val lifeWindow = make_managed_widget ("Life", Form, applicationShell, 
a237 9
  val life = lifeWindow
  val _ = Windows.showWindow (life, Windows.SW_SHOWDEFAULT)

  val (scroll,message) = make_message_text ("message",mainWindow,[]);
  val _ = Windows.showWindow (scroll, Windows.SW_HIDE);
  val no_message_widget : unit -> unit = env "nt no message widget"
  val set_message_window : Windows.hwnd -> unit = env "nt set message widget"

  fun set_message_widget widget = set_message_window widget
d239 1
a239 6
  fun start_messages () = set_message_widget message
  fun stop_messages () = no_message_widget ()

  val _ = start_messages ()

    local 
d241 1
a241 1
    in 
d245 1
a245 1
    end
d261 4
a264 5
	
      fun make_rect (x,y) = Windows.RECT {left=Bits.lshift (x,size_exp)+1,
					  top=Bits.lshift (y,size_exp)+1,
					  right=(Bits.lshift (x,size_exp)+1)+ block_size,
					  bottom=(Bits.lshift (y,size_exp)+1) +block_size}
d277 1
a277 1
	  ExtendedArray.iterate_index
d300 1
a300 1
	  gen1;
d318 1
a318 1
      fun paint_event _ = (draw_picture (); Option.NONE)
d327 1
a327 1
      fun resize_event data = (clearit (); Option.NONE)
d332 13
a344 8
	
    fun mouse_event event (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
      let 
	val xPos = Windows.loword(lparam)
	val yPos = Windows.hiword(lparam)
      in
	(case event of 
	  Windows.WM_LBUTTONDOWN => (
d364 40
a403 41
	| _ => ();
	Option.NONE)
      end

      val colorcount = ref 0

      fun P s = MLWorks.IO.output (MLWorks.IO.terminal_out,s)
      fun delay 0 = ()
        | delay n = if n>0 then delay (n-1) else ()

      val ok = ref true;

      fun do_key key = 
	case key of
	   "x" => (stop_messages ();
		   Windows.postQuitMessage 0;
		   Windows.destroyWindow life;
		   ())
	|  "r" => (state :=init_gen (initvals,world_x,world_y);
		   clearit ())
	|  "s" => (goforit := not (!goforit);
	           if !goforit then new_gen() else ())
	|   _  => (new_gen (); ())
	

    fun key_press (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
      (do_key (str (chr (Windows.wordToInt wparam))); Option.NONE)

    fun mainLoop () =
      let
        val loop =
	  (Windows.mainLoop (); false)
  	  (* normal return, don't loop *)
	  handle 
            MLWorks.Interrupt => true	(* interrupt, continue *)
          | exn => true
      in
        if loop then mainLoop () else stop_messages () 
      end
    in
      Windows.addMessageHandler(life, Windows.WM_LBUTTONDOWN, mouse_event Windows.WM_LBUTTONDOWN);  
d409 1
a409 1
                                            Option.SOME Windows.nullWord));
a413 1

a420 1
  fun test () =  create (init_gen (initvals,world_x,world_y), world_x,world_y)
d422 1
@


1.6
log
@[Bug #1757]
renamed __ieeereal
@
text
@d6 4
a40 1
  structure Threads = MLWorks.Threads
d287 1
a287 1
      val title = "test"
d438 1
a438 7
	      draw_picture ()
(*		;let val dc = Windows.getDC life
		in (Windows.fillRect(dc, Windows.RECT {left=0, top=0,
			right=toplevel_width, bottom=toplevel_height}, off_brush);
		    Windows.releaseDC (life, dc))
		end  *)
		)
a493 2
      val _ = Threads.Internal.Preemption.set_interval 100;

a495 4
      fun delay_fun n = (ok := false; delay n; 
			Threads.Internal.Preemption.stop ();
			ok := true)

d499 3
a501 2
		  Windows.postQuitMessage 0;
		  Windows.destroyWindow life;())
d506 1
a506 1
	|   _  => (new_gen ();())
d512 1
a512 1
    fun mainLoop frame =
d514 1
a514 1
	val loop =
d516 1
a516 1
	  (* normal return, don't loop *)
d518 1
a518 1
          MLWorks.Interrupt => true	(* interrupt, continue X interface *)
d521 1
a521 1
	    if loop then mainLoop frame else stop_messages() 
a522 1

d524 1
a524 1
      Windows.addMessageHandler(life, Windows.WM_LBUTTONDOWN, mouse_event Windows.WM_LBUTTONDOWN);
d526 1
a526 1
      Windows.addMessageHandler(life, Windows.WM_SIZE, resize_event);
d528 6
a533 4
      Windows.addMessageHandler (life,Windows.WM_DESTROY,
                                   fn _ => (stop_messages ();
					    Windows.postQuitMessage 0;
                                            Option.NONE));
a534 1
      Threads.fork mainLoop ()
a535 2
    end;
    
a539 2
(*  fun runx () = mainLoop ()*)

a544 3
(*   fun appl () = (test (); runx ())*)

val _ = test ()
@


1.5
log
@Removed some test code.
@
text
@d6 3
d31 1
a31 1
require "$.basis.__ieeereal";
@


1.5.1.1
log
@branched from 1.5
@
text
@a5 3
 *  Revision 1.5  1996/12/06  11:13:25  johnh
 *  Removed some test code.
 *
@


1.5.1.1.1.1
log
@branched from 1.5.1.1
@
text
@a5 3
 *  Revision 1.5.1.1  1996/12/17  17:39:52  hope
 *  branched from 1.5
 *
@


1.4
log
@[Bug #1823]
[Bug #1823]
Removing references to capitypes and labelstrings.
@
text
@d6 5
d491 1
a491 1
      fun delay 0 = P "finished delay!\n"
a506 19
	|  "l" => (if !ok then (P "started\n";
			if (Threads.Internal.Preemption.on ()) then
				Threads.Internal.Preemption.stop ()
				else ();
			Threads.fork delay_fun 131231313;
			Threads.Internal.Preemption.start ())
		   else ();
		   ())

	|  "t" => (colorcount := !colorcount + 100;
		   P ((Int.toString (!colorcount)) ^ "\n");
		   let val dc = Windows.getDC life
		       val the_brush = Windows.createSolidBrush 
				(Windows.COLOR (Windows.intToWord (!colorcount)))
		       val the_rect = Windows.RECT {left=0, top=0, right=50, bottom=50}
		   in
		     (Windows.fillRect(dc, the_rect, the_brush);
		      Windows.releaseDC (life,dc))
		   end;())
d539 1
a539 2
      Threads.fork mainLoop ();
	P "finished!\n"
@


1.3
log
@Removing redundant references to structure Windows_
@
text
@d1 574
a574 582
(*  ==== Life demo  ====
 *
 *  Copyright (C) 1996 Harlequin Ltd
 *
 * $Log: mswindows:life.sml,v $
 *  Revision 1.1  1996/10/11  14:10:15  johnh
 *  new unit
 *  Reorganised demo directory to include separate demos for mswindows and motif.
 *
 *
 *)

require "forms";

require "$.mswindows.__windows";
require "$.mswindows.__capitypes";
require "$.mswindows.__labelstrings";
require "$.basis.__int"; 
require "$.basis.__real";
require "$.basis.__string";
require "$.basis.__text_io";
require "$.basis.__ieeereal";

local

  datatype WidgetClass = Frame | Graphics | Label | Text | RowColumn | Paned | Form 

  structure Threads = MLWorks.Threads
  structure CapiTypes = CapiTypes_ ;
  structure LabelStrings = LabelStrings_; 
  structure Option = MLWorks.Option;
  structure Array = MLWorks.Internal.Array

  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)

  structure Array = MLWorks.Internal.Array
  structure ExtendedArray = MLWorks.Internal.ExtendedArray
  structure Bits = MLWorks.Internal.Bits
  open MLWorks.IO
in    
  fun P s = output (std_out, s ^ "\n")
    
  val size_exp = 3
  val block_size = Bits.lshift (1,size_exp)
    
  fun max (x:int,y) = if x > y then x else y
  fun min (x:int,y) = if x < y then x else y
    
  fun make_gen (n,m) =
    (Array.tabulate (n, fn _ => Array.array (m,0)),
     n,
     m)
    
  fun sub ((array,n,m),i,j) =
    if i < 0 then 0
    else if j < 0 then 0
    else if i >= n then 0
    else if j >= m then 0
	 else Array.sub (Array.sub (array,i),j)
	   
  fun mymod (i,n) =
    if i < 0 then mymod (i+n,n)
    else if i >= n then mymod (i-n,n)
	 else i
	   
  fun update ((array,n,m),i,j,x:int) =
    Array.update (Array.sub (array,mymod (i,n)),mymod (j,m),x)
    
  fun calc_val (array,i,j) =
    sub (array,i-1,j-1) +
    sub (array,i-1,j) +
    sub (array,i-1,j+1) +
    sub (array,i,j-1) +
    sub (array,i,j+1) +
    sub (array,i+1,j-1) +
    sub (array,i+1,j) +
    sub (array,i+1,j+1)
    
  fun calc_val ((a,n,m),i,j) : int =
    let
      val lix = if j = 0 then m-1 else j-1
      val mix = j
      val rix = if j = m-1 then 0 else j+1
      val top_row = Array.sub (a,if i=0 then n-1 else i-1)
      val mid_row = Array.sub (a,i)
      val bottom_row = Array.sub (a,if i = n-1 then 0 else i+1)
    in
      Array.sub (top_row,lix) +
      Array.sub (top_row,mix) +
      Array.sub (top_row,rix) +
      Array.sub (mid_row,lix) +
      Array.sub (mid_row,rix) +
      Array.sub (bottom_row,lix) +
      Array.sub (bottom_row,mix) +
      Array.sub (bottom_row,rix)
    end
  
  fun new (ina,i,j,outa) =
    let
      val newval =
	case calc_val (ina,i,j) of
	  2 => sub (ina,i,j)
	| 3 => 1
	| _ => 0
    in
      update (outa,i,j,newval)
    end
  
  fun clean (a,n,m) =
    let
      fun loop1 i =
	if i = n
	  then ()
	else
	  let
	    val suba = Array.sub (a,i)
	    fun loop2 j =
	      if j = m then ()
	      else 
		(Array.update (suba,j,0);
		 loop2 (j+1))
	  in
	    loop2 0;
	    loop1 (i+1)
	  end
    in
      loop1 0
    end
  
  fun gen (ina as (_,n,m),outa) =
    let
      fun loop1 i =
	if i = n
	  then ()
	else
	  let
	    fun loop2 j =
	      if j = m then ()
	      else 
		(new (ina,i,j,outa);
		 loop2 (j+1))
	  in
	    loop2 0;
	    loop1 (i+1)
	  end
    in
      clean outa;
      loop1 0;
      (outa,ina)
    end
  
  fun set (a,[]) = ()
    | set (a,(i,j)::rest) =
      (update (a,i,j,1);
       set (a,rest))
      
  val gunvals =
    [(2,20),(3,19),(3,21),(4,18),
     (4,22),(4,23),(4,32),(5,7),
     (5,8),(5,18),(5,22),(5,23),
     (5,29),(5,30),(5,31),(5,32),
     (5,36),(6,7),(6,8),(6,18),
     (6,22),(6,23),(6,28),(6,29),
     (6,30),(6,31),(6,36),(7,19),
     (7,21),(7,28),(7,31),(7,42),
     (7,41),(8,20),(8,28),(8,29),
     (8,30),(8,31),(8,42),(8,41),
     (9,29),(9,30),(9,31),(9,32)
     ]
    
  fun move (a:int,b:int) l = map (fn (x,y) => (x+a,y+b)) l
    
  val initvals = move (10,10) crash
    
  fun init_gen (initvals,world_x,world_y) = 
    let
      val (a1,a2) = (make_gen (world_x,world_y),make_gen (world_x,world_y))
      val _ = set (a1,initvals)
    in
      (a1,a2)
    end
  
  val state = ref (make_gen (0,0),make_gen (0,0))
    
  (* Windows stuff *)

   fun munge_string s =
    let
      fun munge ([],acc) = MLWorks.String.implode (rev acc)
        | munge ("\013" :: "\010" :: rest,acc) =
          munge (rest, "\010" :: "\013" :: acc)
        | munge ("\n"::rest,acc) = munge (rest,"\013\010" :: acc)
        | munge (c::rest,acc) = munge (rest,c::acc)
    in
      munge (MLWorks.String.explode s,[])
    end

  fun set_gui_font window =
    let
      val Windows.OBJECT gui_font =
	Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
	handle
	  Windows.WindowSystemError _ => 
	    Windows.getStockObject (Windows.ANSI_VAR_FONT)
    in
      Windows.sendMessage
        (CapiTypes.get_real window,
         Windows.WM_SETFONT,
         Windows.WPARAM gui_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

  fun convert_class class =
    case class of
      Label => ("STATIC",[Windows.SS_LEFT])
    | Text => ("EDIT",[Windows.WS_BORDER])
    | _ => ("Frame",[]) (* A class of my own devising *)

  fun set_text (window,s) =
    let
      val string_word = Windows.makeCString (munge_string s)
    in
      Windows.sendMessage (CapiTypes.get_real window,Windows.WM_SETTEXT,
                            Windows.WPARAM (Windows.nullWord),
                            Windows.LPARAM string_word);
      Windows.free string_word
    end

  fun reveal window =
    (Windows.showWindow (window,Windows.SW_SHOWNORMAL);
     Windows.updateWindow window)

  fun set_text_font window =
    let
      val Windows.OBJECT text_font =
	Windows.getStockObject (Windows.ANSI_FIXED_FONT)
    in
      Windows.sendMessage
        (CapiTypes.get_real window,
         Windows.WM_SETFONT,
         Windows.WPARAM text_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

  fun class_postaction (window,class) =
    case class of
      Text =>
	(set_text_font window;
         set_text (window, ""))
    | Label => set_gui_font window
    | _ => ()

  fun create_revealed args =
    let
      val window = Windows.createWindow args
    in
      reveal window;
      window
    end

  fun convert_name (Label,name) = LabelStrings.get_label name
    | convert_name (_,name) = LabelStrings.get_title name

  fun class_height class =
    case class of
      Frame => 120
    | Graphics => 120
    | Label => 20
    | Text => 25
    | RowColumn => 30
    | Paned => 120
    | Form => 120
    
  fun make_toplevel (world_x,world_y) =
    let
      val title = "test"
	
      (*  The extent of the drawing area *)
      val xextent = world_x * block_size
      val yextent = world_y * block_size
	
    val default_width = xextent
    val toplevel_width = default_width + 10
    val graphics_height = yextent
    val toplevel_height = graphics_height + 34
  

  fun make_managed_widget (name,class,parent,height,width,attributes) = 
    let
      val (class_name,styles) = convert_class class
      val window =
        create_revealed {class = class_name,
                         name = convert_name (class,name),
                         width = width,
                         height = height,
                         parent = CapiTypes.get_real parent,
                         menu = Windows.nullWord,
                         styles = (* [Windows.WS_CHILD] @@ *) 
				styles @@ attributes}

      val widget = CapiTypes.REAL (window,parent)

    in
      class_postaction (widget,class);
      widget
    end

  fun make_message_text (name,parent,attributes) =
    let
      val window =
        create_revealed
        {class = "EDIT",
         name = LabelStrings.get_title name,
         width = default_width,
         height = 200,
         parent = CapiTypes.get_real parent,
         menu = Windows.nullWord,
         styles = [Windows.WS_CHILD,
                   Windows.WS_BORDER,
                   Windows.WS_HSCROLL,Windows.WS_VSCROLL,
                   Windows.ES_READONLY,
                   Windows.ES_MULTILINE,
                   Windows.ES_AUTOHSCROLL,Windows.ES_AUTOVSCROLL]}
      val widget = CapiTypes.REAL (window,parent)
    in
      set_text_font widget;
      set_text (widget,"");
      (widget,widget)
    end

      val window = Windows.mainInit ()
      val applicationShell = CapiTypes.REAL (window, CapiTypes.NONE)

  val mainWindow = applicationShell
  val menuBar = applicationShell

  val lifeWindow = make_managed_widget ("Life", Form, applicationShell, 
			toplevel_height, toplevel_width,
			[Windows.WS_OVERLAPPED_WINDOW])
  val life = CapiTypes.get_real lifeWindow
  val _ = Windows.showWindow (life, Windows.SW_SHOWDEFAULT)

  val (scroll,message) = make_message_text ("message",mainWindow,[]);
  val _ = Windows.showWindow (CapiTypes.get_real scroll, Windows.SW_HIDE);
  val no_message_widget : unit -> unit = env "nt no message widget"
  val set_message_window : CapiTypes.Hwnd -> unit = env "nt set message widget"

  fun set_message_widget widget =
    set_message_window (CapiTypes.get_real widget)

  fun start_messages () = set_message_widget message
  fun stop_messages () = no_message_widget ()

  val _ = start_messages ()

    local 
	val hdc = Windows.getDC life
    in 
	val on_brush = Windows.createSolidBrush (Windows.getTextColor hdc);
	val off_brush = Windows.createSolidBrush (Windows.getBkColor hdc);
	val _ = Windows.releaseDC (life,hdc)
    end

      fun draw_image (x,y) = 
	let val hdc = Windows.getDC life
	in (Windows.fillRect (hdc,Windows.RECT {left=x+1,top=y+1,right=x + block_size,
				bottom=y + block_size}, on_brush);
	    Windows.releaseDC (life,hdc))
	end
	
      fun clear_image (x,y) =
	let val hdc = Windows.getDC life
	in (Windows.fillRect (hdc,Windows.RECT {left=x+1,top=y+1,right=x + block_size,
				bottom=y + block_size}, off_brush);
	    Windows.releaseDC (life,hdc))
	end

	
      fun make_rect (x,y) = Windows.RECT {left=Bits.lshift (x,size_exp)+1,
					  top=Bits.lshift (y,size_exp)+1,
					  right=(Bits.lshift (x,size_exp)+1)+ block_size,
					  bottom=(Bits.lshift (y,size_exp)+1) +block_size}
	
      fun draw_picture _ =
	let
	  val ((gen1,_,_),(gen2,_,_)) = !state
	  val on_rects = ref []
	  val off_rects = ref []
	  val hdc = Windows.getDC life
	  fun fill_rects (brush, []) = ()
	    | fill_rects (brush, (rect1::rest)) = 
		(Windows.fillRect(hdc, rect1, brush); 
		 fill_rects (brush, rest))
	in
	  ExtendedArray.iterate_index
	  (fn (i,a) =>
	   let
	     val max = Array.length a
	     val a2 = Array.sub (gen2,i)
	     fun loop j = 
	       if j = max then ()
	       else
		 let
		   val n = Array.sub (a,j)
		 in
		   if n = 1 then 
		     on_rects := make_rect (i,j) :: !on_rects
		   else
		     if n = Array.sub (a2,j)
		       then ()
		     else
		       off_rects := make_rect (i,j) :: !off_rects;
		       loop (j+1)
		 end
	   in
	     loop 0
	   end)
	  gen1;
	  fill_rects (off_brush,!off_rects);
	  fill_rects (on_brush, !on_rects);
	  Windows.releaseDC (life, hdc)
	end
      
      val goforit = ref false
	
      fun drawit _ =
	(draw_picture ();
	 if !goforit
	   then
	     (state := gen (!state);
	      draw_picture ()
(*		;let val dc = Windows.getDC life
		in (Windows.fillRect(dc, Windows.RECT {left=0, top=0,
			right=toplevel_width, bottom=toplevel_height}, off_brush);
		    Windows.releaseDC (life, dc))
		end  *)
		)
	 else ())
	
      val draw_picture = drawit 
	
      fun paint_event _ = (draw_picture (); Option.NONE)

      fun clearit _ =
	let val hdc = Windows.getDC life
	in (Windows.fillRect (hdc, Windows.RECT {left=0, top=0, right=toplevel_width,
						bottom=toplevel_height}, off_brush);
	    Windows.releaseDC (life, hdc))
	end
	  
      fun resize_event data = (clearit (); Option.NONE)
	
      fun new_gen () =
	(state := gen (!state);
	 drawit ())
	
    fun mouse_event event (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
      let 
	val xPos = Windows.loword(lparam)
	val yPos = Windows.hiword(lparam)
      in
	(case event of 
	  Windows.WM_LBUTTONDOWN => (
	      let
		val i = xPos div block_size
		val j = yPos div block_size
	      in
		if i >= 0 andalso i < world_x
		  andalso j >= 0 andalso j < world_y
		  then
		    let 
		      val ((a,_,_),_) = !state
		      val current = Array.sub (Array.sub (a,i),j)
		      val new = 1 - current
		    in
		      Array.update (Array.sub (a,i),j,new);
		      if new = 1 
			then draw_image (i*block_size,j*block_size)
		      else clear_image (i*block_size,j*block_size)
		    end
		else ()
	      end)
	| _ => ();
	Option.NONE)
      end

      val colorcount = ref 0

      fun P s = MLWorks.IO.output (MLWorks.IO.terminal_out,s)
      fun delay 0 = P "finished delay!\n"
        | delay n = if n>0 then delay (n-1) else ()

      val _ = Threads.Internal.Preemption.set_interval 100;

      val ok = ref true;

      fun delay_fun n = (ok := false; delay n; 
			Threads.Internal.Preemption.stop ();
			ok := true)

      fun do_key key = 
	case key of
	   "x" => (stop_messages ();
		  Windows.postQuitMessage 0;
		  Windows.destroyWindow life;())
	|  "l" => (if !ok then (P "started\n";
			if (Threads.Internal.Preemption.on ()) then
				Threads.Internal.Preemption.stop ()
				else ();
			Threads.fork delay_fun 131231313;
			Threads.Internal.Preemption.start ())
		   else ();
		   ())

	|  "t" => (colorcount := !colorcount + 100;
		   P ((Int.toString (!colorcount)) ^ "\n");
		   let val dc = Windows.getDC life
		       val the_brush = Windows.createSolidBrush 
				(Windows.COLOR (Windows.intToWord (!colorcount)))
		       val the_rect = Windows.RECT {left=0, top=0, right=50, bottom=50}
		   in
		     (Windows.fillRect(dc, the_rect, the_brush);
		      Windows.releaseDC (life,dc))
		   end;())
	|  "r" => (state :=init_gen (initvals,world_x,world_y);
		   clearit ())
	|  "s" => (goforit := not (!goforit);
	           if !goforit then new_gen() else ())
	|   _  => (new_gen ();())
	

    fun key_press (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
      (do_key (str (chr (Windows.wordToInt wparam))); Option.NONE)

    fun mainLoop frame =
      let
	val loop =
	  (Windows.mainLoop (); false)
	  (* normal return, don't loop *)
	  handle 
          MLWorks.Interrupt => true	(* interrupt, continue X interface *)
          | exn => true
      in
	    if loop then mainLoop frame else stop_messages() 
      end

    in
      Windows.addMessageHandler(life, Windows.WM_LBUTTONDOWN, mouse_event Windows.WM_LBUTTONDOWN);
      Windows.addMessageHandler(life, Windows.WM_PAINT, paint_event);
      Windows.addMessageHandler(life, Windows.WM_SIZE, resize_event);
      Windows.addMessageHandler(life, Windows.WM_CHAR, key_press);
      Windows.addMessageHandler (life,Windows.WM_DESTROY,
                                   fn _ => (stop_messages ();
					    Windows.postQuitMessage 0;
                                            Option.NONE));

      Threads.fork mainLoop ();
	P "finished!\n"

    end;
    
  fun create (init,x,y) = 
    (state := init;
     make_toplevel (x,y))
    
(*  fun runx () = mainLoop ()*)

  val world_x = 121
  val world_y = 37
  
  fun test () =  create (init_gen (initvals,world_x,world_y), world_x,world_y)
  fun life (vals,x,y) = create (init_gen (vals,x,y),x,y)
(*   fun appl () = (test (); runx ())*)

val _ = test ()

end

@


1.3.2.1
log
@branched from 1.3
@
text
@d5 1
a5 4
 * $Log: mswindows:life.sml,v $
 *  Revision 1.3  1996/11/07  19:02:30  jkbrook
 *  Removing redundant references to structure Windows_
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@d5 1
a5 4
 * $Log: mswindows:life.sml,v $
 *  Revision 1.3  1996/11/07  19:02:30  jkbrook
 *  Removing redundant references to structure Windows_
 *
@


1.3.1.1.1.1
log
@branched from 1.3.1.1
@
text
@a5 3
 *  Revision 1.3.1.1  1996/11/14  12:40:31  hope
 *  branched from 1.3
 *
@


1.2
log
@[Bug #1728]
__integer becomes __int
@
text
@d1 582
a582 583
(*  ==== Life demo  ====
 *
 *  Copyright (C) 1996 Harlequin Ltd
 *
 * $Log: mswindows:life.sml,v $
 *  Revision 1.1  1996/10/11  14:10:15  johnh
 *  new unit
 *  Reorganised demo directory to include separate demos for mswindows and motif.
 *
 *
 *)

require "forms";

require "$.mswindows.__windows";
require "$.mswindows.__capitypes";
require "$.mswindows.__labelstrings";
require "$.basis.__int";
require "$.basis.__real";
require "$.basis.__string";
require "$.basis.__text_io";
require "$.basis.__ieeereal";

local

  datatype WidgetClass = Frame | Graphics | Label | Text | RowColumn | Paned | Form 

  structure Threads = MLWorks.Threads
  structure CapiTypes = CapiTypes_ ;
  structure Windows = Windows_ ;
  structure LabelStrings = LabelStrings_; 
  structure Option = MLWorks.Option;
  structure Array = MLWorks.Internal.Array

  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)

  structure Array = MLWorks.Internal.Array
  structure ExtendedArray = MLWorks.Internal.ExtendedArray
  structure Bits = MLWorks.Internal.Bits
  open MLWorks.IO
in    
  fun P s = output (std_out, s ^ "\n")
    
  val size_exp = 3
  val block_size = Bits.lshift (1,size_exp)
    
  fun max (x:int,y) = if x > y then x else y
  fun min (x:int,y) = if x < y then x else y
    
  fun make_gen (n,m) =
    (Array.tabulate (n, fn _ => Array.array (m,0)),
     n,
     m)
    
  fun sub ((array,n,m),i,j) =
    if i < 0 then 0
    else if j < 0 then 0
    else if i >= n then 0
    else if j >= m then 0
	 else Array.sub (Array.sub (array,i),j)
	   
  fun mymod (i,n) =
    if i < 0 then mymod (i+n,n)
    else if i >= n then mymod (i-n,n)
	 else i
	   
  fun update ((array,n,m),i,j,x:int) =
    Array.update (Array.sub (array,mymod (i,n)),mymod (j,m),x)
    
  fun calc_val (array,i,j) =
    sub (array,i-1,j-1) +
    sub (array,i-1,j) +
    sub (array,i-1,j+1) +
    sub (array,i,j-1) +
    sub (array,i,j+1) +
    sub (array,i+1,j-1) +
    sub (array,i+1,j) +
    sub (array,i+1,j+1)
    
  fun calc_val ((a,n,m),i,j) : int =
    let
      val lix = if j = 0 then m-1 else j-1
      val mix = j
      val rix = if j = m-1 then 0 else j+1
      val top_row = Array.sub (a,if i=0 then n-1 else i-1)
      val mid_row = Array.sub (a,i)
      val bottom_row = Array.sub (a,if i = n-1 then 0 else i+1)
    in
      Array.sub (top_row,lix) +
      Array.sub (top_row,mix) +
      Array.sub (top_row,rix) +
      Array.sub (mid_row,lix) +
      Array.sub (mid_row,rix) +
      Array.sub (bottom_row,lix) +
      Array.sub (bottom_row,mix) +
      Array.sub (bottom_row,rix)
    end
  
  fun new (ina,i,j,outa) =
    let
      val newval =
	case calc_val (ina,i,j) of
	  2 => sub (ina,i,j)
	| 3 => 1
	| _ => 0
    in
      update (outa,i,j,newval)
    end
  
  fun clean (a,n,m) =
    let
      fun loop1 i =
	if i = n
	  then ()
	else
	  let
	    val suba = Array.sub (a,i)
	    fun loop2 j =
	      if j = m then ()
	      else 
		(Array.update (suba,j,0);
		 loop2 (j+1))
	  in
	    loop2 0;
	    loop1 (i+1)
	  end
    in
      loop1 0
    end
  
  fun gen (ina as (_,n,m),outa) =
    let
      fun loop1 i =
	if i = n
	  then ()
	else
	  let
	    fun loop2 j =
	      if j = m then ()
	      else 
		(new (ina,i,j,outa);
		 loop2 (j+1))
	  in
	    loop2 0;
	    loop1 (i+1)
	  end
    in
      clean outa;
      loop1 0;
      (outa,ina)
    end
  
  fun set (a,[]) = ()
    | set (a,(i,j)::rest) =
      (update (a,i,j,1);
       set (a,rest))
      
  val gunvals =
    [(2,20),(3,19),(3,21),(4,18),
     (4,22),(4,23),(4,32),(5,7),
     (5,8),(5,18),(5,22),(5,23),
     (5,29),(5,30),(5,31),(5,32),
     (5,36),(6,7),(6,8),(6,18),
     (6,22),(6,23),(6,28),(6,29),
     (6,30),(6,31),(6,36),(7,19),
     (7,21),(7,28),(7,31),(7,42),
     (7,41),(8,20),(8,28),(8,29),
     (8,30),(8,31),(8,42),(8,41),
     (9,29),(9,30),(9,31),(9,32)
     ]
    
  fun move (a:int,b:int) l = map (fn (x,y) => (x+a,y+b)) l
    
  val initvals = move (10,10) crash
    
  fun init_gen (initvals,world_x,world_y) = 
    let
      val (a1,a2) = (make_gen (world_x,world_y),make_gen (world_x,world_y))
      val _ = set (a1,initvals)
    in
      (a1,a2)
    end
  
  val state = ref (make_gen (0,0),make_gen (0,0))
    
  (* Windows stuff *)

   fun munge_string s =
    let
      fun munge ([],acc) = MLWorks.String.implode (rev acc)
        | munge ("\013" :: "\010" :: rest,acc) =
          munge (rest, "\010" :: "\013" :: acc)
        | munge ("\n"::rest,acc) = munge (rest,"\013\010" :: acc)
        | munge (c::rest,acc) = munge (rest,c::acc)
    in
      munge (MLWorks.String.explode s,[])
    end

  fun set_gui_font window =
    let
      val Windows.OBJECT gui_font =
	Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
	handle
	  Windows.WindowSystemError _ => 
	    Windows.getStockObject (Windows.ANSI_VAR_FONT)
    in
      Windows.sendMessage
        (CapiTypes.get_real window,
         Windows.WM_SETFONT,
         Windows.WPARAM gui_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

  fun convert_class class =
    case class of
      Label => ("STATIC",[Windows.SS_LEFT])
    | Text => ("EDIT",[Windows.WS_BORDER])
    | _ => ("Frame",[]) (* A class of my own devising *)

  fun set_text (window,s) =
    let
      val string_word = Windows.makeCString (munge_string s)
    in
      Windows.sendMessage (CapiTypes.get_real window,Windows.WM_SETTEXT,
                            Windows.WPARAM (Windows.nullWord),
                            Windows.LPARAM string_word);
      Windows.free string_word
    end

  fun reveal window =
    (Windows.showWindow (window,Windows.SW_SHOWNORMAL);
     Windows.updateWindow window)

  fun set_text_font window =
    let
      val Windows.OBJECT text_font =
	Windows.getStockObject (Windows.ANSI_FIXED_FONT)
    in
      Windows.sendMessage
        (CapiTypes.get_real window,
         Windows.WM_SETFONT,
         Windows.WPARAM text_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

  fun class_postaction (window,class) =
    case class of
      Text =>
	(set_text_font window;
         set_text (window, ""))
    | Label => set_gui_font window
    | _ => ()

  fun create_revealed args =
    let
      val window = Windows.createWindow args
    in
      reveal window;
      window
    end

  fun convert_name (Label,name) = LabelStrings.get_label name
    | convert_name (_,name) = LabelStrings.get_title name

  fun class_height class =
    case class of
      Frame => 120
    | Graphics => 120
    | Label => 20
    | Text => 25
    | RowColumn => 30
    | Paned => 120
    | Form => 120
    
  fun make_toplevel (world_x,world_y) =
    let
      val title = "test"
	
      (*  The extent of the drawing area *)
      val xextent = world_x * block_size
      val yextent = world_y * block_size
	
    val default_width = xextent
    val toplevel_width = default_width + 10
    val graphics_height = yextent
    val toplevel_height = graphics_height + 34
  

  fun make_managed_widget (name,class,parent,height,width,attributes) = 
    let
      val (class_name,styles) = convert_class class
      val window =
        create_revealed {class = class_name,
                         name = convert_name (class,name),
                         width = width,
                         height = height,
                         parent = CapiTypes.get_real parent,
                         menu = Windows.nullWord,
                         styles = (* [Windows.WS_CHILD] @@ *) 
				styles @@ attributes}

      val widget = CapiTypes.REAL (window,parent)

    in
      class_postaction (widget,class);
      widget
    end

  fun make_message_text (name,parent,attributes) =
    let
      val window =
        create_revealed
        {class = "EDIT",
         name = LabelStrings.get_title name,
         width = default_width,
         height = 200,
         parent = CapiTypes.get_real parent,
         menu = Windows.nullWord,
         styles = [Windows.WS_CHILD,
                   Windows.WS_BORDER,
                   Windows.WS_HSCROLL,Windows.WS_VSCROLL,
                   Windows.ES_READONLY,
                   Windows.ES_MULTILINE,
                   Windows.ES_AUTOHSCROLL,Windows.ES_AUTOVSCROLL]}
      val widget = CapiTypes.REAL (window,parent)
    in
      set_text_font widget;
      set_text (widget,"");
      (widget,widget)
    end

      val window = Windows.mainInit ()
      val applicationShell = CapiTypes.REAL (window, CapiTypes.NONE)

  val mainWindow = applicationShell
  val menuBar = applicationShell

  val lifeWindow = make_managed_widget ("Life", Form, applicationShell, 
			toplevel_height, toplevel_width,
			[Windows.WS_OVERLAPPED_WINDOW])
  val life = CapiTypes.get_real lifeWindow
  val _ = Windows.showWindow (life, Windows.SW_SHOWDEFAULT)

  val (scroll,message) = make_message_text ("message",mainWindow,[]);
  val _ = Windows.showWindow (CapiTypes.get_real scroll, Windows.SW_HIDE);
  val no_message_widget : unit -> unit = env "nt no message widget"
  val set_message_window : CapiTypes.Hwnd -> unit = env "nt set message widget"

  fun set_message_widget widget =
    set_message_window (CapiTypes.get_real widget)

  fun start_messages () = set_message_widget message
  fun stop_messages () = no_message_widget ()

  val _ = start_messages ()

    local 
	val hdc = Windows.getDC life
    in 
	val on_brush = Windows.createSolidBrush (Windows.getTextColor hdc);
	val off_brush = Windows.createSolidBrush (Windows.getBkColor hdc);
	val _ = Windows.releaseDC (life,hdc)
    end

      fun draw_image (x,y) = 
	let val hdc = Windows.getDC life
	in (Windows.fillRect (hdc,Windows.RECT {left=x+1,top=y+1,right=x + block_size,
				bottom=y + block_size}, on_brush);
	    Windows.releaseDC (life,hdc))
	end
	
      fun clear_image (x,y) =
	let val hdc = Windows.getDC life
	in (Windows.fillRect (hdc,Windows.RECT {left=x+1,top=y+1,right=x + block_size,
				bottom=y + block_size}, off_brush);
	    Windows.releaseDC (life,hdc))
	end

	
      fun make_rect (x,y) = Windows.RECT {left=Bits.lshift (x,size_exp)+1,
					  top=Bits.lshift (y,size_exp)+1,
					  right=(Bits.lshift (x,size_exp)+1)+ block_size,
					  bottom=(Bits.lshift (y,size_exp)+1) +block_size}
	
      fun draw_picture _ =
	let
	  val ((gen1,_,_),(gen2,_,_)) = !state
	  val on_rects = ref []
	  val off_rects = ref []
	  val hdc = Windows.getDC life
	  fun fill_rects (brush, []) = ()
	    | fill_rects (brush, (rect1::rest)) = 
		(Windows.fillRect(hdc, rect1, brush); 
		 fill_rects (brush, rest))
	in
	  ExtendedArray.iterate_index
	  (fn (i,a) =>
	   let
	     val max = Array.length a
	     val a2 = Array.sub (gen2,i)
	     fun loop j = 
	       if j = max then ()
	       else
		 let
		   val n = Array.sub (a,j)
		 in
		   if n = 1 then 
		     on_rects := make_rect (i,j) :: !on_rects
		   else
		     if n = Array.sub (a2,j)
		       then ()
		     else
		       off_rects := make_rect (i,j) :: !off_rects;
		       loop (j+1)
		 end
	   in
	     loop 0
	   end)
	  gen1;
	  fill_rects (off_brush,!off_rects);
	  fill_rects (on_brush, !on_rects);
	  Windows.releaseDC (life, hdc)
	end
      
      val goforit = ref false
	
      fun drawit _ =
	(draw_picture ();
	 if !goforit
	   then
	     (state := gen (!state);
	      draw_picture ()
(*		;let val dc = Windows.getDC life
		in (Windows.fillRect(dc, Windows.RECT {left=0, top=0,
			right=toplevel_width, bottom=toplevel_height}, off_brush);
		    Windows.releaseDC (life, dc))
		end  *)
		)
	 else ())
	
      val draw_picture = drawit 
	
      fun paint_event _ = (draw_picture (); Option.NONE)

      fun clearit _ =
	let val hdc = Windows.getDC life
	in (Windows.fillRect (hdc, Windows.RECT {left=0, top=0, right=toplevel_width,
						bottom=toplevel_height}, off_brush);
	    Windows.releaseDC (life, hdc))
	end
	  
      fun resize_event data = (clearit (); Option.NONE)
	
      fun new_gen () =
	(state := gen (!state);
	 drawit ())
	
    fun mouse_event event (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
      let 
	val xPos = Windows.loword(lparam)
	val yPos = Windows.hiword(lparam)
      in
	(case event of 
	  Windows.WM_LBUTTONDOWN => (
	      let
		val i = xPos div block_size
		val j = yPos div block_size
	      in
		if i >= 0 andalso i < world_x
		  andalso j >= 0 andalso j < world_y
		  then
		    let 
		      val ((a,_,_),_) = !state
		      val current = Array.sub (Array.sub (a,i),j)
		      val new = 1 - current
		    in
		      Array.update (Array.sub (a,i),j,new);
		      if new = 1 
			then draw_image (i*block_size,j*block_size)
		      else clear_image (i*block_size,j*block_size)
		    end
		else ()
	      end)
	| _ => ();
	Option.NONE)
      end

      val colorcount = ref 0

      fun P s = MLWorks.IO.output (MLWorks.IO.terminal_out,s)
      fun delay 0 = P "finished delay!\n"
        | delay n = if n>0 then delay (n-1) else ()

      val _ = Threads.Internal.Preemption.set_interval 100;

      val ok = ref true;

      fun delay_fun n = (ok := false; delay n; 
			Threads.Internal.Preemption.stop ();
			ok := true)

      fun do_key key = 
	case key of
	   "x" => (stop_messages ();
		  Windows.postQuitMessage 0;
		  Windows.destroyWindow life;())
	|  "l" => (if !ok then (P "started\n";
			if (Threads.Internal.Preemption.on ()) then
				Threads.Internal.Preemption.stop ()
				else ();
			Threads.fork delay_fun 131231313;
			Threads.Internal.Preemption.start ())
		   else ();
		   ())

	|  "t" => (colorcount := !colorcount + 100;
		   P ((Int.toString (!colorcount)) ^ "\n");
		   let val dc = Windows.getDC life
		       val the_brush = Windows.createSolidBrush 
				(Windows.COLOR (Windows.intToWord (!colorcount)))
		       val the_rect = Windows.RECT {left=0, top=0, right=50, bottom=50}
		   in
		     (Windows.fillRect(dc, the_rect, the_brush);
		      Windows.releaseDC (life,dc))
		   end;())
	|  "r" => (state :=init_gen (initvals,world_x,world_y);
		   clearit ())
	|  "s" => (goforit := not (!goforit);
	           if !goforit then new_gen() else ())
	|   _  => (new_gen ();())
	

    fun key_press (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
      (do_key (str (chr (Windows.wordToInt wparam))); Option.NONE)

    fun mainLoop frame =
      let
	val loop =
	  (Windows.mainLoop (); false)
	  (* normal return, don't loop *)
	  handle 
          MLWorks.Interrupt => true	(* interrupt, continue X interface *)
          | exn => true
      in
	    if loop then mainLoop frame else stop_messages() 
      end

    in
      Windows.addMessageHandler(life, Windows.WM_LBUTTONDOWN, mouse_event Windows.WM_LBUTTONDOWN);
      Windows.addMessageHandler(life, Windows.WM_PAINT, paint_event);
      Windows.addMessageHandler(life, Windows.WM_SIZE, resize_event);
      Windows.addMessageHandler(life, Windows.WM_CHAR, key_press);
      Windows.addMessageHandler (life,Windows.WM_DESTROY,
                                   fn _ => (stop_messages ();
					    Windows.postQuitMessage 0;
                                            Option.NONE));

      Threads.fork mainLoop ();
	P "finished!\n"

    end;
    
  fun create (init,x,y) = 
    (state := init;
     make_toplevel (x,y))
    
(*  fun runx () = mainLoop ()*)

  val world_x = 121
  val world_y = 37
  
  fun test () =  create (init_gen (initvals,world_x,world_y), world_x,world_y)
  fun life (vals,x,y) = create (init_gen (vals,x,y),x,y)
(*   fun appl () = (test (); runx ())*)

val _ = test ()

end

@


1.1
log
@new unit
Reorganised demo directory to include separate demos for mswindows and motif.
@
text
@d5 5
a9 1
 * $Log$
d18 1
a18 1
require "$.basis.__integer";
@


1.1.1.1
log
@branched from 1.1
@
text
@d5 1
a5 5
 * $Log: mswindows:life.sml,v $
 *  Revision 1.1  1996/10/11  14:10:15  johnh
 *  new unit
 *  Reorganised demo directory to include separate demos for mswindows and motif.
 *
@
