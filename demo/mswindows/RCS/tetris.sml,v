head	1.16;
access;
symbols
	MLWorks_21c0_1999_03_25:1.16
	MLWorks_20c1_1998_08_20:1.15
	MLWorks_20c0_1998_08_04:1.15
	MLWorks_20b2c2_1998_06_19:1.15
	MLWorks_20b2_Windows_1998_06_12:1.15
	MLWorks_20b1c1_1998_05_07:1.15
	MLWorks_20b0_1998_04_07:1.14
	MLWorks_20b0_1998_03_20:1.14
	MLWorks_20m2_1998_02_16:1.14
	MLWorks_workspace_97:1.14.1
	MLWorks_20m1_1997_10_23:1.14
	MLWorks_11r1:1.11.1.3.1.2.1
	MLWorks_11c0_1997_09_09:1.11.1.3.1.2
	MLWorks_10r3:1.11.1.3.3
	MLWorks_10r2_551:1.11.1.3.2
	MLWorks_11:1.11.1.3.1
	MLWorks_1_0_r2c2_1997_07_28:1.11.1.3
	MLWorks_20m0_1997_06_20:1.13
	MLWorks_1_0_r2c2_1997_06_14:1.11.1.3
	MLWorks_1_0_r2c1_released_1997_05_23:1.11.1.3
	MLWorks_1_0_r2c1_1997_05_12:1.11.1
	MLWorks_BugFix_1997_04_24:1.11
	MLWorks_1_0_r2_Win32_1997_04_11:1.11
	MLWorks_1_0_r2_Unix_1997_04_04:1.10
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.1.1.1
	MLWorks_1_0_Win32_1996_12_17:1.8.1
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.5.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.5.1.1
	MLWorks_1_0_Irix_1996_11_28:1.5.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.5.2
	MLWorks_1_0_Unix_1996_11_14:1.5.1
	MLWorks_Open_Beta2_1996_10_11:1.2.1
	MLWorks_License_dev:1.1.1;
locks; strict;
comment	@ *  @;


1.16
date	98.11.09.11.33.55;	author johnh;	state Exp;
branches;
next	1.15;

1.15
date	98.05.07.14.54.37;	author jkbrook;	state Exp;
branches;
next	1.14;

1.14
date	97.08.06.12.54.15;	author johnh;	state Exp;
branches
	1.14.1.1;
next	1.13;

1.13
date	97.06.16.13.04.17;	author jkbrook;	state Exp;
branches;
next	1.12;

1.12
date	97.05.14.14.48.52;	author johnh;	state Exp;
branches;
next	1.11;

1.11
date	97.04.11.08.52.39;	author johnh;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	97.04.03.09.13.00;	author johnh;	state Exp;
branches;
next	1.9;

1.9
date	97.01.07.16.38.34;	author io;	state Exp;
branches;
next	1.8;

1.8
date	96.12.06.15.56.41;	author daveb;	state Exp;
branches
	1.8.1.1;
next	1.7;

1.7
date	96.12.02.16.54.35;	author johnh;	state Exp;
branches;
next	1.6;

1.6
date	96.12.02.15.07.07;	author johnh;	state Exp;
branches;
next	1.5;

1.5
date	96.11.08.12.03.15;	author johnh;	state Exp;
branches
	1.5.1.1
	1.5.2.1;
next	1.4;

1.4
date	96.11.07.18.59.18;	author jkbrook;	state Exp;
branches;
next	1.3;

1.3
date	96.11.06.11.54.28;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	96.10.11.14.44.23;	author johnh;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	96.10.03.15.15.00;	author johnh;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.10.07.15.58.27;	author hope;	state Exp;
branches;
next	;

1.2.1.1
date	96.10.17.11.16.46;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.11.14.12.40.10;	author hope;	state Exp;
branches
	1.5.1.1.1.1;
next	;

1.5.1.1.1.1
date	96.11.28.14.52.00;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.11.22.18.00.39;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	96.12.17.17.39.31;	author hope;	state Exp;
branches
	1.8.1.1.1.1;
next	;

1.8.1.1.1.1
date	97.02.24.11.26.42;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	97.05.12.10.24.30;	author hope;	state Exp;
branches;
next	1.11.1.2;

1.11.1.2
date	97.05.15.08.46.58;	author daveb;	state Exp;
branches;
next	1.11.1.3;

1.11.1.3
date	97.05.15.13.22.32;	author daveb;	state Exp;
branches
	1.11.1.3.1.1
	1.11.1.3.2.1
	1.11.1.3.3.1;
next	;

1.11.1.3.1.1
date	97.07.28.18.10.31;	author daveb;	state Exp;
branches;
next	1.11.1.3.1.2;

1.11.1.3.1.2
date	97.08.06.16.15.25;	author johnh;	state Exp;
branches
	1.11.1.3.1.2.1.1;
next	;

1.11.1.3.1.2.1.1
date	97.10.07.11.34.42;	author jkbrook;	state Exp;
branches;
next	;

1.11.1.3.2.1
date	97.09.08.17.03.50;	author daveb;	state Exp;
branches;
next	;

1.11.1.3.3.1
date	97.09.09.13.58.50;	author daveb;	state Exp;
branches;
next	;

1.14.1.1
date	97.11.30.16.48.53;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Added new windows version of tetris.
@


1.16
log
@[Bug #50105]
Make toplevel functions unique across demos to avoid conflicts when loading demo project.
@
text
@(*  ==== Tetris demo  ====
 *
 *  Copyright (C) 1997 The Harlequin Group Limited.  All rights reserved.
 *
 * $Log: mswindows:tetris.sml,v $
 *  Revision 1.15  1998/05/07  14:54:37  jkbrook
 *  [Bug #30388]
 *  Change Windows to WindowsGui and remove use of MLWorks.IO
 *  Also put in ignores to get rid of warnings
 *
 *  Revision 1.14  1997/08/06  12:54:15  johnh
 *  [Bug #30130]
 *  Fix similar bug as in life demo - leaving listener hanging.
 *
 *  Revision 1.13  1997/06/16  13:04:17  jkbrook
 *  [Bug #30127]
 *  Merging changes from 1.0r2c1 into 2.0m0
 *
 *
 *  Revision 1.11.1.3  1997/05/15  13:22:32  daveb
 *  [Bug #30127]
 *  Updated copyright.
 *
 *  Revision 1.11.1.2  1997/05/15  08:46:58  daveb
 *  [Bug #20009]
 *  Making the demo unresizable.
 *
 *  Revision 1.11.1.1  1997/05/12  10:24:30  hope
 *  branched from 1.11
 *
 *  Revision 1.12  1997/05/14  14:48:52  johnh
 *  Making the demo unresizable.
 *
 *  Revision 1.11  1997/04/11  08:52:39  johnh
 *  Tidied some code and fix problems with adding revision comments.
 *
 *  Revision 1.1  1996/10/03  15:15:00  johnh
 *  new unit
 *  Added new windows version of tetris
 *
 *
*)


(* To play, type:  
 *	make_toplevel <your_name> <level 1 - 5>
 *)

require "$.winsys.__windows_gui";
require "$.basis.__int";
require "$.basis.__real";
require "$.basis.__string";
require "$.basis.__text_io";
require "$.basis.__io";
require "$.basis.__ieee_real";
require "$.basis.__char";
require "$.basis.__array";

local
  datatype WidgetClass = Text | Form 

  val xsize = 12
  val ysize = 30

  val block_size = 16
  (* These are the primitive shapes of the game which get rotated into the
   * various orientations used in the game. *)
  val square = [(~1,~1),(~1,0),(0,~1),(0,0)]
  val line = [(~2,0),(~1,0),(0,0),(1,0)]
  val step = [(~1,0),(0,0),(0,~1),(1,~1)]
  val el = [(~1,~1),(~1,0),(0,0),(1,0)]
  val tee = [(0,~1),(~1,0),(0,0),(1,0)]

  (* reflection - used in reflect the shapes into new shapes *)
  fun refl l = 
    map (fn (x:int,y:int) => (y,x)) l

  (* rotation - again used to create new shapes *)
  fun rot l = 
    map (fn (x:int,y:int) => (~y,x)) l

  val shapes =
    [step,
     square,
     line,
     tee,
     refl step,
     el,
     rot (rot tee),
     rot line,
     refl el]

  (* make a high score table *)
  fun make_high_scores y = 
    Array.tabulate (y, fn i => 
	("No-one   ", 0))

  val highscores = make_high_scores 6;

  fun make_grid (x,y,tf) =
    Array.tabulate
    (y, fn i => Array.array (x,tf))
      
  val score = ref 0

  fun boolToString true = "T"
    | boolToString false = "F"
      
  (* functions sub??? access arrays, for example accessing the high
   * score array to see if a high score has been beaten. *)
  fun sub2 (a,x,y) =
    Array.sub (Array.sub (a,y),x)
     handle Subscript => false
        
  fun sub_hs (a,y) = 
    Array.sub (a,y)
     handle Subscript => ("", 0)
	
  (* functions update??? update the appropriate arrays. *)
  fun update2 (a,x,y,v) =
    Array.update (Array.sub (a,y),x,v)
     handle Subscript => () 
        
  fun update_hs (a,y,v) = 
    Array.update (a,y,v)
     handle Subscript => ()
      
  (* Sets up the game grid *)
  val grid = make_grid (xsize,ysize,false)
  val update = make_grid (xsize,ysize,true)      

  fun print_grid () = 
    let 
      fun print xstr = TextIO.output (TextIO.stdOut, xstr)
      fun print_line x y = if x>xsize then 
				print "\n"
			   else (print ((boolToString (sub2 (grid, x,y))) ^ "   ");
				 print_line (x+1) y)
      fun print_grid' y = if y>ysize then print ""	
				else (print_line 0 y; print_grid' (y+1))
    in
      print_grid' 0
    end

  (* This checks the top line in the game grid to see if there are
   * any blocks there, and if there are then this is used to mark
   * the end of a game. *)
  fun not_end 0 = not (sub2(grid, 0, 1))
    | not_end n = (not (sub2(grid, n, 1))) andalso not_end (n-1);
        
  local 
    val a = 16807.0 and m = 2147483647.0
  in 
    fun nextrand seed = 
      let val t = a * seed
      in t - m * real(floor(t/m)) end
  end;

  val rand_num = ref (Int.toLarge 23478645);
  
  val current_shape = ref []
  val current_xy = ref (5,0)
  val current_points = ref []

  (* down, left and right move the shapes within the grid *)
  fun down ((x,y),shape) = ((x,y+1),shape)
    
  fun right ((x,y),shape) = ((x+1,y),shape)
    
  fun left ((x,y),shape) = ((x-1,y),shape)
    
  (* rot and crot functions are used to rotate a shape within the game grid *) 
  fun rot (xy,shape) =
    (xy,map (fn (x:int,y:int) => (y,~x)) shape)
  fun crot (xy,shape) = 
    (xy,map (fn (x:int,y:int) => (~y,x)) shape)
      
  fun get_current_points (xy,shape) =
    let
      val (cx,cy) = xy
    in
      map (fn (x:int,y:int) => (x+cx,y+cy)) shape
    end
    
  (* This function is used to make sure that a new position of the current
   * shape is legal, ie. does not cross the boundary of another shape or
   * cross the boundary of the game grid. *)
  fun allowable [] = true
    | allowable ((x,y) :: rest) =
      x >= 0 andalso x < xsize
      andalso y < ysize
      andalso
      (not (sub2 (grid,x,y)))
      andalso
      allowable rest
      
  fun member (a,[]) = false
    | member (a,(b::c)) = a = b orelse member (a,c)
      
  fun diff ([],l) = []
    | diff (a::b,l) =
      if member (a,l) then diff (b,l)
      else a :: diff (b,l)
        
  fun move f =
    let
      val old_points = !current_points
      val (new_xy,new_shape) = f (!current_xy,!current_shape)
      val new_points = get_current_points (new_xy,new_shape)
      val newbits = diff (new_points,old_points)
    in
      if allowable newbits
        then
           (current_points := new_points;
           current_xy := new_xy;
           current_shape:= new_shape;
           ignore (map
           (fn (x,y) =>
             (ignore (update2 (grid,x,y,false));
	     update2 (update,x,y,true)))
             old_points);
           ignore (map
           (fn (x,y) =>
            (ignore (update2 (grid,x,y,true));
	     update2 (update,x,y,true)))
             new_points);
           true)
      else
        false
    end

  exception no_shape;

  local 
    fun update_rand () = 
        (rand_num := Real.toLargeInt IEEEReal.TO_NEAREST (nextrand 
                     (Real.fromLargeInt (!rand_num)));())

    fun get_shape 0 (a::rest) = a
      | get_shape n (a::rest) = get_shape (n-1) rest
      | get_shape _ [] = raise no_shape;
  in 
    fun next_shape () = (update_rand ();
                         get_shape (Int.fromLarge ((!rand_num) mod 9)) shapes)
  end

  (*  The extent of the drawing area *)
  val xextent = xsize * block_size
  val yextent = ysize * block_size
  val default_width = xsize * block_size
  val toplevel_width = default_width + 10
  val graphics_height = ysize * block_size
  val toplevel_height = graphics_height + 34
  
  fun munge_string s =
    let
      fun munge ([],acc) = MLWorks.String.implode (rev acc)
        | munge ("\013" :: "\010" :: rest,acc) =
          munge (rest, "\010" :: "\013" :: acc)
        | munge ("\n"::rest,acc) = munge (rest,"\013\010" :: acc)
        | munge (c::rest,acc) = munge (rest,c::acc)
    in
      munge (MLWorks.String.explode s,[])
    end

  fun convert_class class =
    case class of
      Text => ("EDIT",[WindowsGui.WS_BORDER])
    | Form => ("Frame",[]) 

  fun set_text (window,s) =
    let
      val string_word = WindowsGui.makeCString (munge_string s)
    in
      ignore (WindowsGui.sendMessage (window,WindowsGui.WM_SETTEXT,
                            WindowsGui.WPARAM (WindowsGui.nullWord),
                            WindowsGui.LPARAM string_word));
      WindowsGui.free string_word
    end

  fun class_postaction (window,class) =
    case class of
      Text => set_text (window, "")
    | Form => ()

  fun create_revealed args =
    let
      val window = WindowsGui.createWindow args
    in
      WindowsGui.showWindow (window,WindowsGui.SW_SHOWNORMAL);
      WindowsGui.updateWindow window;
      window
    end

  fun make_managed_widget (name,class,parent,height,width,attributes) = 
    let
      val (class_name,styles) = convert_class class
      val window =
        create_revealed {class = class_name,
                         name = name,
                         width = width,
                         height = height,
                         parent = parent,
                         menu = WindowsGui.nullWord,
                         styles = styles @@ attributes}
    in
      class_postaction (window,class);
      window
    end

  local 
    fun get_level n = sub_hs (highscores, n)
    fun save_levels outstrm 0 = ()
      | save_levels outstrm n = 
	let 
	  val (lname,lhs) = get_level (n-1)
	in
	  (TextIO.output (outstrm, Int.toString n ^ "\n");
	   TextIO.output (outstrm, lname ^ "\n");
	   TextIO.output (outstrm, Int.toString lhs ^ "\n");
	   save_levels outstrm (n-1);
	   TextIO.closeOut outstrm)
	end

    fun load_levels instrm = 
      if (not (TextIO.endOfStream instrm)) then
	(let
	   fun get_opt NONE = 0
	     | get_opt (SOME s) = s
	   val some_level = Int.fromString (TextIO.inputLine (instrm))
	   val level = get_opt some_level
	   val lname = (let val l = TextIO.inputLine (instrm) 
		     in String.substring(l, 0, (String.size l) - 1)
			handle Subscript => "" end)
	   val some_lhs = Int.fromString (TextIO.inputLine (instrm))
	   val lhs = get_opt some_lhs
	 in
	   (update_hs (highscores, level - 1, (lname,lhs)); 
	    load_levels instrm)
	 end)
       else (TextIO.closeIn instrm)
  in	
    fun save_table filename = save_levels (TextIO.openOut filename) 5
    fun load_table filename = load_levels (TextIO.openIn filename)
	    handle IO.Io {function="openIn",...} => save_table filename
  end

  fun make_toplevel player level =
    let
      val deltime = (5 - level) * 50 + 30
      val del = ref deltime
      val _ = load_table "highscores.tet"; 

      (* This statement uses an MS Windows procedure to initialise the
       * main window of the game. *)
      val applicationShell = WindowsGui.mainInit ();

      val scoresMainWindow = make_managed_widget ("Scores", Form, applicationShell, 
        			350,275, 
        			[WindowsGui.WS_CAPTION,
        			WindowsGui.WS_SYSMENU,
        			WindowsGui.WS_MINIMIZEBOX])
      val scoresWindow = make_managed_widget ("", Text, scoresMainWindow,
        			350,272, 
        			[WindowsGui.ES_MULTILINE, WindowsGui.ES_READONLY,
        			WindowsGui.ES_AUTOVSCROLL, WindowsGui.WS_CHILD])

      val tetris = make_managed_widget ("Tetris", Form, applicationShell, 
        			toplevel_height, toplevel_width,
        			[WindowsGui.WS_SYSMENU,
				 WindowsGui.WS_MINIMIZEBOX,
				 WindowsGui.WS_OVERLAPPED])
    
      val _ = WindowsGui.showWindow (scoresWindow, WindowsGui.SW_SHOWDEFAULT)
      val _ = WindowsGui.showWindow (tetris, WindowsGui.SW_SHOWDEFAULT)

      val title = player

      local 
	val hdc = WindowsGui.getDC tetris
      in 
	val on_brush = WindowsGui.createSolidBrush (WindowsGui.getTextColor hdc);
	val off_brush = WindowsGui.createSolidBrush (WindowsGui.getBkColor hdc);
	val _ = WindowsGui.releaseDC (tetris,hdc)
      end

      fun draw_image (x,y) =
        let val hdc = WindowsGui.getDC tetris
        in 
	  (WindowsGui.fillRect (hdc,WindowsGui.RECT {left=x+1,top=y+1,right=x + block_size,
			      bottom=y + block_size}, on_brush);
	  WindowsGui.releaseDC (tetris,hdc))
        end

      fun clear_image (x,y) = (* change brush; draw_image; change brush *)
        let val hdc = WindowsGui.getDC tetris
        in 
	  (WindowsGui.fillRect (hdc, WindowsGui.RECT 
		{left=x+1,top=y+1, right=x + block_size, bottom=y + block_size}, 
		off_brush);
	  WindowsGui.releaseDC (tetris,hdc))
        end

      fun draw a =   (* a always = grid *)
        let
          fun yloop y =
            if y = Array.length a then ()
            else
              let
                val suba = Array.sub (a,y)
                fun subloop x =
                  if x = Array.length suba then ()
                  else
  		    (if Array.sub ((Array.sub (update,y)),x) then
                       ((if Array.sub (suba,x)
                        then
                           draw_image (x*16,y*16)
                        else
                           clear_image (x*16,y*16));
  		        update2 (update,x,y,false))
  		     else ();
                     subloop (x+1))
              in
                subloop 0;
                yloop (y+1)
              end
        in
          yloop 0
        end

      val xref = ref (xsize div 2)

      fun arot a =
        let
          fun loop 0 = ()
            | loop i =
              (Array.update (a,i,Array.sub (a,i-1));
               loop (i-1))
        in
          loop (Array.length a - 1)
        end

      (* This function clears rows within the grid which are complete. *)
      fun elim_clear_rows () =
        let
          fun doit n =
            if n = 0
              then ()
            else
              let
                val row = Array.sub (grid,n)
                fun check n =
                  if n = Array.length row
                    then true
                  else Array.sub (row,n) andalso check (n+1)
              in
                if check 0
                  then
                    let
                      fun move_down 0 =
                          (Array.update (grid,0,Array.array (xsize,false));
  			   Array.update (update, 0, Array.array (xsize,true));
                           draw grid)
                        | move_down n =
                          (Array.update (grid,n,Array.sub (grid,n-1));
  			   Array.update (update,n,Array.array (xsize,true));
                           move_down (n-1))
                    in
                      move_down n;
                      doit n
                    end
                else
                  doit (n-1)
              end
        in
          doit (Array.length grid - 1)
        end

      fun new_shape () =
        let
          val _ = elim_clear_rows ()
          val shape = next_shape ()
          val dx = !xref
          val _ = xref := (dx + 4) mod xsize
        in
          current_shape := shape;
          current_xy := (dx,0);
          current_points := [];
	  if not (move down) then 
		(new_shape ();()) 
	  else ()
        end

      local 
	val (hname, hs) = sub_hs (highscores, level - 1)
      in
	val get_name = hname;
	val get_hs = hs;
      end

      val text_buf = ref "";
      fun hs_win hs_str = text_buf := (!text_buf) ^ hs_str

      local 
        fun get_hs2 l = sub_hs (highscores, l - 1)
        fun print_hs 6 = true
          | print_hs (n:int) = 
            let 
              val (cname, chs) = get_hs2 n
            in 
	      
              (hs_win ((Int.toString n) ^":    "^ Int.toString chs ^"   by   "^ 
			cname ^"\n");
	       ignore (print_hs (n+1));
               true)
            end
      in
        fun output_hs () = 
			
                       (text_buf := ""; hs_win "Level: Score by Player.\n\n"; 
  			ignore (print_hs 1); 
                        hs_win "------------------------\n\n";
  			set_text (scoresWindow, !text_buf ))
      end

      val _ = output_hs ();

      fun set_array the_array array_value = 
        let 
	  fun clear_line 0 y = update2 (the_array, 0,y,array_value)
	    | clear_line x y = (clear_line (x-1) y; 
				update2 (the_array, x, y, array_value))
	  fun clear_whole 0 = clear_line (xsize-1) 0
	    | clear_whole y = (clear_whole (y-1); 
			       clear_line (xsize-1) y)
        in
	  clear_whole (ysize - 1)
        end

      fun the_end () = 
        let 	
	  val _ = if get_hs < !score then
		(update_hs(highscores, level - 1, (player, !score));())
		else ()
        in
    	  (output_hs ();hs_win (player^" scored "^ Int.toString (!score) ^ " on level " 
	         ^ Int.toString level ^".\n\n");
	  set_text (scoresWindow, !text_buf);
	  save_table "highscores.tet")
        end

(* Keep this around as it might be brought back in to increase
 * the speed of the game as it progreses *)

(*    fun test_score () = case (!score) of 
			    50 => del := !del - 150000
			|  100 => del := !del - 150000
			|  150 => del := !del - 150000
			|  200 => del := 0
			|   _  => ()
*)

      val start = ref false;
      val locked = ref 0;

      exception Quit;

      fun do_key key = 
        (if ((!locked) = 0) then 
	    (locked := !locked + 1;
            ignore (case key of
               " " => if move down then true else 
		    if not_end xsize then (new_shape (); 
			score := !score + 1;
			true) else
		    	(ignore (the_end ();  
			hs_win "Press 'S' in the Tetris window to start.\n\n";
			set_text (scoresWindow, !text_buf);
			start := false);
			false)
            | "s" => (ignore (score := 0;
		    set_array update true;
		    set_array grid false;
		    draw grid;
		    start := true); 
		    false)
            | "l" => move right
            | "h" => move left
            | "i" => move rot
            | "o" => move (rot o rot o rot)
            | "x" => (ignore (WindowsGui.destroyWindow tetris; 
		    WindowsGui.destroyWindow scoresMainWindow;
		    raise Quit);
		    false)
            | _ => true);
	   locked := !locked - 1;
	   false)
         else false)

      fun delay 0 = () | delay n = 
        if n>0 then 
	  delay (n-1) 
        else ()

      fun timer _ = 
        if ((!start) andalso ((!locked) = 0)) then 
	  (ignore (do_key " ");
	   draw grid; ()) 
        else ()

      fun paint_event _ = 
        (set_array update true; draw grid; NONE)

      fun key_press (WindowsGui.WPARAM wparam, WindowsGui.LPARAM lparam) = 
         (ignore 
          (do_key (str (Char.toLower (chr (WindowsGui.wordToInt wparam))))); 
         draw grid; NONE)

    in
      ignore (WindowsGui.setTimer(tetris, !del, timer));
      WindowsGui.addMessageHandler (tetris, WindowsGui.WM_CLOSE, 
				   fn _ => (ignore (do_key "x"); 
					    SOME WindowsGui.nullWord));
      WindowsGui.addMessageHandler (tetris, WindowsGui.WM_PAINT, paint_event);
      WindowsGui.addMessageHandler (tetris, WindowsGui.WM_CHAR, key_press);

      (* The following code initialises the tetris window to start with a new game *)
      score := 0;
      set_array update true;
      set_array grid false;
      new_shape ();
      draw grid;
      start := true
    end

in

  fun tetris (name, level) = 
    (make_toplevel name level;
     WindowsGui.mainLoop () handle _ => ())

  fun tetris_appl (name, level) () = 
    (make_toplevel name level;
     WindowsGui.mainLoop () handle _ => WindowsGui.postQuitMessage 0)

  fun tetris_test () = tetris ("You", 3)

end


@


1.15
log
@[Bug #30388]
Change Windows to WindowsGui and remove use of MLWorks.IO
Also put in ignores to get rid of warnings
@
text
@d6 5
d642 1
a642 1
  fun appl (name, level) () = 
d646 1
a646 1
  fun test () = tetris ("You", 3)
@


1.14
log
@[Bug #30130]
Fix similar bug as in life demo - leaving listener hanging.
@
text
@d6 4
d44 1
a44 1
require "$.winsys.__windows";
d129 1
a129 1
      fun print xstr = MLWorks.IO.output (MLWorks.IO.terminal_out, xstr)
d209 1
a209 1
          (current_points := new_points;
d212 1
a212 1
           map
d214 1
a214 1
            (update2 (grid,x,y,false);
d216 2
a217 2
             old_points;
           map
d219 1
a219 1
            (update2 (grid,x,y,true);
d221 1
a221 1
             new_points;
d263 1
a263 1
      Text => ("EDIT",[Windows.WS_BORDER])
d268 1
a268 1
      val string_word = Windows.makeCString (munge_string s)
d270 4
a273 4
      Windows.sendMessage (window,Windows.WM_SETTEXT,
                            Windows.WPARAM (Windows.nullWord),
                            Windows.LPARAM string_word);
      Windows.free string_word
d283 1
a283 1
      val window = Windows.createWindow args
d285 2
a286 2
      Windows.showWindow (window,Windows.SW_SHOWNORMAL);
      Windows.updateWindow window;
d299 1
a299 1
                         menu = Windows.nullWord,
d351 1
a351 1
      val applicationShell = Windows.mainInit ();
d355 3
a357 3
        			[Windows.WS_CAPTION,
        			Windows.WS_SYSMENU,
        			Windows.WS_MINIMIZEBOX])
d360 2
a361 2
        			[Windows.ES_MULTILINE, Windows.ES_READONLY,
        			Windows.ES_AUTOVSCROLL, Windows.WS_CHILD])
d365 3
a367 3
        			[Windows.WS_SYSMENU,
				 Windows.WS_MINIMIZEBOX,
				 Windows.WS_OVERLAPPED])
d369 2
a370 2
      val _ = Windows.showWindow (scoresWindow, Windows.SW_SHOWDEFAULT)
      val _ = Windows.showWindow (tetris, Windows.SW_SHOWDEFAULT)
d375 1
a375 1
	val hdc = Windows.getDC tetris
d377 3
a379 3
	val on_brush = Windows.createSolidBrush (Windows.getTextColor hdc);
	val off_brush = Windows.createSolidBrush (Windows.getBkColor hdc);
	val _ = Windows.releaseDC (tetris,hdc)
d383 1
a383 1
        let val hdc = Windows.getDC tetris
d385 1
a385 1
	  (Windows.fillRect (hdc,Windows.RECT {left=x+1,top=y+1,right=x + block_size,
d387 1
a387 1
	  Windows.releaseDC (tetris,hdc))
d391 1
a391 1
        let val hdc = Windows.getDC tetris
d393 1
a393 1
	  (Windows.fillRect (hdc, Windows.RECT 
d396 1
a396 1
	  Windows.releaseDC (tetris,hdc))
d506 1
d508 2
a509 2
			cname ^"\n") ;
	       print_hs (n+1);
d513 5
a517 2
        fun output_hs () = (text_buf := "";hs_win "Level: Score by Player.\n\n"; 
  			print_hs 1; hs_win "------------------------\n\n";
d565 2
a566 2
	   (locked := !locked + 1;
            case key of
d571 1
a571 1
		    	(the_end ();  
d574 1
a574 1
			start := false;
d576 1
a576 1
            | "s" => (score := 0;
d580 1
a580 1
		    start := true; 
d586 3
a588 3
            | "x" => (Windows.destroyWindow tetris; 
		    Windows.destroyWindow scoresMainWindow;
		    raise Quit;
d590 1
a590 1
            | _ => true;
d602 1
a602 1
	  (do_key " ";
d609 3
a611 2
      fun key_press (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
        (do_key (str (Char.toLower (chr (Windows.wordToInt wparam)))); 
d615 6
a620 6
      Windows.setTimer(tetris, !del, timer);
      Windows.addMessageHandler (tetris, Windows.WM_CLOSE, 
				   fn _ => (do_key "x"; 
					    SOME Windows.nullWord));
      Windows.addMessageHandler (tetris, Windows.WM_PAINT, paint_event);
      Windows.addMessageHandler (tetris, Windows.WM_CHAR, key_press);
d635 1
a635 1
     Windows.mainLoop () handle _ => ())
d639 1
a639 1
     Windows.mainLoop () handle _ => Windows.postQuitMessage 0)
@


1.14.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 4
 *  Revision 1.14  1997/08/06  12:54:15  johnh
 *  [Bug #30130]
 *  Fix similar bug as in life demo - leaving listener hanging.
 *
@


1.13
log
@[Bug #30127]
Merging changes from 1.0r2c1 into 2.0m0
@
text
@d6 4
a338 3
in

  (* eg. make_toplevel "John" 2; *)
d553 2
d578 3
a580 3
            | "x" => (Windows.postQuitMessage 0;
		    Windows.destroyWindow tetris; 
		    Windows.destroyWindow scoresMainWindow; 
a604 13
      fun mainLoop () =
        let
	  val loop =
	    (Windows.mainLoop (); false)
	    (* normal return, don't loop *)
	    handle 
            MLWorks.Interrupt => true	(* interrupt, continue *)
            | exn => true
        in
	  if loop then mainLoop () else ()
	  (* tail recursive call *)
        end

d619 1
a619 3
      start := true; 
      mainLoop ()
	
d621 12
@


1.12
log
@Making the demo unresizable.
@
text
@d3 1
a3 1
 *  Copyright (C) 1996 Harlequin Ltd
d6 15
@


1.11
log
@Tidied some code and fix problems with adding revision comments.
@
text
@d6 3
d345 3
a347 1
        			[Windows.WS_OVERLAPPED_WINDOW])
@


1.11.1.1
log
@branched from 1.11
@
text
@a5 3
 *  Revision 1.11  1997/04/11  08:52:39  johnh
 *  Tidied some code and fix problems with adding revision comments.
 *
@


1.11.1.2
log
@[Bug #20009]
Making the demo unresizable.
@
text
@a5 6
 *  Revision 1.11.1.1  1997/05/12  10:24:30  hope
 *  branched from 1.11
 *
 *  Revision 1.12  1997/05/14  14:48:52  johnh
 *  Making the demo unresizable.
 *
d345 1
a345 3
        			[Windows.WS_SYSMENU,
				 Windows.WS_MINIMIZEBOX,
				 Windows.WS_OVERLAPPED])
@


1.11.1.3
log
@[Bug #30127]
Updated copyright.
@
text
@d3 1
a3 1
 *  Copyright (C) 1997 The Harlequin Group Limited.  All rights reserved.
a5 4
 *  Revision 1.11.1.2  1997/05/15  08:46:58  daveb
 *  [Bug #20009]
 *  Making the demo unresizable.
 *
@


1.11.1.3.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 4
 *  Revision 1.11.1.3  1997/05/15  13:22:32  daveb
 *  [Bug #30127]
 *  Updated copyright.
 *
@


1.11.1.3.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 4
 *  Revision 1.11.1.3  1997/05/15  13:22:32  daveb
 *  [Bug #30127]
 *  Updated copyright.
 *
@


1.11.1.3.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 4
 *  Revision 1.11.1.3  1997/05/15  13:22:32  daveb
 *  [Bug #30127]
 *  Updated copyright.
 *
@


1.11.1.3.1.2
log
@[Bug #30130]
Merging - Only call Windows.postQuitMessage when delivered.
@
text
@a5 3
 *  Revision 1.11.1.3.1.1  1997/07/28  18:10:31  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d334 3
a550 2
      exception Quit;

d574 3
a576 3
            | "x" => (Windows.destroyWindow tetris; 
		    Windows.destroyWindow scoresMainWindow;
		    raise Quit;
d601 13
d628 3
a630 1
      start := true
a631 12

in

  fun tetris (name, level) = 
    (make_toplevel name level;
     Windows.mainLoop () handle _ => ())

  fun appl (name, level) () = 
    (make_toplevel name level;
     Windows.mainLoop () handle _ => Windows.postQuitMessage 0)

  fun test () = tetris ("You", 3)
@


1.11.1.3.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 4
 *  Revision 1.11.1.3.1.2  1997/08/06  16:15:25  johnh
 *  [Bug #30130]
 *  Merging - Only call Windows.postQuitMessage when delivered.
 *
@


1.10
log
@[Bug #2010]
Fixed various windowing problems.
@
text
@d5 3
a7 3
 * $Log: mswindows:tetris.sml,v 
 *  Revision 1.1  1996/10/03  15:15:00  john
 *  new uni
d26 1
d29 1
a29 1
datatype WidgetClass = Frame | Graphics | Label | Text | RowColumn | Paned | Form 
d31 2
a32 2
  structure Option = MLWorks.Option;
  structure Array = MLWorks.Internal.Array
d34 31
a64 39
  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)


in

val xsize = 12
val ysize = 30

val block_size = 16
(* These are the primitive shapes of the game which get rotated into the
 * various orientations used in the game. *)
val square = [(~1,~1),(~1,0),(0,~1),(0,0)]
val line = [(~2,0),(~1,0),(0,0),(1,0)]
val step = [(~1,0),(0,0),(0,~1),(1,~1)]
val el = [(~1,~1),(~1,0),(0,0),(1,0)]
val tee = [(0,~1),(~1,0),(0,0),(1,0)]

(* reflection - used in reflect the shapes into new shapes *)
fun refl l = 
   map (fn (x:int,y:int) => (y,x)) l

(* rotation - again used to create new shapes *)
fun rot l = 
   map (fn (x:int,y:int) => (~y,x)) l

val shapes =
  [step,
   square,
   line,
   tee,
   refl step,
   el,
   rot (rot tee),
   rot line,
   refl el]

(* make a high score table *)
fun make_high_scores y = 
  Array.tabulate (y, fn i => 
d67 1
a67 1
val highscores = make_high_scores 6;
d69 3
a71 4
    fun make_grid (x,y,tf) =
      Array.tabulate
      (y,
       fn i => Array.array (x,tf))
d73 1
a73 1
    val score = ref 0
d75 2
a76 2
    fun boolToString true = "T"
      | boolToString false = "F"
d78 5
a82 5
      (* functions sub??? access arrays, for example accessing the high
       * score array to see if a high score has been beaten. *)
    fun sub2 (a,x,y) =
      Array.sub (Array.sub (a,y),x)
      handle Array.Subscript => false
d84 3
a86 3
    fun sub_hs (a,y) = 
      Array.sub (a,y)
      handle Array.Subscript => ("", 0)
d88 4
a91 4
      (* functions update??? update the appropriate arrays. *)
    fun update2 (a,x,y,v) =
      Array.update (Array.sub (a,y),x,v)
      handle Array.Subscript => ()
d93 12
a104 12
    fun update_hs (a,y,v) = 
      Array.update (a,y,v)
      handle Array.Subscript => ()
        
      (* Sets up the game grid *)
    val grid = make_grid (xsize,ysize,false)
    val update = make_grid (xsize,ysize,true)      

    fun print_grid () = 
      let 
	fun print xstr = MLWorks.IO.output (MLWorks.IO.terminal_out, xstr)
	fun print_line x y = if x>xsize then 
d108 1
a108 1
	fun print_grid' y = if y>ysize then print ""	
d110 3
a112 3
      in
	print_grid' 0
      end
d114 5
a118 5
      (* This checks the top line in the game grid to see if there are
       * any blocks there, and if there are then this is used to mark
       * the end of a game. *)
    fun not_end 0 = not (sub2(grid, 0, 1))
      | not_end n = (not (sub2(grid, n, 1))) andalso not_end (n-1);
d120 4
a123 2
    local val a = 16807.0 and m = 2147483647.0
    in fun nextrand seed = 
d126 1
a126 1
    end;
d128 1
a128 1
    val rand_num = ref (Int.toLarge 23478645);
d130 6
a135 6
    val current_shape = ref []
    val current_xy = ref (5,0)
    val current_points = ref []
      
      (* down, left and right move the shapes within the grid *)
    fun down ((x,y),shape) = ((x,y+1),shape)
d137 1
a137 1
    fun right ((x,y),shape) = ((x+1,y),shape)
d139 1
a139 1
    fun left ((x,y),shape) = ((x-1,y),shape)
d141 5
a145 5
    (* rot and crot functions are used to rotate a shape within the game grid *) 
    fun rot (xy,shape) =
      (xy,map (fn (x:int,y:int) => (y,~x)) shape)
    fun crot (xy,shape) = 
      (xy,map (fn (x:int,y:int) => (~y,x)) shape)
d147 6
a152 6
    fun get_current_points (xy,shape) =
      let
        val (cx,cy) = xy
      in
        map (fn (x:int,y:int) => (x+cx,y+cy)) shape
      end
d154 19
a172 11
    (* This function is used to make sure that a new position of the current
     * shape is legal, ie. does not cross the boundary of another shape or
     * cross the boundary of the game grid. *)
    fun allowable [] = true
      | allowable ((x,y) :: rest) =
        x >= 0 andalso x < xsize
        andalso y < ysize
        andalso
        (not (sub2 (grid,x,y)))
        andalso
        allowable rest
d174 16
a189 24
    fun member (a,[]) = false
      | member (a,(b::c)) = a = b orelse member (a,c)
        
    fun diff ([],l) = []
      | diff (a::b,l) =
        if member (a,l) then diff (b,l)
        else a :: diff (b,l)
          
    fun move f =
      let
        val old_points = !current_points
        val (new_xy,new_shape) = f (!current_xy,!current_shape)
        val new_points = get_current_points (new_xy,new_shape)
        val newbits = diff (new_points,old_points)
      in
        if allowable newbits
          then
            (current_points := new_points;
             current_xy := new_xy;
             current_shape:= new_shape;
             map
             (fn (x,y) =>
              (update2 (grid,x,y,false);
	       update2 (update,x,y,true)))
d191 4
a194 4
             map
             (fn (x,y) =>
              (update2 (grid,x,y,true);
	       update2 (update,x,y,true)))
d196 19
a214 6
             true)
        else
          false
      end

    exception no_shape;
d216 7
a222 21
    local 
      fun update_rand () = 
          (rand_num := Real.toLargeInt IEEEReal.TO_NEAREST (nextrand 
                       (Real.fromLargeInt (!rand_num)));())

      fun get_shape 0 (a::rest) = a
        | get_shape n (a::rest) = get_shape (n-1) rest
        | get_shape _ [] = raise no_shape;
    in 
      fun next_shape () = (update_rand ();
                           get_shape (Int.fromLarge ((!rand_num) mod 9)) shapes)
    end

    (*  The extent of the drawing area *)
    val xextent = xsize * block_size;
    val yextent = ysize * block_size;

    val default_width = xsize * block_size
    val toplevel_width = default_width + 10
    val graphics_height = ysize * block_size
    val toplevel_height = graphics_height + 34
d224 1
a224 1
   fun munge_string s =
a234 17
  fun set_gui_font window =
    let
      val Windows.OBJECT gui_font =
	Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
	handle
	  Windows.WindowSystemError _ => 
	    Windows.getStockObject (Windows.ANSI_VAR_FONT)
    in
      Windows.sendMessage
        (window,
         Windows.WM_SETFONT,
         Windows.WPARAM gui_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

d237 2
a238 3
      Label => ("STATIC",[Windows.SS_LEFT])
    | Text => ("EDIT",[Windows.WS_BORDER])
    | _ => ("Frame",[]) (* A class of my own devising *)
a249 18
  fun reveal window =
    (Windows.showWindow (window,Windows.SW_SHOWNORMAL);
     Windows.updateWindow window)

  fun set_text_font window =
    let
      val Windows.OBJECT text_font =
	Windows.getStockObject (Windows.ANSI_FIXED_FONT)
    in
      Windows.sendMessage
        (window,
         Windows.WM_SETFONT,
         Windows.WPARAM text_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

d252 2
a253 5
      Text =>
	(set_text_font window;
         set_text (window, ""))
    | Label => set_gui_font window
    | _ => ()
d259 2
a260 1
      reveal window;
a263 10
  fun class_height class =
    case class of
      Frame => 120
    | Graphics => 120
    | Label => 20
    | Text => 25
    | RowColumn => 30
    | Paned => 120
    | Form => 120

d274 1
a274 3
                         styles = (* [Windows.WS_CHILD] @@ *) 
				styles @@ attributes}

d280 34
a313 55
  fun make_message_text (name,parent,attributes) =
    let
      val window =
        create_revealed
        {class = "EDIT",
         name = name,
         width = default_width,
         height = 200,
         parent = parent,
         menu = Windows.nullWord,
         styles = [Windows.WS_CHILD,
                   Windows.WS_BORDER,
                   Windows.WS_HSCROLL,Windows.WS_VSCROLL,
                   Windows.ES_READONLY,
                   Windows.ES_MULTILINE,
                   Windows.ES_AUTOHSCROLL,Windows.ES_AUTOVSCROLL]}
    in
      set_text_font window;
      set_text (window,"");
      (window,window)
    end

    local 
   	fun get_level n = sub_hs (highscores, n)
   	fun save_levels outstrm 0 = ()
     	  | save_levels outstrm n = 
	     let 
		val (lname,lhs) = get_level (n-1)
	     in
		(TextIO.output (outstrm, Int.toString n ^ "\n");
		TextIO.output (outstrm, lname ^ "\n");
		TextIO.output (outstrm, Int.toString lhs ^ "\n");
		save_levels outstrm (n-1);
		TextIO.closeOut outstrm)
	     end

	fun load_levels instrm = if (not (TextIO.endOfStream instrm)) then
	     (let
		fun get_opt NONE = 0
		  | get_opt (SOME s) = s
		val some_level = Int.fromString (TextIO.inputLine (instrm))
		val level = get_opt some_level
	     	val lname = (let val l = TextIO.inputLine (instrm) 
			     in String.substring(l, 0, (String.size l) - 1)
				handle Subscript => "" end)
	     	val some_lhs = Int.fromString (TextIO.inputLine (instrm))
		val lhs = get_opt some_lhs
	      in
		(update_hs (highscores, level - 1, (lname,lhs)); 
		load_levels instrm)
	      end)
		else (TextIO.closeIn instrm)
    in	
	fun save_table filename = save_levels (TextIO.openOut filename) 5
	fun load_table filename = load_levels (TextIO.openIn filename)
d315 1
d317 1
a317 2
	
    end
d319 27
a345 7
(* eg. make_toplevel "John" 2; *)
fun make_toplevel player level =
  let

    val deltime = (5 - level) * 50 + 30
    val del = ref deltime
    val _ = load_table "highscores.tet"; 
d347 1
d349 1
a349 45
    (* This statement uses an MS Windows procedure to initialise the
     * main window of the game. *)
    val window = Windows.mainInit ();
    val applicationShell = window

  val mainWindow = applicationShell
  val menuBar = applicationShell

  val scoresMainWindow = make_managed_widget ("Scores", Form, applicationShell, 
			350,275, 
			[Windows.WS_CAPTION,
			Windows.WS_SYSMENU,
			Windows.WS_MINIMIZEBOX])
  val scoresWindow = make_managed_widget ("", Text, scoresMainWindow,
			350,272, 
			[Windows.ES_MULTILINE, Windows.ES_READONLY,
			Windows.ES_AUTOVSCROLL, Windows.WS_CHILD])
  val scores = scoresWindow

  val tetrisWindow = make_managed_widget ("Tetris", Form, applicationShell, 
			toplevel_height, toplevel_width,
			[Windows.WS_OVERLAPPED_WINDOW])
  val tetris = tetrisWindow

  val _ = Windows.showWindow (scores, Windows.SW_SHOWDEFAULT)
  val _ = Windows.showWindow (tetris, Windows.SW_SHOWDEFAULT)

  val (scroll,message) = make_message_text ("message",mainWindow,[]);

  val _ = Windows.showWindow (scroll, Windows.SW_HIDE);

  val no_message_widget : unit -> unit = env "nt no message widget"

  val set_message_window : Windows.hwnd -> unit = env "nt set message widget"

  fun set_message_widget widget = set_message_window widget

  fun start_messages () = set_message_widget message
  fun stop_messages () = no_message_widget ()

  val _ = start_messages ()

   val title = player

    local 
d351 1
a351 1
    in 
a354 7
    end

    fun draw_image (x,y) =
      let val hdc = Windows.getDC tetris
      in (Windows.fillRect (hdc,Windows.RECT {left=x+1,top=y+1,right=x + block_size,
			bottom=y + block_size}, on_brush);
	Windows.releaseDC (tetris,hdc))
d357 12
a368 3
    fun clear_image (x,y) = (* change brush; draw_image; change brush *)
      let val hdc = Windows.getDC tetris
      in (Windows.fillRect (hdc, Windows.RECT 
d371 2
a372 2
	Windows.releaseDC (tetris,hdc))
      end
d374 68
a441 9
    fun draw a =   (* a always = grid *)
      let
        fun yloop y =
          if y = Array.length a then ()
          else
            let
              val suba = Array.sub (a,y)
              fun subloop x =
                if x = Array.length suba then ()
d443 17
a459 76
		  (if Array.sub ((Array.sub (update,y)),x) then
                     ((if Array.sub (suba,x)
                      then
                         draw_image (x*16,y*16)
                      else
                         clear_image (x*16,y*16));
		       update2 (update,x,y,false))
		   else ();
                   subloop (x+1))
            in
              subloop 0;
              yloop (y+1)
            end
      in
        yloop 0
      end

    val xref = ref (xsize div 2)

    fun arot a =
      let
        fun loop 0 = ()
          | loop i =
            (Array.update (a,i,Array.sub (a,i-1));
             loop (i-1))
      in
        loop (Array.length a - 1)
      end

    (* This function clears rows within the grid which are complete. *)
    fun elim_clear_rows () =
      let
        fun doit n =
          if n = 0
            then ()
          else
            let
              val row = Array.sub (grid,n)
              fun check n =
                if n = Array.length row
                  then true
                else Array.sub (row,n) andalso check (n+1)
            in
              if check 0
                then
                  let
                    fun move_down 0 =
                      (Array.update (grid,0,Array.array (xsize,false));
			Array.update (update, 0, Array.array (xsize,true));
                       draw grid)
                      | move_down n =
                        (Array.update (grid,n,Array.sub (grid,n-1));
			 Array.update (update,n,Array.array (xsize,true));
                         move_down (n-1))
                  in
                    move_down n;
                    doit n
                  end
              else
                doit (n-1)
            end
      in
        doit (Array.length grid - 1)
      end

    fun new_shape () =
      let
        val _ = elim_clear_rows ()
        val shape = next_shape ()
        val dx = !xref
        val _ = xref := (dx + 4) mod xsize
      in
        current_shape := shape;
        current_xy := (dx,0);
        current_points := [];
	if not (move down) then 
d461 2
a462 2
	else ()
      end
d464 1
a464 1
    local 
d466 1
a466 1
    in
d469 1
a469 1
    end
d471 2
a472 2
    val text_buf = ref "";
    fun hs_win hs_str = text_buf := (!text_buf) ^ hs_str
d474 12
a485 24
    local 
      fun get_hs2 l = sub_hs (highscores, l - 1)
      fun print_hs 6 = true
        | print_hs (n:int) = 
          let 
            val (cname, chs) = get_hs2 n
          in 
            (hs_win ((Int.toString n) ^":    "^ Int.toString chs ^"   by   "^ cname ^"\n") ;print_hs (n+1);
             true)
          end
    in
      fun output_hs () = (text_buf := "";hs_win "Level: Score by Player.\n\n"; 
			print_hs 1; hs_win "------------------------\n\n";
			set_text (scoresWindow, !text_buf ))
    end

    val _ = output_hs ();

    fun set_array the_array array_value = 
      let 
	fun clear_line 0 y = update2 (the_array, 0,y,array_value)
	  | clear_line x y = (clear_line (x-1) y; update2 (the_array, x, y, array_value))
	fun clear_whole 0 = clear_line (xsize-1) 0
	  | clear_whole y = (clear_whole (y-1); clear_line (xsize-1) y)
d487 22
a508 6
	clear_whole (ysize - 1)
      end

    fun the_end () = 
      let 	
	val _ = if get_hs < !score then
d511 9
a519 6
      in
    	(output_hs ();hs_win (player^" scored "^ Int.toString (!score) ^ " on level " 
	^ Int.toString level ^".\n\n");
	set_text (scoresWindow, !text_buf);
	save_table "highscores.tet")
      end
a527 2
    val delayTimerID = ref (Windows.setTimer (tetris, 5000000, fn () => ()));
    val start = ref false;
d529 2
a530 1
    val locked = ref 0;
d532 5
a536 5
    fun do_key key = 
      (if ((!locked) = 0) then 
	 (locked := !locked + 1;
          case key of
            " " => if move down then true else 
d545 1
a545 1
          | "s" => (score := 0;
d549 7
a555 7
		    start := true;false)
          | "l" => move right
          | "h" => move left
          | "i" => move rot
          | "o" => move (rot o rot o rot)
          | "x" => (stop_messages ();
		    Windows.postQuitMessage 0;
d559 35
a593 31
          | _ => true;
	 locked := !locked - 1;
	 false)
      else false)

    fun delay 0 = () | delay n = if n>0 then delay (n-1) else ()

    fun timer _ = if ((!start) andalso ((!locked) = 0))
	then (do_key " ";draw grid; ()) else ()

    fun paint_event _ = 
      (set_array update true; draw grid;
	Option.NONE)

    fun key_press (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
      (do_key (str (Char.toLower (chr (Windows.wordToInt wparam)))); 
       draw grid; 
       Option.NONE)

    fun mainLoop frame =
      let
	val loop =
	  (Windows.mainLoop (); false)
	  (* normal return, don't loop *)
	  handle 
          MLWorks.Interrupt => true	(* interrupt, continue X interface *)
          | exn => true
      in
	    if loop then mainLoop frame else stop_messages() 
	(* tail recursive call *)
      end
d595 3
a597 5
    val _ = delayTimerID := Windows.setTimer (tetris, !del, timer)


  in
    Windows.addMessageHandler (tetris, Windows.WM_CLOSE, 
d600 2
a601 2
    Windows.addMessageHandler (tetris, Windows.WM_PAINT, paint_event);
    Windows.addMessageHandler (tetris, Windows.WM_CHAR, key_press);
d603 8
a610 8
    (* The following code initialises the tetris window to start with a new game *)
    score := 0;
    set_array update true;
    set_array grid false;
    new_shape ();
    draw grid;
    start := true; 
    mainLoop ()
d612 1
a612 1
  end
@


1.9
log
@[Bug #1757]
renamed __ieeereal
@
text
@d25 1
a396 1

a413 4
  val tetrisWindow = make_managed_widget ("Tetris", Form, applicationShell, 
			toplevel_height, toplevel_width,
			[Windows.WS_OVERLAPPED_WINDOW])
  val tetris = tetrisWindow
d424 6
d638 1
a638 2
          | "s" => (do_key "S";false)
          | "S" => (score := 0;
d647 1
a647 1
          | "X" => (stop_messages ();
d667 3
a669 1
      (do_key (str (chr (Windows.wordToInt wparam))); draw grid; Option.NONE)
d688 3
a690 4
    Windows.addMessageHandler (tetris,Windows.WM_DESTROY,
                                   fn _ => (stop_messages ();
					    Windows.postQuitMessage 0;
                                            Option.NONE));
d694 4
@


1.8
log
@Added handle around call to substring in load_levels.
Made the quit function destroy the main scores window, not just the text.
@
text
@d24 1
a24 1
require "$.basis.__ieeereal";
@


1.8.1.1
log
@branched from 1.8
@
text
@@


1.8.1.1.1.1
log
@branched from 1.8.1.1
@
text
@@


1.7
log
@[Bug #1824]
putting the highscore text field as a child of a form
@
text
@d371 1
d379 2
a380 1
			     in String.substring(l, 0, (String.size l) - 1) end)
d391 1
a391 1
	    handle IO.Io {function="openIn",...} => save_table filename;
d649 1
a649 1
		    Windows.destroyWindow scores; 
@


1.6
log
@[Bug #1823]
[Bug #1823]
Removing references to capitypes and labelstrings.
@
text
@d416 7
a422 2
  val scoresWindow = make_managed_widget ("Scores", Text, applicationShell,
			350,270, 
d424 1
a424 1
			Windows.ES_AUTOVSCROLL, Windows.WS_OVERLAPPED_WINDOW])
@


1.5
log
@Improved playability and removed ^M.
@
text
@d18 1
a18 3
require "$.mswindows.__windows";
require "$.mswindows.__capitypes";
require "$.mswindows.__labelstrings";
a28 2
  structure CapiTypes = CapiTypes_ ;
  structure LabelStrings = LabelStrings_; 
d36 1
d250 1
a250 1
        (CapiTypes.get_real window,
d268 1
a268 1
      Windows.sendMessage (CapiTypes.get_real window,Windows.WM_SETTEXT,
d284 1
a284 1
        (CapiTypes.get_real window,
a307 3
  fun convert_name (Label,name) = LabelStrings.get_label name
    | convert_name (_,name) = LabelStrings.get_title name

d323 1
a323 1
                         name = convert_name (class,name),
d326 1
a326 1
                         parent = CapiTypes.get_real parent,
a330 2
      val widget = CapiTypes.REAL (window,parent)

d332 2
a333 2
      class_postaction (widget,class);
      widget
d341 1
a341 1
         name = LabelStrings.get_title name,
d344 1
a344 1
         parent = CapiTypes.get_real parent,
a351 1
      val widget = CapiTypes.REAL (window,parent)
d353 3
a355 3
      set_text_font widget;
      set_text (widget,"");
      (widget,widget)
d407 1
a407 1
    val applicationShell = CapiTypes.REAL (window, CapiTypes.NONE) 
d415 1
a415 1
  val tetris = CapiTypes.get_real tetrisWindow
d420 1
a420 1
  val scores = CapiTypes.get_real scoresWindow
d426 1
a426 1
  val _ = Windows.showWindow (CapiTypes.get_real scroll, Windows.SW_HIDE);
d430 1
a430 1
  val set_message_window : CapiTypes.Hwnd -> unit = env "nt set message widget"
d432 1
a432 2
  fun set_message_widget widget =
    set_message_window (CapiTypes.get_real widget)
@


1.5.2.1
log
@branched from 1.5
@
text
@@


1.5.1.1
log
@branched from 1.5
@
text
@@


1.5.1.1.1.1
log
@branched from 1.5.1.1
@
text
@@


1.4
log
@Removing redundant references to structure Windows_
Handled exception Io so that new highscore file is created if none found
@
text
@d1 704
a704 713
(*  ==== Tetris demo  ====
 *
 *  Copyright (C) 1996 Harlequin Ltd
 *
 * $Log: mswindows:tetris.sml,v 
 *  Revision 1.1  1996/10/03  15:15:00  john
 *  new uni
 *  Added new windows version of tetris
 *
 *
*)


(* To play, type:  
 *	make_toplevel <your_name> <level 1 - 5>
 *)

require "$.mswindows.__windows";
require "$.mswindows.__capitypes";
require "$.mswindows.__labelstrings";
require "$.basis.__int";
require "$.basis.__real";
require "$.basis.__string";
require "$.basis.__text_io";
require "$.basis.__io";
require "$.basis.__ieeereal";

(* require "$/basis/__word"; *)

local
datatype WidgetClass = Frame | Graphics | Label | Text | RowColumn | Paned | Form 

  structure CapiTypes = CapiTypes_ ;
  structure LabelStrings = LabelStrings_; 
  structure Option = MLWorks.Option;
  structure Array = MLWorks.Internal.Array

  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)


in
val xsize = 12
val ysize = 30

val block_size = 16
(* These are the primitive shapes of the game which get rotated into the
 * various orientations used in the game. *)
val square = [(~1,~1),(~1,0),(0,~1),(0,0)]
val line = [(~2,0),(~1,0),(0,0),(1,0)]
val step = [(~1,0),(0,0),(0,~1),(1,~1)]
val el = [(~1,~1),(~1,0),(0,0),(1,0)]
val tee = [(0,~1),(~1,0),(0,0),(1,0)]

(* reflection - used in reflect the shapes into new shapes *)
fun refl l = 
   map (fn (x:int,y:int) => (y,x)) l

(* rotation - again used to create new shapes *)
fun rot l = 
   map (fn (x:int,y:int) => (~y,x)) l

val shapes =
  [step,
   square,
   line,
   tee,
   refl step,
   el,
   rot (rot tee),
   rot line,
   refl el]

(* make a high score table *)
fun make_high_scores y = 
  Array.tabulate (y, fn i => 
	("No-one   ", 0))

val highscores = make_high_scores 6;

    fun make_grid (x,y,tf) =
      Array.tabulate
      (y,
       fn i => Array.array (x,tf))
      
    val score = ref 0

    fun boolToString true = "T"
      | boolToString false = "F"
      
      (* functions sub??? access arrays, for example accessing the high
       * score array to see if a high score has been beaten. *)
    fun sub2 (a,x,y) =
      Array.sub (Array.sub (a,y),x)
      handle Array.Subscript => false
        
    fun sub_hs (a,y) = 
      Array.sub (a,y)
      handle Array.Subscript => ("", 0)
	
      (* functions update??? update the appropriate arrays. *)
    fun update2 (a,x,y,v) =
      Array.update (Array.sub (a,y),x,v)
      handle Array.Subscript => ()
        
    fun update_hs (a,y,v) = 
      Array.update (a,y,v)
      handle Array.Subscript => ()
        
      (* Sets up the game grid *)
    val grid = make_grid (xsize,ysize,false)
    val update = make_grid (xsize,ysize,true)      

    fun print_grid () = 
      let 
	fun print xstr = MLWorks.IO.output (MLWorks.IO.terminal_out, xstr)
	fun print_line x y = if x>xsize then 
				print "\n"
			   else (print ((boolToString (sub2 (grid, x,y))) ^ "   ");
				 print_line (x+1) y)
	fun print_grid' y = if y>ysize then print ""	
				else (print_line 0 y; print_grid' (y+1))
      in
	print_grid' 0
      end

      (* This checks the top line in the game grid to see if there are
       * any blocks there, and if there are then this is used to mark
       * the end of a game. *)
    fun not_end 0 = not (sub2(grid, 0, 1))
      | not_end n = (not (sub2(grid, n, 1))) andalso not_end (n-1);
        
    local val a = 16807.0 and m = 2147483647.0
    in fun nextrand seed = 
      let val t = a * seed
      in t - m * real(floor(t/m)) end
    end;

    val rand_num = ref (Int.toLarge 23478645);
  
    val current_shape = ref []
    val current_xy = ref (5,0)
    val current_points = ref []
      
      (* down, left and right move the shapes within the grid *)
    fun down ((x,y),shape) = ((x,y+1),shape)
    
    fun right ((x,y),shape) = ((x+1,y),shape)
    
    fun left ((x,y),shape) = ((x-1,y),shape)
    
    (* rot and crot functions are used to rotate a shape within the game grid *) 
    fun rot (xy,shape) =
      (xy,map (fn (x:int,y:int) => (y,~x)) shape)
    fun crot (xy,shape) = 
      (xy,map (fn (x:int,y:int) => (~y,x)) shape)
      
    fun get_current_points (xy,shape) =
      let
        val (cx,cy) = xy
      in
        map (fn (x:int,y:int) => (x+cx,y+cy)) shape
      end
    
    (* This function is used to make sure that a new position of the current
     * shape is legal, ie. does not cross the boundary of another shape or
     * cross the boundary of the game grid. *)
    fun allowable [] = true
      | allowable ((x,y) :: rest) =
        x >= 0 andalso x < xsize
        andalso y < ysize
        andalso
        (not (sub2 (grid,x,y)))
        andalso
        allowable rest
        
    fun member (a,[]) = false
      | member (a,(b::c)) = a = b orelse member (a,c)
        
    fun diff ([],l) = []
      | diff (a::b,l) =
        if member (a,l) then diff (b,l)
        else a :: diff (b,l)
          
    fun move f =
      let
        val old_points = !current_points
        val (new_xy,new_shape) = f (!current_xy,!current_shape)
        val new_points = get_current_points (new_xy,new_shape)
        val newbits = diff (new_points,old_points)
      in
        if allowable newbits
          then
            (current_points := new_points;
             current_xy := new_xy;
             current_shape:= new_shape;
             map
             (fn (x,y) =>
              (update2 (grid,x,y,false);
	       update2 (update,x,y,true)))
             old_points;
             map
             (fn (x,y) =>
              (update2 (grid,x,y,true);
	       update2 (update,x,y,true)))
             new_points;
             true)
        else
          false
      end

    exception no_shape;

    local 
      fun update_rand () = 
          (rand_num := Real.toLargeInt IEEEReal.TO_NEAREST (nextrand 
                       (Real.fromLargeInt (!rand_num)));())

      fun get_shape 0 (a::rest) = a
        | get_shape n (a::rest) = get_shape (n-1) rest
        | get_shape _ [] = raise no_shape;
    in 
      fun next_shape () = (update_rand ();
                           get_shape (Int.fromLarge ((!rand_num) mod 9)) shapes)
    end

    (*  The extent of the drawing area *)
    val xextent = xsize * block_size;
    val yextent = ysize * block_size;

    val default_width = xsize * block_size
    val toplevel_width = default_width + 10
    val graphics_height = ysize * block_size
    val toplevel_height = graphics_height + 34
  
   fun munge_string s =
    let
      fun munge ([],acc) = MLWorks.String.implode (rev acc)
        | munge ("\013" :: "\010" :: rest,acc) =
          munge (rest, "\010" :: "\013" :: acc)
        | munge ("\n"::rest,acc) = munge (rest,"\013\010" :: acc)
        | munge (c::rest,acc) = munge (rest,c::acc)
    in
      munge (MLWorks.String.explode s,[])
    end

  fun set_gui_font window =
    let
      val Windows.OBJECT gui_font =
	Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
	handle
	  Windows.WindowSystemError _ => 
	    Windows.getStockObject (Windows.ANSI_VAR_FONT)
    in
      Windows.sendMessage
        (CapiTypes.get_real window,
         Windows.WM_SETFONT,
         Windows.WPARAM gui_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

  fun convert_class class =
    case class of
      Label => ("STATIC",[Windows.SS_LEFT])
    | Text => ("EDIT",[Windows.WS_BORDER])
    | _ => ("Frame",[]) (* A class of my own devising *)

  fun set_text (window,s) =
    let
      val string_word = Windows.makeCString (munge_string s)
    in
      Windows.sendMessage (CapiTypes.get_real window,Windows.WM_SETTEXT,
                            Windows.WPARAM (Windows.nullWord),
                            Windows.LPARAM string_word);
      Windows.free string_word
    end

  fun reveal window =
    (Windows.showWindow (window,Windows.SW_SHOWNORMAL);
     Windows.updateWindow window)

  fun set_text_font window =
    let
      val Windows.OBJECT text_font =
	Windows.getStockObject (Windows.ANSI_FIXED_FONT)
    in
      Windows.sendMessage
        (CapiTypes.get_real window,
         Windows.WM_SETFONT,
         Windows.WPARAM text_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

  fun class_postaction (window,class) =
    case class of
      Text =>
	(set_text_font window;
         set_text (window, ""))
    | Label => set_gui_font window
    | _ => ()

  fun create_revealed args =
    let
      val window = Windows.createWindow args
    in
      reveal window;
      window
    end

  fun convert_name (Label,name) = LabelStrings.get_label name
    | convert_name (_,name) = LabelStrings.get_title name

  fun class_height class =
    case class of
      Frame => 120
    | Graphics => 120
    | Label => 20
    | Text => 25
    | RowColumn => 30
    | Paned => 120
    | Form => 120

  fun make_managed_widget (name,class,parent,height,width,attributes) = 
    let
      val (class_name,styles) = convert_class class
      val window =
        create_revealed {class = class_name,
                         name = convert_name (class,name),
                         width = width,
                         height = height,
                         parent = CapiTypes.get_real parent,
                         menu = Windows.nullWord,
                         styles = (* [Windows.WS_CHILD] @@ *) 
				styles @@ attributes}

      val widget = CapiTypes.REAL (window,parent)

    in
      class_postaction (widget,class);
      widget
    end

  fun make_message_text (name,parent,attributes) =
    let
      val window =
        create_revealed
        {class = "EDIT",
         name = LabelStrings.get_title name,
         width = default_width,
         height = 200,
         parent = CapiTypes.get_real parent,
         menu = Windows.nullWord,
         styles = [Windows.WS_CHILD,
                   Windows.WS_BORDER,
                   Windows.WS_HSCROLL,Windows.WS_VSCROLL,
                   Windows.ES_READONLY,
                   Windows.ES_MULTILINE,
                   Windows.ES_AUTOHSCROLL,Windows.ES_AUTOVSCROLL]}
      val widget = CapiTypes.REAL (window,parent)
    in
      set_text_font widget;
      set_text (widget,"");
      (widget,widget)
    end

    local 
   	fun get_level n = sub_hs (highscores, n)
   	fun save_levels outstrm 0 = ()
     	  | save_levels outstrm n = 
	     let 
		val (lname,lhs) = get_level (n-1)
	     in
		(TextIO.output (outstrm, Int.toString n ^ "\n");
		TextIO.output (outstrm, lname ^ "\n");
		TextIO.output (outstrm, Int.toString lhs ^ "\n");
		save_levels outstrm (n-1);
		TextIO.closeOut outstrm)
	     end
	fun load_levels instrm = if (not (TextIO.endOfStream instrm)) then
	     (let
		fun get_opt NONE = 0
		  | get_opt (SOME s) = s
		val some_level = Int.fromString (TextIO.inputLine (instrm))
		val level = get_opt some_level
	     	val lname = (let val l = TextIO.inputLine (instrm) 
			     in String.substring(l, 0, (String.size l) - 1) end)
	     	val some_lhs = Int.fromString (TextIO.inputLine (instrm))
		val lhs = get_opt some_lhs
	      in
		(update_hs (highscores, level - 1, (lname,lhs)); 
		load_levels instrm)
	      end)
		else (TextIO.closeIn instrm)
    in	
	fun save_table filename = save_levels (TextIO.openOut filename) 5
	fun load_table filename = load_levels (TextIO.openIn filename)
	    handle IO.Io {function="openIn",...} => save_table filename;

	
    end


(* eg. make_toplevel "John" 2; *)
fun make_toplevel player level =
  let

    val deltime = (5 - level) * 50 + 30
    val del = ref deltime
    val _ = load_table "highscores.tet"; 


    (* This statement uses an MS Windows procedure to initialise the
     * main window of the game. *)
    val window = Windows.mainInit ();
    val applicationShell = CapiTypes.REAL (window, CapiTypes.NONE) 

  val mainWindow = applicationShell
  val menuBar = applicationShell

  val tetrisWindow = make_managed_widget ("Tetris", Form, applicationShell, 
			toplevel_height, toplevel_width,
			[Windows.WS_OVERLAPPED_WINDOW])
  val tetris = CapiTypes.get_real tetrisWindow
  val scoresWindow = make_managed_widget ("Scores", Text, applicationShell,
			350,270, 
			[Windows.ES_MULTILINE, Windows.ES_READONLY,
			Windows.ES_AUTOVSCROLL, Windows.WS_OVERLAPPED_WINDOW])
  val scores = CapiTypes.get_real scoresWindow
  val _ = Windows.showWindow (scores, Windows.SW_SHOWDEFAULT)
  val _ = Windows.showWindow (tetris, Windows.SW_SHOWDEFAULT)

  val (scroll,message) = make_message_text ("message",mainWindow,[]);

  val _ = Windows.showWindow (CapiTypes.get_real scroll, Windows.SW_HIDE);

  val no_message_widget : unit -> unit = env "nt no message widget"

  val set_message_window : CapiTypes.Hwnd -> unit = env "nt set message widget"

  fun set_message_widget widget =
    set_message_window (CapiTypes.get_real widget)

  fun start_messages () = set_message_widget message
  fun stop_messages () = no_message_widget ()

  val _ = start_messages ()

   val title = player

    local 
	val hdc = Windows.getDC tetris
    in 
	val on_brush = Windows.createSolidBrush (Windows.getTextColor hdc);
	val off_brush = Windows.createSolidBrush (Windows.getBkColor hdc);
	val _ = Windows.releaseDC (tetris,hdc)
    end

    fun draw_image (x,y) =
      let val hdc = Windows.getDC tetris
      in (Windows.fillRect (hdc,Windows.RECT {left=x+1,top=y+1,right=x + block_size,
			bottom=y + block_size}, on_brush);
	Windows.releaseDC (tetris,hdc))
      end

    fun clear_image (x,y) = (* change brush; draw_image; change brush *)
      let val hdc = Windows.getDC tetris
      in (Windows.fillRect (hdc, Windows.RECT 
		{left=x+1,top=y+1, right=x + block_size, bottom=y + block_size}, 
		off_brush);
	Windows.releaseDC (tetris,hdc))
      end

    fun draw a =   (* a always = grid *)
      let
        fun yloop y =
          if y = Array.length a then ()
          else
            let
              val suba = Array.sub (a,y)
              fun subloop x =
                if x = Array.length suba then ()
                else
		  (if Array.sub ((Array.sub (update,y)),x) then
                     ((if Array.sub (suba,x)
                      then
                         draw_image (x*16,y*16)
                      else
                         clear_image (x*16,y*16));
		       update2 (update,x,y,false))
		   else ();
                   subloop (x+1))
            in
              subloop 0;
              yloop (y+1)
            end
      in
        yloop 0
(* 	Windows.updateWindow tetris *)
(*        Xm.sync (display,false) *)
      end

    val xref = ref (xsize div 2)

    fun arot a =
      let
        fun loop 0 = ()
          | loop i =
            (Array.update (a,i,Array.sub (a,i-1));
             loop (i-1))
      in
        loop (Array.length a - 1)
      end

    (* This function clears rows within the grid which are complete. *)
    fun elim_clear_rows () =
      let
        fun doit n =
          if n = 0
            then ()
          else
            let
              val row = Array.sub (grid,n)
              fun check n =
                if n = Array.length row
                  then true
                else Array.sub (row,n) andalso check (n+1)
            in
              if check 0
                then
                  let
                    fun move_down 0 =
                      (Array.update (grid,0,Array.array (xsize,false));
			Array.update (update, 0, Array.array (xsize,true));
                       draw grid)
                      | move_down n =
                        (Array.update (grid,n,Array.sub (grid,n-1));
			 Array.update (update,n,Array.array (xsize,true));
                         move_down (n-1))
                  in
                    move_down n;
                    doit n
                  end
              else
                doit (n-1)
            end
      in
        doit (Array.length grid - 1)
      end

    fun new_shape () =
      let
        val _ = elim_clear_rows ()
        val shape = next_shape ()
        val dx = !xref
        val _ = xref := (dx + 4) mod xsize
      in
        current_shape := shape;
        current_xy := (dx,0);
        current_points := [];
	if not (move down) then 
		(new_shape ();()) 
	else ()
      end

    local 
	val (hname, hs) = sub_hs (highscores, level - 1)
    in
	val get_name = hname;
	val get_hs = hs;
    end

    val text_buf = ref "";
    fun hs_win hs_str = text_buf := (!text_buf) ^ hs_str

    local 
      fun get_hs2 l = sub_hs (highscores, l - 1)
      fun print_hs 6 = true
        | print_hs (n:int) = 
          let 
            val (cname, chs) = get_hs2 n
          in 
            (hs_win ((Int.toString n) ^":    "^ Int.toString chs ^"   by   "^ cname ^"\n") ;print_hs (n+1);
             true)
          end
    in
      fun output_hs () = (text_buf := "";hs_win "Level: Score by Player.\n\n"; 
			print_hs 1; hs_win "------------------------\n\n";
			set_text (scoresWindow, !text_buf ))
    end

    val _ = output_hs ();

    fun set_array the_array array_value = 
      let 
	fun clear_line 0 y = update2 (the_array, 0,y,array_value)
	  | clear_line x y = (clear_line (x-1) y; update2 (the_array, x, y, array_value))
	fun clear_whole 0 = clear_line (xsize-1) 0
	  | clear_whole y = (clear_whole (y-1); clear_line (xsize-1) y)
      in
	clear_whole (ysize - 1)
      end

    fun the_end () = 
      let 	
	val _ = if get_hs < !score then
		(update_hs(highscores, level - 1, (player, !score));())
		else ()
      in
    	(output_hs ();hs_win (player^" scored "^ Int.toString (!score) ^ " on level " 
	^ Int.toString level ^".\n\n");
	set_text (scoresWindow, !text_buf);
	save_table "highscores.tet")
      end

(*    fun test_score () = case (!score) of 
			    50 => del := !del - 150000
			|  100 => del := !del - 150000
			|  150 => del := !del - 150000
			|  200 => del := 0
			|   _  => ()
*)
    val delayTimerID = ref (Windows.setTimer (tetris, 5000000, fn () => ()));
    val start = ref false;

    fun do_key key = (
      case key of
        " " => if move down then true else 
		if not_end xsize then (new_shape (); 
			score := !score + 1;
			true) else
		    	(the_end ();  
(*			set_array grid false;
			set_array update true;
			draw grid;*)
			hs_win "Press 'S' in the Tetris window to start.\n\n";
			set_text (scoresWindow, !text_buf);
			start := false;
			false)
      | "s" => (do_key "S";false)
      | "S" => (score := 0;
		set_array update true;
		set_array grid false;
		draw grid;
		start := true;false)
      | "l" => move right
      | "h" => move left
      | "i" => move rot
      | "o" => move (rot o rot o rot)
(*      | "g" => (new_shape (); true)
      | "G" => (draw grid; true)
       | "n" => (MLWorks.IO.output (MLWorks.IO.terminal_out, "\n"); true) *)
      | "X" => (stop_messages ();
		Windows.postQuitMessage 0;
		Windows.destroyWindow tetris; 
		Windows.destroyWindow scores; 
		false)
(*      | "p" => (print_grid (); false) *)
      | _ => true)

    fun delay 0 = () | delay n = if n>0 then delay (n-1) else ()

    fun timer _ = if (!start) then (do_key " ";draw grid; ()) else ()

    fun paint_event _ = 
      (set_array update true; draw grid;
(*	Windows.updateWindow tetris;
	Windows.sendMessage (tetris, Windows.WM_PAINT, Windows.WPARAM Windows.nullWord,
				Windows.LPARAM Windows.nullWord); *)
	Option.NONE)

    fun key_press (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
      (do_key (str (chr (Windows.wordToInt wparam))); draw grid; Option.NONE)

    fun mainLoop frame =
      let
	val loop =
	  (Windows.mainLoop (); false)
	  (* normal return, don't loop *)
	  handle 
          MLWorks.Interrupt => true	(* interrupt, continue X interface *)
          | exn => true
      in
(*		loop *)
	    if loop then mainLoop frame else stop_messages() 
	(* tail recursive call *)
      end

    val _ = delayTimerID := Windows.setTimer (tetris, !del, timer)


  in
    Windows.addMessageHandler (tetris,Windows.WM_DESTROY,
                                   fn _ => (stop_messages ();
					    Windows.postQuitMessage 0;
                                            Option.NONE));
    Windows.addMessageHandler (tetris, Windows.WM_PAINT, paint_event);
    Windows.addMessageHandler (tetris, Windows.WM_CHAR, key_press);

    new_shape ();
    draw grid;
    start := true; 
    mainLoop ()
	
  end

val _ = make_toplevel "John" 3

end


@


1.3
log
@[Bug #1728]
__integer becomes __int
@
text
@d1 713
a713 709
(*  ==== Tetris demo  ====
 *
 *  Copyright (C) 1996 Harlequin Ltd
 *
 * $Log: mswindows:tetris.sml,v 
 *  Revision 1.1  1996/10/03  15:15:00  john
 *  new uni
 *  Added new windows version of tetris
 *
 *
*)

(* To play, type:  
 *	make_toplevel <your_name> <level 1 - 5>
 *)

require "$.mswindows.__windows";
require "$.mswindows.__capitypes";
require "$.mswindows.__labelstrings";
require "$.basis.__int";
require "$.basis.__real";
require "$.basis.__string";
require "$.basis.__text_io";
require "$.basis.__ieeereal";

(* require "$/basis/__word"; *)

local
datatype WidgetClass = Frame | Graphics | Label | Text | RowColumn | Paned | Form 

  structure CapiTypes = CapiTypes_ ;
  structure Windows = Windows_ ;
  structure LabelStrings = LabelStrings_; 
  structure Option = MLWorks.Option;
  structure Array = MLWorks.Internal.Array

  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)


in
val xsize = 12
val ysize = 30

val block_size = 16
(* These are the primitive shapes of the game which get rotated into the
 * various orientations used in the game. *)
val square = [(~1,~1),(~1,0),(0,~1),(0,0)]
val line = [(~2,0),(~1,0),(0,0),(1,0)]
val step = [(~1,0),(0,0),(0,~1),(1,~1)]
val el = [(~1,~1),(~1,0),(0,0),(1,0)]
val tee = [(0,~1),(~1,0),(0,0),(1,0)]

(* reflection - used in reflect the shapes into new shapes *)
fun refl l = 
   map (fn (x:int,y:int) => (y,x)) l

(* rotation - again used to create new shapes *)
fun rot l = 
   map (fn (x:int,y:int) => (~y,x)) l

val shapes =
  [step,
   square,
   line,
   tee,
   refl step,
   el,
   rot (rot tee),
   rot line,
   refl el]

(* make a high score table *)
fun make_high_scores y = 
  Array.tabulate (y, fn i => 
	("No-one   ", 0))

val highscores = make_high_scores 6;

    fun make_grid (x,y,tf) =
      Array.tabulate
      (y,
       fn i => Array.array (x,tf))
      
    val score = ref 0

    fun boolToString true = "T"
      | boolToString false = "F"
      
      (* functions sub??? access arrays, for example accessing the high
       * score array to see if a high score has been beaten. *)
    fun sub2 (a,x,y) =
      Array.sub (Array.sub (a,y),x)
      handle Array.Subscript => false
        
    fun sub_hs (a,y) = 
      Array.sub (a,y)
      handle Array.Subscript => ("", 0)
	
      (* functions update??? update the appropriate arrays. *)
    fun update2 (a,x,y,v) =
      Array.update (Array.sub (a,y),x,v)
      handle Array.Subscript => ()
        
    fun update_hs (a,y,v) = 
      Array.update (a,y,v)
      handle Array.Subscript => ()
        
      (* Sets up the game grid *)
    val grid = make_grid (xsize,ysize,false)
    val update = make_grid (xsize,ysize,true)      

    fun print_grid () = 
      let 
	fun print xstr = MLWorks.IO.output (MLWorks.IO.terminal_out, xstr)
	fun print_line x y = if x>xsize then 
				print "\n"
			   else (print ((boolToString (sub2 (grid, x,y))) ^ "   ");
				 print_line (x+1) y)
	fun print_grid' y = if y>ysize then print ""	
				else (print_line 0 y; print_grid' (y+1))
      in
	print_grid' 0
      end

      (* This checks the top line in the game grid to see if there are
       * any blocks there, and if there are then this is used to mark
       * the end of a game. *)
    fun not_end 0 = not (sub2(grid, 0, 1))
      | not_end n = (not (sub2(grid, n, 1))) andalso not_end (n-1);
        
    local val a = 16807.0 and m = 2147483647.0
    in fun nextrand seed = 
      let val t = a * seed
      in t - m * real(floor(t/m)) end
    end;

    val rand_num = ref (Int.toLarge 23478645);
  
    val current_shape = ref []
    val current_xy = ref (5,0)
    val current_points = ref []
      
      (* down, left and right move the shapes within the grid *)
    fun down ((x,y),shape) = ((x,y+1),shape)
    
    fun right ((x,y),shape) = ((x+1,y),shape)
    
    fun left ((x,y),shape) = ((x-1,y),shape)
    
    (* rot and crot functions are used to rotate a shape within the game grid *) 
    fun rot (xy,shape) =
      (xy,map (fn (x:int,y:int) => (y,~x)) shape)
    fun crot (xy,shape) = 
      (xy,map (fn (x:int,y:int) => (~y,x)) shape)
      
    fun get_current_points (xy,shape) =
      let
        val (cx,cy) = xy
      in
        map (fn (x:int,y:int) => (x+cx,y+cy)) shape
      end
    
    (* This function is used to make sure that a new position of the current
     * shape is legal, ie. does not cross the boundary of another shape or
     * cross the boundary of the game grid. *)
    fun allowable [] = true
      | allowable ((x,y) :: rest) =
        x >= 0 andalso x < xsize
        andalso y < ysize
        andalso
        (not (sub2 (grid,x,y)))
        andalso
        allowable rest
        
    fun member (a,[]) = false
      | member (a,(b::c)) = a = b orelse member (a,c)
        
    fun diff ([],l) = []
      | diff (a::b,l) =
        if member (a,l) then diff (b,l)
        else a :: diff (b,l)
          
    fun move f =
      let
        val old_points = !current_points
        val (new_xy,new_shape) = f (!current_xy,!current_shape)
        val new_points = get_current_points (new_xy,new_shape)
        val newbits = diff (new_points,old_points)
      in
        if allowable newbits
          then
            (current_points := new_points;
             current_xy := new_xy;
             current_shape:= new_shape;
             map
             (fn (x,y) =>
              (update2 (grid,x,y,false);
	       update2 (update,x,y,true)))
             old_points;
             map
             (fn (x,y) =>
              (update2 (grid,x,y,true);
	       update2 (update,x,y,true)))
             new_points;
             true)
        else
          false
      end

    exception no_shape;

    local 
      fun update_rand () = 
          (rand_num := Real.toLargeInt IEEEReal.TO_NEAREST (nextrand 
                       (Real.fromLargeInt (!rand_num)));())

      fun get_shape 0 (a::rest) = a
        | get_shape n (a::rest) = get_shape (n-1) rest
        | get_shape _ [] = raise no_shape;
    in 
      fun next_shape () = (update_rand ();
                           get_shape (Int.fromLarge ((!rand_num) mod 9)) shapes)
    end

    (*  The extent of the drawing area *)
    val xextent = xsize * block_size;
    val yextent = ysize * block_size;

    val default_width = xsize * block_size
    val toplevel_width = default_width + 10
    val graphics_height = ysize * block_size
    val toplevel_height = graphics_height + 34
  
   fun munge_string s =
    let
      fun munge ([],acc) = MLWorks.String.implode (rev acc)
        | munge ("\013" :: "\010" :: rest,acc) =
          munge (rest, "\010" :: "\013" :: acc)
        | munge ("\n"::rest,acc) = munge (rest,"\013\010" :: acc)
        | munge (c::rest,acc) = munge (rest,c::acc)
    in
      munge (MLWorks.String.explode s,[])
    end

  fun set_gui_font window =
    let
      val Windows.OBJECT gui_font =
	Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
	handle
	  Windows.WindowSystemError _ => 
	    Windows.getStockObject (Windows.ANSI_VAR_FONT)
    in
      Windows.sendMessage
        (CapiTypes.get_real window,
         Windows.WM_SETFONT,
         Windows.WPARAM gui_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

  fun convert_class class =
    case class of
      Label => ("STATIC",[Windows.SS_LEFT])
    | Text => ("EDIT",[Windows.WS_BORDER])
    | _ => ("Frame",[]) (* A class of my own devising *)

  fun set_text (window,s) =
    let
      val string_word = Windows.makeCString (munge_string s)
    in
      Windows.sendMessage (CapiTypes.get_real window,Windows.WM_SETTEXT,
                            Windows.WPARAM (Windows.nullWord),
                            Windows.LPARAM string_word);
      Windows.free string_word
    end

  fun reveal window =
    (Windows.showWindow (window,Windows.SW_SHOWNORMAL);
     Windows.updateWindow window)

  fun set_text_font window =
    let
      val Windows.OBJECT text_font =
	Windows.getStockObject (Windows.ANSI_FIXED_FONT)
    in
      Windows.sendMessage
        (CapiTypes.get_real window,
         Windows.WM_SETFONT,
         Windows.WPARAM text_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

  fun class_postaction (window,class) =
    case class of
      Text =>
	(set_text_font window;
         set_text (window, ""))
    | Label => set_gui_font window
    | _ => ()

  fun create_revealed args =
    let
      val window = Windows.createWindow args
    in
      reveal window;
      window
    end

  fun convert_name (Label,name) = LabelStrings.get_label name
    | convert_name (_,name) = LabelStrings.get_title name

  fun class_height class =
    case class of
      Frame => 120
    | Graphics => 120
    | Label => 20
    | Text => 25
    | RowColumn => 30
    | Paned => 120
    | Form => 120

  fun make_managed_widget (name,class,parent,height,width,attributes) = 
    let
      val (class_name,styles) = convert_class class
      val window =
        create_revealed {class = class_name,
                         name = convert_name (class,name),
                         width = width,
                         height = height,
                         parent = CapiTypes.get_real parent,
                         menu = Windows.nullWord,
                         styles = (* [Windows.WS_CHILD] @@ *) 
				styles @@ attributes}

      val widget = CapiTypes.REAL (window,parent)

    in
      class_postaction (widget,class);
      widget
    end

  fun make_message_text (name,parent,attributes) =
    let
      val window =
        create_revealed
        {class = "EDIT",
         name = LabelStrings.get_title name,
         width = default_width,
         height = 200,
         parent = CapiTypes.get_real parent,
         menu = Windows.nullWord,
         styles = [Windows.WS_CHILD,
                   Windows.WS_BORDER,
                   Windows.WS_HSCROLL,Windows.WS_VSCROLL,
                   Windows.ES_READONLY,
                   Windows.ES_MULTILINE,
                   Windows.ES_AUTOHSCROLL,Windows.ES_AUTOVSCROLL]}
      val widget = CapiTypes.REAL (window,parent)
    in
      set_text_font widget;
      set_text (widget,"");
      (widget,widget)
    end

    local 
   	fun get_level n = sub_hs (highscores, n)
   	fun save_levels outstrm 0 = ()
     	  | save_levels outstrm n = 
	     let 
		val (lname,lhs) = get_level (n-1)
	     in
		(TextIO.output (outstrm, Int.toString n ^ "\n");
		TextIO.output (outstrm, lname ^ "\n");
		TextIO.output (outstrm, Int.toString lhs ^ "\n");
		save_levels outstrm (n-1);
		TextIO.closeOut outstrm)
	     end
	fun load_levels instrm = if (not (TextIO.endOfStream instrm)) then
	     (let
		fun get_opt NONE = 0
		  | get_opt (SOME s) = s
		val some_level = Int.fromString (TextIO.inputLine (instrm))
		val level = get_opt some_level
	     	val lname = (let val l = TextIO.inputLine (instrm) 
			     in String.substring(l, 0, (String.size l) - 1) end)
	     	val some_lhs = Int.fromString (TextIO.inputLine (instrm))
		val lhs = get_opt some_lhs
	      in
		(update_hs (highscores, level - 1, (lname,lhs)); 
		load_levels instrm)
	      end)
		else (TextIO.closeIn instrm)
    in	
	fun save_table filename = save_levels (TextIO.openOut filename) 5
	fun load_table filename = load_levels (TextIO.openIn filename)
    end


(* eg. make_toplevel "John" 2; *)
fun make_toplevel player level =
  let

    val deltime = (5 - level) * 50 + 30
    val del = ref deltime
    val _ = load_table "highscores.tet"; 


    (* This statement uses an MS Windows procedure to initialise the
     * main window of the game. *)
    val window = Windows.mainInit ();
    val applicationShell = CapiTypes.REAL (window, CapiTypes.NONE) 

  val mainWindow = applicationShell
  val menuBar = applicationShell

  val tetrisWindow = make_managed_widget ("Tetris", Form, applicationShell, 
			toplevel_height, toplevel_width,
			[Windows.WS_OVERLAPPED_WINDOW])
  val tetris = CapiTypes.get_real tetrisWindow
  val scoresWindow = make_managed_widget ("Scores", Text, applicationShell,
			350,270, 
			[Windows.ES_MULTILINE, Windows.ES_READONLY,
			Windows.ES_AUTOVSCROLL, Windows.WS_OVERLAPPED_WINDOW])
  val scores = CapiTypes.get_real scoresWindow
  val _ = Windows.showWindow (scores, Windows.SW_SHOWDEFAULT)
  val _ = Windows.showWindow (tetris, Windows.SW_SHOWDEFAULT)

  val (scroll,message) = make_message_text ("message",mainWindow,[]);

  val _ = Windows.showWindow (CapiTypes.get_real scroll, Windows.SW_HIDE);

  val no_message_widget : unit -> unit = env "nt no message widget"

  val set_message_window : CapiTypes.Hwnd -> unit = env "nt set message widget"

  fun set_message_widget widget =
    set_message_window (CapiTypes.get_real widget)

  fun start_messages () = set_message_widget message
  fun stop_messages () = no_message_widget ()

  val _ = start_messages ()

   val title = player

    local 
	val hdc = Windows.getDC tetris
    in 
	val on_brush = Windows.createSolidBrush (Windows.getTextColor hdc);
	val off_brush = Windows.createSolidBrush (Windows.getBkColor hdc);
	val _ = Windows.releaseDC (tetris,hdc)
    end

    fun draw_image (x,y) =
      let val hdc = Windows.getDC tetris
      in (Windows.fillRect (hdc,Windows.RECT {left=x+1,top=y+1,right=x + block_size,
			bottom=y + block_size}, on_brush);
	Windows.releaseDC (tetris,hdc))
      end

    fun clear_image (x,y) = (* change brush; draw_image; change brush *)
      let val hdc = Windows.getDC tetris
      in (Windows.fillRect (hdc, Windows.RECT 
		{left=x+1,top=y+1, right=x + block_size, bottom=y + block_size}, 
		off_brush);
	Windows.releaseDC (tetris,hdc))
      end

    fun draw a =   (* a always = grid *)
      let
        fun yloop y =
          if y = Array.length a then ()
          else
            let
              val suba = Array.sub (a,y)
              fun subloop x =
                if x = Array.length suba then ()
                else
		  (if Array.sub ((Array.sub (update,y)),x) then
                     ((if Array.sub (suba,x)
                      then
                         draw_image (x*16,y*16)
                      else
                         clear_image (x*16,y*16));
		       update2 (update,x,y,false))
		   else ();
                   subloop (x+1))
            in
              subloop 0;
              yloop (y+1)
            end
      in
        yloop 0
(* 	Windows.updateWindow tetris *)
(*        Xm.sync (display,false) *)
      end

    val xref = ref (xsize div 2)

    fun arot a =
      let
        fun loop 0 = ()
          | loop i =
            (Array.update (a,i,Array.sub (a,i-1));
             loop (i-1))
      in
        loop (Array.length a - 1)
      end

    (* This function clears rows within the grid which are complete. *)
    fun elim_clear_rows () =
      let
        fun doit n =
          if n = 0
            then ()
          else
            let
              val row = Array.sub (grid,n)
              fun check n =
                if n = Array.length row
                  then true
                else Array.sub (row,n) andalso check (n+1)
            in
              if check 0
                then
                  let
                    fun move_down 0 =
                      (Array.update (grid,0,Array.array (xsize,false));
			Array.update (update, 0, Array.array (xsize,true));
                       draw grid)
                      | move_down n =
                        (Array.update (grid,n,Array.sub (grid,n-1));
			 Array.update (update,n,Array.array (xsize,true));
                         move_down (n-1))
                  in
                    move_down n;
                    doit n
                  end
              else
                doit (n-1)
            end
      in
        doit (Array.length grid - 1)
      end

    fun new_shape () =
      let
        val _ = elim_clear_rows ()
        val shape = next_shape ()
        val dx = !xref
        val _ = xref := (dx + 4) mod xsize
      in
        current_shape := shape;
        current_xy := (dx,0);
        current_points := [];
	if not (move down) then 
		(new_shape ();()) 
	else ()
      end

    local 
	val (hname, hs) = sub_hs (highscores, level - 1)
    in
	val get_name = hname;
	val get_hs = hs;
    end

    val text_buf = ref "";
    fun hs_win hs_str = text_buf := (!text_buf) ^ hs_str

    local 
      fun get_hs2 l = sub_hs (highscores, l - 1)
      fun print_hs 6 = true
        | print_hs (n:int) = 
          let 
            val (cname, chs) = get_hs2 n
          in 
            (hs_win ((Int.toString n) ^":    "^ Int.toString chs ^"   by   "^ cname ^"\n") ;print_hs (n+1);
             true)
          end
    in
      fun output_hs () = (text_buf := "";hs_win "Level: Score by Player.\n\n"; 
			print_hs 1; hs_win "------------------------\n\n";
			set_text (scoresWindow, !text_buf ))
    end

    val _ = output_hs ();

    fun set_array the_array array_value = 
      let 
	fun clear_line 0 y = update2 (the_array, 0,y,array_value)
	  | clear_line x y = (clear_line (x-1) y; update2 (the_array, x, y, array_value))
	fun clear_whole 0 = clear_line (xsize-1) 0
	  | clear_whole y = (clear_whole (y-1); clear_line (xsize-1) y)
      in
	clear_whole (ysize - 1)
      end

    fun the_end () = 
      let 	
	val _ = if get_hs < !score then
		(update_hs(highscores, level - 1, (player, !score));())
		else ()
      in
    	(output_hs ();hs_win (player^" scored "^ Int.toString (!score) ^ " on level " 
	^ Int.toString level ^".\n\n");
	set_text (scoresWindow, !text_buf);
	save_table "highscores.tet")
      end

(*    fun test_score () = case (!score) of 
			    50 => del := !del - 150000
			|  100 => del := !del - 150000
			|  150 => del := !del - 150000
			|  200 => del := 0
			|   _  => ()
*)
    val delayTimerID = ref (Windows.setTimer (tetris, 5000000, fn () => ()));
    val start = ref false;

    fun do_key key = (
      case key of
        " " => if move down then true else 
		if not_end xsize then (new_shape (); 
			score := !score + 1;
			true) else
		    	(the_end ();  
(*			set_array grid false;
			set_array update true;
			draw grid;*)
			hs_win "Press 'S' in the Tetris window to start.\n\n";
			set_text (scoresWindow, !text_buf);
			start := false;
			false)
      | "s" => (do_key "S";false)
      | "S" => (score := 0;
		set_array update true;
		set_array grid false;
		draw grid;
		start := true;false)
      | "l" => move right
      | "h" => move left
      | "i" => move rot
      | "o" => move (rot o rot o rot)
(*      | "g" => (new_shape (); true)
      | "G" => (draw grid; true)
       | "n" => (MLWorks.IO.output (MLWorks.IO.terminal_out, "\n"); true) *)
      | "X" => (stop_messages ();
		Windows.postQuitMessage 0;
		Windows.destroyWindow tetris; 
		Windows.destroyWindow scores; 
		false)
(*      | "p" => (print_grid (); false) *)
      | _ => true)

    fun delay 0 = () | delay n = if n>0 then delay (n-1) else ()

    fun timer _ = if (!start) then (do_key " ";draw grid; ()) else ()

    fun paint_event _ = 
      (set_array update true; draw grid;
(*	Windows.updateWindow tetris;
	Windows.sendMessage (tetris, Windows.WM_PAINT, Windows.WPARAM Windows.nullWord,
				Windows.LPARAM Windows.nullWord); *)
	Option.NONE)

    fun key_press (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
      (do_key (str (chr (Windows.wordToInt wparam))); draw grid; Option.NONE)

    fun mainLoop frame =
      let
	val loop =
	  (Windows.mainLoop (); false)
	  (* normal return, don't loop *)
	  handle 
          MLWorks.Interrupt => true	(* interrupt, continue X interface *)
          | exn => true
      in
(*		loop *)
	    if loop then mainLoop frame else stop_messages() 
	(* tail recursive call *)
      end

    val _ = delayTimerID := Windows.setTimer (tetris, !del, timer)


  in
    Windows.addMessageHandler (tetris,Windows.WM_DESTROY,
                                   fn _ => (stop_messages ();
					    Windows.postQuitMessage 0;
                                            Option.NONE));
    Windows.addMessageHandler (tetris, Windows.WM_PAINT, paint_event);
    Windows.addMessageHandler (tetris, Windows.WM_CHAR, key_press);

    new_shape ();
    draw grid;
    start := true; 
    mainLoop ()
	
  end

val _ = make_toplevel "John" 3

end


@


1.2
log
@Removing ^M from end of lines.
@
text
@d20 1
a20 1
require "$.basis.__integer";
@


1.2.1.1
log
@branched from 1.2
@
text
@@


1.1
log
@new unit
Added new windows version of tetris.
@
text
@d1 709
a709 705
(*  ==== Tetris demo  ====
 *
 *  Copyright (C) 1996 Harlequin Ltd
 *
 * $Log$
 *
*)

(* To play, type:  
 *	make_toplevel <your_name> <level 1 - 5>
 *)

require "$.mswindows.__windows";
require "$.mswindows.__capitypes";
require "$.mswindows.__labelstrings";
require "$.basis.__integer";
require "$.basis.__real";
require "$.basis.__string";
require "$.basis.__text_io";
require "$.basis.__ieeereal";

(* require "$/basis/__word"; *)

local
datatype WidgetClass = Frame | Graphics | Label | Text | RowColumn | Paned | Form 

  structure CapiTypes = CapiTypes_ ;
  structure Windows = Windows_ ;
  structure LabelStrings = LabelStrings_; 
  structure Option = MLWorks.Option;
  structure Array = MLWorks.Internal.Array

  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)


in
val xsize = 12
val ysize = 30

val block_size = 16
(* These are the primitive shapes of the game which get rotated into the
 * various orientations used in the game. *)
val square = [(~1,~1),(~1,0),(0,~1),(0,0)]
val line = [(~2,0),(~1,0),(0,0),(1,0)]
val step = [(~1,0),(0,0),(0,~1),(1,~1)]
val el = [(~1,~1),(~1,0),(0,0),(1,0)]
val tee = [(0,~1),(~1,0),(0,0),(1,0)]

(* reflection - used in reflect the shapes into new shapes *)
fun refl l = 
   map (fn (x:int,y:int) => (y,x)) l

(* rotation - again used to create new shapes *)
fun rot l = 
   map (fn (x:int,y:int) => (~y,x)) l

val shapes =
  [step,
   square,
   line,
   tee,
   refl step,
   el,
   rot (rot tee),
   rot line,
   refl el]

(* make a high score table *)
fun make_high_scores y = 
  Array.tabulate (y, fn i => 
	("No-one   ", 0))

val highscores = make_high_scores 6;

    fun make_grid (x,y,tf) =
      Array.tabulate
      (y,
       fn i => Array.array (x,tf))
      
    val score = ref 0

    fun boolToString true = "T"
      | boolToString false = "F"
      
      (* functions sub??? access arrays, for example accessing the high
       * score array to see if a high score has been beaten. *)
    fun sub2 (a,x,y) =
      Array.sub (Array.sub (a,y),x)
      handle Array.Subscript => false
        
    fun sub_hs (a,y) = 
      Array.sub (a,y)
      handle Array.Subscript => ("", 0)
	
      (* functions update??? update the appropriate arrays. *)
    fun update2 (a,x,y,v) =
      Array.update (Array.sub (a,y),x,v)
      handle Array.Subscript => ()
        
    fun update_hs (a,y,v) = 
      Array.update (a,y,v)
      handle Array.Subscript => ()
        
      (* Sets up the game grid *)
    val grid = make_grid (xsize,ysize,false)
    val update = make_grid (xsize,ysize,true)      

    fun print_grid () = 
      let 
	fun print xstr = MLWorks.IO.output (MLWorks.IO.terminal_out, xstr)
	fun print_line x y = if x>xsize then 
				print "\n"
			   else (print ((boolToString (sub2 (grid, x,y))) ^ "   ");
				 print_line (x+1) y)
	fun print_grid' y = if y>ysize then print ""	
				else (print_line 0 y; print_grid' (y+1))
      in
	print_grid' 0
      end

      (* This checks the top line in the game grid to see if there are
       * any blocks there, and if there are then this is used to mark
       * the end of a game. *)
    fun not_end 0 = not (sub2(grid, 0, 1))
      | not_end n = (not (sub2(grid, n, 1))) andalso not_end (n-1);
        
    local val a = 16807.0 and m = 2147483647.0
    in fun nextrand seed = 
      let val t = a * seed
      in t - m * real(floor(t/m)) end
    end;

    val rand_num = ref (Int.toLarge 23478645);
  
    val current_shape = ref []
    val current_xy = ref (5,0)
    val current_points = ref []
      
      (* down, left and right move the shapes within the grid *)
    fun down ((x,y),shape) = ((x,y+1),shape)
    
    fun right ((x,y),shape) = ((x+1,y),shape)
    
    fun left ((x,y),shape) = ((x-1,y),shape)
    
    (* rot and crot functions are used to rotate a shape within the game grid *) 
    fun rot (xy,shape) =
      (xy,map (fn (x:int,y:int) => (y,~x)) shape)
    fun crot (xy,shape) = 
      (xy,map (fn (x:int,y:int) => (~y,x)) shape)
      
    fun get_current_points (xy,shape) =
      let
        val (cx,cy) = xy
      in
        map (fn (x:int,y:int) => (x+cx,y+cy)) shape
      end
    
    (* This function is used to make sure that a new position of the current
     * shape is legal, ie. does not cross the boundary of another shape or
     * cross the boundary of the game grid. *)
    fun allowable [] = true
      | allowable ((x,y) :: rest) =
        x >= 0 andalso x < xsize
        andalso y < ysize
        andalso
        (not (sub2 (grid,x,y)))
        andalso
        allowable rest
        
    fun member (a,[]) = false
      | member (a,(b::c)) = a = b orelse member (a,c)
        
    fun diff ([],l) = []
      | diff (a::b,l) =
        if member (a,l) then diff (b,l)
        else a :: diff (b,l)
          
    fun move f =
      let
        val old_points = !current_points
        val (new_xy,new_shape) = f (!current_xy,!current_shape)
        val new_points = get_current_points (new_xy,new_shape)
        val newbits = diff (new_points,old_points)
      in
        if allowable newbits
          then
            (current_points := new_points;
             current_xy := new_xy;
             current_shape:= new_shape;
             map
             (fn (x,y) =>
              (update2 (grid,x,y,false);
	       update2 (update,x,y,true)))
             old_points;
             map
             (fn (x,y) =>
              (update2 (grid,x,y,true);
	       update2 (update,x,y,true)))
             new_points;
             true)
        else
          false
      end

    exception no_shape;

    local 
      fun update_rand () = 
          (rand_num := Real.toLargeInt IEEEReal.TO_NEAREST (nextrand 
                       (Real.fromLargeInt (!rand_num)));())

      fun get_shape 0 (a::rest) = a
        | get_shape n (a::rest) = get_shape (n-1) rest
        | get_shape _ [] = raise no_shape;
    in 
      fun next_shape () = (update_rand ();
                           get_shape (Int.fromLarge ((!rand_num) mod 9)) shapes)
    end

    (*  The extent of the drawing area *)
    val xextent = xsize * block_size;
    val yextent = ysize * block_size;

    val default_width = xsize * block_size
    val toplevel_width = default_width + 10
    val graphics_height = ysize * block_size
    val toplevel_height = graphics_height + 34
  
   fun munge_string s =
    let
      fun munge ([],acc) = MLWorks.String.implode (rev acc)
        | munge ("\013" :: "\010" :: rest,acc) =
          munge (rest, "\010" :: "\013" :: acc)
        | munge ("\n"::rest,acc) = munge (rest,"\013\010" :: acc)
        | munge (c::rest,acc) = munge (rest,c::acc)
    in
      munge (MLWorks.String.explode s,[])
    end

  fun set_gui_font window =
    let
      val Windows.OBJECT gui_font =
	Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
	handle
	  Windows.WindowSystemError _ => 
	    Windows.getStockObject (Windows.ANSI_VAR_FONT)
    in
      Windows.sendMessage
        (CapiTypes.get_real window,
         Windows.WM_SETFONT,
         Windows.WPARAM gui_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

  fun convert_class class =
    case class of
      Label => ("STATIC",[Windows.SS_LEFT])
    | Text => ("EDIT",[Windows.WS_BORDER])
    | _ => ("Frame",[]) (* A class of my own devising *)

  fun set_text (window,s) =
    let
      val string_word = Windows.makeCString (munge_string s)
    in
      Windows.sendMessage (CapiTypes.get_real window,Windows.WM_SETTEXT,
                            Windows.WPARAM (Windows.nullWord),
                            Windows.LPARAM string_word);
      Windows.free string_word
    end

  fun reveal window =
    (Windows.showWindow (window,Windows.SW_SHOWNORMAL);
     Windows.updateWindow window)

  fun set_text_font window =
    let
      val Windows.OBJECT text_font =
	Windows.getStockObject (Windows.ANSI_FIXED_FONT)
    in
      Windows.sendMessage
        (CapiTypes.get_real window,
         Windows.WM_SETFONT,
         Windows.WPARAM text_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
    end
    handle Windows.WindowSystemError _ => ()

  fun class_postaction (window,class) =
    case class of
      Text =>
	(set_text_font window;
         set_text (window, ""))
    | Label => set_gui_font window
    | _ => ()

  fun create_revealed args =
    let
      val window = Windows.createWindow args
    in
      reveal window;
      window
    end

  fun convert_name (Label,name) = LabelStrings.get_label name
    | convert_name (_,name) = LabelStrings.get_title name

  fun class_height class =
    case class of
      Frame => 120
    | Graphics => 120
    | Label => 20
    | Text => 25
    | RowColumn => 30
    | Paned => 120
    | Form => 120

  fun make_managed_widget (name,class,parent,height,width,attributes) = 
    let
      val (class_name,styles) = convert_class class
      val window =
        create_revealed {class = class_name,
                         name = convert_name (class,name),
                         width = width,
                         height = height,
                         parent = CapiTypes.get_real parent,
                         menu = Windows.nullWord,
                         styles = (* [Windows.WS_CHILD] @@ *) 
				styles @@ attributes}

      val widget = CapiTypes.REAL (window,parent)

    in
      class_postaction (widget,class);
      widget
    end

  fun make_message_text (name,parent,attributes) =
    let
      val window =
        create_revealed
        {class = "EDIT",
         name = LabelStrings.get_title name,
         width = default_width,
         height = 200,
         parent = CapiTypes.get_real parent,
         menu = Windows.nullWord,
         styles = [Windows.WS_CHILD,
                   Windows.WS_BORDER,
                   Windows.WS_HSCROLL,Windows.WS_VSCROLL,
                   Windows.ES_READONLY,
                   Windows.ES_MULTILINE,
                   Windows.ES_AUTOHSCROLL,Windows.ES_AUTOVSCROLL]}
      val widget = CapiTypes.REAL (window,parent)
    in
      set_text_font widget;
      set_text (widget,"");
      (widget,widget)
    end

    local 
   	fun get_level n = sub_hs (highscores, n)
   	fun save_levels outstrm 0 = ()
     	  | save_levels outstrm n = 
	     let 
		val (lname,lhs) = get_level (n-1)
	     in
		(TextIO.output (outstrm, Int.toString n ^ "\n");
		TextIO.output (outstrm, lname ^ "\n");
		TextIO.output (outstrm, Int.toString lhs ^ "\n");
		save_levels outstrm (n-1);
		TextIO.closeOut outstrm)
	     end
	fun load_levels instrm = if (not (TextIO.endOfStream instrm)) then
	     (let
		fun get_opt NONE = 0
		  | get_opt (SOME s) = s
		val some_level = Int.fromString (TextIO.inputLine (instrm))
		val level = get_opt some_level
	     	val lname = (let val l = TextIO.inputLine (instrm) 
			     in String.substring(l, 0, (String.size l) - 1) end)
	     	val some_lhs = Int.fromString (TextIO.inputLine (instrm))
		val lhs = get_opt some_lhs
	      in
		(update_hs (highscores, level - 1, (lname,lhs)); 
		load_levels instrm)
	      end)
		else (TextIO.closeIn instrm)
    in	
	fun save_table filename = save_levels (TextIO.openOut filename) 5
	fun load_table filename = load_levels (TextIO.openIn filename)
    end


(* eg. make_toplevel "John" 2; *)
fun make_toplevel player level =
  let

    val deltime = (5 - level) * 50 + 30
    val del = ref deltime
    val _ = load_table "highscores.tet"; 


    (* This statement uses an MS Windows procedure to initialise the
     * main window of the game. *)
    val window = Windows.mainInit ();
    val applicationShell = CapiTypes.REAL (window, CapiTypes.NONE) 

  val mainWindow = applicationShell
  val menuBar = applicationShell

  val tetrisWindow = make_managed_widget ("Tetris", Form, applicationShell, 
			toplevel_height, toplevel_width,
			[Windows.WS_OVERLAPPED_WINDOW])
  val tetris = CapiTypes.get_real tetrisWindow
  val scoresWindow = make_managed_widget ("Scores", Text, applicationShell,
			350,270, 
			[Windows.ES_MULTILINE, Windows.ES_READONLY,
			Windows.ES_AUTOVSCROLL, Windows.WS_OVERLAPPED_WINDOW])
  val scores = CapiTypes.get_real scoresWindow
  val _ = Windows.showWindow (scores, Windows.SW_SHOWDEFAULT)
  val _ = Windows.showWindow (tetris, Windows.SW_SHOWDEFAULT)

  val (scroll,message) = make_message_text ("message",mainWindow,[]);

  val _ = Windows.showWindow (CapiTypes.get_real scroll, Windows.SW_HIDE);

  val no_message_widget : unit -> unit = env "nt no message widget"

  val set_message_window : CapiTypes.Hwnd -> unit = env "nt set message widget"

  fun set_message_widget widget =
    set_message_window (CapiTypes.get_real widget)

  fun start_messages () = set_message_widget message
  fun stop_messages () = no_message_widget ()

  val _ = start_messages ()

   val title = player

    local 
	val hdc = Windows.getDC tetris
    in 
	val on_brush = Windows.createSolidBrush (Windows.getTextColor hdc);
	val off_brush = Windows.createSolidBrush (Windows.getBkColor hdc);
	val _ = Windows.releaseDC (tetris,hdc)
    end

    fun draw_image (x,y) =
      let val hdc = Windows.getDC tetris
      in (Windows.fillRect (hdc,Windows.RECT {left=x+1,top=y+1,right=x + block_size,
			bottom=y + block_size}, on_brush);
	Windows.releaseDC (tetris,hdc))
      end

    fun clear_image (x,y) = (* change brush; draw_image; change brush *)
      let val hdc = Windows.getDC tetris
      in (Windows.fillRect (hdc, Windows.RECT 
		{left=x+1,top=y+1, right=x + block_size, bottom=y + block_size}, 
		off_brush);
	Windows.releaseDC (tetris,hdc))
      end

    fun draw a =   (* a always = grid *)
      let
        fun yloop y =
          if y = Array.length a then ()
          else
            let
              val suba = Array.sub (a,y)
              fun subloop x =
                if x = Array.length suba then ()
                else
		  (if Array.sub ((Array.sub (update,y)),x) then
                     ((if Array.sub (suba,x)
                      then
                         draw_image (x*16,y*16)
                      else
                         clear_image (x*16,y*16));
		       update2 (update,x,y,false))
		   else ();
                   subloop (x+1))
            in
              subloop 0;
              yloop (y+1)
            end
      in
        yloop 0
(* 	Windows.updateWindow tetris *)
(*        Xm.sync (display,false) *)
      end

    val xref = ref (xsize div 2)

    fun arot a =
      let
        fun loop 0 = ()
          | loop i =
            (Array.update (a,i,Array.sub (a,i-1));
             loop (i-1))
      in
        loop (Array.length a - 1)
      end

    (* This function clears rows within the grid which are complete. *)
    fun elim_clear_rows () =
      let
        fun doit n =
          if n = 0
            then ()
          else
            let
              val row = Array.sub (grid,n)
              fun check n =
                if n = Array.length row
                  then true
                else Array.sub (row,n) andalso check (n+1)
            in
              if check 0
                then
                  let
                    fun move_down 0 =
                      (Array.update (grid,0,Array.array (xsize,false));
			Array.update (update, 0, Array.array (xsize,true));
                       draw grid)
                      | move_down n =
                        (Array.update (grid,n,Array.sub (grid,n-1));
			 Array.update (update,n,Array.array (xsize,true));
                         move_down (n-1))
                  in
                    move_down n;
                    doit n
                  end
              else
                doit (n-1)
            end
      in
        doit (Array.length grid - 1)
      end

    fun new_shape () =
      let
        val _ = elim_clear_rows ()
        val shape = next_shape ()
        val dx = !xref
        val _ = xref := (dx + 4) mod xsize
      in
        current_shape := shape;
        current_xy := (dx,0);
        current_points := [];
	if not (move down) then 
		(new_shape ();()) 
	else ()
      end

    local 
	val (hname, hs) = sub_hs (highscores, level - 1)
    in
	val get_name = hname;
	val get_hs = hs;
    end

    val text_buf = ref "";
    fun hs_win hs_str = text_buf := (!text_buf) ^ hs_str

    local 
      fun get_hs2 l = sub_hs (highscores, l - 1)
      fun print_hs 6 = true
        | print_hs (n:int) = 
          let 
            val (cname, chs) = get_hs2 n
          in 
            (hs_win ((Int.toString n) ^":    "^ Int.toString chs ^"   by   "^ cname ^"\n") ;print_hs (n+1);
             true)
          end
    in
      fun output_hs () = (text_buf := "";hs_win "Level: Score by Player.\n\n"; 
			print_hs 1; hs_win "------------------------\n\n";
			set_text (scoresWindow, !text_buf ))
    end

    val _ = output_hs ();

    fun set_array the_array array_value = 
      let 
	fun clear_line 0 y = update2 (the_array, 0,y,array_value)
	  | clear_line x y = (clear_line (x-1) y; update2 (the_array, x, y, array_value))
	fun clear_whole 0 = clear_line (xsize-1) 0
	  | clear_whole y = (clear_whole (y-1); clear_line (xsize-1) y)
      in
	clear_whole (ysize - 1)
      end

    fun the_end () = 
      let 	
	val _ = if get_hs < !score then
		(update_hs(highscores, level - 1, (player, !score));())
		else ()
      in
    	(output_hs ();hs_win (player^" scored "^ Int.toString (!score) ^ " on level " 
	^ Int.toString level ^".\n\n");
	set_text (scoresWindow, !text_buf);
	save_table "highscores.tet")
      end

(*    fun test_score () = case (!score) of 
			    50 => del := !del - 150000
			|  100 => del := !del - 150000
			|  150 => del := !del - 150000
			|  200 => del := 0
			|   _  => ()
*)
    val delayTimerID = ref (Windows.setTimer (tetris, 5000000, fn () => ()));
    val start = ref false;

    fun do_key key = (
      case key of
        " " => if move down then true else 
		if not_end xsize then (new_shape (); 
			score := !score + 1;
			true) else
		    	(the_end ();  
(*			set_array grid false;
			set_array update true;
			draw grid;*)
			hs_win "Press 'S' in the Tetris window to start.\n\n";
			set_text (scoresWindow, !text_buf);
			start := false;
			false)
      | "s" => (do_key "S";false)
      | "S" => (score := 0;
		set_array update true;
		set_array grid false;
		draw grid;
		start := true;false)
      | "l" => move right
      | "h" => move left
      | "i" => move rot
      | "o" => move (rot o rot o rot)
(*      | "g" => (new_shape (); true)
      | "G" => (draw grid; true)
       | "n" => (MLWorks.IO.output (MLWorks.IO.terminal_out, "\n"); true) *)
      | "X" => (stop_messages ();
		Windows.postQuitMessage 0;
		Windows.destroyWindow tetris; 
		Windows.destroyWindow scores; 
		false)
(*      | "p" => (print_grid (); false) *)
      | _ => true)

    fun delay 0 = () | delay n = if n>0 then delay (n-1) else ()

    fun timer _ = if (!start) then (do_key " ";draw grid; ()) else ()

    fun paint_event _ = 
      (set_array update true; draw grid;
(*	Windows.updateWindow tetris;
	Windows.sendMessage (tetris, Windows.WM_PAINT, Windows.WPARAM Windows.nullWord,
				Windows.LPARAM Windows.nullWord); *)
	Option.NONE)

    fun key_press (Windows.WPARAM wparam, Windows.LPARAM lparam) = 
      (do_key (str (chr (Windows.wordToInt wparam))); draw grid; Option.NONE)

    fun mainLoop frame =
      let
	val loop =
	  (Windows.mainLoop (); false)
	  (* normal return, don't loop *)
	  handle 
          MLWorks.Interrupt => true	(* interrupt, continue X interface *)
          | exn => true
      in
(*		loop *)
	    if loop then mainLoop frame else stop_messages() 
	(* tail recursive call *)
      end

    val _ = delayTimerID := Windows.setTimer (tetris, !del, timer)


  in
    Windows.addMessageHandler (tetris,Windows.WM_DESTROY,
                                   fn _ => (stop_messages ();
					    Windows.postQuitMessage 0;
                                            Option.NONE));
    Windows.addMessageHandler (tetris, Windows.WM_PAINT, paint_event);
    Windows.addMessageHandler (tetris, Windows.WM_CHAR, key_press);

    new_shape ();
    draw grid;
    start := true; 
    mainLoop ()
	
  end

val _ = make_toplevel "John" 3

end


@


1.1.1.1
log
@branched from 1.1
@
text
@d5 1
a5 5
 * $Log: mswindows:tetris.sml,v $
 *  Revision 1.1  1996/10/03  15:15:00  johnh
 *  new unit
 *  Added new windows version of tetris.
 *
@
