head	1.2;
access;
symbols
	MLWorks_21c0_1999_03_25:1.2
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2
	MLWorks_20b1c1_1998_05_07:1.2
	MLWorks_20b0_1998_04_07:1.2
	MLWorks_20b0_1998_03_20:1.2
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_workspace_97:1.2.8
	MLWorks_20m1_1997_10_23:1.2
	MLWorks_11r1:1.2.7.1.1.1.1
	MLWorks_11c0_1997_09_09:1.2.7.1.1.1
	MLWorks_10r3:1.2.7.1.3
	MLWorks_10r2_551:1.2.7.1.2
	MLWorks_11:1.2.7.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.2.7.1
	MLWorks_20m0_1997_06_20:1.2
	MLWorks_1_0_r2c2_1997_06_14:1.2.7.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.2.7.1
	MLWorks_1_0_r2c1_1997_05_12:1.2.7
	MLWorks_BugFix_1997_04_24:1.2
	MLWorks_1_0_r2_Win32_1997_04_11:1.2
	MLWorks_1_0_r2_Unix_1997_04_04:1.2
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.2.6.1.1
	MLWorks_1_0_Win32_1996_12_17:1.2.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.2.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.2.4.1
	MLWorks_1_0_Irix_1996_11_28:1.2.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.2.5
	MLWorks_1_0_Unix_1996_11_14:1.2.4
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@# @;


1.2
date	94.10.11.14.55.23;	author daveb;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1
	1.2.4.1
	1.2.5.1
	1.2.6.1
	1.2.7.1
	1.2.8.1;
next	1.1;

1.1
date	94.09.06.15.41.56;	author daveb;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.07.01;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.15.58.08;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.16.28;	author hope;	state Exp;
branches;
next	;

1.2.4.1
date	96.11.14.12.39.32;	author hope;	state Exp;
branches
	1.2.4.1.1.1;
next	;

1.2.4.1.1.1
date	96.11.28.14.51.31;	author hope;	state Exp;
branches;
next	;

1.2.5.1
date	96.11.22.18.00.08;	author hope;	state Exp;
branches;
next	;

1.2.6.1
date	96.12.17.17.39.03;	author hope;	state Exp;
branches
	1.2.6.1.1.1;
next	;

1.2.6.1.1.1
date	97.02.24.11.26.15;	author hope;	state Exp;
branches;
next	;

1.2.7.1
date	97.05.12.10.24.00;	author hope;	state Exp;
branches
	1.2.7.1.1.1
	1.2.7.1.2.1
	1.2.7.1.3.1;
next	;

1.2.7.1.1.1
date	97.07.28.18.10.40;	author daveb;	state Exp;
branches
	1.2.7.1.1.1.1.1;
next	;

1.2.7.1.1.1.1.1
date	97.10.07.11.34.56;	author jkbrook;	state Exp;
branches;
next	;

1.2.7.1.2.1
date	97.09.08.17.03.58;	author daveb;	state Exp;
branches;
next	;

1.2.7.1.3.1
date	97.09.09.13.58.59;	author daveb;	state Exp;
branches;
next	;

1.2.8.1
date	97.11.30.16.49.04;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.2
log
@add was returning a TreeRep instead of a Tree.
@
text
@
structure Btree =
    struct

	datatype 'a TreeRep = E | T of 'a * int * 'a TreeRep * 'a TreeRep
	datatype 'a Tree = Tree of 'a TreeRep * ('a * 'a -> bool)

	local

	    fun size' E = 0
	      | size' (T(_,n,_,_)) = n
	    
	    val weight = 3

	    (*fun N(v,l,r) = T(v,1+size'(l)+size'(r),l,r)*)
	    fun N(v,E,              E)               = T(v,1,E,E)
	      | N(v,E,              r as T(_,n,_,_)) = T(v,n+1,E,r)
	      | N(v,l as T(_,n,_,_),E)               = T(v,n+1,l,E)
	      | N(v,l as T(_,n,_,_),r as T(_,m,_,_)) = T(v,n+m+1,l,r)

	    fun single_L (a,x,T(b,_,y,z)) = N(b,N(a,x,y),z)
	      | single_L _ = raise Match
	    fun single_R (b,T(a,_,x,y),z) = N(a,x,N(b,y,z))
	      | single_R _ = raise Match
	    fun double_L (a,w,T(c,_,T(b,_,x,y),z)) = N(b,N(a,w,x),N(c,y,z))
	      | double_L _ = raise Match
	    fun double_R (c,T(a,_,w,T(b,_,x,y)),z) = N(b,N(a,w,x),N(c,y,z))
	      | double_R _ = raise Match

	    fun T' (v,E,E) = T(v,1,E,E)
	      | T' (v,E,r as T(_,_,E,E))     = T(v,2,E,r)
	      | T' (v,l as T(_,_,E,E),E)     = T(v,2,l,E)

	      | T' (p as (_,E,T(_,_,T(_,_,_,_),E))) = double_L p
	      | T' (p as (_,T(_,_,E,T(_,_,_,_)),E)) = double_R p

	      (* these cases almost never happen with small weight*)
	      | T' (p as (_,E,T(_,_,T(_,ln,_,_),T(_,rn,_,_)))) =
		if ln < rn then single_L p else double_L p
	      | T' (p as (_,T(_,_,T(_,ln,_,_),T(_,rn,_,_)),E)) =
		if rn < ln then single_R p else double_R p

	      | T' (p as (_,E,T(_,_,E,_)))  = single_L p
	      | T' (p as (_,T(_,_,_,E),E))  = single_R p

	      | T' (p as (v,l as T(lv,ln,ll,lr),r as T(rv,rn,rl,rr))) =
		if rn>=weight*ln then (*right is too big*)
		    let val rln = size' rl
			val rrn = size' rr
		    in
			if rln < rrn then  single_L p  else  double_L p
		    end
		    
		else if ln>=weight*rn then  (*left is too big*)
		    let val lln = size' ll
			val lrn = size' lr
		    in
			if lrn < lln then  single_R p  else  double_R p
		    end

		else
	             T(v,ln+rn+1,l,r)

	    fun add' _ (E, 42) = raise Div
	      | add' _ (E, x) = T (x, 1, E, E)
	      | add' lt (tree as T (v, _, l, r), x) =
	        if lt(x,v) then T' (v, add' lt (l,x), r)
		else if lt(v,x) then T' (v, l, add' lt (r,x))
		     else tree

	    fun concat3 lt (E,v,r) = add' lt (r,v)
	      | concat3 lt (l,v,E) = add' lt (l,v)
	      | concat3 lt (l as T(v1,n1,l1,r1), v, r as T(v2,n2,l2,r2)) =
		if weight*n1 < n2 then T' (v2, concat3 lt (l,v,l2), r2)
		else if weight*n2 < n1 then T' (v1, l1, concat3 lt (r1,v,r))
		     else N (v, l, r)

	    fun split_lt lt (E,x) = E
	      | split_lt lt (t as T(v,_,l,r), x) =
		if lt(x,v) then split_lt lt (l,x)
		else if lt(v,x) then concat3 lt (l, v, split_lt lt (r,x))
		     else l

	    fun split_gt lt (E,x) = E
	      | split_gt lt (t as T(v,_,l,r), x) =
		if lt(v,x) then split_gt lt (r, x)
		else if lt(x,v) then concat3 lt (split_gt lt (l,x), v, r)
		     else r

	    fun min (T(v,_,E,_)) = v
	      | min (T(v,_,l,_)) = min l
	      | min _            = raise Match
		
	    and delete' (E,r) = r
	      | delete' (l,E) = l
	      | delete' (l,r) = let val min_elt = min r in
		                  T'(min_elt,l,delmin r)
				end
	    and delmin (T(_,_,E,r)) = r
	      | delmin (T(v,_,l,r)) = T'(v,delmin l,r)
	      | delmin _ = raise Match

	    fun delete'' lt (E, x) = E
	      | delete'' lt (tree as T (v, _, l, r), x) =
		if lt(x,v) then T' (v, delete'' lt (l, x), r)
		else if lt(v,x) then T' (v, l, delete'' lt (r, x))
		else delete' (l, r)

	    fun concat (E,  s2) = s2
	      | concat (s1, E)  = s1
	      | concat (t1 as T(v1,n1,l1,r1), t2 as T(v2,n2,l2,r2)) =
		if weight*n1 < n2 then T'(v2,concat(t1,l2),r2)
		else if weight*n2 < n1 then T'(v1,l1,concat(r1,t2))
		     else T'(min t2,t1, delmin t2)

	    fun fold(f,base,set) =
		let fun fold'(base,E) = base
		      | fold'(base,T(v,_,l,r)) = fold'(f(v,fold'(base,r)),l)
		in 
		    fold'(base,set)
		end

	    fun listfold f b [] = b
	      | listfold f b (h::t) = listfold f (f (h, b)) t
	in
	    fun size (Tree (tree, lt)) = size' tree

	    fun empty lt = Tree (E, lt)

	    fun add (Tree (tree, lt), v) = Tree (add' lt (tree, v), lt)
		
	    fun member (x, Tree (tree, lt)) =
		let fun mem E = false
		      | mem (T(v,_,l,r)) =
			if lt(x,v) then
			  mem l
			else if lt(v,x) then
			  mem r
			else true
		in mem tree end

	    fun delete (Tree (tree, lt), x) = Tree (delete'' lt (tree, x), lt)

	    fun members (Tree (tree, _)) = fold(op::,[],tree)

	    fun fromList (l, lt) =
		Tree (listfold (fn (x,y) => add' lt (y,x)) E l, lt)

	    val eg = fromList ([12,23,1,~54,7896,8,~96], op<)
	end
    end
@


1.2.8.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@@


1.2.7.1
log
@branched from 1.2
@
text
@@


1.2.7.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.2.7.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.2.7.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.2.7.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.2.6.1
log
@branched from 1.2
@
text
@@


1.2.6.1.1.1
log
@branched from 1.2.6.1
@
text
@@


1.2.5.1
log
@branched from 1.2
@
text
@@


1.2.4.1
log
@branched from 1.2
@
text
@@


1.2.4.1.1.1
log
@branched from 1.2.4.1
@
text
@@


1.2.3.1
log
@branched from 1.2
@
text
@@


1.2.2.1
log
@branched from 1.2
@
text
@@


1.2.1.1
log
@branched from 1.2
@
text
@@


1.1
log
@new file
@
text
@d130 1
a130 1
	    fun add (Tree (tree, lt), v) = add' lt (tree, v)
@
