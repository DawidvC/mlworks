head	1.3;
access;
symbols
	MLWorks_21c0_1999_03_25:1.3
	MLWorks_20c1_1998_08_20:1.3
	MLWorks_20c0_1998_08_04:1.3
	MLWorks_20b2c2_1998_06_19:1.3
	MLWorks_20b2_Windows_1998_06_12:1.3
	MLWorks_20b1c1_1998_05_07:1.3
	MLWorks_20b0_1998_04_07:1.2
	MLWorks_20b0_1998_03_20:1.2
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_workspace_97:1.2.8
	MLWorks_20m1_1997_10_23:1.2
	MLWorks_11r1:1.2.7.1.1.1.1
	MLWorks_11c0_1997_09_09:1.2.7.1.1.1
	MLWorks_10r3:1.2.7.1.3
	MLWorks_10r2_551:1.2.7.1.2
	MLWorks_11:1.2.7.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.2.7.1
	MLWorks_20m0_1997_06_20:1.2
	MLWorks_1_0_r2c2_1997_06_14:1.2.7.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.2.7.1
	MLWorks_1_0_r2c1_1997_05_12:1.2.7
	MLWorks_BugFix_1997_04_24:1.2
	MLWorks_1_0_r2_Win32_1997_04_11:1.2
	MLWorks_1_0_r2_Unix_1997_04_04:1.2
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.2.6.1.1
	MLWorks_1_0_Win32_1996_12_17:1.2.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.2.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.2.4.1
	MLWorks_1_0_Irix_1996_11_28:1.2.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.2.5
	MLWorks_1_0_Unix_1996_11_14:1.2.4
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ *  @;


1.3
date	98.05.06.16.28.49;	author johnh;	state Exp;
branches;
next	1.2;

1.2
date	96.05.30.08.54.38;	author nickb;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1
	1.2.4.1
	1.2.5.1
	1.2.6.1
	1.2.7.1
	1.2.8.1;
next	1.1;

1.1
date	95.10.27.11.02.04;	author nickb;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.07.15;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.15.58.26;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.16.45;	author hope;	state Exp;
branches;
next	;

1.2.4.1
date	96.11.14.12.40.09;	author hope;	state Exp;
branches
	1.2.4.1.1.1;
next	;

1.2.4.1.1.1
date	96.11.28.14.51.59;	author hope;	state Exp;
branches;
next	;

1.2.5.1
date	96.11.22.18.00.38;	author hope;	state Exp;
branches;
next	;

1.2.6.1
date	96.12.17.17.39.30;	author hope;	state Exp;
branches
	1.2.6.1.1.1;
next	;

1.2.6.1.1.1
date	97.02.24.11.26.41;	author hope;	state Exp;
branches;
next	;

1.2.7.1
date	97.05.12.10.24.29;	author hope;	state Exp;
branches
	1.2.7.1.1.1
	1.2.7.1.2.1
	1.2.7.1.3.1;
next	;

1.2.7.1.1.1
date	97.07.28.18.10.30;	author daveb;	state Exp;
branches
	1.2.7.1.1.1.1.1;
next	;

1.2.7.1.1.1.1.1
date	97.10.07.11.34.41;	author jkbrook;	state Exp;
branches;
next	;

1.2.7.1.2.1
date	97.09.08.17.03.49;	author daveb;	state Exp;
branches;
next	;

1.2.7.1.3.1
date	97.09.09.13.58.48;	author daveb;	state Exp;
branches;
next	;

1.2.8.1
date	97.11.30.16.48.52;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
File for a profile demo.
@


1.3
log
@[Bug #30292]
Fix compiler warnings.
@
text
@require "simplelib";
require "basis.__array";

functor SimpleLib() : SIMPLELIB = 
struct

  (* list ops *)
      
  fun nil @@ M = M
    | (x :: L) @@ M = x :: (L @@ M)
  fun map f =
    let fun m nil = nil
	  | m (a::r) = f a :: m r
    in  m
    end
      
(* the 'map' function defined above is not good for short lists.
   neither does it have good stack behaviour. The following version
   is optimised for both *)
(*
  local
    fun rev' (done, []) = done
      | rev' (done, x::xs) = rev' (x::done, xs)
  in
    
    (* We seem to use map with short lists a lot so... *)
    fun map f [] = []
      | map f [x] = [f x]
      | map f [x,y] = [f x, f y]
      | map f [x,y,z] = [f x, f y, f z]
      | map f [x,y,z,w] = [f x, f y, f z, f w]
      | map f (x :: y :: z :: w :: rest) =
	let
	  fun map_sub([], done) = rev' ([], done)
	    | map_sub(x :: xs, done) = map_sub (xs, f x :: done)
	in
	  f x :: f y :: f z :: f w :: map_sub(rest, [])
	end
  end
 *)
  exception Hd
  exception Tl
  
  fun hd (a::r) = a | hd nil = raise Hd
  fun tl (a::r) = r | tl nil = raise Tl    

  fun fold f (b,[]) = b
    | fold f (b,a::r) = let fun f2(e,[]) = f(e,b)
			      | f2(e,a::r) = f(e,f2(a,r))
			in f2(a,r)
			end

  (* the version of 'fold' above is not bad, but defines a new closure
   for each complete application. The version below is slightly more efficient. *)
(*
  fun fold f = 
    let
      fun red (acc, []) = acc
	| red (acc, x::xs) = red (f(acc,x), xs)
    in 
      red
    end
*)  
  (* misc *)
    
  fun min(x:real,y:real) = if x<y then x else y
  fun max(x:real,y:real) = if x<y then y else x
  fun abs(x:real) = if x < 0.0 then ~x else x
  exception MaxList
  exception MinList
  exception SumList
  fun max_list [] = raise MaxList | max_list l = fold max (hd l,l)
  fun min_list [] = raise MinList | min_list l = fold min (hd l,l)
  fun sum_list [] = 0.0
    | sum_list (x :: xs) = x + sum_list xs

  (* the version of sum_list above has bad stack discipline. This
   * version uses an accumulator *)
(*
  local
    fun sum_list' ([],acc) = acc
      | sum_list' (x::xs,acc) = sum_list' (xs,x+acc:real)
   in
     fun sum_list l = sum_list' (l,0.0)
   end
 *)
  fun for {from=start:int,step=delta:int, to=endd:int} body =
      if delta>0 andalso endd>=start then 
	  let fun f x = if x > endd then () else (ignore (body x); f(x+delta))
	  in f start
	  end
      else if endd<=start then
	  let fun f x = if x < endd then () else (ignore (body x); f(x+delta))
	  in f start
	  end
      else ()
  fun from(n,m) = if n>m then [] else n::from(n+1,m)

  (* this version of from has bad stack discipline. It would be better
   * to use an accumulator: *)
(*
 local
   fun from'(n,m,acc) = if n > m then acc else from'(n,m-1,m::acc)
 in
   fun from (n,m) = from'(n,m,[])
 end
 *)
  fun flatten [] = []
    | flatten (x::xs) = x @@ flatten xs

  fun pow(x,y) = if y = 0 then 1.0 else x*pow(x,y-1)
      
(* The version of 'pow' above has bad stack behaviour. It is more
 * efficiently coded using an accumulator: *)
(*
  local
    fun pow'(x:real,y,acc) = if y = 0 then acc else pow'(x,y-1,x*acc)
  in
    fun pow(x,y) = if y = 0 then 1.0 else pow'(x,y,1.0)
  end
 *)
   fun min(a:real,b) = if a<b then a else b
   fun max(a:real,b) = if a>b then a else b

   exception Overflow

   type bounds2 = ((int * int) * (int * int))

  type 'a array2 = {rows : int, columns : int, v : 'a Array.array} * bounds2

  fun array2'(rows, columns, e) = 
    if rows<0 orelse columns<0 then raise Size
    else {rows=rows,columns=columns,v=Array.array(rows*columns,e)}
      
  fun sub2' ({rows,columns,v}, s :int, t:int) =
    if s < 0 then raise Subscript
    else if s>=rows then raise Subscript
	 else if t<0 then raise Subscript
	      else if t>=columns then raise Subscript
		   else Array.sub(v,s*columns+t)

  fun update2' ({rows,columns,v}, s : int, t:int, e) : unit = Array.update(v,s*columns+t,e)
    
(* The 2d arrays defined above use integer multiplication on every
access: a slow operation on some machines. The following version does
not: *)
(*
   type 'a array2 = 'a Array.array MLWorks.Vector.vector * ((int * int) * (int * int))

   fun maken (0,f,acc) = acc
     | maken (n,f,acc) = maken (n-1,f,(f ())::acc)

   fun array2' (rows,columns,e) =
     MLWorks.Vector.vector (maken (rows, fn () => Array.array(columns,e),[]))

   fun sub2' (a,s,t) = Array.sub(MLWorks.Vector.sub(a,s),t)

   fun update2' (a,s,t,v) = Array.update(MLWorks.Vector.sub(a,s),t,v)
 *)

  fun array2 (bounds as ((l1,u1),(l2,u2)),v) = (array2'(u1-l1+1,u2-l2+1,v), bounds) 
  fun sub2 ((A,((lb1,ub1), (lb2,ub2))),(k,l)) = sub2'(A, k-lb1, l-lb2) 
  fun  update2 ((A,((lb1,_),(lb2,_))),(k,l), v) = update2'(A,k-lb1,l-lb2,v)

  type 'a array1 = 'a Array.array * (int * int)
  val array1 = fn ((l,u),v) => (Array.array(u-l+1,v),(l,u))
  val sub1 = fn ((A,(l:int,u:int)),i:int) => Array.sub(A,i-l) 
  val update1 = fn((A,(l,_)),i,v) => Array.update(A,i-l,v)
  fun bounds1(_,b) = b

  val grid_max = 20

  val iterations = 3

end
@


1.2
log
@Change in basis names.
@
text
@d89 1
a89 1
	  let fun f x = if x > endd then () else (body x; f(x+delta))
d93 1
a93 1
	  let fun f x = if x < endd then () else (body x; f(x+delta))
@


1.2.8.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@@


1.2.7.1
log
@branched from 1.2
@
text
@@


1.2.7.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.2.7.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.2.7.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.2.7.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.2.6.1
log
@branched from 1.2
@
text
@@


1.2.6.1.1.1
log
@branched from 1.2.6.1
@
text
@@


1.2.5.1
log
@branched from 1.2
@
text
@@


1.2.4.1
log
@branched from 1.2
@
text
@@


1.2.4.1.1.1
log
@branched from 1.2.4.1
@
text
@@


1.2.3.1
log
@branched from 1.2
@
text
@@


1.2.2.1
log
@branched from 1.2
@
text
@@


1.2.1.1
log
@branched from 1.2
@
text
@@


1.1
log
@new unit
File for a profile demo.
@
text
@d2 1
@
