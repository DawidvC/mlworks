head	1.2;
access;
symbols
	MLWorks_21c0_1999_03_25:1.2
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2
	MLWorks_20b1c1_1998_05_07:1.2
	MLWorks_20b0_1998_04_07:1.2
	MLWorks_20b0_1998_03_20:1.2
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_workspace_97:1.2.8
	MLWorks_20m1_1997_10_23:1.2
	MLWorks_11r1:1.2.7.1.1.1.1
	MLWorks_11c0_1997_09_09:1.2.7.1.1.1
	MLWorks_10r3:1.2.7.1.3
	MLWorks_10r2_551:1.2.7.1.2
	MLWorks_11:1.2.7.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.2.7.1
	MLWorks_20m0_1997_06_20:1.2
	MLWorks_1_0_r2c2_1997_06_14:1.2.7.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.2.7.1
	MLWorks_1_0_r2c1_1997_05_12:1.2.7
	MLWorks_BugFix_1997_04_24:1.2
	MLWorks_1_0_r2_Win32_1997_04_11:1.2
	MLWorks_1_0_r2_Unix_1997_04_04:1.2
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.2.6.1.1
	MLWorks_1_0_Win32_1996_12_17:1.2.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.2.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.2.4.1
	MLWorks_1_0_Irix_1996_11_28:1.2.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.2.5
	MLWorks_1_0_Unix_1996_11_14:1.2.4
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ *  @;


1.2
date	96.04.03.13.56.40;	author daveb;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1
	1.2.4.1
	1.2.5.1
	1.2.6.1
	1.2.7.1
	1.2.8.1;
next	1.1;

1.1
date	95.10.26.17.38.09;	author daveb;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.07.09;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.15.58.19;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.16.37;	author hope;	state Exp;
branches;
next	;

1.2.4.1
date	96.11.14.12.39.55;	author hope;	state Exp;
branches
	1.2.4.1.1.1;
next	;

1.2.4.1.1.1
date	96.11.28.14.51.47;	author hope;	state Exp;
branches;
next	;

1.2.5.1
date	96.11.22.18.00.26;	author hope;	state Exp;
branches;
next	;

1.2.6.1
date	96.12.17.17.39.19;	author hope;	state Exp;
branches
	1.2.6.1.1.1;
next	;

1.2.6.1.1.1
date	97.02.24.11.26.30;	author hope;	state Exp;
branches;
next	;

1.2.7.1
date	97.05.12.10.24.17;	author hope;	state Exp;
branches
	1.2.7.1.1.1
	1.2.7.1.2.1
	1.2.7.1.3.1;
next	;

1.2.7.1.1.1
date	97.07.28.18.10.54;	author daveb;	state Exp;
branches
	1.2.7.1.1.1.1.1;
next	;

1.2.7.1.1.1.1.1
date	97.10.07.11.35.22;	author jkbrook;	state Exp;
branches;
next	;

1.2.7.1.2.1
date	97.09.08.17.04.13;	author daveb;	state Exp;
branches;
next	;

1.2.7.1.3.1
date	97.09.09.13.59.15;	author daveb;	state Exp;
branches;
next	;

1.2.8.1
date	97.11.30.16.49.14;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Example trees for the inspector.
@


1.2
log
@Changes for value polymorphism.
@
text
@(* Data Trees
 *
 * (C) Harlequin 1995
 *
 * Useful examples for demonstrating the graphical inspector
 *
 * $Log: data_tree.sml,v $
 *  Revision 1.1  1995/10/26  17:38:09  daveb
 *  new unit
 *  Example trees for the inspector.
 *
 *  Revision 1.1  1995/10/15  22:11:39  brianm
 *  new unit
 *  New file.
 *
 *
 *)

datatype DTree =
         EMPTY      |
	 INT of int | STR of string | TRUE | FALSE |
	 NODE of DTree * DTree list

val e  = EMPTY
val tt = TRUE
val ff = FALSE

fun i x = INT x
fun b x = if x then TRUE else FALSE
fun s x = STR(x)
fun n x l  =  NODE(x,l)
fun n' x y =  NODE(x,[y])

fun l (x :: y) = NODE(x,[(l y)])
  | l nil      = EMPTY

fun copies x =
    let fun doit (0,r) = r
          | doit (i,r) = doit (i-1,x::r)
        fun run n = if n > 0 then doit(n,[]) else []
    in
       run
    end

fun ll n =
    let fun doit (x::xl) =
            let val xl' = doit(xl)
                val v = NODE(x,xl') 
            in
                copies v n
            end
          | doit ([]) = []
    in
        doit
    end

fun flip (NODE(EMPTY,y::l)) = flip(NODE(y,l))
  | flip (NODE(x,y::l))     = NODE(flip(y), map flip (x :: l))
  | flip (NODE(x,[]))       = NODE(EMPTY,[flip(x)])
  | flip (TRUE)      = FALSE
  | flip (FALSE)     = TRUE
  | flip (INT(i))    = INT(~i)
  | flip (STR(s))    = STR( implode ( rev (explode s) ) )
  | flip (a)         = a

fun maptree f =
    let fun mapit (NODE(d,l)) = NODE(mapit(d),map mapit l)
          | mapit (atom)      = f(atom)
    in
        mapit
    end

fun at_end (x,l) =
    let fun doit (a::l,r) = doit(l,a::r)
          | doit ([],r)   = rev(x::r)
    in
        doit(l,[])
    end

fun rotmaptree f = 
    let fun doit (NODE(d,d'::l)) = NODE(doit(d'),map doit (at_end(d,l)))
          | doit (atom)          = f(atom)
    in
        doit
    end

  fun rottree x = rotmaptree (fn x => x) x

    local
      fun doit (NODE(x,y::l), sofar) = doit(y,NODE(x,sofar::l))
          | doit (NODE(x,[]), sofar) = doit(x,sofar)
          | doit (EMPTY, sofar) = sofar
          | doit (atom, sofar)  = NODE(atom,[sofar])
    in
      val revtree =
        fn dt => doit(dt,EMPTY)
    end

    local
      fun doit (NODE(x,y::l), sofar) =
            let val x' = doit(x,EMPTY)
            in
                doit(y,NODE(x',sofar::l))
            end
          | doit (NODE(x,[]), sofar) = doit(x,sofar)
          | doit (EMPTY, sofar) = sofar
          | doit (atom, sofar)  = NODE(atom,[sofar])
    in
      val REVtree =
        fn dt => doit(dt,EMPTY)
    end

    local
      fun doit (NODE(x,y::l), sofar) =
            let val x' = doit(x,sofar)
            in
                doit(y,NODE(x',sofar::l))
            end
          | doit (NODE(x,[]), sofar) = doit(x,sofar)
          | doit (EMPTY, sofar) = sofar
          | doit (atom, sofar)  = NODE(atom,[sofar])
    in
      val topsy_turvey =
        fn dt => doit(dt,EMPTY)
    end

fun subtrees (n as NODE(d,l)) = NODE(n,subtrees(d) :: (map subtrees l))
  | subtrees (atom)           = atom

fun apptree l r =
    let fun doit (NODE(d,lst)) = NODE(d, doit_all lst)
	  | doit (EMPTY)       = r
	  | doit (atom)        = atom

	and doit_all [] = []
	  | doit_all (l) =
	    let fun loop ([a],r)  = rev(doit(a) :: r)
		  | loop (a::l,r) = loop(l,a::r)
		  | loop ([],r)   = rev(r)
	    in
		loop(l,[])
	    end
    in
	doit(l)
    end

fun blend (NODE(d,l)) (NODE(d',l')) =
    let val dd' = blend d d'
        val ll' = blend_list l l'
    in
        NODE(dd',ll')
    end
  | blend EMPTY dt = dt
  | blend dt EMPTY = dt
  | blend l r = NODE(l,[r])

and blend_list (dt::l) (dt'::l') = (blend dt dt') :: (blend_list l l')
  | blend_list [] _ = []
  | blend_list _ [] = []


val s1 = "The Quick Brown Fox Jumps Over The Lazy Dog"
val s2 = "One Small Step for A Man, One Giant Leap For Mankind"
val s3 = "Now Is The Time For All Good Men To Come To The Aid Of The Party"
val s4 = "Hope Springs Eternal In The Human Breast"

val l1 = [s1,s2,s3,s4]
val l2 = l1 @@ l1 @@ l1 @@ l1
val l3 = l2 @@ l2 @@ l2 @@ l2
val l4 = l3 @@ l3 @@ l3 @@ l3

val t1  = (s1,s2,s3,s4)

val t2 = (t1,t1,t1)
val t3 = (t2,t2,t2)
val t4 = (t3,t3,t3)

val t2' = (s1,t1,s2,t1,s3,t1,s4)
val t3' = (s1,t2',s2,t2',s3,t2',s4)
val t4' = (s1,t3',s2,t3',s3,t3',s4)

val x1 = s s1
val x2 = s s2
val x3 = i 42
val x4 = i 23

val y1 = n' (n' x1 x2) (n' x3 x4)
val y2 = l [x1, x2, x3, x4, tt, ff]
val y3 = n x1 [ (n x2 [y1,y1,y1]),  (n x2 [y1,y1,y1]),  (n x2 [y1,y1,y1]) ]
val y4 = n x1 (ll 3 [x2, x3, x4, tt, ff])

val z = ()

fun box (n as NODE(_,[])) = n
  | box (NODE(x,l))          = NODE( box(x), (map box l) )
  | box (atom)               = NODE(atom,[])

fun unbox (NODE(dt,[])) = unbox(dt)
  | unbox (NODE(d,l)) = NODE(unbox d, map unbox l)
  | unbox (atom) = atom

fun atoms dt =
    let fun doit(NODE(d,l), al) =
            let val rl = doit_all(rev l,al)
            in
                doit(d,rl)
            end
          | doit(EMPTY,al) = al
          | doit(atom,al)  = atom :: al

        and doit_all (a::l,al) = doit_all(l,doit(a,al))
          | doit_all ([],al)   = al
    in
        doit(dt,[])
    end

fun max(a:int,b) = if a < b then b else a

fun height (NODE(x,y)) = 1 + height_list(x::y)
  | height (EMPTY)     = 0
  | height (atom)      = 1

and height_list l =
    let fun doit (m,a::l) =
            let val h = height(a)
            in
	       doit(max(m,h),l)
	    end
          | doit(m,[]) = m
    in
       doit(0,l)
    end

fun fsum_list (f,l) =
    let fun doit(s,a::l) = doit(s+f(a),l)
          | doit(s,[])   = s
    in
       doit(0,l)
    end

fun nodes (NODE(x,l)) = 1 + nodes(x) + fsum_list(nodes,l)
  | nodes (EMPTY)     = 0
  | nodes (atom)      = 1

fun tips (NODE(x,l)) = tips(x) + fsum_list(tips,l)
  | tips (EMPTY)     = 0
  | tips (atom)      = 1

fun inodes (NODE(x,l)) = 1 + inodes(x) + fsum_list(inodes,l)
  | inodes (atom)      = 0

fun is_prefix (NODE(d,l),NODE(d',l')) = (d = d') andalso is_prefix_list (l,l')
  | is_prefix (EMPTY, _)   = true
  | is_prefix (atom,atom') = (atom = atom')

and is_prefix_list (a::l,a'::l') = is_prefix(a,a') andalso is_prefix_list(l,l')
  | is_prefix_list ([],_)        = true
  | is_prefix_list (_,_)         = false

fun find test =
    let fun try (dt) = test (dt) orelse scan (dt)
        and scan (NODE(d,l)) = try (d) orelse try_every (l)
          | scan (atom) = test (atom)
        and try_every (a::l) = try(a) orelse try_every(l)
          | try_every ([])   = false

        fun top_level (l as NODE(_,_)) = try(l)
          | top_level (atom) = test(atom)
    in
        top_level
    end

fun is_subtree dt1 dt2 = find (fn dt' => (dt1 = dt')) dt2
@


1.2.8.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 3
 *  Revision 1.2  1996/04/03  13:56:40  daveb
 *  Changes for value polymorphism.
 *
@


1.2.7.1
log
@branched from 1.2
@
text
@a7 3
 *  Revision 1.2  1996/04/03  13:56:40  daveb
 *  Changes for value polymorphism.
 *
@


1.2.7.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 *  Revision 1.2.7.1  1997/05/12  10:24:17  hope
 *  branched from 1.2
 *
@


1.2.7.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 *  Revision 1.2.7.1  1997/05/12  10:24:17  hope
 *  branched from 1.2
 *
@


1.2.7.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 *  Revision 1.2.7.1  1997/05/12  10:24:17  hope
 *  branched from 1.2
 *
@


1.2.7.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 *  Revision 1.2.7.1.1.1  1997/07/28  18:10:54  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.2.6.1
log
@branched from 1.2
@
text
@a7 3
 *  Revision 1.2  1996/04/03  13:56:40  daveb
 *  Changes for value polymorphism.
 *
@


1.2.6.1.1.1
log
@branched from 1.2.6.1
@
text
@a7 3
 *  Revision 1.2.6.1  1996/12/17  17:39:19  hope
 *  branched from 1.2
 *
@


1.2.5.1
log
@branched from 1.2
@
text
@a7 3
 *  Revision 1.2  1996/04/03  13:56:40  daveb
 *  Changes for value polymorphism.
 *
@


1.2.4.1
log
@branched from 1.2
@
text
@a7 3
 *  Revision 1.2  1996/04/03  13:56:40  daveb
 *  Changes for value polymorphism.
 *
@


1.2.4.1.1.1
log
@branched from 1.2.4.1
@
text
@a7 3
 *  Revision 1.2.4.1  1996/11/14  12:39:55  hope
 *  branched from 1.2
 *
@


1.2.3.1
log
@branched from 1.2
@
text
@a7 3
 *  Revision 1.2  1996/04/03  13:56:40  daveb
 *  Changes for value polymorphism.
 *
@


1.2.2.1
log
@branched from 1.2
@
text
@a7 3
 *  Revision 1.2  1996/04/03  13:56:40  daveb
 *  Changes for value polymorphism.
 *
@


1.2.1.1
log
@branched from 1.2
@
text
@a7 3
 *  Revision 1.2  1996/04/03  13:56:40  daveb
 *  Changes for value polymorphism.
 *
@


1.1
log
@new unit
Example trees for the inspector.
@
text
@d8 4
d19 4
a22 5
datatype 'a DTree =
            EMPTY      |
            ANY of 'a  |
	    INT of int | STR of string | TRUE | FALSE |
	    NODE of 'a DTree * 'a DTree list
a27 1
fun a x = ANY x
d87 1
a87 1
val rottree = rotmaptree (fn x => x)
d89 2
a90 2
val revtree =
    let fun doit (NODE(x,y::l), sofar) = doit(y,NODE(x,sofar::l))
d95 1
d99 2
a100 2
val REVtree =
    let fun doit (NODE(x,y::l), sofar) =
d109 1
d113 2
a114 2
val topsy_turvey =
    let fun doit (NODE(x,y::l), sofar) =
d123 1
@
