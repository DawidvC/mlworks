head	1.6;
access;
symbols
	MLWorks_21c0_1999_03_25:1.6
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.5
	MLWorks_20b0_1998_03_20:1.5
	MLWorks_20m2_1998_02_16:1.5
	MLWorks_workspace_97:1.5.1
	MLWorks_20m1_1997_10_23:1.5
	MLWorks_11r1:1.4.7.1.1.1.1
	MLWorks_11c0_1997_09_09:1.4.7.1.1.1
	MLWorks_10r3:1.4.7.1.3
	MLWorks_10r2_551:1.4.7.1.2
	MLWorks_11:1.4.7.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.4.7.1
	MLWorks_20m0_1997_06_20:1.4
	MLWorks_1_0_r2c2_1997_06_14:1.4.7.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.4.7.1
	MLWorks_1_0_r2c1_1997_05_12:1.4.7
	MLWorks_BugFix_1997_04_24:1.4
	MLWorks_1_0_r2_Win32_1997_04_11:1.4
	MLWorks_1_0_r2_Unix_1997_04_04:1.4
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.4.6.1.1
	MLWorks_1_0_Win32_1996_12_17:1.4.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.4.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.4.4.1
	MLWorks_1_0_Irix_1996_11_28:1.4.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.4.5
	MLWorks_1_0_Unix_1996_11_14:1.4.4
	MLWorks_Open_Beta2_1996_10_11:1.4.3
	MLWorks_License_dev:1.4.2
	MLWorks_1_open_beta_1996_09_13:1.4.1
	MLWorks_Open_Beta_1996_08_22:1.3
	MLWorks_Beta_1996_07_02:1.3
	MLWorks_Beta_1996_06_07:1.3
	MLWorks_Beta_1996_06_06:1.3
	MLWorks_Beta_1996_06_05:1.3
	MLWorks_Beta_1996_06_03:1.3
	MLWorks_Beta_1996_05_31:1.3
	MLWorks_Beta_1996_05_30:1.3;
locks; strict;
comment	@ *  @;


1.6
date	98.05.07.08.27.30;	author johnh;	state Exp;
branches;
next	1.5;

1.5
date	97.07.15.11.17.06;	author brucem;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	96.09.03.14.52.14;	author johnh;	state Exp;
branches
	1.4.1.1
	1.4.2.1
	1.4.3.1
	1.4.4.1
	1.4.5.1
	1.4.6.1
	1.4.7.1;
next	1.3;

1.3
date	96.02.26.15.57.18;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.10.11.12.59.29;	author io;	state Exp;
branches;
next	1.1;

1.1
date	95.06.20.14.29.55;	author matthew;	state Exp;
branches;
next	;

1.4.1.1
date	96.09.13.11.07.33;	author hope;	state Exp;
branches;
next	;

1.4.2.1
date	96.10.07.15.58.42;	author hope;	state Exp;
branches;
next	;

1.4.3.1
date	96.10.17.11.17.02;	author hope;	state Exp;
branches;
next	;

1.4.4.1
date	96.11.14.12.40.30;	author hope;	state Exp;
branches
	1.4.4.1.1.1;
next	;

1.4.4.1.1.1
date	96.11.28.14.52.20;	author hope;	state Exp;
branches;
next	;

1.4.5.1
date	96.11.22.18.00.58;	author hope;	state Exp;
branches;
next	;

1.4.6.1
date	96.12.17.17.39.51;	author hope;	state Exp;
branches
	1.4.6.1.1.1;
next	;

1.4.6.1.1.1
date	97.02.24.11.27.03;	author hope;	state Exp;
branches;
next	;

1.4.7.1
date	97.05.12.10.24.51;	author hope;	state Exp;
branches
	1.4.7.1.1.1
	1.4.7.1.2.1
	1.4.7.1.3.1;
next	;

1.4.7.1.1.1
date	97.07.28.18.10.09;	author daveb;	state Exp;
branches
	1.4.7.1.1.1.1.1;
next	;

1.4.7.1.1.1.1.1
date	97.10.07.11.34.08;	author jkbrook;	state Exp;
branches;
next	;

1.4.7.1.2.1
date	97.09.08.17.03.28;	author daveb;	state Exp;
branches;
next	;

1.4.7.1.3.1
date	97.09.09.13.58.05;	author daveb;	state Exp;
branches;
next	;

1.5.1.1
date	97.11.30.16.47.09;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Demo for graphics stuff
@


1.6
log
@[Bug #30392]
Fix compiler warnings.
@
text
@(* MLWorks graphics demo *)

(* To use:
 *
 * make this file
 * > test (5,6) (* for example *)
 *
 * Press "x" to break out of event loop
 * Click in the window or press any key (apart from "x") for other happenings
 *)

require "$.motif.__xm";
local
  (* ix, iy are increments for moving dobbs image *)
  fun make_toplevel (ix, iy) = 
    let
      val name = "mlworks"
      and class = "MLWorks"
      and title = "test"

      (* Extent of drawing area *)
      and xextent = 700
      and yextent = 700

      val applicationShell = 
        Xm.initialize
        (name, class, [(Xm.TITLE, Xm.STRING title), (Xm.ICON_NAME, Xm.STRING title)]);
        
      val scroll = Xm.Widget.createManaged
        ("drawScroll", Xm.Widget.SCROLLED_WINDOW,applicationShell,[])
        
      val main =
        Xm.Widget.createManaged
        ("drawPane", Xm.Widget.DRAWING_AREA, scroll,[])
        
      val vscroll = Xm.Widget.createManaged
        ("drawVScroll", Xm.Widget.SCROLLBAR,scroll,
         [(Xm.ORIENTATION, Xm.ORIENTATION_VALUE Xm.VERTICAL),
          (Xm.MAXIMUM, Xm.INT yextent)])
        
      val hscroll = Xm.Widget.createManaged
        ("drawHScroll", Xm.Widget.SCROLLBAR,scroll,
         [(Xm.ORIENTATION, Xm.ORIENTATION_VALUE Xm.HORIZONTAL),
          (Xm.MAXIMUM, Xm.INT xextent)])
        
      val _ = Xm.Widget.valuesSet
        (scroll,
         [(Xm.VERTICAL_SCROLLBAR,Xm.WIDGET vscroll),
          (Xm.HORIZONTAL_SCROLLBAR,Xm.WIDGET hscroll),
          (Xm.WORK_WINDOW,Xm.WIDGET main)])
        
      (* offset of start of window *)
      val xi_ref = ref 0
      val yi_ref = ref 0
        
      val _ = Xm.Widget.realize applicationShell
        
      fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
      val get_widget_resource : Xm.widget * string * string -> Xm.font = env "x get application resource"
        
      val myfont = get_widget_resource (applicationShell,"foo","Foo")
      val window= Xm.Widget.window main
      val display = Xm.Widget.display main
      val screen = Xm.Widget.screen main
      val pix1 = 
        let
          val pixmap = Xm.Pixmap.create (display,window,8,8,1)
          val gc1 = Xm.GC.create (display,pixmap,[Xm.GC.FONT myfont,
                                                  Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                                  Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen)])
          val gc2 = Xm.GC.create (display,pixmap,[Xm.GC.FONT myfont,
                                                  Xm.GC.FOREGROUND (Xm.Pixel.screenWhite screen),
                                                  Xm.GC.BACKGROUND (Xm.Pixel.screenBlack screen)])
          (* draw a pattern in the pixmap *)
          fun fill () =
            let
              fun aux1 8 = ()
                | aux1 i =
                let
                  fun aux2 8 = ()
                    | aux2 j =
                    (if (i+j) mod 3 = 0 then Xm.Draw.point (display,pixmap,gc1,i,j)
                     else Xm.Draw.point (display,pixmap,gc2,i,j);
                       aux2 (j+1))
                in
                  aux2 0;
                  aux1 (i+1)
                end
            in
              aux1 0
            end
        in
          fill ();
          (* ought to destroy gc1 and gc2 at this point *)
          pixmap
        end
      
      exception Size
      fun size widget =
        case Xm.Widget.valuesGet (widget,[Xm.WIDTH,Xm.HEIGHT]) of
          [Xm.INT width,Xm.INT height] => (width,height) 
        | _ => raise Size
            
      local
        val dobbs = Xm.Pixmap.get (screen,"minidobb.xbm",
                                   Xm.Pixel.screenBlack screen,Xm.Pixel.screenWhite screen)
          
        val dobbs_mask = Xm.Pixmap.get (screen,"minidobb-mask.xbm",
                                        Xm.Pixel.screenBlack screen,Xm.Pixel.screenWhite screen)
          
        val dobbs_mask_bitmap = Xm.Pixmap.create (display,window,64,75,1)
          
        val mask_gc = Xm.GC.create (display,dobbs_mask_bitmap,[Xm.GC.FONT myfont,
                                                               Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                                               Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen)])
          
        val _ = Xm.Draw.copyPlane (display,dobbs_mask,dobbs_mask_bitmap,mask_gc,0,0,64,75,0,0,1);
          
        val image_gc = Xm.GC.create (display,window,[Xm.GC.FONT myfont,
                                                     Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                                     Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen),
                                                     Xm.GC.CLIP_MASK (Xm.GC.PIXMAP dobbs_mask_bitmap)])
      in
        fun draw_image (x,y) =
          let
            val xi = ~(!xi_ref)
            val yi = ~(!yi_ref)
          in
            Xm.GC.change (display,image_gc,
                          [Xm.GC.CLIP_X_ORIGIN (x+xi),
                           Xm.GC.CLIP_Y_ORIGIN (y+yi)]);
            Xm.Draw.copyArea (display,dobbs,window,image_gc,0,0,64,75,x+xi,y+yi)
          end
      end
    
      (* The bouncing dobbs feature *)
    
      fun new_pos (widget,coords) =
        let
          val (width,height) = size widget
          fun doone ((x,y),(ix,iy)) =
            let
              val x' = x + ix
              val y' = y + iy
              val ix = 
                if x' < 0 orelse x' > (width-64)
                  then ~ix
                else ix
              val iy = 
                if y' < 0 orelse y' > (height-75)
                  then ~iy
                else iy;
              val newx = x + ix
              val newy = y + iy
            in
              ((newx,newy),(ix,iy))
            end
        in
          map doone coords
        end
      
      val coords = ref [] : ((int * int) * (int * int)) list ref
        
      fun bounce_dobbs () =
        case !coords of
          [] => ()
        | _ => 
            let
              fun loop 0 = ()
                | loop n =
                (coords := new_pos (main,!coords);
                 ignore (map (draw_image o #1) (rev (!coords)));
                 Xm.sync (display,false);
                 loop (n-1))
            in
              loop 100
            end
          
      local
        val gc1 = Xm.GC.create (display,window,[(* Xm.GC.FUNCTION Xm.GC.XOR, *)
                                                Xm.GC.FONT myfont,
                                                Xm.GC.LINE_WIDTH 20,
                                                Xm.GC.CAP_STYLE Xm.GC.CAP_ROUND,
                                                Xm.GC.JOIN_STYLE Xm.GC.JOIN_ROUND,
                                                Xm.GC.FILL_STYLE Xm.GC.FILL_STIPPLED,
                                                Xm.GC.STIPPLE pix1,
                                                Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                                Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen)])
          
        val gc2 = Xm.GC.create (display,window,[Xm.GC.FONT myfont,
                                                Xm.GC.LINE_STYLE Xm.GC.LINE_ONOFF_DASH,
                                                Xm.GC.DASHES 7,
                                                Xm.GC.DASH_OFFSET 3,
                                                Xm.GC.CAP_STYLE Xm.GC.CAP_ROUND,
                                                Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                                Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen)])
        val gc3 = Xm.GC.create (display,window,[Xm.GC.FONT myfont,
                                                Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                                Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen)])
      in
        fun draw_picture () =
          let
            val xi = ~(!xi_ref)
            val yi = ~(!yi_ref)
            val (width,height) = (xextent,yextent)(* size main *)
            val x1 = 20
            val x2 = width - 20
            val y1 = 20
            val y2 = height - 20
            (* Change the GC here so we get the right offset for stippling *)
            val _ = Xm.GC.change (display,gc1,
                                  [Xm.GC.TS_X_ORIGIN xi,
                                   Xm.GC.TS_Y_ORIGIN yi])
          in
            Xm.Draw.point (display,window,gc3,100+xi,100+yi);
            Xm.Draw.points (display,window,gc3,[(350+xi,150+yi),(2,2),(2,2),(2,2),(2,2),(2,2),(2,2)],Xm.Draw.PREVIOUS);
            Xm.Draw.fillPolygon (display,window,gc1,[(40+xi,40+yi),(151+xi,167+yi),(199+xi,100+yi),(275+xi,232+yi)],Xm.Draw.COMPLEX,Xm.Draw.ORIGIN);
            Xm.Draw.segments (display,window,gc3,[(10+xi,320+yi,130+xi,440+yi),(140+xi,430+yi,20+xi,310+yi)]);
            Xm.Draw.fillRectangle (display,window,gc3,40+xi,280+yi,100,50);
            Xm.Draw.rectangle (display,window,gc3,20+xi,20+yi,200,150);
            Xm.Draw.rectangles (display,window,gc3,[(20+xi,40+yi,200,150),(22+xi,42+yi,200,150),(24+xi,44+yi,200,150)]);
            Xm.Draw.fillRectangles (display,window,gc3,[(140+xi,240+yi,100,50),(144+xi,244+yi,100,50),(148+xi,248+yi,100,50),(152+xi,252+yi,100,50)]);
            Xm.Draw.fillArc (display,window,gc1,280+xi,280+yi,140,130,0,64 * 360);
            Xm.Draw.arcs (display,window,gc3,[(280+xi,280+yi,140,130,0,64 * 360),(275+xi,285+yi,150,130,0,64 * 360),(270+xi,290+yi,160,130,0,64 * 360),(265+xi,295+yi,170,130,0,64 * 360)]);
            Xm.Draw.lines(display,window,gc1,[(x1+xi,y1+yi),(x1+xi,y2+yi),(x2+xi,y2+yi),(x2+xi,y1+yi),(y1+xi,x1+yi)],Xm.Draw.ORIGIN);
            Xm.Draw.line (display,window,gc2,x1+xi,y1+yi,x2+xi,y2+yi);
            Xm.Draw.line (display,window,gc2,x1+xi,y2+yi,x2+xi,y1+yi);
            Xm.Draw.imageString (display,window,gc1,20+xi,(height div 3)+yi,"Hello World");
            Xm.Draw.string (display,window,gc2,20+xi,2 * (height div 3)+yi,"Hello World");
            ignore (map (draw_image o #1) (rev (!coords)))
          end
        
        (* Scrolling *)
        (* These need to be a little careful about the way the copy area is done *)
        fun horizontal_scroll_callback data =
          let
            val new_xi = case Xm.Widget.valuesGet (hscroll,[Xm.VALUE]) of
			[Xm.INT x] => x
			| _ => raise Fail "new_xi"
            val (width,height) = size main
            val old_xi = !xi_ref
            val delta = old_xi-new_xi
          in
            xi_ref := new_xi;
            if delta > 0
              then Xm.Draw.copyArea (display,window,window,gc3,~delta,0,width+delta,height,0,0)
            else Xm.Draw.copyArea (display,window,window,gc3,0,0,width-delta,height,delta,0);
              draw_picture ()
          end

        fun vertical_scroll_callback data =
          let
            val new_yi = case Xm.Widget.valuesGet (vscroll,[Xm.VALUE]) of
				[Xm.INT y] => y
			| _ => raise Fail "new_yi"
            val (width,height) = size main
            val old_yi = !yi_ref
            val delta = old_yi-new_yi
          in
            yi_ref := new_yi;
            if delta > 0
              then Xm.Draw.copyArea (display,window,window,gc3,0,~delta,width,height+delta,0,0)
            else Xm.Draw.copyArea (display,window,window,gc3,0,0,width,height-delta,0,delta);
              draw_picture ()
          end
        
      end
    
      fun expose_callback data =
        draw_picture ()
        
      fun clearit _ =
        if Xm.Widget.isRealized main
          then Xm.Draw.clearArea (display,Xm.Widget.window main,0,0,0,0,true)
        else ()
          
      fun resize_callback data = clearit ()
        
      exception Halt
      
      fun input_callback data =
        let
          val (reason,event) = Xm.Callback.convertAny data
        in
          case event of
            Xm.Event.BUTTON_PRESS 
            (Xm.Event.BUTTON_EVENT {x,y,...}) => 
              (coords := ((x,y),(ix,iy)) :: !coords;
               draw_image (x,y))
          | (Xm.Event.KEY_PRESS (Xm.Event.KEY_EVENT {key = "x",...})) =>
             Xm.Widget.destroy applicationShell
          | (Xm.Event.KEY_PRESS _) =>
                bounce_dobbs ()
          | _ => ()
        end
    in

      Xm.Callback.add (main,Xm.Callback.EXPOSE,expose_callback);
      Xm.Callback.add (main,Xm.Callback.INPUT,input_callback);
      Xm.Callback.add (main,Xm.Callback.RESIZE,resize_callback);
      Xm.Callback.add (hscroll,Xm.Callback.VALUE_CHANGED,horizontal_scroll_callback);
      Xm.Callback.add (vscroll,Xm.Callback.VALUE_CHANGED,vertical_scroll_callback);
      Xm.Callback.add (hscroll,Xm.Callback.DRAG,horizontal_scroll_callback);
      Xm.Callback.add (vscroll,Xm.Callback.DRAG,vertical_scroll_callback)
    end;
    
in
  
  fun test data = make_toplevel data;
  fun runx () = Xm.mainLoop ();
  fun appl data = (test data; runx ())
    
end;



@


1.5
log
@[Bug #30199]
#Changes to structure names.
@
text
@d172 1
a172 1
                 map (draw_image o #1) (rev (!coords));
d230 1
a230 2
            map (draw_image o #1) (rev (!coords));
            ()
@


1.5.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@@


1.4
log
@[Bug #1500]
Changing pathnames which refer to non-distributive paths.
Also changed the way the demo is started to be consistent with man-demo.sml.
@
text
@d12 1
a12 1
require "motif/__xm";
a13 1
  structure Xm = Xm_;
d315 1
@


1.4.7.1
log
@branched from 1.4
@
text
@@


1.4.7.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.4.7.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.4.7.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.4.7.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.4.6.1
log
@branched from 1.4
@
text
@@


1.4.6.1.1.1
log
@branched from 1.4.6.1
@
text
@@


1.4.5.1
log
@branched from 1.4
@
text
@@


1.4.4.1
log
@branched from 1.4
@
text
@@


1.4.4.1.1.1
log
@branched from 1.4.4.1
@
text
@@


1.4.3.1
log
@branched from 1.4
@
text
@@


1.4.2.1
log
@branched from 1.4
@
text
@@


1.4.1.1
log
@branched from 1.4
@
text
@@


1.3
log
@Changes to Xm signature.
@
text
@d6 1
a6 1
 * > run (5,6) (* for example *)
d106 1
a106 1
        val dobbs = Xm.Pixmap.get (screen,"/u/sml/MLW/src/app-defaults/minidobb.xbm",
d109 1
a109 1
        val dobbs_mask = Xm.Pixmap.get (screen,"/u/sml/MLW/src/app-defaults/minidobb-mask.xbm",
d177 1
a177 1
              loop 1000
d239 3
a241 1
            val [Xm.INT new_xi] = Xm.Widget.valuesGet (hscroll,[Xm.VALUE])
d252 1
a252 1
        
d255 3
a257 1
            val [Xm.INT new_yi] = Xm.Widget.valuesGet (vscroll,[Xm.VALUE])
d293 1
a293 1
              raise Halt
d299 1
d311 3
a313 3
  fun run (ix,iy) = 
    (make_toplevel (ix,iy);
     Xm.mainLoop ())
@


1.2
log
@update to curr Xm
@
text
@d12 1
a12 1
require "library/__xm";
d18 2
a19 2
      val name = Xm.Widget.NAME "mlworks"
      and class = Xm.APP_CLASS "MLWorks"
d28 1
a28 1
        (name, class, [(Xm.Title, Xm.STRING title), (Xm.IconName, Xm.STRING title)]);
d31 1
a31 1
        (Xm.Widget.NAME "drawScroll", Xm.Widget.Class.ScrolledWindow,applicationShell,[])
d35 1
a35 1
        (Xm.Widget.NAME "drawPane", Xm.Widget.Class.DrawingArea, scroll,[])
d38 3
a40 3
        (Xm.Widget.NAME "drawVScroll", Xm.Widget.Class.ScrollBar,scroll,
         [(Xm.Orientation, Xm.ORIENTATION Xm.VERTICAL),
          (Xm.Maximum, Xm.INT yextent)])
d43 3
a45 3
        (Xm.Widget.NAME "drawHScroll", Xm.Widget.Class.ScrollBar,scroll,
         [(Xm.Orientation, Xm.ORIENTATION Xm.HORIZONTAL),
          (Xm.Maximum, Xm.INT xextent)])
d49 3
a51 3
         [(Xm.VerticalScrollBar,Xm.WIDGET vscroll),
          (Xm.HorizontalScrollBar,Xm.WIDGET hscroll),
          (Xm.WorkWindow,Xm.WIDGET main)])
d60 1
a60 1
      val get_widget_resource : Xm.Widget * string * string -> Xm.Font = env "x get application resource"
d101 1
a101 1
        case Xm.Widget.valuesGet (widget,[Xm.Width,Xm.Height]) of
d184 3
a186 3
                                                Xm.GC.CAP_STYLE Xm.GC.CAPROUND,
                                                Xm.GC.JOIN_STYLE Xm.GC.JOINROUND,
                                                Xm.GC.FILL_STYLE Xm.GC.FILLSTIPPLED,
d192 1
a192 1
                                                Xm.GC.LINE_STYLE Xm.GC.LINEONOFFDASH,
d195 1
a195 1
                                                Xm.GC.CAP_STYLE Xm.GC.CAPROUND,
d239 1
a239 1
            val [Xm.INT new_xi] = Xm.Widget.valuesGet (hscroll,[Xm.Value])
d253 1
a253 1
            val [Xm.INT new_yi] = Xm.Widget.valuesGet (vscroll,[Xm.Value])
d271 1
a271 1
        if Xm.Widget.is_realized main
d284 1
a284 1
            Xm.Event.ButtonPress 
d288 1
a288 1
          | (Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "x",...})) =>
d290 1
a290 1
          | (Xm.Event.KeyPress _) =>
d295 7
a301 7
      Xm.Widget.callbackAdd (main,Xm.Callback.Expose,expose_callback);
      Xm.Widget.callbackAdd (main,Xm.Callback.Input,input_callback);
      Xm.Widget.callbackAdd (main,Xm.Callback.Resize,resize_callback);
      Xm.Widget.callbackAdd (hscroll,Xm.Callback.ValueChanged,horizontal_scroll_callback);
      Xm.Widget.callbackAdd (vscroll,Xm.Callback.ValueChanged,vertical_scroll_callback);
      Xm.Widget.callbackAdd (hscroll,Xm.Callback.Drag,horizontal_scroll_callback);
      Xm.Widget.callbackAdd (vscroll,Xm.Callback.Drag,vertical_scroll_callback)
@


1.1
log
@new unit
Demo for graphics stuff
@
text
@d4 7
d12 1
a12 8
make this file
> run (5,6) (* for example *)

Press "x" to break out of event loop
Click in the window or press any key (apart from "x") for other happenings
*)

require "library/__xm.sml";
d15 31
a45 5
(* ix,iy are increments for moving dobbs image *)
fun make_toplevel (ix,iy) =
  let
    val name = Xm.Widget.NAME "mlworks"
    val class = Xm.APP_CLASS "MLWorks"
d47 33
a79 61
    val title = "test"

    (*  The extent of the drawing area *)
    val xextent = 700
    val yextent = 700

    val applicationShell =
      Xm.initialize
      (name, class,
       [(Xm.Title, Xm.STRING title), (Xm.IconName, Xm.STRING title)]);

    val scroll = Xm.Widget.createManaged
      (Xm.Widget.NAME "drawScroll", Xm.Widget.Class.ScrolledWindow,applicationShell,[])

    val main =
      Xm.Widget.createManaged
      (Xm.Widget.NAME "drawPane", Xm.Widget.Class.DrawingArea, scroll,[])

    val vscroll = Xm.Widget.createManaged
      (Xm.Widget.NAME "drawVScroll", Xm.Widget.Class.ScrollBar,scroll,
       [(Xm.Orientation, Xm.ORIENTATION Xm.VERTICAL),
        (Xm.Maximum, Xm.INT yextent)])

    val hscroll = Xm.Widget.createManaged
      (Xm.Widget.NAME "drawHScroll", Xm.Widget.Class.ScrollBar,scroll,
       [(Xm.Orientation, Xm.ORIENTATION Xm.HORIZONTAL),
        (Xm.Maximum, Xm.INT xextent)])

    val _ = Xm.Widget.valuesSet
      (scroll,
       [(Xm.VerticalScrollBar,Xm.WIDGET vscroll),
        (Xm.HorizontalScrollBar,Xm.WIDGET hscroll),
        (Xm.WorkWindow,Xm.WIDGET main)])

    (* offset of start of window *)
    val xi_ref = ref 0
    val yi_ref = ref 0

    val _ = Xm.Widget.realize applicationShell

    fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
    val get_widget_resource : Xm.Widget * string * string -> Xm.Font = env "x get application resource"

    val myfont = get_widget_resource (applicationShell,"foo","Foo")
    val window= Xm.Widget.window main
    val display = Xm.Widget.display main
    val screen = Xm.Widget.screen main
    val pix1 = 
      let
        val pixmap = Xm.Pixmap.create (display,window,8,8,1)
        val gc1 = Xm.GC.create (display,pixmap,[Xm.GC.FONT myfont,
                                                Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                                Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen)])
        val gc2 = Xm.GC.create (display,pixmap,[Xm.GC.FONT myfont,
                                                Xm.GC.FOREGROUND (Xm.Pixel.screenWhite screen),
                                                Xm.GC.BACKGROUND (Xm.Pixel.screenBlack screen)])
        (* draw a pattern in the pixmap *)
        fun fill () =
          let
            fun aux1 8 = ()
              | aux1 i =
d83 3
a85 3
                      (if (i+j) mod 3 = 0 then Xm.Draw.point (display,pixmap,gc1,i,j)
                       else Xm.Draw.point (display,pixmap,gc2,i,j);
                         aux2 (j+1))
d90 39
d130 4
a133 1
            aux1 0
a134 4
      in
        fill ();
        (* ought to destroy gc1 and gc2 at this point *)
        pixmap
d136 4
a139 28

    exception Size
    fun size widget =
      case Xm.Widget.valuesGet (widget,[Xm.Width,Xm.Height]) of
        [Xm.INT width,Xm.INT height] => (width,height) 
      | _ => raise Size

    local
      val dobbs = Xm.Pixmap.get (screen,"/u/sml/MLW/src/app-defaults/minidobb.xbm",
                                 Xm.Pixel.screenBlack screen,Xm.Pixel.screenWhite screen)

      val dobbs_mask = Xm.Pixmap.get (screen,"/u/sml/MLW/src/app-defaults/minidobb-mask.xbm",
                                      Xm.Pixel.screenBlack screen,Xm.Pixel.screenWhite screen)

      val dobbs_mask_bitmap = Xm.Pixmap.create (display,window,64,75,1)

      val mask_gc = Xm.GC.create (display,dobbs_mask_bitmap,[Xm.GC.FONT myfont,
                                                             Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                                             Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen)])

      val _ = Xm.Draw.copyPlane (display,dobbs_mask,dobbs_mask_bitmap,mask_gc,0,0,64,75,0,0,1);

      val image_gc = Xm.GC.create (display,window,[Xm.GC.FONT myfont,
                                                   Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                                   Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen),
                                                   Xm.GC.CLIP_MASK dobbs_mask_bitmap])
    in
      fun draw_image (x,y) =
d141 18
a158 2
          val xi = ~(!xi_ref)
          val yi = ~(!yi_ref)
d160 1
a160 4
          Xm.GC.change (display,image_gc,
                        [Xm.GC.CLIP_X_ORIGIN (x+xi),
                         Xm.GC.CLIP_Y_ORIGIN (y+yi)]);
          Xm.Draw.copyArea (display,dobbs,window,image_gc,0,0,64,75,x+xi,y+yi)
d162 76
a237 8
    end

    (* The bouncing dobbs feature *)

    fun new_pos (widget,coords) =
      let
        val (width,height) = size widget
        fun doone ((x,y),(ix,iy)) =
d239 4
a242 12
            val x' = x + ix
            val y' = y + iy
            val ix = 
              if x' < 0 orelse x' > (width-64)
                then ~ix
              else ix
            val iy = 
              if y' < 0 orelse y' > (height-75)
                then ~iy
              else iy;
            val newx = x + ix
            val newy = y + iy
d244 5
a248 1
            ((newx,newy),(ix,iy))
d250 2
a251 10
      in
        map doone coords
      end

    val coords = ref [] : ((int * int) * (int * int)) list ref

    fun bounce_dobbs () =
      case !coords of
        [] => ()
      | _ => 
d253 4
a256 6
            fun loop 0 = ()
              | loop n =
                (coords := new_pos (main,!coords);
                 map (draw_image o #1) (rev (!coords));
                 Xm.sync (display,false);
                 loop (n-1))
d258 5
a262 1
            loop 1000
d264 16
a279 24

    local
      val gc1 = Xm.GC.create (display,window,[(* Xm.GC.FUNCTION Xm.GC.XOR, *)
                                              Xm.GC.FONT myfont,
                                              Xm.GC.LINE_WIDTH 20,
                                              Xm.GC.CAP_STYLE Xm.GC.CAPROUND,
                                              Xm.GC.JOIN_STYLE Xm.GC.JOINROUND,
                                              Xm.GC.FILL_STYLE Xm.GC.FILLSTIPPLED,
                                              Xm.GC.STIPPLE pix1,
                                              Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                              Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen)])

      val gc2 = Xm.GC.create (display,window,[Xm.GC.FONT myfont,
                                              Xm.GC.LINE_STYLE Xm.GC.LINEONOFFDASH,
                                              Xm.GC.DASHES 7,
                                              Xm.GC.DASH_OFFSET 3,
                                              Xm.GC.CAP_STYLE Xm.GC.CAPROUND,
                                              Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                              Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen)])
      val gc3 = Xm.GC.create (display,window,[Xm.GC.FONT myfont,
                                              Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                              Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen)])
    in
      fun draw_picture () =
d281 1
a281 11
          val xi = ~(!xi_ref)
          val yi = ~(!yi_ref)
          val (width,height) = (xextent,yextent)(* size main *)
          val x1 = 20
          val x2 = width - 20
          val y1 = 20
          val y2 = height - 20
          (* Change the GC here so we get the right offset for stippling *)
          val _ = Xm.GC.change (display,gc1,
                                [Xm.GC.TS_X_ORIGIN xi,
                                 Xm.GC.TS_Y_ORIGIN yi])
d283 10
a292 17
          Xm.Draw.point (display,window,gc3,100+xi,100+yi);
          Xm.Draw.points (display,window,gc3,[(350+xi,150+yi),(2,2),(2,2),(2,2),(2,2),(2,2),(2,2)],Xm.Draw.PREVIOUS);
          Xm.Draw.fillPolygon (display,window,gc1,[(40+xi,40+yi),(151+xi,167+yi),(199+xi,100+yi),(275+xi,232+yi)],Xm.Draw.COMPLEX,Xm.Draw.ORIGIN);
          Xm.Draw.segments (display,window,gc3,[(10+xi,320+yi,130+xi,440+yi),(140+xi,430+yi,20+xi,310+yi)]);
          Xm.Draw.fillRectangle (display,window,gc3,40+xi,280+yi,100,50);
          Xm.Draw.rectangle (display,window,gc3,20+xi,20+yi,200,150);
          Xm.Draw.rectangles (display,window,gc3,[(20+xi,40+yi,200,150),(22+xi,42+yi,200,150),(24+xi,44+yi,200,150)]);
          Xm.Draw.fillRectangles (display,window,gc3,[(140+xi,240+yi,100,50),(144+xi,244+yi,100,50),(148+xi,248+yi,100,50),(152+xi,252+yi,100,50)]);
          Xm.Draw.fillArc (display,window,gc1,280+xi,280+yi,140,130,0,64 * 360);
          Xm.Draw.arcs (display,window,gc3,[(280+xi,280+yi,140,130,0,64 * 360),(275+xi,285+yi,150,130,0,64 * 360),(270+xi,290+yi,160,130,0,64 * 360),(265+xi,295+yi,170,130,0,64 * 360)]);
          Xm.Draw.lines(display,window,gc1,[(x1+xi,y1+yi),(x1+xi,y2+yi),(x2+xi,y2+yi),(x2+xi,y1+yi),(y1+xi,x1+yi)],Xm.Draw.ORIGIN);
          Xm.Draw.line (display,window,gc2,x1+xi,y1+yi,x2+xi,y2+yi);
          Xm.Draw.line (display,window,gc2,x1+xi,y2+yi,x2+xi,y1+yi);
          Xm.Draw.imageString (display,window,gc1,20+xi,(height div 3)+yi,"Hello World");
          Xm.Draw.string (display,window,gc2,20+xi,2 * (height div 3)+yi,"Hello World");
          map (draw_image o #1) (rev (!coords));
          ()
d294 10
a303 70

      (* Scrolling *)
      (* These need to be a little careful about the way the copy area is done *)
      fun horizontal_scroll_callback data =
        let
          val [Xm.INT new_xi] = Xm.Widget.valuesGet (hscroll,[Xm.Value])
          val (width,height) = size main
          val old_xi = !xi_ref
          val delta = old_xi-new_xi
        in
          xi_ref := new_xi;
          if delta > 0
            then Xm.Draw.copyArea (display,window,window,gc3,~delta,0,width+delta,height,0,0)
          else Xm.Draw.copyArea (display,window,window,gc3,0,0,width-delta,height,delta,0);
            draw_picture ()
        end

      fun vertical_scroll_callback data =
        let
          val [Xm.INT new_yi] = Xm.Widget.valuesGet (vscroll,[Xm.Value])
          val (width,height) = size main
          val old_yi = !yi_ref
          val delta = old_yi-new_yi
        in
          yi_ref := new_yi;
          if delta > 0
            then Xm.Draw.copyArea (display,window,window,gc3,0,~delta,width,height+delta,0,0)
          else Xm.Draw.copyArea (display,window,window,gc3,0,0,width,height-delta,0,delta);
            draw_picture ()
        end

    end

    fun expose_callback data =
      draw_picture ()

    fun clearit _ =
      if Xm.Widget.is_realized main
        then Xm.Draw.clearArea (display,Xm.Widget.window main,0,0,0,0,true)
      else ()

    fun resize_callback data = clearit ()

    exception Halt

    fun input_callback data =
      let
        val (reason,event) = Xm.Callback.convertAny data
      in
        case event of
          Xm.Event.ButtonPress 
          (Xm.Event.BUTTON_EVENT {x,y,...}) => 
            (coords := ((x,y),(ix,iy)) :: !coords;
             draw_image (x,y))
        | (Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "x",...})) =>
            raise Halt
        | (Xm.Event.KeyPress _) =>
            bounce_dobbs ()
        | _ => ()
      end
  in
    Xm.Widget.callbackAdd (main,Xm.Callback.Expose,expose_callback);
    Xm.Widget.callbackAdd (main,Xm.Callback.Input,input_callback);
    Xm.Widget.callbackAdd (main,Xm.Callback.Resize,resize_callback);
    Xm.Widget.callbackAdd (hscroll,Xm.Callback.ValueChanged,horizontal_scroll_callback);
    Xm.Widget.callbackAdd (vscroll,Xm.Callback.ValueChanged,vertical_scroll_callback);
    Xm.Widget.callbackAdd (hscroll,Xm.Callback.Drag,horizontal_scroll_callback);
    Xm.Widget.callbackAdd (vscroll,Xm.Callback.Drag,vertical_scroll_callback)
  end;

d305 1
a305 1

d309 3
a312 1
end;
@
