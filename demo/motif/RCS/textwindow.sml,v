head	1.6;
access;
symbols
	MLWorks_21c0_1999_03_25:1.6
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.4
	MLWorks_20b0_1998_03_20:1.4
	MLWorks_20m2_1998_02_16:1.4
	MLWorks_workspace_97:1.4.1
	MLWorks_20m1_1997_10_23:1.4
	MLWorks_11r1:1.3.4.2.1.1.1
	MLWorks_11c0_1997_09_09:1.3.4.2.1.1
	MLWorks_10r3:1.3.4.2.3
	MLWorks_10r2_551:1.3.4.2.2
	MLWorks_11:1.3.4.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.4.2
	MLWorks_20m0_1997_06_20:1.4
	MLWorks_1_0_r2c2_1997_06_14:1.3.4.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.4.2
	MLWorks_1_0_r2c1_1997_05_12:1.3.4
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.3.3.1.1
	MLWorks_1_0_Win32_1996_12_17:1.3.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.3.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.3.1.1
	MLWorks_1_0_Irix_1996_11_28:1.3.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.3.2
	MLWorks_1_0_Unix_1996_11_14:1.3.1
	MLWorks_Open_Beta2_1996_10_11:1.2.1
	MLWorks_License_dev:1.1.1;
locks; strict;
comment	@ *  @;


1.6
date	98.05.07.10.57.17;	author johnh;	state Exp;
branches;
next	1.5;

1.5
date	98.04.21.17.21.06;	author mitchell;	state Exp;
branches;
next	1.4;

1.4
date	97.06.16.12.18.12;	author jkbrook;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	96.11.05.16.48.18;	author jkbrook;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1
	1.3.4.1;
next	1.2;

1.2
date	96.10.11.13.54.19;	author johnh;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	96.10.03.14.50.23;	author johnh;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.10.07.15.58.23;	author hope;	state Exp;
branches;
next	;

1.2.1.1
date	96.10.17.11.16.41;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	96.11.14.12.40.01;	author hope;	state Exp;
branches
	1.3.1.1.1.1;
next	;

1.3.1.1.1.1
date	96.11.28.14.51.53;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.11.22.18.00.31;	author hope;	state Exp;
branches;
next	;

1.3.3.1
date	96.12.17.17.39.25;	author hope;	state Exp;
branches
	1.3.3.1.1.1;
next	;

1.3.3.1.1.1
date	97.02.24.11.26.35;	author hope;	state Exp;
branches;
next	;

1.3.4.1
date	97.05.12.10.24.22;	author hope;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	97.05.15.13.26.43;	author daveb;	state Exp;
branches
	1.3.4.2.1.1
	1.3.4.2.2.1
	1.3.4.2.3.1;
next	;

1.3.4.2.1.1
date	97.07.28.18.10.23;	author daveb;	state Exp;
branches
	1.3.4.2.1.1.1.1;
next	;

1.3.4.2.1.1.1.1
date	97.10.07.11.34.28;	author jkbrook;	state Exp;
branches;
next	;

1.3.4.2.2.1
date	97.09.08.17.03.40;	author daveb;	state Exp;
branches;
next	;

1.3.4.2.3.1
date	97.09.09.13.58.27;	author daveb;	state Exp;
branches;
next	;

1.4.1.1
date	97.11.30.16.48.41;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Regorganising directory structure.
@


1.6
log
@[Bug #30292]
Fix compiler warnings.
@
text
@(*  ==== Text Window demo  ====
 *
 *  Copyright (C) 1997 The Harlequin Group Limited.  All rights reserved.
 *
 * $Log: motif:textwindow.sml,v 
 *  Revision 1.1  1996/10/03  14:50:23  john
 *  new unit
 *  Reorganising directory structure
 *
 *  Revision 1.2  1996/08/20  16:18:12  johnh
 *  update the demo to refer to the existing Xm library.
 *
 *)

require "$.motif.__xm";

fun text_window {title, height, width} =

  let
    
    val appshell = Xm.initialize (title,
				     "appshellappclass", 
                                     [(Xm.DELETE_RESPONSE, Xm.DELETE_RESPONSE_VALUE Xm.DO_NOTHING)])
      
    val text_widget = Xm.Widget.createScrolledText
      (appshell, "text_widget",
       [(Xm.EDIT_MODE, Xm.EDIT_MODE_VALUE Xm.MULTI_LINE_EDIT),
	(Xm.HEIGHT, Xm.INT height),
	(Xm.WIDTH, Xm.INT width)])
      
    val _ = Xm.Widget.manage text_widget
      
    val _ = Xm.Widget.realize appshell
      
    val pos = ref 0
      
    fun output s = 
      let
	val length = size s
	val current = !pos
	val new = current + length
      in
	(Xm.Text.insert (text_widget,
			  current,
			  s);
	 pos := new)
      end
    fun destroy () = Xm.Widget.destroy appshell
  in
    (output,destroy)
  end

local
  fun doit(0,f,a) = ()
    | doit (n,f,a) = (ignore (f a);
		      doit (n-1,f,a))
  fun id x = x
  fun delay n = doit(n,id,())
  fun delayed_dot (d,out) = (delay d;
			     out ".")
  fun slow_line' (n,d,out) = (doit(n,delayed_dot,(d,out));
			     out "\n")
  fun slow_lines (wname,n,m,d,out) =
    (ignore (out("some dots : "^wname^"\n"));
     doit (n,slow_line',(m,d,out));
     out("done some dots for "^wname^"\n"))
in    
  fun slow_window(wname,h,w,n,m,d) =
    let val (ptw,dtw) = text_window{title = wname, height = h, width = w}
    in (slow_lines(wname:string,n,m,d,ptw);
	dtw())
    end
  fun dots () = slow_window("dots",200,200,20,20,50000)
  fun slow_line (n,out) = slow_line'(n,100000,out)
end












@


1.5
log
@[Bug #30367]
Make tetris a bit more robust
@
text
@d55 1
a55 1
    | doit (n,f,a) = (f a;
d64 1
a64 1
    (out("some dots : "^wname^"\n");
@


1.4
log
@[Bug #30127]
Merging changes from 1.0r2c1 into 2.0m0
@
text
@d22 2
a23 1
				     "appshellappclass", [])
d76 10
@


1.4.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@@


1.3
log
@[Bug #1733]
Removing references to redundant structure Xm_
@
text
@d3 1
a3 1
 *  Copyright (C) 1996 Harlequin Ltd
d7 2
a8 2
 *  new uni
 *  Regorganising directory structure
@


1.3.4.1
log
@branched from 1.3
@
text
@@


1.3.4.2
log
@[Bug #30127]
Updated copyright.
@
text
@d3 1
a3 1
 *  Copyright (C) 1997 The Harlequin Group Limited.  All rights reserved.
d7 2
a8 2
 *  new unit
 *  Reorganising directory structure
@


1.3.4.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.3.4.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.3.4.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.3.4.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.3.3.1
log
@branched from 1.3
@
text
@@


1.3.3.1.1.1
log
@branched from 1.3.3.1
@
text
@@


1.3.2.1
log
@branched from 1.3
@
text
@@


1.3.1.1
log
@branched from 1.3
@
text
@@


1.3.1.1.1.1
log
@branched from 1.3.1.1
@
text
@@


1.2
log
@remvoing ^M from the end of each line.
@
text
@d21 1
a21 1
    val appshell = Xm_.initialize (title,
d24 1
a24 1
    val text_widget = Xm_.Widget.createScrolledText
d26 3
a28 3
       [(Xm_.EDIT_MODE, Xm_.EDIT_MODE_VALUE Xm_.MULTI_LINE_EDIT),
	(Xm_.HEIGHT, Xm_.INT height),
	(Xm_.WIDTH, Xm_.INT width)])
d30 1
a30 1
    val _ = Xm_.Widget.manage text_widget
d32 1
a32 1
    val _ = Xm_.Widget.realize appshell
d42 1
a42 1
	(Xm_.Text.insert (text_widget,
d47 1
a47 1
    fun destroy () = Xm_.Widget.destroy appshell
@


1.2.1.1
log
@branched from 1.2
@
text
@@


1.1
log
@new unit
Regorganising directory structure.
@
text
@d1 76
a76 72
(*  ==== Text Window demo  ====
 *
 *  Copyright (C) 1996 Harlequin Ltd
 *
 * $Log: textwindow.sml,v $
 *  Revision 1.2  1996/08/20  16:18:12  johnh
 *  update the demo to refer to the existing Xm library.
 *
 *)

require "$.motif.__xm";

fun text_window {title, height, width} =

  let
    
    val appshell = Xm_.initialize (title,
				     "appshellappclass", [])
      
    val text_widget = Xm_.Widget.createScrolledText
      (appshell, "text_widget",
       [(Xm_.EDIT_MODE, Xm_.EDIT_MODE_VALUE Xm_.MULTI_LINE_EDIT),
	(Xm_.HEIGHT, Xm_.INT height),
	(Xm_.WIDTH, Xm_.INT width)])
      
    val _ = Xm_.Widget.manage text_widget
      
    val _ = Xm_.Widget.realize appshell
      
    val pos = ref 0
      
    fun output s = 
      let
	val length = size s
	val current = !pos
	val new = current + length
      in
	(Xm_.Text.insert (text_widget,
			  current,
			  s);
	 pos := new)
      end
    fun destroy () = Xm_.Widget.destroy appshell
  in
    (output,destroy)
  end

local
  fun doit(0,f,a) = ()
    | doit (n,f,a) = (f a;
		      doit (n-1,f,a))
  fun id x = x
  fun delay n = doit(n,id,())
  fun delayed_dot (d,out) = (delay d;
			     out ".")
  fun slow_line' (n,d,out) = (doit(n,delayed_dot,(d,out));
			     out "\n")
  fun slow_lines (wname,n,m,d,out) =
    (out("some dots : "^wname^"\n");
     doit (n,slow_line',(m,d,out));
     out("done some dots for "^wname^"\n"))
in    
  fun slow_window(wname,h,w,n,m,d) =
    let val (ptw,dtw) = text_window{title = wname, height = h, width = w}
    in (slow_lines(wname:string,n,m,d,ptw);
	dtw())
    end
  fun dots () = slow_window("dots",200,200,20,20,50000)
  fun slow_line (n,out) = slow_line'(n,100000,out)
end


@


1.1.1.1
log
@branched from 1.1
@
text
@d5 1
a5 5
 * $Log: motif:textwindow.sml,v $
 *  Revision 1.1  1996/10/03  14:50:23  johnh
 *  new unit
 *  Regorganising directory structure.
 *
@
