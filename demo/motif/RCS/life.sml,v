head	1.7;
access;
symbols
	MLWorks_21c0_1999_03_25:1.7
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.6
	MLWorks_20b0_1998_03_20:1.6
	MLWorks_20m2_1998_02_16:1.6
	MLWorks_workspace_97:1.6.1
	MLWorks_20m1_1997_10_23:1.6
	MLWorks_11r1:1.3.1.3.1.1.1
	MLWorks_11c0_1997_09_09:1.3.1.3.1.1
	MLWorks_10r3:1.3.1.3.3
	MLWorks_10r2_551:1.3.1.3.2
	MLWorks_11:1.3.1.3.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.1.3
	MLWorks_20m0_1997_06_20:1.6
	MLWorks_1_0_r2c2_1997_06_14:1.3.1.3
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.1.3
	MLWorks_1_0_r2c1_1997_05_12:1.3.1
	MLWorks_BugFix_1997_04_24:1.4
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.2.3.1.1
	MLWorks_1_0_Win32_1996_12_17:1.2.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.2.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.2.1.1
	MLWorks_1_0_Irix_1996_11_28:1.2.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.2.2
	MLWorks_1_0_Unix_1996_11_14:1.2.1
	MLWorks_Open_Beta2_1996_10_11:1.1.1;
locks; strict;
comment	@ *  @;


1.7
date	98.11.09.11.44.44;	author johnh;	state Exp;
branches;
next	1.6;

1.6
date	97.06.16.11.14.12;	author jkbrook;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	97.05.09.08.52.33;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	97.04.07.15.07.50;	author stephenb;	state Exp;
branches;
next	1.3;

1.3
date	97.01.06.14.59.19;	author matthew;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	96.11.05.17.19.56;	author jkbrook;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1;
next	1.1;

1.1
date	96.10.11.14.01.44;	author johnh;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.10.17.11.16.43;	author hope;	state Exp;
branches;
next	;

1.2.1.1
date	96.11.14.12.40.05;	author hope;	state Exp;
branches
	1.2.1.1.1.1;
next	;

1.2.1.1.1.1
date	96.11.28.14.51.56;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.11.22.18.00.34;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.12.17.17.39.27;	author hope;	state Exp;
branches
	1.2.3.1.1.1;
next	;

1.2.3.1.1.1
date	97.02.24.11.26.38;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	97.05.12.10.24.25;	author hope;	state Exp;
branches;
next	1.3.1.2;

1.3.1.2
date	97.05.14.14.32.52;	author daveb;	state Exp;
branches;
next	1.3.1.3;

1.3.1.3
date	97.05.15.13.25.47;	author daveb;	state Exp;
branches
	1.3.1.3.1.1
	1.3.1.3.2.1
	1.3.1.3.3.1;
next	;

1.3.1.3.1.1
date	97.07.28.18.10.25;	author daveb;	state Exp;
branches
	1.3.1.3.1.1.1.1;
next	;

1.3.1.3.1.1.1.1
date	97.10.07.11.34.32;	author jkbrook;	state Exp;
branches;
next	;

1.3.1.3.2.1
date	97.09.08.17.03.43;	author daveb;	state Exp;
branches;
next	;

1.3.1.3.3.1
date	97.09.09.13.58.34;	author daveb;	state Exp;
branches;
next	;

1.6.1.1
date	97.11.30.16.48.45;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Reorganised demo directory to include separate demos for mswindows and motif.
@


1.7
log
@[Bug #50105]
Make toplevel functions unique across demos to avoid conflicts when loading demo project.
@
text
@(*  ==== Life demo  ====
 *
 *  Copyright (C) 1997  The Harlequin Group Limited.   All rights reserved.
 *
 * $Log: motif:life.sml,v $
 *  Revision 1.6  1997/06/16  11:14:12  jkbrook
 *  [Bug #30127]
 *  Merging changes from 1.0r2c1 into 2.0m0
 *
 *
 *  Revision 1.5  1997/05/09  08:52:33  daveb
 *  [Bug #20010]
 *  Ensured that single key presses are ignored when !runit = true.
 *
 *  Revision 1.4  1997/04/07  15:07:50  stephenb
 *  <URI:spring://ML_Notebook/Review/demo/motif/life.sml>
 *
 *  Revision 1.3  1997/01/06  14:59:19  matthew
 *  Various improvements
 *
 *  Revision 1.2  1996/11/05  17:19:56  jkbrook
 *  [Bug #1733]
 *  Removing references to redundant structure Xm_
 *
 *  Revision 1.1  1996/10/11  14:01:44  johnh
 *  new unit
 *  Reorganised demo directory to include separate demos for mswindows and motif.
 *
 *
 *)

require "forms";
require "$.motif.__xm";
require "$.basis.__array";

local

  type generation = {cells : int array array, columns: int, rows: int}

  type life_state = generation * generation

  val blockSize = 8  (* in pixels *)
    
  fun newVal ({cells, columns, rows}, i, j) : int =
    let
      val lix = if j = 0 then rows-1 else j-1
      val mix = j
      val rix = if j = rows-1 then 0 else j+1
      val topRow = Array.sub (cells, if i=0 then columns-1 else i-1)
      val midRow = Array.sub (cells, i)
      val bottomRow = Array.sub (cells, if i = columns-1 then 0 else i+1)
      val count =
        Array.sub (topRow, lix) +
        Array.sub (topRow, mix) +
        Array.sub (topRow, rix) +
        Array.sub (midRow, lix) +
        Array.sub (midRow, rix) +
        Array.sub (bottomRow, lix) +
        Array.sub (bottomRow, mix) +
        Array.sub (bottomRow, rix)
    in
      case count of
        2 => Array.sub (midRow, mix)
      | 3 => 1
      | _ => 0
    end
  
  fun update ({cells, columns, rows}, x, y, value:int) =
    Array.update (Array.sub (cells, x mod columns), y mod rows, value)
    
  fun new (inGen, x, y, outGen) =
    update (outGen, x, y, newVal (inGen, x, y))
  

  fun cleanGen {cells, columns, rows} =
    let
      fun cleanColumn i =
        if i = columns
          then ()
        else
          let
            val suba = Array.sub (cells, i)
            fun cleanRow j =
              if j = rows then
                ()
              else 
                (Array.update (suba, j, 0);
                 cleanRow (j+1))
          in
            cleanRow 0;
            cleanColumn (i+1)
          end
    in
      cleanColumn 0
    end

  
  fun nextGen ((current as {rows, columns, ...}), next) =
    let
      fun doColumns x =
        if x = columns then
          ()
        else
          let
            fun doRows y =
              if y = rows then
                ()
              else 
                (new (current, x, y, next);
                 doRows (y+1))
          in
            doRows 0;
            doColumns (x+1)
          end
    in
      cleanGen next;
      doColumns 0;
      (next, current)
    end

  
  fun updateFromList (gen, []) = ()
    | updateFromList (gen, (i, j)::rest) =
      (update (gen, i, j, 1);
       updateFromList (gen, rest))
      

  fun makeGen (columns, rows):generation =
    { cells = Array.tabulate (columns, fn _ => Array.array (rows, 0)),
      columns = columns,
      rows = rows }
    

  fun initState (columns, rows, initVals) = 
    let
      val (g1, g2) = (makeGen (columns, rows), makeGen (columns, rows))
      val _ = updateFromList (g1, initVals)
    in
      (g1, g2)
    end


  fun makeRect (x, y) =
    ((x * blockSize) + 1 ,(y * blockSize) + 1, blockSize - 2 , blockSize - 2)


  fun diffGen (state:life_state) =
    let
      val ({cells = currentCells, ...}, {cells = nextCells, ...}) = state
      val limit = Array.length currentCells
      fun scan (i, onRects, offRects) =
        if i = limit then
          (onRects, offRects)
        else
          let
            val a = Array.sub (currentCells, i)
            val max = Array.length a
            val a2 = Array.sub (nextCells, i)
            fun loop (j, onRects, offRects) = 
              if j = max then
                (onRects, offRects)
              else
                let
                  val n = Array.sub (a, j)
                in
                  if n = 1 then 
                    loop (j+1, makeRect (i, j)::onRects, offRects)
                  else if n = Array.sub (a2, j) then
                    loop (j+1, onRects, offRects)
                  else
                    loop (j+1, onRects, makeRect (i, j)::offRects)
                end
            val (onRects', offRects') = loop (0, onRects, offRects)
          in
            scan (i+1, onRects', offRects')
          end
    in
      scan (0, [], [])
    end




  fun makeToplevel (columns, rows, initvals) =
    let
      val state = ref (initState (columns, rows, initvals))
      val name = "mlworks"
      val class = "MLWorks"
        
      val title = "test"
        
      (*  The extent of the drawing area *)
      val xExtent = columns * blockSize
      val yExtent = rows * blockSize
        
      val applicationShell =
        Xm.initialize
        (name, class,
         [(Xm.TITLE, Xm.STRING title), (Xm.ICON_NAME, Xm.STRING title)]);
        
      val main =
        Xm.Widget.createManaged
        ("drawPane", Xm.Widget.DRAWING_AREA, applicationShell,
         [(Xm.WIDTH, Xm.INT xExtent), (Xm.HEIGHT, Xm.INT yExtent)])
        
      val _ = Xm.Widget.realize applicationShell
        
      val window= Xm.Widget.window main
      val display = Xm.Widget.display main
      val screen = Xm.Widget.screen main
        
      (*
       * The Crash exception indicates a problem has occured with X.
       * It is not explicitly caught anywhere since the usual action 
       * on catching it would be to terminate the program and that is
       * what happens as default when you don't catch an exception.
       *)
      exception Crash of string

      local
        val bg  =
          case Xm.Widget.valuesGet (main, [Xm.BACKGROUND]) of 
            [(Xm.PIXEL bg)] => bg
          | _ => raise Crash "get background failed"
        val onGc = Xm.GC.create (display, window, [Xm.GC.FOREGROUND 
                                                  (Xm.Pixel.screenBlack screen),
                                                  Xm.GC.BACKGROUND bg])
        val offGc = Xm.GC.create (display, window,[Xm.GC.FOREGROUND bg,
                                                   Xm.GC.BACKGROUND bg])
      in
        
        fun drawImage (x, y) =
          Xm.Draw.fillRectangle (display, window, onGc, 
                                 x+1, y+1, blockSize - 2, blockSize - 2)
        
        fun clearImage (x, y) =
          Xm.Draw.fillRectangle (display, window, offGc, 
                                 x+1, y+1, blockSize - 2, blockSize - 2)
        
        fun drawPicture () =
          let
            val (onRects, offRects) = diffGen (!state)
          in
            Xm.Draw.fillRectangles (display, window, offGc, offRects);
            Xm.Draw.fillRectangles (display, window, onGc, onRects);
            Xm.sync (display, false)
          end

      end



      val runit = ref false
        
      fun drawit () =
        (drawPicture ();
         if !runit then
           (state := nextGen (!state);
            drawPicture ();
            (* This generates an expose event *)
            Xm.Draw.clearArea (display, window, 0, 0, 1, 1, true))
         else
           ())
        
      
      (*
       * Doesn't pass along the affected region since the display update
       * routine just updates everything.
       *)
      fun doExpose (Xm.Event.EXPOSE_EVENT {common,x,y,width,height,count}) =
        drawit ()
        

      fun exposeHandler data =
        let
          val event = Xm.Event.convertEvent data
        in
          case event of
            Xm.Event.EXPOSE exposeEvent => doExpose exposeEvent
          | Xm.Event.GRAPHICS_EXPOSE exposeEvent => doExpose exposeEvent
          (* Could be a NoExpose event *)
          | _ => ()
        end
      
      fun clearit () =
        if Xm.Widget.isRealized main
          then Xm.Draw.clearArea (display, window, 0, 0, 0, 0, true)
        else ()
          
      fun resizeCallback data = clearit ()
        
      fun drawNextGen () =
        (state := nextGen (!state);
         drawit ())
        

      fun toggleCell (x, y) =
        let
          val i = x div blockSize
          val j = y div blockSize
        in
          if i >= 0 andalso i < columns andalso j >= 0 andalso j < rows then
            let 
              val ({cells, ...}, _) = !state
              val current = Array.sub (Array.sub (cells, i), j)
              val new = 1 - current
            in
              Array.update (Array.sub (cells, i), j, new);
              if new = 1 then
                drawImage (i * blockSize, j * blockSize)
              else
                clearImage (i * blockSize, j * blockSize)
            end
          else
            ()
         end


      fun inputCallback data =
        let
          val (_, event) = Xm.Callback.convertAny data
        in
          case event of
            Xm.Event.BUTTON_PRESS (Xm.Event.BUTTON_EVENT {x, y, ...}) => 
              toggleCell (x, y)
          | (Xm.Event.KEY_PRESS (Xm.Event.KEY_EVENT {key = "x", ...})) =>
              Xm.Widget.destroy applicationShell
          | (Xm.Event.KEY_PRESS (Xm.Event.KEY_EVENT {key = "r", ...})) =>
              (state := initState (columns, rows, initvals);
               clearit ())
          | (Xm.Event.KEY_PRESS (Xm.Event.KEY_EVENT {key = "s", ...})) =>
              (runit := not (!runit);
               if !runit then drawNextGen () else ())
          | (Xm.Event.KEY_PRESS _) =>
	      if not (!runit) then
                drawNextGen ()
	      else
		(* The next generation will be drawn anyway.  If we draw
		   it again here, the extra cycle of expose events will
		   override the keyboard input. *)
		()
          | _ => ()
        end

    in
      Xm.Event.addHandler (main, [Xm.Event.EXPOSURE_MASK], true, exposeHandler);
      Xm.Callback.add (main, Xm.Callback.INPUT, inputCallback);
      Xm.Callback.add (main, Xm.Callback.RESIZE, resizeCallback)
    end;

in  
  fun move (a:int,b:int) l = map (fn (x, y) => (x+a, y+b)) l
  val initvals = move (10, 10) crash
  val columns = 121
  val rows = 37
  fun life_runx () = Xm.mainLoop ()
  fun life_test () =  makeToplevel (columns, rows, initvals)
  fun life (columns, rows, vals) = makeToplevel (columns, rows, vals)
  fun life_appl () = (life_test (); life_runx ())
end
@


1.6
log
@[Bug #30127]
Merging changes from 1.0r2c1 into 2.0m0
@
text
@d6 4
d356 2
a357 2
  fun runx () = Xm.mainLoop ()
  fun test () =  makeToplevel (columns, rows, initvals)
d359 1
a359 1
  fun appl () = (test (); runx ())
@


1.6.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 4
 *  Revision 1.6  1997/06/16  11:14:12  jkbrook
 *  [Bug #30127]
 *  Merging changes from 1.0r2c1 into 2.0m0
 *
@


1.5
log
@[Bug #20010]
Ensured that single key presses are ignored when !runit = true.
@
text
@d3 1
a3 1
 *  Copyright (C) 1996 Harlequin Ltd
d6 5
@


1.4
log
@<URI:spring://ML_Notebook/Review/demo/motif/life.sml>
@
text
@d6 3
d326 7
a332 1
              drawNextGen ()
@


1.3
log
@Various improvements
@
text
@d6 3
d21 1
a21 1
require "$.motif.__xm.sml";
d26 5
a30 1
  val block_size = 8
d32 1
a32 1
  fun new_val ((a,n,m),i,j) : int =
d34 1
a34 1
      val lix = if j = 0 then m-1 else j-1
d36 4
a39 4
      val rix = if j = m-1 then 0 else j+1
      val top_row = Array.sub (a,if i=0 then n-1 else i-1)
      val mid_row = Array.sub (a,i)
      val bottom_row = Array.sub (a,if i = n-1 then 0 else i+1)
d41 8
a48 8
        Array.sub (top_row,lix) +
        Array.sub (top_row,mix) +
        Array.sub (top_row,rix) +
        Array.sub (mid_row,lix) +
        Array.sub (mid_row,rix) +
        Array.sub (bottom_row,lix) +
        Array.sub (bottom_row,mix) +
        Array.sub (bottom_row,rix)
d51 1
a51 1
        2 => Array.sub (mid_row,mix)
d56 2
a57 2
  fun update ((array,n,m),i,j,x:int) =
    Array.update (Array.sub (array,i mod n), j mod m, x)
d59 2
a60 2
  fun new (ina,i,j,outa) =
    update (outa,i,j,new_val(ina,i,j))
d62 2
a63 1
  fun clean (a,n,m) =
d65 16
a80 15
      fun loop1 i =
	if i = n
	  then ()
	else
	  let
	    val suba = Array.sub (a,i)
	    fun loop2 j =
	      if j = m then ()
	      else 
		(Array.update (suba,j,0);
		 loop2 (j+1))
	  in
	    loop2 0;
	    loop1 (i+1)
	  end
d82 1
a82 1
      loop1 0
d84 1
d86 1
a86 1
  fun gen (ina as (_,n,m),outa) =
d88 15
a102 14
      fun loop1 i =
	if i = n
	  then ()
	else
	  let
	    fun loop2 j =
	      if j = m then ()
	      else 
		(new (ina,i,j,outa);
		 loop2 (j+1))
	  in
	    loop2 0;
	    loop1 (i+1)
	  end
d104 3
a106 3
      clean outa;
      loop1 0;
      (outa,ina)
d108 1
d110 4
a113 4
  fun set (a,[]) = ()
    | set (a,(i,j)::rest) =
      (update (a,i,j,1);
       set (a,rest))
d115 5
a119 4
  fun make_gen (n,m) =
    (Array.tabulate (n, fn _ => Array.array (m,0)),
     n,
     m)
d121 2
a122 1
  fun init_gen (world_x,world_y,initvals) = 
d124 2
a125 2
      val (a1,a2) = (make_gen (world_x,world_y),make_gen (world_x,world_y))
      val _ = set (a1,initvals)
d127 1
a127 1
      (a1,a2)
d130 43
a172 2
  (* The main function *)
  fun make_toplevel (world_x,world_y,initvals) =
d174 1
a174 1
      val state = ref (init_gen (world_x,world_y,initvals))
d177 1
a177 1
	
d179 1
a179 1
	
d181 3
a183 3
      val xextent = world_x * block_size
      val yextent = world_y * block_size
	
d185 4
a188 4
	Xm.initialize
	(name, class,
	 [(Xm.TITLE, Xm.STRING title), (Xm.ICON_NAME, Xm.STRING title)]);
	
d190 4
a193 4
	Xm.Widget.createManaged
	("drawPane", Xm.Widget.DRAWING_AREA,applicationShell,
	 [(Xm.WIDTH,Xm.INT xextent),(Xm.HEIGHT,Xm.INT yextent)])
	
d195 1
a195 1
	
d199 7
a205 1
	
a207 6
      fun size widget =
	case Xm.Widget.valuesGet (widget,[Xm.WIDTH,Xm.HEIGHT]) of
	  [Xm.INT width,Xm.INT height] => (width,height) 
	| _ => raise Crash "widget size failed"
	    

d209 5
a213 4
        val bg  = case Xm.Widget.valuesGet (main,[Xm.BACKGROUND]) of 
          [(Xm.PIXEL bg)] => bg
        | _ => raise Crash "get background failed"
        val on_gc = Xm.GC.create (display,window,[Xm.GC.FOREGROUND 
d216 1
a216 1
        val off_gc = Xm.GC.create (display,window,[Xm.GC.FOREGROUND bg,
d219 18
a236 50
	
      fun draw_image (x,y) =
	Xm.Draw.fillRectangle (display, window, on_gc, 
                               x+1, y+1, block_size - 2, block_size - 2)
	
      fun clear_image (x,y) =
	Xm.Draw.fillRectangle (display, window, off_gc, 
                               x+1, y+1, block_size - 2, block_size - 2)
	
      fun make_rect (x,y) =
	((x * block_size) + 1 ,(y * block_size) + 1, block_size - 2 , block_size - 2)
	
      fun draw_picture _ =
	let
	  val ((gen1,_,_),(gen2,_,_)) = !state
	  val on_rects = ref []
	  val off_rects = ref []
          val limit = Array.length gen1
          fun scan i =
            if i = limit then ()
            else
              let
                val a = Array.sub (gen1,i)
                val max = Array.length a
                val a2 = Array.sub (gen2,i)
                fun loop j = 
                  if j = max then ()
                  else
                    let
                      val n = Array.sub (a,j)
                    in
                      if n = 1 then 
                        on_rects := make_rect (i,j) :: !on_rects
                      else
                        if n = Array.sub (a2,j)
                          then ()
                        else
                          off_rects := make_rect (i,j) :: !off_rects;
                          loop (j+1)
                    end
              in
                loop 0;
                scan (i+1)
              end
        in
          scan 0;
	  Xm.Draw.fillRectangles (display,window,off_gc,!off_rects);
	  Xm.Draw.fillRectangles (display,window,on_gc,!on_rects);
	  Xm.sync (display,false)
	end
d239 2
d242 11
a252 20
	
      fun drawit _ =
	(draw_picture ();
	 if !runit
	   then
	     (state := gen (!state);
	      draw_picture ();
              (* This generates an expose event *)
	      Xm.Draw.clearArea (display,window,0,0,1,1,true))
	 else ())
	
      val draw_picture = drawit 
	
      fun expose_callback data =
	let
	  val (reason,event,window) = Xm.Callback.convertDrawingArea data
	  val (w,h) = size main
	in
	  draw_picture (0,0,w,h)
	end
d254 18
a271 13
      fun do_expose (Xm.Event.EXPOSE_EVENT {common,x,y,width,height,count}) =
	draw_picture (x,y,width,height)
	
      fun expose_handler data =
	let
	  val event = Xm.Event.convertEvent data
	in
	  case event of
	    Xm.Event.EXPOSE expose_event => do_expose expose_event
	  | Xm.Event.GRAPHICS_EXPOSE expose_event => do_expose expose_event
	  (* Could be a NoExpose event *)
	  | _ => ()
	end
d273 54
a326 50
      fun clearit _ =
	if Xm.Widget.isRealized main
	  then Xm.Draw.clearArea (display,Xm.Widget.window main,0,0,0,0,true)
	else ()
	  
      fun resize_callback data = 
	clearit ()
	
      fun new_gen () =
	(state := gen (!state);
	 drawit ())
	
      fun input_callback data =
	let
	  val (reason,event) = Xm.Callback.convertAny data
	in
	  case event of
	    Xm.Event.BUTTON_PRESS 
	    (Xm.Event.BUTTON_EVENT {x,y,...}) => 
	      let
		val i = x div block_size
		val j = y div block_size
	      in
		if i >= 0 andalso i < world_x
		  andalso j >= 0 andalso j < world_y
		  then
		    let 
		      val ((a,_,_),_) = !state
		      val current = Array.sub (Array.sub (a,i),j)
		      val new = 1 - current
		    in
		      Array.update (Array.sub (a,i),j,new);
		      if new = 1 
			then draw_image (i * block_size, j * block_size)
		      else clear_image (i * block_size, j * block_size)
		    end
		else ()
	      end
	  | (Xm.Event.KEY_PRESS (Xm.Event.KEY_EVENT {key = "x",...})) =>
	      Xm.Widget.destroy applicationShell
	  | (Xm.Event.KEY_PRESS (Xm.Event.KEY_EVENT {key = "r",...})) =>
	      (state := init_gen (world_x,world_y,initvals);
	       clearit ())
	  | (Xm.Event.KEY_PRESS (Xm.Event.KEY_EVENT {key = "s",...})) =>
	      (runit := not (!runit);
	       if !runit then new_gen () else ())
	  | (Xm.Event.KEY_PRESS _) =>
	      new_gen ()
	  | _ => ()
	end
d328 3
a330 3
      Xm.Event.addHandler (main,[Xm.Event.EXPOSURE_MASK],true,expose_handler);
      Xm.Callback.add (main,Xm.Callback.INPUT,input_callback);
      Xm.Callback.add (main,Xm.Callback.RESIZE,resize_callback)
d332 1
d334 4
a337 4
  fun move (a:int,b:int) l = map (fn (x,y) => (x+a,y+b)) l    
  val initvals = move (10,10) crash
  val world_x = 121
  val world_y = 37
d339 2
a340 2
  fun test () =  make_toplevel (world_x, world_y, initvals)
  fun life (x,y,vals) = make_toplevel (x, y, vals)
@


1.3.1.1
log
@branched from 1.3
@
text
@a5 3
 *  Revision 1.3  1997/01/06  14:59:19  matthew
 *  Various improvements
 *
@


1.3.1.2
log
@[Bug #20010]
Merged 1.4 and 1.5 into 1.0r2c1.
@
text
@a5 10
 *  Revision 1.3.1.1  1997/05/12  10:24:25  hope
 *  branched from 1.3
 *
 *  Revision 1.5  1997/05/09  08:52:33  daveb
 *  [Bug #20010]
 *  Ensured that single key presses are ignored when !runit = true.
 *
 *  Revision 1.4  1997/04/07  15:07:50  stephenb
 *  <URI:spring://ML_Notebook/Review/demo/motif/life.sml>
 *
d21 1
a21 1
require "$.motif.__xm";
d26 1
a26 5
  type generation = {cells : int array array, columns: int, rows: int}

  type life_state = generation * generation

  val blockSize = 8  (* in pixels *)
d28 1
a28 1
  fun newVal ({cells, columns, rows}, i, j) : int =
d30 1
a30 1
      val lix = if j = 0 then rows-1 else j-1
d32 4
a35 4
      val rix = if j = rows-1 then 0 else j+1
      val topRow = Array.sub (cells, if i=0 then columns-1 else i-1)
      val midRow = Array.sub (cells, i)
      val bottomRow = Array.sub (cells, if i = columns-1 then 0 else i+1)
d37 8
a44 8
        Array.sub (topRow, lix) +
        Array.sub (topRow, mix) +
        Array.sub (topRow, rix) +
        Array.sub (midRow, lix) +
        Array.sub (midRow, rix) +
        Array.sub (bottomRow, lix) +
        Array.sub (bottomRow, mix) +
        Array.sub (bottomRow, rix)
d47 1
a47 1
        2 => Array.sub (midRow, mix)
d52 2
a53 2
  fun update ({cells, columns, rows}, x, y, value:int) =
    Array.update (Array.sub (cells, x mod columns), y mod rows, value)
d55 2
a56 2
  fun new (inGen, x, y, outGen) =
    update (outGen, x, y, newVal (inGen, x, y))
d58 1
a58 2

  fun cleanGen {cells, columns, rows} =
d60 15
a74 16
      fun cleanColumn i =
        if i = columns
          then ()
        else
          let
            val suba = Array.sub (cells, i)
            fun cleanRow j =
              if j = rows then
                ()
              else 
                (Array.update (suba, j, 0);
                 cleanRow (j+1))
          in
            cleanRow 0;
            cleanColumn (i+1)
          end
d76 1
a76 1
      cleanColumn 0
a77 1

d79 1
a79 1
  fun nextGen ((current as {rows, columns, ...}), next) =
d81 14
a94 15
      fun doColumns x =
        if x = columns then
          ()
        else
          let
            fun doRows y =
              if y = rows then
                ()
              else 
                (new (current, x, y, next);
                 doRows (y+1))
          in
            doRows 0;
            doColumns (x+1)
          end
d96 3
a98 3
      cleanGen next;
      doColumns 0;
      (next, current)
a99 1

d101 4
a104 4
  fun updateFromList (gen, []) = ()
    | updateFromList (gen, (i, j)::rest) =
      (update (gen, i, j, 1);
       updateFromList (gen, rest))
d106 4
a109 5

  fun makeGen (columns, rows):generation =
    { cells = Array.tabulate (columns, fn _ => Array.array (rows, 0)),
      columns = columns,
      rows = rows }
d111 1
a111 2

  fun initState (columns, rows, initVals) = 
d113 2
a114 41
      val (g1, g2) = (makeGen (columns, rows), makeGen (columns, rows))
      val _ = updateFromList (g1, initVals)
    in
      (g1, g2)
    end


  fun makeRect (x, y) =
    ((x * blockSize) + 1 ,(y * blockSize) + 1, blockSize - 2 , blockSize - 2)


  fun diffGen (state:life_state) =
    let
      val ({cells = currentCells, ...}, {cells = nextCells, ...}) = state
      val limit = Array.length currentCells
      fun scan (i, onRects, offRects) =
        if i = limit then
          (onRects, offRects)
        else
          let
            val a = Array.sub (currentCells, i)
            val max = Array.length a
            val a2 = Array.sub (nextCells, i)
            fun loop (j, onRects, offRects) = 
              if j = max then
                (onRects, offRects)
              else
                let
                  val n = Array.sub (a, j)
                in
                  if n = 1 then 
                    loop (j+1, makeRect (i, j)::onRects, offRects)
                  else if n = Array.sub (a2, j) then
                    loop (j+1, onRects, offRects)
                  else
                    loop (j+1, onRects, makeRect (i, j)::offRects)
                end
            val (onRects', offRects') = loop (0, onRects, offRects)
          in
            scan (i+1, onRects', offRects')
          end
d116 1
a116 1
      scan (0, [], [])
d119 2
a120 4



  fun makeToplevel (columns, rows, initvals) =
d122 1
a122 1
      val state = ref (initState (columns, rows, initvals))
d125 1
a125 1
        
d127 1
a127 1
        
d129 3
a131 3
      val xExtent = columns * blockSize
      val yExtent = rows * blockSize
        
d133 4
a136 4
        Xm.initialize
        (name, class,
         [(Xm.TITLE, Xm.STRING title), (Xm.ICON_NAME, Xm.STRING title)]);
        
d138 4
a141 4
        Xm.Widget.createManaged
        ("drawPane", Xm.Widget.DRAWING_AREA, applicationShell,
         [(Xm.WIDTH, Xm.INT xExtent), (Xm.HEIGHT, Xm.INT yExtent)])
        
d143 1
a143 1
        
d147 1
a147 7
        
      (*
       * The Crash exception indicates a problem has occured with X.
       * It is not explicitly caught anywhere since the usual action 
       * on catching it would be to terminate the program and that is
       * what happens as default when you don't catch an exception.
       *)
d150 6
d157 4
a160 5
        val bg  =
          case Xm.Widget.valuesGet (main, [Xm.BACKGROUND]) of 
            [(Xm.PIXEL bg)] => bg
          | _ => raise Crash "get background failed"
        val onGc = Xm.GC.create (display, window, [Xm.GC.FOREGROUND 
d163 1
a163 1
        val offGc = Xm.GC.create (display, window,[Xm.GC.FOREGROUND bg,
d166 50
a215 18
        
        fun drawImage (x, y) =
          Xm.Draw.fillRectangle (display, window, onGc, 
                                 x+1, y+1, blockSize - 2, blockSize - 2)
        
        fun clearImage (x, y) =
          Xm.Draw.fillRectangle (display, window, offGc, 
                                 x+1, y+1, blockSize - 2, blockSize - 2)
        
        fun drawPicture () =
          let
            val (onRects, offRects) = diffGen (!state)
          in
            Xm.Draw.fillRectangles (display, window, offGc, offRects);
            Xm.Draw.fillRectangles (display, window, onGc, onRects);
            Xm.sync (display, false)
          end

a217 2


d219 20
a238 11
        
      fun drawit () =
        (drawPicture ();
         if !runit then
           (state := nextGen (!state);
            drawPicture ();
            (* This generates an expose event *)
            Xm.Draw.clearArea (display, window, 0, 0, 1, 1, true))
         else
           ())
        
d240 13
a252 18
      (*
       * Doesn't pass along the affected region since the display update
       * routine just updates everything.
       *)
      fun doExpose (Xm.Event.EXPOSE_EVENT {common,x,y,width,height,count}) =
        drawit ()
        

      fun exposeHandler data =
        let
          val event = Xm.Event.convertEvent data
        in
          case event of
            Xm.Event.EXPOSE exposeEvent => doExpose exposeEvent
          | Xm.Event.GRAPHICS_EXPOSE exposeEvent => doExpose exposeEvent
          (* Could be a NoExpose event *)
          | _ => ()
        end
d254 50
a303 60
      fun clearit () =
        if Xm.Widget.isRealized main
          then Xm.Draw.clearArea (display, window, 0, 0, 0, 0, true)
        else ()
          
      fun resizeCallback data = clearit ()
        
      fun drawNextGen () =
        (state := nextGen (!state);
         drawit ())
        

      fun toggleCell (x, y) =
        let
          val i = x div blockSize
          val j = y div blockSize
        in
          if i >= 0 andalso i < columns andalso j >= 0 andalso j < rows then
            let 
              val ({cells, ...}, _) = !state
              val current = Array.sub (Array.sub (cells, i), j)
              val new = 1 - current
            in
              Array.update (Array.sub (cells, i), j, new);
              if new = 1 then
                drawImage (i * blockSize, j * blockSize)
              else
                clearImage (i * blockSize, j * blockSize)
            end
          else
            ()
         end


      fun inputCallback data =
        let
          val (_, event) = Xm.Callback.convertAny data
        in
          case event of
            Xm.Event.BUTTON_PRESS (Xm.Event.BUTTON_EVENT {x, y, ...}) => 
              toggleCell (x, y)
          | (Xm.Event.KEY_PRESS (Xm.Event.KEY_EVENT {key = "x", ...})) =>
              Xm.Widget.destroy applicationShell
          | (Xm.Event.KEY_PRESS (Xm.Event.KEY_EVENT {key = "r", ...})) =>
              (state := initState (columns, rows, initvals);
               clearit ())
          | (Xm.Event.KEY_PRESS (Xm.Event.KEY_EVENT {key = "s", ...})) =>
              (runit := not (!runit);
               if !runit then drawNextGen () else ())
          | (Xm.Event.KEY_PRESS _) =>
	      if not (!runit) then
                drawNextGen ()
	      else
		(* The next generation will be drawn anyway.  If we draw
		   it again here, the extra cycle of expose events will
		   override the keyboard input. *)
		()
          | _ => ()
        end

d305 3
a307 3
      Xm.Event.addHandler (main, [Xm.Event.EXPOSURE_MASK], true, exposeHandler);
      Xm.Callback.add (main, Xm.Callback.INPUT, inputCallback);
      Xm.Callback.add (main, Xm.Callback.RESIZE, resizeCallback)
a308 1

d310 4
a313 4
  fun move (a:int,b:int) l = map (fn (x, y) => (x+a, y+b)) l
  val initvals = move (10, 10) crash
  val columns = 121
  val rows = 37
d315 2
a316 2
  fun test () =  makeToplevel (columns, rows, initvals)
  fun life (columns, rows, vals) = makeToplevel (columns, rows, vals)
@


1.3.1.3
log
@[Bug #30127]
Updated copyright.
@
text
@d3 1
a3 1
 *  Copyright (C) 1997  The Harlequin Group Limited.   All rights reserved.
a5 4
 *  Revision 1.3.1.2  1997/05/14  14:32:52  daveb
 *  [Bug #20010]
 *  Merged 1.4 and 1.5 into 1.0r2c1.
 *
@


1.3.1.3.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 4
 *  Revision 1.3.1.3  1997/05/15  13:25:47  daveb
 *  [Bug #30127]
 *  Updated copyright.
 *
@


1.3.1.3.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 4
 *  Revision 1.3.1.3  1997/05/15  13:25:47  daveb
 *  [Bug #30127]
 *  Updated copyright.
 *
@


1.3.1.3.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 4
 *  Revision 1.3.1.3  1997/05/15  13:25:47  daveb
 *  [Bug #30127]
 *  Updated copyright.
 *
@


1.3.1.3.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 3
 *  Revision 1.3.1.3.1.1  1997/07/28  18:10:25  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.2
log
@[Bug #1733]
Removing references to redundant structure Xm_
@
text
@d6 4
a17 1

d19 1
d22 2
a23 44
  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
  val sync_graphics_exposures : unit -> unit = env "x sync graphics exposures"
  structure Array = MLWorks.Internal.Array
  structure ExtendedArray = MLWorks.Internal.ExtendedArray
  structure Bits = MLWorks.Internal.Bits
  open MLWorks.IO
in    
  fun P s = output (std_out, s ^ "\n")
    
  val size_exp = 3
  val block_size = Bits.lshift (1,size_exp)
    
  fun max (x:int,y) = if x > y then x else y
  fun min (x:int,y) = if x < y then x else y
    
  fun make_gen (n,m) =
    (Array.tabulate (n, fn _ => Array.array (m,0)),
     n,
     m)
    
  fun sub ((array,n,m),i,j) =
    if i < 0 then 0
    else if j < 0 then 0
    else if i >= n then 0
    else if j >= m then 0
	 else Array.sub (Array.sub (array,i),j)
	   
  fun mymod (i,n) =
    if i < 0 then mymod (i+n,n)
    else if i >= n then mymod (i-n,n)
	 else i
	   
  fun update ((array,n,m),i,j,x:int) =
    Array.update (Array.sub (array,mymod (i,n)),mymod (j,m),x)
    
  fun calc_val (array,i,j) =
    sub (array,i-1,j-1) +
    sub (array,i-1,j) +
    sub (array,i-1,j+1) +
    sub (array,i,j-1) +
    sub (array,i,j+1) +
    sub (array,i+1,j-1) +
    sub (array,i+1,j) +
    sub (array,i+1,j+1)
d25 1
a25 1
  fun calc_val ((a,n,m),i,j) : int =
d33 9
d43 4
a46 8
      Array.sub (top_row,lix) +
      Array.sub (top_row,mix) +
      Array.sub (top_row,rix) +
      Array.sub (mid_row,lix) +
      Array.sub (mid_row,rix) +
      Array.sub (bottom_row,lix) +
      Array.sub (bottom_row,mix) +
      Array.sub (bottom_row,rix)
d49 3
d53 1
a53 9
    let
      val newval =
	case calc_val (ina,i,j) of
	  2 => sub (ina,i,j)
	| 3 => 1
	| _ => 0
    in
      update (outa,i,j,newval)
    end
d103 4
a106 13
  val gunvals =
    [(2,20),(3,19),(3,21),(4,18),
     (4,22),(4,23),(4,32),(5,7),
     (5,8),(5,18),(5,22),(5,23),
     (5,29),(5,30),(5,31),(5,32),
     (5,36),(6,7),(6,8),(6,18),
     (6,22),(6,23),(6,28),(6,29),
     (6,30),(6,31),(6,36),(7,19),
     (7,21),(7,28),(7,31),(7,42),
     (7,41),(8,20),(8,28),(8,29),
     (8,30),(8,31),(8,42),(8,41),
     (9,29),(9,30),(9,31),(9,32)
     ]
d108 1
a108 5
  fun move (a:int,b:int) l = map (fn (x,y) => (x+a,y+b)) l
    
  val initvals = move (10,10) crash
    
  fun init_gen (initvals,world_x,world_y) = 
d115 3
a117 6
  
  val state = ref (make_gen (0,0),make_gen (0,0))
    
  (* Motif stuff *)
    
  fun make_toplevel (world_x,world_y) =
d119 1
d145 2
a146 1
      exception Size
d150 1
a150 1
	| _ => raise Size
d152 11
a162 10
      exception Crash
      
      val bg  = case Xm.Widget.valuesGet (main,[Xm.BACKGROUND]) of 
	[(Xm.PIXEL bg)] => bg
      | _ => raise Crash
	  
      val on_gc = Xm.GC.create (display,window,[Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
						Xm.GC.BACKGROUND bg])
      val off_gc = Xm.GC.create (display,window,[Xm.GC.FOREGROUND bg,
						 Xm.GC.BACKGROUND bg])
d165 2
a166 1
	Xm.Draw.fillRectangle (display,window,on_gc,x+1,y+1,block_size -2 ,block_size -2)
d169 2
a170 1
	Xm.Draw.fillRectangle (display,window,off_gc,x+1,y+1,block_size -2,block_size -2)
d173 1
a173 1
	(Bits.lshift (x,size_exp)+1 ,Bits.lshift (y,size_exp)+1,block_size-2,block_size-2)
d180 29
a208 25
	in
	  ExtendedArray.iterate_index
	  (fn (i,a) =>
	   let
	     val max = Array.length a
	     val a2 = Array.sub (gen2,i)
	     fun loop j = 
	       if j = max then ()
	       else
		 let
		   val n = Array.sub (a,j)
		 in
		   if n = 1 then 
		     on_rects := make_rect (i,j) :: !on_rects
		   else
		     if n = Array.sub (a2,j)
		       then ()
		     else
		       off_rects := make_rect (i,j) :: !off_rects;
		       loop (j+1)
		 end
	   in
	     loop 0
	   end)
	  gen1;
d213 3
a215 2
      
      val goforit = ref false
d219 1
a219 1
	 if !goforit
d223 1
d284 2
a285 2
			then draw_image (i*block_size,j*block_size)
		      else clear_image (i*block_size,j*block_size)
d292 1
a292 1
	      (state :=init_gen (initvals,world_x,world_y);
d295 2
a296 2
	      (goforit := not (!goforit);
	       if !goforit then new_gen() else ())
d306 3
a308 7
    
  fun create (init,x,y) = 
    (state := init;
     make_toplevel (x,y))
    
  fun runx () = Xm.mainLoop ()

d311 3
a313 3
  
  fun test () =  create (init_gen (initvals,world_x,world_y), world_x,world_y)
  fun life (vals,x,y) = create (init_gen (vals,x,y),x,y)
@


1.2.3.1
log
@branched from 1.2
@
text
@a5 4
 *  Revision 1.2  1996/11/05  17:19:56  jkbrook
 *  [Bug #1733]
 *  Removing references to redundant structure Xm_
 *
@


1.2.3.1.1.1
log
@branched from 1.2.3.1
@
text
@a5 3
 *  Revision 1.2.3.1  1996/12/17  17:39:27  hope
 *  branched from 1.2
 *
@


1.2.2.1
log
@branched from 1.2
@
text
@a5 4
 *  Revision 1.2  1996/11/05  17:19:56  jkbrook
 *  [Bug #1733]
 *  Removing references to redundant structure Xm_
 *
@


1.2.1.1
log
@branched from 1.2
@
text
@a5 4
 *  Revision 1.2  1996/11/05  17:19:56  jkbrook
 *  [Bug #1733]
 *  Removing references to redundant structure Xm_
 *
@


1.2.1.1.1.1
log
@branched from 1.2.1.1
@
text
@a5 3
 *  Revision 1.2.1.1  1996/11/14  12:40:05  hope
 *  branched from 1.2
 *
@


1.1
log
@new unit
Reorganised demo directory to include separate demos for mswindows and motif.
@
text
@d5 5
a9 1
 * $Log$
a17 1
  structure Xm = Xm_
@


1.1.1.1
log
@branched from 1.1
@
text
@d5 1
a5 5
 * $Log: motif:life.sml,v $
 *  Revision 1.1  1996/10/11  14:01:44  johnh
 *  new unit
 *  Reorganised demo directory to include separate demos for mswindows and motif.
 *
@
