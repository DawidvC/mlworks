head	1.5;
access;
symbols
	MLWorks_21c0_1999_03_25:1.5
	MLWorks_20c1_1998_08_20:1.4
	MLWorks_20c0_1998_08_04:1.4
	MLWorks_20b2c2_1998_06_19:1.4
	MLWorks_20b2_Windows_1998_06_12:1.4
	MLWorks_20b1c1_1998_05_07:1.4
	MLWorks_20b0_1998_04_07:1.4
	MLWorks_20b0_1998_03_20:1.4
	MLWorks_20m2_1998_02_16:1.4
	MLWorks_workspace_97:1.4.1
	MLWorks_20m1_1997_10_23:1.4
	MLWorks_11r1:1.3.1.2.1.1.1
	MLWorks_11c0_1997_09_09:1.3.1.2.1.1
	MLWorks_10r3:1.3.1.2.3
	MLWorks_10r2_551:1.3.1.2.2
	MLWorks_11:1.3.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.1.2
	MLWorks_20m0_1997_06_20:1.4
	MLWorks_1_0_r2c2_1997_06_14:1.3.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.3.1
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3;
locks; strict;
comment	@ *  @;


1.5
date	99.03.18.13.21.25;	author johnh;	state Exp;
branches;
next	1.4;

1.4
date	97.05.16.15.16.48;	author andreww;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	97.04.03.14.29.39;	author andreww;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	97.04.03.11.55.42;	author andreww;	state Exp;
branches;
next	1.1;

1.1
date	97.02.06.17.48.06;	author andreww;	state Exp;
branches;
next	;

1.3.1.1
date	97.05.12.10.24.34;	author hope;	state Exp;
branches;
next	1.3.1.2;

1.3.1.2
date	97.05.16.16.42.22;	author daveb;	state Exp;
branches
	1.3.1.2.1.1
	1.3.1.2.2.1
	1.3.1.2.3.1;
next	;

1.3.1.2.1.1
date	97.07.28.18.09.53;	author daveb;	state Exp;
branches
	1.3.1.2.1.1.1.1;
next	;

1.3.1.2.1.1.1.1
date	97.10.07.11.33.42;	author jkbrook;	state Exp;
branches;
next	;

1.3.1.2.2.1
date	97.09.08.17.03.11;	author daveb;	state Exp;
branches;
next	;

1.3.1.2.3.1
date	97.09.09.13.57.48;	author daveb;	state Exp;
branches;
next	;

1.4.1.1
date	97.11.30.16.48.12;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
demo for mutual exclusion primitives.
@


1.5
log
@[Bug #190530]
fix compilation problem.
@
text
@(* ==== THREADS SYNCHRONIZATION EXAMPLES : the sleeping barber problem ====
 *
 * Copyright (C) 1997 Harlequin Ltd.
 *
 * Description
 * -----------
 * (from "Operating Systems Concepts", 4th Ed. Silberschatz and Galvin
 * Addison-Wesley 1994, page 212):
 *
 * A barbershop consists of a waiting room with n chairs, and the barber
 * room containing the barber chair.  If there are no customers to be served,
 * the barber goes to sleep.  If a customer enters the barbershop and all
 * the chairs are occupied, then the customer leaves the shop.  If the
 * barber is busy, but chairs are available,then the customer sits in one
 * of the free chairs.  If the barber is asleep, the customer wakes up
 * the barber.
 *
 * Revision Log:
 * -------------
 * $Log: threads:sleeping_barber.sml,v $
 *  Revision 1.4  1997/05/16  15:16:48  andreww
 *  [Bug #50000]
 *  Must set max_stack_blocks explicitly so won't overflow default stack.
 *
 *  Revision 1.3  1997/04/03  14:29:39  andreww
 *  [Bug #2017]
 *  Adjusting the copyright messages in the demo files.
 *
 *  Revision 1.2  1997/04/03  11:55:42  andreww
 *  [Bug #2017]
 *  renaming run function, making sure each variable is reinitialized
 *  every run.
 *
 *  Revision 1.1  1997/02/06  17:48:06  andreww
 *  new unit
 *  demo for mutual exclusion primitives.
 *
 *
 *
 *)






require "$.system.__time";
require "$.basis.__array";
require "$.basis.__timer";
require "$.basis.__string";
require "$.basis.__int32";
require "$.basis.__text_io";
require "$.utils.__mutex";


local

  structure T = MLWorks.Threads;
  structure I = T.Internal;
  structure P = I.Preemption;
    
    
  (* The output device *)
    
  val output = Mutex.newBinaryMutex false;
  val outputString = ref "";
    
  fun safePrint message = 
    Mutex.critical([output], fn()=>outputString:=(!outputString^message))()
    
  fun unsafePrint message = outputString := (!outputString)^message
    
    
  fun flushOutput () = while (Mutex.query output <>[]) do ()
    
    
    




  (* functions to pass away the time *)


  fun random() =
    let
      val timeString = Time.fmt 4 (Time.now())
      val number = case (rev(String.tokens (fn c => c= #".") timeString))
                     of [] => 0
                      | (h::_) => valOf(Int32.fromString h)
    in
      number mod 1971
    end;
    
    
  fun occupySomeTime scale message =
    let
      val timeToPass = Time.fromMilliseconds (random()*scale)
      val _ = safePrint message
      val timer = Timer.startRealTimer()
      fun passTime() = if Time.<(Timer.checkRealTimer timer,timeToPass)
                         then passTime()
                       else ()
    in
      passTime()
    end;
    
    

  (* the barbershop: the total number of chairs available *)
  val LIMIT = 4;
    
  val numChairs = ref LIMIT;
    
    
  fun makeBarber (chairs,barber,customer,custom,output) =
    let
      val barberSleeping = ref true
        
      fun barbering() =
        while true do
          (Mutex.wait [custom,output];              (* wait for some custom. *)
           if !barberSleeping 
             then (unsafePrint "The barber has woken up.\n";
                   barberSleeping:=false)
           else ();
             Mutex.signal [barber,output]; (* signal that barber is ready. *)
             Mutex.wait [customer];        (* wait for customer to say "me!"*)
             occupySomeTime 1 "The barber is busy.\n";
             safePrint "The barber has finished.\n";
             Mutex.signal [customer];          (* tell customer "finished". *)
             if !numChairs<LIMIT then () else 
               (safePrint "The barber has fallen asleep.\n";
                barberSleeping:=true)
               )
    in
      barbering
    end
  




  fun makeCustomer name (chairs,barber,customer,custom,output) =
    let
      val inShop = ref false
        
      fun sillyMessage() = 
        case (random() mod 10)
          of 0 => name^" is buying a packet of fags.\n"
           | 1 => name^" is pondering lambda optimization.\n"
           | 2 => name^" is enjoying a black cherry flavoured yoghurt.\n"
           | 3 => name^" is chatting to a dining philosopher.\n"
           | 4 => name^" has just proved a difficult theorem.\n"
           | 5 => name^" is window-shopping.\n"
           | 6 => name^" is buying lunch.\n"
           | 7 => name^" has gone swimming.\n"
           | 8 => name^" is avoiding the team dinner.\n"
           | 9 => name^" is playing some guitar.\n"
           | _ => ""
            
            

      fun customering() =
        while true do
          (occupySomeTime 2 (sillyMessage());
           Mutex.critical([output],fn ()=>
                          (Mutex.signal [custom];
                           unsafePrint (name^" has entered the shop.\n");
                           inShop:=true)
                          )();
           Mutex.critical
           ([chairs], fn()=>
            if !numChairs=0
              then (Mutex.wait [custom,output];
                    unsafePrint (name^" has left the crowded shop.\n");
                    inShop:=false;
                    Mutex.signal [output])
            else numChairs:=(!numChairs-1)
              )();
           if !inShop
             then (Mutex.wait [barber];
                   Mutex.signal [customer];
                   safePrint(name^" is getting a hair cut.\n");
                   Mutex.wait [customer,output];
                   unsafePrint (name^" has a new hairstyle.\n");
                   Mutex.signal [output];
                   Mutex.wait ([chairs,custom,output]);
                   numChairs:=(!numChairs+1);
                   unsafePrint (name^" has left the shop.\n");
                   inShop:=false;
                   Mutex.signal [chairs,output]
                   )
           else ())
    in
      customering
    end                      
  
  





in
  (*  set up the threads mechanism *)

   (* 1. Ensure we have enough stack blocks to give one to each thread.
    * The environment already runs two, and we fork another 8.
    *)

    val _ = MLWorks.Internal.Runtime.Memory.max_stack_blocks:=10;


    fun runBarber interval timeLimit  =
      let
        
        val chairs = Mutex.newBinaryMutex false;
        val _ = numChairs:= LIMIT;
        val barber = Mutex.newBinaryMutex true;          (* barber unatainable
                                                          while sleeping *)
        val customer = Mutex.newBinaryMutex false;
        val custom = Mutex.newCountingMutex 0;
      
        val deadlockFlag = ref false;

        
        val _ = outputString:=""
          
        val  b = makeBarber(chairs,barber,customer,custom,output)
        val p1 = makeCustomer "    Jon" (chairs,barber,customer,custom,output)
        val p2 = makeCustomer "   Dave" (chairs,barber,customer,custom,output)
        val p3 = makeCustomer "Matthew" (chairs,barber,customer,custom,output)
        val p4 = makeCustomer "Stephen" (chairs,barber,customer,custom,output)
        val p6 = makeCustomer " Andrew" (chairs,barber,customer,custom,output)
        val p7 = makeCustomer "     Jo" (chairs,barber,customer,custom,output)
        val p8 = makeCustomer "   John" (chairs,barber,customer,custom,output)
          
          
          
        (*  set up the threads mechanism *)
        val _ = P.set_interval interval;
        val _ = P.start();
          
        val bid = T.fork b ()
        val id1 = T.fork p1 ()
        val id2 = T.fork p2 ()
        val id3 = T.fork p3 ()
        val id4 = T.fork p4 ()
        val id6 = T.fork p6 ()
        val id7 = T.fork p7 ()
        val id8 = T.fork p8 ()
          
          
        (* set up deadlock detector *)
          
          
        val _ = deadlockFlag:=false;
          
        fun detectDeadlock () =
          if Mutex.allSleeping [bid,id1,id2,id3,id4,id6,id7,id8]
            then deadlockFlag:=true
          else detectDeadlock()
            
        val dd = T.fork detectDeadlock ()
          
          
          
        fun checkTime timer =
          if Time.toSeconds(Timer.checkRealTimer timer)<timeLimit
            andalso not (!deadlockFlag)
            then checkTime timer
               else (I.kill bid;
                     I.kill id1;
                     I.kill id2;
                     I.kill id3;
                     I.kill id4;
                     I.kill id6;
                     I.kill id7;
                     I.kill id8;
                     if !deadlockFlag then () else I.kill dd)
                 
                 
                 
        (* set up a timer *)
        val timer = Timer.startRealTimer()
        val _ = checkTime timer
          
        (* wait for program to finish *)
          
        val _ = if !deadlockFlag then print "Deadlock.\n"
                else print "Finished.\n"
        val _ = print "See file barber.out for log.\n"
                  
        val x = TextIO.openOut "barber.out";
      in
        TextIO.output(x,!outputString);
        TextIO.closeOut x
      end
end




@


1.4
log
@[Bug #50000]
Must set max_stack_blocks explicitly so won't overflow default stack.
@
text
@d21 4
d51 1
a51 1
require "$.basis.__int";
d90 1
a90 1
                      | (h::_) => valOf(Int.fromString h)
@


1.4.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a20 4
 *  Revision 1.4  1997/05/16  15:16:48  andreww
 *  [Bug #50000]
 *  Must set max_stack_blocks explicitly so won't overflow default stack.
 *
@


1.3
log
@[Bug #2017]
Adjusting the copyright messages in the demo files.
@
text
@d21 4
d51 1
d203 6
@


1.3.1.1
log
@branched from 1.3
@
text
@a20 4
 *  Revision 1.3  1997/04/03  14:29:39  andreww
 *  [Bug #2017]
 *  Adjusting the copyright messages in the demo files.
 *
@


1.3.1.2
log
@[Bug #50000]
Ensure we have enough stack blocks to give one to each thread.
@
text
@a20 7
 *  Revision 1.3.1.1  1997/05/12  10:24:34  hope
 *  branched from 1.3
 *
 *  Revision 1.4  1997/05/16  15:16:48  andreww
 *  [Bug #50000]
 *  Must set max_stack_blocks explicitly so won't overflow default stack.
 *
a50 1

a201 6

   (* 1. Ensure we have enough stack blocks to give one to each thread.
    * The environment already runs two, and we fork another 8.
    *)

    val _ = MLWorks.Internal.Runtime.Memory.max_stack_blocks:=10;
@


1.3.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a20 4
 *  Revision 1.3.1.2  1997/05/16  16:42:22  daveb
 *  [Bug #50000]
 *  Ensure we have enough stack blocks to give one to each thread.
 *
@


1.3.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a20 4
 *  Revision 1.3.1.2  1997/05/16  16:42:22  daveb
 *  [Bug #50000]
 *  Ensure we have enough stack blocks to give one to each thread.
 *
@


1.3.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a20 4
 *  Revision 1.3.1.2  1997/05/16  16:42:22  daveb
 *  [Bug #50000]
 *  Ensure we have enough stack blocks to give one to each thread.
 *
@


1.3.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a20 3
 *  Revision 1.3.1.2.1.1  1997/07/28  18:09:53  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.2
log
@[Bug #2017]
renaming run function, making sure each variable is reinitialized
every run.
@
text
@d1 6
a6 2
(*
 * The Sleeping Barber problem.  Test for new MLWorks Threads mutexes.
d8 9
a16 1
 * Addison-Wesley 1994)
d21 5
a31 2
 * Copyright (C) 1997 Harlequin Ltd.
 *
a34 13

(* Description
 * (from "Operating Systems Concepts", 4th Ed. Silberschatz and Galvin
 * Addison-Wesley 1994, page 212):

 A barbershop consists of a waiting room with n chairs, and the barber
 room containing the barber chair.  If there are no customers to be served,
 the barber goes to sleep.  If a customer enters the barbershop and all
 the chairs are occupied, then the customer leaves the shop.  If the
 barber is busy, but chairs are available,then the customer sits in one
 of the free chairs.  If the barber is asleep, the customer wakes up
 the barber.
*)
@


1.1
log
@new unit
demo for mutual exclusion primitives.
@
text
@d4 1
d8 5
a12 1
 * $Log:,v$
d21 3
a23 1
(* Description (from "operating systems concepts" page 212):
d99 1
a99 4
  (* The barbershop: a counting mutex, plus a customer queue (n=LIMIT) *)



d198 1
a198 1
    fun run interval timeLimit  =
d202 1
a206 1
      
@
