head	1.5;
access;
symbols
	MLWorks_21c0_1999_03_25:1.5
	MLWorks_20c1_1998_08_20:1.4
	MLWorks_20c0_1998_08_04:1.4
	MLWorks_20b2c2_1998_06_19:1.4
	MLWorks_20b2_Windows_1998_06_12:1.4
	MLWorks_20b1c1_1998_05_07:1.4
	MLWorks_20b0_1998_04_07:1.4
	MLWorks_20b0_1998_03_20:1.4
	MLWorks_20m2_1998_02_16:1.4
	MLWorks_workspace_97:1.4.1
	MLWorks_20m1_1997_10_23:1.4
	MLWorks_11r1:1.3.1.2.1.1.1
	MLWorks_11c0_1997_09_09:1.3.1.2.1.1
	MLWorks_10r3:1.3.1.2.3
	MLWorks_10r2_551:1.3.1.2.2
	MLWorks_11:1.3.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.1.2
	MLWorks_20m0_1997_06_20:1.4
	MLWorks_1_0_r2c2_1997_06_14:1.3.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.3.1
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3;
locks; strict;
comment	@ *  @;


1.5
date	99.03.18.13.21.22;	author johnh;	state Exp;
branches;
next	1.4;

1.4
date	97.05.16.15.11.58;	author andreww;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	97.04.03.14.32.05;	author andreww;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	97.04.03.11.26.22;	author andreww;	state Exp;
branches;
next	1.1;

1.1
date	97.02.06.17.51.23;	author andreww;	state Exp;
branches;
next	;

1.3.1.1
date	97.05.12.10.25.12;	author hope;	state Exp;
branches;
next	1.3.1.2;

1.3.1.2
date	97.05.16.16.42.15;	author daveb;	state Exp;
branches
	1.3.1.2.1.1
	1.3.1.2.2.1
	1.3.1.2.3.1;
next	;

1.3.1.2.1.1
date	97.07.28.18.10.26;	author daveb;	state Exp;
branches
	1.3.1.2.1.1.1.1;
next	;

1.3.1.2.1.1.1.1
date	97.10.07.11.34.33;	author jkbrook;	state Exp;
branches;
next	;

1.3.1.2.2.1
date	97.09.08.17.03.44;	author daveb;	state Exp;
branches;
next	;

1.3.1.2.3.1
date	97.09.09.13.58.36;	author daveb;	state Exp;
branches;
next	;

1.4.1.1
date	97.11.30.16.47.26;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
demo for mutual exclusion primitives.
@


1.5
log
@[Bug #190530]
fix compilation problem.
@
text
@(* ==== THREADS SYNCHRONIZATION EXAMPLES : The readers-writers problem ====
 *
 * Copyright (C) 1997 Harlequin ltd.
 *
 * Description
 * -----------
 * An implementation of the classic readers-writers synchronization problem.
 * It illustrates the use of threads and mutexes.
 * This solution allows as many readers as possible to read a resource
 * at a time, but only one writer.
 *
 * Revision Log:
 * -------------
 * $Log: threads:readers_writers.sml,v $
 *  Revision 1.4  1997/05/16  15:11:58  andreww
 *  [Bug #50000]
 *  Must set max_stack_blocks explicitly so won't overflow default stack.
 *
 *  Revision 1.3  1997/04/03  14:32:05  andreww
 *  [Bug #2017]
 *  Adjusting the copyright messages in the demo files.
 *
 *  Revision 1.2  1997/04/03  11:26:22  andreww
 *  [Bug #2017]
 *  renaming run function.
 *
 *  Revision 1.1  1997/02/06  17:51:23  andreww
 *  new unit
 *  demo for mutual exclusion primitives.
 *
 *
 *
 *)



(* Description (from "operating systems concepts" page 212):

*)




require "$.system.__time";
require "$.basis.__array";
require "$.basis.__timer";
require "$.basis.__string";
require "$.basis.__int32";
require "$.basis.__text_io";
require "$.utils.__mutex";


val deadlockFlag = ref false;

local
  structure T = MLWorks.Threads;
  structure I = T.Internal;
  structure P = I.Preemption;

  (* The output device *)
    
  val output = Mutex.newBinaryMutex false;
  val outputString = ref "";
    
  fun safePrint message = 
    Mutex.critical([output], fn()=>outputString:=(!outputString^message))()
    
  fun unsafePrint message = outputString := (!outputString)^message
    
    
  fun flushOutput () = while (Mutex.query output <>[]) do ()
    
    
    
    
    
    
    
    
    
  (* functions to pass away the time *)
    
    
  fun random() =
    let
      val timeString = Time.fmt 4 (Time.now())
      val number = case (rev(String.tokens (fn c => c= #".") timeString))
                     of [] => 0
                      | (h::_) => valOf(Int32.fromString h)
    in
      number mod 1971
    end;
    
    
  fun occupySomeTime scale message =
    let
      val timeToPass = Time.fromMilliseconds (random()*scale)
      val _ = safePrint message
      val timer = Timer.startRealTimer()
      fun passTime() = if Time.<(Timer.checkRealTimer timer,timeToPass)
                         then passTime()
                       else ()
    in
      passTime()
    end;
    
    
    
    
in    
    
  (* set up stack size: each thread will be allocated one stack block.
   * must make sure that the upper limit of stack blocks is high
   * enough.  We fork eight threads, and two exist in environment.
   *)

  val _ = MLWorks.Internal.Runtime.Memory.max_stack_blocks:=10;

  fun runReadWrite interval timeLimit  =
    let
      
      (* database *)
      
      val datum = ref 0;
      val OKtoWrite = Mutex.newBinaryMutex false;
      val OKtoRead = Mutex.newBinaryMutex false;
        
      (* status *)
        
      val writing = ref false;
      val numReaders = ref 0;    
      val status = Mutex.newBinaryMutex false;      
  (*mutex to ensure exclusive access to the  status flags*)
        

        
        
      fun empty mutex = Mutex.query mutex=[]
        
        

      (* readers *)
        
        
      fun makeReader name =
        while true do
          (
           occupySomeTime 1 "";
           Mutex.await([OKtoRead,status], fn()=> not (!writing));
           numReaders:=(!numReaders)+1;
           Mutex.signal [status,OKtoRead];
           occupySomeTime 1 ("  "^name^" is reading "^
                             (Int32.toString (!datum)^".\n"));
           safePrint ("   "^name^" has finished reading.\n");
           Mutex.wait [status];
           numReaders:=(!numReaders)-1;
           if !numReaders=0 then Mutex.signal [OKtoWrite,status] else
             Mutex.signal [status]
             )
          
          
          
          
      (* writers *)
          
      fun makeWriter name =
        while true do
          (
           occupySomeTime 1 "";
           Mutex.await([OKtoWrite,status],
                       fn()=> not(!writing) andalso !numReaders=0);
           writing:=true;
           Mutex.signal [status];
           datum := (random());
           occupySomeTime 1 (name^
                             " is writing "^(Int32.toString (!datum))^".\n");
           safePrint (name^" has finished writing.\n");
           Mutex.wait [status];
           writing:=false;
           if empty OKtoRead 
             then Mutex.signal [OKtoWrite,status]
           else Mutex.signal [OKtoRead,status]
             )
          
      
  
      val _ = outputString:=""
      val _ = writing:=false
      val _ = numReaders:=0
        
      (*  set up the threads mechanism *)
      val _ = P.set_interval interval;
      val _ = P.start();
        
      val id1 = T.fork makeWriter "Voltaire"
      val id2 = T.fork makeWriter "Tolstoy"
      val id3 = T.fork makeWriter "Hemmingway"
      val id4 = T.fork makeReader "Arthur"
      val id5 = T.fork makeReader "Betty"
      val id6 = T.fork makeReader "Charles"
      val id7 = T.fork makeReader "Diana"
        
        
      (* Deadlock detection *)
        
      val _ = deadlockFlag:=false;
        
      fun detectDeadlock () =
        if Mutex.allSleeping [id1,id2,id3,id4,id5,id6,id7]
          then deadlockFlag:=true
        else detectDeadlock()
          
      val dd = T.fork detectDeadlock ()
        
        
        
      fun checkTime timer =
        if Time.toSeconds(Timer.checkRealTimer timer)<timeLimit
          andalso not(!deadlockFlag) 
          then checkTime timer
        else (I.kill id1;
              I.kill id2;
              I.kill id3;
              I.kill id4;
              I.kill id5;
              I.kill id6;
              I.kill id7;
              if !deadlockFlag then () else I.kill dd)
               
               
      val timer = Timer.startRealTimer()
      val _ = checkTime timer
        
      val _ = if !deadlockFlag then print "Deadlock.\n" 
              else print "Finished.\n"
      val _ = print "See file read_write.out for log.\n"
      val x = TextIO.openOut "read_write.out"
    in
      TextIO.output(x,!outputString);
      TextIO.closeOut x
    end

end





@


1.4
log
@[Bug #50000]
Must set max_stack_blocks explicitly so won't overflow default stack.
@
text
@d15 4
d48 1
a48 1
require "$.basis.__int";
d89 1
a89 1
                      | (h::_) => valOf(Int.fromString h)
d153 1
a153 1
                             (Int.toString (!datum)^".\n"));
d176 1
a176 1
                             " is writing "^(Int.toString (!datum))^".\n");
@


1.4.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a14 4
 *  Revision 1.4  1997/05/16  15:11:58  andreww
 *  [Bug #50000]
 *  Must set max_stack_blocks explicitly so won't overflow default stack.
 *
@


1.3
log
@[Bug #2017]
Adjusting the copyright messages in the demo files.
@
text
@d15 4
d108 7
a116 3
      
      
      
@


1.3.1.1
log
@branched from 1.3
@
text
@a14 4
 *  Revision 1.3  1997/04/03  14:32:05  andreww
 *  [Bug #2017]
 *  Adjusting the copyright messages in the demo files.
 *
@


1.3.1.2
log
@[Bug #50000]
Ensure we have enough stack blocks to give one to each thread.
@
text
@a14 7
 *  Revision 1.3.1.1  1997/05/12  10:25:12  hope
 *  branched from 1.3
 *
 *  Revision 1.4  1997/05/16  15:11:58  andreww
 *  [Bug #50000]
 *  Must set max_stack_blocks explicitly so won't overflow default stack.
 *
a107 7
  (* set up stack size: each thread will be allocated one stack block.
   * must make sure that the upper limit of stack blocks is high
   * enough.  We fork eight threads, and two exist in environment.
   *)

  val _ = MLWorks.Internal.Runtime.Memory.max_stack_blocks:=10;

d110 3
@


1.3.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a14 4
 *  Revision 1.3.1.2  1997/05/16  16:42:15  daveb
 *  [Bug #50000]
 *  Ensure we have enough stack blocks to give one to each thread.
 *
@


1.3.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a14 4
 *  Revision 1.3.1.2  1997/05/16  16:42:15  daveb
 *  [Bug #50000]
 *  Ensure we have enough stack blocks to give one to each thread.
 *
@


1.3.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a14 4
 *  Revision 1.3.1.2  1997/05/16  16:42:15  daveb
 *  [Bug #50000]
 *  Ensure we have enough stack blocks to give one to each thread.
 *
@


1.3.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a14 3
 *  Revision 1.3.1.2.1.1  1997/07/28  18:10:26  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.2
log
@[Bug #2017]
renaming run function.
@
text
@d1 10
a10 2
(*
 * The Readers and Writers problem.
d15 4
a24 2
 * Copyright (C) 1997 Harlequin Ltd.
 *
a30 2
  As many readers as possible may read a resource at a time,
  but only one writer.
@


1.1
log
@new unit
demo for mutual exclusion primitives.
@
text
@d6 5
a10 1
 * $Log:,v$
d96 1
a96 1
  fun run interval timeLimit  =
@
