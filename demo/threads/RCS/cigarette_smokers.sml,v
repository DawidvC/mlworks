head	1.5;
access;
symbols
	MLWorks_21c0_1999_03_25:1.5
	MLWorks_20c1_1998_08_20:1.4
	MLWorks_20c0_1998_08_04:1.4
	MLWorks_20b2c2_1998_06_19:1.4
	MLWorks_20b2_Windows_1998_06_12:1.4
	MLWorks_20b1c1_1998_05_07:1.4
	MLWorks_20b0_1998_04_07:1.4
	MLWorks_20b0_1998_03_20:1.4
	MLWorks_20m2_1998_02_16:1.4
	MLWorks_workspace_97:1.4.1
	MLWorks_20m1_1997_10_23:1.4
	MLWorks_11r1:1.3.1.2.1.1.1
	MLWorks_11c0_1997_09_09:1.3.1.2.1.1
	MLWorks_10r3:1.3.1.2.3
	MLWorks_10r2_551:1.3.1.2.2
	MLWorks_11:1.3.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.1.2
	MLWorks_20m0_1997_06_20:1.4
	MLWorks_1_0_r2c2_1997_06_14:1.3.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.3.1
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3;
locks; strict;
comment	@ *  @;


1.5
date	99.03.18.13.21.20;	author johnh;	state Exp;
branches;
next	1.4;

1.4
date	97.05.16.15.13.52;	author andreww;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	97.04.03.14.26.21;	author andreww;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	97.04.03.11.55.21;	author andreww;	state Exp;
branches;
next	1.1;

1.1
date	97.02.06.17.35.10;	author andreww;	state Exp;
branches;
next	;

1.3.1.1
date	97.05.12.10.23.47;	author hope;	state Exp;
branches;
next	1.3.1.2;

1.3.1.2
date	97.05.16.16.42.02;	author daveb;	state Exp;
branches
	1.3.1.2.1.1
	1.3.1.2.2.1
	1.3.1.2.3.1;
next	;

1.3.1.2.1.1
date	97.07.28.18.10.33;	author daveb;	state Exp;
branches
	1.3.1.2.1.1.1.1;
next	;

1.3.1.2.1.1.1.1
date	97.10.07.11.34.44;	author jkbrook;	state Exp;
branches;
next	;

1.3.1.2.2.1
date	97.09.08.17.03.51;	author daveb;	state Exp;
branches;
next	;

1.3.1.2.3.1
date	97.09.09.13.58.51;	author daveb;	state Exp;
branches;
next	;

1.4.1.1
date	97.11.30.16.48.54;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
demo for mutual exclusion primitives.
@


1.5
log
@[Bug #190530]
fix compilation problem.
@
text
@(* ==== THREADS SYNCHRONIZATION EXAMPLES: cigarette smokers problem ====
 *
 * Copyright (C) 1997 Harlequin Ltd.
 *
 * Description
 * -----------
 * (from "Operating Systems Concepts", 4th Ed. Silberschatz and Galvin
 * Addison-Wesley 1994, page 212):
 *
 * Consider a system with three smoker processes and one agent process.
 * Each smoker continuously rolls a cigarette and then smokes it.  But
 * to roll and smoke a cigarette, the smoker needs three ingredients:
 * tobacco, paper and matches.  One of the smoker processes has paper,
 * another has tobacco, and the third has matches.  The agent has an
 * infinite supply of all three materials.  The agent places two of the
 * ingredients on the table.  The smoker who has the remaining ingredient
 * then makes and smokes a cigarette, signaling the agent on completion.
 * The agent then puts out another two of the three ingredients, and the
 * cycle repeats.
 *
 * Revision Log:
 * -------------
 * $Log: threads:cigarette_smokers.sml,v $
 *  Revision 1.4  1997/05/16  15:13:52  andreww
 *  [Bug #50000]
 *  Must set max_stack_blocks explicitly so won't overflow default stack.
 *
 *  Revision 1.3  1997/04/03  14:26:21  andreww
 *  [Bug #2017]
 *  Adjusting the copyright messages in the demo files.
 *
 *  Revision 1.2  1997/04/03  11:55:21  andreww
 *  [Bug #2017]
 *  renaming run functions.
 *
 *  Revision 1.1  1997/02/06  17:35:10  andreww
 *  new unit
 *  demo for mutual exclusion primitives.
 *
 *
 *
 *)






require "$.system.__time";
require "$.basis.__array";
require "$.basis.__timer";
require "$.basis.__string";
require "$.basis.__list";
require "$.basis.__int32";
require "$.basis.__text_io";
require "$.utils.__mutex";


local
  
  structure T = MLWorks.Threads;
  structure I = T.Internal;
  structure P = I.Preemption;
    
    
  (* The output device *)
    
  val output = Mutex.newBinaryMutex false;
  val outputString = ref "";
    
  fun safePrint message = 
    Mutex.critical([output], fn()=>outputString:=(!outputString^message))()
    
  fun unsafePrint message = outputString := (!outputString)^message
    
    
  fun flushOutput () = while (Mutex.query output <>[]) do ()
    
    







  (* functions to pass away the time *)


  fun random() =
    let
      val timeString = Time.fmt 4 (Time.now())
      val number = case (rev(String.tokens (fn c => c= #".") timeString))
                     of [] => 0
                      | (h::_) => valOf(Int32.fromString h)
    in
      number mod 1971
    end;
    
    
  fun occupySomeTime scale message =
    let
      val timeToPass = Time.fromMilliseconds (random()*scale)
      val _ = safePrint message
      val timer = Timer.startRealTimer()
      fun passTime() = if Time.<(Timer.checkRealTimer timer,timeToPass)
                         then passTime()
                       else ()
    in
      passTime()
    end;
    
    
  val deadlockFlag = ref false;
    
in    
  (* must set max limit of stack blocks high enough to give one block
   * to each thread.  2 threads already exist in the environment, and
   * we create a further 5.
   *)
    
  val _ = MLWorks.Internal.Runtime.Memory.max_stack_blocks:=7;

    
  fun runSmokers interval timeLimit  =
    let
      val paper = Mutex.newBinaryMutex true;
      val tobacco = Mutex.newBinaryMutex true;
      val matches = Mutex.newBinaryMutex true;
      val smoked = Mutex.newBinaryMutex true;
        
        
      fun makeSmoker (name,item1,item2) =
        let
          fun smoking() =
            while true do
              (
               Mutex.wait [item1,item2];
               occupySomeTime 1 (name^" has lit up.\n");
               Mutex.signal [smoked]
               )
        in
          smoking
        end
      
      
      
      fun makeAgent() =
        let
          fun supply() =
            while true do
              (
               let val (mesg,items) = 
                 case (random() mod 3)
                   of 0 => ("paper and matches",[paper,matches])
                    | 1 => ("paper and tobacco",[paper,tobacco])
                    | 2 => ("matches and tobacco",[matches,tobacco])
                    | _ => ("",[])
                     
               in
                 safePrint ("The agent has supplied "^mesg^".\n");
                 Mutex.signal items;
                 Mutex.wait [smoked]
               end
               )
        in
          supply
        end
      
      
      
    (*  set up the threads mechanism *)
  
      val _ = outputString:=""
        
      val p1 = makeAgent ()
      val p2 = makeSmoker ("The Marlboro man",matches,tobacco)
      val p3 = makeSmoker ("Humphrey Bogart",paper,matches)
      val p4 = makeSmoker ("The man in the Iron Lung",paper,tobacco)
        
        
      (*  set up the threads mechanism *)
      val _ = P.set_interval interval;
      val _ = P.start();
        
      val id1 = T.fork p1 ()
      val id2 = T.fork p2 ()
      val id3 = T.fork p3 ()
      val id4 = T.fork p4 ()
        
        
        
        
      (* Deadlock detection *)
        
      val _ = deadlockFlag:=false;
        
      fun detectDeadlock () =
        if Mutex.allSleeping [id1,id2,id3,id4]
          then deadlockFlag:=true
        else detectDeadlock()
          
      val dd = T.fork detectDeadlock ()
        
        
        
        
        
      (* set up a timer *)
        
      fun checkTime timer =
        if Time.toSeconds(Timer.checkRealTimer timer)<timeLimit
          andalso not (!deadlockFlag)
               then checkTime timer
             else (I.kill id1;
                   I.kill id2;
                   I.kill id3;
                   I.kill id4;
                   if !deadlockFlag then () else I.kill dd)
               
               
      val timer = Timer.startRealTimer()
      val _ = checkTime timer
        
      val _ = if !deadlockFlag then print "Deadlock.\n" 
              else print "Finished.\n"
      val _ = print "See file smokers.out for log.\n"
      val x = TextIO.openOut "smokers.out"
    in
      TextIO.output(x,!outputString);
      TextIO.closeOut x
    end
end




@


1.4
log
@[Bug #50000]
Must set max_stack_blocks explicitly so won't overflow default stack.
@
text
@d24 4
d54 1
a54 1
require "$.basis.__int";
d95 1
a95 1
                      | (h::_) => valOf(Int.fromString h)
@


1.4.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a23 4
 *  Revision 1.4  1997/05/16  15:13:52  andreww
 *  [Bug #50000]
 *  Must set max_stack_blocks explicitly so won't overflow default stack.
 *
@


1.3
log
@[Bug #2017]
Adjusting the copyright messages in the demo files.
@
text
@d24 4
d54 1
d113 4
d118 2
@


1.3.1.1
log
@branched from 1.3
@
text
@a23 4
 *  Revision 1.3  1997/04/03  14:26:21  andreww
 *  [Bug #2017]
 *  Adjusting the copyright messages in the demo files.
 *
@


1.3.1.2
log
@[Bug #50000]
Ensure we have enough stack blocks to give one to each thread.
@
text
@a23 7
 *  Revision 1.3.1.1  1997/05/12  10:23:47  hope
 *  branched from 1.3
 *
 *  Revision 1.4  1997/05/16  15:13:52  andreww
 *  [Bug #50000]
 *  Must set max_stack_blocks explicitly so won't overflow default stack.
 *
a53 1

a111 4
  (* must set max limit of stack blocks high enough to give one block
   * to each thread.  2 threads already exist in the environment, and
   * we create a further 5.
   *)
a112 2
  val _ = MLWorks.Internal.Runtime.Memory.max_stack_blocks:=7;

@


1.3.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a23 4
 *  Revision 1.3.1.2  1997/05/16  16:42:02  daveb
 *  [Bug #50000]
 *  Ensure we have enough stack blocks to give one to each thread.
 *
@


1.3.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a23 4
 *  Revision 1.3.1.2  1997/05/16  16:42:02  daveb
 *  [Bug #50000]
 *  Ensure we have enough stack blocks to give one to each thread.
 *
@


1.3.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a23 4
 *  Revision 1.3.1.2  1997/05/16  16:42:02  daveb
 *  [Bug #50000]
 *  Ensure we have enough stack blocks to give one to each thread.
 *
@


1.3.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a23 3
 *  Revision 1.3.1.2.1.1  1997/07/28  18:10:33  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.2
log
@[Bug #2017]
renaming run functions.
@
text
@d1 6
a6 2
(*
 * The Cigarette Smokers problem.  Test for new MLWorks Threads mutexes.
d8 12
a19 1
 * Addison-Wesley 1994)
d24 4
a33 2
 * Copyright (C) 1997 Harlequin Ltd.
 *
a36 16

(* Description
 * (from "Operating Systems Concepts", 4th Ed. Silberschatz and Galvin
 * Addison-Wesley 1994, page 212):

  Consider a system with three smoker processes and one agent process.
  Each smoker continuously rolls a cigarette and then smokes it.  But
  to roll and smoke a cigarette, the smoker needs three ingredients:
  tobacco, paper and matches.  One of the smoker processes has paper,
  another has tobacco, and the third has matches.  The agent has an
  infinite supply of all three materials.  The agent places two of the
  ingredients on the table.  The smoker who has the remaining ingredient
  then makes and smokes a cigarette, signaling the agent on completion.
  The agent then puts out another two of the three ingredients, and the
  cycle repeats.
*)
@


1.1
log
@new unit
demo for mutual exclusion primitives.
@
text
@d4 1
d8 5
a12 1
 * $Log:,v$
d21 3
a23 1
(* Description (from "operating systems concepts" page 212):
d109 1
a109 1
  fun run interval timeLimit  =
@
