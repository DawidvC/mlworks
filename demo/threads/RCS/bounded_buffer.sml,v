head	1.4;
access;
symbols
	MLWorks_21c0_1999_03_25:1.4
	MLWorks_20c1_1998_08_20:1.4
	MLWorks_20c0_1998_08_04:1.4
	MLWorks_20b2c2_1998_06_19:1.4
	MLWorks_20b2_Windows_1998_06_12:1.4
	MLWorks_20b1c1_1998_05_07:1.4
	MLWorks_20b0_1998_04_07:1.4
	MLWorks_20b0_1998_03_20:1.4
	MLWorks_20m2_1998_02_16:1.4
	MLWorks_workspace_97:1.4.1
	MLWorks_20m1_1997_10_23:1.4
	MLWorks_11r1:1.3.1.2.1.1.1
	MLWorks_11c0_1997_09_09:1.3.1.2.1.1
	MLWorks_10r3:1.3.1.2.3
	MLWorks_10r2_551:1.3.1.2.2
	MLWorks_11:1.3.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.1.2
	MLWorks_20m0_1997_06_20:1.4
	MLWorks_1_0_r2c2_1997_06_14:1.3.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.3.1
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3;
locks; strict;
comment	@ *  @;


1.4
date	97.05.16.15.05.29;	author andreww;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	97.04.03.14.24.36;	author andreww;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	97.04.03.11.34.48;	author andreww;	state Exp;
branches;
next	1.1;

1.1
date	97.02.06.17.39.20;	author andreww;	state Exp;
branches;
next	;

1.3.1.1
date	97.05.12.10.24.28;	author hope;	state Exp;
branches;
next	1.3.1.2;

1.3.1.2
date	97.05.16.16.41.55;	author daveb;	state Exp;
branches
	1.3.1.2.1.1
	1.3.1.2.2.1
	1.3.1.2.3.1;
next	;

1.3.1.2.1.1
date	97.07.28.18.10.30;	author daveb;	state Exp;
branches
	1.3.1.2.1.1.1.1;
next	;

1.3.1.2.1.1.1.1
date	97.10.07.11.34.40;	author jkbrook;	state Exp;
branches;
next	;

1.3.1.2.2.1
date	97.09.08.17.03.49;	author daveb;	state Exp;
branches;
next	;

1.3.1.2.3.1
date	97.09.09.13.58.46;	author daveb;	state Exp;
branches;
next	;

1.4.1.1
date	97.11.30.16.48.51;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
demo for mutual exclusion primitives.
@


1.4
log
@[Bug #50000]
Must set max_stack_blocks explicitly so won't overflow default stack.
@
text
@(* ==== THREAD SYNCHRONIZATION EXAMPLES : bounded buffers ====
 *
 * Copyright (C) 1997 Harlequin Ltd.
 *
 * Description
 * -----------
 * An implementation of the classic producer/consumer synchronization
 * problem.  It illustrates the use of threads and mutexes.
 *
 * Revision Log:
 * -------------
 * $Log: threads:bounded_buffer.sml,v $
 *  Revision 1.3  1997/04/03  14:24:36  andreww
 *  [Bug #2017]
 *  Adjusting the copyright messages in the demo files.
 *
 *  Revision 1.2  1997/04/03  11:34:48  andreww
 *  [Bug #2017]
 *  renaming run functions.
 *
 *  Revision 1.1  1997/02/06  17:39:20  andreww
 *  new unit
 *  demo for mutual exclusion primitives.
 *
 *
 *
 *)

require "$.system.__time";
require "$.basis.__array";
require "$.basis.__timer";
require "$.utils.__mutex";

local
  structure T = MLWorks.Threads;
  structure I = T.Internal;
  structure P = I.Preemption;
    
    
  (* shared resource *)
    
  local
    val buffer = Array.array(10,0);
    val size = ref 0;
    val putIndex = ref 0;
    val getIndex = ref 0;
  in
    fun addToBuffer x = 
      (if !size=10 then print "data lost!\n"       (* shouldn't happen*)
       else size:= !size+1;
         Array.update(buffer,!putIndex,x);
         putIndex:=(!putIndex+1) mod 10)
         
    fun readFromBuffer () =
      (if !size=0 then print "phantom data!\n"     (*shouldn't happen*)
       else size:= !size-1;
         Array.sub(buffer,!getIndex) before
         getIndex:=(!getIndex+1) mod 10)
  end



  (* mutexes for buffer access *)

  val access = Mutex.newBinaryMutex false;
  val empty = Mutex.newCountingMutex 10;
  val full = Mutex.newCountingMutex 0;
    
    
    
  (* producer *)
    
  fun makeProducer () =
    let
      val producerData = ref 0;
        
      fun nextItem()=(!producerData) before (producerData:=(!producerData)+1);
        
      fun produce() =
        while true do
          let val item = nextItem()
          in
            Mutex.wait [empty];
            Mutex.critical([access],addToBuffer) item;
            Mutex.signal [full]
          end
    in
      produce
    end






  (* consumer *)

  val output: int list ref = ref []
    
  fun makeConsumer () =
    let
      fun processDatum x = output:= x::(!output)
      
      fun consume() =
        while true do
          let
            val _ = Mutex.wait [full];
            val datum = Mutex.critical([access],readFromBuffer)();
            val _ = Mutex.signal [empty];
          in
            processDatum datum
          end
    in
      consume
    end
  


  val deadlockFlag = ref false;


in

  (*  set up the threads mechanism *)

  (* 1. We must ensure that there is enough stack space: each thread
   *    is allocated one stack block.  We fork three threads, and have
   *    two already existing in the environment.
   *)

  val _ = MLWorks.Internal.Runtime.Memory.max_stack_blocks:=5;


  fun runProdCons interval timeLimit =
    let
      
      val _ = output:=[]
        
      val p1 = makeProducer()
      val p2 = makeConsumer()
        
        
      (*  set up the threads mechanism *)
      val _ = P.set_interval interval;
      val _ = P.start();
        
      val id1 = T.fork p1 ()
      val id2 = T.fork p2 ()
        
        
      fun detectDeadlock() =
        if Mutex.allSleeping [id1,id2]
          then deadlockFlag:=true
        else detectDeadlock()
          
      val _ = deadlockFlag:=false
      val dd = T.fork detectDeadlock ()
        
        
        
        
        
        
      fun checkTime timer =
        if !deadlockFlag then ()
        else if Time.toSeconds(Timer.checkRealTimer timer)<timeLimit
               then checkTime timer
             else (I.kill id1;
                   I.kill id2;
                   if !deadlockFlag then () else I.kill dd)
               
               
               
               
      (* set up a timer *)
               
      val timer = Timer.startRealTimer()
      val _ =  checkTime timer
        
      val _ = if !deadlockFlag then print "Deadlock.\n" 
              else print "Finished.\n"
                
    in
      ()
    end
  
  
  

  fun testOutput () =
    let
      fun testOK ([],_) = true
        | testOK (h::t,n) = h+1=n andalso testOK(t,h)
    in
      case (!output)
        of [] => true
         | (h::t) => testOK (t,h)
    end
  
end  


val testAnswer = (runProdCons 1 10; testOutput())
@


1.4.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a12 4
 *  Revision 1.4  1997/05/16  15:05:29  andreww
 *  [Bug #50000]
 *  Must set max_stack_blocks explicitly so won't overflow default stack.
 *
@


1.3
log
@[Bug #2017]
Adjusting the copyright messages in the demo files.
@
text
@d13 4
d125 7
@


1.3.1.1
log
@branched from 1.3
@
text
@a12 4
 *  Revision 1.3  1997/04/03  14:24:36  andreww
 *  [Bug #2017]
 *  Adjusting the copyright messages in the demo files.
 *
@


1.3.1.2
log
@[Bug #50000]
Ensure we have enough stack blocks to give one to each thread.
@
text
@a12 7
 *  Revision 1.3.1.1  1997/05/12  10:24:28  hope
 *  branched from 1.3
 *
 *  Revision 1.4  1997/05/16  15:05:29  andreww
 *  [Bug #50000]
 *  Must set max_stack_blocks explicitly so won't overflow default stack.
 *
a124 7

  (* 1. We must ensure that there is enough stack space: each thread
   *    is allocated one stack block.  We fork three threads, and have
   *    two already existing in the environment.
   *)

  val _ = MLWorks.Internal.Runtime.Memory.max_stack_blocks:=5;
@


1.3.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 4
 *  Revision 1.3.1.2  1997/05/16  16:41:55  daveb
 *  [Bug #50000]
 *  Ensure we have enough stack blocks to give one to each thread.
 *
@


1.3.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 4
 *  Revision 1.3.1.2  1997/05/16  16:41:55  daveb
 *  [Bug #50000]
 *  Ensure we have enough stack blocks to give one to each thread.
 *
@


1.3.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 4
 *  Revision 1.3.1.2  1997/05/16  16:41:55  daveb
 *  [Bug #50000]
 *  Ensure we have enough stack blocks to give one to each thread.
 *
@


1.3.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a12 3
 *  Revision 1.3.1.2.1.1  1997/07/28  18:10:30  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.2
log
@[Bug #2017]
renaming run functions.
@
text
@d1 8
a8 2
(*
 * Bounded Buffers implementation.  Test for new MLWorks Threads mutexes.
d13 4
a21 2
 *
 * Copyright (C) 1997 Harlequin Ltd.
@


1.1
log
@new unit
demo for mutual exclusion primitives.
@
text
@d6 5
a10 1
 * $Log:,v$
d115 1
a115 1
  fun run interval timeLimit =
d184 1
a184 1
val testAnswer = (run 1 10; testOutput())
@
