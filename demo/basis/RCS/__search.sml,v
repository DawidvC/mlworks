head	1.2;
access;
symbols
	MLWorks_21c0_1999_03_25:1.2
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2
	MLWorks_20b1c1_1998_05_07:1.2
	MLWorks_20b0_1998_04_07:1.2
	MLWorks_20b0_1998_03_20:1.2
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_workspace_97:1.2.8
	MLWorks_20m1_1997_10_23:1.2
	MLWorks_11r1:1.2.7.1.1.1.1
	MLWorks_11c0_1997_09_09:1.2.7.1.1.1
	MLWorks_10r3:1.2.7.1.3
	MLWorks_10r2_551:1.2.7.1.2
	MLWorks_11:1.2.7.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.2.7.1
	MLWorks_20m0_1997_06_20:1.2
	MLWorks_1_0_r2c2_1997_06_14:1.2.7.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.2.7.1
	MLWorks_1_0_r2c1_1997_05_12:1.2.7
	MLWorks_BugFix_1997_04_24:1.2
	MLWorks_1_0_r2_Win32_1997_04_11:1.2
	MLWorks_1_0_r2_Unix_1997_04_04:1.2
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.2.6.1.1
	MLWorks_1_0_Win32_1996_12_17:1.2.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.2.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.2.4.1
	MLWorks_1_0_Irix_1996_11_28:1.2.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.2.5
	MLWorks_1_0_Unix_1996_11_14:1.2.4
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.1;
locks; strict;
comment	@ *  @;


1.2
date	96.09.04.11.56.24;	author jont;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1
	1.2.4.1
	1.2.5.1
	1.2.6.1
	1.2.7.1
	1.2.8.1;
next	1.1;

1.1
date	96.08.09.18.00.06;	author davids;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.07.05;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.15.58.15;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.16.33;	author hope;	state Exp;
branches;
next	;

1.2.4.1
date	96.11.14.12.39.45;	author hope;	state Exp;
branches
	1.2.4.1.1.1;
next	;

1.2.4.1.1.1
date	96.11.28.14.51.39;	author hope;	state Exp;
branches;
next	;

1.2.5.1
date	96.11.22.18.00.17;	author hope;	state Exp;
branches;
next	;

1.2.6.1
date	96.12.17.17.39.12;	author hope;	state Exp;
branches
	1.2.6.1.1.1;
next	;

1.2.6.1.1.1
date	97.02.24.11.26.22;	author hope;	state Exp;
branches;
next	;

1.2.7.1
date	97.05.12.10.24.09;	author hope;	state Exp;
branches
	1.2.7.1.1.1
	1.2.7.1.2.1
	1.2.7.1.3.1;
next	;

1.2.7.1.1.1
date	97.07.28.18.10.06;	author daveb;	state Exp;
branches
	1.2.7.1.1.1.1.1;
next	;

1.2.7.1.1.1.1.1
date	97.10.07.11.34.03;	author jkbrook;	state Exp;
branches;
next	;

1.2.7.1.2.1
date	97.09.08.17.03.25;	author daveb;	state Exp;
branches;
next	;

1.2.7.1.3.1
date	97.09.09.13.58.02;	author daveb;	state Exp;
branches;
next	;

1.2.8.1
date	97.11.30.16.47.05;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.2
log
@Make require statements absolute
@
text
@(*  ==== BASIS EXAMPLES : Search structure ====
 *
 *  Copyright (C) 1996 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This module searches a stream for a string by using a simple brute force
 *  algorithm.  It demonstrates the use of the TextIO structure, in particular
 *  the underlying functional streams used in the TextIO.StreamIO structure.
 *
 *  Revision Log
 *  ------------
 *  $Log: basis:__search.sml,v $
 *  Revision 1.1  1996/08/09  18:00:06  davids
 *  new unit
 *
 *
 *)


require "search.sml";
require "$.basis.__text_io";
require "$.basis.__string";

structure Search : SEARCH =
  struct


    (* Search along the stream and string to see if 'searchString' is found
     at this point in 'strm'. *)

    fun search' (strm, searchString, pos) =
      case TextIO.StreamIO.input1 strm of
	NONE => false
      | SOME (chr, nextStrm) =>
	  pos >= size searchString orelse
	  
	  if chr = String.sub (searchString, pos) then
	    search' (nextStrm, searchString, pos + 1)
	  else
	    false
	  

    (* Search through 'strm' until 'searchString' is found within it.  Return
     the remaining stream, or NONE if no match is found. *)

    fun search (strm, searchString) =
      case TextIO.StreamIO.input1 strm of
	NONE => NONE
      | SOME (chr, nextStrm) => 
	  if search' (strm, searchString, 0) then
	    SOME strm
	  else
	    search (nextStrm, searchString)
	

    (* Consume all characters in 'inputStream' up to the first occurrence of
     'searchString', if it exists.  This is done here by converting the
     imperative 'inputStream' into a functional stream, searching this, and
     assigning the result back to the imperative stream. *)

    fun searchStream (inputStream, searchString) =
      let
	val funcStream = TextIO.getInstream inputStream
      in
	case search (funcStream, searchString) of
	  NONE => ignore (TextIO.inputAll inputStream)
	| SOME resultStream => TextIO.setInstream (inputStream, resultStream)
      end


    (* Determine whether 'searchString' is contained somewhere within the file
     'filename'. *)

    fun searchFile (filename, searchString) =
      let
	val strm = TextIO.openIn filename      
	val _ = searchStream (strm, searchString)
	val matchFound = not (TextIO.endOfStream strm)
	val _ = TextIO.closeIn strm
      in
	matchFound
      end


    (* Use the standard input stream to ask the user for the strings to
     search with.  Return the answer on the standard output stream by
     using TextIO.print *)

    fun searchInput () =
      let
	fun removeNewline s = String.extract (s, 0, SOME (size s - 1))
	val _ = TextIO.print "Enter string to search through:\n"
        val inputString = removeNewline (TextIO.inputLine TextIO.stdIn)
	val _ = TextIO.print "Enter string to search for:\n"
	val searchString = removeNewline (TextIO.inputLine TextIO.stdIn)
	val strm = TextIO.openString inputString
	val _ = searchStream (strm, searchString)
	val resultString = TextIO.inputAll strm
	val _ = TextIO.closeIn strm
      in
	case resultString of
	  "" => TextIO.print "String not found.\n"
	| s => TextIO.print ("String found at:\n" ^ s ^ "\n")
      end
      
  end
@


1.2.8.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a13 3
 *  Revision 1.2  1996/09/04  11:56:24  jont
 *  Make require statements absolute
 *
@


1.2.7.1
log
@branched from 1.2
@
text
@a13 3
 *  Revision 1.2  1996/09/04  11:56:24  jont
 *  Make require statements absolute
 *
@


1.2.7.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a13 3
 *  Revision 1.2.7.1  1997/05/12  10:24:09  hope
 *  branched from 1.2
 *
@


1.2.7.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a13 3
 *  Revision 1.2.7.1  1997/05/12  10:24:09  hope
 *  branched from 1.2
 *
@


1.2.7.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a13 3
 *  Revision 1.2.7.1  1997/05/12  10:24:09  hope
 *  branched from 1.2
 *
@


1.2.7.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a13 3
 *  Revision 1.2.7.1.1.1  1997/07/28  18:10:06  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.2.6.1
log
@branched from 1.2
@
text
@a13 3
 *  Revision 1.2  1996/09/04  11:56:24  jont
 *  Make require statements absolute
 *
@


1.2.6.1.1.1
log
@branched from 1.2.6.1
@
text
@a13 3
 *  Revision 1.2.6.1  1996/12/17  17:39:12  hope
 *  branched from 1.2
 *
@


1.2.5.1
log
@branched from 1.2
@
text
@a13 3
 *  Revision 1.2  1996/09/04  11:56:24  jont
 *  Make require statements absolute
 *
@


1.2.4.1
log
@branched from 1.2
@
text
@a13 3
 *  Revision 1.2  1996/09/04  11:56:24  jont
 *  Make require statements absolute
 *
@


1.2.4.1.1.1
log
@branched from 1.2.4.1
@
text
@a13 3
 *  Revision 1.2.4.1  1996/11/14  12:39:45  hope
 *  branched from 1.2
 *
@


1.2.3.1
log
@branched from 1.2
@
text
@a13 3
 *  Revision 1.2  1996/09/04  11:56:24  jont
 *  Make require statements absolute
 *
@


1.2.2.1
log
@branched from 1.2
@
text
@a13 3
 *  Revision 1.2  1996/09/04  11:56:24  jont
 *  Make require statements absolute
 *
@


1.2.1.1
log
@branched from 1.2
@
text
@a13 3
 *  Revision 1.2  1996/09/04  11:56:24  jont
 *  Make require statements absolute
 *
@


1.1
log
@new unit
@
text
@d13 4
a16 1
 *  $Log$
d22 2
a23 2
require "basis.__text_io";
require "basis.__string";
@
