head	1.3;
access;
symbols
	MLWorks_21c0_1999_03_25:1.3
	MLWorks_20c1_1998_08_20:1.3
	MLWorks_20c0_1998_08_04:1.3
	MLWorks_20b2c2_1998_06_19:1.3
	MLWorks_20b2_Windows_1998_06_12:1.3
	MLWorks_20b1c1_1998_05_07:1.3
	MLWorks_20b0_1998_04_07:1.3
	MLWorks_20b0_1998_03_20:1.3
	MLWorks_20m2_1998_02_16:1.3
	MLWorks_workspace_97:1.3.5
	MLWorks_20m1_1997_10_23:1.3
	MLWorks_11r1:1.3.4.1.1.1.1
	MLWorks_11c0_1997_09_09:1.3.4.1.1.1
	MLWorks_10r3:1.3.4.1.3
	MLWorks_10r2_551:1.3.4.1.2
	MLWorks_11:1.3.4.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.4.1
	MLWorks_20m0_1997_06_20:1.3
	MLWorks_1_0_r2c2_1997_06_14:1.3.4.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.4.1
	MLWorks_1_0_r2c1_1997_05_12:1.3.4
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.3.3.1.1
	MLWorks_1_0_Win32_1996_12_17:1.3.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.3.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.3.1.1
	MLWorks_1_0_Irix_1996_11_28:1.3.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.3.2
	MLWorks_1_0_Unix_1996_11_14:1.3.1
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.1;
locks; strict;
comment	@ *  @;


1.3
date	96.11.06.11.55.27;	author matthew;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1
	1.3.4.1
	1.3.5.1;
next	1.2;

1.2
date	96.09.04.11.55.34;	author jont;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1;
next	1.1;

1.1
date	96.07.26.15.02.04;	author davids;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.07.02;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.15.58.10;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.16.30;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	96.11.14.12.39.34;	author hope;	state Exp;
branches
	1.3.1.1.1.1;
next	;

1.3.1.1.1.1
date	96.11.28.14.51.33;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.11.22.18.00.12;	author hope;	state Exp;
branches;
next	;

1.3.3.1
date	96.12.17.17.39.06;	author hope;	state Exp;
branches
	1.3.3.1.1.1;
next	;

1.3.3.1.1.1
date	97.02.24.11.26.16;	author hope;	state Exp;
branches;
next	;

1.3.4.1
date	97.05.12.10.24.01;	author hope;	state Exp;
branches
	1.3.4.1.1.1
	1.3.4.1.2.1
	1.3.4.1.3.1;
next	;

1.3.4.1.1.1
date	97.07.28.18.10.04;	author daveb;	state Exp;
branches
	1.3.4.1.1.1.1.1;
next	;

1.3.4.1.1.1.1.1
date	97.10.07.11.33.55;	author jkbrook;	state Exp;
branches;
next	;

1.3.4.1.2.1
date	97.09.08.17.03.22;	author daveb;	state Exp;
branches;
next	;

1.3.4.1.3.1
date	97.09.09.13.57.59;	author daveb;	state Exp;
branches;
next	;

1.3.5.1
date	97.11.30.16.47.01;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
\Nor  reason given.
@


1.3
log
@[Bug #1728]
__integer becomes __int
@
text
@(*  ==== BASIS EXAMPLES : Queens structure ====
 *
 *  Copyright (C) 1996 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This module demonstrates the use of the Word structure in the basis
 *  library.  It solves the eight queens problem - the problem of determining
 *  how eight queens may be placed on a chessboard such that no queen attacks
 *  another queen.  The solution given here works down the board row by row,
 *  using words to represent the state of the current row.
 *
 *  Revision Log
 *  ------------
 *  $Log: basis:__queens.sml,v $
 *  Revision 1.2  1996/09/04  11:55:34  jont
 *  Make require statements absolute
 *
 *  Revision 1.1  1996/07/26  15:02:04  davids
 *  new unit
 *  No reason given.
 *
 *
 *)


require "queens";

(* This example uses the default Word structure.  The length of word defined
 by this may vary between implementations. *)

require "$.basis.__word";

require "$.basis.__int";

structure Queens : QUEENS =
  struct
    
    (* Extract the nth bit from word w *)

    fun getBit (w, n) = 
      let
        val place = Word.fromInt n
	val mask = Word.<< (0w1, place)
	val b = Word.andb (w, mask)
      in
	Word.>> (b, place)
      end


    (* Set the nth bit in word w *)

    fun setBit (w, n) =
      let
	val mask = Word.<< (0w1, Word.fromInt n)
      in
	Word.orb (w, mask)
      end


    (* Create a string representing a row of the board, placing a queen at the
     position specified by parameter queenPos.  Parameter size specifies the
     length of the row. *)

    fun makeRow (column, queenPos, size) =
      let 
        val letter = if column = queenPos then "Q " else "o "
      in
	if column < size then letter ^ makeRow (column + 1, queenPos, size)
	else "\n"
      end


    (* Create a string representing the board, of dimensions (size x size).
     The positions of the queens are specified in a list of length size. *)

    fun makeBoard (size, []) = "\n"
      | makeBoard (size, h::t) = makeRow (0, h, size) ^ makeBoard (size, t)


    (* For the given row, try placing a queen on all squares of that row which
     are not attacked by queens in any previous rows.  Then recursively call
     placeQueen for the next row.  The function returns the number of 
     solutions found.

     Parameter queens holds the list of positions of queens that have been
     placed.  Parameters vert, ldiag and rdiag are all words representing the
     state of the current row.  If a bit is set then that square is attacked
     by a queen on a previous row.  Each of these parameters represents an
     attack in a different direction. *)

    fun placeQueen (size, row, vert, ldiag, rdiag, queens) =
      let

        fun trySquare column =
	  if column < size then

	    (* If square is not attacked in any direction *)
	    if getBit (vert, column) = 0w0 andalso
	       getBit (ldiag, column) = 0w0 andalso
	       getBit (rdiag, column) = 0w0
	    
	    (* then set bits in vert, ldiag and rdiag representing new queen *)
	    then placeQueen (size, row - 1, setBit (vert, column),
			     Word.<< (setBit (ldiag, column), 0w1),
			     Word.>> (setBit (rdiag, column), 0w1),
			     column::queens) 
	       + trySquare (column + 1)

	    else trySquare (column + 1)
	  else 0
      in
	if row = 0 then (print (makeBoard (size, queens)); 1)	    
	else trySquare 0      
      end


    (* Display all solutions to the n queens problem.  This is a
     generalisation of the eight queens problem, placing n queens on a
     board of size (n x n). *)

    fun nQueens n =
      if n > Word.wordSize then
	print "Board size too large.\n"
      else 
	(print ("Number of solutions: " ^ 
		Int.toString (placeQueen (n, n, 0w0, 0w0, 0w0, [])) ^ "\n"))
	handle Overflow => print ("Too many solutions!")


    (* Display all solutions to the eight queens problem. *)

    fun eightQueens () = nQueens 8
  
  end




@


1.3.5.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a15 4
 *  Revision 1.3  1996/11/06  11:55:27  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.4.1
log
@branched from 1.3
@
text
@a15 4
 *  Revision 1.3  1996/11/06  11:55:27  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.4.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a15 3
 *  Revision 1.3.4.1  1997/05/12  10:24:01  hope
 *  branched from 1.3
 *
@


1.3.4.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a15 3
 *  Revision 1.3.4.1  1997/05/12  10:24:01  hope
 *  branched from 1.3
 *
@


1.3.4.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a15 3
 *  Revision 1.3.4.1  1997/05/12  10:24:01  hope
 *  branched from 1.3
 *
@


1.3.4.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a15 3
 *  Revision 1.3.4.1.1.1  1997/07/28  18:10:04  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.3.3.1
log
@branched from 1.3
@
text
@a15 4
 *  Revision 1.3  1996/11/06  11:55:27  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.3.1.1.1
log
@branched from 1.3.3.1
@
text
@a15 3
 *  Revision 1.3.3.1  1996/12/17  17:39:06  hope
 *  branched from 1.3
 *
@


1.3.2.1
log
@branched from 1.3
@
text
@a15 4
 *  Revision 1.3  1996/11/06  11:55:27  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a15 4
 *  Revision 1.3  1996/11/06  11:55:27  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.1.1.1.1
log
@branched from 1.3.1.1
@
text
@a15 3
 *  Revision 1.3.1.1  1996/11/14  12:39:34  hope
 *  branched from 1.3
 *
@


1.2
log
@Make require statements absolute
@
text
@d16 3
d34 1
a34 1
require "$.basis.__integer";
@


1.2.3.1
log
@branched from 1.2
@
text
@a15 3
 *  Revision 1.2  1996/09/04  11:55:34  jont
 *  Make require statements absolute
 *
@


1.2.2.1
log
@branched from 1.2
@
text
@a15 3
 *  Revision 1.2  1996/09/04  11:55:34  jont
 *  Make require statements absolute
 *
@


1.2.1.1
log
@branched from 1.2
@
text
@a15 3
 *  Revision 1.2  1996/09/04  11:55:34  jont
 *  Make require statements absolute
 *
@


1.1
log
@new unit
\Nor  reason given.
@
text
@d15 5
a19 1
 *  $Log$
d29 1
a29 1
require "basis.__word";
d31 1
a31 1
require "basis.__integer";
@
